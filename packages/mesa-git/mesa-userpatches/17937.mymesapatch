From a35cce47e0815756c201c8ecff960d48d57e4e05 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Sat, 6 Aug 2022 18:05:59 -0400
Subject: [PATCH 01/15] gallium: add struct pipe_vertex_elements to replace
 separate count and elements

cso_cache keeps a copy of pipe_vertex_element[] in a malloc'd structure.
By adding pipe_vertex_element[] at the beginning of the CSO itself,
cso_cache won't have to keep that copy.

This commit changes the CSO from void* to struct pipe_vertex_elements*.
It's the first CSO being represented by its type. The new structure is:

  struct pipe_vertex_elements
  {
     unsigned count;
     struct pipe_vertex_element input[PIPE_MAX_ATTRIBS];
  };

Drivers must put this at the beginning of the CSO, but must not modify
it because it will be used by memcmp for CSO lookups.

This commit is massive, so brace yourself.
---
 src/asahi/compiler/agx_compile.h              |  6 ++
 src/gallium/auxiliary/cso_cache/cso_cache.h   |  9 +-
 src/gallium/auxiliary/cso_cache/cso_context.c | 19 ++--
 src/gallium/auxiliary/cso_cache/cso_context.h |  4 +-
 .../auxiliary/driver_ddebug/dd_context.c      | 60 ++++++-----
 src/gallium/auxiliary/driver_ddebug/dd_draw.c | 16 +--
 src/gallium/auxiliary/driver_ddebug/dd_pipe.h | 11 +--
 .../auxiliary/driver_ddebug/dd_screen.c       |  5 +-
 src/gallium/auxiliary/driver_noop/noop_pipe.c |  5 +-
 .../auxiliary/driver_noop/noop_state.c        | 21 +++-
 .../auxiliary/driver_rbug/rbug_context.c      | 15 ++-
 .../auxiliary/driver_trace/tr_context.c       | 17 ++--
 .../auxiliary/driver_trace/tr_screen.c        |  9 +-
 src/gallium/auxiliary/hud/hud_context.c       |  6 +-
 src/gallium/auxiliary/hud/hud_private.h       |  2 +-
 .../auxiliary/postprocess/pp_private.h        |  2 +-
 .../auxiliary/postprocess/pp_program.c        | 16 +--
 src/gallium/auxiliary/util/u_blitter.c        | 27 ++---
 src/gallium/auxiliary/util/u_blitter.h        |  8 +-
 src/gallium/auxiliary/util/u_helpers.c        | 42 ++++----
 src/gallium/auxiliary/util/u_helpers.h        |  8 +-
 src/gallium/auxiliary/util/u_tests.c          |  6 +-
 .../auxiliary/util/u_threaded_context.c       | 12 +--
 src/gallium/auxiliary/util/u_vbuf.c           | 99 +++++++++----------
 src/gallium/auxiliary/util/u_vbuf.h           |  4 +-
 .../auxiliary/util/u_vertex_state_cache.c     | 11 +--
 .../auxiliary/util/u_vertex_state_cache.h     |  3 +-
 src/gallium/auxiliary/vl/vl_bicubic_filter.c  | 13 +--
 src/gallium/auxiliary/vl/vl_bicubic_filter.h  |  2 +-
 src/gallium/auxiliary/vl/vl_compositor.c      | 32 +++---
 src/gallium/auxiliary/vl/vl_compositor.h      |  2 +-
 src/gallium/auxiliary/vl/vl_deint_filter.c    | 13 +--
 src/gallium/auxiliary/vl/vl_deint_filter.h    |  2 +-
 src/gallium/auxiliary/vl/vl_matrix_filter.c   | 13 +--
 src/gallium/auxiliary/vl/vl_matrix_filter.h   |  2 +-
 src/gallium/auxiliary/vl/vl_median_filter.c   | 13 +--
 src/gallium/auxiliary/vl/vl_median_filter.h   |  2 +-
 src/gallium/auxiliary/vl/vl_vertex_buffers.c  | 34 ++++---
 src/gallium/auxiliary/vl/vl_vertex_buffers.h  |  4 +-
 src/gallium/drivers/asahi/agx_blit.c          |  2 +-
 src/gallium/drivers/asahi/agx_state.c         | 31 +++---
 src/gallium/drivers/asahi/agx_state.h         |  2 +-
 src/gallium/drivers/crocus/crocus_blit.c      |  2 +-
 src/gallium/drivers/crocus/crocus_state.c     | 57 ++++++-----
 src/gallium/drivers/d3d12/d3d12_blit.cpp      |  2 +-
 src/gallium/drivers/d3d12/d3d12_context.cpp   | 31 +++---
 .../drivers/d3d12/d3d12_pipeline_state.h      |  1 +
 .../drivers/etnaviv/etnaviv_clear_blit.c      |  2 +-
 .../drivers/etnaviv/etnaviv_internal.h        |  3 +
 src/gallium/drivers/etnaviv/etnaviv_state.c   | 54 +++++-----
 src/gallium/drivers/freedreno/a2xx/fd2_draw.c | 12 +--
 .../drivers/freedreno/a2xx/fd2_program.c      |  4 +-
 src/gallium/drivers/freedreno/a3xx/fd3_emit.c |  4 +-
 src/gallium/drivers/freedreno/a4xx/fd4_emit.c |  4 +-
 src/gallium/drivers/freedreno/a5xx/fd5_emit.c |  2 +-
 .../drivers/freedreno/a6xx/fd6_context.c      | 23 +++--
 .../drivers/freedreno/a6xx/fd6_context.h      |  2 +-
 .../drivers/freedreno/freedreno_context.c     | 39 ++++----
 .../drivers/freedreno/freedreno_context.h     |  9 +-
 .../drivers/freedreno/freedreno_state.c       | 16 ++-
 src/gallium/drivers/i915/i915_context.h       |  7 +-
 src/gallium/drivers/i915/i915_state.c         | 31 +++---
 src/gallium/drivers/iris/iris_state.c         | 73 +++++++-------
 src/gallium/drivers/lima/lima_context.h       |  7 +-
 src/gallium/drivers/lima/lima_draw.c          | 10 +-
 src/gallium/drivers/lima/lima_state.c         | 18 ++--
 src/gallium/drivers/llvmpipe/lp_context.h     |  3 +-
 src/gallium/drivers/llvmpipe/lp_state.h       |  8 --
 .../drivers/llvmpipe/lp_state_vertex.c        | 26 +++--
 src/gallium/drivers/llvmpipe/lp_surface.c     |  2 +-
 src/gallium/drivers/nouveau/nv30/nv30_draw.c  |  2 +-
 .../drivers/nouveau/nv30/nv30_miptree.c       |  2 +-
 src/gallium/drivers/nouveau/nv30/nv30_state.h |  2 +-
 src/gallium/drivers/nouveau/nv30/nv30_vbo.c   | 32 +++---
 .../drivers/nouveau/nv50/nv50_context.h       |  7 +-
 src/gallium/drivers/nouveau/nv50/nv50_state.c |  4 +-
 .../drivers/nouveau/nv50/nv50_stateobj.h      |  1 +
 src/gallium/drivers/nouveau/nv50/nv50_vbo.c   | 22 ++---
 .../drivers/nouveau/nvc0/nvc0_context.h       |  7 +-
 src/gallium/drivers/nouveau/nvc0/nvc0_state.c |  4 +-
 .../drivers/nouveau/nvc0/nvc0_stateobj.h      |  1 +
 src/gallium/drivers/nouveau/nvc0/nvc0_vbo.c   | 30 +++---
 src/gallium/drivers/panfrost/pan_blit.c       |  2 +-
 src/gallium/drivers/panfrost/pan_cmdstream.c  | 49 +++++----
 src/gallium/drivers/panfrost/pan_context.c    | 12 ++-
 src/gallium/drivers/r300/r300_blit.c          |  2 +-
 src/gallium/drivers/r300/r300_context.h       |  6 +-
 src/gallium/drivers/r300/r300_emit.c          |  4 +-
 src/gallium/drivers/r300/r300_render.c        | 14 +--
 src/gallium/drivers/r300/r300_state.c         | 50 +++++-----
 src/gallium/drivers/r600/r600_asm.c           | 43 ++++----
 src/gallium/drivers/r600/r600_asm.h           |  5 +-
 src/gallium/drivers/r600/r600_pipe.h          |  1 +
 src/gallium/drivers/r600/r600_pipe_common.c   |  2 +-
 src/gallium/drivers/r600/r600_pipe_common.h   |  2 +-
 src/gallium/drivers/r600/r600_state_common.c  |  4 +-
 src/gallium/drivers/radeonsi/si_pipe.c        |  5 +-
 src/gallium/drivers/radeonsi/si_pipe.h        |  2 +-
 src/gallium/drivers/radeonsi/si_state.c       | 64 ++++++------
 src/gallium/drivers/radeonsi/si_state.h       |  2 +
 .../drivers/radeonsi/si_state_draw.cpp        |  3 +-
 src/gallium/drivers/softpipe/sp_context.h     |  3 +-
 src/gallium/drivers/softpipe/sp_state.h       |  5 -
 .../drivers/softpipe/sp_state_vertex.c        | 28 +++---
 src/gallium/drivers/svga/svga_context.h       |  3 +-
 src/gallium/drivers/svga/svga_pipe_blit.c     |  3 +-
 src/gallium/drivers/svga/svga_pipe_clear.c    |  3 +-
 src/gallium/drivers/svga/svga_pipe_vertex.c   | 28 +++---
 src/gallium/drivers/svga/svga_state_vdecl.c   | 10 +-
 src/gallium/drivers/svga/svga_swtnl_state.c   |  4 +-
 src/gallium/drivers/tegra/tegra_context.c     | 10 +-
 src/gallium/drivers/v3d/v3d_blit.c            |  2 +-
 src/gallium/drivers/v3d/v3d_context.h         |  4 +-
 src/gallium/drivers/v3d/v3d_program.c         |  4 +-
 src/gallium/drivers/v3d/v3dx_draw.c           | 10 +-
 src/gallium/drivers/v3d/v3dx_state.c          | 27 +++--
 src/gallium/drivers/vc4/vc4_context.h         |  7 +-
 src/gallium/drivers/vc4/vc4_draw.c            | 12 +--
 src/gallium/drivers/vc4/vc4_program.c         |  2 +-
 src/gallium/drivers/vc4/vc4_state.c           | 22 +++--
 src/gallium/drivers/virgl/virgl_context.c     | 35 ++++---
 src/gallium/drivers/zink/zink_blit.c          |  2 +-
 src/gallium/drivers/zink/zink_state.c         | 38 +++----
 src/gallium/drivers/zink/zink_state.h         |  6 +-
 src/gallium/drivers/zink/zink_types.h         |  1 +
 .../frontends/d3d10umd/InputAssembly.cpp      |  8 +-
 src/gallium/frontends/d3d10umd/State.h        |  2 +-
 src/gallium/frontends/lavapipe/lvp_execute.c  | 26 ++---
 src/gallium/frontends/nine/nine_state.c       | 36 +++----
 src/gallium/frontends/xa/xa_renderer.c        |  8 +-
 src/gallium/include/pipe/p_context.h          | 14 +--
 src/gallium/include/pipe/p_screen.h           |  5 +-
 src/gallium/include/pipe/p_state.h            | 13 ++-
 src/gallium/tests/graw/fs-fragcoord.c         | 38 +------
 src/gallium/tests/graw/fs-frontface.c         | 39 +-------
 src/gallium/tests/graw/fs-test.c              | 21 ++--
 src/gallium/tests/graw/fs-write-z.c           | 40 +-------
 src/gallium/tests/graw/graw_util.h            | 34 +++++++
 src/gallium/tests/graw/gs-test.c              | 25 ++---
 src/gallium/tests/graw/occlusion-query.c      | 40 +-------
 src/gallium/tests/graw/quad-sample.c          | 37 +------
 src/gallium/tests/graw/quad-tex.c             | 22 ++---
 src/gallium/tests/graw/shader-leak.c          | 37 +------
 src/gallium/tests/graw/tex-srgb.c             | 41 +-------
 src/gallium/tests/graw/tex-swizzle.c          | 37 +------
 src/gallium/tests/graw/tri-gs.c               | 37 +------
 src/gallium/tests/graw/tri-instanced.c        | 36 +++----
 src/gallium/tests/graw/tri-large.c            | 22 ++---
 src/gallium/tests/graw/tri.c                  | 37 +------
 src/gallium/tests/graw/vs-test.c              | 23 ++---
 src/gallium/tests/trivial/quad-tex.c          | 18 ++--
 src/gallium/tests/trivial/tri.c               | 18 ++--
 src/mesa/state_tracker/st_atom.h              |  6 +-
 src/mesa/state_tracker/st_atom_array.cpp      | 23 +++--
 src/mesa/state_tracker/st_cb_drawtex.c        | 12 +--
 src/mesa/state_tracker/st_context.c           | 18 ++--
 src/mesa/state_tracker/st_context.h           |  2 +-
 src/mesa/state_tracker/st_draw_feedback.c     |  4 +-
 src/mesa/state_tracker/st_pbo.c               | 12 +--
 src/util/indices/u_primconvert.c              |  3 +-
 160 files changed, 1090 insertions(+), 1421 deletions(-)

diff --git a/src/asahi/compiler/agx_compile.h b/src/asahi/compiler/agx_compile.h
index c42dbd709188..e2d899b53dad 100644
--- a/src/asahi/compiler/agx_compile.h
+++ b/src/asahi/compiler/agx_compile.h
@@ -27,6 +27,7 @@
 #include "compiler/nir/nir.h"
 #include "util/u_dynarray.h"
 #include "asahi/lib/agx_pack.h"
+#include "pipe/p_state.h"
 
 enum agx_push_type {
    /* Array of 64-bit pointers to the base addresses (BASES) and array of
@@ -231,6 +232,11 @@ struct agx_attribute {
    unsigned padding : 5;
 };
 
+struct agx_vertex_elements {
+   struct pipe_vertex_elements base; /* don't change, it's used by memcmp for CSO lookups */
+   struct agx_attribute attributes[AGX_MAX_ATTRIBS];
+};
+
 struct agx_vs_shader_key {
    unsigned num_vbufs;
    unsigned vbuf_strides[AGX_MAX_VBUFS];
diff --git a/src/gallium/auxiliary/cso_cache/cso_cache.h b/src/gallium/auxiliary/cso_cache/cso_cache.h
index 3e9b05ce21af..14d19a670e61 100644
--- a/src/gallium/auxiliary/cso_cache/cso_cache.h
+++ b/src/gallium/auxiliary/cso_cache/cso_cache.h
@@ -136,14 +136,9 @@ struct cso_sampler {
    unsigned hash_key;
 };
 
-struct cso_velems_state {
-   unsigned count;
-   struct pipe_vertex_element velems[PIPE_MAX_ATTRIBS];
-};
-
 struct cso_velements {
-   struct cso_velems_state state;
-   void *data;
+   struct pipe_vertex_elements state;
+   struct pipe_vertex_elements *data;
 };
 
 void cso_cache_init(struct cso_cache *sc, struct pipe_context *pipe);
diff --git a/src/gallium/auxiliary/cso_cache/cso_context.c b/src/gallium/auxiliary/cso_cache/cso_context.c
index b09643dcd8a3..2520e3c24f53 100644
--- a/src/gallium/auxiliary/cso_cache/cso_context.c
+++ b/src/gallium/auxiliary/cso_cache/cso_context.c
@@ -107,7 +107,7 @@ struct cso_context {
    void *tessctrl_shader, *tessctrl_shader_saved;
    void *tesseval_shader, *tesseval_shader_saved;
    void *compute_shader, *compute_shader_saved;
-   void *velements, *velements_saved;
+   struct pipe_vertex_elements *velements, *velements_saved;
    struct pipe_query *render_condition, *render_condition_saved;
    uint render_condition_mode, render_condition_mode_saved;
    boolean render_condition_cond, render_condition_cond_saved;
@@ -1027,11 +1027,11 @@ cso_restore_compute_samplers(struct cso_context *ctx)
 
 static void
 cso_set_vertex_elements_direct(struct cso_context *ctx,
-                               const struct cso_velems_state *velems)
+                               const struct pipe_vertex_elements *velems)
 {
    unsigned key_size, hash_key;
    struct cso_hash_iter iter;
-   void *handle;
+   struct pipe_vertex_elements *handle;
 
    /* Need to include the count into the stored state data too.
     * Otherwise first few count pipe_vertex_elements could be identical
@@ -1052,13 +1052,10 @@ cso_set_vertex_elements_direct(struct cso_context *ctx,
       memcpy(&cso->state, velems, key_size);
 
       /* Lower 64-bit vertex attributes. */
-      unsigned new_count = velems->count;
-      const struct pipe_vertex_element *new_elems = velems->velems;
-      struct pipe_vertex_element tmp[PIPE_MAX_ATTRIBS];
-      util_lower_uint64_vertex_elements(&new_elems, &new_count, tmp);
+      struct pipe_vertex_elements tmp;
+      util_lower_uint64_vertex_elements(&velems, &tmp);
 
-      cso->data = ctx->pipe->create_vertex_elements_state(ctx->pipe, new_count,
-                                                          new_elems);
+      cso->data = ctx->pipe->create_vertex_elements_state(ctx->pipe, velems);
 
       iter = cso_insert_state(&ctx->cache, hash_key, CSO_VELEMENTS, cso);
       if (cso_hash_iter_is_null(iter)) {
@@ -1080,7 +1077,7 @@ cso_set_vertex_elements_direct(struct cso_context *ctx,
 
 enum pipe_error
 cso_set_vertex_elements(struct cso_context *ctx,
-                        const struct cso_velems_state *velems)
+                        const struct pipe_vertex_elements *velems)
 {
    struct u_vbuf *vbuf = ctx->vbuf_current;
 
@@ -1162,7 +1159,7 @@ void cso_set_vertex_buffers(struct cso_context *ctx,
  */
 void
 cso_set_vertex_buffers_and_elements(struct cso_context *ctx,
-                                    const struct cso_velems_state *velems,
+                                    const struct pipe_vertex_elements *velems,
                                     unsigned vb_count,
                                     unsigned unbind_trailing_vb_count,
                                     bool take_ownership,
diff --git a/src/gallium/auxiliary/cso_cache/cso_context.h b/src/gallium/auxiliary/cso_cache/cso_context.h
index 3c5b60642097..281c03ce453a 100644
--- a/src/gallium/auxiliary/cso_cache/cso_context.h
+++ b/src/gallium/auxiliary/cso_cache/cso_context.h
@@ -86,7 +86,7 @@ cso_single_sampler_done(struct cso_context *cso,
 
 
 enum pipe_error cso_set_vertex_elements(struct cso_context *ctx,
-                                        const struct cso_velems_state *velems);
+                                        const struct pipe_vertex_elements *velems);
 
 void cso_set_vertex_buffers(struct cso_context *ctx,
                             unsigned start_slot, unsigned count,
@@ -184,7 +184,7 @@ void cso_restore_compute_state(struct cso_context *cso);
 /* Optimized version. */
 void
 cso_set_vertex_buffers_and_elements(struct cso_context *ctx,
-                                    const struct cso_velems_state *velems,
+                                    const struct pipe_vertex_elements *velems,
                                     unsigned vb_count,
                                     unsigned unbind_trailing_vb_count,
                                     bool take_ownership,
diff --git a/src/gallium/auxiliary/driver_ddebug/dd_context.c b/src/gallium/auxiliary/driver_ddebug/dd_context.c
index cddea36367dd..3ff7f963f0e2 100644
--- a/src/gallium/auxiliary/driver_ddebug/dd_context.c
+++ b/src/gallium/auxiliary/driver_ddebug/dd_context.c
@@ -162,56 +162,56 @@ dd_context_render_condition(struct pipe_context *_pipe,
  * constant (immutable) non-shader states
  */
 
-#define DD_CSO_CREATE(name, shortname) \
-   static void * \
-   dd_context_create_##name##_state(struct pipe_context *_pipe, \
-                                    const struct pipe_##name##_state *state) \
+#define DD_CSO_CREATE(name, shortname, type) \
+   static type * \
+   dd_context_create_##name(struct pipe_context *_pipe, \
+                                    const struct pipe_##name *state) \
    { \
       struct pipe_context *pipe = dd_context(_pipe)->pipe; \
       struct dd_state *hstate = CALLOC_STRUCT(dd_state); \
  \
       if (!hstate) \
          return NULL; \
-      hstate->cso = pipe->create_##name##_state(pipe, state); \
+      hstate->cso = pipe->create_##name(pipe, state); \
       hstate->state.shortname = *state; \
       return hstate; \
    }
 
-#define DD_CSO_BIND(name, shortname) \
+#define DD_CSO_BIND(name, shortname, type) \
    static void \
-   dd_context_bind_##name##_state(struct pipe_context *_pipe, void *state) \
+   dd_context_bind_##name(struct pipe_context *_pipe, type *state) \
    { \
       struct dd_context *dctx = dd_context(_pipe); \
       struct pipe_context *pipe = dctx->pipe; \
-      struct dd_state *hstate = state; \
+      struct dd_state *hstate = (struct dd_state*)state; \
  \
       dctx->draw_state.shortname = hstate; \
-      pipe->bind_##name##_state(pipe, hstate ? hstate->cso : NULL); \
+      pipe->bind_##name(pipe, hstate ? hstate->cso : NULL); \
    }
 
-#define DD_CSO_DELETE(name) \
+#define DD_CSO_DELETE(name, type) \
    static void \
-   dd_context_delete_##name##_state(struct pipe_context *_pipe, void *state) \
+   dd_context_delete_##name(struct pipe_context *_pipe, type *state) \
    { \
       struct dd_context *dctx = dd_context(_pipe); \
       struct pipe_context *pipe = dctx->pipe; \
-      struct dd_state *hstate = state; \
+      struct dd_state *hstate = (struct dd_state*)state; \
  \
-      pipe->delete_##name##_state(pipe, hstate->cso); \
+      pipe->delete_##name(pipe, hstate->cso); \
       FREE(hstate); \
    }
 
-#define DD_CSO_WHOLE(name, shortname) \
-   DD_CSO_CREATE(name, shortname) \
-   DD_CSO_BIND(name, shortname) \
-   DD_CSO_DELETE(name)
+#define DD_CSO_WHOLE(name, shortname, type) \
+   DD_CSO_CREATE(name, shortname, type) \
+   DD_CSO_BIND(name, shortname, type) \
+   DD_CSO_DELETE(name, type)
 
-DD_CSO_WHOLE(blend, blend)
-DD_CSO_WHOLE(rasterizer, rs)
-DD_CSO_WHOLE(depth_stencil_alpha, dsa)
+DD_CSO_WHOLE(blend_state, blend, void)
+DD_CSO_WHOLE(rasterizer_state, rs, void)
+DD_CSO_WHOLE(depth_stencil_alpha_state, dsa, void)
 
-DD_CSO_CREATE(sampler, sampler)
-DD_CSO_DELETE(sampler)
+DD_CSO_CREATE(sampler_state, sampler, void)
+DD_CSO_DELETE(sampler_state, void)
 
 static void
 dd_context_bind_sampler_states(struct pipe_context *_pipe,
@@ -239,24 +239,22 @@ dd_context_bind_sampler_states(struct pipe_context *_pipe,
       pipe->bind_sampler_states(pipe, shader, start, count, NULL);
 }
 
-static void *
+static struct pipe_vertex_elements *
 dd_context_create_vertex_elements_state(struct pipe_context *_pipe,
-                                        unsigned num_elems,
-                                        const struct pipe_vertex_element *elems)
+                                        const struct pipe_vertex_elements *ve)
 {
    struct pipe_context *pipe = dd_context(_pipe)->pipe;
    struct dd_state *hstate = CALLOC_STRUCT(dd_state);
 
    if (!hstate)
       return NULL;
-   hstate->cso = pipe->create_vertex_elements_state(pipe, num_elems, elems);
-   memcpy(hstate->state.velems.velems, elems, sizeof(elems[0]) * num_elems);
-   hstate->state.velems.count = num_elems;
-   return hstate;
+   hstate->cso = pipe->create_vertex_elements_state(pipe, ve);
+   memcpy(&hstate->state.ve, ve, sizeof(*ve));
+   return &hstate->state.ve;
 }
 
-DD_CSO_BIND(vertex_elements, velems)
-DD_CSO_DELETE(vertex_elements)
+DD_CSO_BIND(vertex_elements_state, ve, struct pipe_vertex_elements)
+DD_CSO_DELETE(vertex_elements_state, struct pipe_vertex_elements)
 
 
 /********************************************************************
diff --git a/src/gallium/auxiliary/driver_ddebug/dd_draw.c b/src/gallium/auxiliary/driver_ddebug/dd_draw.c
index 6dd4a12fa7e4..c8e2b0c31d99 100644
--- a/src/gallium/auxiliary/driver_ddebug/dd_draw.c
+++ b/src/gallium/auxiliary/driver_ddebug/dd_draw.c
@@ -383,12 +383,12 @@ dd_dump_draw_vbo(struct dd_draw_state *dstate, struct pipe_draw_info *info,
             DUMP_M(resource, &dstate->vertex_buffers[i], buffer.resource);
       }
 
-   if (dstate->velems) {
+   if (dstate->ve) {
       PRINT_NAMED(uint, "num vertex elements",
-                        dstate->velems->state.velems.count);
-      for (i = 0; i < dstate->velems->state.velems.count; i++) {
+                        dstate->ve->state.ve.count);
+      for (i = 0; i < dstate->ve->state.ve.count; i++) {
          fprintf(f, "  ");
-         DUMP_I(vertex_element, &dstate->velems->state.velems.velems[i], i);
+         DUMP_I(vertex_element, &dstate->ve->state.ve.input[i], i);
       }
    }
 
@@ -804,7 +804,7 @@ dd_init_copy_of_draw_state(struct dd_draw_state_copy *state)
          state->base.sampler_states[i][j] = &state->sampler_states[i][j];
    }
 
-   state->base.velems = &state->velems;
+   state->base.ve = &state->velems;
    state->base.rs = &state->rs;
    state->base.dsa = &state->dsa;
    state->base.blend = &state->blend;
@@ -911,10 +911,10 @@ dd_copy_draw_state(struct dd_draw_state *dst, struct dd_draw_state *src)
       }
    }
 
-   if (src->velems)
-      dst->velems->state.velems = src->velems->state.velems;
+   if (src->ve)
+      dst->ve->state.ve = src->ve->state.ve;
    else
-      dst->velems = NULL;
+      dst->ve = NULL;
 
    if (src->rs)
       dst->rs->state.rs = src->rs->state.rs;
diff --git a/src/gallium/auxiliary/driver_ddebug/dd_pipe.h b/src/gallium/auxiliary/driver_ddebug/dd_pipe.h
index b880a8045368..8c962ae3ad2b 100644
--- a/src/gallium/auxiliary/driver_ddebug/dd_pipe.h
+++ b/src/gallium/auxiliary/driver_ddebug/dd_pipe.h
@@ -204,19 +204,16 @@ struct dd_query
 
 struct dd_state
 {
-   void *cso;
-
    union {
       struct pipe_blend_state blend;
       struct pipe_depth_stencil_alpha_state dsa;
       struct pipe_rasterizer_state rs;
       struct pipe_sampler_state sampler;
-      struct {
-         struct pipe_vertex_element velems[PIPE_MAX_ATTRIBS];
-         unsigned count;
-      } velems;
+      struct pipe_vertex_elements ve;
       struct pipe_shader_state shader;
    } state;
+
+   void *cso;
 };
 
 struct dd_draw_state
@@ -240,7 +237,7 @@ struct dd_draw_state
    struct pipe_image_view shader_images[PIPE_SHADER_TYPES][PIPE_MAX_SHADER_IMAGES];
    struct pipe_shader_buffer shader_buffers[PIPE_SHADER_TYPES][PIPE_MAX_SHADER_BUFFERS];
 
-   struct dd_state *velems;
+   struct dd_state *ve;
    struct dd_state *rs;
    struct dd_state *dsa;
    struct dd_state *blend;
diff --git a/src/gallium/auxiliary/driver_ddebug/dd_screen.c b/src/gallium/auxiliary/driver_ddebug/dd_screen.c
index a4e56da95ac8..91765c3ac3cf 100644
--- a/src/gallium/auxiliary/driver_ddebug/dd_screen.c
+++ b/src/gallium/auxiliary/driver_ddebug/dd_screen.c
@@ -408,14 +408,13 @@ dd_screen_fence_get_fd(struct pipe_screen *_screen,
 static struct pipe_vertex_state *
 dd_screen_create_vertex_state(struct pipe_screen *_screen,
                               struct pipe_vertex_buffer *buffer,
-                              const struct pipe_vertex_element *elements,
-                              unsigned num_elements,
+                              const struct pipe_vertex_elements *ve,
                               struct pipe_resource *indexbuf,
                               uint32_t full_velem_mask)
 {
    struct pipe_screen *screen = dd_screen(_screen)->screen;
    struct pipe_vertex_state *state =
-      screen->create_vertex_state(screen, buffer, elements, num_elements,
+      screen->create_vertex_state(screen, buffer, ve,
                                   indexbuf, full_velem_mask);
 
    if (!state)
diff --git a/src/gallium/auxiliary/driver_noop/noop_pipe.c b/src/gallium/auxiliary/driver_noop/noop_pipe.c
index b6e1306579e4..34fbf3eb3c0c 100644
--- a/src/gallium/auxiliary/driver_noop/noop_pipe.c
+++ b/src/gallium/auxiliary/driver_noop/noop_pipe.c
@@ -720,8 +720,7 @@ static void noop_query_dmabuf_modifiers(struct pipe_screen *screen,
 static struct pipe_vertex_state *
 noop_create_vertex_state(struct pipe_screen *screen,
                          struct pipe_vertex_buffer *buffer,
-                         const struct pipe_vertex_element *elements,
-                         unsigned num_elements,
+                         const struct pipe_vertex_elements *ve,
                          struct pipe_resource *indexbuf,
                          uint32_t full_velem_mask)
 {
@@ -730,7 +729,7 @@ noop_create_vertex_state(struct pipe_screen *screen,
    if (!state)
       return NULL;
 
-   util_init_pipe_vertex_state(screen, buffer, elements, num_elements, indexbuf,
+   util_init_pipe_vertex_state(screen, buffer, ve, indexbuf,
                                full_velem_mask, state);
    return state;
 }
diff --git a/src/gallium/auxiliary/driver_noop/noop_state.c b/src/gallium/auxiliary/driver_noop/noop_state.c
index 74069401b85a..bf6431723138 100644
--- a/src/gallium/auxiliary/driver_noop/noop_state.c
+++ b/src/gallium/auxiliary/driver_noop/noop_state.c
@@ -221,13 +221,24 @@ static void noop_set_vertex_buffers(struct pipe_context *ctx,
 {
 }
 
-static void *noop_create_vertex_elements(struct pipe_context *ctx,
-                                         unsigned count,
-                                         const struct pipe_vertex_element *state)
+static struct pipe_vertex_elements *
+noop_create_vertex_elements(struct pipe_context *ctx,
+                            const struct pipe_vertex_elements *ve)
 {
    return MALLOC(1);
 }
 
+static void noop_bind_vertex_elements(struct pipe_context *ctx,
+                                      struct pipe_vertex_elements *state)
+{
+}
+
+static void noop_delete_vertex_elements(struct pipe_context *ctx,
+                                        struct pipe_vertex_elements *state)
+{
+   FREE(state);
+}
+
 static void *noop_create_shader_state(struct pipe_context *ctx,
                                       const struct pipe_shader_state *state)
 {
@@ -433,7 +444,7 @@ void noop_init_state_functions(struct pipe_context *ctx)
    ctx->bind_sampler_states = noop_bind_sampler_states;
    ctx->bind_fs_state = noop_bind_state;
    ctx->bind_rasterizer_state = noop_bind_state;
-   ctx->bind_vertex_elements_state = noop_bind_state;
+   ctx->bind_vertex_elements_state = noop_bind_vertex_elements;
    ctx->bind_compute_state = noop_bind_state;
    ctx->bind_tcs_state = noop_bind_state;
    ctx->bind_tes_state = noop_bind_state;
@@ -444,7 +455,7 @@ void noop_init_state_functions(struct pipe_context *ctx)
    ctx->delete_fs_state = noop_delete_state;
    ctx->delete_rasterizer_state = noop_delete_state;
    ctx->delete_sampler_state = noop_delete_state;
-   ctx->delete_vertex_elements_state = noop_delete_state;
+   ctx->delete_vertex_elements_state = noop_delete_vertex_elements;
    ctx->delete_compute_state = noop_delete_state;
    ctx->delete_tcs_state = noop_delete_state;
    ctx->delete_tes_state = noop_delete_state;
diff --git a/src/gallium/auxiliary/driver_rbug/rbug_context.c b/src/gallium/auxiliary/driver_rbug/rbug_context.c
index 46d78ad729eb..08a6f6367d88 100644
--- a/src/gallium/auxiliary/driver_rbug/rbug_context.c
+++ b/src/gallium/auxiliary/driver_rbug/rbug_context.c
@@ -546,19 +546,16 @@ rbug_delete_gs_state(struct pipe_context *_pipe,
    mtx_unlock(&rb_pipe->call_mutex);
 }
 
-static void *
+static struct pipe_vertex_elements *
 rbug_create_vertex_elements_state(struct pipe_context *_pipe,
-                                  unsigned num_elements,
-                                  const struct pipe_vertex_element *vertex_elements)
+                                  const struct pipe_vertex_elements *ve)
 {
    struct rbug_context *rb_pipe = rbug_context(_pipe);
    struct pipe_context *pipe = rb_pipe->pipe;
-   void *ret;
+   struct pipe_vertex_elements *ret;
 
    mtx_lock(&rb_pipe->call_mutex);
-   ret = pipe->create_vertex_elements_state(pipe,
-                                             num_elements,
-                                             vertex_elements);
+   ret = pipe->create_vertex_elements_state(pipe, ve);
    mtx_unlock(&rb_pipe->call_mutex);
 
    return ret;
@@ -566,7 +563,7 @@ rbug_create_vertex_elements_state(struct pipe_context *_pipe,
 
 static void
 rbug_bind_vertex_elements_state(struct pipe_context *_pipe,
-                                void *velems)
+                                struct pipe_vertex_elements *velems)
 {
    struct rbug_context *rb_pipe = rbug_context(_pipe);
    struct pipe_context *pipe = rb_pipe->pipe;
@@ -579,7 +576,7 @@ rbug_bind_vertex_elements_state(struct pipe_context *_pipe,
 
 static void
 rbug_delete_vertex_elements_state(struct pipe_context *_pipe,
-                                  void *velems)
+                                  struct pipe_vertex_elements *velems)
 {
    struct rbug_context *rb_pipe = rbug_context(_pipe);
    struct pipe_context *pipe = rb_pipe->pipe;
diff --git a/src/gallium/auxiliary/driver_trace/tr_context.c b/src/gallium/auxiliary/driver_trace/tr_context.c
index b32a1ec30f1b..2215acd25707 100644
--- a/src/gallium/auxiliary/driver_trace/tr_context.c
+++ b/src/gallium/auxiliary/driver_trace/tr_context.c
@@ -789,25 +789,24 @@ trace_context_delete_compute_state(struct pipe_context *_pipe,
    trace_dump_call_end();
 }
 
-static void *
+static struct pipe_vertex_elements *
 trace_context_create_vertex_elements_state(struct pipe_context *_pipe,
-                                           unsigned num_elements,
-                                           const struct  pipe_vertex_element *elements)
+                                           const struct pipe_vertex_elements *ve)
 {
    struct trace_context *tr_ctx = trace_context(_pipe);
    struct pipe_context *pipe = tr_ctx->pipe;
-   void * result;
+   struct pipe_vertex_elements *result;
 
    trace_dump_call_begin("pipe_context", "create_vertex_elements_state");
 
    trace_dump_arg(ptr, pipe);
-   trace_dump_arg(uint, num_elements);
+   trace_dump_arg(uint, ve->count);
 
    trace_dump_arg_begin("elements");
-   trace_dump_struct_array(vertex_element, elements, num_elements);
+   trace_dump_struct_array(vertex_element, ve->input, ve->count);
    trace_dump_arg_end();
 
-   result = pipe->create_vertex_elements_state(pipe, num_elements, elements);
+   result = pipe->create_vertex_elements_state(pipe, ve);
 
    trace_dump_ret(ptr, result);
 
@@ -819,7 +818,7 @@ trace_context_create_vertex_elements_state(struct pipe_context *_pipe,
 
 static void
 trace_context_bind_vertex_elements_state(struct pipe_context *_pipe,
-                                         void *state)
+                                         struct pipe_vertex_elements *state)
 {
    struct trace_context *tr_ctx = trace_context(_pipe);
    struct pipe_context *pipe = tr_ctx->pipe;
@@ -837,7 +836,7 @@ trace_context_bind_vertex_elements_state(struct pipe_context *_pipe,
 
 static void
 trace_context_delete_vertex_elements_state(struct pipe_context *_pipe,
-                                           void *state)
+                                           struct pipe_vertex_elements *state)
 {
    struct trace_context *tr_ctx = trace_context(_pipe);
    struct pipe_context *pipe = tr_ctx->pipe;
diff --git a/src/gallium/auxiliary/driver_trace/tr_screen.c b/src/gallium/auxiliary/driver_trace/tr_screen.c
index d964b42b0adc..f79b02f812a4 100644
--- a/src/gallium/auxiliary/driver_trace/tr_screen.c
+++ b/src/gallium/auxiliary/driver_trace/tr_screen.c
@@ -1290,8 +1290,7 @@ trace_screen_get_sparse_texture_virtual_page_size(struct pipe_screen *_screen,
 static struct pipe_vertex_state *
 trace_screen_create_vertex_state(struct pipe_screen *_screen,
                                  struct pipe_vertex_buffer *buffer,
-                                 const struct pipe_vertex_element *elements,
-                                 unsigned num_elements,
+                                 const struct pipe_vertex_elements *ve,
                                  struct pipe_resource *indexbuf,
                                  uint32_t full_velem_mask)
 {
@@ -1304,14 +1303,14 @@ trace_screen_create_vertex_state(struct pipe_screen *_screen,
    trace_dump_arg(ptr, buffer->buffer.resource);
    trace_dump_arg(vertex_buffer, buffer);
    trace_dump_arg_begin("elements");
-   trace_dump_struct_array(vertex_element, elements, num_elements);
+   trace_dump_struct_array(vertex_element, ve->input, ve->count);
    trace_dump_arg_end();
-   trace_dump_arg(uint, num_elements);
+   trace_dump_arg(uint, ve->count);
    trace_dump_arg(ptr, indexbuf);
    trace_dump_arg(uint, full_velem_mask);
 
    struct pipe_vertex_state *vstate =
-      screen->create_vertex_state(screen, buffer, elements, num_elements,
+      screen->create_vertex_state(screen, buffer, ve,
                                   indexbuf, full_velem_mask);
    trace_dump_ret(ptr, vstate);
    trace_dump_call_end();
diff --git a/src/gallium/auxiliary/hud/hud_context.c b/src/gallium/auxiliary/hud/hud_context.c
index 75a0a80982d2..a598676383fc 100644
--- a/src/gallium/auxiliary/hud/hud_context.c
+++ b/src/gallium/auxiliary/hud/hud_context.c
@@ -1927,9 +1927,9 @@ hud_create(struct cso_context *cso, struct st_context_iface *st,
    /* vertex elements */
    hud->velems.count = 2;
    for (i = 0; i < 2; i++) {
-      hud->velems.velems[i].src_offset = i * 2 * sizeof(float);
-      hud->velems.velems[i].src_format = PIPE_FORMAT_R32G32_FLOAT;
-      hud->velems.velems[i].vertex_buffer_index = 0;
+      hud->velems.input[i].src_offset = i * 2 * sizeof(float);
+      hud->velems.input[i].src_format = PIPE_FORMAT_R32G32_FLOAT;
+      hud->velems.input[i].vertex_buffer_index = 0;
    }
 
    /* sampler state (for font drawing) */
diff --git a/src/gallium/auxiliary/hud/hud_private.h b/src/gallium/auxiliary/hud/hud_private.h
index b8ee49532e28..a93a1fb2410b 100644
--- a/src/gallium/auxiliary/hud/hud_private.h
+++ b/src/gallium/auxiliary/hud/hud_private.h
@@ -63,7 +63,7 @@ struct hud_context {
    void *fs_color, *fs_text;
    struct pipe_rasterizer_state rasterizer, rasterizer_aa_lines;
    void *vs_color, *vs_text;
-   struct cso_velems_state velems;
+   struct pipe_vertex_elements velems;
 
    /* font */
    struct util_font font;
diff --git a/src/gallium/auxiliary/postprocess/pp_private.h b/src/gallium/auxiliary/postprocess/pp_private.h
index 922b93c7ec7e..d351230037f6 100644
--- a/src/gallium/auxiliary/postprocess/pp_private.h
+++ b/src/gallium/auxiliary/postprocess/pp_private.h
@@ -50,7 +50,7 @@ struct pp_program
    struct pipe_sampler_state sampler_point;     /* point */
    struct pipe_viewport_state viewport;
    struct pipe_framebuffer_state framebuffer;
-   struct cso_velems_state velem;
+   struct pipe_vertex_elements velem;
 
    union pipe_color_union clear_color;
 
diff --git a/src/gallium/auxiliary/postprocess/pp_program.c b/src/gallium/auxiliary/postprocess/pp_program.c
index 258133bb3c54..97f037d8a452 100644
--- a/src/gallium/auxiliary/postprocess/pp_program.c
+++ b/src/gallium/auxiliary/postprocess/pp_program.c
@@ -111,14 +111,14 @@ pp_init_prog(struct pp_queue_t *ppq, struct pipe_context *pipe,
    p->sampler_point.normalized_coords = 1;
 
    p->velem.count = 2;
-   p->velem.velems[0].src_offset = 0;
-   p->velem.velems[0].instance_divisor = 0;
-   p->velem.velems[0].vertex_buffer_index = 0;
-   p->velem.velems[0].src_format = PIPE_FORMAT_R32G32B32A32_FLOAT;
-   p->velem.velems[1].src_offset = 1 * 4 * sizeof(float);
-   p->velem.velems[1].instance_divisor = 0;
-   p->velem.velems[1].vertex_buffer_index = 0;
-   p->velem.velems[1].src_format = PIPE_FORMAT_R32G32B32A32_FLOAT;
+   p->velem.input[0].src_offset = 0;
+   p->velem.input[0].instance_divisor = 0;
+   p->velem.input[0].vertex_buffer_index = 0;
+   p->velem.input[0].src_format = PIPE_FORMAT_R32G32B32A32_FLOAT;
+   p->velem.input[1].src_offset = 1 * 4 * sizeof(float);
+   p->velem.input[1].instance_divisor = 0;
+   p->velem.input[1].vertex_buffer_index = 0;
+   p->velem.input[1].src_format = PIPE_FORMAT_R32G32B32A32_FLOAT;
 
    if (!p->screen->is_format_supported(p->screen,
                                        PIPE_FORMAT_R32G32B32A32_FLOAT,
diff --git a/src/gallium/auxiliary/util/u_blitter.c b/src/gallium/auxiliary/util/u_blitter.c
index 0daa5b77e099..6c53075355a7 100644
--- a/src/gallium/auxiliary/util/u_blitter.c
+++ b/src/gallium/auxiliary/util/u_blitter.c
@@ -122,8 +122,8 @@ struct blitter_context_priv
    void *dsa_replicate_stencil_bit[8];
 
    /* Vertex elements states. */
-   void *velem_state;
-   void *velem_state_readbuf[4]; /**< X, XY, XYZ, XYZW */
+   struct pipe_vertex_elements *velem_state;
+   struct pipe_vertex_elements *velem_state_readbuf[4]; /**< X, XY, XYZ, XYZW */
 
    /* Sampler state. */
    void *sampler_state;
@@ -318,13 +318,15 @@ struct blitter_context *util_blitter_create(struct pipe_context *pipe)
    ctx->base.vb_slot = 0; /* 0 for now */
 
    /* vertex elements states */
-   memset(&velem[0], 0, sizeof(velem[0]) * 2);
+   struct pipe_vertex_elements ve;
+   ve.count = 2;
+   memset(&ve.input[0], 0, sizeof(velem[0]) * 2);
    for (i = 0; i < 2; i++) {
-      velem[i].src_offset = i * 4 * sizeof(float);
-      velem[i].src_format = PIPE_FORMAT_R32G32B32A32_FLOAT;
-      velem[i].vertex_buffer_index = ctx->base.vb_slot;
+      ve.input[i].src_offset = i * 4 * sizeof(float);
+      ve.input[i].src_format = PIPE_FORMAT_R32G32B32A32_FLOAT;
+      ve.input[i].vertex_buffer_index = ctx->base.vb_slot;
    }
-   ctx->velem_state = pipe->create_vertex_elements_state(pipe, 2, &velem[0]);
+   ctx->velem_state = pipe->create_vertex_elements_state(pipe, &ve);
 
    if (ctx->has_stream_out) {
       static enum pipe_format formats[4] = {
@@ -335,10 +337,11 @@ struct blitter_context *util_blitter_create(struct pipe_context *pipe)
       };
 
       for (i = 0; i < 4; i++) {
-         velem[0].src_format = formats[i];
-         velem[0].vertex_buffer_index = ctx->base.vb_slot;
+         ve.count = 1;
+         ve.input[0].src_format = formats[i];
+         ve.input[0].vertex_buffer_index = ctx->base.vb_slot;
          ctx->velem_state_readbuf[i] =
-               pipe->create_vertex_elements_state(pipe, 1, &velem[0]);
+               pipe->create_vertex_elements_state(pipe, &ve);
       }
    }
 
@@ -1394,7 +1397,7 @@ static void blitter_set_common_draw_rect_state(struct blitter_context_priv *ctx,
 }
 
 static void blitter_draw(struct blitter_context_priv *ctx,
-                         void *vertex_elements_cso,
+                         struct pipe_vertex_elements *vertex_elements_cso,
                          blitter_get_vs_func get_vs,
                          int x1, int y1, int x2, int y2, float depth,
                          unsigned num_instances)
@@ -1433,7 +1436,7 @@ static void blitter_draw(struct blitter_context_priv *ctx,
 }
 
 void util_blitter_draw_rectangle(struct blitter_context *blitter,
-                                 void *vertex_elements_cso,
+                                 struct pipe_vertex_elements *vertex_elements_cso,
                                  blitter_get_vs_func get_vs,
                                  int x1, int y1, int x2, int y2,
                                  float depth, unsigned num_instances,
diff --git a/src/gallium/auxiliary/util/u_blitter.h b/src/gallium/auxiliary/util/u_blitter.h
index e4357bbfa5ef..b2fccd051f9d 100644
--- a/src/gallium/auxiliary/util/u_blitter.h
+++ b/src/gallium/auxiliary/util/u_blitter.h
@@ -90,7 +90,7 @@ struct blitter_context
     *       a rectangular point sprite.
     */
    void (*draw_rectangle)(struct blitter_context *blitter,
-                          void *vertex_elements_cso,
+                          struct pipe_vertex_elements *vertex_elements_cso,
                           blitter_get_vs_func get_vs,
                           int x1, int y1, int x2, int y2,
                           float depth, unsigned num_instances,
@@ -107,7 +107,7 @@ struct blitter_context
 
    void *saved_blend_state;   /**< blend state */
    void *saved_dsa_state;     /**< depth stencil alpha state */
-   void *saved_velem_state;   /**< vertex elements state */
+   struct pipe_vertex_elements *saved_velem_state;   /**< vertex elements state */
    void *saved_rs_state;      /**< rasterizer state */
    void *saved_fs, *saved_vs, *saved_gs, *saved_tcs, *saved_tes; /**< shaders */
 
@@ -178,7 +178,7 @@ void util_blitter_set_texture_multisample(struct blitter_context *blitter,
 /* The default function to draw a rectangle. This can only be used
  * inside of the draw_rectangle callback if the driver overrides it. */
 void util_blitter_draw_rectangle(struct blitter_context *blitter,
-                                 void *vertex_elements_cso,
+                                 struct pipe_vertex_elements *vertex_elements_cso,
                                  blitter_get_vs_func get_vs,
                                  int x1, int y1, int x2, int y2,
                                  float depth, unsigned num_instances,
@@ -422,7 +422,7 @@ util_blitter_save_depth_stencil_alpha(struct blitter_context *blitter,
 }
 
 static inline void
-util_blitter_save_vertex_elements(struct blitter_context *blitter, void *state)
+util_blitter_save_vertex_elements(struct blitter_context *blitter, struct pipe_vertex_elements *state)
 {
    blitter->saved_velem_state = state;
 }
diff --git a/src/gallium/auxiliary/util/u_helpers.c b/src/gallium/auxiliary/util/u_helpers.c
index e0e91aab4628..17d1246fd81d 100644
--- a/src/gallium/auxiliary/util/u_helpers.c
+++ b/src/gallium/auxiliary/util/u_helpers.c
@@ -178,12 +178,11 @@ util_upload_index_buffer(struct pipe_context *pipe,
  * @param tmp           Temporary array of PIPE_MAX_ATTRIBS vertex elements.
  */
 void
-util_lower_uint64_vertex_elements(const struct pipe_vertex_element **velems,
-                                  unsigned *velem_count,
-                                  struct pipe_vertex_element tmp[PIPE_MAX_ATTRIBS])
+util_lower_uint64_vertex_elements(const struct pipe_vertex_elements **ve,
+                                  struct pipe_vertex_elements *tmp)
 {
-   const struct pipe_vertex_element *input = *velems;
-   unsigned count = *velem_count;
+   const struct pipe_vertex_element *input = (*ve)->input;
+   unsigned count = (*ve)->count;
    bool has_64bit = false;
 
    for (unsigned i = 0; i < count; i++) {
@@ -217,38 +216,38 @@ util_lower_uint64_vertex_elements(const struct pipe_vertex_element **velems,
 
       switch (format) {
       case PIPE_FORMAT_R64_UINT:
-         tmp[new_count] = input[i];
-         tmp[new_count].src_format = PIPE_FORMAT_R32G32_UINT;
+         tmp->input[new_count] = input[i];
+         tmp->input[new_count].src_format = PIPE_FORMAT_R32G32_UINT;
          new_count++;
          break;
 
       case PIPE_FORMAT_R64G64_UINT:
-         tmp[new_count] = input[i];
-         tmp[new_count].src_format = PIPE_FORMAT_R32G32B32A32_UINT;
+         tmp->input[new_count] = input[i];
+         tmp->input[new_count].src_format = PIPE_FORMAT_R32G32B32A32_UINT;
          new_count++;
          break;
 
       case PIPE_FORMAT_R64G64B64_UINT:
       case PIPE_FORMAT_R64G64B64A64_UINT:
          assert(new_count + 2 <= PIPE_MAX_ATTRIBS);
-         tmp[new_count] = tmp[new_count + 1] = input[i];
-         tmp[new_count].src_format = PIPE_FORMAT_R32G32B32A32_UINT;
-         tmp[new_count + 1].src_format =
+         tmp->input[new_count] = tmp->input[new_count + 1] = input[i];
+         tmp->input[new_count].src_format = PIPE_FORMAT_R32G32B32A32_UINT;
+         tmp->input[new_count + 1].src_format =
             format == PIPE_FORMAT_R64G64B64_UINT ?
                   PIPE_FORMAT_R32G32_UINT :
                   PIPE_FORMAT_R32G32B32A32_UINT;
-         tmp[new_count + 1].src_offset += 16;
+         tmp->input[new_count + 1].src_offset += 16;
          new_count += 2;
          break;
 
       default:
-         tmp[new_count++] = input[i];
+         tmp->input[new_count++] = input[i];
          break;
       }
    }
 
-   *velem_count = new_count;
-   *velems = tmp;
+   tmp->count = new_count;
+   *ve = tmp;
 }
 
 /* This is a helper for hardware bring-up. Don't remove. */
@@ -501,22 +500,21 @@ util_lower_clearsize_to_dword(const void *clearValue, int *clearValueSize, uint3
 void
 util_init_pipe_vertex_state(struct pipe_screen *screen,
                             struct pipe_vertex_buffer *buffer,
-                            const struct pipe_vertex_element *elements,
-                            unsigned num_elements,
+                            const struct pipe_vertex_elements *ve,
                             struct pipe_resource *indexbuf,
                             uint32_t full_velem_mask,
                             struct pipe_vertex_state *state)
 {
-   assert(num_elements == util_bitcount(full_velem_mask));
+   assert(ve->count == util_bitcount(full_velem_mask));
 
    pipe_reference_init(&state->reference, 1);
    state->screen = screen;
 
    pipe_vertex_buffer_reference(&state->input.vbuffer, buffer);
    pipe_resource_reference(&state->input.indexbuf, indexbuf);
-   state->input.num_elements = num_elements;
-   for (unsigned i = 0; i < num_elements; i++)
-      state->input.elements[i] = elements[i];
+   state->input.ve.count = ve->count;
+   for (unsigned i = 0; i < ve->count; i++)
+      state->input.ve.input[i] = ve->input[i];
    state->input.full_velem_mask = full_velem_mask;
 }
 
diff --git a/src/gallium/auxiliary/util/u_helpers.h b/src/gallium/auxiliary/util/u_helpers.h
index 299c67980886..246286d2bee1 100644
--- a/src/gallium/auxiliary/util/u_helpers.h
+++ b/src/gallium/auxiliary/util/u_helpers.h
@@ -63,9 +63,8 @@ bool util_upload_index_buffer(struct pipe_context *pipe,
                               unsigned *out_offset, unsigned alignment);
 
 void
-util_lower_uint64_vertex_elements(const struct pipe_vertex_element **velems,
-                                  unsigned *velem_count,
-                                  struct pipe_vertex_element tmp[PIPE_MAX_ATTRIBS]);
+util_lower_uint64_vertex_elements(const struct pipe_vertex_elements **ve,
+                                  struct pipe_vertex_elements *tmp);
 
 /* Helper function to determine if the varying should contain the point
  * coordinates, given the sprite_coord_enable mask.  Requires
@@ -124,8 +123,7 @@ util_lower_clearsize_to_dword(const void *clearValue, int *clearValueSize, uint3
 void
 util_init_pipe_vertex_state(struct pipe_screen *screen,
                             struct pipe_vertex_buffer *buffer,
-                            const struct pipe_vertex_element *elements,
-                            unsigned num_elements,
+                            const struct pipe_vertex_elements *ve,
                             struct pipe_resource *indexbuf,
                             uint32_t full_velem_mask,
                             struct pipe_vertex_state *state);
diff --git a/src/gallium/auxiliary/util/u_tests.c b/src/gallium/auxiliary/util/u_tests.c
index eb58c05cc267..ea835c5dc2bb 100644
--- a/src/gallium/auxiliary/util/u_tests.c
+++ b/src/gallium/auxiliary/util/u_tests.c
@@ -138,14 +138,14 @@ static void
 util_set_interleaved_vertex_elements(struct cso_context *cso,
                                      unsigned num_elements)
 {
-   struct cso_velems_state velem;
+   struct pipe_vertex_elements velem;
    unsigned i;
 
    memset(&velem, 0, sizeof(velem));
    velem.count = num_elements;
    for (i = 0; i < num_elements; i++) {
-      velem.velems[i].src_format = PIPE_FORMAT_R32G32B32A32_FLOAT;
-      velem.velems[i].src_offset = i * 16;
+      velem.input[i].src_format = PIPE_FORMAT_R32G32B32A32_FLOAT;
+      velem.input[i].src_offset = i * 16;
    }
 
    cso_set_vertex_elements(cso, &velem);
diff --git a/src/gallium/auxiliary/util/u_threaded_context.c b/src/gallium/auxiliary/util/u_threaded_context.c
index 45cd8561aea0..1bcb514a4dbb 100644
--- a/src/gallium/auxiliary/util/u_threaded_context.c
+++ b/src/gallium/auxiliary/util/u_threaded_context.c
@@ -1055,16 +1055,16 @@ TC_CSO_SHADER_TRACK(tcs)
 TC_CSO_SHADER_TRACK(tes)
 TC_CSO_CREATE(sampler, sampler)
 TC_CSO_DELETE(sampler)
-TC_CSO_BIND(vertex_elements)
-TC_CSO_DELETE(vertex_elements)
+TC_FUNC1(bind_vertex_elements_state, , struct pipe_vertex_elements *, ,)
+TC_FUNC1(delete_vertex_elements_state, , struct pipe_vertex_elements *, ,)
 
-static void *
-tc_create_vertex_elements_state(struct pipe_context *_pipe, unsigned count,
-                                const struct pipe_vertex_element *elems)
+static struct pipe_vertex_elements *
+tc_create_vertex_elements_state(struct pipe_context *_pipe,
+                                const struct pipe_vertex_elements *elems)
 {
    struct pipe_context *pipe = threaded_context(_pipe)->pipe;
 
-   return pipe->create_vertex_elements_state(pipe, count, elems);
+   return pipe->create_vertex_elements_state(pipe, elems);
 }
 
 struct tc_sampler_states {
diff --git a/src/gallium/auxiliary/util/u_vbuf.c b/src/gallium/auxiliary/util/u_vbuf.c
index 4a8f6cd284a8..475e00abb61b 100644
--- a/src/gallium/auxiliary/util/u_vbuf.c
+++ b/src/gallium/auxiliary/util/u_vbuf.c
@@ -102,8 +102,7 @@
 #include "cso_cache/cso_hash.h"
 
 struct u_vbuf_elements {
-   unsigned count;
-   struct pipe_vertex_element ve[PIPE_MAX_ATTRIBS];
+   struct pipe_vertex_elements base; /* don't change, it's used by memcmp for CSO lookups */
 
    unsigned src_format_size[PIPE_MAX_ATTRIBS];
 
@@ -139,7 +138,7 @@ struct u_vbuf_elements {
    /* Which buffers are used by multiple vertex attribs. */
    uint32_t interleaved_vb_mask;
 
-   void *driver_cso;
+   struct pipe_vertex_elements *driver_cso;
 };
 
 enum {
@@ -177,7 +176,7 @@ struct u_vbuf {
    struct u_vbuf_elements *ve, *ve_saved;
 
    /* Vertex elements used for the translate fallback. */
-   struct cso_velems_state fallback_velems;
+   struct pipe_vertex_elements fallback_velems;
    /* If non-NULL, this is a vertex element state used for the translate
     * fallback and therefore used for rendering too. */
    boolean using_translate;
@@ -196,9 +195,9 @@ struct u_vbuf {
    uint32_t allowed_vb_mask;
 };
 
-static void *
-u_vbuf_create_vertex_elements(struct u_vbuf *mgr, unsigned count,
-                              const struct pipe_vertex_element *attribs);
+static struct u_vbuf_elements *
+u_vbuf_create_vertex_elements(struct u_vbuf *mgr,
+                              const struct pipe_vertex_elements *attribs);
 static void u_vbuf_delete_vertex_elements(void *ctx, void *state,
                                           enum cso_cache_type type);
 
@@ -383,7 +382,7 @@ u_vbuf_create(struct pipe_context *pipe, struct u_vbuf_caps *caps)
  * its own preprocessed state per vertex element CSO. */
 static struct u_vbuf_elements *
 u_vbuf_set_vertex_elements_internal(struct u_vbuf *mgr,
-                                    const struct cso_velems_state *velems)
+                                    const struct pipe_vertex_elements *velems)
 {
    struct pipe_context *pipe = mgr->pipe;
    unsigned key_size, hash_key;
@@ -400,13 +399,12 @@ u_vbuf_set_vertex_elements_internal(struct u_vbuf *mgr,
    if (cso_hash_iter_is_null(iter)) {
       struct cso_velements *cso = MALLOC_STRUCT(cso_velements);
       memcpy(&cso->state, velems, key_size);
-      cso->data = u_vbuf_create_vertex_elements(mgr, velems->count,
-                                                velems->velems);
+      cso->data = &u_vbuf_create_vertex_elements(mgr, velems)->base;
 
       iter = cso_insert_state(&mgr->cso_cache, hash_key, CSO_VELEMENTS, cso);
-      ve = cso->data;
+      ve = (struct u_vbuf_elements *)cso->data;
    } else {
-      ve = ((struct cso_velements *)cso_hash_iter_data(iter))->data;
+      ve = (struct u_vbuf_elements *)((struct cso_velements *)cso_hash_iter_data(iter))->data;
    }
 
    assert(ve);
@@ -418,7 +416,7 @@ u_vbuf_set_vertex_elements_internal(struct u_vbuf *mgr,
 }
 
 void u_vbuf_set_vertex_elements(struct u_vbuf *mgr,
-                                const struct cso_velems_state *velems)
+                                const struct pipe_vertex_elements *velems)
 {
    mgr->ve = u_vbuf_set_vertex_elements_internal(mgr, velems);
 }
@@ -706,8 +704,8 @@ u_vbuf_translate_begin(struct u_vbuf *mgr,
 
    /* See if there are vertex attribs of each type to translate and
     * which ones. */
-   for (i = 0; i < mgr->ve->count; i++) {
-      unsigned vb_index = mgr->ve->ve[i].vertex_buffer_index;
+   for (i = 0; i < mgr->ve->base.count; i++) {
+      unsigned vb_index = mgr->ve->base.input[i].vertex_buffer_index;
 
       if (!mgr->vertex_buffer[vb_index].stride) {
          if (!(mgr->ve->incompatible_elem_mask & (1 << i)) &&
@@ -715,7 +713,7 @@ u_vbuf_translate_begin(struct u_vbuf *mgr,
             continue;
          }
          mask[VB_CONST] |= 1 << vb_index;
-      } else if (mgr->ve->ve[i].instance_divisor) {
+      } else if (mgr->ve->base.input[i].instance_divisor) {
          if (!(mgr->ve->incompatible_elem_mask & (1 << i)) &&
              !(incompatible_vb_mask & (1 << vb_index))) {
             continue;
@@ -740,11 +738,11 @@ u_vbuf_translate_begin(struct u_vbuf *mgr,
 
    unsigned min_alignment[VB_NUM] = {0};
    /* Initialize the translate keys. */
-   for (i = 0; i < mgr->ve->count; i++) {
+   for (i = 0; i < mgr->ve->base.count; i++) {
       struct translate_key *k;
       struct translate_element *te;
       enum pipe_format output_format = mgr->ve->native_format[i];
-      unsigned bit, vb_index = mgr->ve->ve[i].vertex_buffer_index;
+      unsigned bit, vb_index = mgr->ve->base.input[i].vertex_buffer_index;
       bit = 1 << vb_index;
 
       if (!(mgr->ve->incompatible_elem_mask & (1 << i)) &&
@@ -761,7 +759,7 @@ u_vbuf_translate_begin(struct u_vbuf *mgr,
          }
       }
       assert(type < VB_NUM);
-      if (mgr->ve->ve[i].src_format != output_format)
+      if (mgr->ve->base.input[i].src_format != output_format)
          assert(translate_is_output_format_supported(output_format));
       /*printf("velem=%i type=%i\n", i, type);*/
 
@@ -773,8 +771,8 @@ u_vbuf_translate_begin(struct u_vbuf *mgr,
       te->type = TRANSLATE_ELEMENT_NORMAL;
       te->instance_divisor = 0;
       te->input_buffer = vb_index;
-      te->input_format = mgr->ve->ve[i].src_format;
-      te->input_offset = mgr->ve->ve[i].src_offset;
+      te->input_format = mgr->ve->base.input[i].src_format;
+      te->input_offset = mgr->ve->base.input[i].src_offset;
       te->output_format = output_format;
       te->output_offset = k->output_stride;
       unsigned adjustment = 0;
@@ -811,14 +809,14 @@ u_vbuf_translate_begin(struct u_vbuf *mgr,
    }
 
    /* Setup new vertex elements. */
-   for (i = 0; i < mgr->ve->count; i++) {
+   for (i = 0; i < mgr->ve->base.count; i++) {
       for (type = 0; type < VB_NUM; type++) {
          if (elem_index[type][i] < key[type].nr_elements) {
             struct translate_element *te = &key[type].element[elem_index[type][i]];
-            mgr->fallback_velems.velems[i].instance_divisor = mgr->ve->ve[i].instance_divisor;
-            mgr->fallback_velems.velems[i].src_format = te->output_format;
-            mgr->fallback_velems.velems[i].src_offset = te->output_offset;
-            mgr->fallback_velems.velems[i].vertex_buffer_index = mgr->fallback_vbs[type];
+            mgr->fallback_velems.input[i].instance_divisor = mgr->ve->base.input[i].instance_divisor;
+            mgr->fallback_velems.input[i].src_format = te->output_format;
+            mgr->fallback_velems.input[i].src_offset = te->output_offset;
+            mgr->fallback_velems.input[i].vertex_buffer_index = mgr->fallback_vbs[type];
 
             /* elem_index[type][i] can only be set for one type. */
             assert(type > VB_INSTANCE || elem_index[type+1][i] == ~0u);
@@ -828,12 +826,12 @@ u_vbuf_translate_begin(struct u_vbuf *mgr,
       }
       /* No translating, just copy the original vertex element over. */
       if (type == VB_NUM) {
-         memcpy(&mgr->fallback_velems.velems[i], &mgr->ve->ve[i],
+         memcpy(&mgr->fallback_velems.input[i], &mgr->ve->base.input[i],
                 sizeof(struct pipe_vertex_element));
       }
    }
 
-   mgr->fallback_velems.count = mgr->ve->count;
+   mgr->fallback_velems.count = mgr->ve->base.count;
 
    u_vbuf_set_vertex_elements_internal(mgr, &mgr->fallback_velems);
    mgr->using_translate = TRUE;
@@ -861,29 +859,28 @@ static void u_vbuf_translate_end(struct u_vbuf *mgr)
    mgr->fallback_vbs_mask = 0;
 }
 
-static void *
-u_vbuf_create_vertex_elements(struct u_vbuf *mgr, unsigned count,
-                              const struct pipe_vertex_element *attribs)
+static struct u_vbuf_elements *
+u_vbuf_create_vertex_elements(struct u_vbuf *mgr,
+                              const struct pipe_vertex_elements *attribs)
 {
-   struct pipe_vertex_element tmp[PIPE_MAX_ATTRIBS];
-   util_lower_uint64_vertex_elements(&attribs, &count, tmp);
+   struct pipe_vertex_elements tmp;
+   util_lower_uint64_vertex_elements(&attribs, &tmp);
 
    struct pipe_context *pipe = mgr->pipe;
    unsigned i;
-   struct pipe_vertex_element driver_attribs[PIPE_MAX_ATTRIBS];
+   struct pipe_vertex_elements driver_attribs;
    struct u_vbuf_elements *ve = CALLOC_STRUCT(u_vbuf_elements);
    uint32_t used_buffers = 0;
 
-   ve->count = count;
+   ve->base = *attribs;
 
-   memcpy(ve->ve, attribs, sizeof(struct pipe_vertex_element) * count);
-   memcpy(driver_attribs, attribs, sizeof(struct pipe_vertex_element) * count);
+   memcpy(&driver_attribs, attribs, sizeof(*attribs));
 
    /* Set the best native format in case the original format is not
     * supported. */
-   for (i = 0; i < count; i++) {
-      enum pipe_format format = ve->ve[i].src_format;
-      unsigned vb_index_bit = 1 << ve->ve[i].vertex_buffer_index;
+   for (i = 0; i < ve->base.count; i++) {
+      enum pipe_format format = ve->base.input[i].src_format;
+      unsigned vb_index_bit = 1 << ve->base.input[i].vertex_buffer_index;
 
       ve->src_format_size[i] = util_format_get_blocksize(format);
 
@@ -892,13 +889,13 @@ u_vbuf_create_vertex_elements(struct u_vbuf *mgr, unsigned count,
 
       used_buffers |= vb_index_bit;
 
-      if (!ve->ve[i].instance_divisor) {
+      if (!ve->base.input[i].instance_divisor) {
          ve->noninstance_vb_mask_any |= vb_index_bit;
       }
 
       format = mgr->caps.format_translation[format];
 
-      driver_attribs[i].src_format = format;
+      driver_attribs.input[i].src_format = format;
       ve->native_format[i] = format;
       ve->native_format_size[i] =
             util_format_get_blocksize(ve->native_format[i]);
@@ -911,11 +908,11 @@ u_vbuf_create_vertex_elements(struct u_vbuf *mgr, unsigned count,
                                 ve->native_format_size[i] : (ve->native_format_size[i] / desc->nr_channels);
       ve->component_size[i] = component_size;
 
-      if (ve->ve[i].src_format != format ||
+      if (ve->base.input[i].src_format != format ||
           (!mgr->caps.velem_src_offset_unaligned &&
-           ve->ve[i].src_offset % 4 != 0) ||
+           ve->base.input[i].src_offset % 4 != 0) ||
           (!mgr->caps.attrib_component_unaligned &&
-           ve->ve[i].src_offset % component_size != 0)) {
+           ve->base.input[i].src_offset % component_size != 0)) {
          ve->incompatible_elem_mask |= 1 << i;
          ve->incompatible_vb_mask_any |= vb_index_bit;
       } else {
@@ -935,7 +932,7 @@ u_vbuf_create_vertex_elements(struct u_vbuf *mgr, unsigned count,
        */
       ve->incompatible_vb_mask_any = used_buffers;
       ve->compatible_vb_mask_any = 0;
-      ve->incompatible_elem_mask = u_bit_consecutive(0, count);
+      ve->incompatible_elem_mask = u_bit_consecutive(0, ve->base.count);
    }
 
    ve->used_vb_mask = used_buffers;
@@ -944,16 +941,16 @@ u_vbuf_create_vertex_elements(struct u_vbuf *mgr, unsigned count,
 
    /* Align the formats and offsets to the size of DWORD if needed. */
    if (!mgr->caps.velem_src_offset_unaligned) {
-      for (i = 0; i < count; i++) {
+      for (i = 0; i < ve->base.count; i++) {
          ve->native_format_size[i] = align(ve->native_format_size[i], 4);
-         driver_attribs[i].src_offset = align(ve->ve[i].src_offset, 4);
+         driver_attribs.input[i].src_offset = align(ve->base.input[i].src_offset, 4);
       }
    }
 
    /* Only create driver CSO if no incompatible elements */
    if (!ve->incompatible_elem_mask) {
       ve->driver_cso =
-         pipe->create_vertex_elements_state(pipe, count, driver_attribs);
+         pipe->create_vertex_elements_state(pipe, &driver_attribs);
    }
 
    return ve;
@@ -1164,9 +1161,9 @@ u_vbuf_upload_buffers(struct u_vbuf *mgr,
 {
    unsigned i;
    struct u_vbuf_elements *ve = mgr->ve;
-   unsigned nr_velems = ve->count;
+   unsigned nr_velems = ve->base.count;
    const struct pipe_vertex_element *velems =
-         mgr->using_translate ? mgr->fallback_velems.velems : ve->ve;
+         mgr->using_translate ? mgr->fallback_velems.input : ve->base.input;
 
    /* Faster path when no vertex attribs are interleaved. */
    if ((ve->interleaved_vb_mask & mgr->user_vb_mask) == 0) {
diff --git a/src/gallium/auxiliary/util/u_vbuf.h b/src/gallium/auxiliary/util/u_vbuf.h
index 2d6ca434df31..5c1db786dc9e 100644
--- a/src/gallium/auxiliary/util/u_vbuf.h
+++ b/src/gallium/auxiliary/util/u_vbuf.h
@@ -38,7 +38,7 @@
 #include "pipe/p_format.h"
 
 struct cso_context;
-struct cso_velems_state;
+struct pipe_vertex_elements;
 struct u_vbuf;
 
 /* Hardware vertex fetcher limitations can be described by this structure. */
@@ -78,7 +78,7 @@ void u_vbuf_destroy(struct u_vbuf *mgr);
 /* State and draw functions. */
 void u_vbuf_set_flatshade_first(struct u_vbuf *mgr, bool flatshade_first);
 void u_vbuf_set_vertex_elements(struct u_vbuf *mgr,
-                                const struct cso_velems_state *velems);
+                                const struct pipe_vertex_elements *velems);
 void u_vbuf_unset_vertex_elements(struct u_vbuf *mgr);
 void u_vbuf_set_vertex_buffers(struct u_vbuf *mgr,
                                unsigned start_slot, unsigned count,
diff --git a/src/gallium/auxiliary/util/u_vertex_state_cache.c b/src/gallium/auxiliary/util/u_vertex_state_cache.c
index 112cd79b4ae1..c519cc8d7977 100644
--- a/src/gallium/auxiliary/util/u_vertex_state_cache.c
+++ b/src/gallium/auxiliary/util/u_vertex_state_cache.c
@@ -65,8 +65,7 @@ util_vertex_state_cache_deinit(struct util_vertex_state_cache *cache)
 struct pipe_vertex_state *
 util_vertex_state_cache_get(struct pipe_screen *screen,
                             struct pipe_vertex_buffer *buffer,
-                            const struct pipe_vertex_element *elements,
-                            unsigned num_elements,
+                            const struct pipe_vertex_elements *ve,
                             struct pipe_resource *indexbuf,
                             uint32_t full_velem_mask,
                             struct util_vertex_state_cache *cache)
@@ -79,9 +78,9 @@ util_vertex_state_cache_get(struct pipe_screen *screen,
    assert(!buffer->is_user_buffer);
    key.input.vbuffer.buffer_offset = buffer->buffer_offset;
    key.input.vbuffer.buffer = buffer->buffer;
-   key.input.num_elements = num_elements;
-   for (unsigned i = 0; i < num_elements; i++)
-      key.input.elements[i] = elements[i];
+   key.input.ve.count = ve->count;
+   for (unsigned i = 0; i < ve->count; i++)
+      key.input.ve.input[i] = ve->input[i];
    key.input.full_velem_mask = full_velem_mask;
 
    uint32_t hash = key_hash(&key);
@@ -100,7 +99,7 @@ util_vertex_state_cache_get(struct pipe_screen *screen,
       return state;
    }
 
-   state = cache->create(screen, buffer, elements, num_elements, indexbuf,
+   state = cache->create(screen, buffer, ve, indexbuf,
                          full_velem_mask);
    if (state) {
       assert(key_hash(state) == hash);
diff --git a/src/gallium/auxiliary/util/u_vertex_state_cache.h b/src/gallium/auxiliary/util/u_vertex_state_cache.h
index 902e91e43a38..3d1c01b6be23 100644
--- a/src/gallium/auxiliary/util/u_vertex_state_cache.h
+++ b/src/gallium/auxiliary/util/u_vertex_state_cache.h
@@ -53,8 +53,7 @@ util_vertex_state_cache_deinit(struct util_vertex_state_cache *cache);
 struct pipe_vertex_state *
 util_vertex_state_cache_get(struct pipe_screen *screen,
                             struct pipe_vertex_buffer *buffer,
-                            const struct pipe_vertex_element *elements,
-                            unsigned num_elements,
+                            const struct pipe_vertex_elements *ve,
                             struct pipe_resource *indexbuf,
                             uint32_t full_velem_mask,
                             struct util_vertex_state_cache *cache);
diff --git a/src/gallium/auxiliary/vl/vl_bicubic_filter.c b/src/gallium/auxiliary/vl/vl_bicubic_filter.c
index 457f2cf68bdb..fc250fe07a2b 100644
--- a/src/gallium/auxiliary/vl/vl_bicubic_filter.c
+++ b/src/gallium/auxiliary/vl/vl_bicubic_filter.c
@@ -251,7 +251,7 @@ vl_bicubic_filter_init(struct vl_bicubic_filter *filter, struct pipe_context *pi
    struct pipe_blend_state blend;
    struct vertex2f offsets[16];
    struct pipe_sampler_state sampler;
-   struct pipe_vertex_element ve;
+   struct pipe_vertex_elements ve;
    unsigned i;
 
    assert(filter && pipe);
@@ -302,11 +302,12 @@ vl_bicubic_filter_init(struct vl_bicubic_filter *filter, struct pipe_context *pi
       goto error_quad;
 
    memset(&ve, 0, sizeof(ve));
-   ve.src_offset = 0;
-   ve.instance_divisor = 0;
-   ve.vertex_buffer_index = 0;
-   ve.src_format = PIPE_FORMAT_R32G32_FLOAT;
-   filter->ves = pipe->create_vertex_elements_state(pipe, 1, &ve);
+   ve.count = 1;
+   ve.input[0].src_offset = 0;
+   ve.input[0].instance_divisor = 0;
+   ve.input[0].vertex_buffer_index = 0;
+   ve.input[0].src_format = PIPE_FORMAT_R32G32_FLOAT;
+   filter->ves = pipe->create_vertex_elements_state(pipe, &ve);
    if (!filter->ves)
       goto error_ves;
 
diff --git a/src/gallium/auxiliary/vl/vl_bicubic_filter.h b/src/gallium/auxiliary/vl/vl_bicubic_filter.h
index e5bef474e509..cb91e0a87e29 100644
--- a/src/gallium/auxiliary/vl/vl_bicubic_filter.h
+++ b/src/gallium/auxiliary/vl/vl_bicubic_filter.h
@@ -40,7 +40,7 @@ struct vl_bicubic_filter
    void *rs_state;
    void *blend;
    void *sampler;
-   void *ves;
+   struct pipe_vertex_elements *ves;
    void *vs, *fs;
 };
 
diff --git a/src/gallium/auxiliary/vl/vl_compositor.c b/src/gallium/auxiliary/vl/vl_compositor.c
index 66abf7325b8f..42e74237a58b 100644
--- a/src/gallium/auxiliary/vl/vl_compositor.c
+++ b/src/gallium/auxiliary/vl/vl_compositor.c
@@ -236,8 +236,10 @@ static void cleanup_pipe_state(struct vl_compositor *c)
 static bool
 init_buffers(struct vl_compositor *c)
 {
-   struct pipe_vertex_element vertex_elems[3];
-   memset(vertex_elems, 0, sizeof(vertex_elems));
+   struct pipe_vertex_elements vertex_elems;
+   memset(&vertex_elems, 0, sizeof(vertex_elems));
+
+   vertex_elems.count = 3;
 
    assert(c);
 
@@ -250,19 +252,19 @@ init_buffers(struct vl_compositor *c)
    c->vertex_buf.is_user_buffer = false;
 
    if (c->pipe_gfx_supported) {
-           vertex_elems[0].src_offset = 0;
-           vertex_elems[0].instance_divisor = 0;
-           vertex_elems[0].vertex_buffer_index = 0;
-           vertex_elems[0].src_format = PIPE_FORMAT_R32G32_FLOAT;
-           vertex_elems[1].src_offset = sizeof(struct vertex2f);
-           vertex_elems[1].instance_divisor = 0;
-           vertex_elems[1].vertex_buffer_index = 0;
-           vertex_elems[1].src_format = PIPE_FORMAT_R32G32B32A32_FLOAT;
-           vertex_elems[2].src_offset = sizeof(struct vertex2f) + sizeof(struct vertex4f);
-           vertex_elems[2].instance_divisor = 0;
-           vertex_elems[2].vertex_buffer_index = 0;
-           vertex_elems[2].src_format = PIPE_FORMAT_R32G32B32A32_FLOAT;
-           c->vertex_elems_state = c->pipe->create_vertex_elements_state(c->pipe, 3, vertex_elems);
+           vertex_elems.input[0].src_offset = 0;
+           vertex_elems.input[0].instance_divisor = 0;
+           vertex_elems.input[0].vertex_buffer_index = 0;
+           vertex_elems.input[0].src_format = PIPE_FORMAT_R32G32_FLOAT;
+           vertex_elems.input[1].src_offset = sizeof(struct vertex2f);
+           vertex_elems.input[1].instance_divisor = 0;
+           vertex_elems.input[1].vertex_buffer_index = 0;
+           vertex_elems.input[1].src_format = PIPE_FORMAT_R32G32B32A32_FLOAT;
+           vertex_elems.input[2].src_offset = sizeof(struct vertex2f) + sizeof(struct vertex4f);
+           vertex_elems.input[2].instance_divisor = 0;
+           vertex_elems.input[2].vertex_buffer_index = 0;
+           vertex_elems.input[2].src_format = PIPE_FORMAT_R32G32B32A32_FLOAT;
+           c->vertex_elems_state = c->pipe->create_vertex_elements_state(c->pipe, &vertex_elems);
    }
 
    return true;
diff --git a/src/gallium/auxiliary/vl/vl_compositor.h b/src/gallium/auxiliary/vl/vl_compositor.h
index 32ce82f73208..1b3c1a3a2ee5 100644
--- a/src/gallium/auxiliary/vl/vl_compositor.h
+++ b/src/gallium/auxiliary/vl/vl_compositor.h
@@ -114,7 +114,7 @@ struct vl_compositor
    void *blend_clear, *blend_add;
    void *rast;
    void *dsa;
-   void *vertex_elems_state;
+   struct pipe_vertex_elements *vertex_elems_state;
 
    void *vs;
    void *fs_video_buffer;
diff --git a/src/gallium/auxiliary/vl/vl_deint_filter.c b/src/gallium/auxiliary/vl/vl_deint_filter.c
index 20b33c6f2b3a..407c45b53fb9 100644
--- a/src/gallium/auxiliary/vl/vl_deint_filter.c
+++ b/src/gallium/auxiliary/vl/vl_deint_filter.c
@@ -240,7 +240,7 @@ vl_deint_filter_init(struct vl_deint_filter *filter, struct pipe_context *pipe,
    struct pipe_rasterizer_state rs_state;
    struct pipe_blend_state blend;
    struct pipe_sampler_state sampler;
-   struct pipe_vertex_element ve;
+   struct pipe_vertex_elements ve;
    struct vertex2f sizes;
    struct pipe_video_buffer templ;
 
@@ -313,11 +313,12 @@ vl_deint_filter_init(struct vl_deint_filter *filter, struct pipe_context *pipe,
       goto error_quad;
 
    memset(&ve, 0, sizeof(ve));
-   ve.src_offset = 0;
-   ve.instance_divisor = 0;
-   ve.vertex_buffer_index = 0;
-   ve.src_format = PIPE_FORMAT_R32G32_FLOAT;
-   filter->ves = pipe->create_vertex_elements_state(pipe, 1, &ve);
+   ve.count = 1;
+   ve.input[0].src_offset = 0;
+   ve.input[0].instance_divisor = 0;
+   ve.input[0].vertex_buffer_index = 0;
+   ve.input[0].src_format = PIPE_FORMAT_R32G32_FLOAT;
+   filter->ves = pipe->create_vertex_elements_state(pipe, &ve);
    if (!filter->ves)
       goto error_ves;
 
diff --git a/src/gallium/auxiliary/vl/vl_deint_filter.h b/src/gallium/auxiliary/vl/vl_deint_filter.h
index 49cc96c20b96..ce32286e7afd 100644
--- a/src/gallium/auxiliary/vl/vl_deint_filter.h
+++ b/src/gallium/auxiliary/vl/vl_deint_filter.h
@@ -40,7 +40,7 @@ struct vl_deint_filter
    void *rs_state;
    void *blend[3];
    void *sampler[4];
-   void *ves;
+   struct pipe_vertex_elements *ves;
    void *vs;
    void *fs_copy_top, *fs_copy_bottom;
    void *fs_deint_top, *fs_deint_bottom;
diff --git a/src/gallium/auxiliary/vl/vl_matrix_filter.c b/src/gallium/auxiliary/vl/vl_matrix_filter.c
index f3e3bd5c63d6..fd63a8e75cf1 100644
--- a/src/gallium/auxiliary/vl/vl_matrix_filter.c
+++ b/src/gallium/auxiliary/vl/vl_matrix_filter.c
@@ -137,7 +137,7 @@ vl_matrix_filter_init(struct vl_matrix_filter *filter, struct pipe_context *pipe
    struct pipe_rasterizer_state rs_state;
    struct pipe_blend_state blend;
    struct pipe_sampler_state sampler;
-   struct pipe_vertex_element ve;
+   struct pipe_vertex_elements ve;
    struct vertex2f *offsets, v, sizes;
    unsigned i, num_offsets = matrix_width * matrix_height;
 
@@ -190,11 +190,12 @@ vl_matrix_filter_init(struct vl_matrix_filter *filter, struct pipe_context *pipe
       goto error_quad;
 
    memset(&ve, 0, sizeof(ve));
-   ve.src_offset = 0;
-   ve.instance_divisor = 0;
-   ve.vertex_buffer_index = 0;
-   ve.src_format = PIPE_FORMAT_R32G32_FLOAT;
-   filter->ves = pipe->create_vertex_elements_state(pipe, 1, &ve);
+   ve.count = 1;
+   ve.input[0].src_offset = 0;
+   ve.input[0].instance_divisor = 0;
+   ve.input[0].vertex_buffer_index = 0;
+   ve.input[0].src_format = PIPE_FORMAT_R32G32_FLOAT;
+   filter->ves = pipe->create_vertex_elements_state(pipe, &ve);
    if (!filter->ves)
       goto error_ves;
 
diff --git a/src/gallium/auxiliary/vl/vl_matrix_filter.h b/src/gallium/auxiliary/vl/vl_matrix_filter.h
index 6e70b53f3383..d3dd6c05a6f6 100644
--- a/src/gallium/auxiliary/vl/vl_matrix_filter.h
+++ b/src/gallium/auxiliary/vl/vl_matrix_filter.h
@@ -41,7 +41,7 @@ struct vl_matrix_filter
    void *rs_state;
    void *blend;
    void *sampler;
-   void *ves;
+   struct pipe_vertex_elements *ves;
    void *vs, *fs;
 };
 
diff --git a/src/gallium/auxiliary/vl/vl_median_filter.c b/src/gallium/auxiliary/vl/vl_median_filter.c
index ca935237b86d..56e10286115c 100644
--- a/src/gallium/auxiliary/vl/vl_median_filter.c
+++ b/src/gallium/auxiliary/vl/vl_median_filter.c
@@ -249,7 +249,7 @@ vl_median_filter_init(struct vl_median_filter *filter, struct pipe_context *pipe
    struct pipe_blend_state blend;
    struct pipe_sampler_state sampler;
    struct vertex2f *offsets = NULL;
-   struct pipe_vertex_element ve;
+   struct pipe_vertex_elements ve;
    unsigned i, num_offsets = 0;
 
    assert(filter && pipe);
@@ -301,11 +301,12 @@ vl_median_filter_init(struct vl_median_filter *filter, struct pipe_context *pipe
       goto error_quad;
 
    memset(&ve, 0, sizeof(ve));
-   ve.src_offset = 0;
-   ve.instance_divisor = 0;
-   ve.vertex_buffer_index = 0;
-   ve.src_format = PIPE_FORMAT_R32G32_FLOAT;
-   filter->ves = pipe->create_vertex_elements_state(pipe, 1, &ve);
+   ve.count = 1;
+   ve.input[0].src_offset = 0;
+   ve.input[0].instance_divisor = 0;
+   ve.input[0].vertex_buffer_index = 0;
+   ve.input[0].src_format = PIPE_FORMAT_R32G32_FLOAT;
+   filter->ves = pipe->create_vertex_elements_state(pipe, &ve);
    if (!filter->ves)
       goto error_ves;
 
diff --git a/src/gallium/auxiliary/vl/vl_median_filter.h b/src/gallium/auxiliary/vl/vl_median_filter.h
index 2aaa6bbaa0ec..99d6070fef5d 100644
--- a/src/gallium/auxiliary/vl/vl_median_filter.h
+++ b/src/gallium/auxiliary/vl/vl_median_filter.h
@@ -49,7 +49,7 @@ struct vl_median_filter
    void *rs_state;
    void *blend;
    void *sampler;
-   void *ves;
+   struct pipe_vertex_elements *ves;
    void *vs, *fs;
 };
 
diff --git a/src/gallium/auxiliary/vl/vl_vertex_buffers.c b/src/gallium/auxiliary/vl/vl_vertex_buffers.c
index be02b82734a5..a3a7fca2b119 100644
--- a/src/gallium/auxiliary/vl/vl_vertex_buffers.c
+++ b/src/gallium/auxiliary/vl/vl_vertex_buffers.c
@@ -158,51 +158,53 @@ vl_vb_element_helper(struct pipe_vertex_element* elements, unsigned num_elements
    }
 }
 
-void *
+struct pipe_vertex_elements *
 vl_vb_get_ves_ycbcr(struct pipe_context *pipe)
 {
-   struct pipe_vertex_element vertex_elems[NUM_VS_INPUTS];
+   struct pipe_vertex_elements vertex_elems;
 
    assert(pipe);
 
    memset(&vertex_elems, 0, sizeof(vertex_elems));
-   vertex_elems[VS_I_RECT] = vl_vb_get_quad_vertex_element();
+   vertex_elems.count = 0;
+   vertex_elems.input[VS_I_RECT] = vl_vb_get_quad_vertex_element();
 
    /* Position element */
-   vertex_elems[VS_I_VPOS].src_format = PIPE_FORMAT_R8G8B8A8_USCALED;
+   vertex_elems.input[VS_I_VPOS].src_format = PIPE_FORMAT_R8G8B8A8_USCALED;
 
    /* block num element */
-   vertex_elems[VS_I_BLOCK_NUM].src_format = PIPE_FORMAT_R32_FLOAT;
+   vertex_elems.input[VS_I_BLOCK_NUM].src_format = PIPE_FORMAT_R32_FLOAT;
 
-   vl_vb_element_helper(&vertex_elems[VS_I_VPOS], 2, 1);
+   vl_vb_element_helper(&vertex_elems.input[VS_I_VPOS], 2, 1);
 
-   return pipe->create_vertex_elements_state(pipe, 3, vertex_elems);
+   return pipe->create_vertex_elements_state(pipe, &vertex_elems);
 }
 
-void *
+struct pipe_vertex_elements *
 vl_vb_get_ves_mv(struct pipe_context *pipe)
 {
-   struct pipe_vertex_element vertex_elems[NUM_VS_INPUTS];
+   struct pipe_vertex_elements vertex_elems;
 
    assert(pipe);
 
    memset(&vertex_elems, 0, sizeof(vertex_elems));
-   vertex_elems[VS_I_RECT] = vl_vb_get_quad_vertex_element();
+   vertex_elems.count = NUM_VS_INPUTS;
+   vertex_elems.input[VS_I_RECT] = vl_vb_get_quad_vertex_element();
 
    /* Position element */
-   vertex_elems[VS_I_VPOS].src_format = PIPE_FORMAT_R16G16_SSCALED;
+   vertex_elems.input[VS_I_VPOS].src_format = PIPE_FORMAT_R16G16_SSCALED;
 
-   vl_vb_element_helper(&vertex_elems[VS_I_VPOS], 1, 1);
+   vl_vb_element_helper(&vertex_elems.input[VS_I_VPOS], 1, 1);
 
    /* motion vector TOP element */
-   vertex_elems[VS_I_MV_TOP].src_format = PIPE_FORMAT_R16G16B16A16_SSCALED;
+   vertex_elems.input[VS_I_MV_TOP].src_format = PIPE_FORMAT_R16G16B16A16_SSCALED;
 
    /* motion vector BOTTOM element */
-   vertex_elems[VS_I_MV_BOTTOM].src_format = PIPE_FORMAT_R16G16B16A16_SSCALED;
+   vertex_elems.input[VS_I_MV_BOTTOM].src_format = PIPE_FORMAT_R16G16B16A16_SSCALED;
 
-   vl_vb_element_helper(&vertex_elems[VS_I_MV_TOP], 2, 2);
+   vl_vb_element_helper(&vertex_elems.input[VS_I_MV_TOP], 2, 2);
 
-   return pipe->create_vertex_elements_state(pipe, NUM_VS_INPUTS, vertex_elems);
+   return pipe->create_vertex_elements_state(pipe, &vertex_elems);
 }
 
 bool
diff --git a/src/gallium/auxiliary/vl/vl_vertex_buffers.h b/src/gallium/auxiliary/vl/vl_vertex_buffers.h
index d77409374fe2..7df906058503 100644
--- a/src/gallium/auxiliary/vl/vl_vertex_buffers.h
+++ b/src/gallium/auxiliary/vl/vl_vertex_buffers.h
@@ -109,9 +109,9 @@ struct pipe_vertex_buffer vl_vb_upload_quads(struct pipe_context *pipe);
 
 struct pipe_vertex_buffer vl_vb_upload_pos(struct pipe_context *pipe, unsigned width, unsigned height);
 
-void *vl_vb_get_ves_ycbcr(struct pipe_context *pipe);
+struct pipe_vertex_elements *vl_vb_get_ves_ycbcr(struct pipe_context *pipe);
 
-void *vl_vb_get_ves_mv(struct pipe_context *pipe);
+struct pipe_vertex_elements *vl_vb_get_ves_mv(struct pipe_context *pipe);
 
 bool vl_vb_init(struct vl_vertex_buffer *buffer,
                 struct pipe_context *pipe,
diff --git a/src/gallium/drivers/asahi/agx_blit.c b/src/gallium/drivers/asahi/agx_blit.c
index f905c5f0bf31..99fa99c18edd 100644
--- a/src/gallium/drivers/asahi/agx_blit.c
+++ b/src/gallium/drivers/asahi/agx_blit.c
@@ -86,7 +86,7 @@ agx_blitter_save(struct agx_context *ctx, struct blitter_context *blitter,
                  bool render_cond)
 {
    util_blitter_save_vertex_buffer_slot(blitter, ctx->vertex_buffers);
-   util_blitter_save_vertex_elements(blitter, ctx->attributes);
+   util_blitter_save_vertex_elements(blitter, &ctx->attributes->base);
    util_blitter_save_vertex_shader(blitter, ctx->stage[PIPE_SHADER_VERTEX].shader);
    util_blitter_save_rasterizer(blitter, ctx->rast);
    util_blitter_save_viewport(blitter, &ctx->viewport);
diff --git a/src/gallium/drivers/asahi/agx_state.c b/src/gallium/drivers/asahi/agx_state.c
index 48929791b512..d902e945fbac 100644
--- a/src/gallium/drivers/asahi/agx_state.c
+++ b/src/gallium/drivers/asahi/agx_state.c
@@ -805,6 +805,12 @@ agx_delete_state(struct pipe_context *ctx, void *state)
    FREE(state);
 }
 
+static void
+agx_delete_vertex_elements(struct pipe_context *ctx, struct pipe_vertex_elements *state)
+{
+   FREE(state);
+}
+
 /* BOs added to the batch in the uniform upload path */
 
 static void
@@ -822,16 +828,17 @@ agx_set_vertex_buffers(struct pipe_context *pctx,
    ctx->dirty |= AGX_DIRTY_VERTEX;
 }
 
-static void *
+static struct pipe_vertex_elements *
 agx_create_vertex_elements(struct pipe_context *ctx,
-                           unsigned count,
-                           const struct pipe_vertex_element *state)
+                           const struct pipe_vertex_elements *state)
 {
-   assert(count < AGX_MAX_ATTRIBS);
+   assert(state->count < AGX_MAX_ATTRIBS);
 
-   struct agx_attribute *attribs = calloc(sizeof(*attribs), AGX_MAX_ATTRIBS);
-   for (unsigned i = 0; i < count; ++i) {
-      const struct pipe_vertex_element ve = state[i];
+   struct agx_vertex_elements *ve = calloc(1, sizeof(*ve));
+   ve->base = *state;
+   struct agx_attribute *attribs = ve->attributes;
+   for (unsigned i = 0; i < state->count; ++i) {
+      const struct pipe_vertex_element ve = state->input[i];
 
       const struct util_format_description *desc =
          util_format_description(ve.src_format);
@@ -851,14 +858,14 @@ agx_create_vertex_elements(struct pipe_context *ctx,
       };
    }
 
-   return attribs;
+   return &ve->base;
 }
 
 static void
-agx_bind_vertex_elements_state(struct pipe_context *pctx, void *cso)
+agx_bind_vertex_elements_state(struct pipe_context *pctx, struct pipe_vertex_elements *cso)
 {
    struct agx_context *ctx = agx_context(pctx);
-   ctx->attributes = cso;
+   ctx->attributes = (struct agx_vertex_elements*)cso;
    ctx->dirty |= AGX_DIRTY_VERTEX;
 }
 
@@ -1082,7 +1089,7 @@ agx_update_vs(struct agx_context *ctx)
       .num_vbufs = util_last_bit(ctx->vb_mask),
    };
 
-   memcpy(key.attributes, ctx->attributes,
+   memcpy(key.attributes, ctx->attributes->attributes,
           sizeof(key.attributes[0]) * AGX_MAX_ATTRIBS);
 
    u_foreach_bit(i, ctx->vb_mask) {
@@ -1797,7 +1804,7 @@ agx_init_state_functions(struct pipe_context *ctx)
    ctx->delete_fs_state = agx_delete_shader_state;
    ctx->delete_rasterizer_state = agx_delete_state;
    ctx->delete_sampler_state = agx_delete_sampler_state;
-   ctx->delete_vertex_elements_state = agx_delete_state;
+   ctx->delete_vertex_elements_state = agx_delete_vertex_elements;
    ctx->delete_vs_state = agx_delete_state;
    ctx->set_blend_color = agx_set_blend_color;
    ctx->set_clip_state = agx_set_clip_state;
diff --git a/src/gallium/drivers/asahi/agx_state.h b/src/gallium/drivers/asahi/agx_state.h
index 94f4b2796b11..811a57a4b344 100644
--- a/src/gallium/drivers/asahi/agx_state.h
+++ b/src/gallium/drivers/asahi/agx_state.h
@@ -153,7 +153,7 @@ struct agx_context {
    uint32_t vb_mask;
 
    struct agx_stage stage[PIPE_SHADER_TYPES];
-   struct agx_attribute *attributes;
+   struct agx_vertex_elements *attributes;
    struct agx_rasterizer *rast;
    struct agx_zsa zs;
    struct agx_blend *blend;
diff --git a/src/gallium/drivers/crocus/crocus_blit.c b/src/gallium/drivers/crocus/crocus_blit.c
index 321ba58c0a05..7526727798aa 100644
--- a/src/gallium/drivers/crocus/crocus_blit.c
+++ b/src/gallium/drivers/crocus/crocus_blit.c
@@ -43,7 +43,7 @@ void crocus_blitter_begin(struct crocus_context *ice, enum crocus_blitter_op op,
    util_blitter_save_so_targets(ice->blitter, ice->state.so_targets,
                                 (struct pipe_stream_output_target**)ice->state.so_target);
    util_blitter_save_vertex_buffer_slot(ice->blitter, ice->state.vertex_buffers);
-   util_blitter_save_vertex_elements(ice->blitter, (void *)ice->state.cso_vertex_elements);
+   util_blitter_save_vertex_elements(ice->blitter, (struct pipe_vertex_elements *)ice->state.cso_vertex_elements);
    if (op & CROCUS_SAVE_FRAGMENT_STATE) {
       util_blitter_save_blend(ice->blitter, ice->state.cso_blend);
       util_blitter_save_depth_stencil_alpha(ice->blitter, ice->state.cso_zsa);
diff --git a/src/gallium/drivers/crocus/crocus_state.c b/src/gallium/drivers/crocus/crocus_state.c
index 910183b4564f..49e22289d4d9 100644
--- a/src/gallium/drivers/crocus/crocus_state.c
+++ b/src/gallium/drivers/crocus/crocus_state.c
@@ -3654,6 +3654,12 @@ crocus_delete_state(struct pipe_context *ctx, void *state)
    free(state);
 }
 
+static void
+crocus_delete_vertex_elements(struct pipe_context *ctx, struct pipe_vertex_elements *state)
+{
+   free(state);
+}
+
 /**
  * The pipe->set_vertex_buffers() driver hook.
  *
@@ -3744,6 +3750,7 @@ static uint8_t get_wa_flags(enum isl_format format)
  * Gallium CSO for vertex elements.
  */
 struct crocus_vertex_element_state {
+   struct pipe_vertex_elements base; /* don't change, it's used by memcmp for CSO lookups */
    uint32_t vertex_elements[1 + 33 * GENX(VERTEX_ELEMENT_STATE_length)];
 #if GFX_VER == 8
    uint32_t vf_instancing[33 * GENX(3DSTATE_VF_INSTANCING_length)];
@@ -3768,21 +3775,21 @@ struct crocus_vertex_element_state {
  * 3DSTATE_VERTEX_ELEMENT and 3DSTATE_VF_INSTANCING that can be used at
  * draw time if we detect that EdgeFlag is needed by the Vertex Shader.
  */
-static void *
+static struct pipe_vertex_elements *
 crocus_create_vertex_elements(struct pipe_context *ctx,
-                              unsigned count,
-                              const struct pipe_vertex_element *state)
+                              const struct pipe_vertex_elements *state)
 {
    struct crocus_screen *screen = (struct crocus_screen *)ctx->screen;
    const struct intel_device_info *devinfo = &screen->devinfo;
    struct crocus_vertex_element_state *cso =
       malloc(sizeof(struct crocus_vertex_element_state));
 
-   cso->count = count;
+   cso->base = *state;
+   cso->count = state->count;
 
    crocus_pack_command(GENX(3DSTATE_VERTEX_ELEMENTS), cso->vertex_elements, ve) {
       ve.DWordLength =
-         1 + GENX(VERTEX_ELEMENT_STATE_length) * MAX2(count, 1) - 2;
+         1 + GENX(VERTEX_ELEMENT_STATE_length) * MAX2(state->count, 1) - 2;
    }
 
    uint32_t *ve_pack_dest = &cso->vertex_elements[1];
@@ -3790,7 +3797,7 @@ crocus_create_vertex_elements(struct pipe_context *ctx,
    uint32_t *vfi_pack_dest = cso->vf_instancing;
 #endif
 
-   if (count == 0) {
+   if (state->count == 0) {
       crocus_pack_state(GENX(VERTEX_ELEMENT_STATE), ve_pack_dest, ve) {
          ve.Valid = true;
          ve.SourceElementFormat = ISL_FORMAT_R32G32B32A32_FLOAT;
@@ -3805,9 +3812,9 @@ crocus_create_vertex_elements(struct pipe_context *ctx,
 #endif
    }
 
-   for (int i = 0; i < count; i++) {
+   for (int i = 0; i < state->count; i++) {
       const struct crocus_format_info fmt =
-         crocus_format_for_usage(devinfo, state[i].src_format, 0);
+         crocus_format_for_usage(devinfo, state->input[i].src_format, 0);
       unsigned comp[4] = { VFCOMP_STORE_SRC, VFCOMP_STORE_SRC,
                            VFCOMP_STORE_SRC, VFCOMP_STORE_SRC };
       enum isl_format actual_fmt = fmt.fmt;
@@ -3837,7 +3844,7 @@ crocus_create_vertex_elements(struct pipe_context *ctx,
          actual_fmt = ISL_FORMAT_R16G16B16A16_UINT;
 #endif
 
-      cso->step_rate[state[i].vertex_buffer_index] = state[i].instance_divisor;
+      cso->step_rate[state->input[i].vertex_buffer_index] = state->input[i].instance_divisor;
 
       switch (isl_format_get_num_channels(fmt.fmt)) {
       case 0: comp[0] = VFCOMP_STORE_0; FALLTHROUGH;
@@ -3852,9 +3859,9 @@ crocus_create_vertex_elements(struct pipe_context *ctx,
 #if GFX_VER >= 6
          ve.EdgeFlagEnable = false;
 #endif
-         ve.VertexBufferIndex = state[i].vertex_buffer_index;
+         ve.VertexBufferIndex = state->input[i].vertex_buffer_index;
          ve.Valid = true;
-         ve.SourceElementOffset = state[i].src_offset;
+         ve.SourceElementOffset = state->input[i].src_offset;
          ve.SourceElementFormat = actual_fmt;
          ve.Component0Control = comp[0];
          ve.Component1Control = comp[1];
@@ -3868,8 +3875,8 @@ crocus_create_vertex_elements(struct pipe_context *ctx,
 #if GFX_VER == 8
       crocus_pack_command(GENX(3DSTATE_VF_INSTANCING), vfi_pack_dest, vi) {
          vi.VertexElementIndex = i;
-         vi.InstancingEnable = state[i].instance_divisor > 0;
-         vi.InstanceDataStepRate = state[i].instance_divisor;
+         vi.InstancingEnable = state->input[i].instance_divisor > 0;
+         vi.InstanceDataStepRate = state->input[i].instance_divisor;
       }
 #endif
       ve_pack_dest += GENX(VERTEX_ELEMENT_STATE_length);
@@ -3881,17 +3888,17 @@ crocus_create_vertex_elements(struct pipe_context *ctx,
    /* An alternative version of the last VE and VFI is stored so it
     * can be used at draw time in case Vertex Shader uses EdgeFlag
     */
-   if (count) {
-      const unsigned edgeflag_index = count - 1;
+   if (state->count) {
+      const unsigned edgeflag_index = state->count - 1;
       const struct crocus_format_info fmt =
-         crocus_format_for_usage(devinfo, state[edgeflag_index].src_format, 0);
+         crocus_format_for_usage(devinfo, state->input[edgeflag_index].src_format, 0);
       crocus_pack_state(GENX(VERTEX_ELEMENT_STATE), cso->edgeflag_ve, ve) {
 #if GFX_VER >= 6
          ve.EdgeFlagEnable = true;
 #endif
-         ve.VertexBufferIndex = state[edgeflag_index].vertex_buffer_index;
+         ve.VertexBufferIndex = state->input[edgeflag_index].vertex_buffer_index;
          ve.Valid = true;
-         ve.SourceElementOffset = state[edgeflag_index].src_offset;
+         ve.SourceElementOffset = state->input[edgeflag_index].src_offset;
          ve.SourceElementFormat = fmt.fmt;
          ve.Component0Control = VFCOMP_STORE_SRC;
          ve.Component1Control = VFCOMP_STORE_0;
@@ -3903,30 +3910,30 @@ crocus_create_vertex_elements(struct pipe_context *ctx,
          /* The vi.VertexElementIndex of the EdgeFlag Vertex Element is filled
           * at draw time, as it should change if SGVs are emitted.
           */
-         vi.InstancingEnable = state[edgeflag_index].instance_divisor > 0;
-         vi.InstanceDataStepRate = state[edgeflag_index].instance_divisor;
+         vi.InstancingEnable = state->input[edgeflag_index].instance_divisor > 0;
+         vi.InstanceDataStepRate = state->input[edgeflag_index].instance_divisor;
       }
 #endif
    }
 
-   return cso;
+   return &cso->base;
 }
 
 /**
  * The pipe->bind_vertex_elements_state() driver hook.
  */
 static void
-crocus_bind_vertex_elements_state(struct pipe_context *ctx, void *state)
+crocus_bind_vertex_elements_state(struct pipe_context *ctx, struct pipe_vertex_elements *state)
 {
    struct crocus_context *ice = (struct crocus_context *) ctx;
 #if GFX_VER == 8
    struct crocus_vertex_element_state *old_cso = ice->state.cso_vertex_elements;
-   struct crocus_vertex_element_state *new_cso = state;
+   struct crocus_vertex_element_state *new_cso = (struct crocus_vertex_element_state *)state;
 
    if (new_cso && cso_changed(count))
       ice->state.dirty |= CROCUS_DIRTY_GEN8_VF_SGVS;
 #endif
-   ice->state.cso_vertex_elements = state;
+   ice->state.cso_vertex_elements = (struct crocus_vertex_element_state *)state;
    ice->state.dirty |= CROCUS_DIRTY_VERTEX_ELEMENTS | CROCUS_DIRTY_VERTEX_BUFFERS;
    ice->state.stage_dirty |= ice->state.stage_dirty_for_nos[CROCUS_NOS_VERTEX_ELEMENTS];
 }
@@ -9260,7 +9267,7 @@ genX(crocus_init_state)(struct crocus_context *ice)
    ctx->delete_depth_stencil_alpha_state = crocus_delete_state;
    ctx->delete_rasterizer_state = crocus_delete_state;
    ctx->delete_sampler_state = crocus_delete_state;
-   ctx->delete_vertex_elements_state = crocus_delete_state;
+   ctx->delete_vertex_elements_state = crocus_delete_vertex_elements;
    ctx->set_blend_color = crocus_set_blend_color;
    ctx->set_clip_state = crocus_set_clip_state;
    ctx->set_constant_buffer = crocus_set_constant_buffer;
diff --git a/src/gallium/drivers/d3d12/d3d12_blit.cpp b/src/gallium/drivers/d3d12/d3d12_blit.cpp
index 6bc1ab8299b5..d5017c44bd7d 100644
--- a/src/gallium/drivers/d3d12/d3d12_blit.cpp
+++ b/src/gallium/drivers/d3d12/d3d12_blit.cpp
@@ -539,7 +539,7 @@ util_blit_save_state(struct d3d12_context *ctx)
 {
    util_blitter_save_blend(ctx->blitter, ctx->gfx_pipeline_state.blend);
    util_blitter_save_depth_stencil_alpha(ctx->blitter, ctx->gfx_pipeline_state.zsa);
-   util_blitter_save_vertex_elements(ctx->blitter, ctx->gfx_pipeline_state.ves);
+   util_blitter_save_vertex_elements(ctx->blitter, &ctx->gfx_pipeline_state.ves->base);
    util_blitter_save_stencil_ref(ctx->blitter, &ctx->stencil_ref);
    util_blitter_save_rasterizer(ctx->blitter, ctx->gfx_pipeline_state.rast);
    util_blitter_save_fragment_shader(ctx->blitter, ctx->gfx_stages[PIPE_SHADER_FRAGMENT]);
diff --git a/src/gallium/drivers/d3d12/d3d12_context.cpp b/src/gallium/drivers/d3d12/d3d12_context.cpp
index ef52590c2bf4..6752ece6db7e 100644
--- a/src/gallium/drivers/d3d12/d3d12_context.cpp
+++ b/src/gallium/drivers/d3d12/d3d12_context.cpp
@@ -114,47 +114,48 @@ d3d12_context_destroy(struct pipe_context *pctx)
    FREE(ctx);
 }
 
-static void *
+static struct pipe_vertex_elements *
 d3d12_create_vertex_elements_state(struct pipe_context *pctx,
-                                   unsigned num_elements,
-                                   const struct pipe_vertex_element *elements)
+                                   const struct pipe_vertex_elements *elements)
 {
    struct d3d12_vertex_elements_state *cso = CALLOC_STRUCT(d3d12_vertex_elements_state);
    if (!cso)
       return NULL;
 
-   for (unsigned i = 0; i < num_elements; ++i) {
+   cso->base = *elements;
+
+   for (unsigned i = 0; i < elements->count; ++i) {
       cso->elements[i].SemanticName = "TEXCOORD";
       cso->elements[i].SemanticIndex = i;
 
       enum pipe_format format_helper =
-         d3d12_emulated_vtx_format((enum pipe_format)elements[i].src_format);
-      bool needs_emulation = format_helper != elements[i].src_format;
+         d3d12_emulated_vtx_format((enum pipe_format)elements->input[i].src_format);
+      bool needs_emulation = format_helper != elements->input[i].src_format;
       cso->needs_format_emulation |= needs_emulation;
       cso->format_conversion[i] =
-         needs_emulation ? (enum pipe_format)elements[i].src_format : PIPE_FORMAT_NONE;
+         needs_emulation ? (enum pipe_format)elements->input[i].src_format : PIPE_FORMAT_NONE;
 
       cso->elements[i].Format = d3d12_get_format(format_helper);
       assert(cso->elements[i].Format != DXGI_FORMAT_UNKNOWN);
-      cso->elements[i].InputSlot = elements[i].vertex_buffer_index;
-      cso->elements[i].AlignedByteOffset = elements[i].src_offset;
+      cso->elements[i].InputSlot = elements->input[i].vertex_buffer_index;
+      cso->elements[i].AlignedByteOffset = elements->input[i].src_offset;
 
-      if (elements[i].instance_divisor) {
+      if (elements->input[i].instance_divisor) {
          cso->elements[i].InputSlotClass = D3D12_INPUT_CLASSIFICATION_PER_INSTANCE_DATA;
-         cso->elements[i].InstanceDataStepRate = elements[i].instance_divisor;
+         cso->elements[i].InstanceDataStepRate = elements->input[i].instance_divisor;
       } else {
          cso->elements[i].InputSlotClass = D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA;
          cso->elements[i].InstanceDataStepRate = 0;
       }
    }
 
-   cso->num_elements = num_elements;
-   return cso;
+   cso->num_elements = elements->count;
+   return &cso->base;
 }
 
 static void
 d3d12_bind_vertex_elements_state(struct pipe_context *pctx,
-                                 void *ve)
+                                 struct pipe_vertex_elements *ve)
 {
    struct d3d12_context *ctx = d3d12_context(pctx);
    ctx->gfx_pipeline_state.ves = (struct d3d12_vertex_elements_state *)ve;
@@ -163,7 +164,7 @@ d3d12_bind_vertex_elements_state(struct pipe_context *pctx,
 
 static void
 d3d12_delete_vertex_elements_state(struct pipe_context *pctx,
-                                   void *ve)
+                                   struct pipe_vertex_elements *ve)
 {
    FREE(ve);
 }
diff --git a/src/gallium/drivers/d3d12/d3d12_pipeline_state.h b/src/gallium/drivers/d3d12/d3d12_pipeline_state.h
index 42d702371e75..0be36f363ad4 100644
--- a/src/gallium/drivers/d3d12/d3d12_pipeline_state.h
+++ b/src/gallium/drivers/d3d12/d3d12_pipeline_state.h
@@ -32,6 +32,7 @@ struct d3d12_context;
 struct d3d12_root_signature;
 
 struct d3d12_vertex_elements_state {
+   struct pipe_vertex_elements base; /* don't change, it's used by memcmp for CSO lookups */
    D3D12_INPUT_ELEMENT_DESC elements[PIPE_MAX_ATTRIBS];
    enum pipe_format format_conversion[PIPE_MAX_ATTRIBS];
    unsigned num_elements:6; // <= PIPE_MAX_ATTRIBS
diff --git a/src/gallium/drivers/etnaviv/etnaviv_clear_blit.c b/src/gallium/drivers/etnaviv/etnaviv_clear_blit.c
index 113f9cf53b7c..eb7b334d2238 100644
--- a/src/gallium/drivers/etnaviv/etnaviv_clear_blit.c
+++ b/src/gallium/drivers/etnaviv/etnaviv_clear_blit.c
@@ -52,7 +52,7 @@ etna_blit_save_state(struct etna_context *ctx)
    util_blitter_save_fragment_constant_buffer_slot(ctx->blitter,
                                                    ctx->constant_buffer[PIPE_SHADER_FRAGMENT].cb);
    util_blitter_save_vertex_buffer_slot(ctx->blitter, ctx->vertex_buffer.vb);
-   util_blitter_save_vertex_elements(ctx->blitter, ctx->vertex_elements);
+   util_blitter_save_vertex_elements(ctx->blitter, &ctx->vertex_elements->base);
    util_blitter_save_vertex_shader(ctx->blitter, ctx->shader.bind_vs);
    util_blitter_save_rasterizer(ctx->blitter, ctx->rasterizer);
    util_blitter_save_viewport(ctx->blitter, &ctx->viewport_s);
diff --git a/src/gallium/drivers/etnaviv/etnaviv_internal.h b/src/gallium/drivers/etnaviv/etnaviv_internal.h
index 7115abced6e2..8cdec743e4bb 100644
--- a/src/gallium/drivers/etnaviv/etnaviv_internal.h
+++ b/src/gallium/drivers/etnaviv/etnaviv_internal.h
@@ -35,6 +35,8 @@
 
 #include "drm/etnaviv_drmif.h"
 
+#include "pipe/p_state.h"
+
 #define ETNA_NUM_INPUTS (16)
 #define ETNA_NUM_VARYINGS 16
 #define ETNA_NUM_LOD (14)
@@ -212,6 +214,7 @@ struct compiled_framebuffer_state {
 
 /* Compiled context->create_vertex_elements_state */
 struct compiled_vertex_elements_state {
+   struct pipe_vertex_elements base; /* don't change, it's used by memcmp for CSO lookups */
    unsigned num_elements;
    uint32_t FE_VERTEX_ELEMENT_CONFIG[VIVS_FE_VERTEX_ELEMENT_CONFIG__LEN];
    uint32_t NFE_GENERIC_ATTRIB_CONFIG0[VIVS_NFE_GENERIC_ATTRIB__LEN];
diff --git a/src/gallium/drivers/etnaviv/etnaviv_state.c b/src/gallium/drivers/etnaviv/etnaviv_state.c
index 6cc7d92cddef..0257d8f49ef4 100644
--- a/src/gallium/drivers/etnaviv/etnaviv_state.c
+++ b/src/gallium/drivers/etnaviv/etnaviv_state.c
@@ -525,9 +525,9 @@ etna_zsa_state_delete(struct pipe_context *pctx, void *zs)
 /** Create vertex element states, which define a layout for fetching
  * vertices for rendering.
  */
-static void *
+static struct pipe_vertex_elements *
 etna_vertex_elements_state_create(struct pipe_context *pctx,
-      unsigned num_elements, const struct pipe_vertex_element *elements)
+      const struct pipe_vertex_elements *elements)
 {
    struct etna_context *ctx = etna_context(pctx);
    struct etna_screen *screen = ctx->screen;
@@ -536,30 +536,32 @@ etna_vertex_elements_state_create(struct pipe_context *pctx,
    if (!cs)
       return NULL;
 
-   if (num_elements > screen->specs.vertex_max_elements) {
-      BUG("number of elements (%u) exceeds chip maximum (%u)", num_elements,
+   if (elements->count > screen->specs.vertex_max_elements) {
+      BUG("number of elements (%u) exceeds chip maximum (%u)", elements->count,
           screen->specs.vertex_max_elements);
       FREE(cs);
       return NULL;
    }
 
+   cs->base = *elements;
+
    /* XXX could minimize number of consecutive stretches here by sorting, and
     * permuting the inputs in shader or does Mesa do this already? */
 
-   cs->num_elements = num_elements;
+   cs->num_elements = elements->count;
 
    unsigned start_offset = 0; /* start of current consecutive stretch */
    bool nonconsecutive = true; /* previous value of nonconsecutive */
    uint32_t buffer_mask = 0; /* mask of buffer_idx already seen */
 
-   for (unsigned idx = 0; idx < num_elements; ++idx) {
-      unsigned buffer_idx = elements[idx].vertex_buffer_index;
-      unsigned element_size = util_format_get_blocksize(elements[idx].src_format);
-      unsigned end_offset = elements[idx].src_offset + element_size;
+   for (unsigned idx = 0; idx < elements->count; ++idx) {
+      unsigned buffer_idx = elements->input[idx].vertex_buffer_index;
+      unsigned element_size = util_format_get_blocksize(elements->input[idx].src_format);
+      unsigned end_offset = elements->input[idx].src_offset + element_size;
       uint32_t format_type, normalize;
 
       if (nonconsecutive)
-         start_offset = elements[idx].src_offset;
+         start_offset = elements->input[idx].src_offset;
 
       /* guaranteed by PIPE_CAP_MAX_VERTEX_BUFFERS */
       assert(buffer_idx < screen->specs.stream_count);
@@ -568,12 +570,12 @@ etna_vertex_elements_state_create(struct pipe_context *pctx,
       assert(element_size != 0 && (end_offset - start_offset) < 256);
 
       /* check whether next element is consecutive to this one */
-      nonconsecutive = (idx == (num_elements - 1)) ||
-                       elements[idx + 1].vertex_buffer_index != buffer_idx ||
-                       end_offset != elements[idx + 1].src_offset;
+      nonconsecutive = (idx == (elements->count - 1)) ||
+                       elements->input[idx + 1].vertex_buffer_index != buffer_idx ||
+                       end_offset != elements->input[idx + 1].src_offset;
 
-      format_type = translate_vertex_format_type(elements[idx].src_format);
-      normalize = translate_vertex_format_normalize(elements[idx].src_format);
+      format_type = translate_vertex_format_type(elements->input[idx].src_format);
+      normalize = translate_vertex_format_normalize(elements->input[idx].src_format);
 
       assert(format_type != ETNA_NO_MATCH);
       assert(normalize != ETNA_NO_MATCH);
@@ -582,53 +584,53 @@ etna_vertex_elements_state_create(struct pipe_context *pctx,
          cs->FE_VERTEX_ELEMENT_CONFIG[idx] =
             COND(nonconsecutive, VIVS_FE_VERTEX_ELEMENT_CONFIG_NONCONSECUTIVE) |
             format_type |
-            VIVS_FE_VERTEX_ELEMENT_CONFIG_NUM(util_format_get_nr_components(elements[idx].src_format)) |
+            VIVS_FE_VERTEX_ELEMENT_CONFIG_NUM(util_format_get_nr_components(elements->input[idx].src_format)) |
             normalize | VIVS_FE_VERTEX_ELEMENT_CONFIG_ENDIAN(ENDIAN_MODE_NO_SWAP) |
             VIVS_FE_VERTEX_ELEMENT_CONFIG_STREAM(buffer_idx) |
-            VIVS_FE_VERTEX_ELEMENT_CONFIG_START(elements[idx].src_offset) |
+            VIVS_FE_VERTEX_ELEMENT_CONFIG_START(elements->input[idx].src_offset) |
             VIVS_FE_VERTEX_ELEMENT_CONFIG_END(end_offset - start_offset);
       } else { /* HALTI5 spread vertex attrib config over two registers */
          cs->NFE_GENERIC_ATTRIB_CONFIG0[idx] =
             format_type |
-            VIVS_NFE_GENERIC_ATTRIB_CONFIG0_NUM(util_format_get_nr_components(elements[idx].src_format)) |
+            VIVS_NFE_GENERIC_ATTRIB_CONFIG0_NUM(util_format_get_nr_components(elements->input[idx].src_format)) |
             normalize | VIVS_NFE_GENERIC_ATTRIB_CONFIG0_ENDIAN(ENDIAN_MODE_NO_SWAP) |
             VIVS_NFE_GENERIC_ATTRIB_CONFIG0_STREAM(buffer_idx) |
-            VIVS_NFE_GENERIC_ATTRIB_CONFIG0_START(elements[idx].src_offset);
+            VIVS_NFE_GENERIC_ATTRIB_CONFIG0_START(elements->input[idx].src_offset);
          cs->NFE_GENERIC_ATTRIB_CONFIG1[idx] =
             COND(nonconsecutive, VIVS_NFE_GENERIC_ATTRIB_CONFIG1_NONCONSECUTIVE) |
             VIVS_NFE_GENERIC_ATTRIB_CONFIG1_END(end_offset - start_offset);
       }
 
-      if (util_format_is_pure_integer(elements[idx].src_format))
+      if (util_format_is_pure_integer(elements->input[idx].src_format))
          cs->NFE_GENERIC_ATTRIB_SCALE[idx] = 1;
       else
          cs->NFE_GENERIC_ATTRIB_SCALE[idx] = fui(1.0f);
 
       /* instance_divisor is part of elements state but should be the same for all buffers */
       if (buffer_mask & 1 << buffer_idx)
-         assert(cs->NFE_VERTEX_STREAMS_VERTEX_DIVISOR[buffer_idx] == elements[idx].instance_divisor);
+         assert(cs->NFE_VERTEX_STREAMS_VERTEX_DIVISOR[buffer_idx] == elements->input[idx].instance_divisor);
       else
-         cs->NFE_VERTEX_STREAMS_VERTEX_DIVISOR[buffer_idx] = elements[idx].instance_divisor;
+         cs->NFE_VERTEX_STREAMS_VERTEX_DIVISOR[buffer_idx] = elements->input[idx].instance_divisor;
 
       buffer_mask |= 1 << buffer_idx;
       cs->num_buffers = MAX2(cs->num_buffers, buffer_idx + 1);
    }
 
-   return cs;
+   return &cs->base;
 }
 
 static void
-etna_vertex_elements_state_delete(struct pipe_context *pctx, void *ve)
+etna_vertex_elements_state_delete(struct pipe_context *pctx, struct pipe_vertex_elements *ve)
 {
    FREE(ve);
 }
 
 static void
-etna_vertex_elements_state_bind(struct pipe_context *pctx, void *ve)
+etna_vertex_elements_state_bind(struct pipe_context *pctx, struct pipe_vertex_elements *ve)
 {
    struct etna_context *ctx = etna_context(pctx);
 
-   ctx->vertex_elements = ve;
+   ctx->vertex_elements = (struct compiled_vertex_elements_state *)ve;
    ctx->dirty |= ETNA_DIRTY_VERTEX_ELEMENTS;
 }
 
diff --git a/src/gallium/drivers/freedreno/a2xx/fd2_draw.c b/src/gallium/drivers/freedreno/a2xx/fd2_draw.c
index 6bcfdf558445..fe4248cd5912 100644
--- a/src/gallium/drivers/freedreno/a2xx/fd2_draw.c
+++ b/src/gallium/drivers/freedreno/a2xx/fd2_draw.c
@@ -53,16 +53,16 @@ emit_cacheflush(struct fd_ringbuffer *ring)
 static void
 emit_vertexbufs(struct fd_context *ctx) assert_dt
 {
-   struct fd_vertex_stateobj *vtx = ctx->vtx.vtx;
+   struct pipe_vertex_elements *vtx = ctx->vtx.vtx;
    struct fd_vertexbuf_stateobj *vertexbuf = &ctx->vtx.vertexbuf;
    struct fd2_vertex_buf bufs[PIPE_MAX_ATTRIBS];
    unsigned i;
 
-   if (!vtx->num_elements)
+   if (!vtx->count)
       return;
 
-   for (i = 0; i < vtx->num_elements; i++) {
-      struct pipe_vertex_element *elem = &vtx->pipe[i];
+   for (i = 0; i < vtx->count; i++) {
+      struct pipe_vertex_element *elem = &vtx->input[i];
       struct pipe_vertex_buffer *vb = &vertexbuf->vb[elem->vertex_buffer_index];
       bufs[i].offset = vb->buffer_offset;
       bufs[i].size = fd_bo_size(fd_resource(vb->buffer.resource)->bo);
@@ -72,8 +72,8 @@ emit_vertexbufs(struct fd_context *ctx) assert_dt
    // NOTE I believe the 0x78 (or 0x9c in solid_vp) relates to the
    // CONST(20,0) (or CONST(26,0) in soliv_vp)
 
-   fd2_emit_vertex_bufs(ctx->batch->draw, 0x78, bufs, vtx->num_elements);
-   fd2_emit_vertex_bufs(ctx->batch->binning, 0x78, bufs, vtx->num_elements);
+   fd2_emit_vertex_bufs(ctx->batch->draw, 0x78, bufs, vtx->count);
+   fd2_emit_vertex_bufs(ctx->batch->binning, 0x78, bufs, vtx->count);
 }
 
 static void
diff --git a/src/gallium/drivers/freedreno/a2xx/fd2_program.c b/src/gallium/drivers/freedreno/a2xx/fd2_program.c
index 46f0124fdf75..d203217a8ec3 100644
--- a/src/gallium/drivers/freedreno/a2xx/fd2_program.c
+++ b/src/gallium/drivers/freedreno/a2xx/fd2_program.c
@@ -182,7 +182,7 @@ patch_vtx_fetch(struct fd_context *ctx, struct pipe_vertex_element *elem,
 
 static void
 patch_fetches(struct fd_context *ctx, struct ir2_shader_info *info,
-              struct fd_vertex_stateobj *vtx,
+              struct pipe_vertex_elements *vtx,
               struct fd_texture_stateobj *tex) assert_dt
 {
    for (int i = 0; i < info->num_fetch_instrs; i++) {
@@ -192,7 +192,7 @@ patch_fetches(struct fd_context *ctx, struct ir2_shader_info *info,
       if (instr->opc == VTX_FETCH) {
          unsigned idx =
             (instr->vtx.const_index - 20) * 3 + instr->vtx.const_index_sel;
-         patch_vtx_fetch(ctx, &vtx->pipe[idx], &instr->vtx, fi->vtx.dst_swiz);
+         patch_vtx_fetch(ctx, &vtx->input[idx], &instr->vtx, fi->vtx.dst_swiz);
          continue;
       }
 
diff --git a/src/gallium/drivers/freedreno/a3xx/fd3_emit.c b/src/gallium/drivers/freedreno/a3xx/fd3_emit.c
index 397a9ff83a63..525e6c51ef1e 100644
--- a/src/gallium/drivers/freedreno/a3xx/fd3_emit.c
+++ b/src/gallium/drivers/freedreno/a3xx/fd3_emit.c
@@ -403,7 +403,7 @@ fd3_emit_vertex_bufs(struct fd_ringbuffer *ring, struct fd3_emit *emit)
             unreachable("invalid system value");
             break;
          }
-      } else if (i < vtx->vtx->num_elements) {
+      } else if (i < vtx->vtx->count) {
          last = i;
       }
    }
@@ -411,7 +411,7 @@ fd3_emit_vertex_bufs(struct fd_ringbuffer *ring, struct fd3_emit *emit)
    for (i = 0, j = 0; i <= last; i++) {
       assert(!vp->inputs[i].sysval);
       if (vp->inputs[i].compmask) {
-         struct pipe_vertex_element *elem = &vtx->vtx->pipe[i];
+         struct pipe_vertex_element *elem = &vtx->vtx->input[i];
          const struct pipe_vertex_buffer *vb =
             &vtx->vertexbuf.vb[elem->vertex_buffer_index];
          struct fd_resource *rsc = fd_resource(vb->buffer.resource);
diff --git a/src/gallium/drivers/freedreno/a4xx/fd4_emit.c b/src/gallium/drivers/freedreno/a4xx/fd4_emit.c
index aaff962ec0b9..69b3970e82fa 100644
--- a/src/gallium/drivers/freedreno/a4xx/fd4_emit.c
+++ b/src/gallium/drivers/freedreno/a4xx/fd4_emit.c
@@ -548,7 +548,7 @@ fd4_emit_vertex_bufs(struct fd_ringbuffer *ring, struct fd4_emit *emit)
             unreachable("invalid system value");
             break;
          }
-      } else if (i < vtx->vtx->num_elements) {
+      } else if (i < vtx->vtx->count) {
          last = i;
       }
    }
@@ -556,7 +556,7 @@ fd4_emit_vertex_bufs(struct fd_ringbuffer *ring, struct fd4_emit *emit)
    for (i = 0, j = 0; i <= last; i++) {
       assert(!vp->inputs[i].sysval);
       if (vp->inputs[i].compmask) {
-         struct pipe_vertex_element *elem = &vtx->vtx->pipe[i];
+         struct pipe_vertex_element *elem = &vtx->vtx->input[i];
          const struct pipe_vertex_buffer *vb =
             &vtx->vertexbuf.vb[elem->vertex_buffer_index];
          struct fd_resource *rsc = fd_resource(vb->buffer.resource);
diff --git a/src/gallium/drivers/freedreno/a5xx/fd5_emit.c b/src/gallium/drivers/freedreno/a5xx/fd5_emit.c
index f290445a8c82..3ee9e3ae3e42 100644
--- a/src/gallium/drivers/freedreno/a5xx/fd5_emit.c
+++ b/src/gallium/drivers/freedreno/a5xx/fd5_emit.c
@@ -479,7 +479,7 @@ fd5_emit_vertex_bufs(struct fd_ringbuffer *ring, struct fd5_emit *emit)
       if (vp->inputs[i].sysval)
          continue;
       if (vp->inputs[i].compmask) {
-         struct pipe_vertex_element *elem = &vtx->vtx->pipe[i];
+         struct pipe_vertex_element *elem = &vtx->vtx->input[i];
          const struct pipe_vertex_buffer *vb =
             &vtx->vertexbuf.vb[elem->vertex_buffer_index];
          struct fd_resource *rsc = fd_resource(vb->buffer.resource);
diff --git a/src/gallium/drivers/freedreno/a6xx/fd6_context.c b/src/gallium/drivers/freedreno/a6xx/fd6_context.c
index af001e36739d..4f851fe371f3 100644
--- a/src/gallium/drivers/freedreno/a6xx/fd6_context.c
+++ b/src/gallium/drivers/freedreno/a6xx/fd6_context.c
@@ -69,22 +69,21 @@ fd6_context_destroy(struct pipe_context *pctx) in_dt
    free(fd6_ctx);
 }
 
-static void *
-fd6_vertex_state_create(struct pipe_context *pctx, unsigned num_elements,
-                        const struct pipe_vertex_element *elements)
+static struct pipe_vertex_elements *
+fd6_vertex_state_create(struct pipe_context *pctx,
+                        const struct pipe_vertex_elements *elements)
 {
    struct fd_context *ctx = fd_context(pctx);
 
    struct fd6_vertex_stateobj *state = CALLOC_STRUCT(fd6_vertex_stateobj);
-   memcpy(state->base.pipe, elements, sizeof(*elements) * num_elements);
-   state->base.num_elements = num_elements;
+   state->base = *elements;
    state->stateobj =
-      fd_ringbuffer_new_object(ctx->pipe, 4 * (num_elements * 2 + 1));
+      fd_ringbuffer_new_object(ctx->pipe, 4 * (elements->count * 2 + 1));
    struct fd_ringbuffer *ring = state->stateobj;
 
-   OUT_PKT4(ring, REG_A6XX_VFD_DECODE(0), 2 * num_elements);
-   for (int32_t i = 0; i < num_elements; i++) {
-      const struct pipe_vertex_element *elem = &elements[i];
+   OUT_PKT4(ring, REG_A6XX_VFD_DECODE(0), 2 * elements->count);
+   for (int32_t i = 0; i < elements->count; i++) {
+      const struct pipe_vertex_element *elem = &elements->input[i];
       enum pipe_format pfmt = elem->src_format;
       enum a6xx_format fmt = fd6_vertex_format(pfmt);
       bool isint = util_format_is_pure_integer(pfmt);
@@ -102,13 +101,13 @@ fd6_vertex_state_create(struct pipe_context *pctx, unsigned num_elements,
                MAX2(1, elem->instance_divisor)); /* VFD_DECODE[j].STEP_RATE */
    }
 
-   return state;
+   return &state->base;
 }
 
 static void
-fd6_vertex_state_delete(struct pipe_context *pctx, void *hwcso)
+fd6_vertex_state_delete(struct pipe_context *pctx, struct pipe_vertex_elements *hwcso)
 {
-   struct fd6_vertex_stateobj *so = hwcso;
+   struct fd6_vertex_stateobj *so = (struct fd6_vertex_stateobj *)hwcso;
 
    fd_ringbuffer_del(so->stateobj);
    FREE(hwcso);
diff --git a/src/gallium/drivers/freedreno/a6xx/fd6_context.h b/src/gallium/drivers/freedreno/a6xx/fd6_context.h
index 122642e4e886..f107ccd96be0 100644
--- a/src/gallium/drivers/freedreno/a6xx/fd6_context.h
+++ b/src/gallium/drivers/freedreno/a6xx/fd6_context.h
@@ -135,7 +135,7 @@ emit_marker6(struct fd_ringbuffer *ring, int scratch_idx)
 }
 
 struct fd6_vertex_stateobj {
-   struct fd_vertex_stateobj base;
+   struct pipe_vertex_elements base;
    struct fd_ringbuffer *stateobj;
 };
 
diff --git a/src/gallium/drivers/freedreno/freedreno_context.c b/src/gallium/drivers/freedreno/freedreno_context.c
index 15e0934f1a27..08563889fc24 100644
--- a/src/gallium/drivers/freedreno/freedreno_context.c
+++ b/src/gallium/drivers/freedreno/freedreno_context.c
@@ -540,11 +540,13 @@ fd_context_setup_common_vbos(struct fd_context *ctx)
 
    /* setup solid_vbuf_state: */
    ctx->solid_vbuf_state.vtx = pctx->create_vertex_elements_state(
-      pctx, 1,
-      (struct pipe_vertex_element[]){{
-         .vertex_buffer_index = 0,
-         .src_offset = 0,
-         .src_format = PIPE_FORMAT_R32G32B32_FLOAT,
+      pctx,
+      (struct pipe_vertex_elements[]){{
+         .count = 1,
+         .input = {{
+            .vertex_buffer_index = 0,
+            .src_offset = 0,
+            .src_format = PIPE_FORMAT_R32G32B32_FLOAT}}
       }});
    ctx->solid_vbuf_state.vertexbuf.count = 1;
    ctx->solid_vbuf_state.vertexbuf.vb[0].stride = 12;
@@ -552,18 +554,21 @@ fd_context_setup_common_vbos(struct fd_context *ctx)
 
    /* setup blit_vbuf_state: */
    ctx->blit_vbuf_state.vtx = pctx->create_vertex_elements_state(
-      pctx, 2,
-      (struct pipe_vertex_element[]){
-         {
-            .vertex_buffer_index = 0,
-            .src_offset = 0,
-            .src_format = PIPE_FORMAT_R32G32_FLOAT,
-         },
-         {
-            .vertex_buffer_index = 1,
-            .src_offset = 0,
-            .src_format = PIPE_FORMAT_R32G32B32_FLOAT,
-         }});
+      pctx,
+      (struct pipe_vertex_elements[]){{
+         .count = 2,
+         .input = {
+            {
+               .vertex_buffer_index = 0,
+               .src_offset = 0,
+               .src_format = PIPE_FORMAT_R32G32_FLOAT,
+            },
+            {
+               .vertex_buffer_index = 1,
+               .src_offset = 0,
+               .src_format = PIPE_FORMAT_R32G32B32_FLOAT,
+            }
+         }}});
    ctx->blit_vbuf_state.vertexbuf.count = 2;
    ctx->blit_vbuf_state.vertexbuf.vb[0].stride = 8;
    ctx->blit_vbuf_state.vertexbuf.vb[0].buffer.resource =
diff --git a/src/gallium/drivers/freedreno/freedreno_context.h b/src/gallium/drivers/freedreno/freedreno_context.h
index 106f027e1c60..2a0c7a77da95 100644
--- a/src/gallium/drivers/freedreno/freedreno_context.h
+++ b/src/gallium/drivers/freedreno/freedreno_context.h
@@ -48,7 +48,7 @@ extern "C" {
 
 #define BORDER_COLOR_UPLOAD_SIZE (2 * PIPE_MAX_SAMPLERS * BORDERCOLOR_SIZE)
 
-struct fd_vertex_stateobj;
+struct pipe_vertex_elements;
 struct fd_batch;
 
 struct fd_texture_stateobj {
@@ -86,11 +86,6 @@ struct fd_vertexbuf_stateobj {
    uint32_t enabled_mask;
 };
 
-struct fd_vertex_stateobj {
-   struct pipe_vertex_element pipe[PIPE_MAX_ATTRIBS];
-   unsigned num_elements;
-};
-
 struct fd_stream_output_target {
    struct pipe_stream_output_target base;
    struct pipe_resource *offset_buf;
@@ -138,7 +133,7 @@ struct fd_global_bindings_stateobj {
  * need their own vertex state:
  */
 struct fd_vertex_state {
-   struct fd_vertex_stateobj *vtx;
+   struct pipe_vertex_elements *vtx;
    struct fd_vertexbuf_stateobj vertexbuf;
 };
 
diff --git a/src/gallium/drivers/freedreno/freedreno_state.c b/src/gallium/drivers/freedreno/freedreno_state.c
index cee035f679f0..ae21784f4442 100644
--- a/src/gallium/drivers/freedreno/freedreno_state.c
+++ b/src/gallium/drivers/freedreno/freedreno_state.c
@@ -492,29 +492,27 @@ fd_zsa_state_delete(struct pipe_context *pctx, void *hwcso) in_dt
    FREE(hwcso);
 }
 
-static void *
-fd_vertex_state_create(struct pipe_context *pctx, unsigned num_elements,
-                       const struct pipe_vertex_element *elements)
+static struct pipe_vertex_elements *
+fd_vertex_state_create(struct pipe_context *pctx,
+                       const struct pipe_vertex_elements *elements)
 {
-   struct fd_vertex_stateobj *so = CALLOC_STRUCT(fd_vertex_stateobj);
+   struct pipe_vertex_elements *so = CALLOC_STRUCT(pipe_vertex_elements);
 
    if (!so)
       return NULL;
 
-   memcpy(so->pipe, elements, sizeof(*elements) * num_elements);
-   so->num_elements = num_elements;
-
+   *so = *elements;
    return so;
 }
 
 static void
-fd_vertex_state_delete(struct pipe_context *pctx, void *hwcso) in_dt
+fd_vertex_state_delete(struct pipe_context *pctx, struct pipe_vertex_elements *hwcso) in_dt
 {
    FREE(hwcso);
 }
 
 static void
-fd_vertex_state_bind(struct pipe_context *pctx, void *hwcso) in_dt
+fd_vertex_state_bind(struct pipe_context *pctx, struct pipe_vertex_elements *hwcso) in_dt
 {
    struct fd_context *ctx = fd_context(pctx);
    ctx->vtx.vtx = hwcso;
diff --git a/src/gallium/drivers/i915/i915_context.h b/src/gallium/drivers/i915/i915_context.h
index 2ff659bdb2a0..ea8385a2c716 100644
--- a/src/gallium/drivers/i915/i915_context.h
+++ b/src/gallium/drivers/i915/i915_context.h
@@ -237,11 +237,6 @@ struct i915_surface {
    bool alpha_is_x : 1;
 };
 
-struct i915_velems_state {
-   unsigned count;
-   struct pipe_vertex_element velem[PIPE_MAX_ATTRIBS];
-};
-
 struct i915_context {
    struct pipe_context base;
 
@@ -261,7 +256,7 @@ struct i915_context {
 
    void *vs;
 
-   struct i915_velems_state *velems;
+   struct pipe_vertex_elements *velems;
    unsigned nr_vertex_buffers;
    struct pipe_vertex_buffer vertex_buffers[PIPE_MAX_ATTRIBS];
 
diff --git a/src/gallium/drivers/i915/i915_state.c b/src/gallium/drivers/i915/i915_state.c
index 74670ba7e0a2..fa039bbd5aa7 100644
--- a/src/gallium/drivers/i915/i915_state.c
+++ b/src/gallium/drivers/i915/i915_state.c
@@ -980,26 +980,24 @@ i915_set_vertex_buffers(struct pipe_context *pipe, unsigned start_slot,
                            buffers);
 }
 
-static void *
-i915_create_vertex_elements_state(struct pipe_context *pipe, unsigned count,
-                                  const struct pipe_vertex_element *attribs)
+static struct pipe_vertex_elements *
+i915_create_vertex_elements_state(struct pipe_context *pipe,
+                                  const struct pipe_vertex_elements *attribs)
 {
-   struct i915_velems_state *velems;
-   assert(count <= PIPE_MAX_ATTRIBS);
+   struct pipe_vertex_elements *velems;
+   assert(attribs->count <= PIPE_MAX_ATTRIBS);
    velems =
-      (struct i915_velems_state *)MALLOC(sizeof(struct i915_velems_state));
-   if (velems) {
-      velems->count = count;
-      memcpy(velems->velem, attribs, sizeof(*attribs) * count);
-   }
+      (struct pipe_vertex_elements *)MALLOC(sizeof(struct pipe_vertex_elements));
+   if (velems)
+      *velems = *attribs;
    return velems;
 }
 
 static void
-i915_bind_vertex_elements_state(struct pipe_context *pipe, void *velems)
+i915_bind_vertex_elements_state(struct pipe_context *pipe,
+                                struct pipe_vertex_elements *velems)
 {
    struct i915_context *i915 = i915_context(pipe);
-   struct i915_velems_state *i915_velems = (struct i915_velems_state *)velems;
 
    if (i915->velems == velems)
       return;
@@ -1007,14 +1005,15 @@ i915_bind_vertex_elements_state(struct pipe_context *pipe, void *velems)
    i915->velems = velems;
 
    /* pass-through to draw module */
-   if (i915_velems) {
-      draw_set_vertex_elements(i915->draw, i915_velems->count,
-                               i915_velems->velem);
+   if (velems) {
+      draw_set_vertex_elements(i915->draw, velems->count,
+                               velems->input);
    }
 }
 
 static void
-i915_delete_vertex_elements_state(struct pipe_context *pipe, void *velems)
+i915_delete_vertex_elements_state(struct pipe_context *pipe,
+                                  struct pipe_vertex_elements *velems)
 {
    FREE(velems);
 }
diff --git a/src/gallium/drivers/iris/iris_state.c b/src/gallium/drivers/iris/iris_state.c
index de36a292dbb8..36cf021d12d6 100644
--- a/src/gallium/drivers/iris/iris_state.c
+++ b/src/gallium/drivers/iris/iris_state.c
@@ -3559,6 +3559,12 @@ iris_delete_state(struct pipe_context *ctx, void *state)
    free(state);
 }
 
+static void
+iris_delete_vertex_elements(struct pipe_context *ctx, struct pipe_vertex_elements *state)
+{
+   free(state);
+}
+
 /**
  * The pipe->set_vertex_buffers() driver hook.
  *
@@ -3645,11 +3651,11 @@ iris_set_vertex_buffers(struct pipe_context *ctx,
  * Gallium CSO for vertex elements.
  */
 struct iris_vertex_element_state {
+   struct pipe_vertex_elements base; /* don't change, it's used by memcmp for CSO lookups */
    uint32_t vertex_elements[1 + 33 * GENX(VERTEX_ELEMENT_STATE_length)];
    uint32_t vf_instancing[33 * GENX(3DSTATE_VF_INSTANCING_length)];
    uint32_t edgeflag_ve[GENX(VERTEX_ELEMENT_STATE_length)];
    uint32_t edgeflag_vfi[GENX(3DSTATE_VF_INSTANCING_length)];
-   unsigned count;
 };
 
 /**
@@ -3663,27 +3669,26 @@ struct iris_vertex_element_state {
  * 3DSTATE_VERTEX_ELEMENT and 3DSTATE_VF_INSTANCING that can be used at
  * draw time if we detect that EdgeFlag is needed by the Vertex Shader.
  */
-static void *
+static struct pipe_vertex_elements *
 iris_create_vertex_elements(struct pipe_context *ctx,
-                            unsigned count,
-                            const struct pipe_vertex_element *state)
+                            const struct pipe_vertex_elements *state)
 {
    struct iris_screen *screen = (struct iris_screen *)ctx->screen;
    const struct intel_device_info *devinfo = &screen->devinfo;
    struct iris_vertex_element_state *cso =
       malloc(sizeof(struct iris_vertex_element_state));
 
-   cso->count = count;
+   cso->base = *state;
 
    iris_pack_command(GENX(3DSTATE_VERTEX_ELEMENTS), cso->vertex_elements, ve) {
       ve.DWordLength =
-         1 + GENX(VERTEX_ELEMENT_STATE_length) * MAX2(count, 1) - 2;
+         1 + GENX(VERTEX_ELEMENT_STATE_length) * MAX2(state->count, 1) - 2;
    }
 
    uint32_t *ve_pack_dest = &cso->vertex_elements[1];
    uint32_t *vfi_pack_dest = cso->vf_instancing;
 
-   if (count == 0) {
+   if (state->count == 0) {
       iris_pack_state(GENX(VERTEX_ELEMENT_STATE), ve_pack_dest, ve) {
          ve.Valid = true;
          ve.SourceElementFormat = ISL_FORMAT_R32G32B32A32_FLOAT;
@@ -3697,9 +3702,9 @@ iris_create_vertex_elements(struct pipe_context *ctx,
       }
    }
 
-   for (int i = 0; i < count; i++) {
+   for (int i = 0; i < state->count; i++) {
       const struct iris_format_info fmt =
-         iris_format_for_usage(devinfo, state[i].src_format, 0);
+         iris_format_for_usage(devinfo, state->input[i].src_format, 0);
       unsigned comp[4] = { VFCOMP_STORE_SRC, VFCOMP_STORE_SRC,
                            VFCOMP_STORE_SRC, VFCOMP_STORE_SRC };
 
@@ -3714,9 +3719,9 @@ iris_create_vertex_elements(struct pipe_context *ctx,
       }
       iris_pack_state(GENX(VERTEX_ELEMENT_STATE), ve_pack_dest, ve) {
          ve.EdgeFlagEnable = false;
-         ve.VertexBufferIndex = state[i].vertex_buffer_index;
+         ve.VertexBufferIndex = state->input[i].vertex_buffer_index;
          ve.Valid = true;
-         ve.SourceElementOffset = state[i].src_offset;
+         ve.SourceElementOffset = state->input[i].src_offset;
          ve.SourceElementFormat = fmt.fmt;
          ve.Component0Control = comp[0];
          ve.Component1Control = comp[1];
@@ -3726,8 +3731,8 @@ iris_create_vertex_elements(struct pipe_context *ctx,
 
       iris_pack_command(GENX(3DSTATE_VF_INSTANCING), vfi_pack_dest, vi) {
          vi.VertexElementIndex = i;
-         vi.InstancingEnable = state[i].instance_divisor > 0;
-         vi.InstanceDataStepRate = state[i].instance_divisor;
+         vi.InstancingEnable = state->input[i].instance_divisor > 0;
+         vi.InstanceDataStepRate = state->input[i].instance_divisor;
       }
 
       ve_pack_dest += GENX(VERTEX_ELEMENT_STATE_length);
@@ -3737,15 +3742,15 @@ iris_create_vertex_elements(struct pipe_context *ctx,
    /* An alternative version of the last VE and VFI is stored so it
     * can be used at draw time in case Vertex Shader uses EdgeFlag
     */
-   if (count) {
-      const unsigned edgeflag_index = count - 1;
+   if (state->count) {
+      const unsigned edgeflag_index = state->count - 1;
       const struct iris_format_info fmt =
-         iris_format_for_usage(devinfo, state[edgeflag_index].src_format, 0);
+         iris_format_for_usage(devinfo, state->input[edgeflag_index].src_format, 0);
       iris_pack_state(GENX(VERTEX_ELEMENT_STATE), cso->edgeflag_ve, ve) {
          ve.EdgeFlagEnable = true ;
-         ve.VertexBufferIndex = state[edgeflag_index].vertex_buffer_index;
+         ve.VertexBufferIndex = state->input[edgeflag_index].vertex_buffer_index;
          ve.Valid = true;
-         ve.SourceElementOffset = state[edgeflag_index].src_offset;
+         ve.SourceElementOffset = state->input[edgeflag_index].src_offset;
          ve.SourceElementFormat = fmt.fmt;
          ve.Component0Control = VFCOMP_STORE_SRC;
          ve.Component1Control = VFCOMP_STORE_0;
@@ -3756,31 +3761,31 @@ iris_create_vertex_elements(struct pipe_context *ctx,
          /* The vi.VertexElementIndex of the EdgeFlag Vertex Element is filled
           * at draw time, as it should change if SGVs are emitted.
           */
-         vi.InstancingEnable = state[edgeflag_index].instance_divisor > 0;
-         vi.InstanceDataStepRate = state[edgeflag_index].instance_divisor;
+         vi.InstancingEnable = state->input[edgeflag_index].instance_divisor > 0;
+         vi.InstanceDataStepRate = state->input[edgeflag_index].instance_divisor;
       }
    }
 
-   return cso;
+   return &cso->base;
 }
 
 /**
  * The pipe->bind_vertex_elements_state() driver hook.
  */
 static void
-iris_bind_vertex_elements_state(struct pipe_context *ctx, void *state)
+iris_bind_vertex_elements_state(struct pipe_context *ctx, struct pipe_vertex_elements *state)
 {
    struct iris_context *ice = (struct iris_context *) ctx;
    struct iris_vertex_element_state *old_cso = ice->state.cso_vertex_elements;
-   struct iris_vertex_element_state *new_cso = state;
+   struct iris_vertex_element_state *new_cso = (struct iris_vertex_element_state *)state;
 
    /* 3DSTATE_VF_SGVs overrides the last VE, so if the count is changing,
     * we need to re-emit it to ensure we're overriding the right one.
     */
-   if (new_cso && cso_changed(count))
+   if (new_cso && cso_changed(base.count))
       ice->state.dirty |= IRIS_DIRTY_VF_SGVS;
 
-   ice->state.cso_vertex_elements = state;
+   ice->state.cso_vertex_elements = new_cso;
    ice->state.dirty |= IRIS_DIRTY_VERTEX_ELEMENTS;
 }
 
@@ -6658,7 +6663,7 @@ iris_upload_dirty_render_state(struct iris_context *ice,
 
    if (dirty & IRIS_DIRTY_VERTEX_ELEMENTS) {
       struct iris_vertex_element_state *cso = ice->state.cso_vertex_elements;
-      const unsigned entries = MAX2(cso->count, 1);
+      const unsigned entries = MAX2(cso->base.count, 1);
       if (!(ice->state.vs_needs_sgvs_element ||
             ice->state.vs_uses_derived_draw_params ||
             ice->state.vs_needs_edge_flag)) {
@@ -6666,7 +6671,7 @@ iris_upload_dirty_render_state(struct iris_context *ice,
                          (1 + entries * GENX(VERTEX_ELEMENT_STATE_length)));
       } else {
          uint32_t dynamic_ves[1 + 33 * GENX(VERTEX_ELEMENT_STATE_length)];
-         const unsigned dyn_count = cso->count +
+         const unsigned dyn_count = cso->base.count +
             ice->state.vs_needs_sgvs_element +
             ice->state.vs_uses_derived_draw_params;
 
@@ -6676,10 +6681,10 @@ iris_upload_dirty_render_state(struct iris_context *ice,
                1 + GENX(VERTEX_ELEMENT_STATE_length) * dyn_count - 2;
          }
          memcpy(&dynamic_ves[1], &cso->vertex_elements[1],
-                (cso->count - ice->state.vs_needs_edge_flag) *
+                (cso->base.count - ice->state.vs_needs_edge_flag) *
                 GENX(VERTEX_ELEMENT_STATE_length) * sizeof(uint32_t));
          uint32_t *ve_pack_dest =
-            &dynamic_ves[1 + (cso->count - ice->state.vs_needs_edge_flag) *
+            &dynamic_ves[1 + (cso->base.count - ice->state.vs_needs_edge_flag) *
                          GENX(VERTEX_ELEMENT_STATE_length)];
 
          if (ice->state.vs_needs_sgvs_element) {
@@ -6724,8 +6729,8 @@ iris_upload_dirty_render_state(struct iris_context *ice,
          iris_batch_emit(batch, cso->vf_instancing, sizeof(uint32_t) *
                          entries * GENX(3DSTATE_VF_INSTANCING_length));
       } else {
-         assert(cso->count > 0);
-         const unsigned edgeflag_index = cso->count - 1;
+         assert(cso->base.count > 0);
+         const unsigned edgeflag_index = cso->base.count - 1;
          uint32_t dynamic_vfi[33 * GENX(3DSTATE_VF_INSTANCING_length)];
          memcpy(&dynamic_vfi[0], cso->vf_instancing, edgeflag_index *
                 GENX(3DSTATE_VF_INSTANCING_length) * sizeof(uint32_t));
@@ -6755,14 +6760,14 @@ iris_upload_dirty_render_state(struct iris_context *ice,
             sgv.VertexIDEnable = true;
             sgv.VertexIDComponentNumber = 2;
             sgv.VertexIDElementOffset =
-               cso->count - ice->state.vs_needs_edge_flag;
+               cso->base.count - ice->state.vs_needs_edge_flag;
          }
 
          if (vs_prog_data->uses_instanceid) {
             sgv.InstanceIDEnable = true;
             sgv.InstanceIDComponentNumber = 3;
             sgv.InstanceIDElementOffset =
-               cso->count - ice->state.vs_needs_edge_flag;
+               cso->base.count - ice->state.vs_needs_edge_flag;
          }
       }
    }
@@ -8444,7 +8449,7 @@ genX(init_state)(struct iris_context *ice)
    ctx->delete_depth_stencil_alpha_state = iris_delete_state;
    ctx->delete_rasterizer_state = iris_delete_state;
    ctx->delete_sampler_state = iris_delete_state;
-   ctx->delete_vertex_elements_state = iris_delete_state;
+   ctx->delete_vertex_elements_state = iris_delete_vertex_elements;
    ctx->set_blend_color = iris_set_blend_color;
    ctx->set_clip_state = iris_set_clip_state;
    ctx->set_constant_buffer = iris_set_constant_buffer;
diff --git a/src/gallium/drivers/lima/lima_context.h b/src/gallium/drivers/lima/lima_context.h
index 772732a0c93e..1e186318997b 100644
--- a/src/gallium/drivers/lima/lima_context.h
+++ b/src/gallium/drivers/lima/lima_context.h
@@ -112,11 +112,6 @@ struct lima_blend_state {
    struct pipe_blend_state base;
 };
 
-struct lima_vertex_element_state {
-   struct pipe_vertex_element pipe[PIPE_MAX_ATTRIBS];
-   unsigned num_elements;
-};
-
 struct lima_context_vertex_buffer {
    struct pipe_vertex_buffer vb[PIPE_MAX_ATTRIBS];
    unsigned count;
@@ -222,7 +217,7 @@ struct lima_context {
    struct lima_fs_compiled_shader *fs;
    struct lima_vs_uncompiled_shader *uncomp_vs;
    struct lima_fs_uncompiled_shader *uncomp_fs;
-   struct lima_vertex_element_state *vertex_elements;
+   struct pipe_vertex_elements *vertex_elements;
    struct lima_context_vertex_buffer vertex_buffers;
    struct lima_rasterizer_state *rasterizer;
    struct lima_depth_stencil_alpha_state *zsa;
diff --git a/src/gallium/drivers/lima/lima_draw.c b/src/gallium/drivers/lima/lima_draw.c
index 771757d084cf..38df920cb15b 100644
--- a/src/gallium/drivers/lima/lima_draw.c
+++ b/src/gallium/drivers/lima/lima_draw.c
@@ -310,7 +310,7 @@ lima_pack_vs_cmd(struct lima_context *ctx, const struct pipe_draw_info *info,
    VS_CMD_SHADER_INFO(ctx->vs->state.prefetch, ctx->vs->state.shader_size);
 
    int num_outputs = ctx->vs->state.num_outputs;
-   int num_attributes = ctx->vertex_elements->num_elements;
+   int num_attributes = ctx->vertex_elements->count;
    VS_CMD_VARYING_ATTRIBUTE_COUNT(num_outputs, MAX2(1, num_attributes));
 
    VS_CMD_UNKNOWN1();
@@ -816,16 +816,16 @@ lima_update_gp_attribute_info(struct lima_context *ctx, const struct pipe_draw_i
                               const struct pipe_draw_start_count_bias *draw)
 {
    struct lima_job *job = lima_job_get(ctx);
-   struct lima_vertex_element_state *ve = ctx->vertex_elements;
+   struct pipe_vertex_elements *ve = ctx->vertex_elements;
    struct lima_context_vertex_buffer *vb = &ctx->vertex_buffers;
 
    uint32_t *attribute =
       lima_ctx_buff_alloc(ctx, lima_ctx_buff_gp_attribute_info,
-                          MAX2(1, ve->num_elements) * 8);
+                          MAX2(1, ve->count) * 8);
 
    int n = 0;
-   for (int i = 0; i < ve->num_elements; i++) {
-      struct pipe_vertex_element *pve = ve->pipe + i;
+   for (int i = 0; i < ve->count; i++) {
+      struct pipe_vertex_element *pve = ve->input + i;
 
       assert(pve->vertex_buffer_index < vb->count);
       assert(vb->enabled_mask & (1 << pve->vertex_buffer_index));
diff --git a/src/gallium/drivers/lima/lima_state.c b/src/gallium/drivers/lima/lima_state.c
index badd815a8b5b..6ad0e2658d64 100644
--- a/src/gallium/drivers/lima/lima_state.c
+++ b/src/gallium/drivers/lima/lima_state.c
@@ -153,24 +153,22 @@ lima_delete_blend_state(struct pipe_context *pctx, void *hwcso)
    FREE(hwcso);
 }
 
-static void *
-lima_create_vertex_elements_state(struct pipe_context *pctx, unsigned num_elements,
-                                  const struct pipe_vertex_element *elements)
+static struct pipe_vertex_elements *
+lima_create_vertex_elements_state(struct pipe_context *pctx,
+                                  const struct pipe_vertex_elements *elements)
 {
-   struct lima_vertex_element_state *so;
+   struct pipe_vertex_elements *so;
 
-   so = CALLOC_STRUCT(lima_vertex_element_state);
+   so = CALLOC_STRUCT(pipe_vertex_elements);
    if (!so)
       return NULL;
 
-   memcpy(so->pipe, elements, sizeof(*elements) * num_elements);
-   so->num_elements = num_elements;
-
+   *so = *elements;
    return so;
 }
 
 static void
-lima_bind_vertex_elements_state(struct pipe_context *pctx, void *hwcso)
+lima_bind_vertex_elements_state(struct pipe_context *pctx, struct pipe_vertex_elements *hwcso)
 {
    struct lima_context *ctx = lima_context(pctx);
 
@@ -179,7 +177,7 @@ lima_bind_vertex_elements_state(struct pipe_context *pctx, void *hwcso)
 }
 
 static void
-lima_delete_vertex_elements_state(struct pipe_context *pctx, void *hwcso)
+lima_delete_vertex_elements_state(struct pipe_context *pctx, struct pipe_vertex_elements *hwcso)
 {
    FREE(hwcso);
 }
diff --git a/src/gallium/drivers/llvmpipe/lp_context.h b/src/gallium/drivers/llvmpipe/lp_context.h
index a61c8e0a569c..ae0b25cca4b7 100644
--- a/src/gallium/drivers/llvmpipe/lp_context.h
+++ b/src/gallium/drivers/llvmpipe/lp_context.h
@@ -53,7 +53,6 @@ struct lp_compute_shader;
 struct lp_blend_state;
 struct lp_setup_context;
 struct lp_setup_variant;
-struct lp_velems_state;
 
 struct llvmpipe_context {
    struct pipe_context pipe;  /**< base class */
@@ -71,7 +70,7 @@ struct llvmpipe_context {
    const struct lp_tess_ctrl_shader *tcs;
    const struct lp_tess_eval_shader *tes;
    struct lp_compute_shader *cs;
-   const struct lp_velems_state *velems;
+   struct pipe_vertex_elements *velems;
    const struct lp_so_state *so;
 
    /** Other rendering state */
diff --git a/src/gallium/drivers/llvmpipe/lp_state.h b/src/gallium/drivers/llvmpipe/lp_state.h
index fab180a8cfbe..940ed41e997b 100644
--- a/src/gallium/drivers/llvmpipe/lp_state.h
+++ b/src/gallium/drivers/llvmpipe/lp_state.h
@@ -93,14 +93,6 @@ struct lp_tess_eval_shader {
    struct draw_tess_eval_shader *dtes;
 };
 
-
-/** Vertex element state */
-struct lp_velems_state
-{
-   unsigned count;
-   struct pipe_vertex_element velem[PIPE_MAX_ATTRIBS];
-};
-
 struct lp_so_state {
    struct pipe_stream_output_info base;
 };
diff --git a/src/gallium/drivers/llvmpipe/lp_state_vertex.c b/src/gallium/drivers/llvmpipe/lp_state_vertex.c
index ee87bed5dfb7..d90fc42d15fc 100644
--- a/src/gallium/drivers/llvmpipe/lp_state_vertex.c
+++ b/src/gallium/drivers/llvmpipe/lp_state_vertex.c
@@ -38,38 +38,34 @@
 #include "util/u_transfer.h"
 
 
-static void *
+static struct pipe_vertex_elements *
 llvmpipe_create_vertex_elements_state(struct pipe_context *pipe,
-                                      unsigned count,
-                                      const struct pipe_vertex_element *attribs)
+                                      const struct pipe_vertex_elements *attribs)
 {
-   struct lp_velems_state *velems;
-   assert(count <= PIPE_MAX_ATTRIBS);
-   velems = (struct lp_velems_state *) MALLOC(sizeof(struct lp_velems_state));
-   if (velems) {
-      velems->count = count;
-      memcpy(velems->velem, attribs, sizeof(*attribs) * count);
-   }
+   struct pipe_vertex_elements *velems;
+   assert(attribs->count <= PIPE_MAX_ATTRIBS);
+   velems = (struct pipe_vertex_elements *) MALLOC(sizeof(struct pipe_vertex_elements));
+   *velems = *attribs;
    return velems;
 }
 
 static void
 llvmpipe_bind_vertex_elements_state(struct pipe_context *pipe,
-                                    void *velems)
+                                    struct pipe_vertex_elements *velems)
 {
    struct llvmpipe_context *llvmpipe = llvmpipe_context(pipe);
-   struct lp_velems_state *lp_velems = (struct lp_velems_state *) velems;
 
-   llvmpipe->velems = lp_velems;
+   llvmpipe->velems = velems;
 
    llvmpipe->dirty |= LP_NEW_VERTEX;
 
    if (velems)
-      draw_set_vertex_elements(llvmpipe->draw, lp_velems->count, lp_velems->velem);
+      draw_set_vertex_elements(llvmpipe->draw, velems->count, velems->input);
 }
 
 static void
-llvmpipe_delete_vertex_elements_state(struct pipe_context *pipe, void *velems)
+llvmpipe_delete_vertex_elements_state(struct pipe_context *pipe,
+                                      struct pipe_vertex_elements *velems)
 {
    FREE( velems );
 }
diff --git a/src/gallium/drivers/llvmpipe/lp_surface.c b/src/gallium/drivers/llvmpipe/lp_surface.c
index 4c86af9cbd0f..b4e6f4da2820 100644
--- a/src/gallium/drivers/llvmpipe/lp_surface.c
+++ b/src/gallium/drivers/llvmpipe/lp_surface.c
@@ -155,7 +155,7 @@ static void lp_blit(struct pipe_context *pipe,
    }
 
    util_blitter_save_vertex_buffer_slot(lp->blitter, lp->vertex_buffer);
-   util_blitter_save_vertex_elements(lp->blitter, (void*)lp->velems);
+   util_blitter_save_vertex_elements(lp->blitter, lp->velems);
    util_blitter_save_vertex_shader(lp->blitter, (void*)lp->vs);
    util_blitter_save_geometry_shader(lp->blitter, (void*)lp->gs);
    util_blitter_save_so_targets(lp->blitter, lp->num_so_targets,
diff --git a/src/gallium/drivers/nouveau/nv30/nv30_draw.c b/src/gallium/drivers/nouveau/nv30/nv30_draw.c
index c1392cf7762c..0ca714742e6e 100644
--- a/src/gallium/drivers/nouveau/nv30/nv30_draw.c
+++ b/src/gallium/drivers/nouveau/nv30/nv30_draw.c
@@ -396,7 +396,7 @@ nv30_render_vbo(struct pipe_context *pipe, const struct pipe_draw_info *info,
       draw_set_clip_state(draw, &nv30->clip);
    if (nv30->draw_dirty & NV30_NEW_ARRAYS) {
       draw_set_vertex_buffers(draw, 0, nv30->num_vtxbufs, 0, nv30->vtxbuf);
-      draw_set_vertex_elements(draw, nv30->vertex->num_elements, nv30->vertex->pipe);
+      draw_set_vertex_elements(draw, nv30->vertex->num_elements, nv30->vertex->base.input);
    }
    if (nv30->draw_dirty & NV30_NEW_FRAGPROG) {
       struct nv30_fragprog *fp = nv30->fragprog.program;
diff --git a/src/gallium/drivers/nouveau/nv30/nv30_miptree.c b/src/gallium/drivers/nouveau/nv30/nv30_miptree.c
index 5d1f16b28c9e..8204645b6aba 100644
--- a/src/gallium/drivers/nouveau/nv30/nv30_miptree.c
+++ b/src/gallium/drivers/nouveau/nv30/nv30_miptree.c
@@ -248,7 +248,7 @@ nv30_blit(struct pipe_context *pipe,
    /* XXX turn off occlusion queries */
 
    util_blitter_save_vertex_buffer_slot(nv30->blitter, nv30->vtxbuf);
-   util_blitter_save_vertex_elements(nv30->blitter, nv30->vertex);
+   util_blitter_save_vertex_elements(nv30->blitter, &nv30->vertex->base);
    util_blitter_save_vertex_shader(nv30->blitter, nv30->vertprog.program);
    util_blitter_save_rasterizer(nv30->blitter, nv30->rast);
    util_blitter_save_viewport(nv30->blitter, &nv30->viewport);
diff --git a/src/gallium/drivers/nouveau/nv30/nv30_state.h b/src/gallium/drivers/nouveau/nv30/nv30_state.h
index ed3b8103a003..f79666ff6ef7 100644
--- a/src/gallium/drivers/nouveau/nv30/nv30_state.h
+++ b/src/gallium/drivers/nouveau/nv30/nv30_state.h
@@ -134,7 +134,7 @@ struct nv30_vertex_element {
 };
 
 struct nv30_vertex_stateobj {
-   struct pipe_vertex_element pipe[PIPE_MAX_ATTRIBS];
+   struct pipe_vertex_elements base; /* don't change, it's used by memcmp for CSO lookups */
    struct translate *translate;
    bool need_conversion;
    unsigned num_elements;
diff --git a/src/gallium/drivers/nouveau/nv30/nv30_vbo.c b/src/gallium/drivers/nouveau/nv30/nv30_vbo.c
index 3e24e90c7350..4838c0cf76fd 100644
--- a/src/gallium/drivers/nouveau/nv30/nv30_vbo.c
+++ b/src/gallium/drivers/nouveau/nv30/nv30_vbo.c
@@ -134,7 +134,7 @@ nv30_update_user_vbufs(struct nv30_context *nv30)
    uint32_t written = 0;
 
    for (i = 0; i < nv30->vertex->num_elements; i++) {
-      struct pipe_vertex_element *ve = &nv30->vertex->pipe[i];
+      struct pipe_vertex_element *ve = &nv30->vertex->base.input[i];
       const int b = ve->vertex_buffer_index;
       struct pipe_vertex_buffer *vb = &nv30->vtxbuf[b];
       struct nv04_resource *buf = nv04_resource(vb->buffer.resource);
@@ -212,7 +212,7 @@ nv30_vbo_validate(struct nv30_context *nv30)
    BEGIN_NV04(push, NV30_3D(VTXFMT(0)), redefine);
 
    for (i = 0; i < vertex->num_elements; i++) {
-      ve = &vertex->pipe[i];
+      ve = &vertex->base.input[i];
       vb = &nv30->vtxbuf[ve->vertex_buffer_index];
 
       if (likely(vb->stride) || nv30->vbo_fifo)
@@ -230,7 +230,7 @@ nv30_vbo_validate(struct nv30_context *nv30)
       unsigned offset;
       bool user;
 
-      ve = &vertex->pipe[i];
+      ve = &vertex->base.input[i];
       vb = &nv30->vtxbuf[ve->vertex_buffer_index];
       user = (nv30->vbo_user & (1 << ve->vertex_buffer_index));
 
@@ -253,26 +253,26 @@ nv30_vbo_validate(struct nv30_context *nv30)
    nv30->state.num_vtxelts = vertex->num_elements;
 }
 
-static void *
-nv30_vertex_state_create(struct pipe_context *pipe, unsigned num_elements,
-                         const struct pipe_vertex_element *elements)
+static struct pipe_vertex_elements *
+nv30_vertex_state_create(struct pipe_context *pipe,
+                         const struct pipe_vertex_elements *elements)
 {
     struct nv30_vertex_stateobj *so;
     struct translate_key transkey;
     unsigned i;
 
-    so = MALLOC(sizeof(*so) + sizeof(*so->element) * num_elements);
+    so = MALLOC(sizeof(*so) + sizeof(*so->element) * elements->count);
     if (!so)
         return NULL;
-    memcpy(so->pipe, elements, sizeof(*elements) * num_elements);
-    so->num_elements = num_elements;
+    so->base = *elements;
+    so->num_elements = elements->count;
     so->need_conversion = false;
 
     transkey.nr_elements = 0;
     transkey.output_stride = 0;
 
-    for (i = 0; i < num_elements; i++) {
-        const struct pipe_vertex_element *ve = &elements[i];
+    for (i = 0; i < elements->count; i++) {
+        const struct pipe_vertex_element *ve = &elements->input[i];
         const unsigned vbi = ve->vertex_buffer_index;
         enum pipe_format fmt = ve->src_format;
 
@@ -310,13 +310,13 @@ nv30_vertex_state_create(struct pipe_context *pipe, unsigned num_elements,
     so->translate = translate_create(&transkey);
     so->vtx_size = transkey.output_stride / 4;
     so->vtx_per_packet_max = NV04_PFIFO_MAX_PACKET_LEN / MAX2(so->vtx_size, 1);
-    return so;
+    return &so->base;
 }
 
 static void
-nv30_vertex_state_delete(struct pipe_context *pipe, void *hwcso)
+nv30_vertex_state_delete(struct pipe_context *pipe, struct pipe_vertex_elements *hwcso)
 {
-   struct nv30_vertex_stateobj *so = hwcso;
+   struct nv30_vertex_stateobj *so = (struct nv30_vertex_stateobj*)hwcso;
 
    if (so->translate)
       so->translate->release(so->translate);
@@ -324,11 +324,11 @@ nv30_vertex_state_delete(struct pipe_context *pipe, void *hwcso)
 }
 
 static void
-nv30_vertex_state_bind(struct pipe_context *pipe, void *hwcso)
+nv30_vertex_state_bind(struct pipe_context *pipe, struct pipe_vertex_elements *hwcso)
 {
    struct nv30_context *nv30 = nv30_context(pipe);
 
-   nv30->vertex = hwcso;
+   nv30->vertex = (struct nv30_vertex_stateobj*)hwcso;
    nv30->dirty |= NV30_NEW_VERTEX;
 }
 
diff --git a/src/gallium/drivers/nouveau/nv50/nv50_context.h b/src/gallium/drivers/nouveau/nv50/nv50_context.h
index ed89d54afe4c..ccd53b17eb4b 100644
--- a/src/gallium/drivers/nouveau/nv50/nv50_context.h
+++ b/src/gallium/drivers/nouveau/nv50/nv50_context.h
@@ -340,12 +340,11 @@ void nv50_draw_vbo(struct pipe_context *, const struct pipe_draw_info *, unsigne
                    const struct pipe_draw_start_count_bias *draws,
                    unsigned num_draws);
 
-void *
+struct pipe_vertex_elements *
 nv50_vertex_state_create(struct pipe_context *pipe,
-                         unsigned num_elements,
-                         const struct pipe_vertex_element *elements);
+                         const struct pipe_vertex_elements *elements);
 void
-nv50_vertex_state_delete(struct pipe_context *pipe, void *hwcso);
+nv50_vertex_state_delete(struct pipe_context *pipe, struct pipe_vertex_elements *hwcso);
 
 void nv50_vertex_arrays_validate(struct nv50_context *nv50);
 
diff --git a/src/gallium/drivers/nouveau/nv50/nv50_state.c b/src/gallium/drivers/nouveau/nv50/nv50_state.c
index 3ad9e41fdbb3..26e7df3508f0 100644
--- a/src/gallium/drivers/nouveau/nv50/nv50_state.c
+++ b/src/gallium/drivers/nouveau/nv50/nv50_state.c
@@ -1122,11 +1122,11 @@ nv50_set_vertex_buffers(struct pipe_context *pipe,
 }
 
 static void
-nv50_vertex_state_bind(struct pipe_context *pipe, void *hwcso)
+nv50_vertex_state_bind(struct pipe_context *pipe, struct pipe_vertex_elements *hwcso)
 {
    struct nv50_context *nv50 = nv50_context(pipe);
 
-   nv50->vertex = hwcso;
+   nv50->vertex = (struct nv50_vertex_stateobj*)hwcso;
    nv50->dirty_3d |= NV50_NEW_3D_VERTEX;
 }
 
diff --git a/src/gallium/drivers/nouveau/nv50/nv50_stateobj.h b/src/gallium/drivers/nouveau/nv50/nv50_stateobj.h
index 579da9a110c1..5e98122fd049 100644
--- a/src/gallium/drivers/nouveau/nv50/nv50_stateobj.h
+++ b/src/gallium/drivers/nouveau/nv50/nv50_stateobj.h
@@ -50,6 +50,7 @@ struct nv50_vertex_element {
 };
 
 struct nv50_vertex_stateobj {
+   struct pipe_vertex_elements base; /* don't change, it's used by memcmp for CSO lookups */
    uint32_t min_instance_div[PIPE_MAX_ATTRIBS];
    uint16_t vb_access_size[PIPE_MAX_ATTRIBS];
    struct translate *translate;
diff --git a/src/gallium/drivers/nouveau/nv50/nv50_vbo.c b/src/gallium/drivers/nouveau/nv50/nv50_vbo.c
index 600434f767d4..c4b34dee36c6 100644
--- a/src/gallium/drivers/nouveau/nv50/nv50_vbo.c
+++ b/src/gallium/drivers/nouveau/nv50/nv50_vbo.c
@@ -36,29 +36,29 @@
 
 void
 nv50_vertex_state_delete(struct pipe_context *pipe,
-                         void *hwcso)
+                         struct pipe_vertex_elements *hwcso)
 {
-   struct nv50_vertex_stateobj *so = hwcso;
+   struct nv50_vertex_stateobj *so = (struct nv50_vertex_stateobj*)hwcso;
 
    if (so->translate)
       so->translate->release(so->translate);
    FREE(hwcso);
 }
 
-void *
+struct pipe_vertex_elements *
 nv50_vertex_state_create(struct pipe_context *pipe,
-                         unsigned num_elements,
-                         const struct pipe_vertex_element *elements)
+                         const struct pipe_vertex_elements *elements)
 {
     struct nv50_vertex_stateobj *so;
     struct translate_key transkey;
     unsigned i;
 
     so = MALLOC(sizeof(*so) +
-                num_elements * sizeof(struct nv50_vertex_element));
+                elements->count * sizeof(struct nv50_vertex_element));
     if (!so)
         return NULL;
-    so->num_elements = num_elements;
+    so->base = *elements;
+    so->num_elements = elements->count;
     so->instance_elts = 0;
     so->instance_bufs = 0;
     so->need_conversion = false;
@@ -71,13 +71,13 @@ nv50_vertex_state_create(struct pipe_context *pipe,
     transkey.nr_elements = 0;
     transkey.output_stride = 0;
 
-    for (i = 0; i < num_elements; ++i) {
-        const struct pipe_vertex_element *ve = &elements[i];
+    for (i = 0; i < elements->count; ++i) {
+        const struct pipe_vertex_element *ve = &elements->input[i];
         const unsigned vbi = ve->vertex_buffer_index;
         unsigned size;
         enum pipe_format fmt = ve->src_format;
 
-        so->element[i].pipe = elements[i];
+        so->element[i].pipe = elements->input[i];
         so->element[i].state = nv50_vertex_format[fmt].vtx;
 
         if (!so->element[i].state) {
@@ -130,7 +130,7 @@ nv50_vertex_state_create(struct pipe_context *pipe,
     so->packet_vertex_limit = NV04_PFIFO_MAX_PACKET_LEN /
        MAX2(so->vertex_size, 1);
 
-    return so;
+    return &so->base;
 }
 
 #define NV50_3D_VERTEX_ATTRIB_INACTIVE              \
diff --git a/src/gallium/drivers/nouveau/nvc0/nvc0_context.h b/src/gallium/drivers/nouveau/nvc0/nvc0_context.h
index 2d8e2f0b38ae..f67db2cd3e56 100644
--- a/src/gallium/drivers/nouveau/nvc0/nvc0_context.h
+++ b/src/gallium/drivers/nouveau/nvc0/nvc0_context.h
@@ -418,12 +418,11 @@ void nvc0_draw_vbo(struct pipe_context *, const struct pipe_draw_info *, unsigne
                    const struct pipe_draw_start_count_bias *draws,
                    unsigned num_draws);
 
-void *
+struct pipe_vertex_elements *
 nvc0_vertex_state_create(struct pipe_context *pipe,
-                         unsigned num_elements,
-                         const struct pipe_vertex_element *elements);
+                         const struct pipe_vertex_elements *elements);
 void
-nvc0_vertex_state_delete(struct pipe_context *pipe, void *hwcso);
+nvc0_vertex_state_delete(struct pipe_context *pipe, struct pipe_vertex_elements *hwcso);
 
 void nvc0_vertex_arrays_validate(struct nvc0_context *);
 
diff --git a/src/gallium/drivers/nouveau/nvc0/nvc0_state.c b/src/gallium/drivers/nouveau/nvc0/nvc0_state.c
index 13c4fc6a27b3..f477c227f1ab 100644
--- a/src/gallium/drivers/nouveau/nvc0/nvc0_state.c
+++ b/src/gallium/drivers/nouveau/nvc0/nvc0_state.c
@@ -1066,11 +1066,11 @@ nvc0_set_vertex_buffers(struct pipe_context *pipe,
 }
 
 static void
-nvc0_vertex_state_bind(struct pipe_context *pipe, void *hwcso)
+nvc0_vertex_state_bind(struct pipe_context *pipe, struct pipe_vertex_elements *hwcso)
 {
     struct nvc0_context *nvc0 = nvc0_context(pipe);
 
-    nvc0->vertex = hwcso;
+    nvc0->vertex = (struct nvc0_vertex_stateobj*)hwcso;
     nvc0->dirty_3d |= NVC0_NEW_3D_VERTEX;
 }
 
diff --git a/src/gallium/drivers/nouveau/nvc0/nvc0_stateobj.h b/src/gallium/drivers/nouveau/nvc0/nvc0_stateobj.h
index e20032845cd0..21bfb59a528f 100644
--- a/src/gallium/drivers/nouveau/nvc0/nvc0_stateobj.h
+++ b/src/gallium/drivers/nouveau/nvc0/nvc0_stateobj.h
@@ -49,6 +49,7 @@ struct nvc0_vertex_element {
 };
 
 struct nvc0_vertex_stateobj {
+   struct pipe_vertex_elements base; /* don't change, it's used by memcmp for CSO lookups */
    uint32_t min_instance_div[PIPE_MAX_ATTRIBS];
    uint16_t vb_access_size[PIPE_MAX_ATTRIBS];
    struct translate *translate;
diff --git a/src/gallium/drivers/nouveau/nvc0/nvc0_vbo.c b/src/gallium/drivers/nouveau/nvc0/nvc0_vbo.c
index b9118cb099e8..2814c1f5eca4 100644
--- a/src/gallium/drivers/nouveau/nvc0/nvc0_vbo.c
+++ b/src/gallium/drivers/nouveau/nvc0/nvc0_vbo.c
@@ -37,19 +37,18 @@
 
 void
 nvc0_vertex_state_delete(struct pipe_context *pipe,
-                         void *hwcso)
+                         struct pipe_vertex_elements *hwcso)
 {
-   struct nvc0_vertex_stateobj *so = hwcso;
+   struct nvc0_vertex_stateobj *so = (struct nvc0_vertex_stateobj*)hwcso;
 
    if (so->translate)
       so->translate->release(so->translate);
    FREE(hwcso);
 }
 
-void *
+struct pipe_vertex_elements *
 nvc0_vertex_state_create(struct pipe_context *pipe,
-                         unsigned num_elements,
-                         const struct pipe_vertex_element *elements)
+                         const struct pipe_vertex_elements *elements)
 {
     struct nvc0_vertex_stateobj *so;
     struct translate_key transkey;
@@ -57,10 +56,11 @@ nvc0_vertex_state_create(struct pipe_context *pipe,
     unsigned src_offset_max = 0;
 
     so = MALLOC(sizeof(*so) +
-                num_elements * sizeof(struct nvc0_vertex_element));
+                elements->count * sizeof(struct nvc0_vertex_element));
     if (!so)
         return NULL;
-    so->num_elements = num_elements;
+    so->base = *elements;
+    so->num_elements = elements->count;
     so->instance_elts = 0;
     so->instance_bufs = 0;
     so->shared_slots = false;
@@ -74,13 +74,13 @@ nvc0_vertex_state_create(struct pipe_context *pipe,
     transkey.nr_elements = 0;
     transkey.output_stride = 0;
 
-    for (i = 0; i < num_elements; ++i) {
-        const struct pipe_vertex_element *ve = &elements[i];
+    for (i = 0; i < elements->count; ++i) {
+        const struct pipe_vertex_element *ve = &elements->input[i];
         const unsigned vbi = ve->vertex_buffer_index;
         unsigned size;
         enum pipe_format fmt = ve->src_format;
 
-        so->element[i].pipe = elements[i];
+        so->element[i].pipe = elements->input[i];
         so->element[i].state = nvc0_vertex_format[fmt].vtx;
 
         if (!so->element[i].state) {
@@ -145,17 +145,17 @@ nvc0_vertex_state_create(struct pipe_context *pipe,
     so->translate = translate_create(&transkey);
 
     if (so->instance_elts || src_offset_max >= (1 << 14))
-       return so;
+       return &so->base;
     so->shared_slots = true;
 
-    for (i = 0; i < num_elements; ++i) {
-       const unsigned b = elements[i].vertex_buffer_index;
-       const unsigned s = elements[i].src_offset;
+    for (i = 0; i < elements->count; ++i) {
+       const unsigned b = elements->input[i].vertex_buffer_index;
+       const unsigned s = elements->input[i].src_offset;
        so->element[i].state &= ~NVC0_3D_VERTEX_ATTRIB_FORMAT_BUFFER__MASK;
        so->element[i].state |= b << NVC0_3D_VERTEX_ATTRIB_FORMAT_BUFFER__SHIFT;
        so->element[i].state |= s << NVC0_3D_VERTEX_ATTRIB_FORMAT_OFFSET__SHIFT;
     }
-    return so;
+    return &so->base;
 }
 
 #define NVC0_3D_VERTEX_ATTRIB_INACTIVE                                       \
diff --git a/src/gallium/drivers/panfrost/pan_blit.c b/src/gallium/drivers/panfrost/pan_blit.c
index 1297ea8b2537..0028b719b50e 100644
--- a/src/gallium/drivers/panfrost/pan_blit.c
+++ b/src/gallium/drivers/panfrost/pan_blit.c
@@ -37,7 +37,7 @@ panfrost_blitter_save(struct panfrost_context *ctx, bool render_cond)
         struct blitter_context *blitter = ctx->blitter;
 
         util_blitter_save_vertex_buffer_slot(blitter, ctx->vertex_buffers);
-        util_blitter_save_vertex_elements(blitter, ctx->vertex);
+        util_blitter_save_vertex_elements(blitter, (struct pipe_vertex_elements*)ctx->vertex);
         util_blitter_save_vertex_shader(blitter, ctx->shader[PIPE_SHADER_VERTEX]);
         util_blitter_save_rasterizer(blitter, ctx->rasterizer);
         util_blitter_save_viewport(blitter, &ctx->pipe_viewport);
diff --git a/src/gallium/drivers/panfrost/pan_cmdstream.c b/src/gallium/drivers/panfrost/pan_cmdstream.c
index 4ac9a1443729..844172922532 100644
--- a/src/gallium/drivers/panfrost/pan_cmdstream.c
+++ b/src/gallium/drivers/panfrost/pan_cmdstream.c
@@ -106,8 +106,7 @@ struct panfrost_sampler_view {
 };
 
 struct panfrost_vertex_state {
-        unsigned num_elements;
-        struct pipe_vertex_element pipe[PIPE_MAX_ATTRIBS];
+        struct pipe_vertex_elements base; /* don't change, it's used by memcmp for CSO lookups */
 
 #if PAN_ARCH >= 9
         /* Packed attribute descriptor. All fields are set at CSO create time
@@ -905,13 +904,13 @@ panfrost_emit_vertex_data(struct panfrost_batch *batch)
         struct panfrost_context *ctx = batch->ctx;
         struct panfrost_vertex_state *vtx = ctx->vertex;
         struct panfrost_ptr T = pan_pool_alloc_desc_array(&batch->pool.base,
-                                                          vtx->num_elements,
+                                                          vtx->base.count,
                                                           ATTRIBUTE);
         struct mali_attribute_packed *attributes = T.cpu;
 
-        for (unsigned i = 0; i < vtx->num_elements; ++i) {
+        for (unsigned i = 0; i < vtx->base.count; ++i) {
                 struct mali_attribute_packed packed;
-                unsigned vbi = vtx->pipe[i].vertex_buffer_index;
+                unsigned vbi = vtx->base.input[i].vertex_buffer_index;
 
                 pan_pack(&packed, ATTRIBUTE, cfg) {
                         cfg.stride = ctx->vertex_buffers[vbi].stride;
@@ -2168,7 +2167,7 @@ panfrost_emit_vertex_data(struct panfrost_batch *batch,
 
         if (nr_images) {
                 k = ALIGN_POT(k, 2);
-                emit_image_attribs(ctx, PIPE_SHADER_VERTEX, out + so->num_elements, k);
+                emit_image_attribs(ctx, PIPE_SHADER_VERTEX, out + so->base.count, k);
                 emit_image_bufs(batch, PIPE_SHADER_VERTEX, bufs + k, k);
                 k += (util_last_bit(ctx->image_mask[PIPE_SHADER_VERTEX]) * 2);
         }
@@ -2190,26 +2189,26 @@ panfrost_emit_vertex_data(struct panfrost_batch *batch,
         /* While these are usually equal, they are not required to be. In some
          * cases, u_blitter passes too high a value for num_elements.
          */
-        assert(vs->info.attributes_read_count <= so->num_elements);
+        assert(vs->info.attributes_read_count <= so->base.count);
 
         for (unsigned i = 0; i < vs->info.attributes_read_count; ++i) {
-                unsigned vbi = so->pipe[i].vertex_buffer_index;
+                unsigned vbi = so->base.input[i].vertex_buffer_index;
                 struct pipe_vertex_buffer *buf = &ctx->vertex_buffers[vbi];
 
                 /* BOs are aligned; just fixup for buffer_offset */
-                signed src_offset = so->pipe[i].src_offset;
+                signed src_offset = so->base.input[i].src_offset;
                 src_offset += (buf->buffer_offset & 63);
 
                 /* Base instance offset */
-                if (ctx->base_instance && so->pipe[i].instance_divisor) {
+                if (ctx->base_instance && so->base.input[i].instance_divisor) {
                         src_offset += (ctx->base_instance * buf->stride) /
-                                      so->pipe[i].instance_divisor;
+                                      so->base.input[i].instance_divisor;
                 }
 
                 /* Also, somewhat obscurely per-instance data needs to be
                  * offset in response to a delayed start in an indexed draw */
 
-                if (so->pipe[i].instance_divisor && ctx->instance_count > 1)
+                if (so->base.input[i].instance_divisor && ctx->instance_count > 1)
                         src_offset -= buf->stride * ctx->offset_start;
 
                 pan_pack(out + i, ATTRIBUTE, cfg) {
@@ -3265,7 +3264,7 @@ panfrost_emit_resources(struct panfrost_batch *batch,
         if (stage == PIPE_SHADER_VERTEX) {
                 panfrost_make_resource_table(T, PAN_TABLE_ATTRIBUTE,
                                              batch->attribs[stage],
-                                             ctx->vertex->num_elements);
+                                             ctx->vertex->base.count);
 
                 panfrost_make_resource_table(T, PAN_TABLE_ATTRIBUTE_BUFFER,
                                              batch->attrib_bufs[stage],
@@ -4340,33 +4339,31 @@ panfrost_pack_attribute(struct panfrost_device *dev,
 }
 #endif
 
-static void *
+static struct pipe_vertex_elements *
 panfrost_create_vertex_elements_state(
         struct pipe_context *pctx,
-        unsigned num_elements,
-        const struct pipe_vertex_element *elements)
+        const struct pipe_vertex_elements *elements)
 {
         struct panfrost_vertex_state *so = CALLOC_STRUCT(panfrost_vertex_state);
         struct panfrost_device *dev = pan_device(pctx->screen);
 
-        so->num_elements = num_elements;
-        memcpy(so->pipe, elements, sizeof(*elements) * num_elements);
+        so->base = *elements;
 
 #if PAN_ARCH >= 9
-        for (unsigned i = 0; i < num_elements; ++i)
-                panfrost_pack_attribute(dev, elements[i], &so->attributes[i]);
+        for (unsigned i = 0; i < elements->count; ++i)
+                panfrost_pack_attribute(dev, elements->input[i], &so->attributes[i]);
 #else
         /* Assign attribute buffers corresponding to the vertex buffers, keyed
          * for a particular divisor since that's how instancing works on Mali */
-        for (unsigned i = 0; i < num_elements; ++i) {
+        for (unsigned i = 0; i < elements->count; ++i) {
                 so->element_buffer[i] = pan_assign_vertex_buffer(
                                 so->buffers, &so->nr_bufs,
-                                elements[i].vertex_buffer_index,
-                                elements[i].instance_divisor);
+                                elements->input[i].vertex_buffer_index,
+                                elements->input[i].instance_divisor);
         }
 
-        for (int i = 0; i < num_elements; ++i) {
-                enum pipe_format fmt = elements[i].src_format;
+        for (int i = 0; i < elements->count; ++i) {
+                enum pipe_format fmt = elements->input[i].src_format;
                 so->formats[i] = dev->formats[fmt].hw;
         }
 
@@ -4375,7 +4372,7 @@ panfrost_create_vertex_elements_state(
         so->formats[PAN_INSTANCE_ID] = dev->formats[PIPE_FORMAT_R32_UINT].hw;
 #endif
 
-        return so;
+        return &so->base;
 }
 
 static inline unsigned
diff --git a/src/gallium/drivers/panfrost/pan_context.c b/src/gallium/drivers/panfrost/pan_context.c
index 0d6255112e7d..d1c6b2df82d3 100644
--- a/src/gallium/drivers/panfrost/pan_context.c
+++ b/src/gallium/drivers/panfrost/pan_context.c
@@ -140,6 +140,12 @@ panfrost_generic_cso_delete(struct pipe_context *pctx, void *hwcso)
         free(hwcso);
 }
 
+static void
+panfrost_vertex_state_delete(struct pipe_context *pctx, struct pipe_vertex_elements *hwcso)
+{
+        free(hwcso);
+}
+
 static void
 panfrost_bind_blend_state(struct pipe_context *pipe, void *cso)
 {
@@ -291,10 +297,10 @@ panfrost_set_shader_images(
 static void
 panfrost_bind_vertex_elements_state(
         struct pipe_context *pctx,
-        void *hwcso)
+        struct pipe_vertex_elements *hwcso)
 {
         struct panfrost_context *ctx = pan_context(pctx);
-        ctx->vertex = hwcso;
+        ctx->vertex = (struct panfrost_vertex_state*) hwcso;
         ctx->dirty |= PAN_DIRTY_VERTEX;
 }
 
@@ -1098,7 +1104,7 @@ panfrost_create_context(struct pipe_screen *screen, void *priv, unsigned flags)
         gallium->delete_rasterizer_state = panfrost_generic_cso_delete;
 
         gallium->bind_vertex_elements_state = panfrost_bind_vertex_elements_state;
-        gallium->delete_vertex_elements_state = panfrost_generic_cso_delete;
+        gallium->delete_vertex_elements_state = panfrost_vertex_state_delete;
 
         gallium->create_fs_state = panfrost_create_shader_state;
         gallium->delete_fs_state = panfrost_delete_shader_state;
diff --git a/src/gallium/drivers/r300/r300_blit.c b/src/gallium/drivers/r300/r300_blit.c
index 2cbdcacd02e2..d684a36d594d 100644
--- a/src/gallium/drivers/r300/r300_blit.c
+++ b/src/gallium/drivers/r300/r300_blit.c
@@ -70,7 +70,7 @@ static void r300_blitter_begin(struct r300_context* r300, enum r300_blitter_op o
     util_blitter_save_scissor(r300->blitter, r300->scissor_state.state);
     util_blitter_save_sample_mask(r300->blitter, *(unsigned*)r300->sample_mask.state, 0);
     util_blitter_save_vertex_buffer_slot(r300->blitter, r300->vertex_buffer);
-    util_blitter_save_vertex_elements(r300->blitter, r300->velems);
+    util_blitter_save_vertex_elements(r300->blitter, &r300->velems->base);
 
     struct pipe_constant_buffer cb = {
        /* r300 doesn't use the size for FS at all. The shader determines it.
diff --git a/src/gallium/drivers/r300/r300_context.h b/src/gallium/drivers/r300/r300_context.h
index 60016a3a01f2..0e97dc4536f6 100644
--- a/src/gallium/drivers/r300/r300_context.h
+++ b/src/gallium/drivers/r300/r300_context.h
@@ -408,8 +408,8 @@ struct r300_resource
 };
 
 struct r300_vertex_element_state {
-    unsigned count;
-    struct pipe_vertex_element velem[PIPE_MAX_ATTRIBS];
+    struct pipe_vertex_elements base; /* don't change, it's used by memcmp for CSO lookups */
+    struct pipe_vertex_elements adjusted;
     unsigned format_size[PIPE_MAX_ATTRIBS];
 
     /* The size of the vertex, in dwords. */
@@ -752,7 +752,7 @@ void r300_plug_in_stencil_ref_fallback(struct r300_context *r300);
 /* r300_render.c */
 void r500_emit_index_bias(struct r300_context *r300, int index_bias);
 void r300_blitter_draw_rectangle(struct blitter_context *blitter,
-                                 void *vertex_elements_cso,
+                                 struct pipe_vertex_elements *vertex_elements_cso,
                                  blitter_get_vs_func get_vs,
                                  int x1, int y1, int x2, int y2,
                                  float depth, unsigned num_instances,
diff --git a/src/gallium/drivers/r300/r300_emit.c b/src/gallium/drivers/r300/r300_emit.c
index 08cd544871ee..f6d34193b710 100644
--- a/src/gallium/drivers/r300/r300_emit.c
+++ b/src/gallium/drivers/r300/r300_emit.c
@@ -931,10 +931,10 @@ void r300_emit_vertex_arrays(struct r300_context* r300, int offset,
                              boolean indexed, int instance_id)
 {
     struct pipe_vertex_buffer *vbuf = r300->vertex_buffer;
-    struct pipe_vertex_element *velem = r300->velems->velem;
+    struct pipe_vertex_element *velem = r300->velems->adjusted.input;
     struct r300_resource *buf;
     int i;
-    unsigned vertex_array_count = r300->velems->count;
+    unsigned vertex_array_count = r300->velems->adjusted.count;
     unsigned packet_size = (vertex_array_count * 3 + 1) / 2;
     struct pipe_vertex_buffer *vb1, *vb2;
     unsigned *hw_format_size = r300->velems->format_size;
diff --git a/src/gallium/drivers/r300/r300_render.c b/src/gallium/drivers/r300/r300_render.c
index ea36d0e16716..ba548a1a07e2 100644
--- a/src/gallium/drivers/r300/r300_render.c
+++ b/src/gallium/drivers/r300/r300_render.c
@@ -151,7 +151,7 @@ static void r300_split_index_bias(struct r300_context *r300, int index_bias,
                                   int *buffer_offset, int *index_offset)
 {
     struct pipe_vertex_buffer *vb, *vbufs = r300->vertex_buffer;
-    struct pipe_vertex_element *velem = r300->velems->velem;
+    struct pipe_vertex_element *velem = r300->velems->adjusted.input;
     unsigned i, size;
     int max_neg_bias;
 
@@ -160,7 +160,7 @@ static void r300_split_index_bias(struct r300_context *r300, int index_bias,
          * here because negative buffer offsets are not allowed
          * by the DRM API. */
         max_neg_bias = INT_MAX;
-        for (i = 0; i < r300->velems->count; i++) {
+        for (i = 0; i < r300->velems->adjusted.count; i++) {
             vb = &vbufs[velem[i].vertex_buffer_index];
             size = (vb->buffer_offset + velem[i].src_offset) / vb->stride;
             max_neg_bias = MIN2(max_neg_bias, size);
@@ -340,7 +340,7 @@ static void r300_draw_arrays_immediate(struct r300_context *r300,
 {
     struct pipe_vertex_element* velem;
     struct pipe_vertex_buffer* vbuf;
-    unsigned vertex_element_count = r300->velems->count;
+    unsigned vertex_element_count = r300->velems->adjusted.count;
     unsigned i, v, vbi;
 
     /* Size of the vertex, in dwords. */
@@ -367,7 +367,7 @@ static void r300_draw_arrays_immediate(struct r300_context *r300,
 
     /* Calculate the vertex size, offsets, strides etc. and map the buffers. */
     for (i = 0; i < vertex_element_count; i++) {
-        velem = &r300->velems->velem[i];
+        velem = &r300->velems->adjusted.input[i];
         size[i] = r300->velems->format_size[i] / 4;
         vbi = velem->vertex_buffer_index;
         vbuf = &r300->vertex_buffer[vbi];
@@ -740,8 +740,8 @@ static void r300_draw_elements_instanced(struct r300_context *r300,
 
 static unsigned r300_max_vertex_count(struct r300_context *r300)
 {
-   unsigned i, nr = r300->velems->count;
-   struct pipe_vertex_element *velems = r300->velems->velem;
+   unsigned i, nr = r300->velems->adjusted.count;
+   struct pipe_vertex_element *velems = r300->velems->adjusted.input;
    unsigned result = ~0;
 
    for (i = 0; i < nr; i++) {
@@ -1158,7 +1158,7 @@ struct draw_stage* r300_draw_stage(struct r300_context* r300)
  * would be computed and stored twice, which makes the clear/copy codepaths
  * somewhat inefficient. Instead we use a rectangular point sprite. */
 void r300_blitter_draw_rectangle(struct blitter_context *blitter,
-                                 void *vertex_elements_cso,
+                                 struct pipe_vertex_elements *vertex_elements_cso,
                                  blitter_get_vs_func get_vs,
                                  int x1, int y1, int x2, int y2,
                                  float depth, unsigned num_instances,
diff --git a/src/gallium/drivers/r300/r300_state.c b/src/gallium/drivers/r300/r300_state.c
index 2e9126db5bb8..8efb217eb11d 100644
--- a/src/gallium/drivers/r300/r300_state.c
+++ b/src/gallium/drivers/r300/r300_state.c
@@ -1835,8 +1835,8 @@ static void r300_vertex_psc(struct r300_vertex_element_state *velems)
     /* Vertex shaders have no semantics on their inputs,
      * so PSC should just route stuff based on the vertex elements,
      * and not on attrib information. */
-    for (i = 0; i < velems->count; i++) {
-        format = velems->velem[i].src_format;
+    for (i = 0; i < velems->adjusted.count; i++) {
+        format = velems->adjusted.input[i].src_format;
 
         type = r300_translate_vertex_data_type(format);
         if (type == R300_INVALID_FORMAT) {
@@ -1868,52 +1868,51 @@ static void r300_vertex_psc(struct r300_vertex_element_state *velems)
     vstream->count = (i >> 1) + 1;
 }
 
-static void* r300_create_vertex_elements_state(struct pipe_context* pipe,
-                                               unsigned count,
-                                               const struct pipe_vertex_element* attribs)
+static struct pipe_vertex_elements*
+r300_create_vertex_elements_state(struct pipe_context* pipe,
+                                  const struct pipe_vertex_elements* attribs)
 {
     struct r300_vertex_element_state *velems;
     unsigned i;
-    struct pipe_vertex_element dummy_attrib = {0};
+    struct pipe_vertex_elements dummy_attrib = { .count = 1 };
+
+    velems = CALLOC_STRUCT(r300_vertex_element_state);
+    if (!velems)
+        return NULL;
+    velems->base = *attribs;
 
     /* R300 Programmable Stream Control (PSC) doesn't support 0 vertex elements. */
-    if (!count) {
-        dummy_attrib.src_format = PIPE_FORMAT_R8G8B8A8_UNORM;
+    if (!attribs->count) {
+        dummy_attrib.input[0].src_format = PIPE_FORMAT_R8G8B8A8_UNORM;
         attribs = &dummy_attrib;
-        count = 1;
-    } else if (count > 16) {
+    } else if (attribs->count > 16) {
         fprintf(stderr, "r300: More than 16 vertex elements are not supported,"
-                " requested %i, using 16.\n", count);
-        count = 16;
+                " requested %i, using 16.\n", attribs->count);
+        assert(0);
     }
 
-    velems = CALLOC_STRUCT(r300_vertex_element_state);
-    if (!velems)
-        return NULL;
-
-    velems->count = count;
-    memcpy(velems->velem, attribs, sizeof(struct pipe_vertex_element) * count);
+    velems->adjusted = *attribs;
 
     if (r300_screen(pipe->screen)->caps.has_tcl) {
         /* Setup PSC.
          * The unused components will be replaced by (..., 0, 1). */
         r300_vertex_psc(velems);
 
-        for (i = 0; i < count; i++) {
+        for (i = 0; i < attribs->count; i++) {
             velems->format_size[i] =
-                align(util_format_get_blocksize(velems->velem[i].src_format), 4);
+                align(util_format_get_blocksize(velems->adjusted.input[i].src_format), 4);
             velems->vertex_size_dwords += velems->format_size[i] / 4;
         }
     }
 
-    return velems;
+    return &velems->adjusted;
 }
 
 static void r300_bind_vertex_elements_state(struct pipe_context *pipe,
-                                            void *state)
+                                            struct pipe_vertex_elements *state)
 {
     struct r300_context *r300 = r300_context(pipe);
-    struct r300_vertex_element_state *velems = state;
+    struct r300_vertex_element_state *velems = (struct r300_vertex_element_state*)state;
 
     if (!velems) {
         return;
@@ -1922,7 +1921,7 @@ static void r300_bind_vertex_elements_state(struct pipe_context *pipe,
     r300->velems = velems;
 
     if (r300->draw) {
-        draw_set_vertex_elements(r300->draw, velems->count, velems->velem);
+        draw_set_vertex_elements(r300->draw, velems->adjusted.count, velems->adjusted.input);
         return;
     }
 
@@ -1931,7 +1930,8 @@ static void r300_bind_vertex_elements_state(struct pipe_context *pipe,
     r300->vertex_arrays_dirty = TRUE;
 }
 
-static void r300_delete_vertex_elements_state(struct pipe_context *pipe, void *state)
+static void r300_delete_vertex_elements_state(struct pipe_context *pipe,
+                                              struct pipe_vertex_elements *state)
 {
     FREE(state);
 }
diff --git a/src/gallium/drivers/r600/r600_asm.c b/src/gallium/drivers/r600/r600_asm.c
index f7c10054b5cd..1e77ec56970b 100644
--- a/src/gallium/drivers/r600/r600_asm.c
+++ b/src/gallium/drivers/r600/r600_asm.c
@@ -2720,9 +2720,8 @@ out_unknown:
 	R600_ERR("unsupported vertex format %s\n", util_format_name(pformat));
 }
 
-void *r600_create_vertex_fetch_shader(struct pipe_context *ctx,
-				      unsigned count,
-				      const struct pipe_vertex_element *elements)
+struct pipe_vertex_elements *r600_create_vertex_fetch_shader(struct pipe_context *ctx,
+				                             const struct pipe_vertex_elements *elements)
 {
 	struct r600_context *rctx = (struct r600_context *)ctx;
 	struct r600_bytecode bc;
@@ -2737,7 +2736,7 @@ void *r600_create_vertex_fetch_shader(struct pipe_context *ctx,
                          (rctx->screen->b.debug_flags & DBG_NIR);
 	unsigned sb_disasm = !no_sb || (rctx->screen->b.debug_flags & DBG_SB_DISASM);
 
-	assert(count < 32);
+	assert(elements->count < 32);
 
 	memset(&bc, 0, sizeof(bc));
 	r600_bytecode_init(&bc, rctx->b.gfx_level, rctx->b.family,
@@ -2745,8 +2744,8 @@ void *r600_create_vertex_fetch_shader(struct pipe_context *ctx,
 
 	bc.isa = rctx->isa;
 
-	for (i = 0; i < count; i++) {
-		if (elements[i].instance_divisor > 1) {
+	for (i = 0; i < elements->count; i++) {
+		if (elements->input[i].instance_divisor > 1) {
 			if (rctx->b.gfx_level == CAYMAN) {
 				for (j = 0; j < 4; j++) {
 					struct r600_bytecode_alu alu;
@@ -2755,7 +2754,7 @@ void *r600_create_vertex_fetch_shader(struct pipe_context *ctx,
 					alu.src[0].sel = 0;
 					alu.src[0].chan = 3;
 					alu.src[1].sel = V_SQ_ALU_SRC_LITERAL;
-					alu.src[1].value = (1ll << 32) / elements[i].instance_divisor + 1;
+					alu.src[1].value = (1ll << 32) / elements->input[i].instance_divisor + 1;
 					alu.dst.sel = i + 1;
 					alu.dst.chan = j;
 					alu.dst.write = j == 3;
@@ -2772,7 +2771,7 @@ void *r600_create_vertex_fetch_shader(struct pipe_context *ctx,
 				alu.src[0].sel = 0;
 				alu.src[0].chan = 3;
 				alu.src[1].sel = V_SQ_ALU_SRC_LITERAL;
-				alu.src[1].value = (1ll << 32) / elements[i].instance_divisor + 1;
+				alu.src[1].value = (1ll << 32) / elements->input[i].instance_divisor + 1;
 				alu.dst.sel = i + 1;
 				alu.dst.chan = 3;
 				alu.dst.write = 1;
@@ -2785,23 +2784,23 @@ void *r600_create_vertex_fetch_shader(struct pipe_context *ctx,
 		}
 	}
 
-	for (i = 0; i < count; i++) {
-		r600_vertex_data_type(elements[i].src_format,
+	for (i = 0; i < elements->count; i++) {
+		r600_vertex_data_type(elements->input[i].src_format,
 				      &format, &num_format, &format_comp, &endian);
 
-		desc = util_format_description(elements[i].src_format);
+		desc = util_format_description(elements->input[i].src_format);
 
-		if (elements[i].src_offset > 65535) {
+		if (elements->input[i].src_offset > 65535) {
 			r600_bytecode_clear(&bc);
-			R600_ERR("too big src_offset: %u\n", elements[i].src_offset);
+			R600_ERR("too big src_offset: %u\n", elements->input[i].src_offset);
 			return NULL;
 		}
 
 		memset(&vtx, 0, sizeof(vtx));
-		vtx.buffer_id = elements[i].vertex_buffer_index + fetch_resource_start;
-		vtx.fetch_type = elements[i].instance_divisor ? SQ_VTX_FETCH_INSTANCE_DATA : SQ_VTX_FETCH_VERTEX_DATA;
-		vtx.src_gpr = elements[i].instance_divisor > 1 ? i + 1 : 0;
-		vtx.src_sel_x = elements[i].instance_divisor ? 3 : 0;
+		vtx.buffer_id = elements->input[i].vertex_buffer_index + fetch_resource_start;
+		vtx.fetch_type = elements->input[i].instance_divisor ? SQ_VTX_FETCH_INSTANCE_DATA : SQ_VTX_FETCH_VERTEX_DATA;
+		vtx.src_gpr = elements->input[i].instance_divisor > 1 ? i + 1 : 0;
+		vtx.src_sel_x = elements->input[i].instance_divisor ? 3 : 0;
 		vtx.mega_fetch_count = 0x1F;
 		vtx.dst_gpr = i + 1;
 		vtx.dst_sel_x = desc->swizzle[0];
@@ -2811,7 +2810,7 @@ void *r600_create_vertex_fetch_shader(struct pipe_context *ctx,
 		vtx.data_format = format;
 		vtx.num_format_all = num_format;
 		vtx.format_comp_all = format_comp;
-		vtx.offset = elements[i].src_offset;
+		vtx.offset = elements->input[i].src_offset;
 		vtx.endian = endian;
 
 		if ((r = r600_bytecode_add_vtx(&bc, &vtx))) {
@@ -2830,9 +2829,9 @@ void *r600_create_vertex_fetch_shader(struct pipe_context *ctx,
 	if (rctx->screen->b.debug_flags & DBG_FS) {
 		fprintf(stderr, "--------------------------------------------------------------\n");
 		fprintf(stderr, "Vertex elements state:\n");
-		for (i = 0; i < count; i++) {
+		for (i = 0; i < elements->count; i++) {
 			fprintf(stderr, "   ");
-			util_dump_vertex_element(stderr, elements+i);
+			util_dump_vertex_element(stderr, elements->input+i);
 			fprintf(stderr, "\n");
 		}
 
@@ -2878,7 +2877,9 @@ void *r600_create_vertex_fetch_shader(struct pipe_context *ctx,
 	rctx->b.ws->buffer_unmap(rctx->b.ws, shader->buffer->buf);
 
 	r600_bytecode_clear(&bc);
-	return shader;
+
+        shader->base = *elements;
+	return &shader->base;
 }
 
 void r600_bytecode_alu_read(struct r600_bytecode *bc,
diff --git a/src/gallium/drivers/r600/r600_asm.h b/src/gallium/drivers/r600/r600_asm.h
index 47fd3ff07791..cc061b884139 100644
--- a/src/gallium/drivers/r600/r600_asm.h
+++ b/src/gallium/drivers/r600/r600_asm.h
@@ -333,9 +333,8 @@ int r600_load_ar(struct r600_bytecode *bc, bool for_src);
 
 int cm_bytecode_add_cf_end(struct r600_bytecode *bc);
 
-void *r600_create_vertex_fetch_shader(struct pipe_context *ctx,
-				      unsigned count,
-				      const struct pipe_vertex_element *elements);
+struct pipe_vertex_elements *r600_create_vertex_fetch_shader(struct pipe_context *ctx,
+				                             const struct pipe_vertex_elements *elements);
 
 /* r700_asm.c */
 void r700_bytecode_cf_vtx_build(uint32_t *bytecode,
diff --git a/src/gallium/drivers/r600/r600_pipe.h b/src/gallium/drivers/r600/r600_pipe.h
index 837a71f22f32..ab283e4dc57f 100644
--- a/src/gallium/drivers/r600/r600_pipe.h
+++ b/src/gallium/drivers/r600/r600_pipe.h
@@ -440,6 +440,7 @@ struct r600_cso_state
 };
 
 struct r600_fetch_shader {
+	struct pipe_vertex_elements	base; /* don't change, it's used by memcmp for CSO lookups */
 	struct r600_resource		*buffer;
 	unsigned			offset;
 };
diff --git a/src/gallium/drivers/r600/r600_pipe_common.c b/src/gallium/drivers/r600/r600_pipe_common.c
index 3d561e9be711..e9edb16f6b81 100644
--- a/src/gallium/drivers/r600/r600_pipe_common.c
+++ b/src/gallium/drivers/r600/r600_pipe_common.c
@@ -126,7 +126,7 @@ void r600_gfx_wait_fence(struct r600_common_context *ctx,
 }
 
 void r600_draw_rectangle(struct blitter_context *blitter,
-			 void *vertex_elements_cso,
+			 struct pipe_vertex_elements *vertex_elements_cso,
 			 blitter_get_vs_func get_vs,
 			 int x1, int y1, int x2, int y2,
 			 float depth, unsigned num_instances,
diff --git a/src/gallium/drivers/r600/r600_pipe_common.h b/src/gallium/drivers/r600/r600_pipe_common.h
index 053da4695710..bcde2d794cdc 100644
--- a/src/gallium/drivers/r600/r600_pipe_common.h
+++ b/src/gallium/drivers/r600/r600_pipe_common.h
@@ -678,7 +678,7 @@ void r600_gfx_wait_fence(struct r600_common_context *ctx,
 			 struct r600_resource *buf,
 			 uint64_t va, uint32_t ref, uint32_t mask);
 void r600_draw_rectangle(struct blitter_context *blitter,
-			 void *vertex_elements_cso,
+			 struct pipe_vertex_elements *vertex_elements_cso,
 			 blitter_get_vs_func get_vs,
 			 int x1, int y1, int x2, int y2,
 			 float depth, unsigned num_instances,
diff --git a/src/gallium/drivers/r600/r600_state_common.c b/src/gallium/drivers/r600/r600_state_common.c
index df4c64c8e097..34ae2f201cc4 100644
--- a/src/gallium/drivers/r600/r600_state_common.c
+++ b/src/gallium/drivers/r600/r600_state_common.c
@@ -545,14 +545,14 @@ static void r600_delete_dsa_state(struct pipe_context *ctx, void *state)
 	free(dsa);
 }
 
-static void r600_bind_vertex_elements(struct pipe_context *ctx, void *state)
+static void r600_bind_vertex_elements(struct pipe_context *ctx, struct pipe_vertex_elements *state)
 {
 	struct r600_context *rctx = (struct r600_context *)ctx;
 
 	r600_set_cso_state(rctx, &rctx->vertex_fetch_shader, state);
 }
 
-static void r600_delete_vertex_elements(struct pipe_context *ctx, void *state)
+static void r600_delete_vertex_elements(struct pipe_context *ctx, struct pipe_vertex_elements *state)
 {
 	struct r600_fetch_shader *shader = (struct r600_fetch_shader*)state;
 	if (shader)
diff --git a/src/gallium/drivers/radeonsi/si_pipe.c b/src/gallium/drivers/radeonsi/si_pipe.c
index 5ab79f8aaf79..e9948cbaa25e 100644
--- a/src/gallium/drivers/radeonsi/si_pipe.c
+++ b/src/gallium/drivers/radeonsi/si_pipe.c
@@ -656,8 +656,9 @@ static struct pipe_context *si_create_context(struct pipe_screen *screen, unsign
       sctx->noop_dsa = util_blitter_get_noop_dsa_state(sctx->blitter);
       sctx->queued.named.dsa = sctx->noop_dsa;
 
-      sctx->no_velems_state = sctx->b.create_vertex_elements_state(&sctx->b, 0, NULL);
-      sctx->vertex_elements = sctx->no_velems_state;
+      struct pipe_vertex_elements velems = {0};
+      sctx->no_velems_state = sctx->b.create_vertex_elements_state(&sctx->b, &velems);
+      sctx->vertex_elements = (struct si_vertex_elements*)sctx->no_velems_state;
 
       sctx->discard_rasterizer_state = util_blitter_get_discard_rasterizer_state(sctx->blitter);
       sctx->queued.named.rasterizer = sctx->discard_rasterizer_state;
diff --git a/src/gallium/drivers/radeonsi/si_pipe.h b/src/gallium/drivers/radeonsi/si_pipe.h
index c2623411de8d..d5ec1c2ed669 100644
--- a/src/gallium/drivers/radeonsi/si_pipe.h
+++ b/src/gallium/drivers/radeonsi/si_pipe.h
@@ -963,7 +963,7 @@ struct si_context {
    struct blitter_context *blitter;
    void *noop_blend;
    void *noop_dsa;
-   void *no_velems_state;
+   struct pipe_vertex_elements *no_velems_state;
    void *discard_rasterizer_state;
    void *custom_dsa_flush;
    void *custom_blend_resolve;
diff --git a/src/gallium/drivers/radeonsi/si_state.c b/src/gallium/drivers/radeonsi/si_state.c
index ba0b20404e38..7d7afcac5a9b 100644
--- a/src/gallium/drivers/radeonsi/si_state.c
+++ b/src/gallium/drivers/radeonsi/si_state.c
@@ -4870,8 +4870,8 @@ struct si_fast_udiv_info32 si_compute_fast_udiv_info32(uint32_t D, unsigned num_
    return result;
 }
 
-static void *si_create_vertex_elements(struct pipe_context *ctx, unsigned count,
-                                       const struct pipe_vertex_element *elements)
+static struct pipe_vertex_elements *
+si_create_vertex_elements(struct pipe_context *ctx, const struct pipe_vertex_elements *state)
 {
    struct si_screen *sscreen = (struct si_screen *)ctx->screen;
    struct si_vertex_elements *v = CALLOC_STRUCT(si_vertex_elements);
@@ -4883,29 +4883,30 @@ static void *si_create_vertex_elements(struct pipe_context *ctx, unsigned count,
    STATIC_ASSERT(sizeof(divisor_factors[0].increment) == 4);
    int i;
 
-   assert(count <= SI_MAX_ATTRIBS);
+   assert(state->count <= SI_MAX_ATTRIBS);
    if (!v)
       return NULL;
 
-   v->count = count;
+   v->base = *state;
+   v->count = state->count;
 
    unsigned num_vbos_in_user_sgprs = si_num_vbos_in_user_sgprs(sscreen);
    unsigned alloc_count =
-      count > num_vbos_in_user_sgprs ? count - num_vbos_in_user_sgprs : 0;
+      state->count > num_vbos_in_user_sgprs ? state->count - num_vbos_in_user_sgprs : 0;
    v->vb_desc_list_alloc_size = align(alloc_count * 16, SI_CPDMA_ALIGNMENT);
 
-   for (i = 0; i < count; ++i) {
+   for (i = 0; i < state->count; ++i) {
       const struct util_format_description *desc;
       const struct util_format_channel_description *channel;
       int first_non_void;
-      unsigned vbo_index = elements[i].vertex_buffer_index;
+      unsigned vbo_index = state->input[i].vertex_buffer_index;
 
       if (vbo_index >= SI_NUM_VERTEX_BUFFERS) {
          FREE(v);
          return NULL;
       }
 
-      unsigned instance_divisor = elements[i].instance_divisor;
+      unsigned instance_divisor = state->input[i].instance_divisor;
       if (instance_divisor) {
          if (instance_divisor == 1) {
             v->instance_divisor_is_one |= 1u << i;
@@ -4915,12 +4916,12 @@ static void *si_create_vertex_elements(struct pipe_context *ctx, unsigned count,
          }
       }
 
-      desc = util_format_description(elements[i].src_format);
-      first_non_void = util_format_get_first_non_void_channel(elements[i].src_format);
+      desc = util_format_description(state->input[i].src_format);
+      first_non_void = util_format_get_first_non_void_channel(state->input[i].src_format);
       channel = first_non_void >= 0 ? &desc->channel[first_non_void] : NULL;
 
       v->format_size[i] = desc->block.bits / 8;
-      v->src_offset[i] = elements[i].src_offset;
+      v->src_offset[i] = state->input[i].src_offset;
       v->vertex_buffer_index[i] = vbo_index;
 
       bool always_fix = false;
@@ -4960,7 +4961,7 @@ static void *si_create_vertex_elements(struct pipe_context *ctx, unsigned count,
             unreachable("bad format type");
          }
       } else {
-         switch (elements[i].src_format) {
+         switch (state->input[i].src_format) {
          case PIPE_FORMAT_R11G11B10_FLOAT:
             fix_fetch.u.format = AC_FETCH_FORMAT_FLOAT;
             break;
@@ -4979,7 +4980,7 @@ static void *si_create_vertex_elements(struct pipe_context *ctx, unsigned count,
           */
          always_fix = sscreen->info.gfx_level <= GFX8 && sscreen->info.family != CHIP_STONEY &&
                       channel->type == UTIL_FORMAT_TYPE_SIGNED;
-      } else if (elements[i].src_format == PIPE_FORMAT_R11G11B10_FLOAT) {
+      } else if (state->input[i].src_format == PIPE_FORMAT_R11G11B10_FLOAT) {
          fix_fetch.u.log_size = 3; /* special encoding */
          fix_fetch.u.format = AC_FETCH_FORMAT_FIXED;
          log_hw_load_size = 2;
@@ -5025,7 +5026,7 @@ static void *si_create_vertex_elements(struct pipe_context *ctx, unsigned count,
             (sscreen->info.gfx_level == GFX6 || sscreen->info.gfx_level >= GFX10);
       bool opencode = sscreen->options.vs_fetch_always_opencode;
 
-      if (check_alignment && (elements[i].src_offset & ((1 << log_hw_load_size) - 1)) != 0)
+      if (check_alignment && (state->input[i].src_offset & ((1 << log_hw_load_size) - 1)) != 0)
          opencode = true;
 
       if (always_fix || check_alignment || opencode)
@@ -5050,7 +5051,7 @@ static void *si_create_vertex_elements(struct pipe_context *ctx, unsigned count,
                          S_008F0C_DST_SEL_W(si_map_swizzle(desc->swizzle[3]));
 
       if (sscreen->info.gfx_level >= GFX10) {
-         const struct gfx10_format *fmt = &ac_get_gfx10_format_table(&sscreen->info)[elements[i].src_format];
+         const struct gfx10_format *fmt = &ac_get_gfx10_format_table(&sscreen->info)[state->input[i].src_format];
          assert(fmt->img_format != 0 && fmt->img_format < 128);
          v->rsrc_word3[i] |= S_008F0C_FORMAT(fmt->img_format) |
                              S_008F0C_RESOURCE_LEVEL(sscreen->info.gfx_level < GFX11);
@@ -5075,17 +5076,17 @@ static void *si_create_vertex_elements(struct pipe_context *ctx, unsigned count,
          sscreen->ws->buffer_map(sscreen->ws, v->instance_divisor_factor_buffer->buf, NULL, PIPE_MAP_WRITE);
       memcpy(map, divisor_factors, num_divisors * sizeof(divisor_factors[0]));
    }
-   return v;
+   return &v->base;
 }
 
-static void si_bind_vertex_elements(struct pipe_context *ctx, void *state)
+static void si_bind_vertex_elements(struct pipe_context *ctx, struct pipe_vertex_elements *state)
 {
    struct si_context *sctx = (struct si_context *)ctx;
    struct si_vertex_elements *old = sctx->vertex_elements;
    struct si_vertex_elements *v = (struct si_vertex_elements *)state;
 
    if (!v)
-      v = sctx->no_velems_state;
+      v = (struct si_vertex_elements*)sctx->no_velems_state;
 
    sctx->vertex_elements = v;
    sctx->num_vertex_elements = v->count;
@@ -5120,12 +5121,12 @@ static void si_bind_vertex_elements(struct pipe_context *ctx, void *state)
    }
 }
 
-static void si_delete_vertex_element(struct pipe_context *ctx, void *state)
+static void si_delete_vertex_element(struct pipe_context *ctx, struct pipe_vertex_elements *state)
 {
    struct si_context *sctx = (struct si_context *)ctx;
    struct si_vertex_elements *v = (struct si_vertex_elements *)state;
 
-   if (sctx->vertex_elements == state)
+   if (sctx->vertex_elements == v)
       si_bind_vertex_elements(ctx, sctx->no_velems_state);
 
    si_resource_reference(&v->instance_divisor_factor_buffer, NULL);
@@ -5216,15 +5217,14 @@ static void si_set_vertex_buffers(struct pipe_context *ctx, unsigned start_slot,
 static struct pipe_vertex_state *
 si_create_vertex_state(struct pipe_screen *screen,
                        struct pipe_vertex_buffer *buffer,
-                       const struct pipe_vertex_element *elements,
-                       unsigned num_elements,
+                       const struct pipe_vertex_elements *ve,
                        struct pipe_resource *indexbuf,
                        uint32_t full_velem_mask)
 {
    struct si_screen *sscreen = (struct si_screen *)screen;
    struct si_vertex_state *state = CALLOC_STRUCT(si_vertex_state);
 
-   util_init_pipe_vertex_state(screen, buffer, elements, num_elements, indexbuf, full_velem_mask,
+   util_init_pipe_vertex_state(screen, buffer, ve, indexbuf, full_velem_mask,
                                &state->b);
 
    /* Initialize the vertex element state in state->element.
@@ -5232,9 +5232,10 @@ si_create_vertex_state(struct pipe_screen *screen,
     */
    struct si_context ctx = {};
    ctx.b.screen = screen;
-   struct si_vertex_elements *velems = si_create_vertex_elements(&ctx.b, num_elements, elements);
+   struct si_vertex_elements *velems =
+      (struct si_vertex_elements*)si_create_vertex_elements(&ctx.b, ve);
    state->velems = *velems;
-   si_delete_vertex_element(&ctx.b, velems);
+   si_delete_vertex_element(&ctx.b, &velems->base);
 
    assert(!state->velems.instance_divisor_is_one);
    assert(!state->velems.instance_divisor_is_fetched);
@@ -5242,12 +5243,12 @@ si_create_vertex_state(struct pipe_screen *screen,
    assert(buffer->stride % 4 == 0);
    assert(buffer->buffer_offset % 4 == 0);
    assert(!buffer->is_user_buffer);
-   for (unsigned i = 0; i < num_elements; i++) {
-      assert(elements[i].src_offset % 4 == 0);
-      assert(!elements[i].dual_slot);
+   for (unsigned i = 0; i < ve->count; i++) {
+      assert(ve->input[i].src_offset % 4 == 0);
+      assert(!ve->input[i].dual_slot);
    }
 
-   for (unsigned i = 0; i < num_elements; i++) {
+   for (unsigned i = 0; i < ve->count; i++) {
       si_set_vertex_buffer_descriptor(sscreen, &state->velems, &state->b.input.vbuffer, i,
                                       &state->descriptors[i * 4]);
    }
@@ -5266,14 +5267,13 @@ static void si_vertex_state_destroy(struct pipe_screen *screen,
 static struct pipe_vertex_state *
 si_pipe_create_vertex_state(struct pipe_screen *screen,
                             struct pipe_vertex_buffer *buffer,
-                            const struct pipe_vertex_element *elements,
-                            unsigned num_elements,
+                            const struct pipe_vertex_elements *ve,
                             struct pipe_resource *indexbuf,
                             uint32_t full_velem_mask)
 {
    struct si_screen *sscreen = (struct si_screen *)screen;
 
-   return util_vertex_state_cache_get(screen, buffer, elements, num_elements, indexbuf,
+   return util_vertex_state_cache_get(screen, buffer, ve, indexbuf,
                                       full_velem_mask, &sscreen->vertex_state_cache);
 }
 
diff --git a/src/gallium/drivers/radeonsi/si_state.h b/src/gallium/drivers/radeonsi/si_state.h
index fa60be479334..6d271f54806e 100644
--- a/src/gallium/drivers/radeonsi/si_state.h
+++ b/src/gallium/drivers/radeonsi/si_state.h
@@ -140,6 +140,8 @@ struct si_stencil_ref {
 };
 
 struct si_vertex_elements {
+   struct pipe_vertex_elements base; /* don't change, it's used by memcmp for CSO lookups */
+
    struct si_resource *instance_divisor_factor_buffer;
    uint32_t rsrc_word3[SI_MAX_ATTRIBS];
    uint16_t src_offset[SI_MAX_ATTRIBS];
diff --git a/src/gallium/drivers/radeonsi/si_state_draw.cpp b/src/gallium/drivers/radeonsi/si_state_draw.cpp
index 9fda376f57c7..0c4338f0232f 100644
--- a/src/gallium/drivers/radeonsi/si_state_draw.cpp
+++ b/src/gallium/drivers/radeonsi/si_state_draw.cpp
@@ -2650,7 +2650,8 @@ static void si_draw_vertex_state(struct pipe_context *ctx,
       pipe_vertex_state_reference(&vstate, NULL);
 }
 
-static void si_draw_rectangle(struct blitter_context *blitter, void *vertex_elements_cso,
+static void si_draw_rectangle(struct blitter_context *blitter,
+                              struct pipe_vertex_elements *vertex_elements_cso,
                               blitter_get_vs_func get_vs, int x1, int y1, int x2, int y2,
                               float depth, unsigned num_instances, enum blitter_attrib_type type,
                               const union blitter_attrib *attrib)
diff --git a/src/gallium/drivers/softpipe/sp_context.h b/src/gallium/drivers/softpipe/sp_context.h
index 4e0d87856b5e..dab25c39a745 100644
--- a/src/gallium/drivers/softpipe/sp_context.h
+++ b/src/gallium/drivers/softpipe/sp_context.h
@@ -47,7 +47,6 @@ struct softpipe_tile_cache;
 struct softpipe_tex_tile_cache;
 struct sp_fragment_shader;
 struct sp_vertex_shader;
-struct sp_velems_state;
 struct sp_so_state;
 
 struct softpipe_context {
@@ -62,7 +61,7 @@ struct softpipe_context {
    struct sp_fragment_shader_variant *fs_variant;
    struct sp_vertex_shader *vs;
    struct sp_geometry_shader *gs;
-   struct sp_velems_state *velems;
+   struct pipe_vertex_elements *velems;
    struct sp_so_state *so;
    struct sp_compute_shader *cs;
 
diff --git a/src/gallium/drivers/softpipe/sp_state.h b/src/gallium/drivers/softpipe/sp_state.h
index 63f6994bbc41..8f85438856d4 100644
--- a/src/gallium/drivers/softpipe/sp_state.h
+++ b/src/gallium/drivers/softpipe/sp_state.h
@@ -121,11 +121,6 @@ struct sp_geometry_shader {
    int max_sampler;
 };
 
-struct sp_velems_state {
-   unsigned count;
-   struct pipe_vertex_element velem[PIPE_MAX_ATTRIBS];
-};
-
 struct sp_so_state {
    struct pipe_stream_output_info base;
 };
diff --git a/src/gallium/drivers/softpipe/sp_state_vertex.c b/src/gallium/drivers/softpipe/sp_state_vertex.c
index d46ee6b23c06..87046eb983f0 100644
--- a/src/gallium/drivers/softpipe/sp_state_vertex.c
+++ b/src/gallium/drivers/softpipe/sp_state_vertex.c
@@ -39,40 +39,36 @@
 #include "draw/draw_context.h"
 
 
-static void *
+static struct pipe_vertex_elements *
 softpipe_create_vertex_elements_state(struct pipe_context *pipe,
-                                      unsigned count,
-                                      const struct pipe_vertex_element *attribs)
+                                      const struct pipe_vertex_elements *attribs)
 {
-   struct sp_velems_state *velems;
-   assert(count <= PIPE_MAX_ATTRIBS);
-   velems = (struct sp_velems_state *) MALLOC(sizeof(struct sp_velems_state));
-   if (velems) {
-      velems->count = count;
-      memcpy(velems->velem, attribs, sizeof(*attribs) * count);
-   }
+   struct pipe_vertex_elements *velems;
+   assert(attribs->count <= PIPE_MAX_ATTRIBS);
+   velems = (struct pipe_vertex_elements *) MALLOC(sizeof(struct pipe_vertex_elements));
+   *velems = *attribs;
    return velems;
 }
 
 
 static void
 softpipe_bind_vertex_elements_state(struct pipe_context *pipe,
-                                    void *velems)
+                                    struct pipe_vertex_elements *velems)
 {
    struct softpipe_context *softpipe = softpipe_context(pipe);
-   struct sp_velems_state *sp_velems = (struct sp_velems_state *) velems;
 
-   softpipe->velems = sp_velems;
+   softpipe->velems = velems;
 
    softpipe->dirty |= SP_NEW_VERTEX;
 
-   if (sp_velems)
-      draw_set_vertex_elements(softpipe->draw, sp_velems->count, sp_velems->velem);
+   if (velems)
+      draw_set_vertex_elements(softpipe->draw, velems->count, velems->input);
 }
 
 
 static void
-softpipe_delete_vertex_elements_state(struct pipe_context *pipe, void *velems)
+softpipe_delete_vertex_elements_state(struct pipe_context *pipe,
+                                      struct pipe_vertex_elements *velems)
 {
    FREE( velems );
 }
diff --git a/src/gallium/drivers/svga/svga_context.h b/src/gallium/drivers/svga/svga_context.h
index 0227d64cf690..3c102ea64a03 100644
--- a/src/gallium/drivers/svga/svga_context.h
+++ b/src/gallium/drivers/svga/svga_context.h
@@ -261,8 +261,7 @@ svga_pipe_sampler_view(struct pipe_sampler_view *v)
 
 
 struct svga_velems_state {
-   unsigned count;
-   struct pipe_vertex_element velem[PIPE_MAX_ATTRIBS];
+   struct pipe_vertex_elements base; /* don't change, it's used by memcmp for CSO lookups */
    SVGA3dDeclType decl_type[PIPE_MAX_ATTRIBS]; /**< vertex attrib formats */
 
    /** Bitmasks indicating which attributes need format conversion */
diff --git a/src/gallium/drivers/svga/svga_pipe_blit.c b/src/gallium/drivers/svga/svga_pipe_blit.c
index d5be5697cdd8..4f88ca4ff2fb 100644
--- a/src/gallium/drivers/svga/svga_pipe_blit.c
+++ b/src/gallium/drivers/svga/svga_pipe_blit.c
@@ -620,7 +620,8 @@ try_blit(struct svga_context *svga, const struct pipe_blit_info *blit_info)
    /* XXX turn off occlusion and streamout queries */
 
    util_blitter_save_vertex_buffer_slot(svga->blitter, svga->curr.vb);
-   util_blitter_save_vertex_elements(svga->blitter, (void*)svga->curr.velems);
+   util_blitter_save_vertex_elements(svga->blitter,
+                                     (struct pipe_vertex_elements*)&svga->curr.velems->base);
    util_blitter_save_vertex_shader(svga->blitter, svga->curr.vs);
    util_blitter_save_geometry_shader(svga->blitter, svga->curr.user_gs);
    util_blitter_save_tessctrl_shader(svga->blitter, svga->curr.tcs);
diff --git a/src/gallium/drivers/svga/svga_pipe_clear.c b/src/gallium/drivers/svga/svga_pipe_clear.c
index 810dfd682c25..adf2f7bdd65d 100644
--- a/src/gallium/drivers/svga/svga_pipe_clear.c
+++ b/src/gallium/drivers/svga/svga_pipe_clear.c
@@ -42,7 +42,8 @@ static void
 begin_blit(struct svga_context *svga)
 {
    util_blitter_save_vertex_buffer_slot(svga->blitter, svga->curr.vb);
-   util_blitter_save_vertex_elements(svga->blitter, (void*)svga->curr.velems);
+   util_blitter_save_vertex_elements(svga->blitter,
+                                     (struct pipe_vertex_elements*)&svga->curr.velems->base);
    util_blitter_save_vertex_shader(svga->blitter, svga->curr.vs);
    util_blitter_save_geometry_shader(svga->blitter, svga->curr.gs);
    util_blitter_save_tessctrl_shader(svga->blitter, svga->curr.tcs);
diff --git a/src/gallium/drivers/svga/svga_pipe_vertex.c b/src/gallium/drivers/svga/svga_pipe_vertex.c
index 89865d55c644..bd75f67d8977 100644
--- a/src/gallium/drivers/svga/svga_pipe_vertex.c
+++ b/src/gallium/drivers/svga/svga_pipe_vertex.c
@@ -126,11 +126,11 @@ define_input_element_object(struct svga_context *svga,
    SVGA3dInputElementDesc elements[PIPE_MAX_ATTRIBS];
    unsigned i;
 
-   assert(velems->count <= PIPE_MAX_ATTRIBS);
+   assert(velems->base.count <= PIPE_MAX_ATTRIBS);
    assert(svga_have_vgpu10(svga));
 
-   for (i = 0; i < velems->count; i++) {
-      const struct pipe_vertex_element *elem = velems->velem + i;
+   for (i = 0; i < velems->base.count; i++) {
+      const struct pipe_vertex_element *elem = velems->base.input + i;
       SVGA3dSurfaceFormat svga_format;
       unsigned vf_flags;
 
@@ -189,7 +189,7 @@ define_input_element_object(struct svga_context *svga,
 
    velems->id = util_bitmask_add(svga->input_element_object_id_bm);
 
-   SVGA_RETRY(svga, SVGA3D_vgpu10_DefineElementLayout(svga->swc, velems->count,
+   SVGA_RETRY(svga, SVGA3D_vgpu10_DefineElementLayout(svga->swc, velems->base.count,
                                                       velems->id, elements));
 }
 
@@ -206,8 +206,8 @@ translate_vertex_decls(struct svga_context *svga,
 
    assert(!svga_have_vgpu10(svga));
 
-   for (i = 0; i < velems->count; i++) {
-      const enum pipe_format f = velems->velem[i].src_format;
+   for (i = 0; i < velems->base.count; i++) {
+      const enum pipe_format f = velems->base.input[i].src_format;
       SVGA3dSurfaceFormat svga_format;
       unsigned vf_flags;
 
@@ -231,19 +231,17 @@ translate_vertex_decls(struct svga_context *svga,
 }
 
 
-static void *
+static struct pipe_vertex_elements *
 svga_create_vertex_elements_state(struct pipe_context *pipe,
-                                  unsigned count,
-                                  const struct pipe_vertex_element *attribs)
+                                  const struct pipe_vertex_elements *attribs)
 {
    struct svga_context *svga = svga_context(pipe);
    struct svga_velems_state *velems;
 
-   assert(count <= PIPE_MAX_ATTRIBS);
+   assert(attribs->count <= PIPE_MAX_ATTRIBS);
    velems = (struct svga_velems_state *) MALLOC(sizeof(struct svga_velems_state));
    if (velems) {
-      velems->count = count;
-      memcpy(velems->velem, attribs, sizeof(*attribs) * count);
+      velems->base = *attribs;
 
       velems->need_swvfetch = FALSE;
       velems->adjust_attrib_range = 0x0;
@@ -268,12 +266,12 @@ svga_create_vertex_elements_state(struct pipe_context *pipe,
    SVGA_STATS_COUNT_INC(svga_screen(svga->pipe.screen)->sws,
                         SVGA_STATS_COUNT_VERTEXELEMENT);
 
-   return velems;
+   return &velems->base;
 }
 
 
 static void
-svga_bind_vertex_elements_state(struct pipe_context *pipe, void *state)
+svga_bind_vertex_elements_state(struct pipe_context *pipe, struct pipe_vertex_elements *state)
 {
    struct svga_context *svga = svga_context(pipe);
    struct svga_velems_state *velems = (struct svga_velems_state *) state;
@@ -284,7 +282,7 @@ svga_bind_vertex_elements_state(struct pipe_context *pipe, void *state)
 
 
 static void
-svga_delete_vertex_elements_state(struct pipe_context *pipe, void *state)
+svga_delete_vertex_elements_state(struct pipe_context *pipe, struct pipe_vertex_elements *state)
 {
    struct svga_context *svga = svga_context(pipe);
    struct svga_velems_state *velems = (struct svga_velems_state *) state;
diff --git a/src/gallium/drivers/svga/svga_state_vdecl.c b/src/gallium/drivers/svga/svga_state_vdecl.c
index 8a139685cc88..1c378a8fcabf 100644
--- a/src/gallium/drivers/svga/svga_state_vdecl.c
+++ b/src/gallium/drivers/svga/svga_state_vdecl.c
@@ -42,13 +42,13 @@
 static enum pipe_error
 emit_hw_vs_vdecl(struct svga_context *svga, uint64_t dirty)
 {
-   const struct pipe_vertex_element *ve = svga->curr.velems->velem;
+   const struct pipe_vertex_element *ve = svga->curr.velems->base.input;
    SVGA3dVertexDecl decls[SVGA3D_INPUTREG_MAX];
    unsigned buffer_indexes[SVGA3D_INPUTREG_MAX];
    unsigned i;
    unsigned neg_bias = 0;
 
-   assert(svga->curr.velems->count >=
+   assert(svga->curr.velems->base.count >=
           svga->curr.vs->base.info.num_inputs);
 
    /**
@@ -66,7 +66,7 @@ emit_hw_vs_vdecl(struct svga_context *svga, uint64_t dirty)
     * confusion.
     */
 
-   for (i = 0; i < svga->curr.velems->count; i++) {
+   for (i = 0; i < svga->curr.velems->base.count; i++) {
       const struct pipe_vertex_buffer *vb =
          &svga->curr.vb[ve[i].vertex_buffer_index];
       struct svga_buffer *buffer;
@@ -85,7 +85,7 @@ emit_hw_vs_vdecl(struct svga_context *svga, uint64_t dirty)
       }
    }
 
-   for (i = 0; i < svga->curr.velems->count; i++) {
+   for (i = 0; i < svga->curr.velems->base.count; i++) {
       const struct pipe_vertex_buffer *vb =
          &svga->curr.vb[ve[i].vertex_buffer_index];
       unsigned usage, index;
@@ -121,7 +121,7 @@ emit_hw_vs_vdecl(struct svga_context *svga, uint64_t dirty)
    }
 
    svga_hwtnl_vertex_decls(svga->hwtnl,
-                           svga->curr.velems->count,
+                           svga->curr.velems->base.count,
                            decls,
                            buffer_indexes,
                            svga->curr.velems->id);
diff --git a/src/gallium/drivers/svga/svga_swtnl_state.c b/src/gallium/drivers/svga/svga_swtnl_state.c
index a02e82d9186e..697386f1e3bf 100644
--- a/src/gallium/drivers/svga/svga_swtnl_state.c
+++ b/src/gallium/drivers/svga/svga_swtnl_state.c
@@ -119,8 +119,8 @@ update_swtnl_draw(struct svga_context *svga, uint64_t dirty)
 
    if (dirty & SVGA_NEW_VELEMENT)
       draw_set_vertex_elements(svga->swtnl.draw,
-                               svga->curr.velems->count,
-                               svga->curr.velems->velem);
+                               svga->curr.velems->base.count,
+                               svga->curr.velems->base.input);
 
    if (dirty & SVGA_NEW_CLIP)
       draw_set_clip_state(svga->swtnl.draw,
diff --git a/src/gallium/drivers/tegra/tegra_context.c b/src/gallium/drivers/tegra/tegra_context.c
index 6e268a696e11..9bf3c4cff1f4 100644
--- a/src/gallium/drivers/tegra/tegra_context.c
+++ b/src/gallium/drivers/tegra/tegra_context.c
@@ -403,20 +403,18 @@ tegra_delete_tes_state(struct pipe_context *pcontext, void *so)
    context->gpu->delete_tes_state(context->gpu, so);
 }
 
-static void *
+static struct pipe_vertex_elements *
 tegra_create_vertex_elements_state(struct pipe_context *pcontext,
-                                   unsigned num_elements,
-                                   const struct pipe_vertex_element *elements)
+                                   const struct pipe_vertex_elements *elements)
 {
    struct tegra_context *context = to_tegra_context(pcontext);
 
    return context->gpu->create_vertex_elements_state(context->gpu,
-                                                     num_elements,
                                                      elements);
 }
 
 static void
-tegra_bind_vertex_elements_state(struct pipe_context *pcontext, void *so)
+tegra_bind_vertex_elements_state(struct pipe_context *pcontext, struct pipe_vertex_elements *so)
 {
    struct tegra_context *context = to_tegra_context(pcontext);
 
@@ -424,7 +422,7 @@ tegra_bind_vertex_elements_state(struct pipe_context *pcontext, void *so)
 }
 
 static void
-tegra_delete_vertex_elements_state(struct pipe_context *pcontext, void *so)
+tegra_delete_vertex_elements_state(struct pipe_context *pcontext, struct pipe_vertex_elements *so)
 {
    struct tegra_context *context = to_tegra_context(pcontext);
 
diff --git a/src/gallium/drivers/v3d/v3d_blit.c b/src/gallium/drivers/v3d/v3d_blit.c
index 9b29bca59558..03cece05edcf 100644
--- a/src/gallium/drivers/v3d/v3d_blit.c
+++ b/src/gallium/drivers/v3d/v3d_blit.c
@@ -42,7 +42,7 @@ v3d_blitter_save(struct v3d_context *v3d, bool op_blit)
         util_blitter_save_fragment_constant_buffer_slot(v3d->blitter,
                                                         v3d->constbuf[PIPE_SHADER_FRAGMENT].cb);
         util_blitter_save_vertex_buffer_slot(v3d->blitter, v3d->vertexbuf.vb);
-        util_blitter_save_vertex_elements(v3d->blitter, v3d->vtx);
+        util_blitter_save_vertex_elements(v3d->blitter, &v3d->vtx->base);
         util_blitter_save_vertex_shader(v3d->blitter, v3d->prog.bind_vs);
         util_blitter_save_geometry_shader(v3d->blitter, v3d->prog.bind_gs);
         util_blitter_save_so_targets(v3d->blitter, v3d->streamout.num_targets,
diff --git a/src/gallium/drivers/v3d/v3d_context.h b/src/gallium/drivers/v3d/v3d_context.h
index cd87ade9bc80..28b4f370f890 100644
--- a/src/gallium/drivers/v3d/v3d_context.h
+++ b/src/gallium/drivers/v3d/v3d_context.h
@@ -261,9 +261,7 @@ struct v3d_vertexbuf_stateobj {
 };
 
 struct v3d_vertex_stateobj {
-        struct pipe_vertex_element pipe[V3D_MAX_VS_INPUTS / 4];
-        unsigned num_elements;
-
+        struct pipe_vertex_elements base; /* don't change, it's used by memcmp for CSO lookups */
         uint8_t attrs[16 * (V3D_MAX_VS_INPUTS / 4)];
         struct pipe_resource *defaults;
         uint32_t defaults_offset;
diff --git a/src/gallium/drivers/v3d/v3d_program.c b/src/gallium/drivers/v3d/v3d_program.c
index 418b8b2b2bc5..a9694032d74d 100644
--- a/src/gallium/drivers/v3d/v3d_program.c
+++ b/src/gallium/drivers/v3d/v3d_program.c
@@ -770,7 +770,7 @@ v3d_update_compiled_vs(struct v3d_context *v3d, uint8_t prim_mode)
 
         nir_shader *s = v3d->prog.bind_vs->base.ir.nir;
         uint64_t inputs_read = s->info.inputs_read;
-        assert(util_bitcount(inputs_read) <= v3d->vtx->num_elements);
+        assert(util_bitcount(inputs_read) <= v3d->vtx->base.count);
 
         while (inputs_read) {
                 int location = u_bit_scan64(&inputs_read);
@@ -778,7 +778,7 @@ v3d_update_compiled_vs(struct v3d_context *v3d, uint8_t prim_mode)
                         nir_find_variable_with_location(s, nir_var_shader_in, location);
                 assert (var != NULL);
                 int driver_location = var->data.driver_location;
-                switch (v3d->vtx->pipe[driver_location].src_format) {
+                switch (v3d->vtx->base.input[driver_location].src_format) {
                 case PIPE_FORMAT_B8G8R8A8_UNORM:
                 case PIPE_FORMAT_B10G10R10A2_UNORM:
                 case PIPE_FORMAT_B10G10R10A2_SNORM:
diff --git a/src/gallium/drivers/v3d/v3dx_draw.c b/src/gallium/drivers/v3d/v3dx_draw.c
index b303d6a1756f..dae10ce62291 100644
--- a/src/gallium/drivers/v3d/v3dx_draw.c
+++ b/src/gallium/drivers/v3d/v3dx_draw.c
@@ -526,8 +526,8 @@ v3d_emit_gl_shader_state(struct v3d_context *v3d,
         job->tmu_dirty_rcl |= v3d->prog.fs->prog_data.fs->base.tmu_dirty_rcl;
 
         uint32_t num_elements_to_emit = 0;
-        for (int i = 0; i < vtx->num_elements; i++) {
-                struct pipe_vertex_element *elem = &vtx->pipe[i];
+        for (int i = 0; i < vtx->base.count; i++) {
+                struct pipe_vertex_element *elem = &vtx->base.input[i];
                 struct pipe_vertex_buffer *vb =
                         &vertexbuf->vb[elem->vertex_buffer_index];
                 if (vb->buffer.resource)
@@ -730,8 +730,8 @@ v3d_emit_gl_shader_state(struct v3d_context *v3d,
         }
 
         bool cs_loaded_any = false;
-        for (int i = 0; i < vtx->num_elements; i++) {
-                struct pipe_vertex_element *elem = &vtx->pipe[i];
+        for (int i = 0; i < vtx->base.count; i++) {
+                struct pipe_vertex_element *elem = &vtx->base.input[i];
                 struct pipe_vertex_buffer *vb =
                         &vertexbuf->vb[elem->vertex_buffer_index];
                 struct v3d_resource *rsc = v3d_resource(vb->buffer.resource);
@@ -762,7 +762,7 @@ v3d_emit_gl_shader_state(struct v3d_context *v3d,
                          */
                         if (v3d->prog.cs->prog_data.vs->vattr_sizes[i])
                                 cs_loaded_any = true;
-                        if (i == vtx->num_elements - 1 && !cs_loaded_any) {
+                        if (i == vtx->base.count - 1 && !cs_loaded_any) {
                                 attr.number_of_values_read_by_coordinate_shader = 1;
                         }
 #if V3D_VERSION >= 41
diff --git a/src/gallium/drivers/v3d/v3dx_state.c b/src/gallium/drivers/v3d/v3dx_state.c
index b7651def3a7a..428f51cb8086 100644
--- a/src/gallium/drivers/v3d/v3dx_state.c
+++ b/src/gallium/drivers/v3d/v3dx_state.c
@@ -337,9 +337,9 @@ v3d_zsa_state_bind(struct pipe_context *pctx, void *hwcso)
         v3d->dirty |= V3D_DIRTY_ZSA;
 }
 
-static void *
-v3d_vertex_state_create(struct pipe_context *pctx, unsigned num_elements,
-                        const struct pipe_vertex_element *elements)
+static struct pipe_vertex_elements *
+v3d_vertex_state_create(struct pipe_context *pctx,
+                        const struct pipe_vertex_elements *elements)
 {
         struct v3d_context *v3d = v3d_context(pctx);
         struct v3d_vertex_stateobj *so = CALLOC_STRUCT(v3d_vertex_stateobj);
@@ -347,11 +347,10 @@ v3d_vertex_state_create(struct pipe_context *pctx, unsigned num_elements,
         if (!so)
                 return NULL;
 
-        memcpy(so->pipe, elements, sizeof(*elements) * num_elements);
-        so->num_elements = num_elements;
+        so->base = *elements;
 
-        for (int i = 0; i < so->num_elements; i++) {
-                const struct pipe_vertex_element *elem = &elements[i];
+        for (int i = 0; i < so->base.count; i++) {
+                const struct pipe_vertex_element *elem = &elements->input[i];
                 const struct util_format_description *desc =
                         util_format_description(elem->src_format);
                 uint32_t r_size = desc->channel[0].size;
@@ -426,8 +425,8 @@ v3d_vertex_state_create(struct pipe_context *pctx, unsigned num_elements,
                 attrs[i * 4 + 0] = 0;
                 attrs[i * 4 + 1] = 0;
                 attrs[i * 4 + 2] = 0;
-                if (i < so->num_elements &&
-                    util_format_is_pure_integer(so->pipe[i].src_format)) {
+                if (i < so->base.count &&
+                    util_format_is_pure_integer(so->base.input[i].src_format)) {
                         attrs[i * 4 + 3] = 1;
                 } else {
                         attrs[i * 4 + 3] = fui(1.0);
@@ -435,23 +434,23 @@ v3d_vertex_state_create(struct pipe_context *pctx, unsigned num_elements,
         }
 
         u_upload_unmap(v3d->state_uploader);
-        return so;
+        return &so->base;
 }
 
 static void
-v3d_vertex_state_delete(struct pipe_context *pctx, void *hwcso)
+v3d_vertex_state_delete(struct pipe_context *pctx, struct pipe_vertex_elements *hwcso)
 {
-        struct v3d_vertex_stateobj *so = hwcso;
+        struct v3d_vertex_stateobj *so = (struct v3d_vertex_stateobj *)hwcso;
 
         pipe_resource_reference(&so->defaults, NULL);
         free(so);
 }
 
 static void
-v3d_vertex_state_bind(struct pipe_context *pctx, void *hwcso)
+v3d_vertex_state_bind(struct pipe_context *pctx, struct pipe_vertex_elements *hwcso)
 {
         struct v3d_context *v3d = v3d_context(pctx);
-        v3d->vtx = hwcso;
+        v3d->vtx = (struct v3d_vertex_stateobj *)hwcso;
         v3d->dirty |= V3D_DIRTY_VTXSTATE;
 }
 
diff --git a/src/gallium/drivers/vc4/vc4_context.h b/src/gallium/drivers/vc4/vc4_context.h
index a55f808a7f63..c56bb9cbae97 100644
--- a/src/gallium/drivers/vc4/vc4_context.h
+++ b/src/gallium/drivers/vc4/vc4_context.h
@@ -187,11 +187,6 @@ struct vc4_vertexbuf_stateobj {
         uint32_t dirty_mask;
 };
 
-struct vc4_vertex_stateobj {
-        struct pipe_vertex_element pipe[PIPE_MAX_ATTRIBS];
-        unsigned num_elements;
-};
-
 /* Hash table key for vc4->jobs */
 struct vc4_job_key {
         struct pipe_surface *cbuf;
@@ -367,7 +362,7 @@ struct vc4_context {
 
         struct vc4_program_stateobj prog;
 
-        struct vc4_vertex_stateobj *vtx;
+        struct pipe_vertex_elements *vtx;
 
         struct {
                 struct pipe_blend_color f;
diff --git a/src/gallium/drivers/vc4/vc4_draw.c b/src/gallium/drivers/vc4/vc4_draw.c
index 0143072fe120..e2d98293b9f6 100644
--- a/src/gallium/drivers/vc4/vc4_draw.c
+++ b/src/gallium/drivers/vc4/vc4_draw.c
@@ -137,14 +137,14 @@ vc4_emit_gl_shader_state(struct vc4_context *vc4,
 {
         struct vc4_job *job = vc4->job;
         /* VC4_DIRTY_VTXSTATE */
-        struct vc4_vertex_stateobj *vtx = vc4->vtx;
+        struct pipe_vertex_elements *vtx = vc4->vtx;
         /* VC4_DIRTY_VTXBUF */
         struct vc4_vertexbuf_stateobj *vertexbuf = &vc4->vertexbuf;
 
         /* The simulator throws a fit if VS or CS don't read an attribute, so
          * we emit a dummy read.
          */
-        uint32_t num_elements_emit = MAX2(vtx->num_elements, 1);
+        uint32_t num_elements_emit = MAX2(vtx->count, 1);
 
         /* Emit the shader record. */
         cl_start_shader_reloc(&job->shader_rec, 3 + num_elements_emit);
@@ -184,8 +184,8 @@ vc4_emit_gl_shader_state(struct vc4_context *vc4,
 
         uint32_t max_index = 0xffff;
         unsigned index_bias = info->index_size ? draws->index_bias : 0;
-        for (int i = 0; i < vtx->num_elements; i++) {
-                struct pipe_vertex_element *elem = &vtx->pipe[i];
+        for (int i = 0; i < vtx->count; i++) {
+                struct pipe_vertex_element *elem = &vtx->input[i];
                 struct pipe_vertex_buffer *vb =
                         &vertexbuf->vb[elem->vertex_buffer_index];
                 struct vc4_resource *rsc = vc4_resource(vb->buffer.resource);
@@ -214,7 +214,7 @@ vc4_emit_gl_shader_state(struct vc4_context *vc4,
                 }
         }
 
-        if (vtx->num_elements == 0) {
+        if (vtx->count == 0) {
                 assert(num_elements_emit == 1);
                 struct vc4_bo *bo = vc4_bo_alloc(vc4->screen, 4096, "scratch VBO");
 
@@ -234,7 +234,7 @@ vc4_emit_gl_shader_state(struct vc4_context *vc4,
                  * attributes.  This field also contains the offset into
                  * shader_rec.
                  */
-                assert(vtx->num_elements <= 8);
+                assert(vtx->count <= 8);
                 shader_state.number_of_attribute_arrays =
                         num_elements_emit & 0x7;
         }
diff --git a/src/gallium/drivers/vc4/vc4_program.c b/src/gallium/drivers/vc4/vc4_program.c
index 86e7ba13722c..4fb5dff9ddc0 100644
--- a/src/gallium/drivers/vc4/vc4_program.c
+++ b/src/gallium/drivers/vc4/vc4_program.c
@@ -2784,7 +2784,7 @@ vc4_update_compiled_vs(struct vc4_context *vc4, uint8_t prim_mode)
         key->fs_inputs = vc4->prog.fs->fs_inputs;
 
         for (int i = 0; i < ARRAY_SIZE(key->attr_formats); i++)
-                key->attr_formats[i] = vc4->vtx->pipe[i].src_format;
+                key->attr_formats[i] = vc4->vtx->input[i].src_format;
 
         key->per_vertex_point_size =
                 (prim_mode == PIPE_PRIM_POINTS &&
diff --git a/src/gallium/drivers/vc4/vc4_state.c b/src/gallium/drivers/vc4/vc4_state.c
index ad068494b3e6..17589ed443da 100644
--- a/src/gallium/drivers/vc4/vc4_state.c
+++ b/src/gallium/drivers/vc4/vc4_state.c
@@ -47,6 +47,12 @@ vc4_generic_cso_state_delete(struct pipe_context *pctx, void *hwcso)
         free(hwcso);
 }
 
+static void
+vc4_vertex_state_delete(struct pipe_context *pctx, struct pipe_vertex_elements *hwcso)
+{
+        free(hwcso);
+}
+
 static void
 vc4_set_blend_color(struct pipe_context *pctx,
                     const struct pipe_blend_color *blend_color)
@@ -360,23 +366,21 @@ vc4_zsa_state_bind(struct pipe_context *pctx, void *hwcso)
         vc4->dirty |= VC4_DIRTY_ZSA;
 }
 
-static void *
-vc4_vertex_state_create(struct pipe_context *pctx, unsigned num_elements,
-                        const struct pipe_vertex_element *elements)
+static struct pipe_vertex_elements *
+vc4_vertex_state_create(struct pipe_context *pctx,
+                        const struct pipe_vertex_elements *elements)
 {
-        struct vc4_vertex_stateobj *so = CALLOC_STRUCT(vc4_vertex_stateobj);
+        struct pipe_vertex_elements *so = CALLOC_STRUCT(pipe_vertex_elements);
 
         if (!so)
                 return NULL;
 
-        memcpy(so->pipe, elements, sizeof(*elements) * num_elements);
-        so->num_elements = num_elements;
-
+        *so = *elements;
         return so;
 }
 
 static void
-vc4_vertex_state_bind(struct pipe_context *pctx, void *hwcso)
+vc4_vertex_state_bind(struct pipe_context *pctx, struct pipe_vertex_elements *hwcso)
 {
         struct vc4_context *vc4 = vc4_context(pctx);
         vc4->vtx = hwcso;
@@ -708,7 +712,7 @@ vc4_state_init(struct pipe_context *pctx)
         pctx->delete_depth_stencil_alpha_state = vc4_generic_cso_state_delete;
 
         pctx->create_vertex_elements_state = vc4_vertex_state_create;
-        pctx->delete_vertex_elements_state = vc4_generic_cso_state_delete;
+        pctx->delete_vertex_elements_state = vc4_vertex_state_delete;
         pctx->bind_vertex_elements_state = vc4_vertex_state_bind;
 
         pctx->create_sampler_state = vc4_create_sampler_state;
diff --git a/src/gallium/drivers/virgl/virgl_context.c b/src/gallium/drivers/virgl/virgl_context.c
index ad1ed8756c90..5d59c6e6b6ea 100644
--- a/src/gallium/drivers/virgl/virgl_context.c
+++ b/src/gallium/drivers/virgl/virgl_context.c
@@ -52,6 +52,7 @@
 #include "virgl_video.h"
 
 struct virgl_vertex_elements_state {
+   struct pipe_vertex_elements base; /* don't change, it's used by memcmp for CSO lookups */
    uint32_t handle;
    uint8_t binding_map[PIPE_MAX_ATTRIBS];
    uint8_t num_bindings;
@@ -513,40 +514,42 @@ static void virgl_set_viewport_states(struct pipe_context *ctx,
    virgl_encoder_set_viewport_states(vctx, start_slot, num_viewports, state);
 }
 
-static void *virgl_create_vertex_elements_state(struct pipe_context *ctx,
-                                                        unsigned num_elements,
-                                                        const struct pipe_vertex_element *elements)
+static struct pipe_vertex_elements *
+virgl_create_vertex_elements_state(struct pipe_context *ctx,
+                                   const struct pipe_vertex_elements *elements)
 {
-   struct pipe_vertex_element new_elements[PIPE_MAX_ATTRIBS];
+   struct pipe_vertex_elements new_elements;
    struct virgl_context *vctx = virgl_context(ctx);
    struct virgl_vertex_elements_state *state =
       CALLOC_STRUCT(virgl_vertex_elements_state);
 
-   for (int i = 0; i < num_elements; ++i) {
-      if (elements[i].instance_divisor) {
+   state->base = *elements;
+
+   for (int i = 0; i < elements->count; ++i) {
+      if (elements->input[i].instance_divisor) {
 	 /* Virglrenderer doesn't deal with instance_divisor correctly if
 	  * there isn't a 1:1 relationship between elements and bindings.
 	  * So let's make sure there is, by duplicating bindings.
 	  */
-	 for (int j = 0; j < num_elements; ++j) {
-            new_elements[j] = elements[j];
-            new_elements[j].vertex_buffer_index = j;
-            state->binding_map[j] = elements[j].vertex_buffer_index;
+         new_elements = *elements;
+	 for (int j = 0; j < elements->count; ++j) {
+            new_elements.input[j].vertex_buffer_index = j;
+            state->binding_map[j] = elements->input[j].vertex_buffer_index;
 	 }
-	 elements = new_elements;
-	 state->num_bindings = num_elements;
+	 elements = &new_elements;
+	 state->num_bindings = elements->count;
 	 break;
       }
    }
 
    state->handle = virgl_object_assign_handle();
    virgl_encoder_create_vertex_elements(vctx, state->handle,
-                                       num_elements, elements);
-   return state;
+                                        elements->count, elements->input);
+   return &state->base;
 }
 
 static void virgl_delete_vertex_elements_state(struct pipe_context *ctx,
-                                              void *ve)
+                                               struct pipe_vertex_elements *ve)
 {
    struct virgl_context *vctx = virgl_context(ctx);
    struct virgl_vertex_elements_state *state =
@@ -556,7 +559,7 @@ static void virgl_delete_vertex_elements_state(struct pipe_context *ctx,
 }
 
 static void virgl_bind_vertex_elements_state(struct pipe_context *ctx,
-                                                     void *ve)
+                                             struct pipe_vertex_elements *ve)
 {
    struct virgl_context *vctx = virgl_context(ctx);
    struct virgl_vertex_elements_state *state =
diff --git a/src/gallium/drivers/zink/zink_blit.c b/src/gallium/drivers/zink/zink_blit.c
index b1bf3cb2c29f..360300912e94 100644
--- a/src/gallium/drivers/zink/zink_blit.c
+++ b/src/gallium/drivers/zink/zink_blit.c
@@ -378,7 +378,7 @@ end:
 void
 zink_blit_begin(struct zink_context *ctx, enum zink_blit_flags flags)
 {
-   util_blitter_save_vertex_elements(ctx->blitter, ctx->element_state);
+   util_blitter_save_vertex_elements(ctx->blitter, &ctx->element_state->base);
    util_blitter_save_viewport(ctx->blitter, ctx->vp_state.viewport_states);
 
    util_blitter_save_vertex_buffer_slot(ctx->blitter, ctx->vertex_buffers);
diff --git a/src/gallium/drivers/zink/zink_state.c b/src/gallium/drivers/zink/zink_state.c
index e6783ebbc1ac..79abb10d1493 100644
--- a/src/gallium/drivers/zink/zink_state.c
+++ b/src/gallium/drivers/zink/zink_state.c
@@ -36,16 +36,16 @@
 
 #include <math.h>
 
-static void *
+static struct pipe_vertex_elements *
 zink_create_vertex_elements_state(struct pipe_context *pctx,
-                                  unsigned num_elements,
-                                  const struct pipe_vertex_element *elements)
+                                  const struct pipe_vertex_elements *elements)
 {
    struct zink_screen *screen = zink_screen(pctx->screen);
    unsigned int i;
    struct zink_vertex_elements_state *ves = CALLOC_STRUCT(zink_vertex_elements_state);
    if (!ves)
       return NULL;
+   ves->base = *elements;
    ves->hw_state.hash = _mesa_hash_pointer(ves);
 
    int buffer_map[PIPE_MAX_ATTRIBS];
@@ -57,8 +57,8 @@ zink_create_vertex_elements_state(struct pipe_context *pctx,
    uint32_t size8 = 0;
    uint32_t size16 = 0;
    uint32_t size32 = 0;
-   for (i = 0; i < num_elements; ++i) {
-      const struct pipe_vertex_element *elem = elements + i;
+   for (i = 0; i < elements->count; ++i) {
+      const struct pipe_vertex_element *elem = elements->input + i;
 
       int binding = elem->vertex_buffer_index;
       if (buffer_map[binding] < 0) {
@@ -122,9 +122,12 @@ zink_create_vertex_elements_state(struct pipe_context *pctx,
          ves->min_stride[binding] = MAX2(ves->min_stride[binding], elem->src_offset + vk_format_get_blocksize(format));
       }
    }
+
+   unsigned num_elements = elements->count;
+
    assert(num_decomposed + num_elements <= PIPE_MAX_ATTRIBS);
    u_foreach_bit(i, ves->decomposed_attrs | ves->decomposed_attrs_without_w) {
-      const struct pipe_vertex_element *elem = elements + i;
+      const struct pipe_vertex_element *elem = elements->input + i;
       const struct util_format_description *desc = util_format_description(elem->src_format);
       unsigned size = 1;
       if (size32 & BITFIELD_BIT(i))
@@ -169,16 +172,16 @@ zink_create_vertex_elements_state(struct pipe_context *pctx,
          }
       }
    }
-   return ves;
+   return &ves->base;
 }
 
 static void
 zink_bind_vertex_elements_state(struct pipe_context *pctx,
-                                void *cso)
+                                struct pipe_vertex_elements *cso)
 {
    struct zink_context *ctx = zink_context(pctx);
    struct zink_gfx_pipeline_state *state = &ctx->gfx_pipeline_state;
-   ctx->element_state = cso;
+   ctx->element_state = (struct zink_vertex_elements_state*)cso;
    if (cso) {
       if (state->element_state != &ctx->element_state->hw_state) {
          ctx->vertex_state_changed = !zink_screen(pctx->screen)->info.have_EXT_vertex_input_dynamic_state;
@@ -232,7 +235,7 @@ zink_bind_vertex_elements_state(struct pipe_context *pctx,
 
 static void
 zink_delete_vertex_elements_state(struct pipe_context *pctx,
-                                  void *ves)
+                                  struct pipe_vertex_elements *ves)
 {
    FREE(ves);
 }
@@ -695,15 +698,14 @@ zink_delete_rasterizer_state(struct pipe_context *pctx, void *rs_state)
 struct pipe_vertex_state *
 zink_create_vertex_state(struct pipe_screen *pscreen,
                           struct pipe_vertex_buffer *buffer,
-                          const struct pipe_vertex_element *elements,
-                          unsigned num_elements,
+                          const struct pipe_vertex_elements *elements,
                           struct pipe_resource *indexbuf,
                           uint32_t full_velem_mask)
 {
    struct zink_vertex_state *zstate = CALLOC_STRUCT(zink_vertex_state);
    _mesa_set_init(&zstate->masks, NULL, NULL, _mesa_key_pointer_equal);
 
-   util_init_pipe_vertex_state(pscreen, buffer, elements, num_elements, indexbuf, full_velem_mask,
+   util_init_pipe_vertex_state(pscreen, buffer, elements, indexbuf, full_velem_mask,
                                &zstate->b);
 
    /* Initialize the vertex element state in state->element.
@@ -711,13 +713,14 @@ zink_create_vertex_state(struct pipe_screen *pscreen,
     */
    struct zink_context ctx;
    ctx.base.screen = pscreen;
-   struct zink_vertex_elements_state *elems = zink_create_vertex_elements_state(&ctx.base, num_elements, elements);
+   struct zink_vertex_elements_state *elems =
+      (struct zink_vertex_elements_state*)zink_create_vertex_elements_state(&ctx.base, elements);
    for (unsigned i = 0; i < elems->hw_state.num_bindings; i++) {
       if (zink_screen(pscreen)->info.have_EXT_vertex_input_dynamic_state)
          elems->hw_state.dynbindings[i].stride = buffer->stride;
    }
    zstate->velems = *elems;
-   zink_delete_vertex_elements_state(&ctx.base, elems);
+   zink_delete_vertex_elements_state(&ctx.base, &elems->base);
 
    return &zstate->b;
 }
@@ -765,14 +768,13 @@ zink_vertex_state_mask(struct pipe_vertex_state *vstate, uint32_t partial_velem_
 struct pipe_vertex_state *
 zink_cache_create_vertex_state(struct pipe_screen *pscreen,
                                struct pipe_vertex_buffer *buffer,
-                               const struct pipe_vertex_element *elements,
-                               unsigned num_elements,
+                               const struct pipe_vertex_elements *elements,
                                struct pipe_resource *indexbuf,
                                uint32_t full_velem_mask)
 {
    struct zink_screen *screen = zink_screen(pscreen);
 
-   return util_vertex_state_cache_get(pscreen, buffer, elements, num_elements, indexbuf,
+   return util_vertex_state_cache_get(pscreen, buffer, elements, indexbuf,
                                       full_velem_mask, &screen->vertex_state_cache);
 }
 
diff --git a/src/gallium/drivers/zink/zink_state.h b/src/gallium/drivers/zink/zink_state.h
index 53a149635a0a..a852e0428e41 100644
--- a/src/gallium/drivers/zink/zink_state.h
+++ b/src/gallium/drivers/zink/zink_state.h
@@ -37,8 +37,7 @@ zink_context_state_init(struct pipe_context *pctx);
 struct pipe_vertex_state *
 zink_create_vertex_state(struct pipe_screen *pscreen,
                           struct pipe_vertex_buffer *buffer,
-                          const struct pipe_vertex_element *elements,
-                          unsigned num_elements,
+                          const struct pipe_vertex_elements *elements,
                           struct pipe_resource *indexbuf,
                           uint32_t full_velem_mask);
 void
@@ -46,8 +45,7 @@ zink_vertex_state_destroy(struct pipe_screen *pscreen, struct pipe_vertex_state
 struct pipe_vertex_state *
 zink_cache_create_vertex_state(struct pipe_screen *pscreen,
                                struct pipe_vertex_buffer *buffer,
-                               const struct pipe_vertex_element *elements,
-                               unsigned num_elements,
+                               const struct pipe_vertex_elements *elements,
                                struct pipe_resource *indexbuf,
                                uint32_t full_velem_mask);
 void
diff --git a/src/gallium/drivers/zink/zink_types.h b/src/gallium/drivers/zink/zink_types.h
index 27010f3413b5..da04bc180e34 100644
--- a/src/gallium/drivers/zink/zink_types.h
+++ b/src/gallium/drivers/zink/zink_types.h
@@ -214,6 +214,7 @@ struct zink_vertex_elements_hw_state {
 };
 
 struct zink_vertex_elements_state {
+   struct pipe_vertex_elements base; /* don't change, it's used by memcmp for CSO lookups */
    struct {
       uint32_t binding;
       VkVertexInputRate inputRate;
diff --git a/src/gallium/frontends/d3d10umd/InputAssembly.cpp b/src/gallium/frontends/d3d10umd/InputAssembly.cpp
index ecbb90605a0e..fa658d356e5b 100644
--- a/src/gallium/frontends/d3d10umd/InputAssembly.cpp
+++ b/src/gallium/frontends/d3d10umd/InputAssembly.cpp
@@ -275,7 +275,7 @@ CreateElementLayout(
    struct pipe_context *pipe = CastPipeContext(hDevice);
    ElementLayout *pElementLayout = CastElementLayout(hElementLayout);
 
-   struct pipe_vertex_element elements[PIPE_MAX_ATTRIBS];
+   struct pipe_vertex_elements elements;
    memset(elements, 0, sizeof elements);
 
    unsigned num_elements = pCreateElementLayout->NumElements;
@@ -284,7 +284,7 @@ CreateElementLayout(
       const D3D10DDIARG_INPUT_ELEMENT_DESC* pVertexElement =
             &pCreateElementLayout->pVertexElements[i];
       struct pipe_vertex_element *ve =
-            &elements[pVertexElement->InputRegister];
+            &elements.input[pVertexElement->InputRegister];
 
       ve->src_offset          = pVertexElement->AlignedByteOffset;
       ve->vertex_buffer_index = pVertexElement->InputSlot;
@@ -315,8 +315,10 @@ CreateElementLayout(
       DebugPrintf("%s: gap\n", __FUNCTION__);
    }
 
+   elements.count = max_elements;
+
    pElementLayout->handle =
-         pipe->create_vertex_elements_state(pipe, max_elements, elements);
+         pipe->create_vertex_elements_state(pipe, &elements);
 }
 
 
diff --git a/src/gallium/frontends/d3d10umd/State.h b/src/gallium/frontends/d3d10umd/State.h
index 3e45cb797435..1395706b21e7 100644
--- a/src/gallium/frontends/d3d10umd/State.h
+++ b/src/gallium/frontends/d3d10umd/State.h
@@ -322,7 +322,7 @@ CastPipeShader(D3D10DDI_HSHADER hShader)
 
 struct ElementLayout
 {
-   void *handle;
+   struct pipe_vertex_elements *handle;
 };
 
 
diff --git a/src/gallium/frontends/lavapipe/lvp_execute.c b/src/gallium/frontends/lavapipe/lvp_execute.c
index 6d024389107d..ce661fada5c8 100644
--- a/src/gallium/frontends/lavapipe/lvp_execute.c
+++ b/src/gallium/frontends/lavapipe/lvp_execute.c
@@ -128,7 +128,7 @@ struct rendering_state {
    int num_vb;
    unsigned start_vb;
    struct pipe_vertex_buffer vb[PIPE_MAX_ATTRIBS];
-   struct cso_velems_state velem;
+   struct pipe_vertex_elements velem;
 
    struct lvp_access_info access[MESA_SHADER_STAGES];
    struct pipe_sampler_view *sv[PIPE_SHADER_TYPES][PIPE_MAX_SHADER_SAMPLER_VIEWS];
@@ -153,7 +153,7 @@ struct rendering_state {
    uint32_t pad:13;
 
    void *ss_cso[PIPE_SHADER_TYPES][PIPE_MAX_SAMPLERS];
-   void *velems_cso;
+   struct pipe_vertex_elements *velems_cso;
 
    uint8_t push_constants[128 * 4];
    uint16_t push_size[2]; //gfx, compute
@@ -897,19 +897,19 @@ static void handle_graphics_pipeline(struct vk_cmd_queue_entry *cmd,
    if (!BITSET_TEST(ps->dynamic, MESA_VK_DYNAMIC_VI)) {
       u_foreach_bit(a, ps->vi->attributes_valid) {
          uint32_t b = ps->vi->attributes[a].binding;
-         state->velem.velems[a].src_offset = ps->vi->attributes[a].offset;
-         state->velem.velems[a].vertex_buffer_index = b;
-         state->velem.velems[a].src_format =
+         state->velem.input[a].src_offset = ps->vi->attributes[a].offset;
+         state->velem.input[a].vertex_buffer_index = b;
+         state->velem.input[a].src_format =
             lvp_vk_format_to_pipe_format(ps->vi->attributes[a].format);
-         state->velem.velems[a].dual_slot = false;
+         state->velem.input[a].dual_slot = false;
 
          uint32_t d = ps->vi->bindings[b].divisor;
          switch (ps->vi->bindings[b].input_rate) {
          case VK_VERTEX_INPUT_RATE_VERTEX:
-            state->velem.velems[a].instance_divisor = 0;
+            state->velem.input[a].instance_divisor = 0;
             break;
          case VK_VERTEX_INPUT_RATE_INSTANCE:
-            state->velem.velems[a].instance_divisor = d ? d : UINT32_MAX;
+            state->velem.input[a].instance_divisor = d ? d : UINT32_MAX;
             break;
          default:
             unreachable("Invalid vertex input rate");
@@ -3636,17 +3636,17 @@ static void handle_set_vertex_input(struct vk_cmd_queue_entry *cmd,
          }
       }
       assert(binding);
-      state->velem.velems[location].src_offset = attrs[i].offset;
-      state->velem.velems[location].vertex_buffer_index = attrs[i].binding;
-      state->velem.velems[location].src_format = lvp_vk_format_to_pipe_format(attrs[i].format);
+      state->velem.input[location].src_offset = attrs[i].offset;
+      state->velem.input[location].vertex_buffer_index = attrs[i].binding;
+      state->velem.input[location].src_format = lvp_vk_format_to_pipe_format(attrs[i].format);
       state->vb[attrs[i].binding].stride = binding->stride;
       uint32_t d = binding->divisor;
       switch (binding->inputRate) {
       case VK_VERTEX_INPUT_RATE_VERTEX:
-         state->velem.velems[location].instance_divisor = 0;
+         state->velem.input[location].instance_divisor = 0;
          break;
       case VK_VERTEX_INPUT_RATE_INSTANCE:
-         state->velem.velems[location].instance_divisor = d ? d : UINT32_MAX;
+         state->velem.input[location].instance_divisor = d ? d : UINT32_MAX;
          break;
       default:
          assert(0);
diff --git a/src/gallium/frontends/nine/nine_state.c b/src/gallium/frontends/nine/nine_state.c
index 3725ebf62594..462f2e010920 100644
--- a/src/gallium/frontends/nine/nine_state.c
+++ b/src/gallium/frontends/nine/nine_state.c
@@ -843,7 +843,7 @@ update_vertex_elements(struct NineDevice9 *device)
     uint16_t used_streams = 0;
     int dummy_vbo_stream = -1;
     BOOL need_dummy_vbo = FALSE;
-    struct cso_velems_state ve;
+    struct pipe_vertex_elements ve;
 
     context->stream_usage_mask = 0;
     memset(vdecl_index_map, -1, 16);
@@ -883,22 +883,22 @@ update_vertex_elements(struct NineDevice9 *device)
     for (n = 0; n < vs->num_inputs; ++n) {
         index = vdecl_index_map[n];
         if (index >= 0) {
-            ve.velems[n] = vdecl->elems[index];
-            b = ve.velems[n].vertex_buffer_index;
+            ve.input[n] = vdecl->elems[index];
+            b = ve.input[n].vertex_buffer_index;
             context->stream_usage_mask |= 1 << b;
             /* XXX wine just uses 1 here: */
             if (context->stream_freq[b] & D3DSTREAMSOURCE_INSTANCEDATA)
-                ve.velems[n].instance_divisor = context->stream_freq[b] & 0x7FFFFF;
+                ve.input[n].instance_divisor = context->stream_freq[b] & 0x7FFFFF;
         } else {
             /* if the vertex declaration is incomplete compared to what the
              * vertex shader needs, we bind a dummy vbo with 0 0 0 0.
              * This is not precised by the spec, but is the behaviour
              * tested on win */
-            ve.velems[n].vertex_buffer_index = dummy_vbo_stream;
-            ve.velems[n].src_format = PIPE_FORMAT_R32G32B32A32_FLOAT;
-            ve.velems[n].src_offset = 0;
-            ve.velems[n].instance_divisor = 0;
-            ve.velems[n].dual_slot = false;
+            ve.input[n].vertex_buffer_index = dummy_vbo_stream;
+            ve.input[n].src_format = PIPE_FORMAT_R32G32B32A32_FLOAT;
+            ve.input[n].src_offset = 0;
+            ve.input[n].instance_divisor = 0;
+            ve.input[n].dual_slot = false;
         }
     }
 
@@ -3051,7 +3051,7 @@ update_vertex_elements_sw(struct NineDevice9 *device)
     int8_t used_streams[device->caps.MaxStreams];
     int dummy_vbo_stream = -1;
     BOOL need_dummy_vbo = FALSE;
-    struct cso_velems_state ve;
+    struct pipe_vertex_elements ve;
     bool programmable_vs = state->vs && !(state->vdecl && state->vdecl->position_t);
 
     memset(vdecl_index_map, -1, 16);
@@ -3093,21 +3093,21 @@ update_vertex_elements_sw(struct NineDevice9 *device)
     for (n = 0; n < vs->num_inputs; ++n) {
         index = vdecl_index_map[n];
         if (index >= 0) {
-            ve.velems[n] = vdecl->elems[index];
-            b = ve.velems[n].vertex_buffer_index;
+            ve.input[n] = vdecl->elems[index];
+            b = ve.input[n].vertex_buffer_index;
             /* XXX wine just uses 1 here: */
             if (state->stream_freq[b] & D3DSTREAMSOURCE_INSTANCEDATA)
-                ve.velems[n].instance_divisor = state->stream_freq[b] & 0x7FFFFF;
+                ve.input[n].instance_divisor = state->stream_freq[b] & 0x7FFFFF;
         } else {
             /* if the vertex declaration is incomplete compared to what the
              * vertex shader needs, we bind a dummy vbo with 0 0 0 0.
              * This is not precised by the spec, but is the behaviour
              * tested on win */
-            ve.velems[n].vertex_buffer_index = dummy_vbo_stream;
-            ve.velems[n].src_format = PIPE_FORMAT_R32G32B32A32_FLOAT;
-            ve.velems[n].src_offset = 0;
-            ve.velems[n].instance_divisor = 0;
-            ve.velems[n].dual_slot = false;
+            ve.input[n].vertex_buffer_index = dummy_vbo_stream;
+            ve.input[n].src_format = PIPE_FORMAT_R32G32B32A32_FLOAT;
+            ve.input[n].src_offset = 0;
+            ve.input[n].instance_divisor = 0;
+            ve.input[n].dual_slot = false;
         }
     }
 
diff --git a/src/gallium/frontends/xa/xa_renderer.c b/src/gallium/frontends/xa/xa_renderer.c
index 10b3f6a1f217..9be42dbb5b00 100644
--- a/src/gallium/frontends/xa/xa_renderer.c
+++ b/src/gallium/frontends/xa/xa_renderer.c
@@ -88,9 +88,9 @@ renderer_draw(struct xa_context *r)
 
     r->pipe->set_scissor_states(r->pipe, 0, 1, &r->scissor);
 
-    struct cso_velems_state velems;
+    struct pipe_vertex_elements velems;
     velems.count = r->attrs_per_vertex;
-    memcpy(velems.velems, r->velems, sizeof(r->velems[0]) * velems.count);
+    memcpy(velems.input, r->velems, sizeof(r->velems[0]) * velems.count);
 
     cso_set_vertex_elements(r->cso, &velems);
     util_draw_user_vertex_buffer(r->cso, r->buffer, PIPE_PRIM_QUADS,
@@ -525,9 +525,9 @@ renderer_draw_yuv(struct xa_context *r,
 
    r->pipe->set_scissor_states(r->pipe, 0, 1, &r->scissor);
 
-   struct cso_velems_state velems;
+   struct pipe_vertex_elements velems;
    velems.count = num_attribs;
-   memcpy(velems.velems, r->velems, sizeof(r->velems[0]) * velems.count);
+   memcpy(velems.input, r->velems, sizeof(r->velems[0]) * velems.count);
 
    cso_set_vertex_elements(r->cso, &velems);
    util_draw_user_vertex_buffer(r->cso, r->buffer, PIPE_PRIM_QUADS,
diff --git a/src/gallium/include/pipe/p_context.h b/src/gallium/include/pipe/p_context.h
index 75e30da09f91..345f808b2985 100644
--- a/src/gallium/include/pipe/p_context.h
+++ b/src/gallium/include/pipe/p_context.h
@@ -70,7 +70,7 @@ struct pipe_stream_output_target;
 struct pipe_surface;
 struct pipe_transfer;
 struct pipe_vertex_buffer;
-struct pipe_vertex_element;
+struct pipe_vertex_elements;
 struct pipe_vertex_state;
 struct pipe_video_buffer;
 struct pipe_video_codec;
@@ -391,11 +391,13 @@ struct pipe_context {
    void   (*bind_tes_state)(struct pipe_context *, void *);
    void   (*delete_tes_state)(struct pipe_context *, void *);
 
-   void * (*create_vertex_elements_state)(struct pipe_context *,
-                                          unsigned num_elements,
-                                          const struct pipe_vertex_element *);
-   void   (*bind_vertex_elements_state)(struct pipe_context *, void *);
-   void   (*delete_vertex_elements_state)(struct pipe_context *, void *);
+   struct pipe_vertex_elements *
+      (*create_vertex_elements_state)(struct pipe_context *,
+                                      const struct pipe_vertex_elements *);
+   void   (*bind_vertex_elements_state)(struct pipe_context *,
+                                        struct pipe_vertex_elements *);
+   void   (*delete_vertex_elements_state)(struct pipe_context *,
+                                          struct pipe_vertex_elements *);
 
    /*@}*/
 
diff --git a/src/gallium/include/pipe/p_screen.h b/src/gallium/include/pipe/p_screen.h
index 8bc1a2de2d81..31bf13c7a214 100644
--- a/src/gallium/include/pipe/p_screen.h
+++ b/src/gallium/include/pipe/p_screen.h
@@ -59,7 +59,7 @@ struct pipe_transfer;
 struct pipe_box;
 struct pipe_memory_info;
 struct pipe_vertex_buffer;
-struct pipe_vertex_element;
+struct pipe_vertex_elements;
 struct pipe_vertex_state;
 struct disk_cache;
 struct driOptionCache;
@@ -69,8 +69,7 @@ struct pipe_screen;
 typedef struct pipe_vertex_state *
    (*pipe_create_vertex_state_func)(struct pipe_screen *screen,
                                     struct pipe_vertex_buffer *buffer,
-                                    const struct pipe_vertex_element *elements,
-                                    unsigned num_elements,
+                                    const struct pipe_vertex_elements *ve,
                                     struct pipe_resource *indexbuf,
                                     uint32_t full_velem_mask);
 typedef void (*pipe_vertex_state_destroy_func)(struct pipe_screen *screen,
diff --git a/src/gallium/include/pipe/p_state.h b/src/gallium/include/pipe/p_state.h
index 22b1dae016ea..b29d9f34c3a4 100644
--- a/src/gallium/include/pipe/p_state.h
+++ b/src/gallium/include/pipe/p_state.h
@@ -722,6 +722,16 @@ struct pipe_vertex_element
    unsigned instance_divisor;
 };
 
+/**
+ * Vertex elements describe where vertex shader inputs come from and their
+ * format and memory layout.
+ */
+struct pipe_vertex_elements
+{
+   unsigned count;
+   struct pipe_vertex_element input[PIPE_MAX_ATTRIBS];
+};
+
 /**
  * Opaque refcounted constant state object encapsulating a vertex buffer,
  * index buffer, and vertex elements. Used by display lists to bind those
@@ -750,8 +760,7 @@ struct pipe_vertex_state {
    struct {
       struct pipe_resource *indexbuf;
       struct pipe_vertex_buffer vbuffer;
-      unsigned num_elements;
-      struct pipe_vertex_element elements[PIPE_MAX_ATTRIBS];
+      struct pipe_vertex_elements ve;
       uint32_t full_velem_mask;
    } input;
 };
diff --git a/src/gallium/tests/graw/fs-fragcoord.c b/src/gallium/tests/graw/fs-fragcoord.c
index 8be8c6ffe384..d93ba5ea1abc 100644
--- a/src/gallium/tests/graw/fs-fragcoord.c
+++ b/src/gallium/tests/graw/fs-fragcoord.c
@@ -15,11 +15,6 @@ static int height = 300;
 
 static struct graw_info info;
 
-struct vertex {
-   float position[4];
-   float color[4];
-};
-
 /* Note: the upper-left vertex is pushed to the left a bit to
  * make sure we can spot upside-down rendering.
  */
@@ -49,37 +44,6 @@ static struct vertex vertices[] =
 #define NUM_VERTS ARRAY_SIZE(vertices)
 
 
-static void
-set_vertices(void)
-{
-   struct pipe_vertex_element ve[2];
-   struct pipe_vertex_buffer vbuf;
-   void *handle;
-
-   memset(ve, 0, sizeof ve);
-
-   ve[0].src_offset = Offset(struct vertex, position);
-   ve[0].src_format = PIPE_FORMAT_R32G32B32A32_FLOAT;
-   ve[1].src_offset = Offset(struct vertex, color);
-   ve[1].src_format = PIPE_FORMAT_R32G32B32A32_FLOAT;
-
-   handle = info.ctx->create_vertex_elements_state(info.ctx, 2, ve);
-   info.ctx->bind_vertex_elements_state(info.ctx, handle);
-
-   memset(&vbuf, 0, sizeof vbuf);
-
-   vbuf.stride = sizeof(struct vertex);
-   vbuf.buffer_offset = 0;
-   vbuf.buffer.resource = pipe_buffer_create_with_data(info.ctx,
-                                              PIPE_BIND_VERTEX_BUFFER,
-                                              PIPE_USAGE_DEFAULT,
-                                              sizeof(vertices),
-                                              vertices);
-
-   info.ctx->set_vertex_buffers(info.ctx, 0, 1, 0, false, &vbuf);
-}
-
-
 static void
 set_vertex_shader(void)
 {
@@ -228,7 +192,7 @@ init(int mode)
 
    graw_util_viewport(&info, 0, 0, width, height, -1.0, 1.0);
 
-   set_vertices();
+   graw_set_vertices(info.ctx, vertices, sizeof(vertices));
    set_vertex_shader();
    set_fragment_shader(mode);
 }
diff --git a/src/gallium/tests/graw/fs-frontface.c b/src/gallium/tests/graw/fs-frontface.c
index d74014461161..900e24ae83ba 100644
--- a/src/gallium/tests/graw/fs-frontface.c
+++ b/src/gallium/tests/graw/fs-frontface.c
@@ -13,11 +13,6 @@ static int height = 300;
 
 static struct graw_info info;
 
-struct vertex {
-   float position[4];
-   float color[4];
-};
-
 #define z0 0.2
 #define z01 0.5
 #define z1 0.4
@@ -70,38 +65,6 @@ static struct vertex vertices[] =
 #define NUM_VERTS ARRAY_SIZE(vertices)
 
 
-
-static void
-set_vertices(void)
-{
-   struct pipe_vertex_element ve[2];
-   struct pipe_vertex_buffer vbuf;
-   void *handle;
-
-   memset(ve, 0, sizeof ve);
-
-   ve[0].src_offset = Offset(struct vertex, position);
-   ve[0].src_format = PIPE_FORMAT_R32G32B32A32_FLOAT;
-   ve[1].src_offset = Offset(struct vertex, color);
-   ve[1].src_format = PIPE_FORMAT_R32G32B32A32_FLOAT;
-
-   handle = info.ctx->create_vertex_elements_state(info.ctx, 2, ve);
-   info.ctx->bind_vertex_elements_state(info.ctx, handle);
-
-   memset(&vbuf, 0, sizeof vbuf);
-
-   vbuf.stride = sizeof(struct vertex);
-   vbuf.buffer_offset = 0;
-   vbuf.buffer.resource = pipe_buffer_create_with_data(info.ctx,
-                                              PIPE_BIND_VERTEX_BUFFER,
-                                              PIPE_USAGE_DEFAULT,
-                                              sizeof(vertices),
-                                              vertices);
-
-   info.ctx->set_vertex_buffers(info.ctx, 0, 1, 0, false, &vbuf);
-}
-
-
 static void
 set_vertex_shader(void)
 {
@@ -190,7 +153,7 @@ init(void)
 
    graw_util_viewport(&info, 0, 0, width, height, -1.0, 1.0);
 
-   set_vertices();
+   graw_set_vertices(info.ctx, vertices, sizeof(vertices));
    set_vertex_shader();
    set_fragment_shader();
 }
diff --git a/src/gallium/tests/graw/fs-test.c b/src/gallium/tests/graw/fs-test.c
index b4ddfb6099d3..0b6670488651 100644
--- a/src/gallium/tests/graw/fs-test.c
+++ b/src/gallium/tests/graw/fs-test.c
@@ -158,20 +158,21 @@ static void set_viewport( float x, float y,
 
 static void set_vertices( void )
 {
-   struct pipe_vertex_element ve[3];
+   struct pipe_vertex_elements ve;
    struct pipe_vertex_buffer vbuf;
-   void *handle;
+   struct pipe_vertex_elements *handle;
 
-   memset(ve, 0, sizeof ve);
+   memset(&ve, 0, sizeof ve);
 
-   ve[0].src_offset = Offset(struct vertex, position);
-   ve[0].src_format = PIPE_FORMAT_R32G32B32A32_FLOAT;
-   ve[1].src_offset = Offset(struct vertex, color);
-   ve[1].src_format = PIPE_FORMAT_R32G32B32A32_FLOAT;
-   ve[2].src_offset = Offset(struct vertex, texcoord);
-   ve[2].src_format = PIPE_FORMAT_R32G32B32A32_FLOAT;
+   ve.count = 3;
+   ve.input[0].src_offset = Offset(struct vertex, position);
+   ve.input[0].src_format = PIPE_FORMAT_R32G32B32A32_FLOAT;
+   ve.input[1].src_offset = Offset(struct vertex, color);
+   ve.input[1].src_format = PIPE_FORMAT_R32G32B32A32_FLOAT;
+   ve.input[2].src_offset = Offset(struct vertex, texcoord);
+   ve.input[2].src_format = PIPE_FORMAT_R32G32B32A32_FLOAT;
 
-   handle = ctx->create_vertex_elements_state(ctx, 3, ve);
+   handle = ctx->create_vertex_elements_state(ctx, &ve);
    ctx->bind_vertex_elements_state(ctx, handle);
 
    memset(&vbuf, 0, sizeof vbuf);
diff --git a/src/gallium/tests/graw/fs-write-z.c b/src/gallium/tests/graw/fs-write-z.c
index ac255b6b61c9..53a9fe759e54 100644
--- a/src/gallium/tests/graw/fs-write-z.c
+++ b/src/gallium/tests/graw/fs-write-z.c
@@ -16,11 +16,6 @@ static int height = 300;
 static struct graw_info info;
 
 
-struct vertex {
-   float position[4];
-   float color[4];
-};
-
 #define z0 0.2
 #define z01 0.5
 #define z1 0.4
@@ -73,39 +68,6 @@ static struct vertex vertices[] =
 
 #define NUM_VERTS ARRAY_SIZE(vertices)
 
-
-
-static void
-set_vertices(void)
-{
-   struct pipe_vertex_element ve[2];
-   struct pipe_vertex_buffer vbuf;
-   void *handle;
-
-   memset(ve, 0, sizeof ve);
-
-   ve[0].src_offset = Offset(struct vertex, position);
-   ve[0].src_format = PIPE_FORMAT_R32G32B32A32_FLOAT;
-   ve[1].src_offset = Offset(struct vertex, color);
-   ve[1].src_format = PIPE_FORMAT_R32G32B32A32_FLOAT;
-
-   handle = info.ctx->create_vertex_elements_state(info.ctx, 2, ve);
-   info.ctx->bind_vertex_elements_state(info.ctx, handle);
-
-   memset(&vbuf, 0, sizeof vbuf);
-
-   vbuf.stride = sizeof(struct vertex);
-   vbuf.buffer_offset = 0;
-   vbuf.buffer.resource = pipe_buffer_create_with_data(info.ctx,
-                                              PIPE_BIND_VERTEX_BUFFER,
-                                              PIPE_USAGE_DEFAULT,
-                                              sizeof(vertices),
-                                              vertices);
-
-   info.ctx->set_vertex_buffers(info.ctx, 0, 1, 0, false, &vbuf);
-}
-
-
 static void
 set_vertex_shader(void)
 {
@@ -207,7 +169,7 @@ init(void)
 
    graw_util_viewport(&info, 0, 0, width, height, -1.0, 1.0);
 
-   set_vertices();
+   graw_set_vertices(info.ctx, vertices, sizeof(vertices));
    set_vertex_shader();
    set_fragment_shader();
 }
diff --git a/src/gallium/tests/graw/graw_util.h b/src/gallium/tests/graw/graw_util.h
index 3ea2c482d176..87b63d7f8a96 100644
--- a/src/gallium/tests/graw/graw_util.h
+++ b/src/gallium/tests/graw/graw_util.h
@@ -327,3 +327,37 @@ graw_util_create_simple_sampler_view(const struct graw_info *info,
    return sv;
 }
 
+struct vertex {
+   float position[4];
+   float color[4];
+};
+
+static inline void
+graw_set_vertices(struct pipe_context *ctx, void *vertices, unsigned size)
+{
+   struct pipe_vertex_elements ve;
+   struct pipe_vertex_buffer vbuf;
+   struct pipe_vertex_elements *handle;
+
+   memset(&ve, 0, sizeof ve);
+
+   ve.count = 2;
+   ve.input[0].src_offset = Offset(struct vertex, position);
+   ve.input[0].src_format = PIPE_FORMAT_R32G32B32A32_FLOAT;
+   ve.input[1].src_offset = Offset(struct vertex, color);
+   ve.input[1].src_format = PIPE_FORMAT_R32G32B32A32_FLOAT;
+
+   handle = ctx->create_vertex_elements_state(ctx, &ve);
+   ctx->bind_vertex_elements_state(ctx, handle);
+
+   memset(&vbuf, 0, sizeof vbuf);
+
+   vbuf.stride = sizeof(struct vertex);
+   vbuf.buffer_offset = 0;
+   vbuf.buffer.resource = pipe_buffer_create_with_data(ctx,
+                                              PIPE_BIND_VERTEX_BUFFER,
+                                              PIPE_USAGE_DEFAULT,
+                                              size, vertices);
+
+   ctx->set_vertex_buffers(ctx, 0, 1, 0, false, &vbuf);
+}
diff --git a/src/gallium/tests/graw/gs-test.c b/src/gallium/tests/graw/gs-test.c
index cd6bdec98c86..0e5c5b6ec41f 100644
--- a/src/gallium/tests/graw/gs-test.c
+++ b/src/gallium/tests/graw/gs-test.c
@@ -216,22 +216,23 @@ static void set_viewport( float x, float y,
 
 static void set_vertices( void )
 {
-   struct pipe_vertex_element ve[4];
+   struct pipe_vertex_elements ve;
    struct pipe_vertex_buffer vbuf;
-   void *handle;
+   struct pipe_vertex_elements *handle;
 
-   memset(ve, 0, sizeof ve);
+   memset(&ve, 0, sizeof ve);
 
-   ve[0].src_offset = Offset(struct vertex, position);
-   ve[0].src_format = PIPE_FORMAT_R32G32B32A32_FLOAT;
-   ve[1].src_offset = Offset(struct vertex, color);
-   ve[1].src_format = PIPE_FORMAT_R32G32B32A32_FLOAT;
-   ve[2].src_offset = Offset(struct vertex, texcoord);
-   ve[2].src_format = PIPE_FORMAT_R32G32B32A32_FLOAT;
-   ve[3].src_offset = Offset(struct vertex, generic);
-   ve[3].src_format = PIPE_FORMAT_R32G32B32A32_FLOAT;
+   ve.count = 4;
+   ve.input[0].src_offset = Offset(struct vertex, position);
+   ve.input[0].src_format = PIPE_FORMAT_R32G32B32A32_FLOAT;
+   ve.input[1].src_offset = Offset(struct vertex, color);
+   ve.input[1].src_format = PIPE_FORMAT_R32G32B32A32_FLOAT;
+   ve.input[2].src_offset = Offset(struct vertex, texcoord);
+   ve.input[2].src_format = PIPE_FORMAT_R32G32B32A32_FLOAT;
+   ve.input[3].src_offset = Offset(struct vertex, generic);
+   ve.input[3].src_format = PIPE_FORMAT_R32G32B32A32_FLOAT;
 
-   handle = ctx->create_vertex_elements_state(ctx, 4, ve);
+   handle = ctx->create_vertex_elements_state(ctx, &ve);
    ctx->bind_vertex_elements_state(ctx, handle);
 
    memset(&vbuf, 0, sizeof vbuf);
diff --git a/src/gallium/tests/graw/occlusion-query.c b/src/gallium/tests/graw/occlusion-query.c
index 9805ef92227a..41e0b992c6dc 100644
--- a/src/gallium/tests/graw/occlusion-query.c
+++ b/src/gallium/tests/graw/occlusion-query.c
@@ -17,11 +17,6 @@ static int expected2 = 420;
 
 static struct graw_info info;
 
-struct vertex {
-   float position[4];
-   float color[4];
-};
-
 #define z0 0.2
 #define z1 0.6
 
@@ -74,37 +69,6 @@ static struct vertex obj2_vertices[4] =
 #define NUM_VERTS 4
 
 
-
-static void
-set_vertices(struct vertex *vertices, unsigned bytes)
-{
-   struct pipe_vertex_element ve[2];
-   struct pipe_vertex_buffer vbuf;
-   void *handle;
-
-   memset(ve, 0, sizeof ve);
-
-   ve[0].src_offset = Offset(struct vertex, position);
-   ve[0].src_format = PIPE_FORMAT_R32G32B32A32_FLOAT;
-   ve[1].src_offset = Offset(struct vertex, color);
-   ve[1].src_format = PIPE_FORMAT_R32G32B32A32_FLOAT;
-
-   handle = info.ctx->create_vertex_elements_state(info.ctx, 2, ve);
-   info.ctx->bind_vertex_elements_state(info.ctx, handle);
-
-
-   vbuf.stride = sizeof(struct vertex);
-   vbuf.buffer_offset = 0;
-   vbuf.buffer.resource = pipe_buffer_create_with_data(info.ctx,
-                                              PIPE_BIND_VERTEX_BUFFER,
-                                              PIPE_USAGE_DEFAULT,
-                                              bytes,
-                                              vertices);
-
-   info.ctx->set_vertex_buffers(info.ctx, 0, 1, 0, false, &vbuf);
-}
-
-
 static void
 set_vertex_shader(struct graw_info *info)
 {
@@ -175,13 +139,13 @@ draw(void)
    q2 = info.ctx->create_query(info.ctx, PIPE_QUERY_OCCLUSION_COUNTER, 0);
 
    /* draw first, large object */
-   set_vertices(obj1_vertices, sizeof(obj1_vertices));
+   graw_set_vertices(info.ctx, obj1_vertices, sizeof(obj1_vertices));
    info.ctx->begin_query(info.ctx, q1);
    util_draw_arrays(info.ctx, PIPE_PRIM_QUADS, 0, NUM_VERTS);
    info.ctx->end_query(info.ctx, q1);
 
    /* draw second, small object behind first object */
-   set_vertices(obj2_vertices, sizeof(obj2_vertices));
+   graw_set_vertices(info.ctx, obj2_vertices, sizeof(obj2_vertices));
    info.ctx->begin_query(info.ctx, q2);
    util_draw_arrays(info.ctx, PIPE_PRIM_QUADS, 0, NUM_VERTS);
    info.ctx->end_query(info.ctx, q2);
diff --git a/src/gallium/tests/graw/quad-sample.c b/src/gallium/tests/graw/quad-sample.c
index 43667463597d..1dee37170441 100644
--- a/src/gallium/tests/graw/quad-sample.c
+++ b/src/gallium/tests/graw/quad-sample.c
@@ -14,6 +14,7 @@
 #include "util/u_memory.h"      /* Offset() */
 #include "util/u_draw_quad.h"
 #include "util/u_box.h"    
+#include "graw_util.h"
 
 #include <stdio.h>
 
@@ -35,11 +36,6 @@ static struct pipe_sampler_view *sv = NULL;
 static void *sampler = NULL;
 static void *window = NULL;
 
-struct vertex {
-   float position[4];
-   float color[4];
-};
-
 static struct vertex vertices[] =
 {
    { { 0.9, -0.9, 0.0, 1.0 },
@@ -84,35 +80,6 @@ static void set_viewport( float x, float y,
    ctx->set_viewport_states( ctx, 0, 1, &vp );
 }
 
-static void set_vertices( void )
-{
-   struct pipe_vertex_element ve[2];
-   struct pipe_vertex_buffer vbuf;
-   void *handle;
-
-   memset(ve, 0, sizeof ve);
-
-   ve[0].src_offset = Offset(struct vertex, position);
-   ve[0].src_format = PIPE_FORMAT_R32G32B32A32_FLOAT;
-   ve[1].src_offset = Offset(struct vertex, color);
-   ve[1].src_format = PIPE_FORMAT_R32G32B32A32_FLOAT;
-
-   handle = ctx->create_vertex_elements_state(ctx, 2, ve);
-   ctx->bind_vertex_elements_state(ctx, handle);
-
-   memset(&vbuf, 0, sizeof vbuf);
-
-   vbuf.stride = sizeof( struct vertex );
-   vbuf.buffer_offset = 0;
-   vbuf.buffer.resource = pipe_buffer_create_with_data(ctx,
-                                              PIPE_BIND_VERTEX_BUFFER,
-                                              PIPE_USAGE_DEFAULT,
-                                              sizeof(vertices),
-                                              vertices);
-
-   ctx->set_vertex_buffers(ctx, 0, 1, 0, false, &vbuf);
-}
-
 static void set_vertex_shader( void )
 {
    void *handle;
@@ -388,7 +355,7 @@ static void init( void )
 
    init_tex();
 
-   set_vertices();
+   graw_set_vertices(ctx, vertices, sizeof(vertices));
    set_vertex_shader();
    set_fragment_shader();
 }
diff --git a/src/gallium/tests/graw/quad-tex.c b/src/gallium/tests/graw/quad-tex.c
index 3c78b3550616..a2e2e5ff909d 100644
--- a/src/gallium/tests/graw/quad-tex.c
+++ b/src/gallium/tests/graw/quad-tex.c
@@ -14,11 +14,6 @@ static struct pipe_resource *texture = NULL;
 static struct pipe_sampler_view *sv = NULL;
 static void *sampler = NULL;
 
-struct vertex {
-   float position[4];
-   float color[4];
-};
-
 static struct vertex vertices[] =
 {
    { { 0.9, -0.9, 0.0, 1.0 },
@@ -39,18 +34,19 @@ static struct vertex vertices[] =
 
 static void set_vertices( void )
 {
-   struct pipe_vertex_element ve[2];
+   struct pipe_vertex_elements ve;
    struct pipe_vertex_buffer vbuf;
-   void *handle;
+   struct pipe_vertex_elements *handle;
 
-   memset(ve, 0, sizeof ve);
+   memset(&ve, 0, sizeof ve);
 
-   ve[0].src_offset = Offset(struct vertex, position);
-   ve[0].src_format = PIPE_FORMAT_R32G32B32A32_FLOAT;
-   ve[1].src_offset = Offset(struct vertex, color);
-   ve[1].src_format = PIPE_FORMAT_R32G32B32A32_FLOAT;
+   ve.count = 2;
+   ve.input[0].src_offset = Offset(struct vertex, position);
+   ve.input[0].src_format = PIPE_FORMAT_R32G32B32A32_FLOAT;
+   ve.input[1].src_offset = Offset(struct vertex, color);
+   ve.input[1].src_format = PIPE_FORMAT_R32G32B32A32_FLOAT;
 
-   handle = info.ctx->create_vertex_elements_state(info.ctx, 2, ve);
+   handle = info.ctx->create_vertex_elements_state(info.ctx, &ve);
    info.ctx->bind_vertex_elements_state(info.ctx, handle);
 
    memset(&vbuf, 0, sizeof vbuf);
diff --git a/src/gallium/tests/graw/shader-leak.c b/src/gallium/tests/graw/shader-leak.c
index 0e121a7d0d61..a77b608b012a 100644
--- a/src/gallium/tests/graw/shader-leak.c
+++ b/src/gallium/tests/graw/shader-leak.c
@@ -12,6 +12,7 @@
 #include "util/u_memory.h"      /* Offset() */
 #include "util/u_draw_quad.h"
 #include "util/u_inlines.h"
+#include "graw_util.h"
 
 
 static int num_iters = 100;
@@ -32,11 +33,6 @@ static struct pipe_surface *surf = NULL;
 static struct pipe_resource *tex = NULL;
 static void *window = NULL;
 
-struct vertex {
-   float position[4];
-   float color[4];
-};
-
 static struct vertex vertices[1] =
 {
    {
@@ -74,35 +70,6 @@ static void set_viewport( float x, float y,
    ctx->set_viewport_states( ctx, 0, 1, &vp );
 }
 
-static void set_vertices( void )
-{
-   struct pipe_vertex_element ve[2];
-   struct pipe_vertex_buffer vbuf;
-   void *handle;
-
-   memset(ve, 0, sizeof ve);
-
-   ve[0].src_offset = Offset(struct vertex, position);
-   ve[0].src_format = PIPE_FORMAT_R32G32B32A32_FLOAT;
-   ve[1].src_offset = Offset(struct vertex, color);
-   ve[1].src_format = PIPE_FORMAT_R32G32B32A32_FLOAT;
-
-   handle = ctx->create_vertex_elements_state(ctx, 2, ve);
-   ctx->bind_vertex_elements_state(ctx, handle);
-
-   memset(&vbuf, 0, sizeof vbuf);
-
-   vbuf.stride = sizeof(struct vertex);
-   vbuf.buffer_offset = 0;
-   vbuf.buffer.resource = pipe_buffer_create_with_data(ctx,
-                                              PIPE_BIND_VERTEX_BUFFER,
-                                              PIPE_USAGE_DEFAULT,
-                                              sizeof(vertices),
-                                              vertices);
-
-   ctx->set_vertex_buffers(ctx, 0, 1, 0, false, &vbuf);
-}
-
 static void set_vertex_shader( void )
 {
    void *handle;
@@ -262,7 +229,7 @@ static void init( void )
    }
 
    set_viewport(0, 0, WIDTH, HEIGHT, 30, 1000);
-   set_vertices();
+   graw_set_vertices(ctx, vertices, sizeof(vertices));
    set_vertex_shader();
    if (0)
       set_fragment_shader();
diff --git a/src/gallium/tests/graw/tex-srgb.c b/src/gallium/tests/graw/tex-srgb.c
index 0d3e9ba15487..4d52cc193fa6 100644
--- a/src/gallium/tests/graw/tex-srgb.c
+++ b/src/gallium/tests/graw/tex-srgb.c
@@ -13,11 +13,6 @@ static struct pipe_resource *texture;
 static struct pipe_sampler_view *linear_sv, *srgb_sv;
 
 
-struct vertex {
-   float position[4];
-   float color[4];
-};
-
 static struct vertex vertices1[] =
 {
    { { -0.1, -0.9, 0.0, 1.0 },
@@ -50,38 +45,6 @@ static struct vertex vertices2[] =
 };
 
 
-
-
-static void
-set_vertices(struct vertex *verts, unsigned num_verts)
-{
-   struct pipe_vertex_element ve[2];
-   struct pipe_vertex_buffer vbuf;
-   void *handle;
-
-   memset(ve, 0, sizeof ve);
-
-   ve[0].src_offset = Offset(struct vertex, position);
-   ve[0].src_format = PIPE_FORMAT_R32G32B32A32_FLOAT;
-   ve[1].src_offset = Offset(struct vertex, color);
-   ve[1].src_format = PIPE_FORMAT_R32G32B32A32_FLOAT;
-
-   handle = info.ctx->create_vertex_elements_state(info.ctx, 2, ve);
-   info.ctx->bind_vertex_elements_state(info.ctx, handle);
-
-   memset(&vbuf, 0, sizeof vbuf);
-
-   vbuf.stride = sizeof(struct vertex);
-   vbuf.buffer_offset = 0;
-   vbuf.buffer.resource = pipe_buffer_create_with_data(info.ctx,
-                                              PIPE_BIND_VERTEX_BUFFER,
-                                              PIPE_USAGE_DEFAULT,
-                                              num_verts * sizeof(struct vertex),
-                                              verts);
-
-   info.ctx->set_vertex_buffers(info.ctx, 0, 1, 0, false, &vbuf);
-}
-
 static void set_vertex_shader( void )
 {
    void *handle;
@@ -130,11 +93,11 @@ static void draw( void )
    info.ctx->clear(info.ctx, PIPE_CLEAR_COLOR, NULL, &clear_color, 0, 0);
 
    info.ctx->set_sampler_views(info.ctx, PIPE_SHADER_FRAGMENT, 0, 1, 0, false, &linear_sv);
-   set_vertices(vertices1, 4);
+   graw_set_vertices(info.ctx, vertices1, sizeof(vertices1));
    util_draw_arrays(info.ctx, PIPE_PRIM_QUADS, 0, 4);
 
    info.ctx->set_sampler_views(info.ctx, PIPE_SHADER_FRAGMENT, 0, 1, 0, false, &srgb_sv);
-   set_vertices(vertices2, 4);
+   graw_set_vertices(info.ctx, vertices2, sizeof(vertices2));
    util_draw_arrays(info.ctx, PIPE_PRIM_QUADS, 0, 4);
 
    info.ctx->flush(info.ctx, NULL, 0);
diff --git a/src/gallium/tests/graw/tex-swizzle.c b/src/gallium/tests/graw/tex-swizzle.c
index a522a2e01622..81e657a2b463 100644
--- a/src/gallium/tests/graw/tex-swizzle.c
+++ b/src/gallium/tests/graw/tex-swizzle.c
@@ -14,11 +14,6 @@ static void *sampler = NULL;
 static const int WIDTH = 300;
 static const int HEIGHT = 300;
 
-struct vertex {
-   float position[4];
-   float color[4];
-};
-
 static struct vertex vertices[] =
 {
    { { 0.9, -0.9, 0.0, 1.0 },
@@ -34,36 +29,6 @@ static struct vertex vertices[] =
      { 0, 0, 0, 1 } },
 };
 
-
-static void set_vertices(void)
-{
-   struct pipe_vertex_element ve[2];
-   struct pipe_vertex_buffer vbuf;
-   void *handle;
-
-   memset(ve, 0, sizeof ve);
-
-   ve[0].src_offset = Offset(struct vertex, position);
-   ve[0].src_format = PIPE_FORMAT_R32G32B32A32_FLOAT;
-   ve[1].src_offset = Offset(struct vertex, color);
-   ve[1].src_format = PIPE_FORMAT_R32G32B32A32_FLOAT;
-
-   handle = info.ctx->create_vertex_elements_state(info.ctx, 2, ve);
-   info.ctx->bind_vertex_elements_state(info.ctx, handle);
-
-   memset(&vbuf, 0, sizeof vbuf);
-
-   vbuf.stride = sizeof(struct vertex);
-   vbuf.buffer_offset = 0;
-   vbuf.buffer.resource = pipe_buffer_create_with_data(info.ctx,
-                                              PIPE_BIND_VERTEX_BUFFER,
-                                              PIPE_USAGE_DEFAULT,
-                                              sizeof(vertices),
-                                              vertices);
-
-   info.ctx->set_vertex_buffers(info.ctx, 0, 1, 0, false, &vbuf);
-}
-
 static void set_vertex_shader(void)
 {
    void *handle;
@@ -171,7 +136,7 @@ init(const unsigned swizzle[4])
 
    init_tex(swizzle);
 
-   set_vertices();
+   graw_set_vertices(info.ctx, vertices, sizeof(vertices));
    set_vertex_shader();
    set_fragment_shader();
 }
diff --git a/src/gallium/tests/graw/tri-gs.c b/src/gallium/tests/graw/tri-gs.c
index 8d5ad205860c..d6964df821e3 100644
--- a/src/gallium/tests/graw/tri-gs.c
+++ b/src/gallium/tests/graw/tri-gs.c
@@ -12,6 +12,7 @@
 #include "util/u_memory.h"      /* Offset() */
 #include "util/u_draw_quad.h"
 #include "util/u_inlines.h"
+#include "graw_util.h"
 
 enum pipe_format formats[] = {
    PIPE_FORMAT_RGBA8888_UNORM,
@@ -28,11 +29,6 @@ static struct pipe_surface *surf = NULL;
 static struct pipe_resource *tex = NULL;
 static void *window = NULL;
 
-struct vertex {
-   float position[4];
-   float color[4];
-};
-
 static struct vertex vertices[4] =
 {
    { { 0.0f, -0.9f, 0.0f, 1.0f },
@@ -75,35 +71,6 @@ static void set_viewport( float x, float y,
    ctx->set_viewport_states( ctx, 0, 1, &vp );
 }
 
-static void set_vertices( void )
-{
-   struct pipe_vertex_element ve[2];
-   struct pipe_vertex_buffer vbuf;
-   void *handle;
-
-   memset(ve, 0, sizeof ve);
-
-   ve[0].src_offset = Offset(struct vertex, position);
-   ve[0].src_format = PIPE_FORMAT_R32G32B32A32_FLOAT;
-   ve[1].src_offset = Offset(struct vertex, color);
-   ve[1].src_format = PIPE_FORMAT_R32G32B32A32_FLOAT;
-
-   handle = ctx->create_vertex_elements_state(ctx, 2, ve);
-   ctx->bind_vertex_elements_state(ctx, handle);
-
-   memset(&vbuf, 0, sizeof vbuf);
-
-   vbuf.stride = sizeof( struct vertex );
-   vbuf.buffer_offset = 0;
-   vbuf.buffer.resource = pipe_buffer_create_with_data(ctx,
-                                              PIPE_BIND_VERTEX_BUFFER,
-                                              PIPE_USAGE_DEFAULT,
-                                              sizeof(vertices),
-                                              vertices);
-
-   ctx->set_vertex_buffers(ctx, 0, 1, 0, false, &vbuf);
-}
-
 static void set_vertex_shader( void )
 {
    void *handle;
@@ -267,7 +234,7 @@ static void init( void )
    }
 
    set_viewport(0, 0, WIDTH, HEIGHT, 30, 1000);
-   set_vertices();
+   graw_set_vertices(ctx, vertices, sizeof(vertices));
    set_vertex_shader();
    set_fragment_shader();
    set_geometry_shader();
diff --git a/src/gallium/tests/graw/tri-instanced.c b/src/gallium/tests/graw/tri-instanced.c
index 66f7d1b22cba..1e60ac06b400 100644
--- a/src/gallium/tests/graw/tri-instanced.c
+++ b/src/gallium/tests/graw/tri-instanced.c
@@ -14,6 +14,7 @@
 #include "util/u_memory.h"      /* Offset() */
 #include "util/u_draw_quad.h"
 #include "util/u_inlines.h"
+#include "graw_util.h"
 
 
 enum pipe_format formats[] = {
@@ -31,12 +32,6 @@ static struct pipe_surface *surf = NULL;
 static struct pipe_resource *tex = NULL;
 static void *window = NULL;
 
-struct vertex {
-   float position[4];
-   float color[4];
-};
-
-
 static int draw_elements = 0;
 
 
@@ -107,29 +102,30 @@ static void set_viewport( float x, float y,
 
 static void set_vertices( void )
 {
-   struct pipe_vertex_element ve[3];
+   struct pipe_vertex_elements ve;
    struct pipe_vertex_buffer vbuf[2];
-   void *handle;
+   struct pipe_vertex_elements *handle;
 
-   memset(ve, 0, sizeof ve);
+   memset(&ve, 0, sizeof ve);
 
    /* pos */
-   ve[0].src_offset = Offset(struct vertex, position);
-   ve[0].src_format = PIPE_FORMAT_R32G32B32A32_FLOAT;
-   ve[0].vertex_buffer_index = 0;
+   ve.count = 3;
+   ve.input[0].src_offset = Offset(struct vertex, position);
+   ve.input[0].src_format = PIPE_FORMAT_R32G32B32A32_FLOAT;
+   ve.input[0].vertex_buffer_index = 0;
 
    /* color */
-   ve[1].src_offset = Offset(struct vertex, color);
-   ve[1].src_format = PIPE_FORMAT_R32G32B32A32_FLOAT;
-   ve[1].vertex_buffer_index = 0;
+   ve.input[1].src_offset = Offset(struct vertex, color);
+   ve.input[1].src_format = PIPE_FORMAT_R32G32B32A32_FLOAT;
+   ve.input[1].vertex_buffer_index = 0;
 
    /* per-instance info */
-   ve[2].src_offset = 0;
-   ve[2].src_format = PIPE_FORMAT_R32G32B32A32_FLOAT;
-   ve[2].vertex_buffer_index = 1;
-   ve[2].instance_divisor = 1;
+   ve.input[2].src_offset = 0;
+   ve.input[2].src_format = PIPE_FORMAT_R32G32B32A32_FLOAT;
+   ve.input[2].vertex_buffer_index = 1;
+   ve.input[2].instance_divisor = 1;
 
-   handle = ctx->create_vertex_elements_state(ctx, 3, ve);
+   handle = ctx->create_vertex_elements_state(ctx, &ve);
    ctx->bind_vertex_elements_state(ctx, handle);
 
    memset(&vbuf, 0, sizeof vbuf);
diff --git a/src/gallium/tests/graw/tri-large.c b/src/gallium/tests/graw/tri-large.c
index 2f4afb0658fa..81f0b2bbbf19 100644
--- a/src/gallium/tests/graw/tri-large.c
+++ b/src/gallium/tests/graw/tri-large.c
@@ -14,11 +14,6 @@ static const int WIDTH = 4*2048;
 static const int HEIGHT = 4*2048;
 
 
-struct vertex {
-   float position[4];
-   float color[4];
-};
-
 static boolean FlatShade = FALSE;
 
 
@@ -41,18 +36,19 @@ static struct vertex vertices[3] =
 
 static void set_vertices( void )
 {
-   struct pipe_vertex_element ve[2];
+   struct pipe_vertex_elements ve;
    struct pipe_vertex_buffer vbuf;
-   void *handle;
+   struct pipe_vertex_elements *handle;
 
-   memset(ve, 0, sizeof ve);
+   memset(&ve, 0, sizeof ve);
 
-   ve[0].src_offset = Offset(struct vertex, position);
-   ve[0].src_format = PIPE_FORMAT_R32G32B32A32_FLOAT;
-   ve[1].src_offset = Offset(struct vertex, color);
-   ve[1].src_format = PIPE_FORMAT_R32G32B32A32_FLOAT;
+   ve.count = 2;
+   ve.input[0].src_offset = Offset(struct vertex, position);
+   ve.input[0].src_format = PIPE_FORMAT_R32G32B32A32_FLOAT;
+   ve.input[1].src_offset = Offset(struct vertex, color);
+   ve.input[1].src_format = PIPE_FORMAT_R32G32B32A32_FLOAT;
 
-   handle = info.ctx->create_vertex_elements_state(info.ctx, 2, ve);
+   handle = info.ctx->create_vertex_elements_state(info.ctx, &ve);
    info.ctx->bind_vertex_elements_state(info.ctx, handle);
 
    memset(&vbuf, 0, sizeof vbuf);
diff --git a/src/gallium/tests/graw/tri.c b/src/gallium/tests/graw/tri.c
index 4c59a66cba4d..48306659aff5 100644
--- a/src/gallium/tests/graw/tri.c
+++ b/src/gallium/tests/graw/tri.c
@@ -11,11 +11,6 @@ static const int WIDTH = 300;
 static const int HEIGHT = 300;
 
 
-struct vertex {
-   float position[4];
-   float color[4];
-};
-
 static boolean FlatShade = FALSE;
 
 
@@ -36,36 +31,6 @@ static struct vertex vertices[3] =
 };
 
 
-static void set_vertices( void )
-{
-   struct pipe_vertex_element ve[2];
-   struct pipe_vertex_buffer vbuf;
-   void *handle;
-
-   memset(ve, 0, sizeof ve);
-
-   ve[0].src_offset = Offset(struct vertex, position);
-   ve[0].src_format = PIPE_FORMAT_R32G32B32A32_FLOAT;
-   ve[1].src_offset = Offset(struct vertex, color);
-   ve[1].src_format = PIPE_FORMAT_R32G32B32A32_FLOAT;
-
-   handle = info.ctx->create_vertex_elements_state(info.ctx, 2, ve);
-   info.ctx->bind_vertex_elements_state(info.ctx, handle);
-
-   memset(&vbuf, 0, sizeof vbuf);
-
-   vbuf.stride = sizeof( struct vertex );
-   vbuf.buffer_offset = 0;
-   vbuf.buffer.resource = pipe_buffer_create_with_data(info.ctx,
-                                              PIPE_BIND_VERTEX_BUFFER,
-                                              PIPE_USAGE_DEFAULT,
-                                              sizeof(vertices),
-                                              vertices);
-
-   info.ctx->set_vertex_buffers(info.ctx, 0, 1, 0, false, &vbuf);
-}
-
-
 static void set_vertex_shader( void )
 {
    void *handle;
@@ -137,7 +102,7 @@ static void init( void )
 
    graw_util_viewport(&info, 0, 0, WIDTH, HEIGHT, 30, 1000);
 
-   set_vertices();
+   graw_set_vertices(info.ctx, vertices, sizeof(vertices));
    set_vertex_shader();
    set_fragment_shader();
 }
diff --git a/src/gallium/tests/graw/vs-test.c b/src/gallium/tests/graw/vs-test.c
index 215a756bbd3c..0d23ccffeb9c 100644
--- a/src/gallium/tests/graw/vs-test.c
+++ b/src/gallium/tests/graw/vs-test.c
@@ -15,6 +15,7 @@
 #include "util/u_memory.h"      /* Offset() */
 #include "util/u_draw_quad.h"
 #include "util/u_box.h"    
+#include "graw_util.h"
 
 static const char *filename = NULL;
 unsigned show_fps = 0;
@@ -50,11 +51,6 @@ static void *sampler = NULL;
 static void *window = NULL;
 static struct pipe_resource *samptex = NULL;
 
-struct vertex {
-   float position[4];
-   float color[3];
-};
-
 /* Draw a regular mesh
  */
 #define MESH_SZ 16
@@ -138,19 +134,20 @@ static void set_viewport( float x, float y,
 
 static void set_vertices( void )
 {
-   struct pipe_vertex_element ve[2];
+   struct pipe_vertex_elements ve;
    struct pipe_vertex_buffer vbuf;
-   void *handle;
+   struct pipe_vertex_elements *handle;
    int x,y;
 
-   memset(ve, 0, sizeof ve);
+   memset(&ve, 0, sizeof ve);
 
-   ve[0].src_offset = Offset(struct vertex, position);
-   ve[0].src_format = PIPE_FORMAT_R32G32B32A32_FLOAT;
-   ve[1].src_offset = Offset(struct vertex, color);
-   ve[1].src_format = PIPE_FORMAT_R32G32B32A32_FLOAT;
+   ve.count = 2;
+   ve.input[0].src_offset = Offset(struct vertex, position);
+   ve.input[0].src_format = PIPE_FORMAT_R32G32B32A32_FLOAT;
+   ve.input[1].src_offset = Offset(struct vertex, color);
+   ve.input[1].src_format = PIPE_FORMAT_R32G32B32A32_FLOAT;
 
-   handle = ctx->create_vertex_elements_state(ctx, 2, ve);
+   handle = ctx->create_vertex_elements_state(ctx, &ve);
    ctx->bind_vertex_elements_state(ctx, handle);
 
    for (x = 0; x < MESH_SZ; x++) {
diff --git a/src/gallium/tests/trivial/quad-tex.c b/src/gallium/tests/trivial/quad-tex.c
index 2578fb573cd0..26911e766092 100644
--- a/src/gallium/tests/trivial/quad-tex.c
+++ b/src/gallium/tests/trivial/quad-tex.c
@@ -74,7 +74,7 @@ struct program
 	struct pipe_sampler_state sampler;
 	struct pipe_viewport_state viewport;
 	struct pipe_framebuffer_state framebuffer;
-	struct cso_velems_state velem;
+	struct pipe_vertex_elements velem;
 
 	void *vs;
 	void *fs;
@@ -261,15 +261,15 @@ static void init_prog(struct program *p)
 	memset(&p->velem, 0, sizeof(p->velem));
         p->velem.count = 2;
 
-	p->velem.velems[0].src_offset = 0 * 4 * sizeof(float); /* offset 0, first element */
-	p->velem.velems[0].instance_divisor = 0;
-	p->velem.velems[0].vertex_buffer_index = 0;
-	p->velem.velems[0].src_format = PIPE_FORMAT_R32G32B32A32_FLOAT;
+	p->velem.input[0].src_offset = 0 * 4 * sizeof(float); /* offset 0, first element */
+	p->velem.input[0].instance_divisor = 0;
+	p->velem.input[0].vertex_buffer_index = 0;
+	p->velem.input[0].src_format = PIPE_FORMAT_R32G32B32A32_FLOAT;
 
-	p->velem.velems[1].src_offset = 1 * 4 * sizeof(float); /* offset 16, second element */
-	p->velem.velems[1].instance_divisor = 0;
-	p->velem.velems[1].vertex_buffer_index = 0;
-	p->velem.velems[1].src_format = PIPE_FORMAT_R32G32B32A32_FLOAT;
+	p->velem.input[1].src_offset = 1 * 4 * sizeof(float); /* offset 16, second element */
+	p->velem.input[1].instance_divisor = 0;
+	p->velem.input[1].vertex_buffer_index = 0;
+	p->velem.input[1].src_format = PIPE_FORMAT_R32G32B32A32_FLOAT;
 
 	/* vertex shader */
 	{
diff --git a/src/gallium/tests/trivial/tri.c b/src/gallium/tests/trivial/tri.c
index 0bc09a983a27..f4ea03445a66 100644
--- a/src/gallium/tests/trivial/tri.c
+++ b/src/gallium/tests/trivial/tri.c
@@ -70,7 +70,7 @@ struct program
 	struct pipe_rasterizer_state rasterizer;
 	struct pipe_viewport_state viewport;
 	struct pipe_framebuffer_state framebuffer;
-	struct cso_velems_state velem;
+	struct pipe_vertex_elements velem;
 
 	void *vs;
 	void *fs;
@@ -204,15 +204,15 @@ static void init_prog(struct program *p)
 	memset(&p->velem, 0, sizeof(p->velem));
         p->velem.count = 2;
 
-	p->velem.velems[0].src_offset = 0 * 4 * sizeof(float); /* offset 0, first element */
-	p->velem.velems[0].instance_divisor = 0;
-	p->velem.velems[0].vertex_buffer_index = 0;
-	p->velem.velems[0].src_format = PIPE_FORMAT_R32G32B32A32_FLOAT;
+	p->velem.input[0].src_offset = 0 * 4 * sizeof(float); /* offset 0, first element */
+	p->velem.input[0].instance_divisor = 0;
+	p->velem.input[0].vertex_buffer_index = 0;
+	p->velem.input[0].src_format = PIPE_FORMAT_R32G32B32A32_FLOAT;
 
-	p->velem.velems[1].src_offset = 1 * 4 * sizeof(float); /* offset 16, second element */
-	p->velem.velems[1].instance_divisor = 0;
-	p->velem.velems[1].vertex_buffer_index = 0;
-	p->velem.velems[1].src_format = PIPE_FORMAT_R32G32B32A32_FLOAT;
+	p->velem.input[1].src_offset = 1 * 4 * sizeof(float); /* offset 16, second element */
+	p->velem.input[1].instance_divisor = 0;
+	p->velem.input[1].vertex_buffer_index = 0;
+	p->velem.input[1].src_format = PIPE_FORMAT_R32G32B32A32_FLOAT;
 
 	/* vertex shader */
 	{
diff --git a/src/mesa/state_tracker/st_atom.h b/src/mesa/state_tracker/st_atom.h
index b20b82884600..33b211b045b1 100644
--- a/src/mesa/state_tracker/st_atom.h
+++ b/src/mesa/state_tracker/st_atom.h
@@ -45,7 +45,7 @@ struct gl_vertex_program;
 struct st_common_variant;
 struct pipe_vertex_buffer;
 struct pipe_vertex_element;
-struct cso_velems_state;
+struct pipe_vertex_elements;
 
 /**
  * Enumeration of state tracker pipelines.
@@ -68,7 +68,7 @@ void
 st_setup_arrays(struct st_context *st,
                 const struct gl_vertex_program *vp,
                 const struct st_common_variant *vp_variant,
-                struct cso_velems_state *velements,
+                struct pipe_vertex_elements *velements,
                 struct pipe_vertex_buffer *vbuffer, unsigned *num_vbuffers,
                 bool *has_user_vertex_buffers);
 
@@ -76,7 +76,7 @@ void
 st_setup_current_user(struct st_context *st,
                       const struct gl_vertex_program *vp,
                       const struct st_common_variant *vp_variant,
-                      struct cso_velems_state *velements,
+                      struct pipe_vertex_elements *velements,
                       struct pipe_vertex_buffer *vbuffer, unsigned *num_vbuffers);
 
 void
diff --git a/src/mesa/state_tracker/st_atom_array.cpp b/src/mesa/state_tracker/st_atom_array.cpp
index 4ed0d488068c..2621c142b034 100644
--- a/src/mesa/state_tracker/st_atom_array.cpp
+++ b/src/mesa/state_tracker/st_atom_array.cpp
@@ -82,7 +82,7 @@ setup_arrays(struct st_context *st,
              const GLbitfield nonzero_divisor_attribs,
              const GLbitfield enabled_attribs,
              const GLbitfield enabled_user_attribs,
-             struct cso_velems_state *velements,
+             struct pipe_vertex_elements *velements,
              struct pipe_vertex_buffer *vbuffer, unsigned *num_vbuffers,
              bool *has_user_vertex_buffers)
 {
@@ -123,7 +123,7 @@ setup_arrays(struct st_context *st,
             continue;
 
          /* Set the vertex element. */
-         init_velement(velements->velems, &attrib->Format, 0,
+         init_velement(velements->input, &attrib->Format, 0,
                        binding->InstanceDivisor, bufidx,
                        dual_slot_inputs & BITFIELD_BIT(attr),
                        util_bitcount_fast<POPCNT>(inputs_read & BITFIELD_MASK(attr)));
@@ -169,7 +169,7 @@ setup_arrays(struct st_context *st,
          const struct gl_array_attributes *const attrib
             = _mesa_draw_array_attrib(vao, attr);
          const GLuint off = _mesa_draw_attributes_relative_offset(attrib);
-         init_velement(velements->velems, &attrib->Format, off,
+         init_velement(velements->input, &attrib->Format, off,
                        binding->InstanceDivisor, bufidx,
                        dual_slot_inputs & BITFIELD_BIT(attr),
                        util_bitcount_fast<POPCNT>(inputs_read & BITFIELD_MASK(attr)));
@@ -182,7 +182,7 @@ void
 st_setup_arrays(struct st_context *st,
                 const struct gl_vertex_program *vp,
                 const struct st_common_variant *vp_variant,
-                struct cso_velems_state *velements,
+                struct pipe_vertex_elements *velements,
                 struct pipe_vertex_buffer *vbuffer, unsigned *num_vbuffers,
                 bool *has_user_vertex_buffers)
 {
@@ -205,7 +205,7 @@ template<util_popcnt POPCNT, st_update_flag UPDATE> void ALWAYS_INLINE
 st_setup_current(struct st_context *st,
                  const struct gl_vertex_program *vp,
                  const struct st_common_variant *vp_variant,
-                 struct cso_velems_state *velements,
+                 struct pipe_vertex_elements *velements,
                  struct pipe_vertex_buffer *vbuffer, unsigned *num_vbuffers)
 {
    struct gl_context *ctx = st->ctx;
@@ -233,7 +233,7 @@ st_setup_current(struct st_context *st,
             memset(cursor + size, 0, alignment - size);
 
          if (UPDATE == UPDATE_ALL) {
-            init_velement(velements->velems, &attrib->Format, cursor - data,
+            init_velement(velements->input, &attrib->Format, cursor - data,
                           0, bufidx, dual_slot_inputs & BITFIELD_BIT(attr),
                           util_bitcount_fast<POPCNT>(inputs_read & BITFIELD_MASK(attr)));
          }
@@ -269,7 +269,7 @@ void
 st_setup_current_user(struct st_context *st,
                       const struct gl_vertex_program *vp,
                       const struct st_common_variant *vp_variant,
-                      struct cso_velems_state *velements,
+                      struct pipe_vertex_elements *velements,
                       struct pipe_vertex_buffer *vbuffer, unsigned *num_vbuffers)
 {
    struct gl_context *ctx = st->ctx;
@@ -285,7 +285,7 @@ st_setup_current_user(struct st_context *st,
          = _mesa_draw_current_attrib(ctx, attr);
       const unsigned bufidx = (*num_vbuffers)++;
 
-      init_velement(velements->velems, &attrib->Format, 0, 0,
+      init_velement(velements->input, &attrib->Format, 0, 0,
                     bufidx, dual_slot_inputs & BITFIELD_BIT(attr),
                     util_bitcount(inputs_read & BITFIELD_MASK(attr)));
 
@@ -308,7 +308,7 @@ st_update_array_templ(struct st_context *st)
 
    struct pipe_vertex_buffer vbuffer[PIPE_MAX_ATTRIBS];
    unsigned num_vbuffers = 0;
-   struct cso_velems_state velements;
+   struct pipe_vertex_elements velements;
    bool uses_user_vertex_buffers;
 
    /* ST_NEW_VERTEX_ARRAYS */
@@ -394,7 +394,7 @@ st_create_gallium_vertex_state(struct gl_context *ctx,
    const GLbitfield dual_slot_inputs = 0; /* always zero */
    struct pipe_vertex_buffer vbuffer[PIPE_MAX_ATTRIBS];
    unsigned num_vbuffers = 0;
-   struct cso_velems_state velements;
+   struct pipe_vertex_elements velements;
    bool uses_user_vertex_buffers;
 
    setup_arrays<POPCNT_NO, UPDATE_ALL>(st, vao, dual_slot_inputs, inputs_read, 0,
@@ -410,8 +410,7 @@ st_create_gallium_vertex_state(struct gl_context *ctx,
 
    struct pipe_screen *screen = st->screen;
    struct pipe_vertex_state *state =
-      screen->create_vertex_state(screen, &vbuffer[0], velements.velems,
-                                  velements.count,
+      screen->create_vertex_state(screen, &vbuffer[0], &velements,
                                   indexbuf ?
                                   indexbuf->buffer : NULL,
                                   enabled_attribs);
diff --git a/src/mesa/state_tracker/st_cb_drawtex.c b/src/mesa/state_tracker/st_cb_drawtex.c
index 357440e9c47c..9aab929fce77 100644
--- a/src/mesa/state_tracker/st_cb_drawtex.c
+++ b/src/mesa/state_tracker/st_cb_drawtex.c
@@ -170,7 +170,7 @@ st_DrawTex(struct gl_context *ctx, GLfloat x, GLfloat y, GLfloat z,
    GLboolean emitColor;
    enum tgsi_semantic semantic_names[2 + MAX_TEXTURE_UNITS];
    uint semantic_indexes[2 + MAX_TEXTURE_UNITS];
-   struct cso_velems_state velems;
+   struct pipe_vertex_elements velems;
    unsigned offset;
 
    st_flush_bitmap_cache(st);
@@ -307,11 +307,11 @@ st_DrawTex(struct gl_context *ctx, GLfloat x, GLfloat y, GLfloat z,
    cso_set_geometry_shader_handle(cso, NULL);
 
    for (i = 0; i < numAttribs; i++) {
-      velems.velems[i].src_offset = i * 4 * sizeof(float);
-      velems.velems[i].instance_divisor = 0;
-      velems.velems[i].vertex_buffer_index = 0;
-      velems.velems[i].src_format = PIPE_FORMAT_R32G32B32A32_FLOAT;
-      velems.velems[i].dual_slot = false;
+      velems.input[i].src_offset = i * 4 * sizeof(float);
+      velems.input[i].instance_divisor = 0;
+      velems.input[i].vertex_buffer_index = 0;
+      velems.input[i].src_format = PIPE_FORMAT_R32G32B32A32_FLOAT;
+      velems.input[i].dual_slot = false;
    }
    velems.count = numAttribs;
 
diff --git a/src/mesa/state_tracker/st_context.c b/src/mesa/state_tracker/st_context.c
index 530ea2c61c84..a8bb30589a3f 100644
--- a/src/mesa/state_tracker/st_context.c
+++ b/src/mesa/state_tracker/st_context.c
@@ -540,15 +540,15 @@ st_create_context_priv(struct gl_context *ctx, struct pipe_context *pipe,
       STATIC_ASSERT(sizeof(struct st_util_vertex) == 9 * sizeof(float));
 
       memset(&st->util_velems, 0, sizeof(st->util_velems));
-      st->util_velems.velems[0].src_offset = 0;
-      st->util_velems.velems[0].vertex_buffer_index = 0;
-      st->util_velems.velems[0].src_format = PIPE_FORMAT_R32G32B32_FLOAT;
-      st->util_velems.velems[1].src_offset = 3 * sizeof(float);
-      st->util_velems.velems[1].vertex_buffer_index = 0;
-      st->util_velems.velems[1].src_format = PIPE_FORMAT_R32G32B32A32_FLOAT;
-      st->util_velems.velems[2].src_offset = 7 * sizeof(float);
-      st->util_velems.velems[2].vertex_buffer_index = 0;
-      st->util_velems.velems[2].src_format = PIPE_FORMAT_R32G32_FLOAT;
+      st->util_velems.input[0].src_offset = 0;
+      st->util_velems.input[0].vertex_buffer_index = 0;
+      st->util_velems.input[0].src_format = PIPE_FORMAT_R32G32B32_FLOAT;
+      st->util_velems.input[1].src_offset = 3 * sizeof(float);
+      st->util_velems.input[1].vertex_buffer_index = 0;
+      st->util_velems.input[1].src_format = PIPE_FORMAT_R32G32B32A32_FLOAT;
+      st->util_velems.input[2].src_offset = 7 * sizeof(float);
+      st->util_velems.input[2].vertex_buffer_index = 0;
+      st->util_velems.input[2].src_format = PIPE_FORMAT_R32G32_FLOAT;
    }
 
    ctx->Const.PackedDriverUniformStorage =
diff --git a/src/mesa/state_tracker/st_context.h b/src/mesa/state_tracker/st_context.h
index 005d18988cea..fa3a0c6fae3c 100644
--- a/src/mesa/state_tracker/st_context.h
+++ b/src/mesa/state_tracker/st_context.h
@@ -340,7 +340,7 @@ struct st_context
    } pbo;
 
    /** for drawing with st_util_vertex */
-   struct cso_velems_state util_velems;
+   struct pipe_vertex_elements util_velems;
 
    /** passthrough vertex shader matching the util_velem attributes */
    void *passthrough_vs;
diff --git a/src/mesa/state_tracker/st_draw_feedback.c b/src/mesa/state_tracker/st_draw_feedback.c
index 8b97d0b8adfb..5bb4695ad567 100644
--- a/src/mesa/state_tracker/st_draw_feedback.c
+++ b/src/mesa/state_tracker/st_draw_feedback.c
@@ -111,7 +111,7 @@ st_feedback_draw_vbo(struct gl_context *ctx,
    struct st_common_variant *vp_variant;
    struct pipe_vertex_buffer vbuffers[PIPE_MAX_SHADER_INPUTS];
    unsigned num_vbuffers = 0;
-   struct cso_velems_state velements;
+   struct pipe_vertex_elements velements;
    struct pipe_transfer *vb_transfer[PIPE_MAX_ATTRIBS] = {NULL};
    struct pipe_transfer *ib_transfer = NULL;
    GLuint i;
@@ -183,7 +183,7 @@ st_feedback_draw_vbo(struct gl_context *ctx,
    }
 
    draw_set_vertex_buffers(draw, 0, num_vbuffers, 0, vbuffers);
-   draw_set_vertex_elements(draw, vp->num_inputs, velements.velems);
+   draw_set_vertex_elements(draw, vp->num_inputs, velements.input);
 
    unsigned start = 0;
 
diff --git a/src/mesa/state_tracker/st_pbo.c b/src/mesa/state_tracker/st_pbo.c
index f32578405f93..897b4e1db4b9 100644
--- a/src/mesa/state_tracker/st_pbo.c
+++ b/src/mesa/state_tracker/st_pbo.c
@@ -211,7 +211,7 @@ st_pbo_draw(struct st_context *st, const struct st_pbo_addresses *addr,
    /* Upload vertices */
    {
       struct pipe_vertex_buffer vbo = {0};
-      struct cso_velems_state velem;
+      struct pipe_vertex_elements velem;
 
       float x0 = (float) addr->xoffset / surface_width * 2.0f - 1.0f;
       float y0 = (float) addr->yoffset / surface_height * 2.0f - 1.0f;
@@ -239,11 +239,11 @@ st_pbo_draw(struct st_context *st, const struct st_pbo_addresses *addr,
       u_upload_unmap(st->pipe->stream_uploader);
 
       velem.count = 1;
-      velem.velems[0].src_offset = 0;
-      velem.velems[0].instance_divisor = 0;
-      velem.velems[0].vertex_buffer_index = 0;
-      velem.velems[0].src_format = PIPE_FORMAT_R32G32_FLOAT;
-      velem.velems[0].dual_slot = false;
+      velem.input[0].src_offset = 0;
+      velem.input[0].instance_divisor = 0;
+      velem.input[0].vertex_buffer_index = 0;
+      velem.input[0].src_format = PIPE_FORMAT_R32G32_FLOAT;
+      velem.input[0].dual_slot = false;
 
       cso_set_vertex_elements(cso, &velem);
 
diff --git a/src/util/indices/u_primconvert.c b/src/util/indices/u_primconvert.c
index dcbc9052dacc..8ec88a3f54f5 100644
--- a/src/util/indices/u_primconvert.c
+++ b/src/util/indices/u_primconvert.c
@@ -357,8 +357,7 @@ util_primconvert_draw_vertex_state(struct primconvert_context *pc,
 
    struct pipe_vertex_state *new_state = pc->pipe->screen->create_vertex_state(pc->pipe->screen,
                                                                                &vstate->input.vbuffer,
-                                                                               vstate->input.elements,
-                                                                               vstate->input.num_elements,
+                                                                               &vstate->input.ve,
                                                                                new_info.index.resource,
                                                                                vstate->input.full_velem_mask);
    if (new_state) {
-- 
GitLab


From 9efc15e8212d85e245c26461b5bc1b8531b837ca Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Sun, 7 Aug 2022 21:52:01 -0400
Subject: [PATCH 02/15] gallium: lower 64-bit attribs in drivers

Since we'll use the CSO structure as a key for lookups, we can't do
the lowering before the CSO structure is created because that would
break CSO lookups.

We have to do the following. Drivers will keep the original vertex
elements (before lowering) in pipe_vertex_elements. Then, if they want
to keep the version of vertex elements after lowering, they have to put
them in their driver-specific version of the CSO structure.

This will allow cso_cache not to allocate a separate structure to keep
the original vertex elements around, so it's a net win for memory usage
and the number of memory allocations.
---
 src/gallium/auxiliary/cso_cache/cso_context.c |  4 --
 src/gallium/auxiliary/util/u_helpers.c        | 27 +++++++++
 src/gallium/auxiliary/util/u_helpers.h        | 12 ++++
 src/gallium/auxiliary/util/u_vbuf.c           | 59 ++++++++++---------
 src/gallium/drivers/crocus/crocus_state.c     |  8 ++-
 src/gallium/drivers/d3d12/d3d12_context.cpp   |  7 ++-
 src/gallium/drivers/iris/iris_state.c         | 29 +++++----
 src/gallium/drivers/llvmpipe/lp_context.h     |  3 +-
 .../drivers/llvmpipe/lp_state_vertex.c        | 35 +++--------
 src/gallium/drivers/llvmpipe/lp_surface.c     |  2 +-
 src/gallium/drivers/nouveau/nvc0/nvc0_vbo.c   |  9 ++-
 src/gallium/drivers/r600/r600_asm.c           |  9 ++-
 src/gallium/drivers/radeonsi/si_state.c       |  8 ++-
 src/gallium/drivers/softpipe/sp_context.h     |  3 +-
 .../drivers/softpipe/sp_state_vertex.c        | 38 +++---------
 src/gallium/drivers/softpipe/sp_surface.c     |  2 +-
 src/gallium/drivers/svga/svga_context.h       |  2 +
 src/gallium/drivers/svga/svga_pipe_vertex.c   | 21 ++++---
 src/gallium/drivers/svga/svga_state_vdecl.c   | 10 ++--
 src/gallium/drivers/svga/svga_swtnl_state.c   |  4 +-
 src/gallium/drivers/virgl/virgl_context.c     |  7 ++-
 src/gallium/drivers/zink/zink_state.c         |  8 ++-
 22 files changed, 185 insertions(+), 122 deletions(-)

diff --git a/src/gallium/auxiliary/cso_cache/cso_context.c b/src/gallium/auxiliary/cso_cache/cso_context.c
index 2520e3c24f53..5887635cb38b 100644
--- a/src/gallium/auxiliary/cso_cache/cso_context.c
+++ b/src/gallium/auxiliary/cso_cache/cso_context.c
@@ -1051,10 +1051,6 @@ cso_set_vertex_elements_direct(struct cso_context *ctx,
 
       memcpy(&cso->state, velems, key_size);
 
-      /* Lower 64-bit vertex attributes. */
-      struct pipe_vertex_elements tmp;
-      util_lower_uint64_vertex_elements(&velems, &tmp);
-
       cso->data = ctx->pipe->create_vertex_elements_state(ctx->pipe, velems);
 
       iter = cso_insert_state(&ctx->cache, hash_key, CSO_VELEMENTS, cso);
diff --git a/src/gallium/auxiliary/util/u_helpers.c b/src/gallium/auxiliary/util/u_helpers.c
index 17d1246fd81d..ffeef92d705d 100644
--- a/src/gallium/auxiliary/util/u_helpers.c
+++ b/src/gallium/auxiliary/util/u_helpers.c
@@ -29,6 +29,7 @@
 #include "util/u_cpu_detect.h"
 #include "util/u_helpers.h"
 #include "util/u_inlines.h"
+#include "util/u_memory.h"
 #include "util/u_upload_mgr.h"
 #include "util/u_thread.h"
 #include "util/os_time.h"
@@ -543,3 +544,29 @@ util_clamp_color(enum pipe_format format,
 
    return clamp_color;
 }
+
+struct pipe_vertex_elements *
+util_create_vertex_elements_cso(struct pipe_context *ctx,
+                                const struct pipe_vertex_elements *state)
+{
+   assert(state->count <= PIPE_MAX_ATTRIBS);
+
+   struct util_vertex_elements_cso *velems;
+   velems = CALLOC_STRUCT(util_vertex_elements_cso);
+   velems->base = *state; /* copy the original state */
+
+   /* Lower double attribs. */
+   struct pipe_vertex_elements tmp;
+   util_lower_uint64_vertex_elements(&state, &tmp);
+   /* now state == &tmp if there was any lowering */
+
+   velems->lowered = *state;
+   return &velems->base;
+}
+
+void
+util_delete_vertex_elements_cso(struct pipe_context *ctx,
+                                struct pipe_vertex_elements *state)
+{
+   FREE(state);
+}
diff --git a/src/gallium/auxiliary/util/u_helpers.h b/src/gallium/auxiliary/util/u_helpers.h
index 246286d2bee1..bacfea5ddb34 100644
--- a/src/gallium/auxiliary/util/u_helpers.h
+++ b/src/gallium/auxiliary/util/u_helpers.h
@@ -131,6 +131,18 @@ util_init_pipe_vertex_state(struct pipe_screen *screen,
 union pipe_color_union util_clamp_color(enum pipe_format format,
                                         const union pipe_color_union *color);
 
+struct util_vertex_elements_cso {
+   struct pipe_vertex_elements base;
+   struct pipe_vertex_elements lowered;
+};
+
+struct pipe_vertex_elements *
+util_create_vertex_elements_cso(struct pipe_context *ctx,
+                                const struct pipe_vertex_elements *state);
+void
+util_delete_vertex_elements_cso(struct pipe_context *ctx,
+                                struct pipe_vertex_elements *state);
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/src/gallium/auxiliary/util/u_vbuf.c b/src/gallium/auxiliary/util/u_vbuf.c
index 475e00abb61b..06029609cea3 100644
--- a/src/gallium/auxiliary/util/u_vbuf.c
+++ b/src/gallium/auxiliary/util/u_vbuf.c
@@ -103,6 +103,7 @@
 
 struct u_vbuf_elements {
    struct pipe_vertex_elements base; /* don't change, it's used by memcmp for CSO lookups */
+   struct pipe_vertex_elements lowered;
 
    unsigned src_format_size[PIPE_MAX_ATTRIBS];
 
@@ -704,8 +705,8 @@ u_vbuf_translate_begin(struct u_vbuf *mgr,
 
    /* See if there are vertex attribs of each type to translate and
     * which ones. */
-   for (i = 0; i < mgr->ve->base.count; i++) {
-      unsigned vb_index = mgr->ve->base.input[i].vertex_buffer_index;
+   for (i = 0; i < mgr->ve->lowered.count; i++) {
+      unsigned vb_index = mgr->ve->lowered.input[i].vertex_buffer_index;
 
       if (!mgr->vertex_buffer[vb_index].stride) {
          if (!(mgr->ve->incompatible_elem_mask & (1 << i)) &&
@@ -713,7 +714,7 @@ u_vbuf_translate_begin(struct u_vbuf *mgr,
             continue;
          }
          mask[VB_CONST] |= 1 << vb_index;
-      } else if (mgr->ve->base.input[i].instance_divisor) {
+      } else if (mgr->ve->lowered.input[i].instance_divisor) {
          if (!(mgr->ve->incompatible_elem_mask & (1 << i)) &&
              !(incompatible_vb_mask & (1 << vb_index))) {
             continue;
@@ -738,11 +739,11 @@ u_vbuf_translate_begin(struct u_vbuf *mgr,
 
    unsigned min_alignment[VB_NUM] = {0};
    /* Initialize the translate keys. */
-   for (i = 0; i < mgr->ve->base.count; i++) {
+   for (i = 0; i < mgr->ve->lowered.count; i++) {
       struct translate_key *k;
       struct translate_element *te;
       enum pipe_format output_format = mgr->ve->native_format[i];
-      unsigned bit, vb_index = mgr->ve->base.input[i].vertex_buffer_index;
+      unsigned bit, vb_index = mgr->ve->lowered.input[i].vertex_buffer_index;
       bit = 1 << vb_index;
 
       if (!(mgr->ve->incompatible_elem_mask & (1 << i)) &&
@@ -759,7 +760,7 @@ u_vbuf_translate_begin(struct u_vbuf *mgr,
          }
       }
       assert(type < VB_NUM);
-      if (mgr->ve->base.input[i].src_format != output_format)
+      if (mgr->ve->lowered.input[i].src_format != output_format)
          assert(translate_is_output_format_supported(output_format));
       /*printf("velem=%i type=%i\n", i, type);*/
 
@@ -771,8 +772,8 @@ u_vbuf_translate_begin(struct u_vbuf *mgr,
       te->type = TRANSLATE_ELEMENT_NORMAL;
       te->instance_divisor = 0;
       te->input_buffer = vb_index;
-      te->input_format = mgr->ve->base.input[i].src_format;
-      te->input_offset = mgr->ve->base.input[i].src_offset;
+      te->input_format = mgr->ve->lowered.input[i].src_format;
+      te->input_offset = mgr->ve->lowered.input[i].src_offset;
       te->output_format = output_format;
       te->output_offset = k->output_stride;
       unsigned adjustment = 0;
@@ -809,11 +810,11 @@ u_vbuf_translate_begin(struct u_vbuf *mgr,
    }
 
    /* Setup new vertex elements. */
-   for (i = 0; i < mgr->ve->base.count; i++) {
+   for (i = 0; i < mgr->ve->lowered.count; i++) {
       for (type = 0; type < VB_NUM; type++) {
          if (elem_index[type][i] < key[type].nr_elements) {
             struct translate_element *te = &key[type].element[elem_index[type][i]];
-            mgr->fallback_velems.input[i].instance_divisor = mgr->ve->base.input[i].instance_divisor;
+            mgr->fallback_velems.input[i].instance_divisor = mgr->ve->lowered.input[i].instance_divisor;
             mgr->fallback_velems.input[i].src_format = te->output_format;
             mgr->fallback_velems.input[i].src_offset = te->output_offset;
             mgr->fallback_velems.input[i].vertex_buffer_index = mgr->fallback_vbs[type];
@@ -826,12 +827,12 @@ u_vbuf_translate_begin(struct u_vbuf *mgr,
       }
       /* No translating, just copy the original vertex element over. */
       if (type == VB_NUM) {
-         memcpy(&mgr->fallback_velems.input[i], &mgr->ve->base.input[i],
+         memcpy(&mgr->fallback_velems.input[i], &mgr->ve->lowered.input[i],
                 sizeof(struct pipe_vertex_element));
       }
    }
 
-   mgr->fallback_velems.count = mgr->ve->base.count;
+   mgr->fallback_velems.count = mgr->ve->lowered.count;
 
    u_vbuf_set_vertex_elements_internal(mgr, &mgr->fallback_velems);
    mgr->using_translate = TRUE;
@@ -863,24 +864,26 @@ static struct u_vbuf_elements *
 u_vbuf_create_vertex_elements(struct u_vbuf *mgr,
                               const struct pipe_vertex_elements *attribs)
 {
-   struct pipe_vertex_elements tmp;
-   util_lower_uint64_vertex_elements(&attribs, &tmp);
-
    struct pipe_context *pipe = mgr->pipe;
    unsigned i;
    struct pipe_vertex_elements driver_attribs;
    struct u_vbuf_elements *ve = CALLOC_STRUCT(u_vbuf_elements);
    uint32_t used_buffers = 0;
 
-   ve->base = *attribs;
+   ve->base = *attribs; /* copy the original state */
+
+   struct pipe_vertex_elements tmp;
+   util_lower_uint64_vertex_elements(&attribs, &tmp);
+   /* now attribs == &tmp if there was any lowering */
 
+   ve->lowered = *attribs;
    memcpy(&driver_attribs, attribs, sizeof(*attribs));
 
    /* Set the best native format in case the original format is not
     * supported. */
-   for (i = 0; i < ve->base.count; i++) {
-      enum pipe_format format = ve->base.input[i].src_format;
-      unsigned vb_index_bit = 1 << ve->base.input[i].vertex_buffer_index;
+   for (i = 0; i < ve->lowered.count; i++) {
+      enum pipe_format format = ve->lowered.input[i].src_format;
+      unsigned vb_index_bit = 1 << ve->lowered.input[i].vertex_buffer_index;
 
       ve->src_format_size[i] = util_format_get_blocksize(format);
 
@@ -889,7 +892,7 @@ u_vbuf_create_vertex_elements(struct u_vbuf *mgr,
 
       used_buffers |= vb_index_bit;
 
-      if (!ve->base.input[i].instance_divisor) {
+      if (!ve->lowered.input[i].instance_divisor) {
          ve->noninstance_vb_mask_any |= vb_index_bit;
       }
 
@@ -908,11 +911,11 @@ u_vbuf_create_vertex_elements(struct u_vbuf *mgr,
                                 ve->native_format_size[i] : (ve->native_format_size[i] / desc->nr_channels);
       ve->component_size[i] = component_size;
 
-      if (ve->base.input[i].src_format != format ||
+      if (ve->lowered.input[i].src_format != format ||
           (!mgr->caps.velem_src_offset_unaligned &&
-           ve->base.input[i].src_offset % 4 != 0) ||
+           ve->lowered.input[i].src_offset % 4 != 0) ||
           (!mgr->caps.attrib_component_unaligned &&
-           ve->base.input[i].src_offset % component_size != 0)) {
+           ve->lowered.input[i].src_offset % component_size != 0)) {
          ve->incompatible_elem_mask |= 1 << i;
          ve->incompatible_vb_mask_any |= vb_index_bit;
       } else {
@@ -932,7 +935,7 @@ u_vbuf_create_vertex_elements(struct u_vbuf *mgr,
        */
       ve->incompatible_vb_mask_any = used_buffers;
       ve->compatible_vb_mask_any = 0;
-      ve->incompatible_elem_mask = u_bit_consecutive(0, ve->base.count);
+      ve->incompatible_elem_mask = u_bit_consecutive(0, ve->lowered.count);
    }
 
    ve->used_vb_mask = used_buffers;
@@ -941,9 +944,9 @@ u_vbuf_create_vertex_elements(struct u_vbuf *mgr,
 
    /* Align the formats and offsets to the size of DWORD if needed. */
    if (!mgr->caps.velem_src_offset_unaligned) {
-      for (i = 0; i < ve->base.count; i++) {
+      for (i = 0; i < ve->lowered.count; i++) {
          ve->native_format_size[i] = align(ve->native_format_size[i], 4);
-         driver_attribs.input[i].src_offset = align(ve->base.input[i].src_offset, 4);
+         driver_attribs.input[i].src_offset = align(ve->lowered.input[i].src_offset, 4);
       }
    }
 
@@ -1161,9 +1164,9 @@ u_vbuf_upload_buffers(struct u_vbuf *mgr,
 {
    unsigned i;
    struct u_vbuf_elements *ve = mgr->ve;
-   unsigned nr_velems = ve->base.count;
+   unsigned nr_velems = ve->lowered.count;
    const struct pipe_vertex_element *velems =
-         mgr->using_translate ? mgr->fallback_velems.input : ve->base.input;
+         mgr->using_translate ? mgr->fallback_velems.input : ve->lowered.input;
 
    /* Faster path when no vertex attribs are interleaved. */
    if ((ve->interleaved_vb_mask & mgr->user_vb_mask) == 0) {
diff --git a/src/gallium/drivers/crocus/crocus_state.c b/src/gallium/drivers/crocus/crocus_state.c
index 49e22289d4d9..8b736da6228f 100644
--- a/src/gallium/drivers/crocus/crocus_state.c
+++ b/src/gallium/drivers/crocus/crocus_state.c
@@ -3784,7 +3784,13 @@ crocus_create_vertex_elements(struct pipe_context *ctx,
    struct crocus_vertex_element_state *cso =
       malloc(sizeof(struct crocus_vertex_element_state));
 
-   cso->base = *state;
+   cso->base = *state; /* copy the original state */
+
+   /* Lower double attribs. */
+   struct pipe_vertex_elements tmp;
+   util_lower_uint64_vertex_elements(&state, &tmp);
+   /* now state == &tmp if there was any lowering */
+
    cso->count = state->count;
 
    crocus_pack_command(GENX(3DSTATE_VERTEX_ELEMENTS), cso->vertex_elements, ve) {
diff --git a/src/gallium/drivers/d3d12/d3d12_context.cpp b/src/gallium/drivers/d3d12/d3d12_context.cpp
index 6752ece6db7e..431c3517c7bc 100644
--- a/src/gallium/drivers/d3d12/d3d12_context.cpp
+++ b/src/gallium/drivers/d3d12/d3d12_context.cpp
@@ -122,7 +122,12 @@ d3d12_create_vertex_elements_state(struct pipe_context *pctx,
    if (!cso)
       return NULL;
 
-   cso->base = *elements;
+   cso->base = *elements; /* copy the original state */
+
+   /* Lower double attribs. */
+   struct pipe_vertex_elements tmp;
+   util_lower_uint64_vertex_elements(&elements, &tmp);
+   /* now elements == &tmp if there was any lowering */
 
    for (unsigned i = 0; i < elements->count; ++i) {
       cso->elements[i].SemanticName = "TEXCOORD";
diff --git a/src/gallium/drivers/iris/iris_state.c b/src/gallium/drivers/iris/iris_state.c
index 36cf021d12d6..6745eae76c7c 100644
--- a/src/gallium/drivers/iris/iris_state.c
+++ b/src/gallium/drivers/iris/iris_state.c
@@ -89,6 +89,7 @@
 #include "pipe/p_context.h"
 #include "pipe/p_screen.h"
 #include "util/u_dual_blend.h"
+#include "util/u_helpers.h"
 #include "util/u_inlines.h"
 #include "util/format/u_format.h"
 #include "util/u_framebuffer.h"
@@ -3652,6 +3653,7 @@ iris_set_vertex_buffers(struct pipe_context *ctx,
  */
 struct iris_vertex_element_state {
    struct pipe_vertex_elements base; /* don't change, it's used by memcmp for CSO lookups */
+   unsigned count;
    uint32_t vertex_elements[1 + 33 * GENX(VERTEX_ELEMENT_STATE_length)];
    uint32_t vf_instancing[33 * GENX(3DSTATE_VF_INSTANCING_length)];
    uint32_t edgeflag_ve[GENX(VERTEX_ELEMENT_STATE_length)];
@@ -3678,7 +3680,14 @@ iris_create_vertex_elements(struct pipe_context *ctx,
    struct iris_vertex_element_state *cso =
       malloc(sizeof(struct iris_vertex_element_state));
 
-   cso->base = *state;
+   cso->base = *state; /* copy the original state */
+
+   /* Lower double attribs. */
+   struct pipe_vertex_elements tmp;
+   util_lower_uint64_vertex_elements(&state, &tmp);
+   /* now state == &tmp if there was any lowering */
+
+   cso->count = state->count;
 
    iris_pack_command(GENX(3DSTATE_VERTEX_ELEMENTS), cso->vertex_elements, ve) {
       ve.DWordLength =
@@ -3782,7 +3791,7 @@ iris_bind_vertex_elements_state(struct pipe_context *ctx, struct pipe_vertex_ele
    /* 3DSTATE_VF_SGVs overrides the last VE, so if the count is changing,
     * we need to re-emit it to ensure we're overriding the right one.
     */
-   if (new_cso && cso_changed(base.count))
+   if (new_cso && cso_changed(count))
       ice->state.dirty |= IRIS_DIRTY_VF_SGVS;
 
    ice->state.cso_vertex_elements = new_cso;
@@ -6663,7 +6672,7 @@ iris_upload_dirty_render_state(struct iris_context *ice,
 
    if (dirty & IRIS_DIRTY_VERTEX_ELEMENTS) {
       struct iris_vertex_element_state *cso = ice->state.cso_vertex_elements;
-      const unsigned entries = MAX2(cso->base.count, 1);
+      const unsigned entries = MAX2(cso->count, 1);
       if (!(ice->state.vs_needs_sgvs_element ||
             ice->state.vs_uses_derived_draw_params ||
             ice->state.vs_needs_edge_flag)) {
@@ -6671,7 +6680,7 @@ iris_upload_dirty_render_state(struct iris_context *ice,
                          (1 + entries * GENX(VERTEX_ELEMENT_STATE_length)));
       } else {
          uint32_t dynamic_ves[1 + 33 * GENX(VERTEX_ELEMENT_STATE_length)];
-         const unsigned dyn_count = cso->base.count +
+         const unsigned dyn_count = cso->count +
             ice->state.vs_needs_sgvs_element +
             ice->state.vs_uses_derived_draw_params;
 
@@ -6681,10 +6690,10 @@ iris_upload_dirty_render_state(struct iris_context *ice,
                1 + GENX(VERTEX_ELEMENT_STATE_length) * dyn_count - 2;
          }
          memcpy(&dynamic_ves[1], &cso->vertex_elements[1],
-                (cso->base.count - ice->state.vs_needs_edge_flag) *
+                (cso->count - ice->state.vs_needs_edge_flag) *
                 GENX(VERTEX_ELEMENT_STATE_length) * sizeof(uint32_t));
          uint32_t *ve_pack_dest =
-            &dynamic_ves[1 + (cso->base.count - ice->state.vs_needs_edge_flag) *
+            &dynamic_ves[1 + (cso->count - ice->state.vs_needs_edge_flag) *
                          GENX(VERTEX_ELEMENT_STATE_length)];
 
          if (ice->state.vs_needs_sgvs_element) {
@@ -6729,8 +6738,8 @@ iris_upload_dirty_render_state(struct iris_context *ice,
          iris_batch_emit(batch, cso->vf_instancing, sizeof(uint32_t) *
                          entries * GENX(3DSTATE_VF_INSTANCING_length));
       } else {
-         assert(cso->base.count > 0);
-         const unsigned edgeflag_index = cso->base.count - 1;
+         assert(cso->count > 0);
+         const unsigned edgeflag_index = cso->count - 1;
          uint32_t dynamic_vfi[33 * GENX(3DSTATE_VF_INSTANCING_length)];
          memcpy(&dynamic_vfi[0], cso->vf_instancing, edgeflag_index *
                 GENX(3DSTATE_VF_INSTANCING_length) * sizeof(uint32_t));
@@ -6760,14 +6769,14 @@ iris_upload_dirty_render_state(struct iris_context *ice,
             sgv.VertexIDEnable = true;
             sgv.VertexIDComponentNumber = 2;
             sgv.VertexIDElementOffset =
-               cso->base.count - ice->state.vs_needs_edge_flag;
+               cso->count - ice->state.vs_needs_edge_flag;
          }
 
          if (vs_prog_data->uses_instanceid) {
             sgv.InstanceIDEnable = true;
             sgv.InstanceIDComponentNumber = 3;
             sgv.InstanceIDElementOffset =
-               cso->base.count - ice->state.vs_needs_edge_flag;
+               cso->count - ice->state.vs_needs_edge_flag;
          }
       }
    }
diff --git a/src/gallium/drivers/llvmpipe/lp_context.h b/src/gallium/drivers/llvmpipe/lp_context.h
index ae0b25cca4b7..0631e1b536e5 100644
--- a/src/gallium/drivers/llvmpipe/lp_context.h
+++ b/src/gallium/drivers/llvmpipe/lp_context.h
@@ -35,6 +35,7 @@
 
 #include "draw/draw_vertex.h"
 #include "util/u_blitter.h"
+#include "util/u_helpers.h"
 
 #include "lp_tex_sample.h"
 #include "lp_jit.h"
@@ -70,7 +71,7 @@ struct llvmpipe_context {
    const struct lp_tess_ctrl_shader *tcs;
    const struct lp_tess_eval_shader *tes;
    struct lp_compute_shader *cs;
-   struct pipe_vertex_elements *velems;
+   struct util_vertex_elements_cso *velems;
    const struct lp_so_state *so;
 
    /** Other rendering state */
diff --git a/src/gallium/drivers/llvmpipe/lp_state_vertex.c b/src/gallium/drivers/llvmpipe/lp_state_vertex.c
index d90fc42d15fc..7889fa55b050 100644
--- a/src/gallium/drivers/llvmpipe/lp_state_vertex.c
+++ b/src/gallium/drivers/llvmpipe/lp_state_vertex.c
@@ -33,41 +33,24 @@
 #include "lp_state.h"
 
 #include "draw/draw_context.h"
-#include "util/u_helpers.h"
 #include "util/u_inlines.h"
 #include "util/u_transfer.h"
 
-
-static struct pipe_vertex_elements *
-llvmpipe_create_vertex_elements_state(struct pipe_context *pipe,
-                                      const struct pipe_vertex_elements *attribs)
-{
-   struct pipe_vertex_elements *velems;
-   assert(attribs->count <= PIPE_MAX_ATTRIBS);
-   velems = (struct pipe_vertex_elements *) MALLOC(sizeof(struct pipe_vertex_elements));
-   *velems = *attribs;
-   return velems;
-}
-
 static void
 llvmpipe_bind_vertex_elements_state(struct pipe_context *pipe,
                                     struct pipe_vertex_elements *velems)
 {
    struct llvmpipe_context *llvmpipe = llvmpipe_context(pipe);
+   struct util_vertex_elements_cso *state =
+      (struct util_vertex_elements_cso *)velems;
 
-   llvmpipe->velems = velems;
-
+   llvmpipe->velems = state;
    llvmpipe->dirty |= LP_NEW_VERTEX;
 
-   if (velems)
-      draw_set_vertex_elements(llvmpipe->draw, velems->count, velems->input);
-}
-
-static void
-llvmpipe_delete_vertex_elements_state(struct pipe_context *pipe,
-                                      struct pipe_vertex_elements *velems)
-{
-   FREE( velems );
+   if (state) {
+      draw_set_vertex_elements(llvmpipe->draw, state->lowered.count,
+                               state->lowered.input);
+   }
 }
 
 static void
@@ -97,9 +80,9 @@ llvmpipe_set_vertex_buffers(struct pipe_context *pipe,
 void
 llvmpipe_init_vertex_funcs(struct llvmpipe_context *llvmpipe)
 {
-   llvmpipe->pipe.create_vertex_elements_state = llvmpipe_create_vertex_elements_state;
+   llvmpipe->pipe.create_vertex_elements_state = util_create_vertex_elements_cso;
    llvmpipe->pipe.bind_vertex_elements_state = llvmpipe_bind_vertex_elements_state;
-   llvmpipe->pipe.delete_vertex_elements_state = llvmpipe_delete_vertex_elements_state;
+   llvmpipe->pipe.delete_vertex_elements_state = util_delete_vertex_elements_cso;
 
    llvmpipe->pipe.set_vertex_buffers = llvmpipe_set_vertex_buffers;
 }
diff --git a/src/gallium/drivers/llvmpipe/lp_surface.c b/src/gallium/drivers/llvmpipe/lp_surface.c
index b4e6f4da2820..0ec0eb4af876 100644
--- a/src/gallium/drivers/llvmpipe/lp_surface.c
+++ b/src/gallium/drivers/llvmpipe/lp_surface.c
@@ -155,7 +155,7 @@ static void lp_blit(struct pipe_context *pipe,
    }
 
    util_blitter_save_vertex_buffer_slot(lp->blitter, lp->vertex_buffer);
-   util_blitter_save_vertex_elements(lp->blitter, lp->velems);
+   util_blitter_save_vertex_elements(lp->blitter, &lp->velems->base);
    util_blitter_save_vertex_shader(lp->blitter, (void*)lp->vs);
    util_blitter_save_geometry_shader(lp->blitter, (void*)lp->gs);
    util_blitter_save_so_targets(lp->blitter, lp->num_so_targets,
diff --git a/src/gallium/drivers/nouveau/nvc0/nvc0_vbo.c b/src/gallium/drivers/nouveau/nvc0/nvc0_vbo.c
index 2814c1f5eca4..73bb928ecd72 100644
--- a/src/gallium/drivers/nouveau/nvc0/nvc0_vbo.c
+++ b/src/gallium/drivers/nouveau/nvc0/nvc0_vbo.c
@@ -25,6 +25,7 @@
 #include "pipe/p_context.h"
 #include "pipe/p_state.h"
 #include "util/u_draw.h"
+#include "util/u_helpers.h"
 #include "util/u_inlines.h"
 #include "util/format/u_format.h"
 #include "translate/translate.h"
@@ -54,12 +55,18 @@ nvc0_vertex_state_create(struct pipe_context *pipe,
     struct translate_key transkey;
     unsigned i;
     unsigned src_offset_max = 0;
+    const struct pipe_vertex_elements *original = elements;
+
+    /* Lower double attribs. */
+    struct pipe_vertex_elements tmp;
+    util_lower_uint64_vertex_elements(&elements, &tmp);
+    /* now elements == &tmp if there was any lowering */
 
     so = MALLOC(sizeof(*so) +
                 elements->count * sizeof(struct nvc0_vertex_element));
     if (!so)
         return NULL;
-    so->base = *elements;
+    so->base = *original; /* copy the original state */
     so->num_elements = elements->count;
     so->instance_elts = 0;
     so->instance_bufs = 0;
diff --git a/src/gallium/drivers/r600/r600_asm.c b/src/gallium/drivers/r600/r600_asm.c
index 1e77ec56970b..507ecf789bc4 100644
--- a/src/gallium/drivers/r600/r600_asm.c
+++ b/src/gallium/drivers/r600/r600_asm.c
@@ -29,6 +29,7 @@
 #include <errno.h>
 #include "util/u_bitcast.h"
 #include "util/u_dump.h"
+#include "util/u_helpers.h"
 #include "util/u_memory.h"
 #include "util/u_math.h"
 #include "pipe/p_shader_tokens.h"
@@ -2735,6 +2736,12 @@ struct pipe_vertex_elements *r600_create_vertex_fetch_shader(struct pipe_context
 	unsigned no_sb = rctx->screen->b.debug_flags & DBG_NO_SB ||
                          (rctx->screen->b.debug_flags & DBG_NIR);
 	unsigned sb_disasm = !no_sb || (rctx->screen->b.debug_flags & DBG_SB_DISASM);
+	const struct pipe_vertex_elements *original = elements;
+
+	/* Lower double attribs. */
+	struct pipe_vertex_elements tmp;
+	util_lower_uint64_vertex_elements(&elements, &tmp);
+	/* now elements == &tmp if there was any lowering */
 
 	assert(elements->count < 32);
 
@@ -2878,7 +2885,7 @@ struct pipe_vertex_elements *r600_create_vertex_fetch_shader(struct pipe_context
 
 	r600_bytecode_clear(&bc);
 
-        shader->base = *elements;
+        shader->base = *original; /* copy the original state */
 	return &shader->base;
 }
 
diff --git a/src/gallium/drivers/radeonsi/si_state.c b/src/gallium/drivers/radeonsi/si_state.c
index 7d7afcac5a9b..eda34d40834e 100644
--- a/src/gallium/drivers/radeonsi/si_state.c
+++ b/src/gallium/drivers/radeonsi/si_state.c
@@ -4887,7 +4887,13 @@ si_create_vertex_elements(struct pipe_context *ctx, const struct pipe_vertex_ele
    if (!v)
       return NULL;
 
-   v->base = *state;
+   v->base = *state; /* copy the original state */
+
+   /* Lower double attribs. */
+   struct pipe_vertex_elements tmp;
+   util_lower_uint64_vertex_elements(&state, &tmp);
+   /* now state == &tmp if there was any lowering */
+
    v->count = state->count;
 
    unsigned num_vbos_in_user_sgprs = si_num_vbos_in_user_sgprs(sscreen);
diff --git a/src/gallium/drivers/softpipe/sp_context.h b/src/gallium/drivers/softpipe/sp_context.h
index dab25c39a745..f368d328cac1 100644
--- a/src/gallium/drivers/softpipe/sp_context.h
+++ b/src/gallium/drivers/softpipe/sp_context.h
@@ -33,6 +33,7 @@
 
 #include "pipe/p_context.h"
 #include "util/u_blitter.h"
+#include "util/u_helpers.h"
 
 #include "draw/draw_vertex.h"
 
@@ -61,7 +62,7 @@ struct softpipe_context {
    struct sp_fragment_shader_variant *fs_variant;
    struct sp_vertex_shader *vs;
    struct sp_geometry_shader *gs;
-   struct pipe_vertex_elements *velems;
+   struct util_vertex_elements_cso *velems;
    struct sp_so_state *so;
    struct sp_compute_shader *cs;
 
diff --git a/src/gallium/drivers/softpipe/sp_state_vertex.c b/src/gallium/drivers/softpipe/sp_state_vertex.c
index 87046eb983f0..98559daec7f5 100644
--- a/src/gallium/drivers/softpipe/sp_state_vertex.c
+++ b/src/gallium/drivers/softpipe/sp_state_vertex.c
@@ -33,47 +33,27 @@
 #include "sp_state.h"
 
 #include "util/u_memory.h"
-#include "util/u_helpers.h"
 #include "util/u_inlines.h"
 #include "util/u_transfer.h"
 #include "draw/draw_context.h"
 
-
-static struct pipe_vertex_elements *
-softpipe_create_vertex_elements_state(struct pipe_context *pipe,
-                                      const struct pipe_vertex_elements *attribs)
-{
-   struct pipe_vertex_elements *velems;
-   assert(attribs->count <= PIPE_MAX_ATTRIBS);
-   velems = (struct pipe_vertex_elements *) MALLOC(sizeof(struct pipe_vertex_elements));
-   *velems = *attribs;
-   return velems;
-}
-
-
 static void
 softpipe_bind_vertex_elements_state(struct pipe_context *pipe,
                                     struct pipe_vertex_elements *velems)
 {
    struct softpipe_context *softpipe = softpipe_context(pipe);
+   struct util_vertex_elements_cso *state =
+      (struct util_vertex_elements_cso *)velems;
 
-   softpipe->velems = velems;
-
+   softpipe->velems = state;
    softpipe->dirty |= SP_NEW_VERTEX;
 
-   if (velems)
-      draw_set_vertex_elements(softpipe->draw, velems->count, velems->input);
+   if (state) {
+      draw_set_vertex_elements(softpipe->draw, state->lowered.count,
+                               state->lowered.input);
+   }
 }
 
-
-static void
-softpipe_delete_vertex_elements_state(struct pipe_context *pipe,
-                                      struct pipe_vertex_elements *velems)
-{
-   FREE( velems );
-}
-
-
 static void
 softpipe_set_vertex_buffers(struct pipe_context *pipe,
                             unsigned start_slot, unsigned count,
@@ -101,9 +81,9 @@ softpipe_set_vertex_buffers(struct pipe_context *pipe,
 void
 softpipe_init_vertex_funcs(struct pipe_context *pipe)
 {
-   pipe->create_vertex_elements_state = softpipe_create_vertex_elements_state;
+   pipe->create_vertex_elements_state = util_create_vertex_elements_cso;
    pipe->bind_vertex_elements_state = softpipe_bind_vertex_elements_state;
-   pipe->delete_vertex_elements_state = softpipe_delete_vertex_elements_state;
+   pipe->delete_vertex_elements_state = util_delete_vertex_elements_cso;
 
    pipe->set_vertex_buffers = softpipe_set_vertex_buffers;
 }
diff --git a/src/gallium/drivers/softpipe/sp_surface.c b/src/gallium/drivers/softpipe/sp_surface.c
index 3f48c94b6e59..99e22b518ca5 100644
--- a/src/gallium/drivers/softpipe/sp_surface.c
+++ b/src/gallium/drivers/softpipe/sp_surface.c
@@ -61,7 +61,7 @@ static void sp_blit(struct pipe_context *pipe,
    /* XXX turn off occlusion and streamout queries */
 
    util_blitter_save_vertex_buffer_slot(sp->blitter, sp->vertex_buffer);
-   util_blitter_save_vertex_elements(sp->blitter, sp->velems);
+   util_blitter_save_vertex_elements(sp->blitter, &sp->velems->base);
    util_blitter_save_vertex_shader(sp->blitter, sp->vs);
    util_blitter_save_geometry_shader(sp->blitter, sp->gs);
    util_blitter_save_so_targets(sp->blitter, sp->num_so_targets,
diff --git a/src/gallium/drivers/svga/svga_context.h b/src/gallium/drivers/svga/svga_context.h
index 3c102ea64a03..e75a29d3e05e 100644
--- a/src/gallium/drivers/svga/svga_context.h
+++ b/src/gallium/drivers/svga/svga_context.h
@@ -262,6 +262,8 @@ svga_pipe_sampler_view(struct pipe_sampler_view *v)
 
 struct svga_velems_state {
    struct pipe_vertex_elements base; /* don't change, it's used by memcmp for CSO lookups */
+   struct pipe_vertex_elements lowered;
+
    SVGA3dDeclType decl_type[PIPE_MAX_ATTRIBS]; /**< vertex attrib formats */
 
    /** Bitmasks indicating which attributes need format conversion */
diff --git a/src/gallium/drivers/svga/svga_pipe_vertex.c b/src/gallium/drivers/svga/svga_pipe_vertex.c
index bd75f67d8977..3b1c33a91932 100644
--- a/src/gallium/drivers/svga/svga_pipe_vertex.c
+++ b/src/gallium/drivers/svga/svga_pipe_vertex.c
@@ -126,11 +126,11 @@ define_input_element_object(struct svga_context *svga,
    SVGA3dInputElementDesc elements[PIPE_MAX_ATTRIBS];
    unsigned i;
 
-   assert(velems->base.count <= PIPE_MAX_ATTRIBS);
+   assert(velems->lowered.count <= PIPE_MAX_ATTRIBS);
    assert(svga_have_vgpu10(svga));
 
-   for (i = 0; i < velems->base.count; i++) {
-      const struct pipe_vertex_element *elem = velems->base.input + i;
+   for (i = 0; i < velems->lowered.count; i++) {
+      const struct pipe_vertex_element *elem = velems->lowered.input + i;
       SVGA3dSurfaceFormat svga_format;
       unsigned vf_flags;
 
@@ -189,7 +189,7 @@ define_input_element_object(struct svga_context *svga,
 
    velems->id = util_bitmask_add(svga->input_element_object_id_bm);
 
-   SVGA_RETRY(svga, SVGA3D_vgpu10_DefineElementLayout(svga->swc, velems->base.count,
+   SVGA_RETRY(svga, SVGA3D_vgpu10_DefineElementLayout(svga->swc, velems->lowered.count,
                                                       velems->id, elements));
 }
 
@@ -206,8 +206,8 @@ translate_vertex_decls(struct svga_context *svga,
 
    assert(!svga_have_vgpu10(svga));
 
-   for (i = 0; i < velems->base.count; i++) {
-      const enum pipe_format f = velems->base.input[i].src_format;
+   for (i = 0; i < velems->lowered.count; i++) {
+      const enum pipe_format f = velems->lowered.input[i].src_format;
       SVGA3dSurfaceFormat svga_format;
       unsigned vf_flags;
 
@@ -241,7 +241,14 @@ svga_create_vertex_elements_state(struct pipe_context *pipe,
    assert(attribs->count <= PIPE_MAX_ATTRIBS);
    velems = (struct svga_velems_state *) MALLOC(sizeof(struct svga_velems_state));
    if (velems) {
-      velems->base = *attribs;
+      velems->base = *attribs; /* copy the original state */
+
+      /* Lower double attribs. */
+      struct pipe_vertex_elements tmp;
+      util_lower_uint64_vertex_elements(&attribs, &tmp);
+      /* now state == &tmp if there was any lowering */
+
+      velems->lowered = *attribs;
 
       velems->need_swvfetch = FALSE;
       velems->adjust_attrib_range = 0x0;
diff --git a/src/gallium/drivers/svga/svga_state_vdecl.c b/src/gallium/drivers/svga/svga_state_vdecl.c
index 1c378a8fcabf..e4de46641c1a 100644
--- a/src/gallium/drivers/svga/svga_state_vdecl.c
+++ b/src/gallium/drivers/svga/svga_state_vdecl.c
@@ -42,13 +42,13 @@
 static enum pipe_error
 emit_hw_vs_vdecl(struct svga_context *svga, uint64_t dirty)
 {
-   const struct pipe_vertex_element *ve = svga->curr.velems->base.input;
+   const struct pipe_vertex_element *ve = svga->curr.velems->lowered.input;
    SVGA3dVertexDecl decls[SVGA3D_INPUTREG_MAX];
    unsigned buffer_indexes[SVGA3D_INPUTREG_MAX];
    unsigned i;
    unsigned neg_bias = 0;
 
-   assert(svga->curr.velems->base.count >=
+   assert(svga->curr.velems->lowered.count >=
           svga->curr.vs->base.info.num_inputs);
 
    /**
@@ -66,7 +66,7 @@ emit_hw_vs_vdecl(struct svga_context *svga, uint64_t dirty)
     * confusion.
     */
 
-   for (i = 0; i < svga->curr.velems->base.count; i++) {
+   for (i = 0; i < svga->curr.velems->lowered.count; i++) {
       const struct pipe_vertex_buffer *vb =
          &svga->curr.vb[ve[i].vertex_buffer_index];
       struct svga_buffer *buffer;
@@ -85,7 +85,7 @@ emit_hw_vs_vdecl(struct svga_context *svga, uint64_t dirty)
       }
    }
 
-   for (i = 0; i < svga->curr.velems->base.count; i++) {
+   for (i = 0; i < svga->curr.velems->lowered.count; i++) {
       const struct pipe_vertex_buffer *vb =
          &svga->curr.vb[ve[i].vertex_buffer_index];
       unsigned usage, index;
@@ -121,7 +121,7 @@ emit_hw_vs_vdecl(struct svga_context *svga, uint64_t dirty)
    }
 
    svga_hwtnl_vertex_decls(svga->hwtnl,
-                           svga->curr.velems->base.count,
+                           svga->curr.velems->lowered.count,
                            decls,
                            buffer_indexes,
                            svga->curr.velems->id);
diff --git a/src/gallium/drivers/svga/svga_swtnl_state.c b/src/gallium/drivers/svga/svga_swtnl_state.c
index 697386f1e3bf..5c87ac311018 100644
--- a/src/gallium/drivers/svga/svga_swtnl_state.c
+++ b/src/gallium/drivers/svga/svga_swtnl_state.c
@@ -119,8 +119,8 @@ update_swtnl_draw(struct svga_context *svga, uint64_t dirty)
 
    if (dirty & SVGA_NEW_VELEMENT)
       draw_set_vertex_elements(svga->swtnl.draw,
-                               svga->curr.velems->base.count,
-                               svga->curr.velems->base.input);
+                               svga->curr.velems->lowered.count,
+                               svga->curr.velems->lowered.input);
 
    if (dirty & SVGA_NEW_CLIP)
       draw_set_clip_state(svga->swtnl.draw,
diff --git a/src/gallium/drivers/virgl/virgl_context.c b/src/gallium/drivers/virgl/virgl_context.c
index 5d59c6e6b6ea..9c85551d136e 100644
--- a/src/gallium/drivers/virgl/virgl_context.c
+++ b/src/gallium/drivers/virgl/virgl_context.c
@@ -523,7 +523,12 @@ virgl_create_vertex_elements_state(struct pipe_context *ctx,
    struct virgl_vertex_elements_state *state =
       CALLOC_STRUCT(virgl_vertex_elements_state);
 
-   state->base = *elements;
+   state->base = *elements; /* copy the original state */
+
+   /* Lower double attribs. */
+   struct pipe_vertex_elements tmp;
+   util_lower_uint64_vertex_elements(&elements, &tmp);
+   /* now elements == &tmp if there was any lowering */
 
    for (int i = 0; i < elements->count; ++i) {
       if (elements->input[i].instance_divisor) {
diff --git a/src/gallium/drivers/zink/zink_state.c b/src/gallium/drivers/zink/zink_state.c
index 79abb10d1493..da1916610fe9 100644
--- a/src/gallium/drivers/zink/zink_state.c
+++ b/src/gallium/drivers/zink/zink_state.c
@@ -45,7 +45,13 @@ zink_create_vertex_elements_state(struct pipe_context *pctx,
    struct zink_vertex_elements_state *ves = CALLOC_STRUCT(zink_vertex_elements_state);
    if (!ves)
       return NULL;
-   ves->base = *elements;
+   ves->base = *elements; /* copy the original state */
+
+   /* Lower double attribs. */
+   struct pipe_vertex_elements tmp;
+   util_lower_uint64_vertex_elements(&elements, &tmp);
+   /* now elements == &tmp if there was any lowering */
+
    ves->hw_state.hash = _mesa_hash_pointer(ves);
 
    int buffer_map[PIPE_MAX_ATTRIBS];
-- 
GitLab


From afe8de83182e7dbd78c62982d9996e63d9cb89db Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Sat, 6 Aug 2022 17:28:59 -0400
Subject: [PATCH 03/15] cso: start without u_vbuf by default if it's not always
 used

no functional change, but it's convenient for future work

Reviewed-by: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
---
 src/gallium/auxiliary/cso_cache/cso_context.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/gallium/auxiliary/cso_cache/cso_context.c b/src/gallium/auxiliary/cso_cache/cso_context.c
index 5887635cb38b..e8a99e95dfb8 100644
--- a/src/gallium/auxiliary/cso_cache/cso_context.c
+++ b/src/gallium/auxiliary/cso_cache/cso_context.c
@@ -239,8 +239,8 @@ static void cso_init_vbuf(struct cso_context *cso, unsigned flags)
        (uses_user_vertex_buffers &&
         caps.fallback_only_for_user_vbuffers)) {
       cso->vbuf = u_vbuf_create(cso->pipe, &caps);
-      cso->vbuf_current = cso->vbuf;
       cso->always_use_vbuf = caps.fallback_always;
+      cso->vbuf_current = caps.fallback_always ? cso->vbuf : NULL;
    }
 }
 
-- 
GitLab


From 5d8bf4d9f3a51600b4f7eb5fc533f4a3181d0215 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Sat, 6 Aug 2022 17:28:34 -0400
Subject: [PATCH 04/15] cso: constify some parameters to remove typecasts

Reviewed-by: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
---
 src/gallium/auxiliary/cso_cache/cso_cache.c   |  2 +-
 src/gallium/auxiliary/cso_cache/cso_cache.h   |  7 ++++---
 src/gallium/auxiliary/cso_cache/cso_context.c | 20 +++++++++----------
 src/gallium/auxiliary/util/u_vbuf.c           |  4 ++--
 4 files changed, 17 insertions(+), 16 deletions(-)

diff --git a/src/gallium/auxiliary/cso_cache/cso_cache.c b/src/gallium/auxiliary/cso_cache/cso_cache.c
index ea9d5c54bca9..ad557eefdb6a 100644
--- a/src/gallium/auxiliary/cso_cache/cso_cache.c
+++ b/src/gallium/auxiliary/cso_cache/cso_cache.c
@@ -144,7 +144,7 @@ void *cso_hash_find_data_from_template( struct cso_hash *hash,
 
 struct cso_hash_iter cso_find_state_template(struct cso_cache *sc,
                                              unsigned hash_key, enum cso_cache_type type,
-                                             void *templ, unsigned size)
+                                             const void *templ, unsigned size)
 {
    struct cso_hash_iter iter = cso_find_state(sc, hash_key, type);
    while (!cso_hash_iter_is_null(iter)) {
diff --git a/src/gallium/auxiliary/cso_cache/cso_cache.h b/src/gallium/auxiliary/cso_cache/cso_cache.h
index 14d19a670e61..9fad21426eae 100644
--- a/src/gallium/auxiliary/cso_cache/cso_cache.h
+++ b/src/gallium/auxiliary/cso_cache/cso_cache.h
@@ -158,15 +158,16 @@ struct cso_hash_iter cso_find_state(struct cso_cache *sc,
                                     unsigned hash_key, enum cso_cache_type type);
 struct cso_hash_iter cso_find_state_template(struct cso_cache *sc,
                                              unsigned hash_key, enum cso_cache_type type,
-                                             void *templ, unsigned size);
+                                             const void *templ, unsigned size);
 void cso_set_maximum_cache_size(struct cso_cache *sc, int number);
 void cso_delete_state(struct pipe_context *pipe, void *state,
                       enum cso_cache_type type);
 
 static inline unsigned
-cso_construct_key(void *key, int key_size)
+cso_construct_key(const void *key, int key_size)
 {
-   unsigned hash = 0, *ikey = (unsigned *)key;
+   unsigned hash = 0;
+   const unsigned *ikey = (const unsigned *)key;
    unsigned num_elements = key_size / 4;
 
    assert(key_size % 4 == 0);
diff --git a/src/gallium/auxiliary/cso_cache/cso_context.c b/src/gallium/auxiliary/cso_cache/cso_context.c
index e8a99e95dfb8..90293a3a8f79 100644
--- a/src/gallium/auxiliary/cso_cache/cso_context.c
+++ b/src/gallium/auxiliary/cso_cache/cso_context.c
@@ -445,9 +445,9 @@ enum pipe_error cso_set_blend(struct cso_context *ctx,
    key_size = templ->independent_blend_enable ?
       sizeof(struct pipe_blend_state) :
       (char *)&(templ->rt[1]) - (char *)templ;
-   hash_key = cso_construct_key((void*)templ, key_size);
+   hash_key = cso_construct_key(templ, key_size);
    iter = cso_find_state_template(&ctx->cache, hash_key, CSO_BLEND,
-                                  (void*)templ, key_size);
+                                  templ, key_size);
 
    if (cso_hash_iter_is_null(iter)) {
       struct cso_blend *cso = MALLOC(sizeof(struct cso_blend));
@@ -501,11 +501,11 @@ cso_set_depth_stencil_alpha(struct cso_context *ctx,
                             const struct pipe_depth_stencil_alpha_state *templ)
 {
    unsigned key_size = sizeof(struct pipe_depth_stencil_alpha_state);
-   unsigned hash_key = cso_construct_key((void*)templ, key_size);
+   unsigned hash_key = cso_construct_key(templ, key_size);
    struct cso_hash_iter iter = cso_find_state_template(&ctx->cache,
                                                        hash_key,
                                                        CSO_DEPTH_STENCIL_ALPHA,
-                                                       (void*)templ, key_size);
+                                                       templ, key_size);
    void *handle;
 
    if (cso_hash_iter_is_null(iter)) {
@@ -563,11 +563,11 @@ enum pipe_error cso_set_rasterizer(struct cso_context *ctx,
                                    const struct pipe_rasterizer_state *templ)
 {
    unsigned key_size = sizeof(struct pipe_rasterizer_state);
-   unsigned hash_key = cso_construct_key((void*)templ, key_size);
+   unsigned hash_key = cso_construct_key(templ, key_size);
    struct cso_hash_iter iter = cso_find_state_template(&ctx->cache,
                                                        hash_key,
                                                        CSO_RASTERIZER,
-                                                       (void*)templ, key_size);
+                                                       templ, key_size);
    void *handle = NULL;
 
    /* We can't have both point_quad_rasterization (sprites) and point_smooth
@@ -1040,9 +1040,9 @@ cso_set_vertex_elements_direct(struct cso_context *ctx,
     */
    key_size = sizeof(struct pipe_vertex_element) * velems->count +
               sizeof(unsigned);
-   hash_key = cso_construct_key((void*)velems, key_size);
+   hash_key = cso_construct_key(velems, key_size);
    iter = cso_find_state_template(&ctx->cache, hash_key, CSO_VELEMENTS,
-                                  (void*)velems, key_size);
+                                  velems, key_size);
 
    if (cso_hash_iter_is_null(iter)) {
       struct cso_velements *cso = MALLOC(sizeof(struct cso_velements));
@@ -1210,12 +1210,12 @@ ALWAYS_INLINE static struct cso_sampler *
 set_sampler(struct cso_context *ctx, enum pipe_shader_type shader_stage,
             unsigned idx, const struct pipe_sampler_state *templ, size_t key_size)
 {
-   unsigned hash_key = cso_construct_key((void*)templ, key_size);
+   unsigned hash_key = cso_construct_key(templ, key_size);
    struct cso_sampler *cso;
    struct cso_hash_iter iter =
       cso_find_state_template(&ctx->cache,
                               hash_key, CSO_SAMPLER,
-                              (void *) templ, key_size);
+                              templ, key_size);
 
    if (cso_hash_iter_is_null(iter)) {
       cso = MALLOC(sizeof(struct cso_sampler));
diff --git a/src/gallium/auxiliary/util/u_vbuf.c b/src/gallium/auxiliary/util/u_vbuf.c
index 06029609cea3..a9507a0e4cde 100644
--- a/src/gallium/auxiliary/util/u_vbuf.c
+++ b/src/gallium/auxiliary/util/u_vbuf.c
@@ -393,9 +393,9 @@ u_vbuf_set_vertex_elements_internal(struct u_vbuf *mgr,
    /* need to include the count into the stored state data too. */
    key_size = sizeof(struct pipe_vertex_element) * velems->count +
               sizeof(unsigned);
-   hash_key = cso_construct_key((void*)velems, key_size);
+   hash_key = cso_construct_key(velems, key_size);
    iter = cso_find_state_template(&mgr->cso_cache, hash_key, CSO_VELEMENTS,
-                                  (void*)velems, key_size);
+                                  velems, key_size);
 
    if (cso_hash_iter_is_null(iter)) {
       struct cso_velements *cso = MALLOC_STRUCT(cso_velements);
-- 
GitLab


From 09cf366179f7fb88390841904b3300f1f0db6964 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Sat, 6 Aug 2022 17:30:02 -0400
Subject: [PATCH 05/15] cso: don't destroy CSOs that are saved

I think this can't happen in practice, but better safe than sorry.
---
 src/gallium/auxiliary/cso_cache/cso_context.c | 26 +++++++++++++++----
 1 file changed, 21 insertions(+), 5 deletions(-)

diff --git a/src/gallium/auxiliary/cso_cache/cso_context.c b/src/gallium/auxiliary/cso_cache/cso_context.c
index 90293a3a8f79..12e271144669 100644
--- a/src/gallium/auxiliary/cso_cache/cso_context.c
+++ b/src/gallium/auxiliary/cso_cache/cso_context.c
@@ -133,19 +133,23 @@ static inline boolean delete_cso(struct cso_context *ctx,
 {
    switch (type) {
    case CSO_BLEND:
-      if (ctx->blend == ((struct cso_blend*)state)->data)
+      if (ctx->blend == ((struct cso_blend*)state)->data ||
+          ctx->blend_saved == ((struct cso_blend*)state)->data)
          return false;
       break;
    case CSO_DEPTH_STENCIL_ALPHA:
-      if (ctx->depth_stencil == ((struct cso_depth_stencil_alpha*)state)->data)
+      if (ctx->depth_stencil == ((struct cso_depth_stencil_alpha*)state)->data ||
+          ctx->depth_stencil_saved == ((struct cso_depth_stencil_alpha*)state)->data)
          return false;
       break;
    case CSO_RASTERIZER:
-      if (ctx->rasterizer == ((struct cso_rasterizer*)state)->data)
+      if (ctx->rasterizer == ((struct cso_rasterizer*)state)->data ||
+          ctx->rasterizer_saved == ((struct cso_rasterizer*)state)->data)
          return false;
       break;
    case CSO_VELEMENTS:
-      if (ctx->velements == ((struct cso_velements*)state)->data)
+      if (ctx->velements == ((struct cso_velements*)state)->data ||
+          ctx->velements_saved == ((struct cso_velements*)state)->data)
          return false;
       break;
    case CSO_SAMPLER:
@@ -182,7 +186,7 @@ sanitize_hash(struct cso_hash *hash, enum cso_cache_type type,
    if (type == CSO_SAMPLER) {
       int i, j;
 
-      samplers_to_restore = MALLOC(PIPE_SHADER_TYPES * PIPE_MAX_SAMPLERS *
+      samplers_to_restore = MALLOC((PIPE_SHADER_TYPES + 2) * PIPE_MAX_SAMPLERS *
                                    sizeof(*samplers_to_restore));
 
       /* Temporarily remove currently bound sampler states from the hash
@@ -196,6 +200,18 @@ sanitize_hash(struct cso_hash *hash, enum cso_cache_type type,
                samplers_to_restore[to_restore++] = sampler;
          }
       }
+      for (j = 0; j < PIPE_MAX_SAMPLERS; j++) {
+         struct cso_sampler *sampler = ctx->fragment_samplers_saved.cso_samplers[j];
+
+         if (sampler && cso_hash_take(hash, sampler->hash_key))
+            samplers_to_restore[to_restore++] = sampler;
+      }
+      for (j = 0; j < PIPE_MAX_SAMPLERS; j++) {
+         struct cso_sampler *sampler = ctx->compute_samplers_saved.cso_samplers[j];
+
+         if (sampler && cso_hash_take(hash, sampler->hash_key))
+            samplers_to_restore[to_restore++] = sampler;
+      }
    }
 
    iter = cso_hash_first_node(hash);
-- 
GitLab


From c9aefc91c85a23f0d0ea4fdab9e5f60ac4055bbf Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Sun, 7 Aug 2022 19:29:37 -0400
Subject: [PATCH 06/15] cso: inline cso_find_state_template because we want
 key_size to be a literal

---
 src/gallium/auxiliary/cso_cache/cso_cache.c | 15 ---------------
 src/gallium/auxiliary/cso_cache/cso_cache.h | 18 +++++++++++++++---
 2 files changed, 15 insertions(+), 18 deletions(-)

diff --git a/src/gallium/auxiliary/cso_cache/cso_cache.c b/src/gallium/auxiliary/cso_cache/cso_cache.c
index ad557eefdb6a..6c07eda30d7d 100644
--- a/src/gallium/auxiliary/cso_cache/cso_cache.c
+++ b/src/gallium/auxiliary/cso_cache/cso_cache.c
@@ -141,21 +141,6 @@ void *cso_hash_find_data_from_template( struct cso_hash *hash,
    return NULL;
 }
 
-
-struct cso_hash_iter cso_find_state_template(struct cso_cache *sc,
-                                             unsigned hash_key, enum cso_cache_type type,
-                                             const void *templ, unsigned size)
-{
-   struct cso_hash_iter iter = cso_find_state(sc, hash_key, type);
-   while (!cso_hash_iter_is_null(iter)) {
-      void *iter_data = cso_hash_iter_data(iter);
-      if (!memcmp(iter_data, templ, size))
-         return iter;
-      iter = cso_hash_iter_next(iter);
-   }
-   return iter;
-}
-
 void cso_cache_init(struct cso_cache *sc, struct pipe_context *pipe)
 {
    memset(sc, 0, sizeof(*sc));
diff --git a/src/gallium/auxiliary/cso_cache/cso_cache.h b/src/gallium/auxiliary/cso_cache/cso_cache.h
index 9fad21426eae..ca00f1270796 100644
--- a/src/gallium/auxiliary/cso_cache/cso_cache.h
+++ b/src/gallium/auxiliary/cso_cache/cso_cache.h
@@ -156,9 +156,6 @@ struct cso_hash_iter cso_insert_state(struct cso_cache *sc,
                                       void *state);
 struct cso_hash_iter cso_find_state(struct cso_cache *sc,
                                     unsigned hash_key, enum cso_cache_type type);
-struct cso_hash_iter cso_find_state_template(struct cso_cache *sc,
-                                             unsigned hash_key, enum cso_cache_type type,
-                                             const void *templ, unsigned size);
 void cso_set_maximum_cache_size(struct cso_cache *sc, int number);
 void cso_delete_state(struct pipe_context *pipe, void *state,
                       enum cso_cache_type type);
@@ -178,6 +175,21 @@ cso_construct_key(const void *key, int key_size)
    return hash;
 }
 
+static inline struct cso_hash_iter
+cso_find_state_template(struct cso_cache *sc, unsigned hash_key,
+                        enum cso_cache_type type, const void *key,
+                        unsigned key_size)
+{
+   struct cso_hash_iter iter = cso_find_state(sc, hash_key, type);
+   while (!cso_hash_iter_is_null(iter)) {
+      void *iter_data = cso_hash_iter_data(iter);
+      if (!memcmp(iter_data, key, key_size))
+         return iter;
+      iter = cso_hash_iter_next(iter);
+   }
+   return iter;
+}
+
 #ifdef __cplusplus
 }
 #endif
-- 
GitLab


From 6072041d9f457b6ad3ec7591f1d22b719f6b0cc9 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Sun, 7 Aug 2022 20:04:44 -0400
Subject: [PATCH 07/15] cso: add ALWAYS_INLINE qualifiers where inlining is
 required for unrolling

and also for inlining and unrolling memcmp
---
 src/gallium/auxiliary/cso_cache/cso_cache.h | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/src/gallium/auxiliary/cso_cache/cso_cache.h b/src/gallium/auxiliary/cso_cache/cso_cache.h
index ca00f1270796..9c483f8e911a 100644
--- a/src/gallium/auxiliary/cso_cache/cso_cache.h
+++ b/src/gallium/auxiliary/cso_cache/cso_cache.h
@@ -160,7 +160,7 @@ void cso_set_maximum_cache_size(struct cso_cache *sc, int number);
 void cso_delete_state(struct pipe_context *pipe, void *state,
                       enum cso_cache_type type);
 
-static inline unsigned
+static ALWAYS_INLINE unsigned
 cso_construct_key(const void *key, int key_size)
 {
    unsigned hash = 0;
@@ -175,7 +175,7 @@ cso_construct_key(const void *key, int key_size)
    return hash;
 }
 
-static inline struct cso_hash_iter
+static ALWAYS_INLINE struct cso_hash_iter
 cso_find_state_template(struct cso_cache *sc, unsigned hash_key,
                         enum cso_cache_type type, const void *key,
                         unsigned key_size)
-- 
GitLab


From b0e2da14ec34f88722575eb84e9ec51fbfc5d7d4 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Sun, 7 Aug 2022 19:41:16 -0400
Subject: [PATCH 08/15] cso: make memcmp and hash computation use a literal key
 size for blend state

This results in faster lookups because memcmp and the hash computation
can be unrolled. We also get separate caches for fewer collisions.
---
 src/gallium/auxiliary/cso_cache/cso_cache.c   |  6 ++--
 src/gallium/auxiliary/cso_cache/cso_cache.h   |  3 +-
 src/gallium/auxiliary/cso_cache/cso_context.c | 32 ++++++++++++++-----
 3 files changed, 30 insertions(+), 11 deletions(-)

diff --git a/src/gallium/auxiliary/cso_cache/cso_cache.c b/src/gallium/auxiliary/cso_cache/cso_cache.c
index 6c07eda30d7d..d224f6ac06d4 100644
--- a/src/gallium/auxiliary/cso_cache/cso_cache.c
+++ b/src/gallium/auxiliary/cso_cache/cso_cache.c
@@ -46,7 +46,8 @@ void cso_delete_state(struct pipe_context *pipe, void *state,
                       enum cso_cache_type type)
 {
    switch (type) {
-   case CSO_BLEND:
+   case CSO_BLEND_RT0:
+   case CSO_BLEND_ALL_RT:
       pipe->delete_blend_state(pipe, ((struct cso_blend*)state)->data);
       break;
    case CSO_SAMPLER:
@@ -175,7 +176,8 @@ void cso_cache_delete(struct cso_cache *sc)
    int i;
 
    /* delete driver data */
-   cso_delete_all(sc, CSO_BLEND);
+   cso_delete_all(sc, CSO_BLEND_RT0);
+   cso_delete_all(sc, CSO_BLEND_ALL_RT);
    cso_delete_all(sc, CSO_DEPTH_STENCIL_ALPHA);
    cso_delete_all(sc, CSO_RASTERIZER);
    cso_delete_all(sc, CSO_SAMPLER);
diff --git a/src/gallium/auxiliary/cso_cache/cso_cache.h b/src/gallium/auxiliary/cso_cache/cso_cache.h
index 9c483f8e911a..89aa7ea7d258 100644
--- a/src/gallium/auxiliary/cso_cache/cso_cache.h
+++ b/src/gallium/auxiliary/cso_cache/cso_cache.h
@@ -87,7 +87,8 @@ extern "C" {
 
 enum cso_cache_type {
    CSO_RASTERIZER,
-   CSO_BLEND,
+   CSO_BLEND_RT0,
+   CSO_BLEND_ALL_RT,
    CSO_DEPTH_STENCIL_ALPHA,
    CSO_SAMPLER,
    CSO_VELEMENTS,
diff --git a/src/gallium/auxiliary/cso_cache/cso_context.c b/src/gallium/auxiliary/cso_cache/cso_context.c
index 12e271144669..52de7f966213 100644
--- a/src/gallium/auxiliary/cso_cache/cso_context.c
+++ b/src/gallium/auxiliary/cso_cache/cso_context.c
@@ -132,7 +132,8 @@ static inline boolean delete_cso(struct cso_context *ctx,
                                  void *state, enum cso_cache_type type)
 {
    switch (type) {
-   case CSO_BLEND:
+   case CSO_BLEND_RT0:
+   case CSO_BLEND_ALL_RT:
       if (ctx->blend == ((struct cso_blend*)state)->data ||
           ctx->blend_saved == ((struct cso_blend*)state)->data)
          return false;
@@ -446,6 +447,9 @@ void cso_destroy_context( struct cso_context *ctx )
  * template, insert it in the cache and return it.
  */
 
+#define CSO_BLEND_KEY_SIZE_RT0      offsetof(struct pipe_blend_state, rt[1])
+#define CSO_BLEND_KEY_SIZE_ALL_RT   sizeof(struct pipe_blend_state)
+
 /*
  * If the driver returns 0 from the create method then they will assign
  * the data member of the cso to be the template itself.
@@ -455,15 +459,27 @@ enum pipe_error cso_set_blend(struct cso_context *ctx,
                               const struct pipe_blend_state *templ)
 {
    unsigned key_size, hash_key;
+   enum cso_cache_type type;
    struct cso_hash_iter iter;
    void *handle;
 
-   key_size = templ->independent_blend_enable ?
-      sizeof(struct pipe_blend_state) :
-      (char *)&(templ->rt[1]) - (char *)templ;
-   hash_key = cso_construct_key(templ, key_size);
-   iter = cso_find_state_template(&ctx->cache, hash_key, CSO_BLEND,
-                                  templ, key_size);
+   if (templ->independent_blend_enable) {
+      /* This is duplicated with the else block below because we want key_size
+       * to be a literal constant, so that memcpy and the hash computation can
+       * be inlined and unrolled.
+       */
+      hash_key = cso_construct_key(templ, CSO_BLEND_KEY_SIZE_ALL_RT);
+      iter = cso_find_state_template(&ctx->cache, hash_key, CSO_BLEND_ALL_RT,
+                                     templ, CSO_BLEND_KEY_SIZE_ALL_RT);
+      type = CSO_BLEND_ALL_RT;
+      key_size = CSO_BLEND_KEY_SIZE_ALL_RT;
+   } else {
+      hash_key = cso_construct_key(templ, CSO_BLEND_KEY_SIZE_RT0);
+      iter = cso_find_state_template(&ctx->cache, hash_key, CSO_BLEND_RT0,
+                                     templ, CSO_BLEND_KEY_SIZE_RT0);
+      type = CSO_BLEND_RT0;
+      key_size = CSO_BLEND_KEY_SIZE_RT0;
+   }
 
    if (cso_hash_iter_is_null(iter)) {
       struct cso_blend *cso = MALLOC(sizeof(struct cso_blend));
@@ -474,7 +490,7 @@ enum pipe_error cso_set_blend(struct cso_context *ctx,
       memcpy(&cso->state, templ, key_size);
       cso->data = ctx->pipe->create_blend_state(ctx->pipe, &cso->state);
 
-      iter = cso_insert_state(&ctx->cache, hash_key, CSO_BLEND, cso);
+      iter = cso_insert_state(&ctx->cache, hash_key, type, cso);
       if (cso_hash_iter_is_null(iter)) {
          FREE(cso);
          return PIPE_ERROR_OUT_OF_MEMORY;
-- 
GitLab


From e721e388d7cc78cdfa947ccf84470df17bbe19aa Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Sun, 7 Aug 2022 19:59:48 -0400
Subject: [PATCH 09/15] cso: fix broken optimization for sampler state lookups

Since the key size wasn't a constant expression, all the function inlining
didn't do much. This makes it a constant expression.

Reviewed-by: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
Cc: stable
---
 src/gallium/auxiliary/cso_cache/cso_context.c | 27 ++++++++++++++-----
 1 file changed, 20 insertions(+), 7 deletions(-)

diff --git a/src/gallium/auxiliary/cso_cache/cso_context.c b/src/gallium/auxiliary/cso_cache/cso_context.c
index 52de7f966213..831f3bae9b72 100644
--- a/src/gallium/auxiliary/cso_cache/cso_context.c
+++ b/src/gallium/auxiliary/cso_cache/cso_context.c
@@ -1283,10 +1283,19 @@ void
 cso_single_sampler(struct cso_context *ctx, enum pipe_shader_type shader_stage,
                    unsigned idx, const struct pipe_sampler_state *templ)
 {
-   size_t size = ctx->sampler_format ? sizeof(struct pipe_sampler_state) :
-                                       offsetof(struct pipe_sampler_state, border_color_format);
-   if (cso_set_sampler(ctx, shader_stage, idx, templ, size))
-      ctx->max_sampler_seen = MAX2(ctx->max_sampler_seen, (int)idx);
+   /* The reasons both blocks are duplicated is that we want the size parameter
+    * to be a constant expression to inline and unroll memcmp and has key
+    * computations.
+    */
+   if (ctx->sampler_format) {
+      if (cso_set_sampler(ctx, shader_stage, idx, templ,
+                          sizeof(struct pipe_sampler_state)))
+         ctx->max_sampler_seen = MAX2(ctx->max_sampler_seen, (int)idx);
+   } else {
+      if (cso_set_sampler(ctx, shader_stage, idx, templ,
+                          offsetof(struct pipe_sampler_state, border_color_format)))
+         ctx->max_sampler_seen = MAX2(ctx->max_sampler_seen, (int)idx);
+   }
 }
 
 /**
@@ -1363,9 +1372,13 @@ cso_set_samplers(struct cso_context *ctx,
    int last = -1;
 
    /* ensure sampler size is a constant for memcmp */
-   size_t size = ctx->sampler_format ? sizeof(struct pipe_sampler_state) :
-                                       offsetof(struct pipe_sampler_state, border_color_format);
-   last = set_samplers(ctx, shader_stage, nr, templates, size);
+   if (ctx->sampler_format) {
+      last = set_samplers(ctx, shader_stage, nr, templates,
+                          sizeof(struct pipe_sampler_state));
+   } else {
+      last = set_samplers(ctx, shader_stage, nr, templates,
+                          offsetof(struct pipe_sampler_state, border_color_format));
+   }
 
    ctx->max_sampler_seen = MAX2(ctx->max_sampler_seen, last);
    cso_single_sampler_done(ctx, shader_stage);
-- 
GitLab


From 37d34832b220b96a4464d8b4697717d87b9d5147 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Sun, 7 Aug 2022 18:35:04 -0400
Subject: [PATCH 10/15] cso: remove cso_velements because the CSO now contains
 the original state

This is a simplification which removes the extra malloc and pointer
indirection.
---
 src/gallium/auxiliary/cso_cache/cso_cache.c   |  8 +++++---
 src/gallium/auxiliary/cso_cache/cso_cache.h   |  5 -----
 src/gallium/auxiliary/cso_cache/cso_context.c | 19 +++++--------------
 src/gallium/auxiliary/util/u_vbuf.c           | 13 ++++---------
 4 files changed, 14 insertions(+), 31 deletions(-)

diff --git a/src/gallium/auxiliary/cso_cache/cso_cache.c b/src/gallium/auxiliary/cso_cache/cso_cache.c
index d224f6ac06d4..c4ede741224f 100644
--- a/src/gallium/auxiliary/cso_cache/cso_cache.c
+++ b/src/gallium/auxiliary/cso_cache/cso_cache.c
@@ -49,25 +49,27 @@ void cso_delete_state(struct pipe_context *pipe, void *state,
    case CSO_BLEND_RT0:
    case CSO_BLEND_ALL_RT:
       pipe->delete_blend_state(pipe, ((struct cso_blend*)state)->data);
+      FREE(state);
       break;
    case CSO_SAMPLER:
       pipe->delete_sampler_state(pipe, ((struct cso_sampler*)state)->data);
+      FREE(state);
       break;
    case CSO_DEPTH_STENCIL_ALPHA:
       pipe->delete_depth_stencil_alpha_state(pipe,
                            ((struct cso_depth_stencil_alpha*)state)->data);
+      FREE(state);
       break;
    case CSO_RASTERIZER:
       pipe->delete_rasterizer_state(pipe, ((struct cso_rasterizer*)state)->data);
+      FREE(state);
       break;
    case CSO_VELEMENTS:
-      pipe->delete_vertex_elements_state(pipe, ((struct cso_velements*)state)->data);
+      pipe->delete_vertex_elements_state(pipe, state);
       break;
    default:
       assert(0);
    }
-
-   FREE(state);
 }
 
 
diff --git a/src/gallium/auxiliary/cso_cache/cso_cache.h b/src/gallium/auxiliary/cso_cache/cso_cache.h
index 89aa7ea7d258..2017b7541174 100644
--- a/src/gallium/auxiliary/cso_cache/cso_cache.h
+++ b/src/gallium/auxiliary/cso_cache/cso_cache.h
@@ -137,11 +137,6 @@ struct cso_sampler {
    unsigned hash_key;
 };
 
-struct cso_velements {
-   struct pipe_vertex_elements state;
-   struct pipe_vertex_elements *data;
-};
-
 void cso_cache_init(struct cso_cache *sc, struct pipe_context *pipe);
 void cso_cache_delete(struct cso_cache *sc);
 
diff --git a/src/gallium/auxiliary/cso_cache/cso_context.c b/src/gallium/auxiliary/cso_cache/cso_context.c
index 831f3bae9b72..ed48ab7780cf 100644
--- a/src/gallium/auxiliary/cso_cache/cso_context.c
+++ b/src/gallium/auxiliary/cso_cache/cso_context.c
@@ -149,8 +149,7 @@ static inline boolean delete_cso(struct cso_context *ctx,
          return false;
       break;
    case CSO_VELEMENTS:
-      if (ctx->velements == ((struct cso_velements*)state)->data ||
-          ctx->velements_saved == ((struct cso_velements*)state)->data)
+      if (ctx->velements == state || ctx->velements_saved == state)
          return false;
       break;
    case CSO_SAMPLER:
@@ -1077,24 +1076,16 @@ cso_set_vertex_elements_direct(struct cso_context *ctx,
                                   velems, key_size);
 
    if (cso_hash_iter_is_null(iter)) {
-      struct cso_velements *cso = MALLOC(sizeof(struct cso_velements));
-      if (!cso)
-         return;
-
-      memcpy(&cso->state, velems, key_size);
-
-      cso->data = ctx->pipe->create_vertex_elements_state(ctx->pipe, velems);
+      handle = ctx->pipe->create_vertex_elements_state(ctx->pipe, velems);
 
-      iter = cso_insert_state(&ctx->cache, hash_key, CSO_VELEMENTS, cso);
+      iter = cso_insert_state(&ctx->cache, hash_key, CSO_VELEMENTS, handle);
       if (cso_hash_iter_is_null(iter)) {
-         FREE(cso);
+         ctx->pipe->delete_vertex_elements_state(ctx->pipe, handle);
          return;
       }
-
-      handle = cso->data;
    }
    else {
-      handle = ((struct cso_velements *)cso_hash_iter_data(iter))->data;
+      handle = (struct pipe_vertex_elements*)cso_hash_iter_data(iter);
    }
 
    if (ctx->velements != handle) {
diff --git a/src/gallium/auxiliary/util/u_vbuf.c b/src/gallium/auxiliary/util/u_vbuf.c
index a9507a0e4cde..68f7c166f0cb 100644
--- a/src/gallium/auxiliary/util/u_vbuf.c
+++ b/src/gallium/auxiliary/util/u_vbuf.c
@@ -398,14 +398,11 @@ u_vbuf_set_vertex_elements_internal(struct u_vbuf *mgr,
                                   velems, key_size);
 
    if (cso_hash_iter_is_null(iter)) {
-      struct cso_velements *cso = MALLOC_STRUCT(cso_velements);
-      memcpy(&cso->state, velems, key_size);
-      cso->data = &u_vbuf_create_vertex_elements(mgr, velems)->base;
+      ve = u_vbuf_create_vertex_elements(mgr, velems);
 
-      iter = cso_insert_state(&mgr->cso_cache, hash_key, CSO_VELEMENTS, cso);
-      ve = (struct u_vbuf_elements *)cso->data;
+      iter = cso_insert_state(&mgr->cso_cache, hash_key, CSO_VELEMENTS, ve);
    } else {
-      ve = (struct u_vbuf_elements *)((struct cso_velements *)cso_hash_iter_data(iter))->data;
+      ve = (struct u_vbuf_elements *)cso_hash_iter_data(iter);
    }
 
    assert(ve);
@@ -963,13 +960,11 @@ static void u_vbuf_delete_vertex_elements(void *ctx, void *state,
                                           enum cso_cache_type type)
 {
    struct pipe_context *pipe = (struct pipe_context*)ctx;
-   struct cso_velements *cso = (struct cso_velements*)state;
-   struct u_vbuf_elements *ve = (struct u_vbuf_elements*)cso->data;
+   struct u_vbuf_elements *ve = (struct u_vbuf_elements*)state;
 
    if (ve->driver_cso)
       pipe->delete_vertex_elements_state(pipe, ve->driver_cso);
    FREE(ve);
-   FREE(cso);
 }
 
 void u_vbuf_set_vertex_buffers(struct u_vbuf *mgr,
-- 
GitLab


From 8e246d828c6490fef3ad659b5697fc57a2d44222 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Sun, 7 Aug 2022 19:13:49 -0400
Subject: [PATCH 11/15] cso: split vertex element cache into 33 caches, each
 storing a different count

Each pipe_vertex_elements::count (0..32) gets its own cache. This has
the following advantages:
- faster lookups due to fewer collisions
- possibility to make the hash key computation faster by turning count
  into an inline constant and not caching the count
---
 src/gallium/auxiliary/cso_cache/cso_cache.c   | 13 ++++---------
 src/gallium/auxiliary/cso_cache/cso_cache.h   |  3 ++-
 src/gallium/auxiliary/cso_cache/cso_context.c | 18 ++++++++++--------
 src/gallium/auxiliary/util/u_vbuf.c           |  7 +++++--
 4 files changed, 21 insertions(+), 20 deletions(-)

diff --git a/src/gallium/auxiliary/cso_cache/cso_cache.c b/src/gallium/auxiliary/cso_cache/cso_cache.c
index c4ede741224f..33294511cb17 100644
--- a/src/gallium/auxiliary/cso_cache/cso_cache.c
+++ b/src/gallium/auxiliary/cso_cache/cso_cache.c
@@ -64,11 +64,10 @@ void cso_delete_state(struct pipe_context *pipe, void *state,
       pipe->delete_rasterizer_state(pipe, ((struct cso_rasterizer*)state)->data);
       FREE(state);
       break;
-   case CSO_VELEMENTS:
+   default:
+      assert(type >= CSO_VELEMENTS0 && type <= CSO_VELEMENTS32);
       pipe->delete_vertex_elements_state(pipe, state);
       break;
-   default:
-      assert(0);
    }
 }
 
@@ -178,12 +177,8 @@ void cso_cache_delete(struct cso_cache *sc)
    int i;
 
    /* delete driver data */
-   cso_delete_all(sc, CSO_BLEND_RT0);
-   cso_delete_all(sc, CSO_BLEND_ALL_RT);
-   cso_delete_all(sc, CSO_DEPTH_STENCIL_ALPHA);
-   cso_delete_all(sc, CSO_RASTERIZER);
-   cso_delete_all(sc, CSO_SAMPLER);
-   cso_delete_all(sc, CSO_VELEMENTS);
+   for (i = 0; i < CSO_CACHE_MAX; i++)
+      cso_delete_all(sc, i);
 
    for (i = 0; i < CSO_CACHE_MAX; i++)
       cso_hash_deinit(&sc->hashes[i]);
diff --git a/src/gallium/auxiliary/cso_cache/cso_cache.h b/src/gallium/auxiliary/cso_cache/cso_cache.h
index 2017b7541174..91906f4c0f3f 100644
--- a/src/gallium/auxiliary/cso_cache/cso_cache.h
+++ b/src/gallium/auxiliary/cso_cache/cso_cache.h
@@ -91,7 +91,8 @@ enum cso_cache_type {
    CSO_BLEND_ALL_RT,
    CSO_DEPTH_STENCIL_ALPHA,
    CSO_SAMPLER,
-   CSO_VELEMENTS,
+   CSO_VELEMENTS0,
+   CSO_VELEMENTS32 = CSO_VELEMENTS0 + 32,
    CSO_CACHE_MAX,
 };
 
diff --git a/src/gallium/auxiliary/cso_cache/cso_context.c b/src/gallium/auxiliary/cso_cache/cso_context.c
index ed48ab7780cf..9e7e3a62c36c 100644
--- a/src/gallium/auxiliary/cso_cache/cso_context.c
+++ b/src/gallium/auxiliary/cso_cache/cso_context.c
@@ -148,15 +148,14 @@ static inline boolean delete_cso(struct cso_context *ctx,
           ctx->rasterizer_saved == ((struct cso_rasterizer*)state)->data)
          return false;
       break;
-   case CSO_VELEMENTS:
-      if (ctx->velements == state || ctx->velements_saved == state)
-         return false;
-      break;
    case CSO_SAMPLER:
       /* nothing to do for samplers */
       break;
    default:
-      assert(0);
+      assert(type >= CSO_VELEMENTS0 && type <= CSO_VELEMENTS32);
+      if (ctx->velements == state || ctx->velements_saved == state)
+         return false;
+      break;
    }
 
    cso_delete_state(ctx->pipe, state, type);
@@ -1064,6 +1063,9 @@ cso_set_vertex_elements_direct(struct cso_context *ctx,
    struct cso_hash_iter iter;
    struct pipe_vertex_elements *handle;
 
+   enum cso_cache_type type = CSO_VELEMENTS0 + velems->count;
+   assert(type <= CSO_VELEMENTS32);
+
    /* Need to include the count into the stored state data too.
     * Otherwise first few count pipe_vertex_elements could be identical
     * even if count is different, and there's no guarantee the hash would
@@ -1072,13 +1074,13 @@ cso_set_vertex_elements_direct(struct cso_context *ctx,
    key_size = sizeof(struct pipe_vertex_element) * velems->count +
               sizeof(unsigned);
    hash_key = cso_construct_key(velems, key_size);
-   iter = cso_find_state_template(&ctx->cache, hash_key, CSO_VELEMENTS,
-                                  velems, key_size);
+   iter = cso_find_state_template(&ctx->cache, hash_key, type, velems,
+                                  key_size);
 
    if (cso_hash_iter_is_null(iter)) {
       handle = ctx->pipe->create_vertex_elements_state(ctx->pipe, velems);
 
-      iter = cso_insert_state(&ctx->cache, hash_key, CSO_VELEMENTS, handle);
+      iter = cso_insert_state(&ctx->cache, hash_key, type, handle);
       if (cso_hash_iter_is_null(iter)) {
          ctx->pipe->delete_vertex_elements_state(ctx->pipe, handle);
          return;
diff --git a/src/gallium/auxiliary/util/u_vbuf.c b/src/gallium/auxiliary/util/u_vbuf.c
index 68f7c166f0cb..0bbd2a6153d4 100644
--- a/src/gallium/auxiliary/util/u_vbuf.c
+++ b/src/gallium/auxiliary/util/u_vbuf.c
@@ -390,17 +390,20 @@ u_vbuf_set_vertex_elements_internal(struct u_vbuf *mgr,
    struct cso_hash_iter iter;
    struct u_vbuf_elements *ve;
 
+   enum cso_cache_type type = CSO_VELEMENTS0 + velems->count;
+   assert(type <= CSO_VELEMENTS32);
+
    /* need to include the count into the stored state data too. */
    key_size = sizeof(struct pipe_vertex_element) * velems->count +
               sizeof(unsigned);
    hash_key = cso_construct_key(velems, key_size);
-   iter = cso_find_state_template(&mgr->cso_cache, hash_key, CSO_VELEMENTS,
+   iter = cso_find_state_template(&mgr->cso_cache, hash_key, type,
                                   velems, key_size);
 
    if (cso_hash_iter_is_null(iter)) {
       ve = u_vbuf_create_vertex_elements(mgr, velems);
 
-      iter = cso_insert_state(&mgr->cso_cache, hash_key, CSO_VELEMENTS, ve);
+      iter = cso_insert_state(&mgr->cso_cache, hash_key, type, ve);
    } else {
       ve = (struct u_vbuf_elements *)cso_hash_iter_data(iter);
    }
-- 
GitLab


From 7fdc26d495dcbd68dd1c1177c05f3311242c1396 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Sun, 7 Aug 2022 19:49:57 -0400
Subject: [PATCH 12/15] cso: add a key_offset parameter to
 cso_find_state_template

So that the key can be inside the structure not at the beginning.
This will be used to skip hashing pipe_vertex_elements::count.
---
 src/gallium/auxiliary/cso_cache/cso_cache.h   |  6 +++---
 src/gallium/auxiliary/cso_cache/cso_context.c | 12 ++++++------
 src/gallium/auxiliary/util/u_vbuf.c           |  2 +-
 3 files changed, 10 insertions(+), 10 deletions(-)

diff --git a/src/gallium/auxiliary/cso_cache/cso_cache.h b/src/gallium/auxiliary/cso_cache/cso_cache.h
index 91906f4c0f3f..c186a40f1f46 100644
--- a/src/gallium/auxiliary/cso_cache/cso_cache.h
+++ b/src/gallium/auxiliary/cso_cache/cso_cache.h
@@ -174,13 +174,13 @@ cso_construct_key(const void *key, int key_size)
 
 static ALWAYS_INLINE struct cso_hash_iter
 cso_find_state_template(struct cso_cache *sc, unsigned hash_key,
-                        enum cso_cache_type type, const void *key,
-                        unsigned key_size)
+                        enum cso_cache_type type, unsigned key_offset,
+                        const void *key, unsigned key_size)
 {
    struct cso_hash_iter iter = cso_find_state(sc, hash_key, type);
    while (!cso_hash_iter_is_null(iter)) {
       void *iter_data = cso_hash_iter_data(iter);
-      if (!memcmp(iter_data, key, key_size))
+      if (!memcmp((uint8_t*)iter_data + key_offset, key, key_size))
          return iter;
       iter = cso_hash_iter_next(iter);
    }
diff --git a/src/gallium/auxiliary/cso_cache/cso_context.c b/src/gallium/auxiliary/cso_cache/cso_context.c
index 9e7e3a62c36c..4ba549774a0f 100644
--- a/src/gallium/auxiliary/cso_cache/cso_context.c
+++ b/src/gallium/auxiliary/cso_cache/cso_context.c
@@ -468,13 +468,13 @@ enum pipe_error cso_set_blend(struct cso_context *ctx,
        */
       hash_key = cso_construct_key(templ, CSO_BLEND_KEY_SIZE_ALL_RT);
       iter = cso_find_state_template(&ctx->cache, hash_key, CSO_BLEND_ALL_RT,
-                                     templ, CSO_BLEND_KEY_SIZE_ALL_RT);
+                                     0, templ, CSO_BLEND_KEY_SIZE_ALL_RT);
       type = CSO_BLEND_ALL_RT;
       key_size = CSO_BLEND_KEY_SIZE_ALL_RT;
    } else {
       hash_key = cso_construct_key(templ, CSO_BLEND_KEY_SIZE_RT0);
       iter = cso_find_state_template(&ctx->cache, hash_key, CSO_BLEND_RT0,
-                                     templ, CSO_BLEND_KEY_SIZE_RT0);
+                                     0, templ, CSO_BLEND_KEY_SIZE_RT0);
       type = CSO_BLEND_RT0;
       key_size = CSO_BLEND_KEY_SIZE_RT0;
    }
@@ -535,7 +535,7 @@ cso_set_depth_stencil_alpha(struct cso_context *ctx,
    struct cso_hash_iter iter = cso_find_state_template(&ctx->cache,
                                                        hash_key,
                                                        CSO_DEPTH_STENCIL_ALPHA,
-                                                       templ, key_size);
+                                                       0, templ, key_size);
    void *handle;
 
    if (cso_hash_iter_is_null(iter)) {
@@ -597,7 +597,7 @@ enum pipe_error cso_set_rasterizer(struct cso_context *ctx,
    struct cso_hash_iter iter = cso_find_state_template(&ctx->cache,
                                                        hash_key,
                                                        CSO_RASTERIZER,
-                                                       templ, key_size);
+                                                       0, templ, key_size);
    void *handle = NULL;
 
    /* We can't have both point_quad_rasterization (sprites) and point_smooth
@@ -1074,7 +1074,7 @@ cso_set_vertex_elements_direct(struct cso_context *ctx,
    key_size = sizeof(struct pipe_vertex_element) * velems->count +
               sizeof(unsigned);
    hash_key = cso_construct_key(velems, key_size);
-   iter = cso_find_state_template(&ctx->cache, hash_key, type, velems,
+   iter = cso_find_state_template(&ctx->cache, hash_key, type, 0, velems,
                                   key_size);
 
    if (cso_hash_iter_is_null(iter)) {
@@ -1240,7 +1240,7 @@ set_sampler(struct cso_context *ctx, enum pipe_shader_type shader_stage,
    struct cso_hash_iter iter =
       cso_find_state_template(&ctx->cache,
                               hash_key, CSO_SAMPLER,
-                              templ, key_size);
+                              0, templ, key_size);
 
    if (cso_hash_iter_is_null(iter)) {
       cso = MALLOC(sizeof(struct cso_sampler));
diff --git a/src/gallium/auxiliary/util/u_vbuf.c b/src/gallium/auxiliary/util/u_vbuf.c
index 0bbd2a6153d4..eb8ed24fe726 100644
--- a/src/gallium/auxiliary/util/u_vbuf.c
+++ b/src/gallium/auxiliary/util/u_vbuf.c
@@ -398,7 +398,7 @@ u_vbuf_set_vertex_elements_internal(struct u_vbuf *mgr,
               sizeof(unsigned);
    hash_key = cso_construct_key(velems, key_size);
    iter = cso_find_state_template(&mgr->cso_cache, hash_key, type,
-                                  velems, key_size);
+                                  0, velems, key_size);
 
    if (cso_hash_iter_is_null(iter)) {
       ve = u_vbuf_create_vertex_elements(mgr, velems);
-- 
GitLab


From e95e36ca624456eaa601e4b75305b028dec82e0c Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Sun, 7 Aug 2022 20:21:28 -0400
Subject: [PATCH 13/15] cso: don't hash pipe_vertex_elements::count because
 each count has its own cache

---
 src/gallium/auxiliary/cso_cache/cso_context.c | 16 ++++++----------
 src/gallium/auxiliary/util/u_vbuf.c           | 10 +++++-----
 2 files changed, 11 insertions(+), 15 deletions(-)

diff --git a/src/gallium/auxiliary/cso_cache/cso_context.c b/src/gallium/auxiliary/cso_cache/cso_context.c
index 4ba549774a0f..dc591172d90c 100644
--- a/src/gallium/auxiliary/cso_cache/cso_context.c
+++ b/src/gallium/auxiliary/cso_cache/cso_context.c
@@ -1066,16 +1066,12 @@ cso_set_vertex_elements_direct(struct cso_context *ctx,
    enum cso_cache_type type = CSO_VELEMENTS0 + velems->count;
    assert(type <= CSO_VELEMENTS32);
 
-   /* Need to include the count into the stored state data too.
-    * Otherwise first few count pipe_vertex_elements could be identical
-    * even if count is different, and there's no guarantee the hash would
-    * be different in that case neither.
-    */
-   key_size = sizeof(struct pipe_vertex_element) * velems->count +
-              sizeof(unsigned);
-   hash_key = cso_construct_key(velems, key_size);
-   iter = cso_find_state_template(&ctx->cache, hash_key, type, 0, velems,
-                                  key_size);
+   /* We don't hash the count because each count has its own cache. */
+   key_size = sizeof(struct pipe_vertex_element) * velems->count;
+   hash_key = cso_construct_key(velems->input, key_size);
+   iter = cso_find_state_template(&ctx->cache, hash_key, type,
+                                  offsetof(struct pipe_vertex_elements, input[0]),
+                                  velems->input, key_size);
 
    if (cso_hash_iter_is_null(iter)) {
       handle = ctx->pipe->create_vertex_elements_state(ctx->pipe, velems);
diff --git a/src/gallium/auxiliary/util/u_vbuf.c b/src/gallium/auxiliary/util/u_vbuf.c
index eb8ed24fe726..3033ccd64347 100644
--- a/src/gallium/auxiliary/util/u_vbuf.c
+++ b/src/gallium/auxiliary/util/u_vbuf.c
@@ -393,12 +393,12 @@ u_vbuf_set_vertex_elements_internal(struct u_vbuf *mgr,
    enum cso_cache_type type = CSO_VELEMENTS0 + velems->count;
    assert(type <= CSO_VELEMENTS32);
 
-   /* need to include the count into the stored state data too. */
-   key_size = sizeof(struct pipe_vertex_element) * velems->count +
-              sizeof(unsigned);
-   hash_key = cso_construct_key(velems, key_size);
+   /* We don't hash the count because each count has its own cache. */
+   key_size = sizeof(struct pipe_vertex_element) * velems->count;
+   hash_key = cso_construct_key(velems->input, key_size);
    iter = cso_find_state_template(&mgr->cso_cache, hash_key, type,
-                                  0, velems, key_size);
+                                  offsetof(struct pipe_vertex_elements, input[0]),
+                                  velems->input, key_size);
 
    if (cso_hash_iter_is_null(iter)) {
       ve = u_vbuf_create_vertex_elements(mgr, velems);
-- 
GitLab


From 052b03a37b2fec93c78337b152612c28c092b440 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Sun, 7 Aug 2022 20:28:09 -0400
Subject: [PATCH 14/15] cso: use a C++ template to optimize vertex element
 state lookups

The big comment in the new file explains this. The idea is to unroll
the hash computation loop and inline and unroll memcmp for CSO lookups.

We use the same optimization technique in radeonsi.
---
 src/gallium/auxiliary/cso_cache/cso_cache.h   | 10 ++
 .../auxiliary/cso_cache/cso_cache_velems.cpp  | 95 +++++++++++++++++++
 src/gallium/auxiliary/cso_cache/cso_context.c | 21 ++--
 src/gallium/auxiliary/meson.build             |  1 +
 src/gallium/auxiliary/util/u_vbuf.c           | 20 ++--
 5 files changed, 119 insertions(+), 28 deletions(-)
 create mode 100644 src/gallium/auxiliary/cso_cache/cso_cache_velems.cpp

diff --git a/src/gallium/auxiliary/cso_cache/cso_cache.h b/src/gallium/auxiliary/cso_cache/cso_cache.h
index c186a40f1f46..1772b7ac2711 100644
--- a/src/gallium/auxiliary/cso_cache/cso_cache.h
+++ b/src/gallium/auxiliary/cso_cache/cso_cache.h
@@ -138,6 +138,15 @@ struct cso_sampler {
    unsigned hash_key;
 };
 
+struct cso_item {
+   unsigned hash_key;
+   struct cso_hash_iter iter;
+};
+
+typedef void (*cso_hash_and_find_velems_callback)(struct cso_cache *cache,
+                                                  const struct pipe_vertex_elements *,
+                                                  struct cso_item *result);
+
 void cso_cache_init(struct cso_cache *sc, struct pipe_context *pipe);
 void cso_cache_delete(struct cso_cache *sc);
 
@@ -156,6 +165,7 @@ struct cso_hash_iter cso_find_state(struct cso_cache *sc,
 void cso_set_maximum_cache_size(struct cso_cache *sc, int number);
 void cso_delete_state(struct pipe_context *pipe, void *state,
                       enum cso_cache_type type);
+extern const cso_hash_and_find_velems_callback cso_hash_and_find_vertex_elements[33];
 
 static ALWAYS_INLINE unsigned
 cso_construct_key(const void *key, int key_size)
diff --git a/src/gallium/auxiliary/cso_cache/cso_cache_velems.cpp b/src/gallium/auxiliary/cso_cache/cso_cache_velems.cpp
new file mode 100644
index 000000000000..cbff6bb2e2f7
--- /dev/null
+++ b/src/gallium/auxiliary/cso_cache/cso_cache_velems.cpp
@@ -0,0 +1,95 @@
+/**************************************************************************
+ *
+ * Copyright 2022 Advanced Micro Devices, Inc.
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sub license, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial portions
+ * of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
+ * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
+ * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ **************************************************************************/
+
+#include "cso_cache.h"
+
+/**
+ * The purpose of this file is to unroll the hash key computation of vertex
+ * elements and inline and unroll memcmp by making the hashed and compared
+ * size a literal constant through a C++ template parameter. Every function
+ * call here is ALWAYS_INLINE to unroll things.
+ *
+ * Users should get the optimized function for each vertex element count by
+ * accessing the array of function pointers.
+ */
+
+template<int COUNT> void
+hash_and_find_vertex_elements(struct cso_cache *cache,
+                              const struct pipe_vertex_elements *velems,
+                              struct cso_item *result)
+{
+   assert(velems->count == COUNT);
+   /* We don't hash the count because each count has its own cache. */
+   unsigned key_size = sizeof(struct pipe_vertex_element) * COUNT;
+   unsigned hash_key = cso_construct_key(velems->input, key_size);
+   enum cso_cache_type type = (enum cso_cache_type)(CSO_VELEMENTS0 + COUNT);
+
+   STATIC_ASSERT(COUNT >= 0 && CSO_VELEMENTS0 + COUNT <= CSO_VELEMENTS32);
+
+   result->iter =
+      cso_find_state_template(cache, hash_key, type,
+                              offsetof(struct pipe_vertex_elements, input[0]),
+                              velems->input, key_size);
+   result->hash_key = hash_key;
+}
+
+const cso_hash_and_find_velems_callback cso_hash_and_find_vertex_elements[33] =
+{
+   hash_and_find_vertex_elements<0>,
+   hash_and_find_vertex_elements<1>,
+   hash_and_find_vertex_elements<2>,
+   hash_and_find_vertex_elements<3>,
+   hash_and_find_vertex_elements<4>,
+   hash_and_find_vertex_elements<5>,
+   hash_and_find_vertex_elements<6>,
+   hash_and_find_vertex_elements<7>,
+   hash_and_find_vertex_elements<8>,
+   hash_and_find_vertex_elements<9>,
+   hash_and_find_vertex_elements<10>,
+   hash_and_find_vertex_elements<11>,
+   hash_and_find_vertex_elements<12>,
+   hash_and_find_vertex_elements<13>,
+   hash_and_find_vertex_elements<14>,
+   hash_and_find_vertex_elements<15>,
+   hash_and_find_vertex_elements<16>,
+   hash_and_find_vertex_elements<17>,
+   hash_and_find_vertex_elements<18>,
+   hash_and_find_vertex_elements<19>,
+   hash_and_find_vertex_elements<20>,
+   hash_and_find_vertex_elements<21>,
+   hash_and_find_vertex_elements<22>,
+   hash_and_find_vertex_elements<23>,
+   hash_and_find_vertex_elements<24>,
+   hash_and_find_vertex_elements<25>,
+   hash_and_find_vertex_elements<26>,
+   hash_and_find_vertex_elements<27>,
+   hash_and_find_vertex_elements<28>,
+   hash_and_find_vertex_elements<29>,
+   hash_and_find_vertex_elements<30>,
+   hash_and_find_vertex_elements<31>,
+   hash_and_find_vertex_elements<32>,
+};
diff --git a/src/gallium/auxiliary/cso_cache/cso_context.c b/src/gallium/auxiliary/cso_cache/cso_context.c
index dc591172d90c..fb4d06978d12 100644
--- a/src/gallium/auxiliary/cso_cache/cso_context.c
+++ b/src/gallium/auxiliary/cso_cache/cso_context.c
@@ -1059,31 +1059,24 @@ static void
 cso_set_vertex_elements_direct(struct cso_context *ctx,
                                const struct pipe_vertex_elements *velems)
 {
-   unsigned key_size, hash_key;
-   struct cso_hash_iter iter;
    struct pipe_vertex_elements *handle;
+   struct cso_item item;
 
-   enum cso_cache_type type = CSO_VELEMENTS0 + velems->count;
-   assert(type <= CSO_VELEMENTS32);
+   cso_hash_and_find_vertex_elements[velems->count](&ctx->cache, velems, &item);
 
-   /* We don't hash the count because each count has its own cache. */
-   key_size = sizeof(struct pipe_vertex_element) * velems->count;
-   hash_key = cso_construct_key(velems->input, key_size);
-   iter = cso_find_state_template(&ctx->cache, hash_key, type,
-                                  offsetof(struct pipe_vertex_elements, input[0]),
-                                  velems->input, key_size);
-
-   if (cso_hash_iter_is_null(iter)) {
+   if (cso_hash_iter_is_null(item.iter)) {
       handle = ctx->pipe->create_vertex_elements_state(ctx->pipe, velems);
 
-      iter = cso_insert_state(&ctx->cache, hash_key, type, handle);
+      struct cso_hash_iter iter = cso_insert_state(&ctx->cache, item.hash_key,
+                                                   CSO_VELEMENTS0 + velems->count,
+                                                   handle);
       if (cso_hash_iter_is_null(iter)) {
          ctx->pipe->delete_vertex_elements_state(ctx->pipe, handle);
          return;
       }
    }
    else {
-      handle = (struct pipe_vertex_elements*)cso_hash_iter_data(iter);
+      handle = (struct pipe_vertex_elements*)cso_hash_iter_data(item.iter);
    }
 
    if (ctx->velements != handle) {
diff --git a/src/gallium/auxiliary/meson.build b/src/gallium/auxiliary/meson.build
index 184e1c87f34f..ae78e7457cb1 100644
--- a/src/gallium/auxiliary/meson.build
+++ b/src/gallium/auxiliary/meson.build
@@ -21,6 +21,7 @@
 files_libgallium = files(
   'cso_cache/cso_cache.c',
   'cso_cache/cso_cache.h',
+  'cso_cache/cso_cache_velems.cpp',
   'cso_cache/cso_context.c',
   'cso_cache/cso_context.h',
   'cso_cache/cso_hash.c',
diff --git a/src/gallium/auxiliary/util/u_vbuf.c b/src/gallium/auxiliary/util/u_vbuf.c
index 3033ccd64347..bc9a7faf3d2d 100644
--- a/src/gallium/auxiliary/util/u_vbuf.c
+++ b/src/gallium/auxiliary/util/u_vbuf.c
@@ -386,26 +386,18 @@ u_vbuf_set_vertex_elements_internal(struct u_vbuf *mgr,
                                     const struct pipe_vertex_elements *velems)
 {
    struct pipe_context *pipe = mgr->pipe;
-   unsigned key_size, hash_key;
-   struct cso_hash_iter iter;
    struct u_vbuf_elements *ve;
+   struct cso_item item;
 
-   enum cso_cache_type type = CSO_VELEMENTS0 + velems->count;
-   assert(type <= CSO_VELEMENTS32);
+   cso_hash_and_find_vertex_elements[velems->count](&mgr->cso_cache, velems, &item);
 
-   /* We don't hash the count because each count has its own cache. */
-   key_size = sizeof(struct pipe_vertex_element) * velems->count;
-   hash_key = cso_construct_key(velems->input, key_size);
-   iter = cso_find_state_template(&mgr->cso_cache, hash_key, type,
-                                  offsetof(struct pipe_vertex_elements, input[0]),
-                                  velems->input, key_size);
-
-   if (cso_hash_iter_is_null(iter)) {
+   if (cso_hash_iter_is_null(item.iter)) {
       ve = u_vbuf_create_vertex_elements(mgr, velems);
 
-      iter = cso_insert_state(&mgr->cso_cache, hash_key, type, ve);
+      cso_insert_state(&mgr->cso_cache, item.hash_key,
+                       CSO_VELEMENTS0 + velems->count, ve);
    } else {
-      ve = (struct u_vbuf_elements *)cso_hash_iter_data(iter);
+      ve = (struct u_vbuf_elements *)cso_hash_iter_data(item.iter);
    }
 
    assert(ve);
-- 
GitLab


From e898141d5c48463a8569362884f71c368f0e156c Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Mon, 8 Aug 2022 10:39:07 -0400
Subject: [PATCH 15/15] cso: inline more functions

---
 src/gallium/auxiliary/cso_cache/cso_cache.c | 15 ---------------
 src/gallium/auxiliary/cso_cache/cso_cache.h | 17 +++++++++++++++--
 2 files changed, 15 insertions(+), 17 deletions(-)

diff --git a/src/gallium/auxiliary/cso_cache/cso_cache.c b/src/gallium/auxiliary/cso_cache/cso_cache.c
index 33294511cb17..76d7fc096939 100644
--- a/src/gallium/auxiliary/cso_cache/cso_cache.c
+++ b/src/gallium/auxiliary/cso_cache/cso_cache.c
@@ -36,11 +36,6 @@
 #include "cso_hash.h"
 
 
-static inline struct cso_hash *_cso_hash_for_type(struct cso_cache *sc, enum cso_cache_type type)
-{
-   return &sc->hashes[type];
-}
-
 /* Default delete callback. It can also be used by custom callbacks. */
 void cso_delete_state(struct pipe_context *pipe, void *state,
                       enum cso_cache_type type)
@@ -115,16 +110,6 @@ cso_insert_state(struct cso_cache *sc,
    return cso_hash_insert(hash, hash_key, state);
 }
 
-struct cso_hash_iter
-cso_find_state(struct cso_cache *sc,
-               unsigned hash_key, enum cso_cache_type type)
-{
-   struct cso_hash *hash = _cso_hash_for_type(sc, type);
-
-   return cso_hash_find(hash, hash_key);
-}
-
-
 void *cso_hash_find_data_from_template( struct cso_hash *hash,
 				        unsigned hash_key, 
 				        void *templ,
diff --git a/src/gallium/auxiliary/cso_cache/cso_cache.h b/src/gallium/auxiliary/cso_cache/cso_cache.h
index 1772b7ac2711..a0daf1860090 100644
--- a/src/gallium/auxiliary/cso_cache/cso_cache.h
+++ b/src/gallium/auxiliary/cso_cache/cso_cache.h
@@ -160,8 +160,6 @@ void cso_cache_set_delete_cso_callback(struct cso_cache *sc,
 struct cso_hash_iter cso_insert_state(struct cso_cache *sc,
                                       unsigned hash_key, enum cso_cache_type type,
                                       void *state);
-struct cso_hash_iter cso_find_state(struct cso_cache *sc,
-                                    unsigned hash_key, enum cso_cache_type type);
 void cso_set_maximum_cache_size(struct cso_cache *sc, int number);
 void cso_delete_state(struct pipe_context *pipe, void *state,
                       enum cso_cache_type type);
@@ -182,6 +180,21 @@ cso_construct_key(const void *key, int key_size)
    return hash;
 }
 
+static ALWAYS_INLINE struct cso_hash *
+_cso_hash_for_type(struct cso_cache *sc, enum cso_cache_type type)
+{
+   return &sc->hashes[type];
+}
+
+static ALWAYS_INLINE struct cso_hash_iter
+cso_find_state(struct cso_cache *sc,
+               unsigned hash_key, enum cso_cache_type type)
+{
+   struct cso_hash *hash = _cso_hash_for_type(sc, type);
+
+   return cso_hash_find(hash, hash_key);
+}
+
 static ALWAYS_INLINE struct cso_hash_iter
 cso_find_state_template(struct cso_cache *sc, unsigned hash_key,
                         enum cso_cache_type type, unsigned key_offset,
-- 
GitLab

