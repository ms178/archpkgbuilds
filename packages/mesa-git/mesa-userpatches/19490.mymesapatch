From 099bb905bc73f3530bd5fbd6856b62ee148a3c6c Mon Sep 17 00:00:00 2001
From: Mario Kleiner <mario.kleiner.de@gmail.com>
Date: Thu, 3 Nov 2022 05:37:51 +0100
Subject: [PATCH] mesa: Make sure row stride for GL_BITMAP texture creation is
 at least 1 Byte.

For glCreateTexture et al. with srcType GL_BITMAP, iow. where each
texel is represented by 1 bit in the source buffer, and each byte
fits 8 texels, according to GL spec, each row of source pixels must
start at a byte boundary, not in the middle of a byte. Cfe. spec
for glPixelStore() function.

This requires skipping to a new source byte after each row of
pixels. Such skipping was missing, leading to corrupted textures
if texture width was not a multiple of 8 texels.

This commit adds suitable pitch handling in the GL_BITMAP path
of extract_uint_indexes() to fix this.

Tested with glTexImage2D(..., GL_COLOR_INDEX, GL_BITMAP, ...) for
requested texture widths < 8 texels.

Signed-off-by: Mario Kleiner <mario.kleiner.de@gmail.com>
---
 src/mesa/main/pack.c | 10 +++++-----
 1 file changed, 5 insertions(+), 5 deletions(-)

diff --git a/src/mesa/main/pack.c b/src/mesa/main/pack.c
index 257f9dd93e8f..17d4beb2812e 100644
--- a/src/mesa/main/pack.c
+++ b/src/mesa/main/pack.c
@@ -256,7 +256,7 @@ _mesa_pack_bitmap( GLint width, GLint height, const GLubyte *source,
 static void
 extract_uint_indexes(GLuint n, GLuint indexes[],
                      GLenum srcFormat, GLenum srcType, const GLvoid *src,
-                     const struct gl_pixelstore_attrib *unpack )
+                     const struct gl_pixelstore_attrib *unpack, GLuint srcWidth)
 {
    assert(srcFormat == GL_COLOR_INDEX || srcFormat == GL_STENCIL_INDEX);
 
@@ -282,7 +282,7 @@ extract_uint_indexes(GLuint n, GLuint indexes[],
                GLuint i;
                for (i = 0; i < n; i++) {
                   indexes[i] = (*ubsrc & mask) ? 1 : 0;
-                  if (mask == 128) {
+                  if (mask == 128 || !((i + 1) % srcWidth)) {
                      mask = 1;
                      ubsrc++;
                   }
@@ -296,7 +296,7 @@ extract_uint_indexes(GLuint n, GLuint indexes[],
                GLuint i;
                for (i = 0; i < n; i++) {
                   indexes[i] = (*ubsrc & mask) ? 1 : 0;
-                  if (mask == 1) {
+                  if (mask == 1 || !((i + 1) % srcWidth)) {
                      mask = 128;
                      ubsrc++;
                   }
@@ -537,7 +537,7 @@ _mesa_unpack_stencil_span( struct gl_context *ctx, GLuint n,
       }
 
       extract_uint_indexes(n, indexes, GL_STENCIL_INDEX, srcType, source,
-                           srcPacking);
+                           srcPacking, n);
 
       if (transferOps & IMAGE_SHIFT_OFFSET_BIT) {
          /* shift and offset indexes */
@@ -1581,7 +1581,7 @@ _mesa_unpack_color_index_to_rgba_float(struct gl_context *ctx, GLuint dims,
                                                srcFormat, srcType,
                                                img, 0, 0);
 
-      extract_uint_indexes(count, indexes, srcFormat, srcType, srcPtr, srcPacking);
+      extract_uint_indexes(count, indexes, srcFormat, srcType, srcPtr, srcPacking, srcWidth);
 
       if (transferOps & IMAGE_SHIFT_OFFSET_BIT)
          _mesa_shift_and_offset_ci(ctx, count, indexes);
-- 
GitLab

