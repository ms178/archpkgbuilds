From 55956c8680b4dbc41b8b4603d1ae89797b493c66 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Mon, 4 Aug 2025 00:58:05 -0400
Subject: [PATCH 1/7] nir: don't allocate nir_constant::elements if there are
 none

---
 src/compiler/glsl/glsl_to_nir.cpp             | 12 ++++----
 src/compiler/nir/nir_clone.c                  | 10 +++++--
 .../nir/nir_lower_const_arrays_to_uniforms.c  | 30 +++++++++++--------
 src/compiler/nir/nir_serialize.c              | 10 ++++---
 src/compiler/nir/nir_split_vars.c             |  9 ++++--
 src/compiler/spirv/spirv_to_nir.c             |  8 +++--
 6 files changed, 49 insertions(+), 30 deletions(-)

diff --git a/src/compiler/glsl/glsl_to_nir.cpp b/src/compiler/glsl/glsl_to_nir.cpp
index 3399895ad809d..cd2b51109faec 100644
--- a/src/compiler/glsl/glsl_to_nir.cpp
+++ b/src/compiler/glsl/glsl_to_nir.cpp
@@ -384,12 +384,14 @@ nir_visitor::constant_copy(ir_constant *ir, void *mem_ctx)
 
    case GLSL_TYPE_STRUCT:
    case GLSL_TYPE_ARRAY:
-      ret->elements = ralloc_array(mem_ctx, nir_constant *,
-                                   ir->type->length);
-      ret->num_elements = ir->type->length;
+      if (ir->type->length) {
+         ret->elements = ralloc_array(mem_ctx, nir_constant *,
+                                      ir->type->length);
+         ret->num_elements = ir->type->length;
 
-      for (i = 0; i < ir->type->length; i++)
-         ret->elements[i] = constant_copy(ir->const_elements[i], mem_ctx);
+         for (i = 0; i < ir->type->length; i++)
+            ret->elements[i] = constant_copy(ir->const_elements[i], mem_ctx);
+      }
       break;
 
    default:
diff --git a/src/compiler/nir/nir_clone.c b/src/compiler/nir/nir_clone.c
index bcf0cafab6b69..6cf2d041754bc 100644
--- a/src/compiler/nir/nir_clone.c
+++ b/src/compiler/nir/nir_clone.c
@@ -133,9 +133,13 @@ nir_constant_clone(const nir_constant *c, nir_variable *nvar)
    memcpy(nc->values, c->values, sizeof(nc->values));
    nc->is_null_constant = c->is_null_constant;
    nc->num_elements = c->num_elements;
-   nc->elements = ralloc_array(nvar, nir_constant *, c->num_elements);
-   for (unsigned i = 0; i < c->num_elements; i++) {
-      nc->elements[i] = nir_constant_clone(c->elements[i], nvar);
+
+   if (c->num_elements) {
+      nc->elements = ralloc_array(nvar, nir_constant *, c->num_elements);
+      for (unsigned i = 0; i < c->num_elements; i++)
+         nc->elements[i] = nir_constant_clone(c->elements[i], nvar);
+   } else {
+      nc->elements = NULL;
    }
 
    return nc;
diff --git a/src/compiler/nir/nir_lower_const_arrays_to_uniforms.c b/src/compiler/nir/nir_lower_const_arrays_to_uniforms.c
index 69d45dd76ebbd..455c0892d65eb 100644
--- a/src/compiler/nir/nir_lower_const_arrays_to_uniforms.c
+++ b/src/compiler/nir/nir_lower_const_arrays_to_uniforms.c
@@ -100,10 +100,13 @@ rebuild_const_array_initialiser(const struct glsl_type *type, void *mem_ctx)
 
    if (glsl_type_is_matrix(type) && glsl_get_matrix_columns(type) > 1) {
       ret->num_elements = glsl_get_matrix_columns(type);
-      ret->elements = ralloc_array(mem_ctx, nir_constant *, ret->num_elements);
 
-      for (unsigned i = 0; i < ret->num_elements; i++) {
-         ret->elements[i] = rzalloc(mem_ctx, nir_constant);
+      if (ret->num_elements) {
+         ret->elements = ralloc_array(mem_ctx, nir_constant *, ret->num_elements);
+
+         for (unsigned i = 0; i < ret->num_elements; i++) {
+            ret->elements[i] = rzalloc(mem_ctx, nir_constant);
+         }
       }
 
       return ret;
@@ -111,15 +114,18 @@ rebuild_const_array_initialiser(const struct glsl_type *type, void *mem_ctx)
 
    if (glsl_type_is_array(type) || glsl_type_is_struct(type)) {
       ret->num_elements = glsl_get_length(type);
-      ret->elements = ralloc_array(mem_ctx, nir_constant *, ret->num_elements);
-
-      for (unsigned i = 0; i < ret->num_elements; i++) {
-         if (glsl_type_is_array(type)) {
-            ret->elements[i] =
-               rebuild_const_array_initialiser(glsl_get_array_element(type), mem_ctx);
-         } else {
-            ret->elements[i] =
-               rebuild_const_array_initialiser(glsl_get_struct_field(type, i), mem_ctx);
+
+      if (ret->num_elements) {
+         ret->elements = ralloc_array(mem_ctx, nir_constant *, ret->num_elements);
+
+         for (unsigned i = 0; i < ret->num_elements; i++) {
+            if (glsl_type_is_array(type)) {
+               ret->elements[i] =
+                  rebuild_const_array_initialiser(glsl_get_array_element(type), mem_ctx);
+            } else {
+               ret->elements[i] =
+                  rebuild_const_array_initialiser(glsl_get_struct_field(type, i), mem_ctx);
+            }
          }
       }
    }
diff --git a/src/compiler/nir/nir_serialize.c b/src/compiler/nir/nir_serialize.c
index f92aea6e1230d..ac86f6eee82dd 100644
--- a/src/compiler/nir/nir_serialize.c
+++ b/src/compiler/nir/nir_serialize.c
@@ -195,10 +195,12 @@ read_constant(read_ctx *ctx, nir_variable *nvar)
    blob_copy_bytes(ctx->blob, (uint8_t *)c->values, sizeof(c->values));
    c->is_null_constant = memcmp(c->values, zero_vals, sizeof(c->values)) == 0;
    c->num_elements = blob_read_uint32(ctx->blob);
-   c->elements = ralloc_array(nvar, nir_constant *, c->num_elements);
-   for (unsigned i = 0; i < c->num_elements; i++) {
-      c->elements[i] = read_constant(ctx, nvar);
-      c->is_null_constant &= c->elements[i]->is_null_constant;
+   if (c->num_elements) {
+      c->elements = ralloc_array(nvar, nir_constant *, c->num_elements);
+      for (unsigned i = 0; i < c->num_elements; i++) {
+         c->elements[i] = read_constant(ctx, nvar);
+         c->is_null_constant &= c->elements[i]->is_null_constant;
+      }
    }
 
    return c;
diff --git a/src/compiler/nir/nir_split_vars.c b/src/compiler/nir/nir_split_vars.c
index 02c8bbcf99458..b7afdd30b0bea 100644
--- a/src/compiler/nir/nir_split_vars.c
+++ b/src/compiler/nir/nir_split_vars.c
@@ -129,9 +129,12 @@ gather_constant_initializers(nir_constant *src,
       assert(src->num_elements == glsl_get_length(type));
       nir_constant *dst = rzalloc(var, nir_constant);
       dst->num_elements = src->num_elements;
-      dst->elements = rzalloc_array(var, nir_constant *, src->num_elements);
-      for (unsigned i = 0; i < src->num_elements; ++i) {
-         dst->elements[i] = gather_constant_initializers(src->elements[i], var, element, field, state);
+      if (dst->num_elements) {
+         dst->elements = rzalloc_array(var, nir_constant *, src->num_elements);
+         for (unsigned i = 0; i < src->num_elements; ++i) {
+            dst->elements[i] = gather_constant_initializers(src->elements[i], var,
+                                                            element, field, state);
+         }
       }
       return dst;
    } else if (glsl_type_is_struct(type)) {
diff --git a/src/compiler/spirv/spirv_to_nir.c b/src/compiler/spirv/spirv_to_nir.c
index 0d27bb5c54778..323867d1421a4 100644
--- a/src/compiler/spirv/spirv_to_nir.c
+++ b/src/compiler/spirv/spirv_to_nir.c
@@ -2461,9 +2461,11 @@ vtn_null_constant(struct vtn_builder *b, struct vtn_type *type)
    case vtn_base_type_struct:
       c->is_null_constant = true;
       c->num_elements = type->length;
-      c->elements = ralloc_array(b, nir_constant *, c->num_elements);
-      for (unsigned i = 0; i < c->num_elements; i++)
-         c->elements[i] = vtn_null_constant(b, type->members[i]);
+      if (c->num_elements) {
+         c->elements = ralloc_array(b, nir_constant *, c->num_elements);
+         for (unsigned i = 0; i < c->num_elements; i++)
+            c->elements[i] = vtn_null_constant(b, type->members[i]);
+      }
       break;
 
    default:
-- 
GitLab


From bd2bed12dac5593b16a24da66eefa731ed4d67d8 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Fri, 1 Aug 2025 18:43:32 -0400
Subject: [PATCH 2/7] nir: add nir_variable_{set,append,steal}_name{f}() to
 modify nir_variable names

Setting variable names currently always uses ralloc, but the new
nir_variable_* helpers will mostly eliminate ralloc/malloc in a later
commit.

This just updates all places that touch nir_variable names to use the new
helpers.

Reviewed-by: Timothy Arceri <tarceri@itsqueeze.com>
---
 .../gl_nir_lower_blend_equation_advanced.c    |  2 +-
 src/compiler/glsl/gl_nir_lower_discard_flow.c |  2 +-
 .../gl_nir_lower_named_interface_blocks.c     |  2 +-
 .../glsl/gl_nir_lower_packed_varyings.c       |  4 +-
 src/compiler/glsl/glsl_to_nir.cpp             |  2 +-
 src/compiler/nir/nir.c                        | 42 ++++++++++++++++++-
 src/compiler/nir/nir.h                        |  5 +++
 src/compiler/nir/nir_clone.c                  |  2 +-
 src/compiler/nir/nir_lower_clip.c             |  2 +-
 .../nir_lower_clip_cull_distance_array_vars.c |  2 +-
 .../nir/nir_lower_const_arrays_to_uniforms.c  |  4 +-
 src/compiler/nir/nir_lower_fragcolor.c        |  3 +-
 .../nir/nir_lower_io_vars_to_temporaries.c    |  4 +-
 src/compiler/nir/nir_passthrough_gs.c         |  6 +--
 src/compiler/nir/nir_serialize.c              |  2 +-
 src/compiler/spirv/vtn_variables.c            |  8 ++--
 src/freedreno/ir3/ir3_nir_lower_tess.c        |  4 +-
 src/gallium/auxiliary/nir/tgsi_to_nir.c       |  6 +--
 src/gallium/drivers/zink/zink_compiler.c      | 12 +++---
 src/intel/compiler/brw_compile_mesh.cpp       |  3 +-
 src/microsoft/compiler/nir_to_dxil.c          |  4 +-
 21 files changed, 79 insertions(+), 42 deletions(-)

diff --git a/src/compiler/glsl/gl_nir_lower_blend_equation_advanced.c b/src/compiler/glsl/gl_nir_lower_blend_equation_advanced.c
index ecacc91b5327d..68d2e9341ec52 100644
--- a/src/compiler/glsl/gl_nir_lower_blend_equation_advanced.c
+++ b/src/compiler/glsl/gl_nir_lower_blend_equation_advanced.c
@@ -218,7 +218,7 @@ add_temp_var(nir_builder *b, char *name, const struct glsl_type *type)
 {
    nir_variable *var = rzalloc(b->shader, nir_variable);
    var->type = type;
-   var->name = ralloc_strdup(var, name);
+   nir_variable_set_name(var, name);
    var->data.mode = nir_var_function_temp;
    nir_function_impl_add_variable(b->impl, var);
 
diff --git a/src/compiler/glsl/gl_nir_lower_discard_flow.c b/src/compiler/glsl/gl_nir_lower_discard_flow.c
index ef88c3269465b..2ec4a34ef0535 100644
--- a/src/compiler/glsl/gl_nir_lower_discard_flow.c
+++ b/src/compiler/glsl/gl_nir_lower_discard_flow.c
@@ -136,7 +136,7 @@ gl_nir_lower_discard_flow(nir_shader *shader)
    nir_function_impl *main = nir_shader_get_entrypoint(shader);
 
    nir_variable *discarded = rzalloc(shader, nir_variable);
-   discarded->name = ralloc_strdup(discarded, "discarded");
+   nir_variable_set_name(discarded, "discarded");
    discarded->type = glsl_bool_type();
    discarded->data.mode = nir_var_shader_temp;
 
diff --git a/src/compiler/glsl/gl_nir_lower_named_interface_blocks.c b/src/compiler/glsl/gl_nir_lower_named_interface_blocks.c
index 79c419a397897..e4b7178936e82 100644
--- a/src/compiler/glsl/gl_nir_lower_named_interface_blocks.c
+++ b/src/compiler/glsl/gl_nir_lower_named_interface_blocks.c
@@ -270,7 +270,7 @@ lower_named_interface_blocks(struct gl_linked_shader *sh)
                glsl_get_struct_field_data(iface_t, i);
 
             nir_variable *new_var = rzalloc(sh->Program->nir, nir_variable);
-            new_var->name = ralloc_strdup(new_var, field_name);
+            nir_variable_set_name(new_var, field_name);
             if (!glsl_type_is_array(var->type)) {
                new_var->type =  glsl_get_struct_field(iface_t, i);
             } else {
diff --git a/src/compiler/glsl/gl_nir_lower_packed_varyings.c b/src/compiler/glsl/gl_nir_lower_packed_varyings.c
index 928e92e10d1fa..c29bc815bc677 100644
--- a/src/compiler/glsl/gl_nir_lower_packed_varyings.c
+++ b/src/compiler/glsl/gl_nir_lower_packed_varyings.c
@@ -271,7 +271,7 @@ create_or_update_packed_varying(struct lower_packed_varyings_state *state,
       assert(name);
 
       nir_variable *packed_var = rzalloc(state->shader, nir_variable);
-      packed_var->name = ralloc_asprintf(packed_var, "packed:%s", name);
+      nir_variable_set_namef(packed_var, "packed:%s", name);
       packed_var->data.mode = state->mode;
 
       bool is_interpolation_flat =
@@ -316,7 +316,7 @@ create_or_update_packed_varying(struct lower_packed_varyings_state *state,
        */
       if (state->gs_input_vertices == 0 || vertex_index == 0) {
          assert(name);
-         ralloc_asprintf_append((char **) &var->name, ",%s", name);
+         nir_variable_append_namef(var, ",%s", name);
       }
    }
 }
diff --git a/src/compiler/glsl/glsl_to_nir.cpp b/src/compiler/glsl/glsl_to_nir.cpp
index cd2b51109faec..560544fc1055f 100644
--- a/src/compiler/glsl/glsl_to_nir.cpp
+++ b/src/compiler/glsl/glsl_to_nir.cpp
@@ -447,7 +447,7 @@ nir_visitor::visit(ir_variable *ir)
 
    nir_variable *var = rzalloc(shader, nir_variable);
    var->type = ir->type;
-   var->name = ralloc_strdup(var, ir->name);
+   nir_variable_set_name(var, ir->name);
 
    var->data.assigned = ir->data.assigned;
    var->data.read_only = ir->data.read_only;
diff --git a/src/compiler/nir/nir.c b/src/compiler/nir/nir.c
index 9c71d8c54737b..ebf56534364dc 100644
--- a/src/compiler/nir/nir.c
+++ b/src/compiler/nir/nir.c
@@ -267,12 +267,50 @@ nir_shader_add_variable(nir_shader *shader, nir_variable *var)
    exec_list_push_tail(&shader->variables, &var->node);
 }
 
+void
+nir_variable_set_name(nir_variable *var, const char *name)
+{
+   if (var->name)
+      ralloc_free(var->name);
+
+   var->name = ralloc_strdup(var, name);
+}
+
+void
+nir_variable_set_namef(nir_variable *var, const char *fmt, ...)
+{
+   if (var->name)
+      ralloc_free(var->name);
+
+   va_list args;
+   va_start(args, fmt);
+   var->name = ralloc_vasprintf(var, fmt, args);
+   va_end(args);
+}
+
+void
+nir_variable_append_namef(nir_variable *var, const char *fmt, ...)
+{
+   va_list args;
+   va_start(args, fmt);
+   ralloc_vasprintf_append(&var->name, fmt, args);
+   va_end(args);
+}
+
+void
+nir_variable_steal_name(nir_variable *dst, nir_variable *src)
+{
+   ralloc_steal(dst, src->name);
+   dst->name = src->name;
+   src->name = NULL;
+}
+
 nir_variable *
 nir_variable_create(nir_shader *shader, nir_variable_mode mode,
                     const struct glsl_type *type, const char *name)
 {
    nir_variable *var = rzalloc(shader, nir_variable);
-   var->name = ralloc_strdup(var, name);
+   nir_variable_set_name(var, name);
    var->type = type;
    var->data.mode = mode;
    var->data.how_declared = nir_var_declared_normally;
@@ -297,7 +335,7 @@ nir_local_variable_create(nir_function_impl *impl,
                           const struct glsl_type *type, const char *name)
 {
    nir_variable *var = rzalloc(impl->function->shader, nir_variable);
-   var->name = ralloc_strdup(var, name);
+   nir_variable_set_name(var, name);
    var->type = type;
    var->data.mode = nir_var_function_temp;
 
diff --git a/src/compiler/nir/nir.h b/src/compiler/nir/nir.h
index 53dc11fc424da..04265d6610f48 100644
--- a/src/compiler/nir/nir.h
+++ b/src/compiler/nir/nir.h
@@ -3942,6 +3942,11 @@ nir_function_impl_add_variable(nir_function_impl *impl, nir_variable *var)
    exec_list_push_tail(&impl->locals, &var->node);
 }
 
+void nir_variable_set_name(nir_variable *var, const char *name);
+void nir_variable_set_namef(nir_variable *var, const char *fmt, ...) PRINTFLIKE(2, 3);
+void nir_variable_append_namef(nir_variable *var, const char *fmt, ...) PRINTFLIKE(2, 3);
+void nir_variable_steal_name(nir_variable *dst, nir_variable *src);
+
 /** creates a variable, sets a few defaults, and adds it to the list */
 nir_variable *nir_variable_create(nir_shader *shader,
                                   nir_variable_mode mode,
diff --git a/src/compiler/nir/nir_clone.c b/src/compiler/nir/nir_clone.c
index 6cf2d041754bc..39206b3b6f538 100644
--- a/src/compiler/nir/nir_clone.c
+++ b/src/compiler/nir/nir_clone.c
@@ -154,7 +154,7 @@ nir_variable_clone(const nir_variable *var, nir_shader *shader)
    nir_variable *nvar = rzalloc(shader, nir_variable);
 
    nvar->type = var->type;
-   nvar->name = ralloc_strdup(nvar, var->name);
+   nir_variable_set_name(nvar, var->name);
    nvar->data = var->data;
    nvar->num_state_slots = var->num_state_slots;
    if (var->num_state_slots) {
diff --git a/src/compiler/nir/nir_lower_clip.c b/src/compiler/nir/nir_lower_clip.c
index 4d67ed52bb6f3..263283b2d9ec2 100644
--- a/src/compiler/nir/nir_lower_clip.c
+++ b/src/compiler/nir/nir_lower_clip.c
@@ -54,7 +54,7 @@ create_clipdist_var(nir_shader *shader,
       var->data.mode = nir_var_shader_in;
       shader->num_inputs += MAX2(1, DIV_ROUND_UP(array_size, 4));
    }
-   var->name = ralloc_asprintf(var, "clipdist_%d", slot - VARYING_SLOT_CLIP_DIST0);
+   nir_variable_set_namef(var, "clipdist_%d", slot - VARYING_SLOT_CLIP_DIST0);
    var->data.index = 0;
    var->data.location = slot;
 
diff --git a/src/compiler/nir/nir_lower_clip_cull_distance_array_vars.c b/src/compiler/nir/nir_lower_clip_cull_distance_array_vars.c
index 80d0b2bb49138..b12298cfcc0e9 100644
--- a/src/compiler/nir/nir_lower_clip_cull_distance_array_vars.c
+++ b/src/compiler/nir/nir_lower_clip_cull_distance_array_vars.c
@@ -147,7 +147,7 @@ replace_var_declaration(struct lower_distance_state *state, nir_shader *sh,
       unsigned new_size = (state->total_size + 3) / 4;
 
       *new_var = rzalloc(sh, nir_variable);
-      (*new_var)->name = ralloc_strdup(*new_var, GLSL_CLIP_VAR_NAME);
+      nir_variable_set_name(*new_var, GLSL_CLIP_VAR_NAME);
       (*new_var)->data.mode = var->data.mode;
       (*new_var)->data.location = VARYING_SLOT_CLIP_DIST0;
       (*new_var)->data.assigned = true;
diff --git a/src/compiler/nir/nir_lower_const_arrays_to_uniforms.c b/src/compiler/nir/nir_lower_const_arrays_to_uniforms.c
index 455c0892d65eb..b0cb2db483f94 100644
--- a/src/compiler/nir/nir_lower_const_arrays_to_uniforms.c
+++ b/src/compiler/nir/nir_lower_const_arrays_to_uniforms.c
@@ -207,8 +207,8 @@ lower_const_array_to_uniform(nir_shader *shader, struct var_info *info,
    uni->data.read_only = true;
    uni->data.mode = nir_var_uniform;
    uni->type = info->var->type;
-   uni->name = ralloc_asprintf(uni, "constarray_%x_%u",
-                               *const_count, shader->info.stage);
+   nir_variable_set_namef(uni,"constarray_%x_%u",
+                          *const_count, shader->info.stage);
 
    nir_shader_add_variable(shader, uni);
 
diff --git a/src/compiler/nir/nir_lower_fragcolor.c b/src/compiler/nir/nir_lower_fragcolor.c
index 37fcae65a1256..682efe0552517 100644
--- a/src/compiler/nir/nir_lower_fragcolor.c
+++ b/src/compiler/nir/nir_lower_fragcolor.c
@@ -62,12 +62,11 @@ lower_fragcolor_intrin(nir_builder *b, nir_intrinsic_instr *instr, void *data)
    b->cursor = nir_after_instr(&instr->instr);
 
    nir_def *frag_color = instr->src[1].ssa;
-   ralloc_free(out->name);
 
    const char *name = out->data.index == 0 ? "gl_FragData[0]" : "gl_SecondaryFragDataEXT[0]";
    const char *name_tmpl = out->data.index == 0 ? "gl_FragData[%u]" : "gl_SecondaryFragDataEXT[%u]";
 
-   out->name = ralloc_strdup(out, name);
+   nir_variable_set_name(out, name);
 
    /* translate gl_FragColor -> gl_FragData since this is already handled */
    out->data.location = FRAG_RESULT_DATA0;
diff --git a/src/compiler/nir/nir_lower_io_vars_to_temporaries.c b/src/compiler/nir/nir_lower_io_vars_to_temporaries.c
index 9e5bcd3cf2c9f..87e419f2f9e62 100644
--- a/src/compiler/nir/nir_lower_io_vars_to_temporaries.c
+++ b/src/compiler/nir/nir_lower_io_vars_to_temporaries.c
@@ -305,13 +305,13 @@ create_shadow_temp(struct lower_io_state *state, nir_variable *var)
    nir_variable *temp = var;
 
    /* Reparent the name to the new variable */
-   ralloc_steal(nvar, nvar->name);
+   nir_variable_steal_name(nvar, var);
 
    assert(nvar->constant_initializer == NULL && nvar->pointer_initializer == NULL);
 
    /* Give the original a new name with @<mode>-temp appended */
    const char *mode = (temp->data.mode == nir_var_shader_in) ? "in" : "out";
-   temp->name = ralloc_asprintf(var, "%s@%s-temp", mode, nvar->name);
+   nir_variable_set_namef(temp, "%s@%s-temp", mode, nvar->name);
    temp->data.mode = nir_var_shader_temp;
    temp->data.read_only = false;
    temp->data.fb_fetch_output = false;
diff --git a/src/compiler/nir/nir_passthrough_gs.c b/src/compiler/nir/nir_passthrough_gs.c
index 94c32759cc38d..e38d176a19547 100644
--- a/src/compiler/nir/nir_passthrough_gs.c
+++ b/src/compiler/nir/nir_passthrough_gs.c
@@ -174,8 +174,7 @@ nir_create_passthrough_gs(const nir_shader_compiler_options *options,
          snprintf(name, sizeof(name), "in_%d", var->data.driver_location);
 
       nir_variable *in = nir_variable_clone(var, nir);
-      ralloc_free(in->name);
-      in->name = ralloc_strdup(in, name);
+      nir_variable_set_name(in, name);
       in->type = glsl_array_type(var->type, 6, false);
       in->data.mode = nir_var_shader_in;
       nir_shader_add_variable(nir, in);
@@ -195,8 +194,7 @@ nir_create_passthrough_gs(const nir_shader_compiler_options *options,
          snprintf(name, sizeof(name), "out_%d", var->data.driver_location);
 
       nir_variable *out = nir_variable_clone(var, nir);
-      ralloc_free(out->name);
-      out->name = ralloc_strdup(out, name);
+      nir_variable_set_name(out, name);
       out->data.mode = nir_var_shader_out;
       nir_shader_add_variable(nir, out);
 
diff --git a/src/compiler/nir/nir_serialize.c b/src/compiler/nir/nir_serialize.c
index ac86f6eee82dd..c02dc721b6bc3 100644
--- a/src/compiler/nir/nir_serialize.c
+++ b/src/compiler/nir/nir_serialize.c
@@ -363,7 +363,7 @@ read_variable(read_ctx *ctx)
 
    if (flags.u.has_name) {
       const char *name = blob_read_string(ctx->blob);
-      var->name = ralloc_strdup(var, name);
+      nir_variable_set_name(var, name);
    } else {
       var->name = NULL;
    }
diff --git a/src/compiler/spirv/vtn_variables.c b/src/compiler/spirv/vtn_variables.c
index f09dc0b8c92fc..9b613f2439185 100644
--- a/src/compiler/spirv/vtn_variables.c
+++ b/src/compiler/spirv/vtn_variables.c
@@ -2183,7 +2183,7 @@ vtn_create_variable(struct vtn_builder *b, struct vtn_value *val,
    case vtn_variable_mode_node_payload:
       /* For these, we create the variable normally */
       var->var = rzalloc(b->shader, nir_variable);
-      var->var->name = ralloc_strdup(var->var, val->name);
+      nir_variable_set_name(var->var, val->name);
       var->var->type = vtn_type_get_nir_type(b, var->type, var->mode);
 
       /* This is a total hack but we need some way to flag variables which are
@@ -2205,7 +2205,7 @@ vtn_create_variable(struct vtn_builder *b, struct vtn_value *val,
    case vtn_variable_mode_accel_struct:
    case vtn_variable_mode_shader_record:
       var->var = rzalloc(b->shader, nir_variable);
-      var->var->name = ralloc_strdup(var->var, val->name);
+      nir_variable_set_name(var->var, val->name);
 
       var->var->type = vtn_type_get_nir_type(b, var->type, var->mode);
       var->var->interface_type = var->var->type;
@@ -2221,7 +2221,7 @@ vtn_create_variable(struct vtn_builder *b, struct vtn_value *val,
    case vtn_variable_mode_task_payload:
       /* Create the variable normally */
       var->var = rzalloc(b->shader, nir_variable);
-      var->var->name = ralloc_strdup(var->var, val->name);
+      nir_variable_set_name(var->var, val->name);
       var->var->type = vtn_type_get_nir_type(b, var->type, var->mode);
       var->var->data.mode = nir_mode;
       if (var->mode == vtn_variable_mode_workgroup &&
@@ -2232,7 +2232,7 @@ vtn_create_variable(struct vtn_builder *b, struct vtn_value *val,
    case vtn_variable_mode_input:
    case vtn_variable_mode_output: {
       var->var = rzalloc(b->shader, nir_variable);
-      var->var->name = ralloc_strdup(var->var, val->name);
+      nir_variable_set_name(var->var, val->name);
       var->var->type = vtn_type_get_nir_type(b, var->type, var->mode);
       var->var->data.mode = nir_mode;
 
diff --git a/src/freedreno/ir3/ir3_nir_lower_tess.c b/src/freedreno/ir3/ir3_nir_lower_tess.c
index 63ca5fa37930c..ab7765017d455 100644
--- a/src/freedreno/ir3/ir3_nir_lower_tess.c
+++ b/src/freedreno/ir3/ir3_nir_lower_tess.c
@@ -1030,14 +1030,14 @@ ir3_nir_lower_gs(nir_shader *shader)
       exec_list_push_tail(&state.new_outputs, &output->node);
 
       /* Rewrite the original output to be a shadow variable. */
-      var->name = ralloc_asprintf(var, "%s@gs-temp", output->name);
+      nir_variable_set_namef(var, "%s@gs-temp", output->name);
       var->data.mode = nir_var_shader_temp;
 
       /* Clone the shadow variable to create the emit shadow variable that
        * we'll assign in the emit conditionals.
        */
       nir_variable *emit_output = nir_variable_clone(var, shader);
-      emit_output->name = ralloc_asprintf(var, "%s@emit-temp", output->name);
+      nir_variable_set_namef(emit_output, "%s@emit-temp", output->name);
       exec_list_push_tail(&state.emit_outputs, &emit_output->node);
    }
 
diff --git a/src/gallium/auxiliary/nir/tgsi_to_nir.c b/src/gallium/auxiliary/nir/tgsi_to_nir.c
index ef05b784e7bfa..08cc06e336ee0 100644
--- a/src/gallium/auxiliary/nir/tgsi_to_nir.c
+++ b/src/gallium/auxiliary/nir/tgsi_to_nir.c
@@ -301,7 +301,7 @@ ttn_emit_declaration(struct ttn_compile *c)
          case TGSI_FILE_INPUT:
             var->data.read_only = true;
             var->data.mode = nir_var_shader_in;
-            var->name = ralloc_asprintf(var, "in_%d", idx);
+            nir_variable_set_namef(var, "in_%d", idx);
 
             if (c->scan->processor == PIPE_SHADER_FRAGMENT) {
                if (decl->Semantic.Name == TGSI_SEMANTIC_FACE) {
@@ -359,7 +359,7 @@ ttn_emit_declaration(struct ttn_compile *c)
                                             is_array ? array_size : 0);
 
             var->data.mode = nir_var_shader_out;
-            var->name = ralloc_asprintf(var, "out_%d", idx);
+            nir_variable_set_namef(var, "out_%d", idx);
             var->data.index = 0;
             var->data.interpolation =
                ttn_translate_interp_mode(decl->Interp.Interpolate);
@@ -446,7 +446,7 @@ ttn_emit_declaration(struct ttn_compile *c)
             break;
          case TGSI_FILE_CONSTANT:
             var->data.mode = nir_var_uniform;
-            var->name = ralloc_asprintf(var, "uniform_%d", idx);
+            nir_variable_set_namef(var, "uniform_%d", idx);
             var->data.location = idx;
             break;
          default:
diff --git a/src/gallium/drivers/zink/zink_compiler.c b/src/gallium/drivers/zink/zink_compiler.c
index cd9b2a2d58ec9..5e8c8e371ce8a 100644
--- a/src/gallium/drivers/zink/zink_compiler.c
+++ b/src/gallium/drivers/zink/zink_compiler.c
@@ -1111,8 +1111,7 @@ zink_create_quads_emulation_gs(const nir_shader_compiler_options *options,
          snprintf(name, sizeof(name), "in_%d", var->data.driver_location);
 
       nir_variable *in = nir_variable_clone(var, nir);
-      ralloc_free(in->name);
-      in->name = ralloc_strdup(in, name);
+      nir_variable_set_name(in, name);
       in->type = glsl_array_type(var->type, 4, false);
       in->data.mode = nir_var_shader_in;
       nir_shader_add_variable(nir, in);
@@ -1123,8 +1122,7 @@ zink_create_quads_emulation_gs(const nir_shader_compiler_options *options,
          snprintf(name, sizeof(name), "out_%d", var->data.driver_location);
 
       nir_variable *out = nir_variable_clone(var, nir);
-      ralloc_free(out->name);
-      out->name = ralloc_strdup(out, name);
+      nir_variable_set_name(out, name);
       out->data.mode = nir_var_shader_out;
       nir_shader_add_variable(nir, out);
 
@@ -2063,7 +2061,7 @@ decompose_attribs(nir_shader *nir, uint32_t decomposed_attrs, uint32_t decompose
       state.needs_w = (decomposed_attrs_without_w & BITFIELD_BIT(location)) != 0 && num_components == 4;
       for (unsigned i = 0; i < (state.needs_w ? num_components - 1 : num_components); i++) {
          split[i+1] = nir_variable_clone(var, nir);
-         split[i+1]->name = ralloc_asprintf(nir, "%s_split%u", var->name, i);
+         nir_variable_set_namef(split[i+1], "%s_split%u", var->name, i);
          if (decomposed_attrs_without_w & BITFIELD_BIT(location))
             split[i+1]->type = !i && num_components == 4 ? var->type : new_type;
          else
@@ -2222,9 +2220,9 @@ get_bo_var(nir_shader *shader, struct bo_vars *bo, bool ssbo, nir_src *src, unsi
       }
       var = nir_variable_clone(var, shader);
       if (ssbo)
-         var->name = ralloc_asprintf(shader, "%s@%u", "ssbos", bit_size);
+         nir_variable_set_namef(var, "%s@%u", "ssbos", bit_size);
       else
-         var->name = ralloc_asprintf(shader, "%s@%u", idx ? "ubos" : "uniform_0", bit_size);
+         nir_variable_set_namef(var, "%s@%u", idx ? "ubos" : "uniform_0", bit_size);
       *ptr = var;
       nir_shader_add_variable(shader, var);
 
diff --git a/src/intel/compiler/brw_compile_mesh.cpp b/src/intel/compiler/brw_compile_mesh.cpp
index 4ea3a44ffc7b5..babaf270a4d26 100644
--- a/src/intel/compiler/brw_compile_mesh.cpp
+++ b/src/intel/compiler/brw_compile_mesh.cpp
@@ -269,8 +269,7 @@ brw_nir_lower_mesh_primitive_count(nir_shader *nir)
          nir_create_variable_with_location(nir, nir_var_shader_out,
                                            VARYING_SLOT_PRIMITIVE_COUNT,
                                            glsl_uint_type());
-      final_primitive_count->name = ralloc_strdup(final_primitive_count,
-                                                  "gl_PrimitiveCountNV");
+      nir_variable_set_name(final_primitive_count, "gl_PrimitiveCountNV");
       final_primitive_count->data.interpolation = INTERP_MODE_NONE;
 
       nir_store_var(b, final_primitive_count,
diff --git a/src/microsoft/compiler/nir_to_dxil.c b/src/microsoft/compiler/nir_to_dxil.c
index 801744cd483cd..5cd5d30b8328a 100644
--- a/src/microsoft/compiler/nir_to_dxil.c
+++ b/src/microsoft/compiler/nir_to_dxil.c
@@ -1494,7 +1494,7 @@ emit_global_consts(struct ntd_context *ctx)
 
    nir_foreach_variable_with_modes(var, ctx->shader, nir_var_mem_constant) {
       if (!var->name)
-         var->name = ralloc_asprintf(var, "const_%d", var->data.driver_location);
+         nir_variable_set_namef(var, "const_%d", var->data.driver_location);
 
       const struct dxil_value *agg_vals =
          get_value_for_const_aggregate(&ctx->mod, var->constant_initializer, var->type);
@@ -1525,7 +1525,7 @@ emit_shared_vars(struct ntd_context *ctx)
 
    nir_foreach_variable_with_modes(var, ctx->shader, nir_var_mem_shared) {
       if (!var->name)
-         var->name = ralloc_asprintf(var, "shared_%d", var->data.driver_location);
+         nir_variable_set_namef(var, "shared_%d", var->data.driver_location);
       const struct dxil_value *gvar = dxil_add_global_ptr_var(&ctx->mod, var->name,
                                                               get_type_for_glsl_type(&ctx->mod, var->type),
                                                               DXIL_AS_GROUPSHARED, 16,
-- 
GitLab


From 8fad50321e743633d0c64ca043b1f2dd4fc2adad Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Fri, 1 Aug 2025 20:56:22 -0400
Subject: [PATCH 3/7] nir: eliminate most ralloc/malloc for nir_variable names

Store small names in a fixed-sized string in nir_variable.
GLSL IR does the same thing.

When compiling my shader-db with the gallium noop driver, it improves GLSL
compile times by 0.7% (much lower than anticipated).

For Unigine Heaven shaders:
- it eliminates 95.6% ralloc calls for nir_variable names
- the total number of ralloc calls is reduced by 11%

It also adds only 16B to nir_variable, while just the ralloc header
for the name would occupy 40B.

Reviewed-by: Timothy Arceri <tarceri@itsqueeze.com>
---
 src/compiler/nir/nir.c | 82 ++++++++++++++++++++++++++++++++++++++----
 src/compiler/nir/nir.h |  9 +++++
 2 files changed, 84 insertions(+), 7 deletions(-)

diff --git a/src/compiler/nir/nir.c b/src/compiler/nir/nir.c
index ebf56534364dc..f92f9c577043f 100644
--- a/src/compiler/nir/nir.c
+++ b/src/compiler/nir/nir.c
@@ -32,6 +32,7 @@
 #include "util/half_float.h"
 #include "util/macros.h"
 #include "util/u_math.h"
+#include "util/u_printf.h"
 #include "util/u_qsort.h"
 #include "nir_builder.h"
 #include "nir_control_flow_private.h"
@@ -270,21 +271,42 @@ nir_shader_add_variable(nir_shader *shader, nir_variable *var)
 void
 nir_variable_set_name(nir_variable *var, const char *name)
 {
-   if (var->name)
+   if (var->name && var->name != var->_name_storage)
       ralloc_free(var->name);
 
-   var->name = ralloc_strdup(var, name);
+   if (!name) {
+      var->name = NULL;
+      return;
+   }
+
+   /* Use _name_storage if the name fits in it. */
+   if (strlen(name) < ARRAY_SIZE(var->_name_storage)) {
+      var->name = var->_name_storage;
+      strcpy(var->name, name);
+   } else {
+      var->name = ralloc_strdup(var, name);
+   }
 }
 
 void
 nir_variable_set_namef(nir_variable *var, const char *fmt, ...)
 {
-   if (var->name)
+   if (var->name && var->name != var->_name_storage)
       ralloc_free(var->name);
 
    va_list args;
    va_start(args, fmt);
-   var->name = ralloc_vasprintf(var, fmt, args);
+   size_t name_size = u_printf_length(fmt, args) + 1;
+
+   /* Use _name_storage if the name fits in it. */
+   if (name_size <= ARRAY_SIZE(var->_name_storage))
+      var->name = var->_name_storage;
+   else
+      var->name = ralloc_size(var, name_size);
+
+   if (var->name)
+      vsnprintf(var->name, name_size, fmt, args);
+
    va_end(args);
 }
 
@@ -293,15 +315,61 @@ nir_variable_append_namef(nir_variable *var, const char *fmt, ...)
 {
    va_list args;
    va_start(args, fmt);
-   ralloc_vasprintf_append(&var->name, fmt, args);
+   size_t old_len = var->name ? strlen(var->name) : 0;
+   size_t append_size = u_printf_length(fmt, args) + 1;
+   size_t name_size = old_len + append_size;
+
+   if (append_size == 1) {
+      /* No change. */
+      va_end(args);
+      return;
+   }
+
+   /* Use _name_storage if the name fits in it. */
+   if (name_size <= ARRAY_SIZE(var->_name_storage)) {
+      if (!var->name) {
+         var->name = var->_name_storage;
+      } else if (var->name != var->_name_storage) {
+         /* Move the name to _name_storage. */
+         memcpy(var->_name_storage, var->name, old_len + 1);
+         ralloc_free(var->name);
+         var->name = var->_name_storage;
+      }
+   } else {
+      /* ralloc the appended name. */
+      if (var->name == var->_name_storage) {
+         /* Move the name from _name_storage to ralloc'd. */
+         var->name = ralloc_size(var, name_size);
+         if (var->name)
+            memcpy(var->name, var->_name_storage, old_len + 1);
+      } else {
+         var->name = reralloc_size(var, var->name, name_size);
+      }
+   }
+
+   /* Append the name. */
+   if (var->name)
+      vsnprintf(var->name + old_len, append_size, fmt, args);
    va_end(args);
 }
 
 void
 nir_variable_steal_name(nir_variable *dst, nir_variable *src)
 {
-   ralloc_steal(dst, src->name);
-   dst->name = src->name;
+   if (!src->name) {
+      dst->name = NULL;
+      return;
+   }
+
+   /* Use _name_storage if the name fits in it. */
+   if (src->name == src->_name_storage) {
+      dst->name = dst->_name_storage;
+      strcpy(dst->name, src->name);
+   } else {
+      ralloc_steal(dst, src->name);
+      dst->name = src->name;
+   }
+
    src->name = NULL;
 }
 
diff --git a/src/compiler/nir/nir.h b/src/compiler/nir/nir.h
index 04265d6610f48..d42c78385fdac 100644
--- a/src/compiler/nir/nir.h
+++ b/src/compiler/nir/nir.h
@@ -865,6 +865,15 @@ typedef struct nir_variable {
     * variables with a struct or array of array of struct type.
     */
    nir_variable_data *members;
+
+   /**
+    * This is the backing storage for "name" if the name is short enough
+    * to fit in it, so that we don't have to ralloc the name.
+    *
+    * It eliminates 95.6% ralloc calls for variable names when compiling
+    * my GLSL shader-db.
+    */
+   char _name_storage[16];
 } nir_variable;
 
 static inline bool
-- 
GitLab


From 19964412fef5e3daec53ea144e27ee4b311a39bf Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Fri, 1 Aug 2025 21:51:00 -0400
Subject: [PATCH 4/7] nir/clone: don't call ralloc_strdup with a NULL pointer
 for intrinsic names

No impact, but it was affecting my ralloc_strdup stats for
nir_intrinsic_instr names.

Reviewed-by: Timothy Arceri <tarceri@itsqueeze.com>
---
 src/compiler/nir/nir_clone.c | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/src/compiler/nir/nir_clone.c b/src/compiler/nir/nir_clone.c
index 39206b3b6f538..d19c86c08a753 100644
--- a/src/compiler/nir/nir_clone.c
+++ b/src/compiler/nir/nir_clone.c
@@ -355,7 +355,8 @@ clone_intrinsic(clone_state *state, const nir_intrinsic_instr *itr)
 
    nitr->num_components = itr->num_components;
    memcpy(nitr->const_index, itr->const_index, sizeof(nitr->const_index));
-   nitr->name = ralloc_strdup(state->ns, itr->name);
+   if (itr->name)
+      nitr->name = ralloc_strdup(state->ns, itr->name);
 
    for (unsigned i = 0; i < num_srcs; i++)
       __clone_src(state, &nitr->instr, &nitr->src[i], &itr->src[i]);
-- 
GitLab


From 9cf0e5d021742dcb3b51b6fdc09ffc74603929ac Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Fri, 1 Aug 2025 23:10:18 -0400
Subject: [PATCH 5/7] nir: don't use variables as ralloc parents, use the
 shader instead

so that we can switch variables to gc_ctx

Reviewed-by: Timothy Arceri <tarceri@itsqueeze.com>
---
 src/compiler/glsl/gl_nir_link_varyings.c      |  2 +-
 .../gl_nir_lower_blend_equation_advanced.c    |  4 +-
 src/compiler/glsl/gl_nir_lower_discard_flow.c |  2 +-
 .../gl_nir_lower_named_interface_blocks.c     |  2 +-
 .../glsl/gl_nir_lower_packed_varyings.c       |  4 +-
 src/compiler/glsl/glsl_to_nir.cpp             | 20 ++++-----
 src/compiler/nir/nir.c                        | 30 +++++++------
 src/compiler/nir/nir.h                        | 14 ++++---
 src/compiler/nir/nir_clone.c                  | 18 ++++----
 src/compiler/nir/nir_lower_clip.c             |  2 +-
 .../nir_lower_clip_cull_distance_array_vars.c |  2 +-
 .../nir/nir_lower_const_arrays_to_uniforms.c  | 14 +++----
 src/compiler/nir/nir_lower_fragcolor.c        |  2 +-
 .../nir/nir_lower_io_vars_to_temporaries.c    |  4 +-
 src/compiler/nir/nir_passthrough_gs.c         |  4 +-
 src/compiler/nir/nir_serialize.c              | 16 +++----
 src/compiler/nir/nir_split_vars.c             | 17 ++++----
 src/compiler/nir/nir_sweep.c                  | 42 ++++++++++++++++---
 src/compiler/spirv/spirv_to_nir.c             |  3 +-
 src/compiler/spirv/vtn_variables.c            | 12 +++---
 src/freedreno/ir3/ir3_nir_lower_tess.c        |  4 +-
 src/gallium/auxiliary/nir/tgsi_to_nir.c       |  6 +--
 src/gallium/drivers/zink/zink_compiler.c      | 10 ++---
 src/intel/compiler/brw_compile_mesh.cpp       |  2 +-
 src/mesa/main/ff_fragment_shader.c            |  2 +-
 src/microsoft/compiler/dxil_nir.c             | 27 ++++++------
 src/microsoft/compiler/nir_to_dxil.c          |  4 +-
 27 files changed, 157 insertions(+), 112 deletions(-)

diff --git a/src/compiler/glsl/gl_nir_link_varyings.c b/src/compiler/glsl/gl_nir_link_varyings.c
index 163cc9d0ac2c9..30b83b6c6665f 100644
--- a/src/compiler/glsl/gl_nir_link_varyings.c
+++ b/src/compiler/glsl/gl_nir_link_varyings.c
@@ -644,7 +644,7 @@ resize_tes_inputs(const struct gl_constants *consts,
          var->data.explicit_location = false;
          var->data.mode = nir_var_mem_constant;
 
-         nir_constant *val = rzalloc(var, nir_constant);
+         nir_constant *val = rzalloc(tes->Program->nir, nir_constant);
          val->values[0].i32 = num_vertices;
          var->constant_initializer = val;
 
diff --git a/src/compiler/glsl/gl_nir_lower_blend_equation_advanced.c b/src/compiler/glsl/gl_nir_lower_blend_equation_advanced.c
index 68d2e9341ec52..999eb7907f76e 100644
--- a/src/compiler/glsl/gl_nir_lower_blend_equation_advanced.c
+++ b/src/compiler/glsl/gl_nir_lower_blend_equation_advanced.c
@@ -218,7 +218,7 @@ add_temp_var(nir_builder *b, char *name, const struct glsl_type *type)
 {
    nir_variable *var = rzalloc(b->shader, nir_variable);
    var->type = type;
-   nir_variable_set_name(var, name);
+   nir_variable_set_name(b->shader, var, name);
    var->data.mode = nir_var_function_temp;
    nir_function_impl_add_variable(b->impl, var);
 
@@ -510,7 +510,7 @@ gl_nir_lower_blend_equation_advanced(nir_shader *sh, bool coherent)
                                             glsl_uint_type(),
                                             "gl_AdvancedBlendModeMESA");
    mode->data.how_declared = nir_var_hidden;
-   mode->state_slots = rzalloc_array(mode, nir_state_slot, 1);
+   mode->state_slots = rzalloc_array(sh, nir_state_slot, 1);
    mode->num_state_slots = 1;
    mode->state_slots[0].tokens[0] = STATE_ADVANCED_BLENDING_MODE;
 
diff --git a/src/compiler/glsl/gl_nir_lower_discard_flow.c b/src/compiler/glsl/gl_nir_lower_discard_flow.c
index 2ec4a34ef0535..8f542af687e71 100644
--- a/src/compiler/glsl/gl_nir_lower_discard_flow.c
+++ b/src/compiler/glsl/gl_nir_lower_discard_flow.c
@@ -136,7 +136,7 @@ gl_nir_lower_discard_flow(nir_shader *shader)
    nir_function_impl *main = nir_shader_get_entrypoint(shader);
 
    nir_variable *discarded = rzalloc(shader, nir_variable);
-   nir_variable_set_name(discarded, "discarded");
+   nir_variable_set_name(shader, discarded, "discarded");
    discarded->type = glsl_bool_type();
    discarded->data.mode = nir_var_shader_temp;
 
diff --git a/src/compiler/glsl/gl_nir_lower_named_interface_blocks.c b/src/compiler/glsl/gl_nir_lower_named_interface_blocks.c
index e4b7178936e82..129e342519253 100644
--- a/src/compiler/glsl/gl_nir_lower_named_interface_blocks.c
+++ b/src/compiler/glsl/gl_nir_lower_named_interface_blocks.c
@@ -270,7 +270,7 @@ lower_named_interface_blocks(struct gl_linked_shader *sh)
                glsl_get_struct_field_data(iface_t, i);
 
             nir_variable *new_var = rzalloc(sh->Program->nir, nir_variable);
-            nir_variable_set_name(new_var, field_name);
+            nir_variable_set_name(sh->Program->nir, new_var, field_name);
             if (!glsl_type_is_array(var->type)) {
                new_var->type =  glsl_get_struct_field(iface_t, i);
             } else {
diff --git a/src/compiler/glsl/gl_nir_lower_packed_varyings.c b/src/compiler/glsl/gl_nir_lower_packed_varyings.c
index c29bc815bc677..8534440897c0f 100644
--- a/src/compiler/glsl/gl_nir_lower_packed_varyings.c
+++ b/src/compiler/glsl/gl_nir_lower_packed_varyings.c
@@ -271,7 +271,7 @@ create_or_update_packed_varying(struct lower_packed_varyings_state *state,
       assert(name);
 
       nir_variable *packed_var = rzalloc(state->shader, nir_variable);
-      nir_variable_set_namef(packed_var, "packed:%s", name);
+      nir_variable_set_namef(state->shader, packed_var, "packed:%s", name);
       packed_var->data.mode = state->mode;
 
       bool is_interpolation_flat =
@@ -316,7 +316,7 @@ create_or_update_packed_varying(struct lower_packed_varyings_state *state,
        */
       if (state->gs_input_vertices == 0 || vertex_index == 0) {
          assert(name);
-         nir_variable_append_namef(var, ",%s", name);
+         nir_variable_append_namef(state->shader, var, ",%s", name);
       }
    }
 }
diff --git a/src/compiler/glsl/glsl_to_nir.cpp b/src/compiler/glsl/glsl_to_nir.cpp
index 560544fc1055f..fe5337d7521c7 100644
--- a/src/compiler/glsl/glsl_to_nir.cpp
+++ b/src/compiler/glsl/glsl_to_nir.cpp
@@ -308,10 +308,10 @@ nir_visitor::constant_copy(ir_constant *ir, void *mem_ctx)
    case GLSL_TYPE_FLOAT16:
    case GLSL_TYPE_DOUBLE:
       if (cols > 1) {
-         ret->elements = ralloc_array(mem_ctx, nir_constant *, cols);
+         ret->elements = ralloc_array(ret, nir_constant *, cols);
          ret->num_elements = cols;
          for (unsigned c = 0; c < cols; c++) {
-            nir_constant *col_const = rzalloc(mem_ctx, nir_constant);
+            nir_constant *col_const = rzalloc(ret, nir_constant);
             col_const->num_elements = 0;
             switch (ir->type->base_type) {
             case GLSL_TYPE_FLOAT:
@@ -385,12 +385,12 @@ nir_visitor::constant_copy(ir_constant *ir, void *mem_ctx)
    case GLSL_TYPE_STRUCT:
    case GLSL_TYPE_ARRAY:
       if (ir->type->length) {
-         ret->elements = ralloc_array(mem_ctx, nir_constant *,
+         ret->elements = ralloc_array(ret, nir_constant *,
                                       ir->type->length);
          ret->num_elements = ir->type->length;
 
          for (i = 0; i < ir->type->length; i++)
-            ret->elements[i] = constant_copy(ir->const_elements[i], mem_ctx);
+            ret->elements[i] = constant_copy(ir->const_elements[i], ret);
       }
       break;
 
@@ -447,7 +447,7 @@ nir_visitor::visit(ir_variable *ir)
 
    nir_variable *var = rzalloc(shader, nir_variable);
    var->type = ir->type;
-   nir_variable_set_name(var, ir->name);
+   nir_variable_set_name(shader, var, ir->name);
 
    var->data.assigned = ir->data.assigned;
    var->data.read_only = ir->data.read_only;
@@ -621,7 +621,7 @@ nir_visitor::visit(ir_variable *ir)
       int *max_ifc_array_access = ir->get_max_ifc_array_access();
       if (max_ifc_array_access) {
          var->max_ifc_array_access =
-            rzalloc_array(var, int, ir->get_interface_type()->length);
+            rzalloc_array(this->shader, int, ir->get_interface_type()->length);
          memcpy(var->max_ifc_array_access, max_ifc_array_access,
                 ir->get_interface_type()->length * sizeof(unsigned));
       }
@@ -629,7 +629,7 @@ nir_visitor::visit(ir_variable *ir)
 
    var->num_state_slots = ir->get_num_state_slots();
    if (var->num_state_slots > 0) {
-      var->state_slots = rzalloc_array(var, nir_state_slot,
+      var->state_slots = rzalloc_array(this->shader, nir_state_slot,
                                        var->num_state_slots);
 
       ir_state_slot *state_slots = ir->get_state_slots();
@@ -645,9 +645,9 @@ nir_visitor::visit(ir_variable *ir)
     * ir->constant_initializer.
     */
    if (ir->constant_initializer)
-      var->constant_initializer = constant_copy(ir->constant_initializer, var);
+      var->constant_initializer = constant_copy(ir->constant_initializer, shader);
    else
-      var->constant_initializer = constant_copy(ir->constant_value, var);
+      var->constant_initializer = constant_copy(ir->constant_value, shader);
 
    if (var->data.mode == nir_var_function_temp)
       nir_function_impl_add_variable(impl, var);
@@ -2736,7 +2736,7 @@ nir_visitor::visit(ir_constant *ir)
    nir_variable *var =
       nir_local_variable_create(this->impl, ir->type, "const_temp");
    var->data.read_only = true;
-   var->constant_initializer = constant_copy(ir, var);
+   var->constant_initializer = constant_copy(ir, shader);
 
    this->deref = nir_build_deref_var(&b, var);
 }
diff --git a/src/compiler/nir/nir.c b/src/compiler/nir/nir.c
index f92f9c577043f..24e721a071d47 100644
--- a/src/compiler/nir/nir.c
+++ b/src/compiler/nir/nir.c
@@ -269,7 +269,7 @@ nir_shader_add_variable(nir_shader *shader, nir_variable *var)
 }
 
 void
-nir_variable_set_name(nir_variable *var, const char *name)
+nir_variable_set_name(nir_shader *nir, nir_variable *var, const char *name)
 {
    if (var->name && var->name != var->_name_storage)
       ralloc_free(var->name);
@@ -284,12 +284,12 @@ nir_variable_set_name(nir_variable *var, const char *name)
       var->name = var->_name_storage;
       strcpy(var->name, name);
    } else {
-      var->name = ralloc_strdup(var, name);
+      var->name = ralloc_strdup(nir, name);
    }
 }
 
 void
-nir_variable_set_namef(nir_variable *var, const char *fmt, ...)
+nir_variable_set_namef(nir_shader *nir, nir_variable *var, const char *fmt, ...)
 {
    if (var->name && var->name != var->_name_storage)
       ralloc_free(var->name);
@@ -302,7 +302,7 @@ nir_variable_set_namef(nir_variable *var, const char *fmt, ...)
    if (name_size <= ARRAY_SIZE(var->_name_storage))
       var->name = var->_name_storage;
    else
-      var->name = ralloc_size(var, name_size);
+      var->name = ralloc_size(nir, name_size);
 
    if (var->name)
       vsnprintf(var->name, name_size, fmt, args);
@@ -311,7 +311,7 @@ nir_variable_set_namef(nir_variable *var, const char *fmt, ...)
 }
 
 void
-nir_variable_append_namef(nir_variable *var, const char *fmt, ...)
+nir_variable_append_namef(nir_shader *nir, nir_variable *var, const char *fmt, ...)
 {
    va_list args;
    va_start(args, fmt);
@@ -339,11 +339,11 @@ nir_variable_append_namef(nir_variable *var, const char *fmt, ...)
       /* ralloc the appended name. */
       if (var->name == var->_name_storage) {
          /* Move the name from _name_storage to ralloc'd. */
-         var->name = ralloc_size(var, name_size);
+         var->name = ralloc_size(nir, name_size);
          if (var->name)
             memcpy(var->name, var->_name_storage, old_len + 1);
       } else {
-         var->name = reralloc_size(var, var->name, name_size);
+         var->name = reralloc_size(nir, var->name, name_size);
       }
    }
 
@@ -354,8 +354,14 @@ nir_variable_append_namef(nir_variable *var, const char *fmt, ...)
 }
 
 void
-nir_variable_steal_name(nir_variable *dst, nir_variable *src)
+nir_variable_steal_name(nir_shader *nir, nir_variable *dst, nir_variable *src)
 {
+   if (dst == src) {
+      if (dst->name != dst->_name_storage)
+         ralloc_steal(nir, dst->name);
+      return;
+   }
+
    if (!src->name) {
       dst->name = NULL;
       return;
@@ -366,7 +372,7 @@ nir_variable_steal_name(nir_variable *dst, nir_variable *src)
       dst->name = dst->_name_storage;
       strcpy(dst->name, src->name);
    } else {
-      ralloc_steal(dst, src->name);
+      ralloc_steal(nir, src->name);
       dst->name = src->name;
    }
 
@@ -378,7 +384,7 @@ nir_variable_create(nir_shader *shader, nir_variable_mode mode,
                     const struct glsl_type *type, const char *name)
 {
    nir_variable *var = rzalloc(shader, nir_variable);
-   nir_variable_set_name(var, name);
+   nir_variable_set_name(shader, var, name);
    var->type = type;
    var->data.mode = mode;
    var->data.how_declared = nir_var_declared_normally;
@@ -403,7 +409,7 @@ nir_local_variable_create(nir_function_impl *impl,
                           const struct glsl_type *type, const char *name)
 {
    nir_variable *var = rzalloc(impl->function->shader, nir_variable);
-   nir_variable_set_name(var, name);
+   nir_variable_set_name(impl->function->shader, var, name);
    var->type = type;
    var->data.mode = nir_var_function_temp;
 
@@ -420,7 +426,7 @@ nir_state_variable_create(nir_shader *shader,
 {
    nir_variable *var = nir_variable_create(shader, nir_var_uniform, type, name);
    var->num_state_slots = 1;
-   var->state_slots = rzalloc_array(var, nir_state_slot, 1);
+   var->state_slots = rzalloc_array(shader, nir_state_slot, 1);
    memcpy(var->state_slots[0].tokens, tokens,
           sizeof(var->state_slots[0].tokens));
    shader->num_uniforms++;
diff --git a/src/compiler/nir/nir.h b/src/compiler/nir/nir.h
index d42c78385fdac..1c2ce687c3696 100644
--- a/src/compiler/nir/nir.h
+++ b/src/compiler/nir/nir.h
@@ -3951,10 +3951,14 @@ nir_function_impl_add_variable(nir_function_impl *impl, nir_variable *var)
    exec_list_push_tail(&impl->locals, &var->node);
 }
 
-void nir_variable_set_name(nir_variable *var, const char *name);
-void nir_variable_set_namef(nir_variable *var, const char *fmt, ...) PRINTFLIKE(2, 3);
-void nir_variable_append_namef(nir_variable *var, const char *fmt, ...) PRINTFLIKE(2, 3);
-void nir_variable_steal_name(nir_variable *dst, nir_variable *src);
+void nir_variable_set_name(nir_shader *nir, nir_variable *var,
+                           const char *name);
+void nir_variable_set_namef(nir_shader *nir, nir_variable *var,
+                            const char *fmt, ...) PRINTFLIKE(3, 4);
+void nir_variable_append_namef(nir_shader *nir, nir_variable *var,
+                               const char *fmt, ...) PRINTFLIKE(3, 4);
+void nir_variable_steal_name(nir_shader *nir, nir_variable *dst,
+                             nir_variable *src);
 
 /** creates a variable, sets a few defaults, and adds it to the list */
 nir_variable *nir_variable_create(nir_shader *shader,
@@ -4666,7 +4670,7 @@ nir_function_impl *
 nir_function_impl_clone_remap_globals(nir_shader *shader,
                                       const nir_function_impl *fi,
                                       struct hash_table *remap_table);
-nir_constant *nir_constant_clone(const nir_constant *c, nir_variable *var);
+nir_constant *nir_constant_clone(const nir_constant *c, void *mem_ctx);
 nir_variable *nir_variable_clone(const nir_variable *c, nir_shader *shader);
 
 void nir_shader_replace(nir_shader *dest, nir_shader *src);
diff --git a/src/compiler/nir/nir_clone.c b/src/compiler/nir/nir_clone.c
index d19c86c08a753..cda8e701e8871 100644
--- a/src/compiler/nir/nir_clone.c
+++ b/src/compiler/nir/nir_clone.c
@@ -126,18 +126,18 @@ remap_var(clone_state *state, const nir_variable *var)
 }
 
 nir_constant *
-nir_constant_clone(const nir_constant *c, nir_variable *nvar)
+nir_constant_clone(const nir_constant *c, void *mem_ctx)
 {
-   nir_constant *nc = ralloc(nvar, nir_constant);
+   nir_constant *nc = ralloc(mem_ctx, nir_constant);
 
    memcpy(nc->values, c->values, sizeof(nc->values));
    nc->is_null_constant = c->is_null_constant;
    nc->num_elements = c->num_elements;
 
    if (c->num_elements) {
-      nc->elements = ralloc_array(nvar, nir_constant *, c->num_elements);
+      nc->elements = ralloc_array(nc, nir_constant *, c->num_elements);
       for (unsigned i = 0; i < c->num_elements; i++)
-         nc->elements[i] = nir_constant_clone(c->elements[i], nvar);
+         nc->elements[i] = nir_constant_clone(c->elements[i], nc);
    } else {
       nc->elements = NULL;
    }
@@ -154,30 +154,30 @@ nir_variable_clone(const nir_variable *var, nir_shader *shader)
    nir_variable *nvar = rzalloc(shader, nir_variable);
 
    nvar->type = var->type;
-   nir_variable_set_name(nvar, var->name);
+   nir_variable_set_name(shader, nvar, var->name);
    nvar->data = var->data;
    nvar->num_state_slots = var->num_state_slots;
    if (var->num_state_slots) {
-      nvar->state_slots = ralloc_array(nvar, nir_state_slot, var->num_state_slots);
+      nvar->state_slots = ralloc_array(shader, nir_state_slot, var->num_state_slots);
       memcpy(nvar->state_slots, var->state_slots,
              var->num_state_slots * sizeof(nir_state_slot));
    }
    if (var->constant_initializer) {
       nvar->constant_initializer =
-         nir_constant_clone(var->constant_initializer, nvar);
+         nir_constant_clone(var->constant_initializer, shader);
    }
    nvar->interface_type = var->interface_type;
 
    if (var->max_ifc_array_access) {
       nvar->max_ifc_array_access =
-         rzalloc_array(nvar, int, var->interface_type->length);
+         rzalloc_array(shader, int, var->interface_type->length);
       memcpy(nvar->max_ifc_array_access, var->max_ifc_array_access,
              var->interface_type->length * sizeof(unsigned));
    }
 
    nvar->num_members = var->num_members;
    if (var->num_members) {
-      nvar->members = ralloc_array(nvar, struct nir_variable_data,
+      nvar->members = ralloc_array(shader, struct nir_variable_data,
                                    var->num_members);
       memcpy(nvar->members, var->members,
              var->num_members * sizeof(*var->members));
diff --git a/src/compiler/nir/nir_lower_clip.c b/src/compiler/nir/nir_lower_clip.c
index 263283b2d9ec2..c4076f547ddf1 100644
--- a/src/compiler/nir/nir_lower_clip.c
+++ b/src/compiler/nir/nir_lower_clip.c
@@ -54,7 +54,7 @@ create_clipdist_var(nir_shader *shader,
       var->data.mode = nir_var_shader_in;
       shader->num_inputs += MAX2(1, DIV_ROUND_UP(array_size, 4));
    }
-   nir_variable_set_namef(var, "clipdist_%d", slot - VARYING_SLOT_CLIP_DIST0);
+   nir_variable_set_namef(shader, var, "clipdist_%d", slot - VARYING_SLOT_CLIP_DIST0);
    var->data.index = 0;
    var->data.location = slot;
 
diff --git a/src/compiler/nir/nir_lower_clip_cull_distance_array_vars.c b/src/compiler/nir/nir_lower_clip_cull_distance_array_vars.c
index b12298cfcc0e9..562c27b3d6ec9 100644
--- a/src/compiler/nir/nir_lower_clip_cull_distance_array_vars.c
+++ b/src/compiler/nir/nir_lower_clip_cull_distance_array_vars.c
@@ -147,7 +147,7 @@ replace_var_declaration(struct lower_distance_state *state, nir_shader *sh,
       unsigned new_size = (state->total_size + 3) / 4;
 
       *new_var = rzalloc(sh, nir_variable);
-      nir_variable_set_name(*new_var, GLSL_CLIP_VAR_NAME);
+      nir_variable_set_name(sh, *new_var, GLSL_CLIP_VAR_NAME);
       (*new_var)->data.mode = var->data.mode;
       (*new_var)->data.location = VARYING_SLOT_CLIP_DIST0;
       (*new_var)->data.assigned = true;
diff --git a/src/compiler/nir/nir_lower_const_arrays_to_uniforms.c b/src/compiler/nir/nir_lower_const_arrays_to_uniforms.c
index b0cb2db483f94..7700b400fc45f 100644
--- a/src/compiler/nir/nir_lower_const_arrays_to_uniforms.c
+++ b/src/compiler/nir/nir_lower_const_arrays_to_uniforms.c
@@ -102,10 +102,10 @@ rebuild_const_array_initialiser(const struct glsl_type *type, void *mem_ctx)
       ret->num_elements = glsl_get_matrix_columns(type);
 
       if (ret->num_elements) {
-         ret->elements = ralloc_array(mem_ctx, nir_constant *, ret->num_elements);
+         ret->elements = ralloc_array(ret, nir_constant *, ret->num_elements);
 
          for (unsigned i = 0; i < ret->num_elements; i++) {
-            ret->elements[i] = rzalloc(mem_ctx, nir_constant);
+            ret->elements[i] = rzalloc(ret, nir_constant);
          }
       }
 
@@ -116,15 +116,15 @@ rebuild_const_array_initialiser(const struct glsl_type *type, void *mem_ctx)
       ret->num_elements = glsl_get_length(type);
 
       if (ret->num_elements) {
-         ret->elements = ralloc_array(mem_ctx, nir_constant *, ret->num_elements);
+         ret->elements = ralloc_array(ret, nir_constant *, ret->num_elements);
 
          for (unsigned i = 0; i < ret->num_elements; i++) {
             if (glsl_type_is_array(type)) {
                ret->elements[i] =
-                  rebuild_const_array_initialiser(glsl_get_array_element(type), mem_ctx);
+                  rebuild_const_array_initialiser(glsl_get_array_element(type), ret);
             } else {
                ret->elements[i] =
-                  rebuild_const_array_initialiser(glsl_get_struct_field(type, i), mem_ctx);
+                  rebuild_const_array_initialiser(glsl_get_struct_field(type, i), ret);
             }
          }
       }
@@ -171,7 +171,7 @@ lower_const_array_to_uniform(nir_shader *shader, struct var_info *info,
    nir_variable *uni = rzalloc(shader, nir_variable);
 
    /* Rebuild constant initialiser */
-   nir_constant *const_init = rebuild_const_array_initialiser(var->type, uni);
+   nir_constant *const_init = rebuild_const_array_initialiser(var->type, shader);
 
    /* Set constant initialiser */
    nir_function_impl *impl = nir_shader_get_entrypoint(shader);
@@ -207,7 +207,7 @@ lower_const_array_to_uniform(nir_shader *shader, struct var_info *info,
    uni->data.read_only = true;
    uni->data.mode = nir_var_uniform;
    uni->type = info->var->type;
-   nir_variable_set_namef(uni,"constarray_%x_%u",
+   nir_variable_set_namef(shader, uni,"constarray_%x_%u",
                           *const_count, shader->info.stage);
 
    nir_shader_add_variable(shader, uni);
diff --git a/src/compiler/nir/nir_lower_fragcolor.c b/src/compiler/nir/nir_lower_fragcolor.c
index 682efe0552517..d99a6b5174a3b 100644
--- a/src/compiler/nir/nir_lower_fragcolor.c
+++ b/src/compiler/nir/nir_lower_fragcolor.c
@@ -66,7 +66,7 @@ lower_fragcolor_intrin(nir_builder *b, nir_intrinsic_instr *instr, void *data)
    const char *name = out->data.index == 0 ? "gl_FragData[0]" : "gl_SecondaryFragDataEXT[0]";
    const char *name_tmpl = out->data.index == 0 ? "gl_FragData[%u]" : "gl_SecondaryFragDataEXT[%u]";
 
-   nir_variable_set_name(out, name);
+   nir_variable_set_name(b->shader, out, name);
 
    /* translate gl_FragColor -> gl_FragData since this is already handled */
    out->data.location = FRAG_RESULT_DATA0;
diff --git a/src/compiler/nir/nir_lower_io_vars_to_temporaries.c b/src/compiler/nir/nir_lower_io_vars_to_temporaries.c
index 87e419f2f9e62..9e64c502ae03c 100644
--- a/src/compiler/nir/nir_lower_io_vars_to_temporaries.c
+++ b/src/compiler/nir/nir_lower_io_vars_to_temporaries.c
@@ -305,13 +305,13 @@ create_shadow_temp(struct lower_io_state *state, nir_variable *var)
    nir_variable *temp = var;
 
    /* Reparent the name to the new variable */
-   nir_variable_steal_name(nvar, var);
+   nir_variable_steal_name(state->shader, nvar, var);
 
    assert(nvar->constant_initializer == NULL && nvar->pointer_initializer == NULL);
 
    /* Give the original a new name with @<mode>-temp appended */
    const char *mode = (temp->data.mode == nir_var_shader_in) ? "in" : "out";
-   nir_variable_set_namef(temp, "%s@%s-temp", mode, nvar->name);
+   nir_variable_set_namef(state->shader, temp, "%s@%s-temp", mode, nvar->name);
    temp->data.mode = nir_var_shader_temp;
    temp->data.read_only = false;
    temp->data.fb_fetch_output = false;
diff --git a/src/compiler/nir/nir_passthrough_gs.c b/src/compiler/nir/nir_passthrough_gs.c
index e38d176a19547..04194deea8075 100644
--- a/src/compiler/nir/nir_passthrough_gs.c
+++ b/src/compiler/nir/nir_passthrough_gs.c
@@ -174,7 +174,7 @@ nir_create_passthrough_gs(const nir_shader_compiler_options *options,
          snprintf(name, sizeof(name), "in_%d", var->data.driver_location);
 
       nir_variable *in = nir_variable_clone(var, nir);
-      nir_variable_set_name(in, name);
+      nir_variable_set_name(nir, in, name);
       in->type = glsl_array_type(var->type, 6, false);
       in->data.mode = nir_var_shader_in;
       nir_shader_add_variable(nir, in);
@@ -194,7 +194,7 @@ nir_create_passthrough_gs(const nir_shader_compiler_options *options,
          snprintf(name, sizeof(name), "out_%d", var->data.driver_location);
 
       nir_variable *out = nir_variable_clone(var, nir);
-      nir_variable_set_name(out, name);
+      nir_variable_set_name(nir, out, name);
       out->data.mode = nir_var_shader_out;
       nir_shader_add_variable(nir, out);
 
diff --git a/src/compiler/nir/nir_serialize.c b/src/compiler/nir/nir_serialize.c
index c02dc721b6bc3..cf09f979e9d01 100644
--- a/src/compiler/nir/nir_serialize.c
+++ b/src/compiler/nir/nir_serialize.c
@@ -187,18 +187,18 @@ write_constant(write_ctx *ctx, const nir_constant *c)
 }
 
 static nir_constant *
-read_constant(read_ctx *ctx, nir_variable *nvar)
+read_constant(read_ctx *ctx, void *mem_ctx)
 {
-   nir_constant *c = ralloc(nvar, nir_constant);
+   nir_constant *c = ralloc(mem_ctx, nir_constant);
 
    static const nir_const_value zero_vals[ARRAY_SIZE(c->values)] = { 0 };
    blob_copy_bytes(ctx->blob, (uint8_t *)c->values, sizeof(c->values));
    c->is_null_constant = memcmp(c->values, zero_vals, sizeof(c->values)) == 0;
    c->num_elements = blob_read_uint32(ctx->blob);
    if (c->num_elements) {
-      c->elements = ralloc_array(nvar, nir_constant *, c->num_elements);
+      c->elements = ralloc_array(c, nir_constant *, c->num_elements);
       for (unsigned i = 0; i < c->num_elements; i++) {
-         c->elements[i] = read_constant(ctx, nvar);
+         c->elements[i] = read_constant(ctx, c);
          c->is_null_constant &= c->elements[i]->is_null_constant;
       }
    }
@@ -363,7 +363,7 @@ read_variable(read_ctx *ctx)
 
    if (flags.u.has_name) {
       const char *name = blob_read_string(ctx->blob);
-      nir_variable_set_name(var, name);
+      nir_variable_set_name(ctx->nir, var, name);
    } else {
       var->name = NULL;
    }
@@ -387,7 +387,7 @@ read_variable(read_ctx *ctx)
 
    var->num_state_slots = flags.u.num_state_slots;
    if (var->num_state_slots != 0) {
-      var->state_slots = ralloc_array(var, nir_state_slot,
+      var->state_slots = ralloc_array(ctx->nir, nir_state_slot,
                                       var->num_state_slots);
       for (unsigned i = 0; i < var->num_state_slots; i++) {
          blob_copy_bytes(ctx->blob, &var->state_slots[i],
@@ -395,7 +395,7 @@ read_variable(read_ctx *ctx)
       }
    }
    if (flags.u.has_constant_initializer)
-      var->constant_initializer = read_constant(ctx, var);
+      var->constant_initializer = read_constant(ctx, ctx->nir);
    else
       var->constant_initializer = NULL;
 
@@ -406,7 +406,7 @@ read_variable(read_ctx *ctx)
 
    var->num_members = flags.u.num_members;
    if (var->num_members > 0) {
-      var->members = ralloc_array(var, struct nir_variable_data,
+      var->members = ralloc_array(ctx->nir, struct nir_variable_data,
                                   var->num_members);
       blob_copy_bytes(ctx->blob, (uint8_t *)var->members,
                       var->num_members * sizeof(*var->members));
diff --git a/src/compiler/nir/nir_split_vars.c b/src/compiler/nir/nir_split_vars.c
index b7afdd30b0bea..2d058214079e3 100644
--- a/src/compiler/nir/nir_split_vars.c
+++ b/src/compiler/nir/nir_split_vars.c
@@ -120,28 +120,31 @@ gather_constant_initializers(nir_constant *src,
                              nir_variable *var,
                              const struct glsl_type *type,
                              struct field *field,
-                             struct split_var_state *state)
+                             void *mem_ctx)
 {
    if (!src)
       return NULL;
    if (glsl_type_is_array(type)) {
       const struct glsl_type *element = glsl_get_array_element(type);
       assert(src->num_elements == glsl_get_length(type));
-      nir_constant *dst = rzalloc(var, nir_constant);
+      nir_constant *dst = rzalloc(mem_ctx, nir_constant);
       dst->num_elements = src->num_elements;
       if (dst->num_elements) {
-         dst->elements = rzalloc_array(var, nir_constant *, src->num_elements);
+         dst->elements = rzalloc_array(dst, nir_constant *, src->num_elements);
          for (unsigned i = 0; i < src->num_elements; ++i) {
             dst->elements[i] = gather_constant_initializers(src->elements[i], var,
-                                                            element, field, state);
+                                                            element, field, dst);
          }
       }
       return dst;
    } else if (glsl_type_is_struct(type)) {
       const struct glsl_type *element = glsl_get_struct_field(type, field->current_index);
-      return gather_constant_initializers(src->elements[field->current_index], var, element, &field->fields[field->current_index], state);
+      return gather_constant_initializers(src->elements[field->current_index],
+                                          var, element,
+                                          &field->fields[field->current_index],
+                                          mem_ctx);
    } else {
-      return nir_constant_clone(src, var);
+      return nir_constant_clone(src, mem_ctx);
    }
 }
 
@@ -193,7 +196,7 @@ init_field_for_type(struct field *field, struct field *parent,
       field->var->data.ray_query = state->base_var->data.ray_query;
       field->var->constant_initializer = gather_constant_initializers(state->base_var->constant_initializer,
                                                                       field->var, state->base_var->type,
-                                                                      root, state);
+                                                                      root, state->shader);
    }
 }
 
diff --git a/src/compiler/nir/nir_sweep.c b/src/compiler/nir/nir_sweep.c
index 8716ba907682e..c64bde183f2bd 100644
--- a/src/compiler/nir/nir_sweep.c
+++ b/src/compiler/nir/nir_sweep.c
@@ -36,10 +36,42 @@
  * earlier, and even many times, trading CPU cycles for memory savings.
  */
 
-#define steal_list(mem_ctx, type, list)        \
-   foreach_list_typed(type, obj, node, list) { \
-      ralloc_steal(mem_ctx, obj);              \
+static void
+sweep_constant(nir_shader *nir, nir_constant *c)
+{
+   ralloc_steal(nir, c);
+
+   if (c->num_elements) {
+      assert(c->elements);
+      ralloc_steal(nir, c->elements);
+      for (unsigned i = 0; i < c->num_elements; i++)
+         sweep_constant(nir, c->elements[i]);
+   } else {
+      assert(!c->elements);
+   }
+}
+
+static void
+sweep_variable(nir_shader *nir, nir_variable *var)
+{
+   ralloc_steal(nir, var);
+   nir_variable_steal_name(nir, var, var);
+   ralloc_steal(nir, var->max_ifc_array_access);
+   ralloc_steal(nir, var->state_slots);
+   if (var->constant_initializer)
+      sweep_constant(nir, var->constant_initializer);
+   if (var->pointer_initializer)
+      sweep_variable(nir, var->pointer_initializer);
+   ralloc_steal(nir, var->members);
+}
+
+static void
+sweep_var_list(nir_shader *nir, struct exec_list *list)
+{
+   foreach_list_typed(nir_variable, var, node, list) {
+      sweep_variable(nir, var);
    }
+}
 
 static void sweep_cf_node(nir_shader *nir, nir_cf_node *cf_node);
 
@@ -122,7 +154,7 @@ sweep_impl(nir_shader *nir, nir_function_impl *impl)
 {
    ralloc_steal(nir, impl);
 
-   steal_list(nir, nir_variable, &impl->locals);
+   sweep_var_list(nir, &impl->locals);
 
    foreach_list_typed(nir_cf_node, cf_node, node, &impl->body) {
       sweep_cf_node(nir, cf_node);
@@ -167,7 +199,7 @@ nir_sweep(nir_shader *nir)
       ralloc_steal(nir, (char *)nir->info.label);
 
    /* Variables are not dead.  Steal them back. */
-   steal_list(nir, nir_variable, &nir->variables);
+   sweep_var_list(nir, &nir->variables);
 
    /* Recurse into functions, stealing their contents back. */
    foreach_list_typed(nir_function, func, node, &nir->functions) {
diff --git a/src/compiler/spirv/spirv_to_nir.c b/src/compiler/spirv/spirv_to_nir.c
index 323867d1421a4..9f94bdd882b2e 100644
--- a/src/compiler/spirv/spirv_to_nir.c
+++ b/src/compiler/spirv/spirv_to_nir.c
@@ -2710,8 +2710,7 @@ vtn_handle_constant(struct vtn_builder *b, SpvOp opcode,
          } else {
             comp = vtn_value(b, w[5], vtn_value_type_constant);
             deref_start = 6;
-            val->constant = nir_constant_clone(comp->constant,
-                                               (nir_variable *)b);
+            val->constant = nir_constant_clone(comp->constant, b->shader);
             c = &val->constant;
          }
 
diff --git a/src/compiler/spirv/vtn_variables.c b/src/compiler/spirv/vtn_variables.c
index 9b613f2439185..717b390882fac 100644
--- a/src/compiler/spirv/vtn_variables.c
+++ b/src/compiler/spirv/vtn_variables.c
@@ -2183,7 +2183,7 @@ vtn_create_variable(struct vtn_builder *b, struct vtn_value *val,
    case vtn_variable_mode_node_payload:
       /* For these, we create the variable normally */
       var->var = rzalloc(b->shader, nir_variable);
-      nir_variable_set_name(var->var, val->name);
+      nir_variable_set_name(b->shader, var->var, val->name);
       var->var->type = vtn_type_get_nir_type(b, var->type, var->mode);
 
       /* This is a total hack but we need some way to flag variables which are
@@ -2205,7 +2205,7 @@ vtn_create_variable(struct vtn_builder *b, struct vtn_value *val,
    case vtn_variable_mode_accel_struct:
    case vtn_variable_mode_shader_record:
       var->var = rzalloc(b->shader, nir_variable);
-      nir_variable_set_name(var->var, val->name);
+      nir_variable_set_name(b->shader, var->var, val->name);
 
       var->var->type = vtn_type_get_nir_type(b, var->type, var->mode);
       var->var->interface_type = var->var->type;
@@ -2221,7 +2221,7 @@ vtn_create_variable(struct vtn_builder *b, struct vtn_value *val,
    case vtn_variable_mode_task_payload:
       /* Create the variable normally */
       var->var = rzalloc(b->shader, nir_variable);
-      nir_variable_set_name(var->var, val->name);
+      nir_variable_set_name(b->shader, var->var, val->name);
       var->var->type = vtn_type_get_nir_type(b, var->type, var->mode);
       var->var->data.mode = nir_mode;
       if (var->mode == vtn_variable_mode_workgroup &&
@@ -2232,7 +2232,7 @@ vtn_create_variable(struct vtn_builder *b, struct vtn_value *val,
    case vtn_variable_mode_input:
    case vtn_variable_mode_output: {
       var->var = rzalloc(b->shader, nir_variable);
-      nir_variable_set_name(var->var, val->name);
+      nir_variable_set_name(b->shader, var->var, val->name);
       var->var->type = vtn_type_get_nir_type(b, var->type, var->mode);
       var->var->data.mode = nir_mode;
 
@@ -2293,7 +2293,7 @@ vtn_create_variable(struct vtn_builder *b, struct vtn_value *val,
       if (per_vertex_type->base_type == vtn_base_type_struct &&
           per_vertex_type->block) {
          var->var->num_members = glsl_get_length(per_vertex_type->type);
-         var->var->members = rzalloc_array(var->var, struct nir_variable_data,
+         var->var->members = rzalloc_array(b->shader, struct nir_variable_data,
                                            var->var->num_members);
 
          for (unsigned i = 0; i < var->var->num_members; i++) {
@@ -2399,7 +2399,7 @@ vtn_create_variable(struct vtn_builder *b, struct vtn_value *val,
       switch (initializer->value_type) {
       case vtn_value_type_constant:
          var->var->constant_initializer =
-            nir_constant_clone(initializer->constant, var->var);
+            nir_constant_clone(initializer->constant, b->shader);
          break;
       case vtn_value_type_pointer:
          var->var->pointer_initializer = initializer->pointer->var->var;
diff --git a/src/freedreno/ir3/ir3_nir_lower_tess.c b/src/freedreno/ir3/ir3_nir_lower_tess.c
index ab7765017d455..905619028cf7f 100644
--- a/src/freedreno/ir3/ir3_nir_lower_tess.c
+++ b/src/freedreno/ir3/ir3_nir_lower_tess.c
@@ -1030,14 +1030,14 @@ ir3_nir_lower_gs(nir_shader *shader)
       exec_list_push_tail(&state.new_outputs, &output->node);
 
       /* Rewrite the original output to be a shadow variable. */
-      nir_variable_set_namef(var, "%s@gs-temp", output->name);
+      nir_variable_set_namef(shader, var, "%s@gs-temp", output->name);
       var->data.mode = nir_var_shader_temp;
 
       /* Clone the shadow variable to create the emit shadow variable that
        * we'll assign in the emit conditionals.
        */
       nir_variable *emit_output = nir_variable_clone(var, shader);
-      nir_variable_set_namef(emit_output, "%s@emit-temp", output->name);
+      nir_variable_set_namef(shader, emit_output, "%s@emit-temp", output->name);
       exec_list_push_tail(&state.emit_outputs, &emit_output->node);
    }
 
diff --git a/src/gallium/auxiliary/nir/tgsi_to_nir.c b/src/gallium/auxiliary/nir/tgsi_to_nir.c
index 08cc06e336ee0..81999005890dc 100644
--- a/src/gallium/auxiliary/nir/tgsi_to_nir.c
+++ b/src/gallium/auxiliary/nir/tgsi_to_nir.c
@@ -301,7 +301,7 @@ ttn_emit_declaration(struct ttn_compile *c)
          case TGSI_FILE_INPUT:
             var->data.read_only = true;
             var->data.mode = nir_var_shader_in;
-            nir_variable_set_namef(var, "in_%d", idx);
+            nir_variable_set_namef(b->shader, var, "in_%d", idx);
 
             if (c->scan->processor == PIPE_SHADER_FRAGMENT) {
                if (decl->Semantic.Name == TGSI_SEMANTIC_FACE) {
@@ -359,7 +359,7 @@ ttn_emit_declaration(struct ttn_compile *c)
                                             is_array ? array_size : 0);
 
             var->data.mode = nir_var_shader_out;
-            nir_variable_set_namef(var, "out_%d", idx);
+            nir_variable_set_namef(b->shader, var, "out_%d", idx);
             var->data.index = 0;
             var->data.interpolation =
                ttn_translate_interp_mode(decl->Interp.Interpolate);
@@ -446,7 +446,7 @@ ttn_emit_declaration(struct ttn_compile *c)
             break;
          case TGSI_FILE_CONSTANT:
             var->data.mode = nir_var_uniform;
-            nir_variable_set_namef(var, "uniform_%d", idx);
+            nir_variable_set_namef(b->shader, var, "uniform_%d", idx);
             var->data.location = idx;
             break;
          default:
diff --git a/src/gallium/drivers/zink/zink_compiler.c b/src/gallium/drivers/zink/zink_compiler.c
index 5e8c8e371ce8a..59d12dc59d520 100644
--- a/src/gallium/drivers/zink/zink_compiler.c
+++ b/src/gallium/drivers/zink/zink_compiler.c
@@ -1111,7 +1111,7 @@ zink_create_quads_emulation_gs(const nir_shader_compiler_options *options,
          snprintf(name, sizeof(name), "in_%d", var->data.driver_location);
 
       nir_variable *in = nir_variable_clone(var, nir);
-      nir_variable_set_name(in, name);
+      nir_variable_set_name(nir, in, name);
       in->type = glsl_array_type(var->type, 4, false);
       in->data.mode = nir_var_shader_in;
       nir_shader_add_variable(nir, in);
@@ -1122,7 +1122,7 @@ zink_create_quads_emulation_gs(const nir_shader_compiler_options *options,
          snprintf(name, sizeof(name), "out_%d", var->data.driver_location);
 
       nir_variable *out = nir_variable_clone(var, nir);
-      nir_variable_set_name(out, name);
+      nir_variable_set_name(nir, out, name);
       out->data.mode = nir_var_shader_out;
       nir_shader_add_variable(nir, out);
 
@@ -2061,7 +2061,7 @@ decompose_attribs(nir_shader *nir, uint32_t decomposed_attrs, uint32_t decompose
       state.needs_w = (decomposed_attrs_without_w & BITFIELD_BIT(location)) != 0 && num_components == 4;
       for (unsigned i = 0; i < (state.needs_w ? num_components - 1 : num_components); i++) {
          split[i+1] = nir_variable_clone(var, nir);
-         nir_variable_set_namef(split[i+1], "%s_split%u", var->name, i);
+         nir_variable_set_namef(nir, split[i+1], "%s_split%u", var->name, i);
          if (decomposed_attrs_without_w & BITFIELD_BIT(location))
             split[i+1]->type = !i && num_components == 4 ? var->type : new_type;
          else
@@ -2220,9 +2220,9 @@ get_bo_var(nir_shader *shader, struct bo_vars *bo, bool ssbo, nir_src *src, unsi
       }
       var = nir_variable_clone(var, shader);
       if (ssbo)
-         nir_variable_set_namef(var, "%s@%u", "ssbos", bit_size);
+         nir_variable_set_namef(shader, var, "%s@%u", "ssbos", bit_size);
       else
-         nir_variable_set_namef(var, "%s@%u", idx ? "ubos" : "uniform_0", bit_size);
+         nir_variable_set_namef(shader, var, "%s@%u", idx ? "ubos" : "uniform_0", bit_size);
       *ptr = var;
       nir_shader_add_variable(shader, var);
 
diff --git a/src/intel/compiler/brw_compile_mesh.cpp b/src/intel/compiler/brw_compile_mesh.cpp
index babaf270a4d26..771732e0c6edc 100644
--- a/src/intel/compiler/brw_compile_mesh.cpp
+++ b/src/intel/compiler/brw_compile_mesh.cpp
@@ -269,7 +269,7 @@ brw_nir_lower_mesh_primitive_count(nir_shader *nir)
          nir_create_variable_with_location(nir, nir_var_shader_out,
                                            VARYING_SLOT_PRIMITIVE_COUNT,
                                            glsl_uint_type());
-      nir_variable_set_name(final_primitive_count, "gl_PrimitiveCountNV");
+      nir_variable_set_name(nir, final_primitive_count, "gl_PrimitiveCountNV");
       final_primitive_count->data.interpolation = INTERP_MODE_NONE;
 
       nir_store_var(b, final_primitive_count,
diff --git a/src/mesa/main/ff_fragment_shader.c b/src/mesa/main/ff_fragment_shader.c
index e1c10b3617b65..1fb75fce1a856 100644
--- a/src/mesa/main/ff_fragment_shader.c
+++ b/src/mesa/main/ff_fragment_shader.c
@@ -365,7 +365,7 @@ register_state_var(struct texenv_fragment_program *p,
    free(name);
 
    var->num_state_slots = 1;
-   var->state_slots = ralloc_array(var, nir_state_slot, 1);
+   var->state_slots = ralloc_array(p->b->shader, nir_state_slot, 1);
    var->data.driver_location = loc;
    memcpy(var->state_slots[0].tokens, tokens,
           sizeof(var->state_slots[0].tokens));
diff --git a/src/microsoft/compiler/dxil_nir.c b/src/microsoft/compiler/dxil_nir.c
index 4dfd6474954f9..1e31fcd91a5f0 100644
--- a/src/microsoft/compiler/dxil_nir.c
+++ b/src/microsoft/compiler/dxil_nir.c
@@ -359,11 +359,12 @@ flatten_var_arrays(nir_builder *b, nir_intrinsic_instr *intr, void *data)
 }
 
 static void
-flatten_constant_initializer(nir_variable *var, nir_constant *src, nir_constant ***dest, unsigned vector_elements)
+flatten_constant_initializer(nir_shader *nir, nir_constant *src, nir_constant ***dest,
+                             unsigned vector_elements)
 {
    if (src->num_elements == 0) {
       for (unsigned i = 0; i < vector_elements; ++i) {
-         nir_constant *new_scalar = rzalloc(var, nir_constant);
+         nir_constant *new_scalar = rzalloc(nir, nir_constant);
          memcpy(&new_scalar->values[0], &src->values[i], sizeof(src->values[0]));
          new_scalar->is_null_constant = src->values[i].u64 == 0;
 
@@ -372,12 +373,12 @@ flatten_constant_initializer(nir_variable *var, nir_constant *src, nir_constant
       }
    } else {
       for (unsigned i = 0; i < src->num_elements; ++i)
-         flatten_constant_initializer(var, src->elements[i], dest, vector_elements);
+         flatten_constant_initializer(nir, src->elements[i], dest, vector_elements);
    }
 }
 
 static bool
-flatten_var_array_types(nir_variable *var)
+flatten_var_array_types(nir_shader *nir, nir_variable *var)
 {
    assert(!glsl_type_is_struct(glsl_without_array(var->type)));
    const struct glsl_type *matrix_type = glsl_without_array(var->type);
@@ -389,9 +390,9 @@ flatten_var_array_types(nir_variable *var)
                                                             glsl_get_component_slots(var->type), 0);
    var->type = flattened_type;
    if (var->constant_initializer) {
-      nir_constant **new_elements = ralloc_array(var, nir_constant *, glsl_get_length(flattened_type));
+      nir_constant **new_elements = ralloc_array(nir, nir_constant *, glsl_get_length(flattened_type));
       nir_constant **temp = new_elements;
-      flatten_constant_initializer(var, var->constant_initializer, &temp, glsl_get_vector_elements(matrix_type));
+      flatten_constant_initializer(nir, var->constant_initializer, &temp, glsl_get_vector_elements(matrix_type));
       var->constant_initializer->num_elements = glsl_get_length(flattened_type);
       var->constant_initializer->elements = new_elements;
    }
@@ -403,12 +404,12 @@ dxil_nir_flatten_var_arrays(nir_shader *shader, nir_variable_mode modes)
 {
    bool progress = false;
    nir_foreach_variable_with_modes(var, shader, modes & ~nir_var_function_temp)
-      progress |= flatten_var_array_types(var);
+      progress |= flatten_var_array_types(shader, var);
 
    if (modes & nir_var_function_temp) {
       nir_foreach_function_impl(impl, shader) {
          nir_foreach_function_temp_variable(var, impl)
-            progress |= flatten_var_array_types(var);
+            progress |= flatten_var_array_types(shader, var);
       }
    }
 
@@ -495,7 +496,7 @@ lower_deref_bit_size(nir_builder *b, nir_intrinsic_instr *intr, void *data)
 }
 
 static bool
-lower_var_bit_size_types(nir_variable *var, unsigned min_bit_size, unsigned max_bit_size)
+lower_var_bit_size_types(nir_shader *nir, nir_variable *var, unsigned min_bit_size, unsigned max_bit_size)
 {
    assert(!glsl_type_is_array_of_arrays(var->type) && !glsl_type_is_struct(var->type));
    const struct glsl_type *type = glsl_without_array(var->type);
@@ -559,8 +560,8 @@ lower_var_bit_size_types(nir_variable *var, unsigned min_bit_size, unsigned max_
       if (var->constant_initializer) {
          unsigned num_elements = var->constant_initializer->num_elements ?
             var->constant_initializer->num_elements * 2 : 2;
-         nir_constant **element_arr = ralloc_array(var, nir_constant *, num_elements);
-         nir_constant *elements = rzalloc_array(var, nir_constant, num_elements);
+         nir_constant **element_arr = ralloc_array(nir, nir_constant *, num_elements);
+         nir_constant *elements = rzalloc_array(nir, nir_constant, num_elements);
          for (unsigned i = 0; i < var->constant_initializer->num_elements; ++i) {
             element_arr[i*2] = &elements[i*2];
             element_arr[i*2+1] = &elements[i*2+1];
@@ -585,12 +586,12 @@ dxil_nir_lower_var_bit_size(nir_shader *shader, nir_variable_mode modes,
 {
    bool progress = false;
    nir_foreach_variable_with_modes(var, shader, modes & ~nir_var_function_temp)
-      progress |= lower_var_bit_size_types(var, min_bit_size, max_bit_size);
+      progress |= lower_var_bit_size_types(shader, var, min_bit_size, max_bit_size);
 
    if (modes & nir_var_function_temp) {
       nir_foreach_function_impl(impl, shader) {
          nir_foreach_function_temp_variable(var, impl)
-            progress |= lower_var_bit_size_types(var, min_bit_size, max_bit_size);
+            progress |= lower_var_bit_size_types(shader, var, min_bit_size, max_bit_size);
       }
    }
 
diff --git a/src/microsoft/compiler/nir_to_dxil.c b/src/microsoft/compiler/nir_to_dxil.c
index 5cd5d30b8328a..8a193d29784af 100644
--- a/src/microsoft/compiler/nir_to_dxil.c
+++ b/src/microsoft/compiler/nir_to_dxil.c
@@ -1494,7 +1494,7 @@ emit_global_consts(struct ntd_context *ctx)
 
    nir_foreach_variable_with_modes(var, ctx->shader, nir_var_mem_constant) {
       if (!var->name)
-         nir_variable_set_namef(var, "const_%d", var->data.driver_location);
+         nir_variable_set_namef(ctx->shader, var, "const_%d", var->data.driver_location);
 
       const struct dxil_value *agg_vals =
          get_value_for_const_aggregate(&ctx->mod, var->constant_initializer, var->type);
@@ -1525,7 +1525,7 @@ emit_shared_vars(struct ntd_context *ctx)
 
    nir_foreach_variable_with_modes(var, ctx->shader, nir_var_mem_shared) {
       if (!var->name)
-         nir_variable_set_namef(var, "shared_%d", var->data.driver_location);
+         nir_variable_set_namef(ctx->shader, var, "shared_%d", var->data.driver_location);
       const struct dxil_value *gvar = dxil_add_global_ptr_var(&ctx->mod, var->name,
                                                               get_type_for_glsl_type(&ctx->mod, var->type),
                                                               DXIL_AS_GROUPSHARED, 16,
-- 
GitLab


From 1a7350cdf3abfe3a86255a7d564220ef03e7957c Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Fri, 1 Aug 2025 22:59:07 -0400
Subject: [PATCH 6/7] nir: add nir_variable_create_zeroed helper

This will allow us to switch nir_variable from ralloc to gc_ctx,
which uses a slab allocator.

Reviewed-by: Timothy Arceri <tarceri@itsqueeze.com>
---
 .../glsl/gl_nir_lower_blend_equation_advanced.c        |  2 +-
 src/compiler/glsl/gl_nir_lower_discard_flow.c          |  2 +-
 .../glsl/gl_nir_lower_named_interface_blocks.c         |  2 +-
 src/compiler/glsl/gl_nir_lower_packed_varyings.c       |  2 +-
 src/compiler/glsl/gl_nir_lower_xfb_varying.c           |  2 +-
 src/compiler/glsl/glsl_to_nir.cpp                      |  2 +-
 src/compiler/nir/nir.c                                 | 10 ++++++++--
 src/compiler/nir/nir.h                                 |  1 +
 src/compiler/nir/nir_clone.c                           |  2 +-
 src/compiler/nir/nir_lower_clip.c                      |  2 +-
 .../nir/nir_lower_clip_cull_distance_array_vars.c      |  2 +-
 src/compiler/nir/nir_lower_const_arrays_to_uniforms.c  |  2 +-
 src/compiler/nir/nir_lower_io_vars_to_temporaries.c    |  2 +-
 src/compiler/nir/nir_serialize.c                       |  2 +-
 src/compiler/spirv/spirv_to_nir.c                      |  2 +-
 src/compiler/spirv/vtn_variables.c                     |  8 ++++----
 src/gallium/auxiliary/nir/tgsi_to_nir.c                |  2 +-
 src/microsoft/compiler/nir_to_dxil.c                   |  2 +-
 18 files changed, 28 insertions(+), 21 deletions(-)

diff --git a/src/compiler/glsl/gl_nir_lower_blend_equation_advanced.c b/src/compiler/glsl/gl_nir_lower_blend_equation_advanced.c
index 999eb7907f76e..e7cd2ba9ab2ee 100644
--- a/src/compiler/glsl/gl_nir_lower_blend_equation_advanced.c
+++ b/src/compiler/glsl/gl_nir_lower_blend_equation_advanced.c
@@ -216,7 +216,7 @@ satv3(nir_builder *b, nir_def *c)
 static nir_variable *
 add_temp_var(nir_builder *b, char *name, const struct glsl_type *type)
 {
-   nir_variable *var = rzalloc(b->shader, nir_variable);
+   nir_variable *var = nir_variable_create_zeroed(b->shader);
    var->type = type;
    nir_variable_set_name(b->shader, var, name);
    var->data.mode = nir_var_function_temp;
diff --git a/src/compiler/glsl/gl_nir_lower_discard_flow.c b/src/compiler/glsl/gl_nir_lower_discard_flow.c
index 8f542af687e71..f4f9f63fa00da 100644
--- a/src/compiler/glsl/gl_nir_lower_discard_flow.c
+++ b/src/compiler/glsl/gl_nir_lower_discard_flow.c
@@ -135,7 +135,7 @@ gl_nir_lower_discard_flow(nir_shader *shader)
 {
    nir_function_impl *main = nir_shader_get_entrypoint(shader);
 
-   nir_variable *discarded = rzalloc(shader, nir_variable);
+   nir_variable *discarded = nir_variable_create_zeroed(shader);
    nir_variable_set_name(shader, discarded, "discarded");
    discarded->type = glsl_bool_type();
    discarded->data.mode = nir_var_shader_temp;
diff --git a/src/compiler/glsl/gl_nir_lower_named_interface_blocks.c b/src/compiler/glsl/gl_nir_lower_named_interface_blocks.c
index 129e342519253..00222adde377c 100644
--- a/src/compiler/glsl/gl_nir_lower_named_interface_blocks.c
+++ b/src/compiler/glsl/gl_nir_lower_named_interface_blocks.c
@@ -269,7 +269,7 @@ lower_named_interface_blocks(struct gl_linked_shader *sh)
             const struct glsl_struct_field *field_data =
                glsl_get_struct_field_data(iface_t, i);
 
-            nir_variable *new_var = rzalloc(sh->Program->nir, nir_variable);
+            nir_variable *new_var = nir_variable_create_zeroed(sh->Program->nir);
             nir_variable_set_name(sh->Program->nir, new_var, field_name);
             if (!glsl_type_is_array(var->type)) {
                new_var->type =  glsl_get_struct_field(iface_t, i);
diff --git a/src/compiler/glsl/gl_nir_lower_packed_varyings.c b/src/compiler/glsl/gl_nir_lower_packed_varyings.c
index 8534440897c0f..659eb58efb42f 100644
--- a/src/compiler/glsl/gl_nir_lower_packed_varyings.c
+++ b/src/compiler/glsl/gl_nir_lower_packed_varyings.c
@@ -270,7 +270,7 @@ create_or_update_packed_varying(struct lower_packed_varyings_state *state,
       assert(state->components[slot] != 0);
       assert(name);
 
-      nir_variable *packed_var = rzalloc(state->shader, nir_variable);
+      nir_variable *packed_var = nir_variable_create_zeroed(state->shader);
       nir_variable_set_namef(state->shader, packed_var, "packed:%s", name);
       packed_var->data.mode = state->mode;
 
diff --git a/src/compiler/glsl/gl_nir_lower_xfb_varying.c b/src/compiler/glsl/gl_nir_lower_xfb_varying.c
index 4469362c5f0d9..e4ba65ce01756 100644
--- a/src/compiler/glsl/gl_nir_lower_xfb_varying.c
+++ b/src/compiler/glsl/gl_nir_lower_xfb_varying.c
@@ -162,7 +162,7 @@ gl_nir_lower_xfb_varying(nir_shader *shader, const char *old_var_name,
    if (!get_deref(&b, old_var_name, toplevel_var, &deref, &type))
       return NULL;
 
-   nir_variable *new_variable = rzalloc(shader, nir_variable);
+   nir_variable *new_variable = nir_variable_create_zeroed(shader);
    new_variable->name = generate_new_name(new_variable, old_var_name);
    new_variable->type = type;
    new_variable->data.mode = nir_var_shader_out;
diff --git a/src/compiler/glsl/glsl_to_nir.cpp b/src/compiler/glsl/glsl_to_nir.cpp
index fe5337d7521c7..a2e6f42d4e49f 100644
--- a/src/compiler/glsl/glsl_to_nir.cpp
+++ b/src/compiler/glsl/glsl_to_nir.cpp
@@ -445,7 +445,7 @@ nir_visitor::visit(ir_variable *ir)
    if (ir->data.mode == ir_var_function_out)
       return;
 
-   nir_variable *var = rzalloc(shader, nir_variable);
+   nir_variable *var = nir_variable_create_zeroed(shader);
    var->type = ir->type;
    nir_variable_set_name(shader, var, ir->name);
 
diff --git a/src/compiler/nir/nir.c b/src/compiler/nir/nir.c
index 24e721a071d47..d49f4f2c2ed92 100644
--- a/src/compiler/nir/nir.c
+++ b/src/compiler/nir/nir.c
@@ -268,6 +268,12 @@ nir_shader_add_variable(nir_shader *shader, nir_variable *var)
    exec_list_push_tail(&shader->variables, &var->node);
 }
 
+nir_variable *
+nir_variable_create_zeroed(nir_shader *nir)
+{
+   return rzalloc(nir, nir_variable);
+}
+
 void
 nir_variable_set_name(nir_shader *nir, nir_variable *var, const char *name)
 {
@@ -383,7 +389,7 @@ nir_variable *
 nir_variable_create(nir_shader *shader, nir_variable_mode mode,
                     const struct glsl_type *type, const char *name)
 {
-   nir_variable *var = rzalloc(shader, nir_variable);
+   nir_variable *var = nir_variable_create_zeroed(shader);
    nir_variable_set_name(shader, var, name);
    var->type = type;
    var->data.mode = mode;
@@ -408,7 +414,7 @@ nir_variable *
 nir_local_variable_create(nir_function_impl *impl,
                           const struct glsl_type *type, const char *name)
 {
-   nir_variable *var = rzalloc(impl->function->shader, nir_variable);
+   nir_variable *var = nir_variable_create_zeroed(impl->function->shader);
    nir_variable_set_name(impl->function->shader, var, name);
    var->type = type;
    var->data.mode = nir_var_function_temp;
diff --git a/src/compiler/nir/nir.h b/src/compiler/nir/nir.h
index 1c2ce687c3696..918a740216ebe 100644
--- a/src/compiler/nir/nir.h
+++ b/src/compiler/nir/nir.h
@@ -3951,6 +3951,7 @@ nir_function_impl_add_variable(nir_function_impl *impl, nir_variable *var)
    exec_list_push_tail(&impl->locals, &var->node);
 }
 
+nir_variable *nir_variable_create_zeroed(nir_shader *nir);
 void nir_variable_set_name(nir_shader *nir, nir_variable *var,
                            const char *name);
 void nir_variable_set_namef(nir_shader *nir, nir_variable *var,
diff --git a/src/compiler/nir/nir_clone.c b/src/compiler/nir/nir_clone.c
index cda8e701e8871..9e1819c8ec395 100644
--- a/src/compiler/nir/nir_clone.c
+++ b/src/compiler/nir/nir_clone.c
@@ -151,7 +151,7 @@ nir_constant_clone(const nir_constant *c, void *mem_ctx)
 nir_variable *
 nir_variable_clone(const nir_variable *var, nir_shader *shader)
 {
-   nir_variable *nvar = rzalloc(shader, nir_variable);
+   nir_variable *nvar = nir_variable_create_zeroed(shader);
 
    nvar->type = var->type;
    nir_variable_set_name(shader, nvar, var->name);
diff --git a/src/compiler/nir/nir_lower_clip.c b/src/compiler/nir/nir_lower_clip.c
index c4076f547ddf1..04a83bcb2c430 100644
--- a/src/compiler/nir/nir_lower_clip.c
+++ b/src/compiler/nir/nir_lower_clip.c
@@ -43,7 +43,7 @@ static nir_variable *
 create_clipdist_var(nir_shader *shader,
                     bool output, gl_varying_slot slot, unsigned array_size)
 {
-   nir_variable *var = rzalloc(shader, nir_variable);
+   nir_variable *var = nir_variable_create_zeroed(shader);
 
    if (output) {
       var->data.driver_location = shader->num_outputs;
diff --git a/src/compiler/nir/nir_lower_clip_cull_distance_array_vars.c b/src/compiler/nir/nir_lower_clip_cull_distance_array_vars.c
index 562c27b3d6ec9..941908b8c06a0 100644
--- a/src/compiler/nir/nir_lower_clip_cull_distance_array_vars.c
+++ b/src/compiler/nir/nir_lower_clip_cull_distance_array_vars.c
@@ -146,7 +146,7 @@ replace_var_declaration(struct lower_distance_state *state, nir_shader *sh,
    if (!(*new_var)) {
       unsigned new_size = (state->total_size + 3) / 4;
 
-      *new_var = rzalloc(sh, nir_variable);
+      *new_var = nir_variable_create_zeroed(sh);
       nir_variable_set_name(sh, *new_var, GLSL_CLIP_VAR_NAME);
       (*new_var)->data.mode = var->data.mode;
       (*new_var)->data.location = VARYING_SLOT_CLIP_DIST0;
diff --git a/src/compiler/nir/nir_lower_const_arrays_to_uniforms.c b/src/compiler/nir/nir_lower_const_arrays_to_uniforms.c
index 7700b400fc45f..8faf867d0aa9d 100644
--- a/src/compiler/nir/nir_lower_const_arrays_to_uniforms.c
+++ b/src/compiler/nir/nir_lower_const_arrays_to_uniforms.c
@@ -168,7 +168,7 @@ lower_const_array_to_uniform(nir_shader *shader, struct var_info *info,
    if (*const_count == limit)
       return false;
 
-   nir_variable *uni = rzalloc(shader, nir_variable);
+   nir_variable *uni = nir_variable_create_zeroed(shader);
 
    /* Rebuild constant initialiser */
    nir_constant *const_init = rebuild_const_array_initialiser(var->type, shader);
diff --git a/src/compiler/nir/nir_lower_io_vars_to_temporaries.c b/src/compiler/nir/nir_lower_io_vars_to_temporaries.c
index 9e64c502ae03c..a455d5cdda2bd 100644
--- a/src/compiler/nir/nir_lower_io_vars_to_temporaries.c
+++ b/src/compiler/nir/nir_lower_io_vars_to_temporaries.c
@@ -297,7 +297,7 @@ emit_input_copies_impl(struct lower_io_state *state, nir_function_impl *impl)
 static nir_variable *
 create_shadow_temp(struct lower_io_state *state, nir_variable *var)
 {
-   nir_variable *nvar = ralloc(state->shader, nir_variable);
+   nir_variable *nvar = nir_variable_create_zeroed(state->shader);
    memcpy(nvar, var, sizeof *nvar);
    nvar->data.cannot_coalesce = true;
 
diff --git a/src/compiler/nir/nir_serialize.c b/src/compiler/nir/nir_serialize.c
index cf09f979e9d01..42f10f7e63679 100644
--- a/src/compiler/nir/nir_serialize.c
+++ b/src/compiler/nir/nir_serialize.c
@@ -339,7 +339,7 @@ write_variable(write_ctx *ctx, const nir_variable *var)
 static nir_variable *
 read_variable(read_ctx *ctx)
 {
-   nir_variable *var = rzalloc(ctx->nir, nir_variable);
+   nir_variable *var = nir_variable_create_zeroed(ctx->nir);
    read_add_object(ctx, var);
 
    union packed_var flags;
diff --git a/src/compiler/spirv/spirv_to_nir.c b/src/compiler/spirv/spirv_to_nir.c
index 9f94bdd882b2e..612cf539fb9a2 100644
--- a/src/compiler/spirv/spirv_to_nir.c
+++ b/src/compiler/spirv/spirv_to_nir.c
@@ -7130,7 +7130,7 @@ vtn_emit_kernel_entry_point_wrapper(struct vtn_builder *b,
          param_type->storage_class == SpvStorageClassFunction;
 
       /* input variable */
-      nir_variable *in_var = rzalloc(b->nb.shader, nir_variable);
+      nir_variable *in_var = nir_variable_create_zeroed(b->nb.shader);
 
       if (is_by_val) {
          in_var->data.mode = nir_var_uniform;
diff --git a/src/compiler/spirv/vtn_variables.c b/src/compiler/spirv/vtn_variables.c
index 717b390882fac..8c072ff9fe839 100644
--- a/src/compiler/spirv/vtn_variables.c
+++ b/src/compiler/spirv/vtn_variables.c
@@ -2182,7 +2182,7 @@ vtn_create_variable(struct vtn_builder *b, struct vtn_value *val,
    case vtn_variable_mode_hit_attrib:
    case vtn_variable_mode_node_payload:
       /* For these, we create the variable normally */
-      var->var = rzalloc(b->shader, nir_variable);
+      var->var = nir_variable_create_zeroed(b->shader);
       nir_variable_set_name(b->shader, var->var, val->name);
       var->var->type = vtn_type_get_nir_type(b, var->type, var->mode);
 
@@ -2204,7 +2204,7 @@ vtn_create_variable(struct vtn_builder *b, struct vtn_value *val,
    case vtn_variable_mode_push_constant:
    case vtn_variable_mode_accel_struct:
    case vtn_variable_mode_shader_record:
-      var->var = rzalloc(b->shader, nir_variable);
+      var->var = nir_variable_create_zeroed(b->shader);
       nir_variable_set_name(b->shader, var->var, val->name);
 
       var->var->type = vtn_type_get_nir_type(b, var->type, var->mode);
@@ -2220,7 +2220,7 @@ vtn_create_variable(struct vtn_builder *b, struct vtn_value *val,
    case vtn_variable_mode_cross_workgroup:
    case vtn_variable_mode_task_payload:
       /* Create the variable normally */
-      var->var = rzalloc(b->shader, nir_variable);
+      var->var = nir_variable_create_zeroed(b->shader);
       nir_variable_set_name(b->shader, var->var, val->name);
       var->var->type = vtn_type_get_nir_type(b, var->type, var->mode);
       var->var->data.mode = nir_mode;
@@ -2231,7 +2231,7 @@ vtn_create_variable(struct vtn_builder *b, struct vtn_value *val,
 
    case vtn_variable_mode_input:
    case vtn_variable_mode_output: {
-      var->var = rzalloc(b->shader, nir_variable);
+      var->var = nir_variable_create_zeroed(b->shader);
       nir_variable_set_name(b->shader, var->var, val->name);
       var->var->type = vtn_type_get_nir_type(b, var->type, var->mode);
       var->var->data.mode = nir_mode;
diff --git a/src/gallium/auxiliary/nir/tgsi_to_nir.c b/src/gallium/auxiliary/nir/tgsi_to_nir.c
index 81999005890dc..a69e39e66f7c5 100644
--- a/src/gallium/auxiliary/nir/tgsi_to_nir.c
+++ b/src/gallium/auxiliary/nir/tgsi_to_nir.c
@@ -289,7 +289,7 @@ ttn_emit_declaration(struct ttn_compile *c)
 
       for (i = 0; i < array_size; i++) {
          unsigned idx = decl->Range.First + i;
-         nir_variable *var = rzalloc(b->shader, nir_variable);
+         nir_variable *var = nir_variable_create_zeroed(b->shader);
 
          var->data.driver_location = idx;
 
diff --git a/src/microsoft/compiler/nir_to_dxil.c b/src/microsoft/compiler/nir_to_dxil.c
index 8a193d29784af..525f88192610a 100644
--- a/src/microsoft/compiler/nir_to_dxil.c
+++ b/src/microsoft/compiler/nir_to_dxil.c
@@ -6437,7 +6437,7 @@ add_sysvalue(struct ntd_context *ctx,
               int driver_location)
 {
 
-   nir_variable *var = rzalloc(ctx->shader, nir_variable);
+   nir_variable *var = nir_variable_create_zeroed(ctx->shader);
    if (!var)
       return NULL;
    var->data.driver_location = driver_location;
-- 
GitLab


From 610bb7604061566b3b1957109025c4c52bca1e2d Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Fri, 1 Aug 2025 23:44:05 -0400
Subject: [PATCH 7/7] nir: use gc_ctx for nir_variable to reduce ralloc/malloc
 overhead

gc_ctx uses a slab allocator. This reduces GLSL compile times by 1-3%
with the gallium noop driver.

This reduces the number of ralloc_size calls for Heaven shaders by 14.3%.
Note that gc_ctx also uses ralloc_size, so the reduction is a net change.

Reviewed-by: Timothy Arceri <tarceri@itsqueeze.com>
---
 src/compiler/nir/nir.c       | 2 +-
 src/compiler/nir/nir_sweep.c | 2 +-
 2 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/src/compiler/nir/nir.c b/src/compiler/nir/nir.c
index d49f4f2c2ed92..f4684377582f5 100644
--- a/src/compiler/nir/nir.c
+++ b/src/compiler/nir/nir.c
@@ -271,7 +271,7 @@ nir_shader_add_variable(nir_shader *shader, nir_variable *var)
 nir_variable *
 nir_variable_create_zeroed(nir_shader *nir)
 {
-   return rzalloc(nir, nir_variable);
+   return gc_zalloc_size(nir->gctx, sizeof(nir_variable), 8);
 }
 
 void
diff --git a/src/compiler/nir/nir_sweep.c b/src/compiler/nir/nir_sweep.c
index c64bde183f2bd..d4a22c276f4aa 100644
--- a/src/compiler/nir/nir_sweep.c
+++ b/src/compiler/nir/nir_sweep.c
@@ -54,7 +54,7 @@ sweep_constant(nir_shader *nir, nir_constant *c)
 static void
 sweep_variable(nir_shader *nir, nir_variable *var)
 {
-   ralloc_steal(nir, var);
+   gc_mark_live(nir->gctx, var);
    nir_variable_steal_name(nir, var, var);
    ralloc_steal(nir, var->max_ifc_array_access);
    ralloc_steal(nir, var->state_slots);
-- 
GitLab

