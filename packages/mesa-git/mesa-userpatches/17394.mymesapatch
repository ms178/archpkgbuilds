From c53be9ccf2cd122c72206deaab32db70038beaa4 Mon Sep 17 00:00:00 2001
From: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
Date: Thu, 7 Jul 2022 11:07:03 +0200
Subject: [PATCH] radeonsi: check last_dirty_buf_counter and dirty_tex_counter

Check both counters in draw and compute, otherwise compute dispatches may
miss buffers invalidation.
This fixes the test case from https://gitlab.freedesktop.org/mesa/piglit/-/merge_requests/702
(both with and without GALLIUM_THREAD=0).

cc: mesa-stable
---
 src/gallium/drivers/radeonsi/si_compute.c     |  2 ++
 src/gallium/drivers/radeonsi/si_pipe.h        | 22 +++++++++++++++++++
 .../drivers/radeonsi/si_state_draw.cpp        | 17 +-------------
 3 files changed, 25 insertions(+), 16 deletions(-)

diff --git a/src/gallium/drivers/radeonsi/si_compute.c b/src/gallium/drivers/radeonsi/si_compute.c
index ccefbc1e2c4c..59e773e886f1 100644
--- a/src/gallium/drivers/radeonsi/si_compute.c
+++ b/src/gallium/drivers/radeonsi/si_compute.c
@@ -948,6 +948,8 @@ static void si_launch_grid(struct pipe_context *ctx, const struct pipe_grid_info
    if (program->ir_type != PIPE_SHADER_IR_NATIVE && program->shader.compilation_failed)
       return;
 
+   si_check_dirty_buffers_textures(sctx);
+
    if (sctx->has_graphics) {
       if (sctx->last_num_draw_calls != sctx->num_draw_calls) {
          si_update_fb_dirtiness_after_rendering(sctx);
diff --git a/src/gallium/drivers/radeonsi/si_pipe.h b/src/gallium/drivers/radeonsi/si_pipe.h
index 80e036783664..1302a08ec8fb 100644
--- a/src/gallium/drivers/radeonsi/si_pipe.h
+++ b/src/gallium/drivers/radeonsi/si_pipe.h
@@ -2062,6 +2062,28 @@ static inline unsigned si_num_vbos_in_user_sgprs(struct si_screen *sscreen)
    return si_num_vbos_in_user_sgprs_inline(sscreen->info.gfx_level);
 }
 
+static inline
+void si_check_dirty_buffers_textures(struct si_context *sctx)
+{
+   /* Recompute and re-emit the texture resource states if needed. */
+   unsigned dirty_tex_counter = p_atomic_read(&sctx->screen->dirty_tex_counter);
+   if (unlikely(dirty_tex_counter != sctx->last_dirty_tex_counter)) {
+      sctx->last_dirty_tex_counter = dirty_tex_counter;
+      sctx->framebuffer.dirty_cbufs |= ((1 << sctx->framebuffer.state.nr_cbufs) - 1);
+      sctx->framebuffer.dirty_zsbuf = true;
+      si_mark_atom_dirty(sctx, &sctx->atoms.s.framebuffer);
+      si_update_all_texture_descriptors(sctx);
+   }
+
+   unsigned dirty_buf_counter = p_atomic_read(&sctx->screen->dirty_buf_counter);
+   if (unlikely(dirty_buf_counter != sctx->last_dirty_buf_counter)) {
+      sctx->last_dirty_buf_counter = dirty_buf_counter;
+      /* Rebind all buffers unconditionally. */
+      si_rebind_buffer(sctx, NULL);
+   }
+}
+
+
 #define PRINT_ERR(fmt, args...)                                                                    \
    fprintf(stderr, "EE %s:%d %s - " fmt, __FILE__, __LINE__, __func__, ##args)
 
diff --git a/src/gallium/drivers/radeonsi/si_state_draw.cpp b/src/gallium/drivers/radeonsi/si_state_draw.cpp
index 8a0eba58303c..e693331fb400 100644
--- a/src/gallium/drivers/radeonsi/si_state_draw.cpp
+++ b/src/gallium/drivers/radeonsi/si_state_draw.cpp
@@ -2179,22 +2179,7 @@ static void si_draw(struct pipe_context *ctx,
     */
    struct si_context *sctx = (struct si_context *)ctx;
 
-   /* Recompute and re-emit the texture resource states if needed. */
-   unsigned dirty_tex_counter = p_atomic_read(&sctx->screen->dirty_tex_counter);
-   if (unlikely(dirty_tex_counter != sctx->last_dirty_tex_counter)) {
-      sctx->last_dirty_tex_counter = dirty_tex_counter;
-      sctx->framebuffer.dirty_cbufs |= ((1 << sctx->framebuffer.state.nr_cbufs) - 1);
-      sctx->framebuffer.dirty_zsbuf = true;
-      si_mark_atom_dirty(sctx, &sctx->atoms.s.framebuffer);
-      si_update_all_texture_descriptors(sctx);
-   }
-
-   unsigned dirty_buf_counter = p_atomic_read(&sctx->screen->dirty_buf_counter);
-   if (unlikely(dirty_buf_counter != sctx->last_dirty_buf_counter)) {
-      sctx->last_dirty_buf_counter = dirty_buf_counter;
-      /* Rebind all buffers unconditionally. */
-      si_rebind_buffer(sctx, NULL);
-   }
+   si_check_dirty_buffers_textures(sctx);
 
    si_decompress_textures(sctx, u_bit_consecutive(0, SI_NUM_GRAPHICS_SHADERS));
    si_need_gfx_cs_space(sctx, num_draws);
-- 
GitLab

