From 94240bab5734747e1d562663710c0f9ba8304644 Mon Sep 17 00:00:00 2001
From: Faith Ekstrand <faith.ekstrand@collabora.com>
Date: Mon, 17 Jul 2023 12:05:48 -0500
Subject: [PATCH 1/4] nir/large_constants: Use nir_component_mask_t

---
 src/compiler/nir/nir_opt_large_constants.c | 10 +++++-----
 1 file changed, 5 insertions(+), 5 deletions(-)

diff --git a/src/compiler/nir/nir_opt_large_constants.c b/src/compiler/nir/nir_opt_large_constants.c
index eae4363acd07c..b4ae686ec5f15 100644
--- a/src/compiler/nir/nir_opt_large_constants.c
+++ b/src/compiler/nir/nir_opt_large_constants.c
@@ -103,7 +103,7 @@ build_constant_load(nir_builder *b, nir_deref_instr *deref,
 static void
 handle_constant_store(void *mem_ctx, struct var_info *info,
                       nir_deref_instr *deref, nir_const_value *val,
-                      unsigned writemask,
+                      nir_component_mask_t write_mask,
                       glsl_type_size_align_func size_align)
 {
    assert(!nir_deref_instr_has_indirect(deref));
@@ -124,7 +124,7 @@ handle_constant_store(void *mem_ctx, struct var_info *info,
    char *dst = (char *)info->constant_data + offset;
 
    for (unsigned i = 0; i < num_components; i++) {
-      if (!(writemask & (1 << i)))
+      if (!(write_mask & (1 << i)))
          continue;
 
       switch (bit_size) {
@@ -218,12 +218,12 @@ nir_opt_large_constants(nir_shader *shader,
 
          bool src_is_const = false;
          nir_deref_instr *src_deref = NULL, *dst_deref = NULL;
-         unsigned writemask = 0;
+         nir_component_mask_t write_mask = 0;
          switch (intrin->intrinsic) {
          case nir_intrinsic_store_deref:
             dst_deref = nir_src_as_deref(intrin->src[0]);
             src_is_const = nir_src_is_const(intrin->src[1]);
-            writemask = nir_intrinsic_write_mask(intrin);
+            write_mask = nir_intrinsic_write_mask(intrin);
             break;
 
          case nir_intrinsic_load_deref:
@@ -261,7 +261,7 @@ nir_opt_large_constants(nir_shader *shader,
                info->is_constant = false;
             } else {
                nir_const_value *val = nir_src_as_const_value(intrin->src[1]);
-               handle_constant_store(var_infos, info, dst_deref, val, writemask,
+               handle_constant_store(var_infos, info, dst_deref, val, write_mask,
                                      size_align);
             }
          }
-- 
GitLab


From f4ab42cd0e745d7445c381ce15b581b2b2e604cd Mon Sep 17 00:00:00 2001
From: Faith Ekstrand <faith.ekstrand@collabora.com>
Date: Mon, 17 Jul 2023 12:07:07 -0500
Subject: [PATCH 2/4] nir/large_constants: Add read/write_const_values helpers

The write helper is just pulling code we already have out into a helper
and flipping the order of the loop and the switch.  The read helper will
be useful in the next commit where we add small constant support.  This
keeps the two helpers right next to each other in the file where they're
easy to compare and we can ensure that they stay in sync.
---
 src/compiler/nir/nir_opt_large_constants.c | 118 +++++++++++++++------
 1 file changed, 86 insertions(+), 32 deletions(-)

diff --git a/src/compiler/nir/nir_opt_large_constants.c b/src/compiler/nir/nir_opt_large_constants.c
index b4ae686ec5f15..eb5cb700394da 100644
--- a/src/compiler/nir/nir_opt_large_constants.c
+++ b/src/compiler/nir/nir_opt_large_constants.c
@@ -25,6 +25,89 @@
 #include "nir_builder.h"
 #include "nir_deref.h"
 
+static void
+read_const_values(nir_const_value *dst, const void *src,
+                  unsigned num_components, unsigned bit_size)
+{
+   memset(dst, 0, num_components * sizeof(*dst));
+
+   switch (bit_size) {
+   case 1:
+      /* Booleans are special-cased to be 32-bit */
+      assert(((uintptr_t)src & 0x3) == 0);
+      for (unsigned i = 0; i < num_components; i++)
+         dst[i].b = ((int32_t *)src)[i] != 0;
+      break;
+
+   case 8:
+      for (unsigned i = 0; i < num_components; i++)
+         dst[i].u8 = ((int8_t *)src)[i];
+      break;
+
+   case 16:
+      assert(((uintptr_t)src & 0x1) == 0);
+      for (unsigned i = 0; i < num_components; i++)
+         dst[i].u16 = ((int16_t *)src)[i];
+      break;
+
+   case 32:
+      assert(((uintptr_t)src & 0x3) == 0);
+      for (unsigned i = 0; i < num_components; i++)
+         dst[i].u32 = ((int32_t *)src)[i];
+      break;
+
+   case 64:
+      assert(((uintptr_t)src & 0x7) == 0);
+      for (unsigned i = 0; i < num_components; i++)
+         dst[i].u64 = ((int64_t *)src)[i];
+      break;
+
+   default:
+      unreachable("Invalid bit size");
+   }
+}
+
+static void
+write_const_values(void *dst, const nir_const_value *src,
+                   nir_component_mask_t write_mask,
+                   unsigned bit_size)
+{
+   switch (bit_size) {
+   case 1:
+      /* Booleans are special-cased to be 32-bit */
+      assert(((uintptr_t)dst & 0x3) == 0);
+      u_foreach_bit(i, write_mask)
+         ((int32_t *)dst)[i] = -(int)src[i].b;
+      break;
+
+   case 8:
+      u_foreach_bit(i, write_mask)
+         ((int8_t *)dst)[i] = src[i].u8;
+      break;
+
+   case 16:
+      assert(((uintptr_t)dst & 0x1) == 0);
+      u_foreach_bit(i, write_mask)
+         ((int16_t *)dst)[i] = src[i].u16;
+      break;
+
+   case 32:
+      assert(((uintptr_t)dst & 0x3) == 0);
+      u_foreach_bit(i, write_mask)
+         ((int32_t *)dst)[i] = src[i].u32;
+      break;
+
+   case 64:
+      assert(((uintptr_t)dst & 0x7) == 0);
+      u_foreach_bit(i, write_mask)
+         ((int64_t *)dst)[i] = src[i].u64;
+      break;
+
+   default:
+      unreachable("Invalid bit size");
+   }
+}
+
 struct var_info {
    nir_variable *var;
 
@@ -121,38 +204,9 @@ handle_constant_store(void *mem_ctx, struct var_info *info,
    if (offset >= info->constant_data_size)
       return;
 
-   char *dst = (char *)info->constant_data + offset;
-
-   for (unsigned i = 0; i < num_components; i++) {
-      if (!(write_mask & (1 << i)))
-         continue;
-
-      switch (bit_size) {
-      case 1:
-         /* Booleans are special-cased to be 32-bit */
-         ((int32_t *)dst)[i] = -(int)val[i].b;
-         break;
-
-      case 8:
-         ((uint8_t *)dst)[i] = val[i].u8;
-         break;
-
-      case 16:
-         ((uint16_t *)dst)[i] = val[i].u16;
-         break;
-
-      case 32:
-         ((uint32_t *)dst)[i] = val[i].u32;
-         break;
-
-      case 64:
-         ((uint64_t *)dst)[i] = val[i].u64;
-         break;
-
-      default:
-         unreachable("Invalid bit size");
-      }
-   }
+   write_const_values((char *)info->constant_data + offset, val,
+                      write_mask & nir_component_mask(num_components),
+                      bit_size);
 }
 
 /** Lower large constant variables to shader constant data
-- 
GitLab


From 7bd75b3e387e118426d26d923738bd8536360750 Mon Sep 17 00:00:00 2001
From: Faith Ekstrand <faith.ekstrand@collabora.com>
Date: Mon, 17 Jul 2023 14:42:37 +0200
Subject: [PATCH 3/4] nir/opt_large_constants: Add Small constant handling

Adds handling for constant arrays that can be lowered to
'(imm >> bit_index) & but_mask' instead of constant loads.

RADV fossils:

Totals from 70 (0.05% of 131205) affected shaders:
Instrs: 31441 -> 31260 (-0.58%); split: -0.59%, +0.02%
CodeSize: 172104 -> 170568 (-0.89%)
VGPRs: 2608 -> 2616 (+0.31%)
Latency: 296687 -> 280859 (-5.33%); split: -5.34%, +0.00%
InvThroughput: 65491 -> 65696 (+0.31%); split: -0.11%, +0.42%
VClause: 671 -> 646 (-3.73%)
SClause: 1014 -> 964 (-4.93%)
Copies: 1742 -> 1564 (-10.22%); split: -10.51%, +0.29%
PreSGPRs: 2039 -> 2036 (-0.15%)
PreVGPRs: 2014 -> 2017 (+0.15%)
---
 src/compiler/nir/nir_opt_large_constants.c | 141 +++++++++++++++++++--
 1 file changed, 129 insertions(+), 12 deletions(-)

diff --git a/src/compiler/nir/nir_opt_large_constants.c b/src/compiler/nir/nir_opt_large_constants.c
index eb5cb700394da..3f8f6f105dd0f 100644
--- a/src/compiler/nir/nir_opt_large_constants.c
+++ b/src/compiler/nir/nir_opt_large_constants.c
@@ -25,6 +25,8 @@
 #include "nir_builder.h"
 #include "nir_deref.h"
 
+#include "util/u_math.h"
+
 static void
 read_const_values(nir_const_value *dst, const void *src,
                   unsigned num_components, unsigned bit_size)
@@ -108,10 +110,19 @@ write_const_values(void *dst, const nir_const_value *src,
    }
 }
 
+struct small_constant {
+   uint64_t data;
+
+   uint32_t bit_size;
+
+   uint32_t bit_stride;
+};
+
 struct var_info {
    nir_variable *var;
 
    bool is_constant;
+   bool is_small;
    bool found_read;
    bool duplicate;
 
@@ -123,6 +134,8 @@ struct var_info {
    /* If is_constant, hold the collected constant data for this var. */
    uint32_t constant_data_size;
    void *constant_data;
+
+   struct small_constant small_constant;
 };
 
 static int
@@ -209,6 +222,96 @@ handle_constant_store(void *mem_ctx, struct var_info *info,
                       bit_size);
 }
 
+static void
+get_small_constant(struct var_info *info, glsl_type_size_align_func size_align)
+{
+   if (!glsl_type_is_array(info->var->type))
+      return;
+
+   const struct glsl_type *elem_type = glsl_get_array_element(info->var->type);
+   if (!glsl_type_is_scalar(elem_type))
+      return;
+
+   uint32_t array_len = glsl_get_length(info->var->type);
+   uint32_t bit_size = glsl_get_bit_size(elem_type);
+
+   /* If our array is large, don't even bother */
+   if (array_len > 64)
+      return;
+
+   /* Skip cases that can be lowered to a bcsel ladder more efficiently. */
+   if (array_len <= 3)
+      return;
+
+   uint32_t elem_size, elem_align;
+   size_align(elem_type, &elem_size, &elem_align);
+   uint32_t stride = ALIGN_POT(elem_size, elem_align);
+
+   nir_const_value values[64];
+   assert(stride == (bit_size == 1 ? 4 : bit_size / 8));
+   read_const_values(values, info->constant_data, array_len, bit_size);
+
+   uint32_t used_bits = 0;
+   for (unsigned i = 0; i < array_len; i++) {
+      uint64_t unsigned_elem = nir_const_value_as_uint(values[i], bit_size);
+      if (!unsigned_elem)
+         continue;
+
+      uint32_t elem_bits = util_logbase2_64(unsigned_elem) + 1;
+      used_bits = MAX2(used_bits, elem_bits);
+   }
+
+   /* Only use power-of-two numbers of bits so we end up with a shift
+    * instead of a multiply on our index.
+    */
+   used_bits = util_next_power_of_two(used_bits);
+
+   if (used_bits * array_len > 64)
+      return;
+
+   info->is_small = true;
+
+   for (unsigned i = 0; i < array_len; i++) {
+      uint64_t unsigned_elem = nir_const_value_as_uint(values[i], bit_size);
+      info->small_constant.data |= unsigned_elem << (i * used_bits);
+   }
+
+   info->small_constant.bit_size = util_next_power_of_two(used_bits * array_len);
+   /* Limit bit_size >= 32 to avoid unnecessary conversions.  */
+   info->small_constant.bit_size = MAX2(info->small_constant.bit_size, 32);
+
+   info->small_constant.bit_stride = used_bits;
+}
+
+static nir_ssa_def *
+build_small_constant_load(nir_builder *b, nir_deref_instr *deref,
+                          struct var_info *info, glsl_type_size_align_func size_align)
+{
+   struct small_constant *constant = &info->small_constant;
+
+   nir_ssa_def *imm = nir_imm_intN_t(b, constant->data, constant->bit_size);
+
+   assert(deref->deref_type == nir_deref_type_array);
+   nir_ssa_def *index = nir_ssa_for_src(b, deref->arr.index, 1);
+
+   nir_ssa_def *shift = nir_imul_imm(b, index, constant->bit_stride);
+   shift = nir_u2uN(b, shift, constant->bit_size);
+
+   nir_ssa_def *ret = nir_ushr(b, imm, shift);
+   ret = nir_iand_imm(b, ret, BITFIELD64_MASK(constant->bit_stride));
+
+   const unsigned bit_size = glsl_get_bit_size(deref->type);
+   if (bit_size < 8) {
+      /* Booleans are special-cased to be 32-bit */
+      assert(glsl_type_is_boolean(deref->type));
+      ret =  nir_ine_imm(b, ret, 0);
+   } else if (bit_size != constant->bit_size) {
+      ret = nir_u2uN(b, ret, bit_size);
+   }
+
+   return ret;
+}
+
 /** Lower large constant variables to shader constant data
  *
  * This pass looks for large (type_size(var->type) > threshold) variables
@@ -342,6 +445,8 @@ nir_opt_large_constants(nir_shader *shader,
       }
    }
 
+   bool has_constant = false;
+
    /* Allocate constant data space for each variable that just has constant
     * data.  We sort them by size and content so we can easily find
     * duplicates.
@@ -357,9 +462,11 @@ nir_opt_large_constants(nir_shader *shader,
       if (!info->is_constant)
          continue;
 
+      get_small_constant(info, size_align);
+
       unsigned var_size, var_align;
       size_align(info->var->type, &var_size, &var_align);
-      if (var_size <= threshold || !info->found_read) {
+      if ((var_size <= threshold && !info->is_small) || !info->found_read) {
          /* Don't bother lowering small stuff or data that's never read */
          info->is_constant = false;
          continue;
@@ -372,23 +479,27 @@ nir_opt_large_constants(nir_shader *shader,
          info->var->data.location = ALIGN_POT(shader->constant_data_size, var_align);
          shader->constant_data_size = info->var->data.location + var_size;
       }
+
+      has_constant |= info->is_constant;
    }
 
-   if (shader->constant_data_size == old_constant_data_size) {
+   if (!has_constant) {
       nir_shader_preserve_all_metadata(shader);
       ralloc_free(var_infos);
       return false;
    }
 
-   assert(shader->constant_data_size > old_constant_data_size);
-   shader->constant_data = rerzalloc_size(shader, shader->constant_data,
-                                          old_constant_data_size,
-                                          shader->constant_data_size);
-   for (int i = 0; i < num_locals; i++) {
-      struct var_info *info = &var_infos[i];
-      if (!info->duplicate && info->is_constant) {
-         memcpy((char *)shader->constant_data + info->var->data.location,
-                info->constant_data, info->constant_data_size);
+   if (shader->constant_data_size != old_constant_data_size) {
+      assert(shader->constant_data_size > old_constant_data_size);
+      shader->constant_data = rerzalloc_size(shader, shader->constant_data,
+                                             old_constant_data_size,
+                                             shader->constant_data_size);
+      for (int i = 0; i < num_locals; i++) {
+         struct var_info *info = &var_infos[i];
+         if (!info->duplicate && info->is_constant) {
+            memcpy((char *)shader->constant_data + info->var->data.location,
+                   info->constant_data, info->constant_data_size);
+         }
       }
    }
 
@@ -412,7 +523,13 @@ nir_opt_large_constants(nir_shader *shader,
                continue;
 
             struct var_info *info = &var_infos[var->index];
-            if (info->is_constant) {
+            if (info->is_small) {
+               b.cursor = nir_after_instr(&intrin->instr);
+               nir_ssa_def *val = build_small_constant_load(&b, deref, info, size_align);
+               nir_ssa_def_rewrite_uses(&intrin->dest.ssa, val);
+               nir_instr_remove(&intrin->instr);
+               nir_deref_instr_remove_if_unused(deref);
+            } else if (info->is_constant) {
                b.cursor = nir_after_instr(&intrin->instr);
                nir_ssa_def *val = build_constant_load(&b, deref, size_align);
                nir_ssa_def_rewrite_uses(&intrin->dest.ssa,
-- 
GitLab


From d6c06e15e5c6caf2e75b3cd23c864076f03b3372 Mon Sep 17 00:00:00 2001
From: Konstantin Seurer <konstantin.seurer@gmail.com>
Date: Mon, 17 Jul 2023 15:08:43 +0200
Subject: [PATCH 4/4] nir/opt_large_constants: Handle small float arrays

Handles small arrays of integer, positive floats.

RADV fossils:

Totals from 65 (0.05% of 131205) affected shaders:
Instrs: 30001 -> 29936 (-0.22%); split: -0.39%, +0.18%
CodeSize: 165676 -> 164996 (-0.41%); split: -0.53%, +0.12%
Latency: 126873 -> 127178 (+0.24%); split: -0.29%, +0.53%
InvThroughput: 26640 -> 26895 (+0.96%); split: -0.48%, +1.44%
VClause: 425 -> 371 (-12.71%)
SClause: 982 -> 981 (-0.10%); split: -0.92%, +0.81%
Copies: 2072 -> 1939 (-6.42%); split: -6.52%, +0.10%
PreVGPRs: 1553 -> 1537 (-1.03%)
---
 src/compiler/nir/nir_opt_large_constants.c | 52 ++++++++++++++++++----
 1 file changed, 44 insertions(+), 8 deletions(-)

diff --git a/src/compiler/nir/nir_opt_large_constants.c b/src/compiler/nir/nir_opt_large_constants.c
index 3f8f6f105dd0f..45eaf631e127f 100644
--- a/src/compiler/nir/nir_opt_large_constants.c
+++ b/src/compiler/nir/nir_opt_large_constants.c
@@ -114,6 +114,7 @@ struct small_constant {
    uint64_t data;
 
    uint32_t bit_size;
+   bool is_float;
 
    uint32_t bit_stride;
 };
@@ -251,13 +252,38 @@ get_small_constant(struct var_info *info, glsl_type_size_align_func size_align)
    assert(stride == (bit_size == 1 ? 4 : bit_size / 8));
    read_const_values(values, info->constant_data, array_len, bit_size);
 
+   bool is_float = true;
+   if (bit_size < 16) {
+      is_float = false;
+   } else {
+      for (unsigned i = 0; i < array_len; i++) {
+         /* See if it's an easily convertible float.
+          * TODO: Compute greatest common divisor to support non-integer floats.
+          * TODO: Compute min value and add it to the result of
+          *       build_small_constant_load for handling negative floats.
+          */
+         uint32_t u = nir_const_value_as_float(values[i], bit_size);
+         nir_const_value fc = nir_const_value_for_float(u, bit_size);
+         is_float &= !memcmp(&fc, &values[i], bit_size / 8);
+      }
+   }
+
    uint32_t used_bits = 0;
    for (unsigned i = 0; i < array_len; i++) {
-      uint64_t unsigned_elem = nir_const_value_as_uint(values[i], bit_size);
-      if (!unsigned_elem)
-         continue;
+      uint32_t elem_bits;
+
+      if (is_float) {
+         double float_elem = nir_const_value_as_float(values[i], bit_size);
+         double float_elem_bits = log2(float_elem) + 1.0;
+         elem_bits = (uint32_t)float_elem_bits;
+      } else {
+         uint64_t unsigned_elem = nir_const_value_as_uint(values[i], bit_size);
+         if (!unsigned_elem)
+            continue;
+
+         elem_bits = util_logbase2_64(unsigned_elem) + 1;
+      }
 
-      uint32_t elem_bits = util_logbase2_64(unsigned_elem) + 1;
       used_bits = MAX2(used_bits, elem_bits);
    }
 
@@ -272,13 +298,20 @@ get_small_constant(struct var_info *info, glsl_type_size_align_func size_align)
    info->is_small = true;
 
    for (unsigned i = 0; i < array_len; i++) {
-      uint64_t unsigned_elem = nir_const_value_as_uint(values[i], bit_size);
-      info->small_constant.data |= unsigned_elem << (i * used_bits);
+      uint64_t elem;
+
+      if (is_float)
+         elem = nir_const_value_as_float(values[i], bit_size);
+      else
+         elem = nir_const_value_as_uint(values[i], bit_size);
+
+      info->small_constant.data |= elem << (i * used_bits);
    }
 
    info->small_constant.bit_size = util_next_power_of_two(used_bits * array_len);
    /* Limit bit_size >= 32 to avoid unnecessary conversions.  */
    info->small_constant.bit_size = MAX2(info->small_constant.bit_size, 32);
+   info->small_constant.is_float = is_float;
 
    info->small_constant.bit_stride = used_bits;
 }
@@ -305,8 +338,11 @@ build_small_constant_load(nir_builder *b, nir_deref_instr *deref,
       /* Booleans are special-cased to be 32-bit */
       assert(glsl_type_is_boolean(deref->type));
       ret =  nir_ine_imm(b, ret, 0);
-   } else if (bit_size != constant->bit_size) {
-      ret = nir_u2uN(b, ret, bit_size);
+   } else {
+      if (constant->is_float)
+         ret = nir_u2fN(b, ret, bit_size);
+      else if (bit_size != constant->bit_size)
+         ret = nir_u2uN(b, ret, bit_size);
    }
 
    return ret;
-- 
GitLab

