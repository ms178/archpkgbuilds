From 84dc5dd8832254c9b35daeac50e86301f3375322 Mon Sep 17 00:00:00 2001
From: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
Date: Wed, 6 Jul 2022 15:37:33 +0200
Subject: [PATCH 01/26] ac/llvm: remove unused vars hash table
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

It's unused because variables are never dereferenced during the
NIR -> LLVM IR translation.

Reviewed-by: Mihai Preda <mhpreda@gmail.com>
Reviewed-by: Dave Airlie <airlied@redhat.com>
Reviewed-by: Qiang Yu <yuq825@gmail.com>
Reviewed-by: Marek Olšák <marek.olsak@amd.com>
Acked-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
---
 src/amd/llvm/ac_nir_to_llvm.c | 8 --------
 1 file changed, 8 deletions(-)

diff --git a/src/amd/llvm/ac_nir_to_llvm.c b/src/amd/llvm/ac_nir_to_llvm.c
index 3a55d828d4d6..34f2f883ada7 100644
--- a/src/amd/llvm/ac_nir_to_llvm.c
+++ b/src/amd/llvm/ac_nir_to_llvm.c
@@ -50,7 +50,6 @@ struct ac_nir_context {
 
    struct hash_table *defs;
    struct hash_table *phis;
-   struct hash_table *vars;
    struct hash_table *verified_interp;
 
    LLVMValueRef main_function;
@@ -5179,11 +5178,6 @@ static bool visit_deref(struct ac_nir_context *ctx, nir_deref_instr *instr)
 
    LLVMValueRef result = NULL;
    switch (instr->deref_type) {
-   case nir_deref_type_var: {
-      struct hash_entry *entry = _mesa_hash_table_search(ctx->vars, instr->var);
-      result = entry->data;
-      break;
-   }
    case nir_deref_type_struct:
       if (nir_deref_mode_is(instr, nir_var_mem_global)) {
          nir_deref_instr *parent = nir_deref_instr_parent(instr);
@@ -5533,7 +5527,6 @@ bool ac_nir_translate(struct ac_llvm_context *ac, struct ac_shader_abi *abi,
 
    ctx.defs = _mesa_hash_table_create(NULL, _mesa_hash_pointer, _mesa_key_pointer_equal);
    ctx.phis = _mesa_hash_table_create(NULL, _mesa_hash_pointer, _mesa_key_pointer_equal);
-   ctx.vars = _mesa_hash_table_create(NULL, _mesa_hash_pointer, _mesa_key_pointer_equal);
 
    if (ctx.abi->kill_ps_if_inf_interp)
       ctx.verified_interp =
@@ -5568,7 +5561,6 @@ bool ac_nir_translate(struct ac_llvm_context *ac, struct ac_shader_abi *abi,
    free(ctx.ssa_defs);
    ralloc_free(ctx.defs);
    ralloc_free(ctx.phis);
-   ralloc_free(ctx.vars);
    if (ctx.abi->kill_ps_if_inf_interp)
       ralloc_free(ctx.verified_interp);
 
-- 
GitLab


From 001a2cf785300c4758e500f6d38109da9403f10f Mon Sep 17 00:00:00 2001
From: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
Date: Wed, 5 Oct 2022 10:55:53 +0200
Subject: [PATCH 02/26] radeonsi: remove USE_LDS_SYMBOLS
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

This has been set to true for 3 years and radeonsi wants LLVM 11, so
we can remove the define and use true directly.

Reviewed-by: Mihai Preda <mhpreda@gmail.com>
Reviewed-by: Dave Airlie <airlied@redhat.com>
Reviewed-by: Qiang Yu <yuq825@gmail.com>
Reviewed-by: Marek Olšák <marek.olsak@amd.com>
Acked-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
---
 src/gallium/drivers/radeonsi/si_shader.h      |  4 ----
 src/gallium/drivers/radeonsi/si_shader_llvm.c | 20 ++++++++-----------
 .../drivers/radeonsi/si_shader_llvm_gs.c      | 11 +++-------
 3 files changed, 11 insertions(+), 24 deletions(-)

diff --git a/src/gallium/drivers/radeonsi/si_shader.h b/src/gallium/drivers/radeonsi/si_shader.h
index f2f63fc83123..4ed1457f7743 100644
--- a/src/gallium/drivers/radeonsi/si_shader.h
+++ b/src/gallium/drivers/radeonsi/si_shader.h
@@ -146,10 +146,6 @@
 extern "C" {
 #endif
 
-// Use LDS symbols when supported by LLVM. Can be disabled for testing the old
-// path on newer LLVM for now. Should be removed in the long term.
-#define USE_LDS_SYMBOLS (true)
-
 struct nir_shader;
 struct si_shader;
 struct si_context;
diff --git a/src/gallium/drivers/radeonsi/si_shader_llvm.c b/src/gallium/drivers/radeonsi/si_shader_llvm.c
index 616341bfa4a7..75e669fa8901 100644
--- a/src/gallium/drivers/radeonsi/si_shader_llvm.c
+++ b/src/gallium/drivers/radeonsi/si_shader_llvm.c
@@ -227,18 +227,14 @@ void si_llvm_create_main_func(struct si_shader_context *ctx, bool ngg_cull_shade
 
    if (ctx->stage <= MESA_SHADER_GEOMETRY &&
        (shader->key.ge.as_ls || ctx->stage == MESA_SHADER_TESS_CTRL)) {
-      if (USE_LDS_SYMBOLS) {
-         /* The LSHS size is not known until draw time, so we append it
-          * at the end of whatever LDS use there may be in the rest of
-          * the shader (currently none, unless LLVM decides to do its
-          * own LDS-based lowering).
-          */
-         ctx->ac.lds = LLVMAddGlobalInAddressSpace(ctx->ac.module, LLVMArrayType(ctx->ac.i32, 0),
-                                                   "__lds_end", AC_ADDR_SPACE_LDS);
-         LLVMSetAlignment(ctx->ac.lds, 256);
-      } else {
-         ac_declare_lds_as_pointer(&ctx->ac);
-      }
+      /* The LSHS size is not known until draw time, so we append it
+       * at the end of whatever LDS use there may be in the rest of
+       * the shader (currently none, unless LLVM decides to do its
+       * own LDS-based lowering).
+       */
+      ctx->ac.lds = LLVMAddGlobalInAddressSpace(ctx->ac.module, LLVMArrayType(ctx->ac.i32, 0),
+                                                "__lds_end", AC_ADDR_SPACE_LDS);
+      LLVMSetAlignment(ctx->ac.lds, 256);
    }
 
    /* Unlike radv, we override these arguments in the prolog, so to the
diff --git a/src/gallium/drivers/radeonsi/si_shader_llvm_gs.c b/src/gallium/drivers/radeonsi/si_shader_llvm_gs.c
index 8d4121afec9b..11773844c54c 100644
--- a/src/gallium/drivers/radeonsi/si_shader_llvm_gs.c
+++ b/src/gallium/drivers/radeonsi/si_shader_llvm_gs.c
@@ -288,14 +288,9 @@ void si_preload_esgs_ring(struct si_shader_context *ctx)
                                                  LLVMConstInt(ctx->ac.i32, 3, 0), "");
       }
    } else {
-      if (USE_LDS_SYMBOLS) {
-         /* Declare the ESGS ring as an explicit LDS symbol. */
-         si_llvm_declare_esgs_ring(ctx);
-         ctx->ac.lds = ctx->esgs_ring;
-      } else {
-         ac_declare_lds_as_pointer(&ctx->ac);
-         ctx->esgs_ring = ctx->ac.lds;
-      }
+      /* Declare the ESGS ring as an explicit LDS symbol. */
+      si_llvm_declare_esgs_ring(ctx);
+      ctx->ac.lds = ctx->esgs_ring;
    }
 }
 
-- 
GitLab


From faa9916de98abca808b6fe3dce3fad8c1f69578b Mon Sep 17 00:00:00 2001
From: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
Date: Wed, 5 Oct 2022 09:33:37 +0200
Subject: [PATCH 03/26] radeonsi: use nir_lower_explicit_io to get rid of
 mem_shared deref
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

We can get them through GLSL compute or SPIR-V.

Reviewed-by: Mihai Preda <mhpreda@gmail.com>
Reviewed-by: Dave Airlie <airlied@redhat.com>
Reviewed-by: Qiang Yu <yuq825@gmail.com>
Reviewed-by: Marek Olšák <marek.olsak@amd.com>
Acked-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
---
 src/gallium/drivers/radeonsi/si_shader_nir.c | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/src/gallium/drivers/radeonsi/si_shader_nir.c b/src/gallium/drivers/radeonsi/si_shader_nir.c
index 135f8711a38c..047224132409 100644
--- a/src/gallium/drivers/radeonsi/si_shader_nir.c
+++ b/src/gallium/drivers/radeonsi/si_shader_nir.c
@@ -342,6 +342,8 @@ char *si_finalize_nir(struct pipe_screen *screen, void *nirptr)
 
    nir_lower_io_passes(nir);
 
+   NIR_PASS_V(nir, nir_lower_explicit_io, nir_var_mem_shared, nir_address_format_32bit_offset);
+
    /* Remove dead derefs, so that we can remove uniforms. */
    NIR_PASS_V(nir, nir_opt_dce);
 
-- 
GitLab


From 294765f6e7e63a5a171e78f1139e7eece8fa2c9c Mon Sep 17 00:00:00 2001
From: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
Date: Wed, 5 Oct 2022 09:40:45 +0200
Subject: [PATCH 04/26] ac/llvm: drop visit_deref
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

This functions processes mem_shared and nir_var_mem_global:
- mem_shared is lowered by radv and radeonsi.
- mem_global is lowered by radv and radonsi doesn't use it.

So we can safely drop this function.

Reviewed-by: Mihai Preda <mhpreda@gmail.com>
Reviewed-by: Dave Airlie <airlied@redhat.com>
Reviewed-by: Qiang Yu <yuq825@gmail.com>
Reviewed-by: Marek Olšák <marek.olsak@amd.com>
Acked-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
---
 src/amd/llvm/ac_nir_to_llvm.c | 108 +---------------------------------
 1 file changed, 2 insertions(+), 106 deletions(-)

diff --git a/src/amd/llvm/ac_nir_to_llvm.c b/src/amd/llvm/ac_nir_to_llvm.c
index 34f2f883ada7..b466725d147c 100644
--- a/src/amd/llvm/ac_nir_to_llvm.c
+++ b/src/amd/llvm/ac_nir_to_llvm.c
@@ -5171,110 +5171,6 @@ static LLVMTypeRef glsl_to_llvm_type(struct ac_llvm_context *ac, const struct gl
    return LLVMStructTypeInContext(ac->context, member_types, glsl_get_length(type), false);
 }
 
-static bool visit_deref(struct ac_nir_context *ctx, nir_deref_instr *instr)
-{
-   if (!nir_deref_mode_is_one_of(instr, nir_var_mem_shared | nir_var_mem_global))
-      return true;
-
-   LLVMValueRef result = NULL;
-   switch (instr->deref_type) {
-   case nir_deref_type_struct:
-      if (nir_deref_mode_is(instr, nir_var_mem_global)) {
-         nir_deref_instr *parent = nir_deref_instr_parent(instr);
-         uint64_t offset = glsl_get_struct_field_offset(parent->type, instr->strct.index);
-         result = ac_build_gep_ptr(&ctx->ac, get_src(ctx, instr->parent),
-                                   LLVMConstInt(ctx->ac.i32, offset, 0));
-      } else {
-         result = ac_build_gep0(&ctx->ac, get_src(ctx, instr->parent),
-                                LLVMConstInt(ctx->ac.i32, instr->strct.index, 0));
-      }
-      break;
-   case nir_deref_type_array:
-      if (nir_deref_mode_is(instr, nir_var_mem_global)) {
-         nir_deref_instr *parent = nir_deref_instr_parent(instr);
-         unsigned stride = glsl_get_explicit_stride(parent->type);
-
-         if ((glsl_type_is_matrix(parent->type) && glsl_matrix_type_is_row_major(parent->type)) ||
-             (glsl_type_is_vector(parent->type) && stride == 0))
-            stride = type_scalar_size_bytes(parent->type);
-
-         assert(stride > 0);
-         LLVMValueRef index = get_src(ctx, instr->arr.index);
-         if (LLVMTypeOf(index) != ctx->ac.i64)
-            index = LLVMBuildZExt(ctx->ac.builder, index, ctx->ac.i64, "");
-
-         LLVMValueRef offset =
-            LLVMBuildMul(ctx->ac.builder, index, LLVMConstInt(ctx->ac.i64, stride, 0), "");
-
-         result = ac_build_gep_ptr(&ctx->ac, get_src(ctx, instr->parent), offset);
-      } else {
-         result =
-            ac_build_gep0(&ctx->ac, get_src(ctx, instr->parent), get_src(ctx, instr->arr.index));
-      }
-      break;
-   case nir_deref_type_ptr_as_array:
-      if (nir_deref_mode_is(instr, nir_var_mem_global)) {
-         unsigned stride = nir_deref_instr_array_stride(instr);
-
-         LLVMValueRef index = get_src(ctx, instr->arr.index);
-         if (LLVMTypeOf(index) != ctx->ac.i64)
-            index = LLVMBuildZExt(ctx->ac.builder, index, ctx->ac.i64, "");
-
-         LLVMValueRef offset =
-            LLVMBuildMul(ctx->ac.builder, index, LLVMConstInt(ctx->ac.i64, stride, 0), "");
-
-         result = ac_build_gep_ptr(&ctx->ac, get_src(ctx, instr->parent), offset);
-      } else {
-         result =
-            ac_build_gep_ptr(&ctx->ac, get_src(ctx, instr->parent), get_src(ctx, instr->arr.index));
-      }
-      break;
-   case nir_deref_type_cast: {
-      result = get_src(ctx, instr->parent);
-
-      /* We can't use the structs from LLVM because the shader
-       * specifies its own offsets. */
-      LLVMTypeRef pointee_type = ctx->ac.i8;
-      if (nir_deref_mode_is(instr, nir_var_mem_shared))
-         pointee_type = glsl_to_llvm_type(&ctx->ac, instr->type);
-
-      unsigned address_space;
-
-      switch (instr->modes) {
-      case nir_var_mem_shared:
-         address_space = AC_ADDR_SPACE_LDS;
-         break;
-      case nir_var_mem_global:
-         address_space = AC_ADDR_SPACE_GLOBAL;
-         break;
-      default:
-         nir_print_instr(&instr->instr, stderr);
-         fprintf(stderr, "Unhandled address space %x\n", instr->modes);
-         return false;
-      }
-
-      LLVMTypeRef type = LLVMPointerType(pointee_type, address_space);
-
-      if (LLVMTypeOf(result) != type) {
-         if (LLVMGetTypeKind(LLVMTypeOf(result)) == LLVMVectorTypeKind) {
-            result = LLVMBuildBitCast(ctx->ac.builder, result, type, "");
-         } else {
-            result = LLVMBuildIntToPtr(ctx->ac.builder, result, type, "");
-         }
-      }
-      break;
-   }
-   default:
-      fprintf(stderr, "Unhandled deref_instr deref type: ");
-      nir_print_instr(&instr->instr, stderr);
-      fprintf(stderr, "\n");
-      return false;
-   }
-
-   ctx->ssa_defs[instr->dest.ssa.index] = result;
-   return true;
-}
-
 static bool visit_cf_list(struct ac_nir_context *ctx, struct exec_list *list);
 
 static bool visit_block(struct ac_nir_context *ctx, nir_block *block)
@@ -5321,8 +5217,8 @@ static bool visit_block(struct ac_nir_context *ctx, nir_block *block)
             return false;
          break;
       case nir_instr_type_deref:
-         if (!visit_deref(ctx, nir_instr_as_deref(instr)))
-            return false;
+         assert (!nir_deref_mode_is_one_of(nir_instr_as_deref(instr),
+                                           nir_var_mem_shared | nir_var_mem_global));
          break;
       default:
          fprintf(stderr, "Unknown NIR instr type: ");
-- 
GitLab


From 602e17dad5c7081298ac94b024f84bfa62256ae2 Mon Sep 17 00:00:00 2001
From: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
Date: Tue, 5 Jul 2022 21:13:59 +0200
Subject: [PATCH 05/26] ac/llvm: simplify get_memory_ptr
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

We actually don't need the type: lds is always treaded as
a "pointer to i8" in this function.

The caller will use the proper type when using the result.

For the same reason, we can get rid of the cast in setup_shared
because LLVM won't use this information anymore.

Reviewed-by: Mihai Preda <mhpreda@gmail.com>
Reviewed-by: Dave Airlie <airlied@redhat.com>
Reviewed-by: Qiang Yu <yuq825@gmail.com>
Reviewed-by: Marek Olšák <marek.olsak@amd.com>
Acked-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
---
 src/amd/llvm/ac_nir_to_llvm.c | 48 +++++++++++++++++------------------
 1 file changed, 24 insertions(+), 24 deletions(-)

diff --git a/src/amd/llvm/ac_nir_to_llvm.c b/src/amd/llvm/ac_nir_to_llvm.c
index b466725d147c..95c1605d6267 100644
--- a/src/amd/llvm/ac_nir_to_llvm.c
+++ b/src/amd/llvm/ac_nir_to_llvm.c
@@ -79,23 +79,12 @@ static LLVMValueRef get_src(struct ac_nir_context *nir, nir_src src)
    return nir->ssa_defs[src.ssa->index];
 }
 
-static LLVMValueRef get_memory_ptr_t(struct ac_nir_context *ctx, nir_src src, LLVMTypeRef elem_type, unsigned c_off)
+static LLVMValueRef get_memory_ptr(struct ac_nir_context *ctx, nir_src src, unsigned c_off)
 {
    LLVMValueRef ptr = get_src(ctx, src);
-   LLVMValueRef lds_i8 = ctx->ac.lds;
-   if (ctx->stage != MESA_SHADER_COMPUTE)
-      lds_i8 = LLVMBuildBitCast(ctx->ac.builder, ctx->ac.lds, LLVMPointerType(ctx->ac.i8, AC_ADDR_SPACE_LDS), "");
-
    ptr = LLVMBuildAdd(ctx->ac.builder, ptr, LLVMConstInt(ctx->ac.i32, c_off, 0), "");
-   ptr = LLVMBuildGEP2(ctx->ac.builder, ctx->ac.i8, lds_i8, &ptr, 1, "");
-   int addr_space = LLVMGetPointerAddressSpace(LLVMTypeOf(ptr));
-
-   return LLVMBuildBitCast(ctx->ac.builder, ptr, LLVMPointerType(elem_type, addr_space), "");
-}
-
-static LLVMValueRef get_memory_ptr(struct ac_nir_context *ctx, nir_src src, unsigned bit_size, unsigned c_off)
-{
-   return get_memory_ptr_t(ctx, src, LLVMIntTypeInContext(ctx->ac.context, bit_size), c_off);
+   /* LDS is used here as a i8 pointer. */
+   return LLVMBuildGEP2(ctx->ac.builder, ctx->ac.i8, ctx->ac.lds, &ptr, 1, "");
 }
 
 static LLVMBasicBlockRef get_block(struct ac_nir_context *nir, const struct nir_block *b)
@@ -3073,10 +3062,15 @@ static LLVMValueRef visit_load_shared(struct ac_nir_context *ctx, const nir_intr
    unsigned const_off = nir_intrinsic_base(instr);
 
    LLVMTypeRef elem_type = LLVMIntTypeInContext(ctx->ac.context, instr->dest.ssa.bit_size);
-   LLVMValueRef ptr = get_memory_ptr_t(ctx, instr->src[0], elem_type, const_off);
+   LLVMValueRef ptr = get_memory_ptr(ctx, instr->src[0], const_off);
 
    for (int chan = 0; chan < instr->num_components; chan++) {
       index = LLVMConstInt(ctx->ac.i32, chan, 0);
+      #if LLVM_VERSION_MAJOR < 14
+      ptr = LLVMBuildBitCast(
+         ctx->ac.builder, ptr,
+         LLVMPointerType(elem_type, LLVMGetPointerAddressSpace(LLVMTypeOf(ptr))), "");
+      #endif
       derived_ptr = LLVMBuildGEP2(ctx->ac.builder, elem_type, ptr, &index, 1, "");
       values[chan] = LLVMBuildLoad2(ctx->ac.builder, elem_type, derived_ptr, "");
    }
@@ -3093,7 +3087,7 @@ static void visit_store_shared(struct ac_nir_context *ctx, const nir_intrinsic_i
 
    unsigned const_off = nir_intrinsic_base(instr);
    LLVMTypeRef elem_type = LLVMIntTypeInContext(ctx->ac.context, instr->src[0].ssa->bit_size);
-   LLVMValueRef ptr = get_memory_ptr_t(ctx, instr->src[1], elem_type, const_off);
+   LLVMValueRef ptr = get_memory_ptr(ctx, instr->src[1], const_off);
    LLVMValueRef src = get_src(ctx, instr->src[0]);
 
    int writemask = nir_intrinsic_write_mask(instr);
@@ -3103,6 +3097,11 @@ static void visit_store_shared(struct ac_nir_context *ctx, const nir_intrinsic_i
       }
       data = ac_llvm_extract_elem(&ctx->ac, src, chan);
       index = LLVMConstInt(ctx->ac.i32, chan, 0);
+      #if LLVM_VERSION_MAJOR < 14
+      ptr = LLVMBuildBitCast(
+         ctx->ac.builder, ptr,
+         LLVMPointerType(elem_type, LLVMGetPointerAddressSpace(LLVMTypeOf(ptr))), "");
+      #endif
       derived_ptr = LLVMBuildGEP2(builder, elem_type, ptr, &index, 1, "");
       LLVMBuildStore(builder, data, derived_ptr);
    }
@@ -3111,15 +3110,16 @@ static void visit_store_shared(struct ac_nir_context *ctx, const nir_intrinsic_i
 static LLVMValueRef visit_load_shared2_amd(struct ac_nir_context *ctx,
                                            const nir_intrinsic_instr *instr)
 {
-   LLVMValueRef ptr = get_memory_ptr(ctx, instr->src[0], instr->dest.ssa.bit_size, 0);
+   LLVMTypeRef pointee_type = LLVMIntTypeInContext(ctx->ac.context, instr->dest.ssa.bit_size);
+   LLVMValueRef ptr = get_memory_ptr(ctx, instr->src[0], 0);
 
    LLVMValueRef values[2];
    uint8_t offsets[] = {nir_intrinsic_offset0(instr), nir_intrinsic_offset1(instr)};
    unsigned stride = nir_intrinsic_st64(instr) ? 64 : 1;
    for (unsigned i = 0; i < 2; i++) {
       LLVMValueRef index = LLVMConstInt(ctx->ac.i32, offsets[i] * stride, 0);
-      LLVMValueRef derived_ptr = LLVMBuildGEP(ctx->ac.builder, ptr, &index, 1, "");
-      values[i] = LLVMBuildLoad(ctx->ac.builder, derived_ptr, "");
+      LLVMValueRef derived_ptr = LLVMBuildGEP2(ctx->ac.builder, pointee_type, ptr, &index, 1, "");
+      values[i] = LLVMBuildLoad2(ctx->ac.builder, pointee_type, derived_ptr, "");
    }
 
    LLVMValueRef ret = ac_build_gather_values(&ctx->ac, values, 2);
@@ -3128,14 +3128,15 @@ static LLVMValueRef visit_load_shared2_amd(struct ac_nir_context *ctx,
 
 static void visit_store_shared2_amd(struct ac_nir_context *ctx, const nir_intrinsic_instr *instr)
 {
-   LLVMValueRef ptr = get_memory_ptr(ctx, instr->src[1], instr->src[0].ssa->bit_size, 0);
+   LLVMTypeRef pointee_type = LLVMIntTypeInContext(ctx->ac.context, instr->src[0].ssa->bit_size);
+   LLVMValueRef ptr = get_memory_ptr(ctx, instr->src[1], 0);
    LLVMValueRef src = get_src(ctx, instr->src[0]);
 
    uint8_t offsets[] = {nir_intrinsic_offset0(instr), nir_intrinsic_offset1(instr)};
    unsigned stride = nir_intrinsic_st64(instr) ? 64 : 1;
    for (unsigned i = 0; i < 2; i++) {
       LLVMValueRef index = LLVMConstInt(ctx->ac.i32, offsets[i] * stride, 0);
-      LLVMValueRef derived_ptr = LLVMBuildGEP(ctx->ac.builder, ptr, &index, 1, "");
+      LLVMValueRef derived_ptr = LLVMBuildGEP2(ctx->ac.builder, pointee_type, ptr, &index, 1, "");
       LLVMBuildStore(ctx->ac.builder, ac_llvm_extract_elem(&ctx->ac, src, i), derived_ptr);
    }
 }
@@ -3949,7 +3950,7 @@ static bool visit_intrinsic(struct ac_nir_context *ctx, nir_intrinsic_instr *ins
    case nir_intrinsic_shared_atomic_fadd:
    case nir_intrinsic_shared_atomic_fmin:
    case nir_intrinsic_shared_atomic_fmax: {
-      LLVMValueRef ptr = get_memory_ptr(ctx, instr->src[0], instr->src[1].ssa->bit_size, 0);
+      LLVMValueRef ptr = get_memory_ptr(ctx, instr->src[0], 0);
       result = visit_var_atomic(ctx, instr, ptr, 1);
       break;
    }
@@ -5368,8 +5369,7 @@ static void setup_shared(struct ac_nir_context *ctx, struct nir_shader *nir)
       LLVMAddGlobalInAddressSpace(ctx->ac.module, type, "compute_lds", AC_ADDR_SPACE_LDS);
    LLVMSetAlignment(lds, 64 * 1024);
 
-   ctx->ac.lds =
-      LLVMBuildBitCast(ctx->ac.builder, lds, LLVMPointerType(ctx->ac.i8, AC_ADDR_SPACE_LDS), "");
+   ctx->ac.lds = lds;
 }
 
 static void setup_gds(struct ac_nir_context *ctx, nir_function_impl *impl)
-- 
GitLab


From 7e8bbf23322f9e8fb29c2787993b0284fac6ad44 Mon Sep 17 00:00:00 2001
From: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
Date: Wed, 5 Oct 2022 17:41:04 +0200
Subject: [PATCH 06/26] ac/llvm: add helpers to get pointer types of ac_arg
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Reviewed-by: Qiang Yu <yuq825@gmail.com>
Reviewed-by: Marek Olšák <marek.olsak@amd.com>
Acked-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
---
 src/amd/llvm/ac_llvm_build.c | 63 ++++++++++++++++++++++++------------
 src/amd/llvm/ac_llvm_build.h |  8 +++++
 2 files changed, 51 insertions(+), 20 deletions(-)

diff --git a/src/amd/llvm/ac_llvm_build.c b/src/amd/llvm/ac_llvm_build.c
index 6dcb9cf1104b..7e0e16abfaa6 100644
--- a/src/amd/llvm/ac_llvm_build.c
+++ b/src/amd/llvm/ac_llvm_build.c
@@ -2828,6 +2828,29 @@ LLVMValueRef ac_find_lsb(struct ac_llvm_context *ctx, LLVMTypeRef dst_type, LLVM
                           LLVMConstInt(ctx->i32, -1, 0), lsb, "");
 }
 
+LLVMTypeRef ac_arg_type_to_pointee_type(struct ac_llvm_context *ctx, enum ac_arg_type type) {
+   switch (type) {
+   case AC_ARG_CONST_PTR:
+      return ctx->i8;
+      break;
+   case AC_ARG_CONST_FLOAT_PTR:
+      return ctx->f32;
+      break;
+   case AC_ARG_CONST_PTR_PTR:
+      return ac_array_in_const32_addr_space(ctx->i8);
+      break;
+   case AC_ARG_CONST_DESC_PTR:
+      return ctx->v4i32;
+      break;
+   case AC_ARG_CONST_IMAGE_PTR:
+      return ctx->v8i32;
+   default:
+      /* Other ac_arg_type values aren't pointers. */
+      assert(false);
+      return NULL;
+   }
+}
+
 LLVMTypeRef ac_array_in_const_addr_space(LLVMTypeRef elem_type)
 {
    return LLVMPointerType(elem_type, AC_ADDR_SPACE_CONST);
@@ -4493,37 +4516,37 @@ void ac_build_export_prim(struct ac_llvm_context *ctx, const struct ac_ngg_prim
 
 static LLVMTypeRef arg_llvm_type(enum ac_arg_type type, unsigned size, struct ac_llvm_context *ctx)
 {
-   if (type == AC_ARG_FLOAT) {
-      return size == 1 ? ctx->f32 : LLVMVectorType(ctx->f32, size);
-   } else if (type == AC_ARG_INT) {
-      return size == 1 ? ctx->i32 : LLVMVectorType(ctx->i32, size);
-   } else {
-      LLVMTypeRef ptr_type;
-      switch (type) {
+   LLVMTypeRef base;
+   switch (type) {
+      case AC_ARG_FLOAT:
+         return size == 1 ? ctx->f32 : LLVMVectorType(ctx->f32, size);
+      case AC_ARG_INT:
+         return size == 1 ? ctx->i32 : LLVMVectorType(ctx->i32, size);
       case AC_ARG_CONST_PTR:
-         ptr_type = ctx->i8;
+         base = ctx->i8;
          break;
       case AC_ARG_CONST_FLOAT_PTR:
-         ptr_type = ctx->f32;
+         base = ctx->f32;
          break;
       case AC_ARG_CONST_PTR_PTR:
-         ptr_type = ac_array_in_const32_addr_space(ctx->i8);
+         base = ac_array_in_const32_addr_space(ctx->i8);
          break;
       case AC_ARG_CONST_DESC_PTR:
-         ptr_type = ctx->v4i32;
+         base = ctx->v4i32;
          break;
       case AC_ARG_CONST_IMAGE_PTR:
-         ptr_type = ctx->v8i32;
+         base = ctx->v8i32;
          break;
       default:
-         unreachable("unknown arg type");
-      }
-      if (size == 1) {
-         return ac_array_in_const32_addr_space(ptr_type);
-      } else {
-         assert(size == 2);
-         return ac_array_in_const_addr_space(ptr_type);
-      }
+         return NULL;
+   }
+
+   assert(base);
+   if (size == 1) {
+      return ac_array_in_const32_addr_space(base);
+   } else {
+      assert(size == 2);
+      return ac_array_in_const_addr_space(base);
    }
 }
 
diff --git a/src/amd/llvm/ac_llvm_build.h b/src/amd/llvm/ac_llvm_build.h
index afe01985c161..7707cb91614e 100644
--- a/src/amd/llvm/ac_llvm_build.h
+++ b/src/amd/llvm/ac_llvm_build.h
@@ -575,12 +575,20 @@ LLVMValueRef ac_pack_edgeflags_for_export(struct ac_llvm_context *ctx,
 LLVMValueRef ac_pack_prim_export(struct ac_llvm_context *ctx, const struct ac_ngg_prim *prim);
 void ac_build_export_prim(struct ac_llvm_context *ctx, const struct ac_ngg_prim *prim);
 
+LLVMTypeRef ac_arg_type_to_pointee_type(struct ac_llvm_context *ctx, enum ac_arg_type type);
+
 static inline LLVMValueRef ac_get_arg(struct ac_llvm_context *ctx, struct ac_arg arg)
 {
    assert(arg.used);
    return LLVMGetParam(ctx->main_function, arg.arg_index);
 }
 
+static inline LLVMTypeRef ac_get_arg_pointee_type(struct ac_llvm_context *ctx, const struct ac_shader_args *args, struct ac_arg arg)
+{
+   assert(arg.used);
+   return ac_arg_type_to_pointee_type(ctx, args->args[arg.arg_index].type);
+}
+
 enum ac_llvm_calling_convention
 {
    AC_LLVM_AMDGPU_VS = 87,
-- 
GitLab


From 7c9b1fcff8d22c78364df66a688fa6d9be185893 Mon Sep 17 00:00:00 2001
From: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
Date: Tue, 5 Jul 2022 21:31:45 +0200
Subject: [PATCH 07/26] ac/llvm: remove LLVMBuildGEP usages
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Use LLVMBuildGEP2 instead.

Reviewed-by: Mihai Preda <mhpreda@gmail.com>
Reviewed-by: Dave Airlie <airlied@redhat.com>
Reviewed-by: Qiang Yu <yuq825@gmail.com>
Reviewed-by: Marek Olšák <marek.olsak@amd.com>
Acked-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
---
 src/amd/llvm/ac_nir_to_llvm.c | 7 ++++---
 1 file changed, 4 insertions(+), 3 deletions(-)

diff --git a/src/amd/llvm/ac_nir_to_llvm.c b/src/amd/llvm/ac_nir_to_llvm.c
index 95c1605d6267..7a233d7d0cfa 100644
--- a/src/amd/llvm/ac_nir_to_llvm.c
+++ b/src/amd/llvm/ac_nir_to_llvm.c
@@ -1667,7 +1667,8 @@ static LLVMValueRef visit_load_push_constant(struct ac_nir_context *ctx, nir_int
       }
    }
 
-   ptr = LLVMBuildGEP(ctx->ac.builder, ac_get_arg(&ctx->ac, ctx->args->push_constants), &addr, 1, "");
+   LLVMTypeRef type = ac_get_arg_pointee_type(&ctx->ac, ctx->args, ctx->args->push_constants);
+   ptr = LLVMBuildGEP2(ctx->ac.builder, type, ac_get_arg(&ctx->ac, ctx->args->push_constants), &addr, 1, "");
 
    if (instr->dest.ssa.bit_size == 8) {
       unsigned load_dwords = instr->dest.ssa.num_components > 1 ? 2 : 1;
@@ -2129,8 +2130,8 @@ static LLVMValueRef get_global_address(struct ac_nir_context *ctx,
 
       LLVMTypeRef i8_ptr_type = LLVMPointerType(ctx->ac.i8, AC_ADDR_SPACE_GLOBAL);
       addr = LLVMBuildIntToPtr(ctx->ac.builder, addr, i8_ptr_type, "");
-      addr = LLVMBuildGEP(ctx->ac.builder, addr, &offset, 1, "");
-      return type == ctx->ac.i8 ? addr : LLVMBuildBitCast(ctx->ac.builder, addr, ptr_type, "");
+      addr = LLVMBuildGEP2(ctx->ac.builder, ctx->ac.i8, addr, &offset, 1, "");
+      return addr;
    } else {
       return LLVMBuildIntToPtr(ctx->ac.builder, addr, ptr_type, "");
    }
-- 
GitLab


From 87315e0a28fe213a00b27add758da78147d93ed9 Mon Sep 17 00:00:00 2001
From: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
Date: Tue, 4 Oct 2022 15:00:41 +0200
Subject: [PATCH 08/26] ac/llvm: add a ac_llvm_pointer type
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

This struct stores a pointer's value and the pointee type and
will be used everywhere LLVM requires us to pass the pointee
type.

Reviewed-by: Mihai Preda <mhpreda@gmail.com>
Reviewed-by: Dave Airlie <airlied@redhat.com>
Reviewed-by: Qiang Yu <yuq825@gmail.com>
Reviewed-by: Marek Olšák <marek.olsak@amd.com>
Acked-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
---
 src/amd/llvm/ac_llvm_build.h | 15 +++++++++++++++
 1 file changed, 15 insertions(+)

diff --git a/src/amd/llvm/ac_llvm_build.h b/src/amd/llvm/ac_llvm_build.h
index 7707cb91614e..cdc1ac7d7fbb 100644
--- a/src/amd/llvm/ac_llvm_build.h
+++ b/src/amd/llvm/ac_llvm_build.h
@@ -63,6 +63,21 @@ struct ac_llvm_flow_state {
    unsigned depth;
 };
 
+struct ac_llvm_pointer {
+   union {
+      LLVMValueRef value;
+      LLVMValueRef v;
+   };
+   /* Doesn't support complex types (pointer to pointer to etc...),
+    * but this isn't a problem since there's no place where this
+    * would be required.
+    */
+   union {
+      LLVMTypeRef pointee_type;
+      LLVMTypeRef t;
+   };
+};
+
 struct ac_llvm_context {
    LLVMContextRef context;
    LLVMModuleRef module;
-- 
GitLab


From b881282324b80c955c035c54f1c0d0eeb54de4b2 Mon Sep 17 00:00:00 2001
From: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
Date: Tue, 4 Oct 2022 15:15:54 +0200
Subject: [PATCH 09/26] ac/llvm: port functions to use ac_llvm_pointer
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Reviewed-by: Mihai Preda <mhpreda@gmail.com>
Reviewed-by: Dave Airlie <airlied@redhat.com>
Reviewed-by: Qiang Yu <yuq825@gmail.com>
Reviewed-by: Marek Olšák <marek.olsak@amd.com>
Acked-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
---
 src/amd/common/ac_shader_args.h               |   1 +
 src/amd/llvm/ac_llvm_build.c                  |  14 +-
 src/amd/llvm/ac_llvm_build.h                  |  14 +-
 src/amd/vulkan/radv_nir_to_llvm.c             |  16 +--
 .../drivers/radeonsi/si_shader_internal.h     |   8 +-
 src/gallium/drivers/radeonsi/si_shader_llvm.c | 134 ++++++++++--------
 .../drivers/radeonsi/si_shader_llvm_gs.c      |   2 +-
 .../drivers/radeonsi/si_shader_llvm_ps.c      |  29 ++--
 .../drivers/radeonsi/si_shader_llvm_tess.c    |   2 +-
 .../drivers/radeonsi/si_shader_llvm_vs.c      |  31 ++--
 10 files changed, 138 insertions(+), 113 deletions(-)

diff --git a/src/amd/common/ac_shader_args.h b/src/amd/common/ac_shader_args.h
index ae9be3037800..7a2026f30007 100644
--- a/src/amd/common/ac_shader_args.h
+++ b/src/amd/common/ac_shader_args.h
@@ -40,6 +40,7 @@ enum ac_arg_regfile
 
 enum ac_arg_type
 {
+   AC_ARG_INVALID = -1,
    AC_ARG_FLOAT,
    AC_ARG_INT,
    AC_ARG_CONST_PTR,       /* Pointer to i8 array */
diff --git a/src/amd/llvm/ac_llvm_build.c b/src/amd/llvm/ac_llvm_build.c
index 7e0e16abfaa6..a3d3df8a82a2 100644
--- a/src/amd/llvm/ac_llvm_build.c
+++ b/src/amd/llvm/ac_llvm_build.c
@@ -4320,10 +4320,10 @@ LLVMValueRef ac_build_is_helper_invocation(struct ac_llvm_context *ctx)
    return LLVMBuildNot(ctx->builder, LLVMBuildAnd(ctx->builder, exact, postponed, ""), "");
 }
 
-LLVMValueRef ac_build_call(struct ac_llvm_context *ctx, LLVMValueRef func, LLVMValueRef *args,
+LLVMValueRef ac_build_call(struct ac_llvm_context *ctx, LLVMTypeRef fn_type, LLVMValueRef func, LLVMValueRef *args,
                            unsigned num_args)
 {
-   LLVMValueRef ret = LLVMBuildCall(ctx->builder, func, args, num_args, "");
+   LLVMValueRef ret = LLVMBuildCall2(ctx->builder, fn_type, func, args, num_args, "");
    LLVMSetInstructionCallConv(ret, LLVMGetFunctionCallConv(func));
    return ret;
 }
@@ -4538,6 +4538,7 @@ static LLVMTypeRef arg_llvm_type(enum ac_arg_type type, unsigned size, struct ac
          base = ctx->v8i32;
          break;
       default:
+         assert(false);
          return NULL;
    }
 
@@ -4550,7 +4551,7 @@ static LLVMTypeRef arg_llvm_type(enum ac_arg_type type, unsigned size, struct ac
    }
 }
 
-LLVMValueRef ac_build_main(const struct ac_shader_args *args, struct ac_llvm_context *ctx,
+struct ac_llvm_pointer ac_build_main(const struct ac_shader_args *args, struct ac_llvm_context *ctx,
                            enum ac_llvm_calling_convention convention, const char *name,
                            LLVMTypeRef ret_type, LLVMModuleRef module)
 {
@@ -4583,14 +4584,17 @@ LLVMValueRef ac_build_main(const struct ac_shader_args *args, struct ac_llvm_con
       }
    }
 
-   ctx->main_function = main_function;
+   ctx->main_function = (struct ac_llvm_pointer) {
+      .value = main_function,
+      .pointee_type = main_function_type
+   };
 
    /* Enable denormals for FP16 and FP64: */
    LLVMAddTargetDependentFunctionAttr(main_function, "denormal-fp-math", "ieee,ieee");
    /* Disable denormals for FP32: */
    LLVMAddTargetDependentFunctionAttr(main_function, "denormal-fp-math-f32",
                                       "preserve-sign,preserve-sign");
-   return main_function;
+   return ctx->main_function;
 }
 
 void ac_build_s_endpgm(struct ac_llvm_context *ctx)
diff --git a/src/amd/llvm/ac_llvm_build.h b/src/amd/llvm/ac_llvm_build.h
index cdc1ac7d7fbb..17372cf212c1 100644
--- a/src/amd/llvm/ac_llvm_build.h
+++ b/src/amd/llvm/ac_llvm_build.h
@@ -83,7 +83,7 @@ struct ac_llvm_context {
    LLVMModuleRef module;
    LLVMBuilderRef builder;
 
-   LLVMValueRef main_function;
+   struct ac_llvm_pointer main_function;
 
    LLVMTypeRef voidt;
    LLVMTypeRef i1;
@@ -561,8 +561,8 @@ LLVMValueRef ac_build_load_helper_invocation(struct ac_llvm_context *ctx);
 
 LLVMValueRef ac_build_is_helper_invocation(struct ac_llvm_context *ctx);
 
-LLVMValueRef ac_build_call(struct ac_llvm_context *ctx, LLVMValueRef func, LLVMValueRef *args,
-                           unsigned num_args);
+LLVMValueRef ac_build_call(struct ac_llvm_context *ctx, LLVMTypeRef fn_type, LLVMValueRef func,
+                           LLVMValueRef *args, unsigned num_args);
 
 LLVMValueRef ac_build_atomic_rmw(struct ac_llvm_context *ctx, LLVMAtomicRMWBinOp op,
                                  LLVMValueRef ptr, LLVMValueRef val, const char *sync_scope);
@@ -595,7 +595,7 @@ LLVMTypeRef ac_arg_type_to_pointee_type(struct ac_llvm_context *ctx, enum ac_arg
 static inline LLVMValueRef ac_get_arg(struct ac_llvm_context *ctx, struct ac_arg arg)
 {
    assert(arg.used);
-   return LLVMGetParam(ctx->main_function, arg.arg_index);
+   return LLVMGetParam(ctx->main_function.value, arg.arg_index);
 }
 
 static inline LLVMTypeRef ac_get_arg_pointee_type(struct ac_llvm_context *ctx, const struct ac_shader_args *args, struct ac_arg arg)
@@ -613,9 +613,9 @@ enum ac_llvm_calling_convention
    AC_LLVM_AMDGPU_HS = 93,
 };
 
-LLVMValueRef ac_build_main(const struct ac_shader_args *args, struct ac_llvm_context *ctx,
-                           enum ac_llvm_calling_convention convention, const char *name,
-                           LLVMTypeRef ret_type, LLVMModuleRef module);
+struct ac_llvm_pointer ac_build_main(const struct ac_shader_args *args, struct ac_llvm_context *ctx,
+                                     enum ac_llvm_calling_convention convention, const char *name,
+                                     LLVMTypeRef ret_type, LLVMModuleRef module);
 void ac_build_s_endpgm(struct ac_llvm_context *ctx);
 
 void ac_build_triangle_strip_indices_to_triangle(struct ac_llvm_context *ctx, LLVMValueRef is_odd,
diff --git a/src/amd/vulkan/radv_nir_to_llvm.c b/src/amd/vulkan/radv_nir_to_llvm.c
index 08da30def76a..c736926d2cbc 100644
--- a/src/amd/vulkan/radv_nir_to_llvm.c
+++ b/src/amd/vulkan/radv_nir_to_llvm.c
@@ -52,7 +52,7 @@ struct radv_shader_context {
 
    unsigned max_workgroup_size;
    LLVMContextRef context;
-   LLVMValueRef main_function;
+   struct ac_llvm_pointer main_function;
 
    LLVMValueRef descriptor_sets[MAX_SETS];
 
@@ -83,20 +83,20 @@ radv_shader_context_from_abi(struct ac_shader_abi *abi)
    return container_of(abi, struct radv_shader_context, abi);
 }
 
-static LLVMValueRef
+static struct ac_llvm_pointer
 create_llvm_function(struct ac_llvm_context *ctx, LLVMModuleRef module, LLVMBuilderRef builder,
                      const struct ac_shader_args *args, enum ac_llvm_calling_convention convention,
                      unsigned max_workgroup_size, const struct radv_nir_compiler_options *options)
 {
-   LLVMValueRef main_function = ac_build_main(args, ctx, convention, "main", ctx->voidt, module);
+   struct ac_llvm_pointer main_function = ac_build_main(args, ctx, convention, "main", ctx->voidt, module);
 
    if (options->address32_hi) {
-      ac_llvm_add_target_dep_function_attr(main_function, "amdgpu-32bit-address-high-bits",
+      ac_llvm_add_target_dep_function_attr(main_function.value, "amdgpu-32bit-address-high-bits",
                                            options->address32_hi);
    }
 
-   ac_llvm_set_workgroup_size(main_function, max_workgroup_size);
-   ac_llvm_set_target_features(main_function, ctx);
+   ac_llvm_set_workgroup_size(main_function.value, max_workgroup_size);
+   ac_llvm_set_target_features(main_function.value, ctx);
 
    return main_function;
 }
@@ -170,7 +170,7 @@ create_function(struct radv_shader_context *ctx, gl_shader_stage stage, bool has
 
    ctx->main_function =
       create_llvm_function(&ctx->ac, ctx->ac.module, ctx->ac.builder, &ctx->args->ac,
-                           get_llvm_calling_convention(ctx->main_function, stage),
+                           get_llvm_calling_convention(ctx->main_function.value, stage),
                            ctx->max_workgroup_size, ctx->options);
 
    ctx->ring_offsets = ac_build_intrinsic(&ctx->ac, "llvm.amdgcn.implicit.buffer.ptr",
@@ -1599,7 +1599,7 @@ ac_gs_copy_shader_emit(struct radv_shader_context *ctx)
    LLVMBasicBlockRef end_bb;
    LLVMValueRef switch_inst;
 
-   end_bb = LLVMAppendBasicBlockInContext(ctx->ac.context, ctx->main_function, "end");
+   end_bb = LLVMAppendBasicBlockInContext(ctx->ac.context, ctx->main_function.value, "end");
    switch_inst = LLVMBuildSwitch(ctx->ac.builder, stream_id, end_bb, 4);
 
    for (unsigned stream = 0; stream < 4; stream++) {
diff --git a/src/gallium/drivers/radeonsi/si_shader_internal.h b/src/gallium/drivers/radeonsi/si_shader_internal.h
index e75de6952ba3..d846c64632f4 100644
--- a/src/gallium/drivers/radeonsi/si_shader_internal.h
+++ b/src/gallium/drivers/radeonsi/si_shader_internal.h
@@ -56,7 +56,7 @@ struct si_shader_context {
    LLVMBasicBlockRef merged_wrap_if_entry_block;
    int merged_wrap_if_label;
 
-   LLVMValueRef main_fn;
+   struct ac_llvm_pointer main_fn;
    LLVMTypeRef return_type;
 
    struct ac_arg const_and_shader_buffers;
@@ -218,9 +218,11 @@ void si_llvm_declare_esgs_ring(struct si_shader_context *ctx);
 LLVMValueRef si_unpack_param(struct si_shader_context *ctx, struct ac_arg param, unsigned rshift,
                              unsigned bitwidth);
 LLVMValueRef si_get_primitive_id(struct si_shader_context *ctx, unsigned swizzle);
-void si_build_wrapper_function(struct si_shader_context *ctx, LLVMValueRef *parts,
+void si_build_wrapper_function(struct si_shader_context *ctx, struct ac_llvm_pointer *parts,
                                unsigned num_parts, unsigned main_part,
-                               unsigned next_shader_first_part, bool same_thread_count);
+                               unsigned next_shader_first_part,
+                               enum ac_arg_type *main_arg_types,
+                               bool same_thread_count);
 bool si_llvm_translate_nir(struct si_shader_context *ctx, struct si_shader *shader,
                            struct nir_shader *nir, bool free_nir, bool ngg_cull_shader);
 bool si_llvm_compile_shader(struct si_screen *sscreen, struct ac_llvm_compiler *compiler,
diff --git a/src/gallium/drivers/radeonsi/si_shader_llvm.c b/src/gallium/drivers/radeonsi/si_shader_llvm.c
index 75e669fa8901..03b4f10353ec 100644
--- a/src/gallium/drivers/radeonsi/si_shader_llvm.c
+++ b/src/gallium/drivers/radeonsi/si_shader_llvm.c
@@ -185,16 +185,16 @@ void si_llvm_create_func(struct si_shader_context *ctx, const char *name, LLVMTy
    ctx->return_value = LLVMGetUndef(ctx->return_type);
 
    if (ctx->screen->info.address32_hi) {
-      ac_llvm_add_target_dep_function_attr(ctx->main_fn, "amdgpu-32bit-address-high-bits",
+      ac_llvm_add_target_dep_function_attr(ctx->main_fn.value, "amdgpu-32bit-address-high-bits",
                                            ctx->screen->info.address32_hi);
    }
 
    if (ctx->stage <= MESA_SHADER_GEOMETRY && ctx->shader->key.ge.as_ngg &&
        si_shader_uses_streamout(ctx->shader))
-      ac_llvm_add_target_dep_function_attr(ctx->main_fn, "amdgpu-gds-size", 256);
+      ac_llvm_add_target_dep_function_attr(ctx->main_fn.value, "amdgpu-gds-size", 256);
 
-   ac_llvm_set_workgroup_size(ctx->main_fn, max_workgroup_size);
-   ac_llvm_set_target_features(ctx->main_fn, &ctx->ac);
+   ac_llvm_set_workgroup_size(ctx->main_fn.value, max_workgroup_size);
+   ac_llvm_set_target_features(ctx->main_fn.value, &ctx->ac);
 }
 
 void si_llvm_create_main_func(struct si_shader_context *ctx, bool ngg_cull_shader)
@@ -216,7 +216,7 @@ void si_llvm_create_main_func(struct si_shader_context *ctx, bool ngg_cull_shade
    /* Reserve register locations for VGPR inputs the PS prolog may need. */
    if (ctx->stage == MESA_SHADER_FRAGMENT && !ctx->shader->is_monolithic) {
       ac_llvm_add_target_dep_function_attr(
-         ctx->main_fn, "InitialPSInputAddr",
+         ctx->main_fn.value, "InitialPSInputAddr",
          S_0286D0_PERSP_SAMPLE_ENA(1) | S_0286D0_PERSP_CENTER_ENA(1) |
             S_0286D0_PERSP_CENTROID_ENA(1) | S_0286D0_LINEAR_SAMPLE_ENA(1) |
             S_0286D0_LINEAR_CENTER_ENA(1) | S_0286D0_LINEAR_CENTROID_ENA(1) |
@@ -314,7 +314,7 @@ LLVMValueRef si_prolog_get_internal_bindings(struct si_shader_context *ctx)
    LLVMValueRef ptr[2], list;
    bool merged_shader = si_is_merged_shader(ctx->shader);
 
-   ptr[0] = LLVMGetParam(ctx->main_fn, (merged_shader ? 8 : 0) + SI_SGPR_INTERNAL_BINDINGS);
+   ptr[0] = LLVMGetParam(ctx->main_fn.value, (merged_shader ? 8 : 0) + SI_SGPR_INTERNAL_BINDINGS);
    list =
       LLVMBuildIntToPtr(ctx->ac.builder, ptr[0], ac_array_in_const32_addr_space(ctx->ac.v4i32), "");
    return list;
@@ -420,9 +420,10 @@ static void si_llvm_declare_compute_memory(struct si_shader_context *ctx)
  * Given a list of shader part functions, build a wrapper function that
  * runs them in sequence to form a monolithic shader.
  */
-void si_build_wrapper_function(struct si_shader_context *ctx, LLVMValueRef *parts,
+void si_build_wrapper_function(struct si_shader_context *ctx, struct ac_llvm_pointer *parts,
                                unsigned num_parts, unsigned main_part,
-                               unsigned next_shader_first_part, bool same_thread_count)
+                               unsigned next_shader_first_part,
+                               enum ac_arg_type *main_arg_types, bool same_thread_count)
 {
    LLVMBuilderRef builder = ctx->ac.builder;
    /* PS epilog has one arg per color component; gfx9 merged shader
@@ -440,8 +441,8 @@ void si_build_wrapper_function(struct si_shader_context *ctx, LLVMValueRef *part
    memset(&ctx->args, 0, sizeof(ctx->args));
 
    for (unsigned i = 0; i < num_parts; ++i) {
-      ac_add_function_attr(ctx->ac.context, parts[i], -1, AC_FUNC_ATTR_ALWAYSINLINE);
-      LLVMSetLinkage(parts[i], LLVMPrivateLinkage);
+      ac_add_function_attr(ctx->ac.context, parts[i].value, -1, AC_FUNC_ATTR_ALWAYSINLINE);
+      LLVMSetLinkage(parts[i].value, LLVMPrivateLinkage);
    }
 
    /* The parameters of the wrapper function correspond to those of the
@@ -452,11 +453,11 @@ void si_build_wrapper_function(struct si_shader_context *ctx, LLVMValueRef *part
    num_sgprs = 0;
    num_vgprs = 0;
 
-   function_type = LLVMGetElementType(LLVMTypeOf(parts[0]));
+   function_type = parts[0].pointee_type;
    num_first_params = LLVMCountParamTypes(function_type);
 
    for (unsigned i = 0; i < num_first_params; ++i) {
-      LLVMValueRef param = LLVMGetParam(parts[0], i);
+      LLVMValueRef param = LLVMGetParam(parts[0].value, i);
 
       if (ac_is_sgpr_param(param)) {
          assert(num_vgprs == 0);
@@ -468,31 +469,11 @@ void si_build_wrapper_function(struct si_shader_context *ctx, LLVMValueRef *part
 
    gprs = 0;
    while (gprs < num_sgprs + num_vgprs) {
-      LLVMValueRef param = LLVMGetParam(parts[main_part], ctx->args.arg_count);
+      LLVMValueRef param = LLVMGetParam(parts[main_part].value, ctx->args.arg_count);
       LLVMTypeRef type = LLVMTypeOf(param);
       unsigned size = ac_get_type_size(type) / 4;
-
-      /* This is going to get casted anyways, so we don't have to
-       * have the exact same type. But we do have to preserve the
-       * pointer-ness so that LLVM knows about it.
-       */
-      enum ac_arg_type arg_type = AC_ARG_INT;
-      if (LLVMGetTypeKind(type) == LLVMPointerTypeKind) {
-         type = LLVMGetElementType(type);
-
-         if (LLVMGetTypeKind(type) == LLVMVectorTypeKind) {
-            if (LLVMGetVectorSize(type) == 4)
-               arg_type = AC_ARG_CONST_DESC_PTR;
-            else if (LLVMGetVectorSize(type) == 8)
-               arg_type = AC_ARG_CONST_IMAGE_PTR;
-            else
-               assert(0);
-         } else if (type == ctx->ac.f32) {
-            arg_type = AC_ARG_CONST_FLOAT_PTR;
-         } else {
-            assert(0);
-         }
-      }
+      enum ac_arg_type arg_type = main_arg_types[ctx->args.arg_count];
+      assert(arg_type != AC_ARG_INVALID);
 
       ac_add_arg(&ctx->args, gprs < num_sgprs ? AC_ARG_SGPR : AC_ARG_VGPR, size, arg_type, NULL);
 
@@ -507,7 +488,7 @@ void si_build_wrapper_function(struct si_shader_context *ctx, LLVMValueRef *part
    unsigned num_returns = 0;
    LLVMTypeRef returns[AC_MAX_ARGS], last_func_type, return_type;
 
-   last_func_type = LLVMGetElementType(LLVMTypeOf(parts[num_parts - 1]));
+   last_func_type = parts[num_parts - 1].pointee_type;
    return_type = LLVMGetReturnType(last_func_type);
 
    switch (LLVMGetTypeKind(return_type)) {
@@ -535,7 +516,7 @@ void si_build_wrapper_function(struct si_shader_context *ctx, LLVMValueRef *part
    num_out_sgpr = 0;
 
    for (unsigned i = 0; i < ctx->args.arg_count; ++i) {
-      LLVMValueRef param = LLVMGetParam(ctx->main_fn, i);
+      LLVMValueRef param = LLVMGetParam(ctx->main_fn.value, i);
       LLVMTypeRef param_type = LLVMTypeOf(param);
       LLVMTypeRef out_type = ctx->args.args[i].file == AC_ARG_SGPR ? ctx->ac.i32 : ctx->ac.f32;
       unsigned size = ac_get_type_size(param_type) / 4;
@@ -579,7 +560,7 @@ void si_build_wrapper_function(struct si_shader_context *ctx, LLVMValueRef *part
       LLVMValueRef in[AC_MAX_ARGS];
       LLVMTypeRef ret_type;
       unsigned out_idx = 0;
-      unsigned num_params = LLVMCountParams(parts[part]);
+      unsigned num_params = LLVMCountParams(parts[part].value);
 
       /* Merged shaders are executed conditionally depending
        * on the number of enabled threads passed in the input SGPRs. */
@@ -609,13 +590,13 @@ void si_build_wrapper_function(struct si_shader_context *ctx, LLVMValueRef *part
          unsigned param_size;
          LLVMValueRef arg = NULL;
 
-         param = LLVMGetParam(parts[part], param_idx);
+         param = LLVMGetParam(parts[part].value, param_idx);
          param_type = LLVMTypeOf(param);
          param_size = ac_get_type_size(param_type) / 4;
          is_sgpr = ac_is_sgpr_param(param);
 
          if (is_sgpr) {
-            ac_add_function_attr(ctx->ac.context, parts[part], param_idx + 1, AC_FUNC_ATTR_INREG);
+            ac_add_function_attr(ctx->ac.context, parts[part].value, param_idx + 1, AC_FUNC_ATTR_INREG);
          } else if (out_idx < num_out_sgpr) {
             /* Skip returned SGPRs the current part doesn't
              * declare on the input. */
@@ -647,7 +628,7 @@ void si_build_wrapper_function(struct si_shader_context *ctx, LLVMValueRef *part
          out_idx += param_size;
       }
 
-      ret = ac_build_call(&ctx->ac, parts[part], in, num_params);
+      ret = ac_build_call(&ctx->ac, parts[part].pointee_type, parts[part].value, in, num_params);
 
       if (!same_thread_count &&
           si_is_multi_part_shader(ctx->shader) && part + 1 == next_shader_first_part) {
@@ -991,7 +972,7 @@ bool si_llvm_translate_nir(struct si_shader_context *ctx, struct si_shader *shad
       si_llvm_init_ps_callbacks(ctx);
 
       unsigned colors_read = ctx->shader->selector->info.colors_read;
-      LLVMValueRef main_fn = ctx->main_fn;
+      LLVMValueRef main_fn = ctx->main_fn.value;
 
       LLVMValueRef undef = LLVMGetUndef(ctx->ac.f32);
 
@@ -1265,14 +1246,14 @@ bool si_llvm_compile_shader(struct si_screen *sscreen, struct ac_llvm_compiler *
    si_llvm_context_init(&ctx, sscreen, compiler, shader->wave_size);
    ctx.so = *so;
 
-   LLVMValueRef ngg_cull_main_fn = NULL;
+   struct ac_llvm_pointer ngg_cull_main_fn = {};
    if (sel->stage <= MESA_SHADER_TESS_EVAL && shader->key.ge.opt.ngg_culling) {
       if (!si_llvm_translate_nir(&ctx, shader, nir, false, true)) {
          si_llvm_dispose(&ctx);
          return false;
       }
       ngg_cull_main_fn = ctx.main_fn;
-      ctx.main_fn = NULL;
+      ctx.main_fn.value = NULL;
    }
 
    if (!si_llvm_translate_nir(&ctx, shader, nir, free_nir, false)) {
@@ -1281,12 +1262,18 @@ bool si_llvm_compile_shader(struct si_screen *sscreen, struct ac_llvm_compiler *
    }
 
    if (shader->is_monolithic && sel->stage == MESA_SHADER_VERTEX) {
-      LLVMValueRef parts[4];
+      struct ac_llvm_pointer parts[4];
       unsigned num_parts = 0;
       bool first_is_prolog = false;
-      LLVMValueRef main_fn = ctx.main_fn;
+      struct ac_llvm_pointer main_fn = ctx.main_fn;
+
+      /* Preserve main arguments. */
+      enum ac_arg_type main_arg_types[AC_MAX_ARGS];
+      for (int i = 0; i < ctx.args.arg_count; i++)
+         main_arg_types[i] = ctx.args.args[i].type;
+      main_arg_types[MIN2(AC_MAX_ARGS - 1, ctx.args.arg_count)] = AC_ARG_INVALID;
 
-      if (ngg_cull_main_fn) {
+      if (ngg_cull_main_fn.value) {
          if (si_vs_needs_prolog(sel, &shader->key.ge.part.vs.prolog, &shader->key, true, false)) {
             union si_shader_part_key prolog_key;
             si_get_vs_prolog_key(&sel->info, shader->info.num_input_sgprs, true,
@@ -1311,9 +1298,15 @@ bool si_llvm_compile_shader(struct si_screen *sscreen, struct ac_llvm_compiler *
       }
       parts[num_parts++] = main_fn;
 
-      si_build_wrapper_function(&ctx, parts, num_parts, first_is_prolog ? 1 : 0, 0, false);
-   } else if (shader->is_monolithic && sel->stage == MESA_SHADER_TESS_EVAL && ngg_cull_main_fn) {
-      LLVMValueRef parts[3], prolog, main_fn = ctx.main_fn;
+      si_build_wrapper_function(&ctx, parts, num_parts, first_is_prolog ? 1 : 0, 0, main_arg_types, false);
+   } else if (shader->is_monolithic && sel->stage == MESA_SHADER_TESS_EVAL && ngg_cull_main_fn.value) {
+      struct ac_llvm_pointer parts[3], prolog, main_fn = ctx.main_fn;
+
+      /* Preserve main arguments. */
+      enum ac_arg_type main_arg_types[AC_MAX_ARGS];
+      for (int i = 0; i < ctx.args.arg_count; i++)
+         main_arg_types[i] = ctx.args.args[i].type;
+      main_arg_types[MIN2(AC_MAX_ARGS - 1, ctx.args.arg_count)] = AC_ARG_INVALID;
 
       /* We reuse the VS prolog code for TES just to load the input VGPRs from LDS. */
       union si_shader_part_key prolog_key;
@@ -1330,11 +1323,14 @@ bool si_llvm_compile_shader(struct si_screen *sscreen, struct ac_llvm_compiler *
       parts[1] = prolog;
       parts[2] = main_fn;
 
-      si_build_wrapper_function(&ctx, parts, 3, 0, 0, false);
+      si_build_wrapper_function(&ctx, parts, 3, 0, 0, main_arg_types, false);
    } else if (shader->is_monolithic && sel->stage == MESA_SHADER_TESS_CTRL) {
+      /* Preserve main arguments. */
+      enum ac_arg_type main_arg_types[AC_MAX_ARGS];
+
       if (sscreen->info.gfx_level >= GFX9) {
          struct si_shader_selector *ls = shader->key.ge.part.tcs.ls;
-         LLVMValueRef parts[4];
+         struct ac_llvm_pointer parts[4];
          bool vs_needs_prolog =
             si_vs_needs_prolog(ls, &shader->key.ge.part.tcs.ls_prolog, &shader->key, false, false);
 
@@ -1366,6 +1362,10 @@ bool si_llvm_compile_shader(struct si_screen *sscreen, struct ac_llvm_compiler *
          shader->info.uses_instanceid |= ls->info.uses_instanceid;
          parts[1] = ctx.main_fn;
 
+         for (int i = 0; i < ctx.args.arg_count; i++)
+            main_arg_types[i] = ctx.args.args[i].type;
+         main_arg_types[MIN2(AC_MAX_ARGS - 1, ctx.args.arg_count)] = AC_ARG_INVALID;
+
          /* LS prolog */
          if (vs_needs_prolog) {
             union si_shader_part_key vs_prolog_key;
@@ -1382,26 +1382,33 @@ bool si_llvm_compile_shader(struct si_screen *sscreen, struct ac_llvm_compiler *
 
          si_build_wrapper_function(&ctx, parts + !vs_needs_prolog, 4 - !vs_needs_prolog,
                                    vs_needs_prolog, vs_needs_prolog ? 2 : 1,
+                                   main_arg_types,
                                    shader->key.ge.opt.same_patch_vertices);
       } else {
-         LLVMValueRef parts[2];
+         struct ac_llvm_pointer parts[2];
          union si_shader_part_key epilog_key;
 
          parts[0] = ctx.main_fn;
 
+         for (int i = 0; i < ctx.args.arg_count; i++)
+            main_arg_types[i] = ctx.args.args[i].type;
+         main_arg_types[MIN2(AC_MAX_ARGS - 1, ctx.args.arg_count)] = AC_ARG_INVALID;
+
          memset(&epilog_key, 0, sizeof(epilog_key));
          epilog_key.tcs_epilog.states = shader->key.ge.part.tcs.epilog;
          si_llvm_build_tcs_epilog(&ctx, &epilog_key);
          parts[1] = ctx.main_fn;
 
-         si_build_wrapper_function(&ctx, parts, 2, 0, 0, false);
+         si_build_wrapper_function(&ctx, parts, 2, 0, 0, main_arg_types, false);
       }
    } else if (shader->is_monolithic && sel->stage == MESA_SHADER_GEOMETRY) {
       if (ctx.screen->info.gfx_level >= GFX9) {
+         enum ac_arg_type main_arg_types[AC_MAX_ARGS];
+
          struct si_shader_selector *es = shader->key.ge.part.gs.es;
-         LLVMValueRef es_prolog = NULL;
-         LLVMValueRef es_main = NULL;
-         LLVMValueRef gs_main = ctx.main_fn;
+         struct ac_llvm_pointer es_prolog = {};
+         struct ac_llvm_pointer es_main = {};
+         struct ac_llvm_pointer gs_main = ctx.main_fn;
 
          /* ES main part */
          struct si_shader shader_es = {};
@@ -1426,6 +1433,11 @@ bool si_llvm_compile_shader(struct si_screen *sscreen, struct ac_llvm_compiler *
          shader->info.uses_instanceid |= es->info.uses_instanceid;
          es_main = ctx.main_fn;
 
+         /* Preserve main (= es_main) arguments. */
+         for (int i = 0; i < ctx.args.arg_count; i++)
+            main_arg_types[i] = ctx.args.args[i].type;
+         main_arg_types[MIN2(AC_MAX_ARGS - 1, ctx.args.arg_count)] = AC_ARG_INVALID;
+
          /* ES prolog */
          if (es->stage == MESA_SHADER_VERTEX &&
              si_vs_needs_prolog(es, &shader->key.ge.part.gs.vs_prolog, &shader->key, false, true)) {
@@ -1442,16 +1454,16 @@ bool si_llvm_compile_shader(struct si_screen *sscreen, struct ac_llvm_compiler *
          ctx.stage = MESA_SHADER_GEOMETRY;
 
          /* Prepare the array of shader parts. */
-         LLVMValueRef parts[4];
+         struct ac_llvm_pointer parts[4];
          unsigned num_parts = 0, main_part;
 
-         if (es_prolog)
+         if (es_prolog.value)
             parts[num_parts++] = es_prolog;
 
          parts[main_part = num_parts++] = es_main;
          parts[num_parts++] = gs_main;
 
-         si_build_wrapper_function(&ctx, parts, num_parts, main_part, main_part + 1, false);
+         si_build_wrapper_function(&ctx, parts, num_parts, main_part, main_part + 1, main_arg_types, false);
       } else {
          /* Nothing to do for gfx6-8. The shader has only 1 part and it's ctx.main_fn. */
       }
@@ -1462,7 +1474,7 @@ bool si_llvm_compile_shader(struct si_screen *sscreen, struct ac_llvm_compiler *
    si_llvm_optimize_module(&ctx);
 
    /* Make sure the input is a pointer and not integer followed by inttoptr. */
-   assert(LLVMGetTypeKind(LLVMTypeOf(LLVMGetParam(ctx.main_fn, 0))) == LLVMPointerTypeKind);
+   assert(LLVMGetTypeKind(LLVMTypeOf(LLVMGetParam(ctx.main_fn.value, 0))) == LLVMPointerTypeKind);
 
    /* Compile to bytecode. */
    if (!si_compile_llvm(sscreen, &shader->binary, &shader->config, compiler, &ctx.ac, debug,
diff --git a/src/gallium/drivers/radeonsi/si_shader_llvm_gs.c b/src/gallium/drivers/radeonsi/si_shader_llvm_gs.c
index 11773844c54c..9da73718b5d3 100644
--- a/src/gallium/drivers/radeonsi/si_shader_llvm_gs.c
+++ b/src/gallium/drivers/radeonsi/si_shader_llvm_gs.c
@@ -453,7 +453,7 @@ struct si_shader *si_generate_gs_copy_shader(struct si_screen *sscreen,
    LLVMBasicBlockRef end_bb;
    LLVMValueRef switch_inst;
 
-   end_bb = LLVMAppendBasicBlockInContext(ctx.ac.context, ctx.main_fn, "end");
+   end_bb = LLVMAppendBasicBlockInContext(ctx.ac.context, ctx.main_fn.value, "end");
    switch_inst = LLVMBuildSwitch(builder, stream_id, end_bb, 4);
 
    for (int stream = 0; stream < 4; stream++) {
diff --git a/src/gallium/drivers/radeonsi/si_shader_llvm_ps.c b/src/gallium/drivers/radeonsi/si_shader_llvm_ps.c
index 069a0f58a4e6..cd622a220b80 100644
--- a/src/gallium/drivers/radeonsi/si_shader_llvm_ps.c
+++ b/src/gallium/drivers/radeonsi/si_shader_llvm_ps.c
@@ -206,7 +206,7 @@ static void si_alpha_test(struct si_shader_context *ctx, LLVMValueRef alpha)
       LLVMRealPredicate cond = cond_map[ctx->shader->key.ps.part.epilog.alpha_func];
       assert(cond);
 
-      LLVMValueRef alpha_ref = LLVMGetParam(ctx->main_fn, SI_PARAM_ALPHA_REF);
+      LLVMValueRef alpha_ref = LLVMGetParam(ctx->main_fn.value, SI_PARAM_ALPHA_REF);
       if (LLVMTypeOf(alpha) == ctx->ac.f16)
          alpha_ref = LLVMBuildFPTrunc(ctx->ac.builder, alpha_ref, ctx->ac.f16, "");
 
@@ -500,7 +500,7 @@ void si_llvm_ps_build_end(struct si_shader_context *ctx)
 
    /* Set SGPRs. */
    ret = LLVMBuildInsertValue(
-      builder, ret, ac_to_integer(&ctx->ac, LLVMGetParam(ctx->main_fn, SI_PARAM_ALPHA_REF)),
+      builder, ret, ac_to_integer(&ctx->ac, LLVMGetParam(ctx->main_fn.value, SI_PARAM_ALPHA_REF)),
       SI_SGPR_ALPHA_REF, "");
 
    /* Set VGPRs */
@@ -609,7 +609,7 @@ void si_llvm_build_ps_prolog(struct si_shader_context *ctx, union si_shader_part
 
    /* Create the function. */
    si_llvm_create_func(ctx, "ps_prolog", return_types, num_returns, 0);
-   func = ctx->main_fn;
+   func = ctx->main_fn.value;
 
    /* Copy inputs to outputs. This should be no-op, as the registers match,
     * but it will prevent the compiler from overwriting them unintentionally.
@@ -849,7 +849,7 @@ void si_llvm_build_ps_epilog(struct si_shader_context *ctx, union si_shader_part
    /* Create the function. */
    si_llvm_create_func(ctx, "ps_epilog", NULL, 0, 0);
    /* Disable elimination of unused inputs. */
-   ac_llvm_add_target_dep_function_attr(ctx->main_fn, "InitialPSInputAddr", 0xffffff);
+   ac_llvm_add_target_dep_function_attr(ctx->main_fn.value, "InitialPSInputAddr", 0xffffff);
 
    /* Prepare color. */
    unsigned vgpr = ctx->args.num_sgprs_used;
@@ -861,7 +861,7 @@ void si_llvm_build_ps_epilog(struct si_shader_context *ctx, union si_shader_part
 
       if (color_type != SI_TYPE_ANY32) {
          for (i = 0; i < 4; i++) {
-            color[write_i][i] = LLVMGetParam(ctx->main_fn, vgpr + i / 2);
+            color[write_i][i] = LLVMGetParam(ctx->main_fn.value, vgpr + i / 2);
             color[write_i][i] = LLVMBuildBitCast(ctx->ac.builder, color[write_i][i],
                                                  ctx->ac.v2f16, "");
             color[write_i][i] = ac_llvm_extract_elem(&ctx->ac, color[write_i][i], i % 2);
@@ -869,7 +869,7 @@ void si_llvm_build_ps_epilog(struct si_shader_context *ctx, union si_shader_part
          vgpr += 4;
       } else {
          for (i = 0; i < 4; i++)
-            color[write_i][i] = LLVMGetParam(ctx->main_fn, vgpr++);
+            color[write_i][i] = LLVMGetParam(ctx->main_fn.value, vgpr++);
       }
 
       si_llvm_build_clamp_alpha_test(ctx, color[write_i], write_i);
@@ -888,11 +888,11 @@ void si_llvm_build_ps_epilog(struct si_shader_context *ctx, union si_shader_part
                             util_bitcount(key->ps_epilog.colors_written) * 4;
 
       if (key->ps_epilog.writes_z)
-         depth = LLVMGetParam(ctx->main_fn, vgpr_index++);
+         depth = LLVMGetParam(ctx->main_fn.value, vgpr_index++);
       if (key->ps_epilog.writes_stencil)
-         stencil = LLVMGetParam(ctx->main_fn, vgpr_index++);
+         stencil = LLVMGetParam(ctx->main_fn.value, vgpr_index++);
       if (key->ps_epilog.writes_samplemask)
-         samplemask = LLVMGetParam(ctx->main_fn, vgpr_index++);
+         samplemask = LLVMGetParam(ctx->main_fn.value, vgpr_index++);
 
       ac_export_mrt_z(&ctx->ac, depth, stencil, samplemask, mrtz_alpha, false,
                       &exp.args[exp.num++]);
@@ -932,9 +932,14 @@ void si_llvm_build_ps_epilog(struct si_shader_context *ctx, union si_shader_part
 
 void si_llvm_build_monolithic_ps(struct si_shader_context *ctx, struct si_shader *shader)
 {
-   LLVMValueRef parts[3];
+   struct ac_llvm_pointer parts[3];
    unsigned num_parts = 0, main_index;
-   LLVMValueRef main_fn = ctx->main_fn;
+   struct ac_llvm_pointer main_fn = ctx->main_fn;
+   /* Preserve main arguments. */
+   enum ac_arg_type main_arg_types[AC_MAX_ARGS];
+   for (int i = 0; i < ctx->args.arg_count; i++)
+      main_arg_types[i] = ctx->args.args[i].type;
+
 
    union si_shader_part_key prolog_key;
    si_get_ps_prolog_key(shader, &prolog_key, false);
@@ -952,7 +957,7 @@ void si_llvm_build_monolithic_ps(struct si_shader_context *ctx, struct si_shader
    si_llvm_build_ps_epilog(ctx, &epilog_key);
    parts[num_parts++] = ctx->main_fn;
 
-   si_build_wrapper_function(ctx, parts, num_parts, main_index, 0, false);
+   si_build_wrapper_function(ctx, parts, num_parts, main_index, 0, main_arg_types, false);
 }
 
 void si_llvm_init_ps_callbacks(struct si_shader_context *ctx)
diff --git a/src/gallium/drivers/radeonsi/si_shader_llvm_tess.c b/src/gallium/drivers/radeonsi/si_shader_llvm_tess.c
index 382ed80b8f19..5a5665a51f6b 100644
--- a/src/gallium/drivers/radeonsi/si_shader_llvm_tess.c
+++ b/src/gallium/drivers/radeonsi/si_shader_llvm_tess.c
@@ -275,7 +275,7 @@ static LLVMValueRef si_nir_load_tcs_varyings(struct ac_shader_abi *abi, LLVMType
 
    LLVMValueRef value[4];
    for (unsigned i = component; i < component + num_components; i++) {
-      value[i] = LLVMGetParam(ctx->main_fn, func_param + i);
+      value[i] = LLVMGetParam(ctx->main_fn.value, func_param + i);
       value[i] = LLVMBuildBitCast(ctx->ac.builder, value[i], type, "");
    }
 
diff --git a/src/gallium/drivers/radeonsi/si_shader_llvm_vs.c b/src/gallium/drivers/radeonsi/si_shader_llvm_vs.c
index 34140fa66907..ce0d34b25158 100644
--- a/src/gallium/drivers/radeonsi/si_shader_llvm_vs.c
+++ b/src/gallium/drivers/radeonsi/si_shader_llvm_vs.c
@@ -76,11 +76,11 @@ static LLVMValueRef get_vertex_index(struct si_shader_context *ctx,
    if (divisor_is_one || divisor_is_fetched) {
       /* Add StartInstance. */
       index = LLVMBuildAdd(ctx->ac.builder, index,
-                           LLVMGetParam(ctx->main_fn, start_instance), "");
+                           LLVMGetParam(ctx->main_fn.value, start_instance), "");
    } else {
       /* VertexID + BaseVertex */
       index = LLVMBuildAdd(ctx->ac.builder, vertex_id,
-                           LLVMGetParam(ctx->main_fn, base_vertex), "");
+                           LLVMGetParam(ctx->main_fn.value, base_vertex), "");
    }
 
    return index;
@@ -103,8 +103,8 @@ static void load_input_vs(struct si_shader_context *ctx, unsigned input_index, L
       unsigned param_vs_blit_inputs = ctx->vs_blit_inputs.arg_index;
       if (input_index == 0) {
          /* Position: */
-         LLVMValueRef x1y1 = LLVMGetParam(ctx->main_fn, param_vs_blit_inputs);
-         LLVMValueRef x2y2 = LLVMGetParam(ctx->main_fn, param_vs_blit_inputs + 1);
+         LLVMValueRef x1y1 = LLVMGetParam(ctx->main_fn.value, param_vs_blit_inputs);
+         LLVMValueRef x2y2 = LLVMGetParam(ctx->main_fn.value, param_vs_blit_inputs + 1);
 
          LLVMValueRef x1 = unpack_sint16(ctx, x1y1, 0);
          LLVMValueRef y1 = unpack_sint16(ctx, x1y1, 1);
@@ -116,7 +116,7 @@ static void load_input_vs(struct si_shader_context *ctx, unsigned input_index, L
 
          out[0] = LLVMBuildSIToFP(ctx->ac.builder, x, ctx->ac.f32, "");
          out[1] = LLVMBuildSIToFP(ctx->ac.builder, y, ctx->ac.f32, "");
-         out[2] = LLVMGetParam(ctx->main_fn, param_vs_blit_inputs + 2);
+         out[2] = LLVMGetParam(ctx->main_fn.value, param_vs_blit_inputs + 2);
          out[3] = ctx->ac.f32_1;
          return;
       }
@@ -126,19 +126,19 @@ static void load_input_vs(struct si_shader_context *ctx, unsigned input_index, L
 
       if (vs_blit_property == SI_VS_BLIT_SGPRS_POS_COLOR) {
          for (int i = 0; i < 4; i++) {
-            out[i] = LLVMGetParam(ctx->main_fn, param_vs_blit_inputs + 3 + i);
+            out[i] = LLVMGetParam(ctx->main_fn.value, param_vs_blit_inputs + 3 + i);
          }
       } else {
          assert(vs_blit_property == SI_VS_BLIT_SGPRS_POS_TEXCOORD);
-         LLVMValueRef x1 = LLVMGetParam(ctx->main_fn, param_vs_blit_inputs + 3);
-         LLVMValueRef y1 = LLVMGetParam(ctx->main_fn, param_vs_blit_inputs + 4);
-         LLVMValueRef x2 = LLVMGetParam(ctx->main_fn, param_vs_blit_inputs + 5);
-         LLVMValueRef y2 = LLVMGetParam(ctx->main_fn, param_vs_blit_inputs + 6);
+         LLVMValueRef x1 = LLVMGetParam(ctx->main_fn.value, param_vs_blit_inputs + 3);
+         LLVMValueRef y1 = LLVMGetParam(ctx->main_fn.value, param_vs_blit_inputs + 4);
+         LLVMValueRef x2 = LLVMGetParam(ctx->main_fn.value, param_vs_blit_inputs + 5);
+         LLVMValueRef y2 = LLVMGetParam(ctx->main_fn.value, param_vs_blit_inputs + 6);
 
          out[0] = LLVMBuildSelect(ctx->ac.builder, sel_x1, x1, x2, "");
          out[1] = LLVMBuildSelect(ctx->ac.builder, sel_y1, y1, y2, "");
-         out[2] = LLVMGetParam(ctx->main_fn, param_vs_blit_inputs + 7);
-         out[3] = LLVMGetParam(ctx->main_fn, param_vs_blit_inputs + 8);
+         out[2] = LLVMGetParam(ctx->main_fn.value, param_vs_blit_inputs + 7);
+         out[3] = LLVMGetParam(ctx->main_fn.value, param_vs_blit_inputs + 8);
       }
       return;
    }
@@ -183,8 +183,9 @@ static void load_input_vs(struct si_shader_context *ctx, unsigned input_index, L
                                       input_index, ctx->instance_divisor_constbuf,
                                       ctx->args.start_instance.arg_index,
                                       ctx->args.base_vertex.arg_index);
-   } else
-      vertex_index = LLVMGetParam(ctx->main_fn, ctx->vertex_index0.arg_index + input_index);
+   } else {
+      vertex_index = LLVMGetParam(ctx->main_fn.value, ctx->vertex_index0.arg_index + input_index);
+   }
 
    /* Use the open-coded implementation for all loads of doubles and
     * of dword-sized data that needs fixups. We need to insert conversion
@@ -961,7 +962,7 @@ void si_llvm_build_vs_prolog(struct si_shader_context *ctx, union si_shader_part
 
    /* Create the function. */
    si_llvm_create_func(ctx, "vs_prolog", returns, num_returns, 0);
-   func = ctx->main_fn;
+   func = ctx->main_fn.value;
 
    for (i = 0; i < num_input_vgprs; i++) {
       input_vgprs[i] = ac_get_arg(&ctx->ac, input_vgpr_param[i]);
-- 
GitLab


From 215969c43c4285791e4b7b3cb2e621a1a5f0348f Mon Sep 17 00:00:00 2001
From: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
Date: Thu, 6 Oct 2022 11:03:14 +0200
Subject: [PATCH 10/26] ac/llvm: switch ac_build_gep_ptr to LLVMBuildGEP2
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Reviewed-by: Mihai Preda <mhpreda@gmail.com>
Reviewed-by: Dave Airlie <airlied@redhat.com>
Reviewed-by: Qiang Yu <yuq825@gmail.com>
Reviewed-by: Marek Olšák <marek.olsak@amd.com>
Acked-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
---
 src/amd/llvm/ac_llvm_build.c                    | 4 ++--
 src/amd/llvm/ac_llvm_build.h                    | 2 +-
 src/amd/llvm/ac_nir_to_llvm.c                   | 2 +-
 src/gallium/drivers/radeonsi/gfx10_shader_ngg.c | 2 +-
 4 files changed, 5 insertions(+), 5 deletions(-)

diff --git a/src/amd/llvm/ac_llvm_build.c b/src/amd/llvm/ac_llvm_build.c
index a3d3df8a82a2..be3b9d8f8d2d 100644
--- a/src/amd/llvm/ac_llvm_build.c
+++ b/src/amd/llvm/ac_llvm_build.c
@@ -1084,10 +1084,10 @@ LLVMValueRef ac_build_fs_interp_mov(struct ac_llvm_context *ctx, LLVMValueRef pa
    }
 }
 
-LLVMValueRef ac_build_gep_ptr(struct ac_llvm_context *ctx, LLVMValueRef base_ptr,
+LLVMValueRef ac_build_gep_ptr(struct ac_llvm_context *ctx, LLVMTypeRef type, LLVMValueRef base_ptr,
                               LLVMValueRef index)
 {
-   return LLVMBuildGEP(ctx->builder, base_ptr, &index, 1, "");
+   return LLVMBuildGEP2(ctx->builder, type, base_ptr, &index, 1, "");
 }
 
 LLVMValueRef ac_build_gep0(struct ac_llvm_context *ctx, LLVMValueRef base_ptr, LLVMValueRef index)
diff --git a/src/amd/llvm/ac_llvm_build.h b/src/amd/llvm/ac_llvm_build.h
index 17372cf212c1..2ba7e3df487a 100644
--- a/src/amd/llvm/ac_llvm_build.h
+++ b/src/amd/llvm/ac_llvm_build.h
@@ -251,7 +251,7 @@ LLVMValueRef ac_build_fs_interp_mov(struct ac_llvm_context *ctx, LLVMValueRef pa
                                     LLVMValueRef llvm_chan, LLVMValueRef attr_number,
                                     LLVMValueRef params);
 
-LLVMValueRef ac_build_gep_ptr(struct ac_llvm_context *ctx, LLVMValueRef base_ptr,
+LLVMValueRef ac_build_gep_ptr(struct ac_llvm_context *ctx, LLVMTypeRef type, LLVMValueRef base_ptr,
                               LLVMValueRef index);
 
 LLVMValueRef ac_build_gep0(struct ac_llvm_context *ctx, LLVMValueRef base_ptr, LLVMValueRef index);
diff --git a/src/amd/llvm/ac_nir_to_llvm.c b/src/amd/llvm/ac_nir_to_llvm.c
index 7a233d7d0cfa..b6f6be1d6d6f 100644
--- a/src/amd/llvm/ac_nir_to_llvm.c
+++ b/src/amd/llvm/ac_nir_to_llvm.c
@@ -4389,7 +4389,7 @@ static bool visit_intrinsic(struct ac_nir_context *ctx, nir_intrinsic_instr *ins
       for (unsigned i = 0; i < instr->num_components; i++) {
          if (write_mask & (1 << i)) {
             LLVMValueRef gds_ptr =
-               ac_build_gep_ptr(&ctx->ac, gdsbase, LLVMConstInt(ctx->ac.i32, i, 0));
+               ac_build_gep_ptr(&ctx->ac, ctx->ac.i32, gdsbase, LLVMConstInt(ctx->ac.i32, i, 0));
             LLVMValueRef count =
                LLVMBuildExtractElement(ctx->ac.builder, add_count,
                                        LLVMConstInt(ctx->ac.i32, i, false), "");
diff --git a/src/gallium/drivers/radeonsi/gfx10_shader_ngg.c b/src/gallium/drivers/radeonsi/gfx10_shader_ngg.c
index 95deba0355cb..a8e4f654aaec 100644
--- a/src/gallium/drivers/radeonsi/gfx10_shader_ngg.c
+++ b/src/gallium/drivers/radeonsi/gfx10_shader_ngg.c
@@ -412,7 +412,7 @@ static void build_streamout(struct si_shader_context *ctx, struct ngg_streamout
             for (unsigned i = 0; i < 4; i++) {
                if (ctx->shader->selector->info.base.xfb_stride[i]) {
                   LLVMValueRef gds_ptr =
-                     ac_build_gep_ptr(&ctx->ac, gdsbase, LLVMConstInt(ctx->ac.i32, i, 0));
+                     ac_build_gep_ptr(&ctx->ac, ctx->ac.i32, gdsbase, LLVMConstInt(ctx->ac.i32, i, 0));
 
                   dwords_written[i] = LLVMBuildAtomicRMW(builder, LLVMAtomicRMWBinOpAdd,
                                                          gds_ptr, dwords_written[i],
-- 
GitLab


From abd9fdbbdc9e8b9ee3f13a119b5ea2938e6458c6 Mon Sep 17 00:00:00 2001
From: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
Date: Thu, 6 Oct 2022 11:11:57 +0200
Subject: [PATCH 11/26] ac/llvm: switch ac_build_pointer_add to LLVMBuildGEP2
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

The cast was superfluous: GEP2 return value is a pointer to
the given type.

Reviewed-by: Mihai Preda <mhpreda@gmail.com>
Reviewed-by: Dave Airlie <airlied@redhat.com>
Reviewed-by: Qiang Yu <yuq825@gmail.com>
Reviewed-by: Marek Olšák <marek.olsak@amd.com>
Acked-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
---
 src/amd/llvm/ac_llvm_build.c                            | 5 ++---
 src/amd/llvm/ac_llvm_build.h                            | 2 +-
 src/gallium/drivers/radeonsi/si_shader_llvm_resources.c | 2 +-
 3 files changed, 4 insertions(+), 5 deletions(-)

diff --git a/src/amd/llvm/ac_llvm_build.c b/src/amd/llvm/ac_llvm_build.c
index be3b9d8f8d2d..7122063d45eb 100644
--- a/src/amd/llvm/ac_llvm_build.c
+++ b/src/amd/llvm/ac_llvm_build.c
@@ -1099,10 +1099,9 @@ LLVMValueRef ac_build_gep0(struct ac_llvm_context *ctx, LLVMValueRef base_ptr, L
    return LLVMBuildGEP(ctx->builder, base_ptr, indices, 2, "");
 }
 
-LLVMValueRef ac_build_pointer_add(struct ac_llvm_context *ctx, LLVMValueRef ptr, LLVMValueRef index)
+LLVMValueRef ac_build_pointer_add(struct ac_llvm_context *ctx, LLVMTypeRef type, LLVMValueRef ptr, LLVMValueRef index)
 {
-   LLVMValueRef offset_ptr = LLVMBuildGEP(ctx->builder, ptr, &index, 1, "");
-   return LLVMBuildPointerCast(ctx->builder, offset_ptr, LLVMTypeOf(ptr), "");
+   return LLVMBuildGEP2(ctx->builder, type, ptr, &index, 1, "");
 }
 
 void ac_build_indexed_store(struct ac_llvm_context *ctx, LLVMValueRef base_ptr, LLVMValueRef index,
diff --git a/src/amd/llvm/ac_llvm_build.h b/src/amd/llvm/ac_llvm_build.h
index 2ba7e3df487a..add6cc2ed4fe 100644
--- a/src/amd/llvm/ac_llvm_build.h
+++ b/src/amd/llvm/ac_llvm_build.h
@@ -255,7 +255,7 @@ LLVMValueRef ac_build_gep_ptr(struct ac_llvm_context *ctx, LLVMTypeRef type, LLV
                               LLVMValueRef index);
 
 LLVMValueRef ac_build_gep0(struct ac_llvm_context *ctx, LLVMValueRef base_ptr, LLVMValueRef index);
-LLVMValueRef ac_build_pointer_add(struct ac_llvm_context *ctx, LLVMValueRef ptr,
+LLVMValueRef ac_build_pointer_add(struct ac_llvm_context *ctx, LLVMTypeRef type, LLVMValueRef ptr,
                                   LLVMValueRef index);
 
 void ac_build_indexed_store(struct ac_llvm_context *ctx, LLVMValueRef base_ptr, LLVMValueRef index,
diff --git a/src/gallium/drivers/radeonsi/si_shader_llvm_resources.c b/src/gallium/drivers/radeonsi/si_shader_llvm_resources.c
index 5a0ab62250a1..8cbc8e5ca6f2 100644
--- a/src/gallium/drivers/radeonsi/si_shader_llvm_resources.c
+++ b/src/gallium/drivers/radeonsi/si_shader_llvm_resources.c
@@ -279,7 +279,7 @@ static LLVMValueRef si_nir_load_sampler_desc(struct ac_shader_abi *abi, unsigned
        */
       dynamic_index =
          LLVMBuildMul(ctx->ac.builder, dynamic_index, LLVMConstInt(ctx->ac.i64, 2, 0), "");
-      list = ac_build_pointer_add(&ctx->ac, list, dynamic_index);
+      list = ac_build_pointer_add(&ctx->ac, ctx->ac.v8i32, list, dynamic_index);
       return si_load_sampler_desc(ctx, list, ctx->ac.i32_0, desc_type);
    }
 
-- 
GitLab


From 8785391135b8e40650a291da310f48cf0f5d2214 Mon Sep 17 00:00:00 2001
From: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
Date: Mon, 10 Oct 2022 11:44:27 +0200
Subject: [PATCH 12/26] ac/llvm: add type param to ac_build_load_invariant
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

And adapt the only user of this function.

Reviewed-by: Mihai Preda <mhpreda@gmail.com>
Reviewed-by: Dave Airlie <airlied@redhat.com>
Reviewed-by: Qiang Yu <yuq825@gmail.com>
Reviewed-by: Marek Olšák <marek.olsak@amd.com>
Acked-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
---
 src/amd/llvm/ac_llvm_build.c  | 2 +-
 src/amd/llvm/ac_llvm_build.h  | 2 +-
 src/amd/llvm/ac_nir_to_llvm.c | 4 +---
 3 files changed, 3 insertions(+), 5 deletions(-)

diff --git a/src/amd/llvm/ac_llvm_build.c b/src/amd/llvm/ac_llvm_build.c
index 7122063d45eb..01e92298de54 100644
--- a/src/amd/llvm/ac_llvm_build.c
+++ b/src/amd/llvm/ac_llvm_build.c
@@ -1164,7 +1164,7 @@ LLVMValueRef ac_build_load(struct ac_llvm_context *ctx, LLVMValueRef base_ptr, L
    return ac_build_load_custom(ctx, base_ptr, index, false, false, false);
 }
 
-LLVMValueRef ac_build_load_invariant(struct ac_llvm_context *ctx, LLVMValueRef base_ptr,
+LLVMValueRef ac_build_load_invariant(struct ac_llvm_context *ctx, LLVMTypeRef type, LLVMValueRef base_ptr,
                                      LLVMValueRef index)
 {
    return ac_build_load_custom(ctx, base_ptr, index, false, true, false);
diff --git a/src/amd/llvm/ac_llvm_build.h b/src/amd/llvm/ac_llvm_build.h
index add6cc2ed4fe..b9b3d06f661d 100644
--- a/src/amd/llvm/ac_llvm_build.h
+++ b/src/amd/llvm/ac_llvm_build.h
@@ -262,7 +262,7 @@ void ac_build_indexed_store(struct ac_llvm_context *ctx, LLVMValueRef base_ptr,
                             LLVMValueRef value);
 
 LLVMValueRef ac_build_load(struct ac_llvm_context *ctx, LLVMValueRef base_ptr, LLVMValueRef index);
-LLVMValueRef ac_build_load_invariant(struct ac_llvm_context *ctx, LLVMValueRef base_ptr,
+LLVMValueRef ac_build_load_invariant(struct ac_llvm_context *ctx, LLVMTypeRef type, LLVMValueRef base_ptr,
                                      LLVMValueRef index);
 LLVMValueRef ac_build_load_to_sgpr(struct ac_llvm_context *ctx, LLVMValueRef base_ptr,
                                    LLVMValueRef index);
diff --git a/src/amd/llvm/ac_nir_to_llvm.c b/src/amd/llvm/ac_nir_to_llvm.c
index b6f6be1d6d6f..dc16a673a13c 100644
--- a/src/amd/llvm/ac_nir_to_llvm.c
+++ b/src/amd/llvm/ac_nir_to_llvm.c
@@ -3724,10 +3724,8 @@ static bool visit_intrinsic(struct ac_nir_context *ctx, nir_intrinsic_instr *ins
       if (ctx->abi->load_grid_size_from_user_sgpr) {
          result = ac_get_arg(&ctx->ac, ctx->args->num_work_groups);
       } else {
-         LLVMTypeRef ptr_type = ac_array_in_const_addr_space(ctx->ac.v3i32);
          LLVMValueRef ptr = ac_get_arg(&ctx->ac, ctx->args->num_work_groups);
-         ptr = LLVMBuildBitCast(ctx->ac.builder, ptr, ptr_type, "");
-         result = ac_build_load_invariant(&ctx->ac, ptr, ctx->ac.i32_0);
+         result = ac_build_load_invariant(&ctx->ac, ctx->ac.v3i32, ptr, ctx->ac.i32_0);
       }
       if (nir_dest_bit_size(instr->dest) == 64)
          result = LLVMBuildZExt(ctx->ac.builder, result, LLVMVectorType(ctx->ac.i64, 3), "");
-- 
GitLab


From 3d7c08eb9c4d0abc8e06047a189db2ce85ad56ff Mon Sep 17 00:00:00 2001
From: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
Date: Mon, 10 Oct 2022 12:13:02 +0200
Subject: [PATCH 13/26] ac/llvm: add xxxx2 functions to iteratively port to
 opaque pointers
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Reviewed-by: Mihai Preda <mhpreda@gmail.com>
Reviewed-by: Dave Airlie <airlied@redhat.com>
Reviewed-by: Qiang Yu <yuq825@gmail.com>
Reviewed-by: Marek Olšák <marek.olsak@amd.com>
Acked-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
---
 src/amd/llvm/ac_llvm_build.c | 76 ++++++++++++++++++++++++++++++++++--
 src/amd/llvm/ac_llvm_build.h | 13 +++++-
 2 files changed, 84 insertions(+), 5 deletions(-)

diff --git a/src/amd/llvm/ac_llvm_build.c b/src/amd/llvm/ac_llvm_build.c
index 01e92298de54..7b0390d7ca32 100644
--- a/src/amd/llvm/ac_llvm_build.c
+++ b/src/amd/llvm/ac_llvm_build.c
@@ -1099,6 +1099,38 @@ LLVMValueRef ac_build_gep0(struct ac_llvm_context *ctx, LLVMValueRef base_ptr, L
    return LLVMBuildGEP(ctx->builder, base_ptr, indices, 2, "");
 }
 
+LLVMTypeRef ac_build_gep0_type(LLVMTypeRef pointee_type, LLVMValueRef index)
+{
+   switch (LLVMGetTypeKind(pointee_type)) {
+      case LLVMPointerTypeKind:
+         return pointee_type;
+      case LLVMArrayTypeKind:
+         /* If input is a pointer to an array GEP2 will return a pointer to
+          * the array elements type.
+          */
+         return LLVMGetElementType(pointee_type);
+      case LLVMStructTypeKind:
+         /* If input is a pointer to a struct, GEP2 will return a pointer to
+          * the index-nth field, so get its type.
+          */
+         return LLVMStructGetTypeAtIndex(pointee_type, LLVMConstIntGetZExtValue(index));
+      default:
+         /* gep0 shouldn't receive any other types. */
+         assert(false);
+   }
+   return NULL;
+}
+
+LLVMValueRef ac_build_gep0_2(struct ac_llvm_context *ctx, LLVMTypeRef pointee_type, LLVMValueRef value, LLVMValueRef index)
+{
+   LLVMValueRef indices[2] = {
+      ctx->i32_0,
+      index,
+   };
+
+   return LLVMBuildGEP2(ctx->builder, pointee_type, value, indices, 2, "");
+}
+
 LLVMValueRef ac_build_pointer_add(struct ac_llvm_context *ctx, LLVMTypeRef type, LLVMValueRef ptr, LLVMValueRef index)
 {
    return LLVMBuildGEP2(ctx->builder, type, ptr, &index, 1, "");
@@ -1110,6 +1142,12 @@ void ac_build_indexed_store(struct ac_llvm_context *ctx, LLVMValueRef base_ptr,
    LLVMBuildStore(ctx->builder, value, ac_build_gep0(ctx, base_ptr, index));
 }
 
+void ac_build_indexed_store2(struct ac_llvm_context *ctx, LLVMTypeRef type, LLVMValueRef base_ptr, LLVMValueRef index,
+                             LLVMValueRef value)
+{
+   LLVMBuildStore(ctx->builder, value, ac_build_gep0_2(ctx, type, base_ptr, index));
+}
+
 /**
  * Build an LLVM bytecode indexed load using LLVMBuildGEP + LLVMBuildLoad.
  * It's equivalent to doing a load from &base_ptr[index].
@@ -1159,15 +1197,36 @@ static LLVMValueRef ac_build_load_custom(struct ac_llvm_context *ctx, LLVMValueR
    return result;
 }
 
-LLVMValueRef ac_build_load(struct ac_llvm_context *ctx, LLVMValueRef base_ptr, LLVMValueRef index)
+static LLVMValueRef ac_build_load_custom2(struct ac_llvm_context *ctx, LLVMTypeRef type,
+                                          LLVMValueRef base_ptr, LLVMValueRef index,
+                                          bool uniform, bool invariant, bool no_unsigned_wraparound)
+{
+   LLVMValueRef pointer, result;
+
+   if (no_unsigned_wraparound &&
+       LLVMGetPointerAddressSpace(LLVMTypeOf(base_ptr)) == AC_ADDR_SPACE_CONST_32BIT)
+      pointer = LLVMBuildInBoundsGEP2(ctx->builder, type, base_ptr, &index, 1, "");
+   else
+      pointer = LLVMBuildGEP2(ctx->builder, type, base_ptr, &index, 1, "");
+
+   if (uniform)
+      LLVMSetMetadata(pointer, ctx->uniform_md_kind, ctx->empty_md);
+   result = LLVMBuildLoad2(ctx->builder, type, pointer, "");
+   if (invariant)
+      LLVMSetMetadata(result, ctx->invariant_load_md_kind, ctx->empty_md);
+   LLVMSetAlignment(result, 4);
+   return result;
+}
+
+LLVMValueRef ac_build_load(struct ac_llvm_context *ctx, LLVMTypeRef type, LLVMValueRef base_ptr, LLVMValueRef index)
 {
-   return ac_build_load_custom(ctx, base_ptr, index, false, false, false);
+   return ac_build_load_custom2(ctx, type, base_ptr, index, false, false, false);
 }
 
 LLVMValueRef ac_build_load_invariant(struct ac_llvm_context *ctx, LLVMTypeRef type, LLVMValueRef base_ptr,
                                      LLVMValueRef index)
 {
-   return ac_build_load_custom(ctx, base_ptr, index, false, true, false);
+   return ac_build_load_custom2(ctx, type, base_ptr, index, false, true, false);
 }
 
 /* This assumes that there is no unsigned integer wraparound during the address
@@ -1178,12 +1237,23 @@ LLVMValueRef ac_build_load_to_sgpr(struct ac_llvm_context *ctx, LLVMValueRef bas
    return ac_build_load_custom(ctx, base_ptr, index, true, true, true);
 }
 
+LLVMValueRef ac_build_load_to_sgpr2(struct ac_llvm_context *ctx, LLVMTypeRef type, LLVMValueRef base_ptr,
+                                    LLVMValueRef index)
+{
+   return ac_build_load_custom2(ctx, type, base_ptr, index, true, true, true);
+}
+
 /* See ac_build_load_custom() documentation. */
 LLVMValueRef ac_build_load_to_sgpr_uint_wraparound(struct ac_llvm_context *ctx,
                                                    LLVMValueRef base_ptr, LLVMValueRef index)
 {
    return ac_build_load_custom(ctx, base_ptr, index, true, true, false);
 }
+LLVMValueRef ac_build_load_to_sgpr_uint_wraparound2(struct ac_llvm_context *ctx, LLVMTypeRef type,
+                                                   LLVMValueRef base_ptr, LLVMValueRef index)
+{
+   return ac_build_load_custom2(ctx, type, base_ptr, index, true, true, false);
+}
 
 static unsigned get_load_cache_policy(struct ac_llvm_context *ctx, unsigned cache_policy)
 {
diff --git a/src/amd/llvm/ac_llvm_build.h b/src/amd/llvm/ac_llvm_build.h
index b9b3d06f661d..dee1bce44de9 100644
--- a/src/amd/llvm/ac_llvm_build.h
+++ b/src/amd/llvm/ac_llvm_build.h
@@ -254,20 +254,29 @@ LLVMValueRef ac_build_fs_interp_mov(struct ac_llvm_context *ctx, LLVMValueRef pa
 LLVMValueRef ac_build_gep_ptr(struct ac_llvm_context *ctx, LLVMTypeRef type, LLVMValueRef base_ptr,
                               LLVMValueRef index);
 
-LLVMValueRef ac_build_gep0(struct ac_llvm_context *ctx, LLVMValueRef base_ptr, LLVMValueRef index);
+LLVMValueRef ac_build_gep0(struct ac_llvm_context *ctx, LLVMValueRef value, LLVMValueRef index);
 LLVMValueRef ac_build_pointer_add(struct ac_llvm_context *ctx, LLVMTypeRef type, LLVMValueRef ptr,
                                   LLVMValueRef index);
 
+LLVMTypeRef ac_build_gep0_type(LLVMTypeRef pointee_type, LLVMValueRef index);
+LLVMValueRef ac_build_gep0_2(struct ac_llvm_context *ctx, LLVMTypeRef type, LLVMValueRef value, LLVMValueRef index);
+
 void ac_build_indexed_store(struct ac_llvm_context *ctx, LLVMValueRef base_ptr, LLVMValueRef index,
                             LLVMValueRef value);
+void ac_build_indexed_store2(struct ac_llvm_context *ctx, LLVMTypeRef type, LLVMValueRef base_ptr, LLVMValueRef index,
+                             LLVMValueRef value);
 
-LLVMValueRef ac_build_load(struct ac_llvm_context *ctx, LLVMValueRef base_ptr, LLVMValueRef index);
+LLVMValueRef ac_build_load(struct ac_llvm_context *ctx, LLVMTypeRef type, LLVMValueRef base_ptr, LLVMValueRef index);
 LLVMValueRef ac_build_load_invariant(struct ac_llvm_context *ctx, LLVMTypeRef type, LLVMValueRef base_ptr,
                                      LLVMValueRef index);
 LLVMValueRef ac_build_load_to_sgpr(struct ac_llvm_context *ctx, LLVMValueRef base_ptr,
                                    LLVMValueRef index);
+LLVMValueRef ac_build_load_to_sgpr2(struct ac_llvm_context *ctx, LLVMTypeRef type, LLVMValueRef base_ptr,
+                                    LLVMValueRef index);
 LLVMValueRef ac_build_load_to_sgpr_uint_wraparound(struct ac_llvm_context *ctx,
                                                    LLVMValueRef base_ptr, LLVMValueRef index);
+LLVMValueRef ac_build_load_to_sgpr_uint_wraparound2(struct ac_llvm_context *ctx, LLVMTypeRef type,
+                                                   LLVMValueRef base_ptr, LLVMValueRef index);
 
 void ac_build_buffer_store_dword(struct ac_llvm_context *ctx, LLVMValueRef rsrc, LLVMValueRef vdata,
                                  LLVMValueRef vindex, LLVMValueRef voffset, LLVMValueRef soffset,
-- 
GitLab


From 5068647d1688390ed4909e06b559218cf268376d Mon Sep 17 00:00:00 2001
From: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
Date: Mon, 10 Oct 2022 12:21:33 +0200
Subject: [PATCH 14/26] ac/llvm: store lds as ac_llvm_pointer
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

This way we can pass the type information to LLVM when needed.

Reviewed-by: Mihai Preda <mhpreda@gmail.com>
Reviewed-by: Dave Airlie <airlied@redhat.com>
Reviewed-by: Qiang Yu <yuq825@gmail.com>
Reviewed-by: Marek Olšák <marek.olsak@amd.com>
Acked-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
---
 src/amd/llvm/ac_llvm_build.c                  | 14 +++++++++-----
 src/amd/llvm/ac_llvm_build.h                  |  2 +-
 src/amd/llvm/ac_nir_to_llvm.c                 |  9 ++++++---
 src/gallium/drivers/radeonsi/si_shader_llvm.c | 19 +++++++++++++------
 .../drivers/radeonsi/si_shader_llvm_gs.c      |  5 ++++-
 5 files changed, 33 insertions(+), 16 deletions(-)

diff --git a/src/amd/llvm/ac_llvm_build.c b/src/amd/llvm/ac_llvm_build.c
index 7b0390d7ca32..4c09ed8feea9 100644
--- a/src/amd/llvm/ac_llvm_build.c
+++ b/src/amd/llvm/ac_llvm_build.c
@@ -2820,20 +2820,24 @@ void ac_init_exec_full_mask(struct ac_llvm_context *ctx)
 void ac_declare_lds_as_pointer(struct ac_llvm_context *ctx)
 {
    unsigned lds_size = ctx->gfx_level >= GFX7 ? 65536 : 32768;
-   ctx->lds = LLVMBuildIntToPtr(
-      ctx->builder, ctx->i32_0,
-      LLVMPointerType(LLVMArrayType(ctx->i32, lds_size / 4), AC_ADDR_SPACE_LDS), "lds");
+   LLVMTypeRef type = LLVMArrayType(ctx->i32, lds_size / 4);
+   ctx->lds = (struct ac_llvm_pointer) {
+      .value = LLVMBuildIntToPtr(ctx->builder, ctx->i32_0,
+                  LLVMPointerType(type, AC_ADDR_SPACE_LDS), "lds"),
+      .pointee_type = type
+   };
 }
 
 LLVMValueRef ac_lds_load(struct ac_llvm_context *ctx, LLVMValueRef dw_addr)
 {
-   return LLVMBuildLoad2(ctx->builder, ctx->i32, ac_build_gep0(ctx, ctx->lds, dw_addr), "");
+   LLVMValueRef v = ac_build_gep0_2(ctx, ctx->lds.t, ctx->lds.v, dw_addr);
+   return LLVMBuildLoad2(ctx->builder, ctx->i32, v, "");
 }
 
 void ac_lds_store(struct ac_llvm_context *ctx, LLVMValueRef dw_addr, LLVMValueRef value)
 {
    value = ac_to_integer(ctx, value);
-   ac_build_indexed_store(ctx, ctx->lds, dw_addr, value);
+   ac_build_indexed_store2(ctx, ctx->lds.t, ctx->lds.v, dw_addr, value);
 }
 
 LLVMValueRef ac_find_lsb(struct ac_llvm_context *ctx, LLVMTypeRef dst_type, LLVMValueRef src0)
diff --git a/src/amd/llvm/ac_llvm_build.h b/src/amd/llvm/ac_llvm_build.h
index dee1bce44de9..aeee00ee5176 100644
--- a/src/amd/llvm/ac_llvm_build.h
+++ b/src/amd/llvm/ac_llvm_build.h
@@ -156,7 +156,7 @@ struct ac_llvm_context {
 
    unsigned float_mode;
 
-   LLVMValueRef lds;
+   struct ac_llvm_pointer lds;
 };
 
 void ac_llvm_context_init(struct ac_llvm_context *ctx, struct ac_llvm_compiler *compiler,
diff --git a/src/amd/llvm/ac_nir_to_llvm.c b/src/amd/llvm/ac_nir_to_llvm.c
index dc16a673a13c..f46e050ac2b2 100644
--- a/src/amd/llvm/ac_nir_to_llvm.c
+++ b/src/amd/llvm/ac_nir_to_llvm.c
@@ -84,7 +84,7 @@ static LLVMValueRef get_memory_ptr(struct ac_nir_context *ctx, nir_src src, unsi
    LLVMValueRef ptr = get_src(ctx, src);
    ptr = LLVMBuildAdd(ctx->ac.builder, ptr, LLVMConstInt(ctx->ac.i32, c_off, 0), "");
    /* LDS is used here as a i8 pointer. */
-   return LLVMBuildGEP2(ctx->ac.builder, ctx->ac.i8, ctx->ac.lds, &ptr, 1, "");
+   return LLVMBuildGEP2(ctx->ac.builder, ctx->ac.i8, ctx->ac.lds.value, &ptr, 1, "");
 }
 
 static LLVMBasicBlockRef get_block(struct ac_nir_context *nir, const struct nir_block *b)
@@ -5359,7 +5359,7 @@ static void setup_constant_data(struct ac_nir_context *ctx, struct nir_shader *s
 
 static void setup_shared(struct ac_nir_context *ctx, struct nir_shader *nir)
 {
-   if (ctx->ac.lds)
+   if (ctx->ac.lds.value)
       return;
 
    LLVMTypeRef type = LLVMArrayType(ctx->ac.i8, nir->info.shared_size);
@@ -5368,7 +5368,10 @@ static void setup_shared(struct ac_nir_context *ctx, struct nir_shader *nir)
       LLVMAddGlobalInAddressSpace(ctx->ac.module, type, "compute_lds", AC_ADDR_SPACE_LDS);
    LLVMSetAlignment(lds, 64 * 1024);
 
-   ctx->ac.lds = lds;
+   ctx->ac.lds = (struct ac_llvm_pointer) {
+      .value = lds,
+      .pointee_type = type
+   };
 }
 
 static void setup_gds(struct ac_nir_context *ctx, nir_function_impl *impl)
diff --git a/src/gallium/drivers/radeonsi/si_shader_llvm.c b/src/gallium/drivers/radeonsi/si_shader_llvm.c
index 03b4f10353ec..41fabf19476a 100644
--- a/src/gallium/drivers/radeonsi/si_shader_llvm.c
+++ b/src/gallium/drivers/radeonsi/si_shader_llvm.c
@@ -232,9 +232,12 @@ void si_llvm_create_main_func(struct si_shader_context *ctx, bool ngg_cull_shade
        * the shader (currently none, unless LLVM decides to do its
        * own LDS-based lowering).
        */
-      ctx->ac.lds = LLVMAddGlobalInAddressSpace(ctx->ac.module, LLVMArrayType(ctx->ac.i32, 0),
-                                                "__lds_end", AC_ADDR_SPACE_LDS);
-      LLVMSetAlignment(ctx->ac.lds, 256);
+      ctx->ac.lds = (struct ac_llvm_pointer) {
+         .value = LLVMAddGlobalInAddressSpace(ctx->ac.module, LLVMArrayType(ctx->ac.i32, 0),
+                                                "__lds_end", AC_ADDR_SPACE_LDS),
+         .pointee_type = LLVMArrayType(ctx->ac.i32, 0)
+      };
+      LLVMSetAlignment(ctx->ac.lds.value, 256);
    }
 
    /* Unlike radv, we override these arguments in the prolog, so to the
@@ -407,13 +410,17 @@ static void si_llvm_declare_compute_memory(struct si_shader_context *ctx)
    LLVMTypeRef i8p = LLVMPointerType(ctx->ac.i8, AC_ADDR_SPACE_LDS);
    LLVMValueRef var;
 
-   assert(!ctx->ac.lds);
+   assert(!ctx->ac.lds.value);
 
-   var = LLVMAddGlobalInAddressSpace(ctx->ac.module, LLVMArrayType(ctx->ac.i8, lds_size),
+   LLVMTypeRef type = LLVMArrayType(ctx->ac.i8, lds_size);
+   var = LLVMAddGlobalInAddressSpace(ctx->ac.module, type,
                                      "compute_lds", AC_ADDR_SPACE_LDS);
    LLVMSetAlignment(var, 64 * 1024);
 
-   ctx->ac.lds = LLVMBuildBitCast(ctx->ac.builder, var, i8p, "");
+   ctx->ac.lds = (struct ac_llvm_pointer) {
+      .value = LLVMBuildBitCast(ctx->ac.builder, var, i8p, ""),
+      .pointee_type = type,
+   };
 }
 
 /**
diff --git a/src/gallium/drivers/radeonsi/si_shader_llvm_gs.c b/src/gallium/drivers/radeonsi/si_shader_llvm_gs.c
index 9da73718b5d3..4634fdf4c8d0 100644
--- a/src/gallium/drivers/radeonsi/si_shader_llvm_gs.c
+++ b/src/gallium/drivers/radeonsi/si_shader_llvm_gs.c
@@ -290,7 +290,10 @@ void si_preload_esgs_ring(struct si_shader_context *ctx)
    } else {
       /* Declare the ESGS ring as an explicit LDS symbol. */
       si_llvm_declare_esgs_ring(ctx);
-      ctx->ac.lds = ctx->esgs_ring;
+      ctx->ac.lds = (struct ac_llvm_pointer) {
+         .value = ctx->esgs_ring,
+         .pointee_type = LLVMArrayType(ctx->ac.i32, 0),
+      };
    }
 }
 
-- 
GitLab


From b394747d8019e2d65b49b747c406099f2078dd49 Mon Sep 17 00:00:00 2001
From: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
Date: Mon, 10 Oct 2022 12:27:13 +0200
Subject: [PATCH 15/26] ac/llvm: store constant_data and scratch as
 ac_llvm_pointer
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

This way we can pass the type information to LLVM when needed.

Reviewed-by: Mihai Preda <mhpreda@gmail.com>
Reviewed-by: Dave Airlie <airlied@redhat.com>
Reviewed-by: Qiang Yu <yuq825@gmail.com>
Reviewed-by: Marek Olšák <marek.olsak@amd.com>
Acked-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
---
 src/amd/llvm/ac_nir_to_llvm.c | 33 ++++++++++++++-------------------
 1 file changed, 14 insertions(+), 19 deletions(-)

diff --git a/src/amd/llvm/ac_nir_to_llvm.c b/src/amd/llvm/ac_nir_to_llvm.c
index f46e050ac2b2..a47ed8e21ee1 100644
--- a/src/amd/llvm/ac_nir_to_llvm.c
+++ b/src/amd/llvm/ac_nir_to_llvm.c
@@ -45,8 +45,8 @@ struct ac_nir_context {
 
    LLVMValueRef *ssa_defs;
 
-   LLVMValueRef scratch;
-   LLVMValueRef constant_data;
+   struct ac_llvm_pointer scratch;
+   struct ac_llvm_pointer constant_data;
 
    struct hash_table *defs;
    struct hash_table *phis;
@@ -4122,22 +4122,18 @@ static bool visit_intrinsic(struct ac_nir_context *ctx, nir_intrinsic_instr *ins
       break;
    case nir_intrinsic_load_scratch: {
       LLVMValueRef offset = get_src(ctx, instr->src[0]);
-      LLVMValueRef ptr = ac_build_gep0(&ctx->ac, ctx->scratch, offset);
+      LLVMValueRef ptr = ac_build_gep0_2(&ctx->ac, ctx->scratch.t, ctx->scratch.v, offset);
       LLVMTypeRef comp_type = LLVMIntTypeInContext(ctx->ac.context, instr->dest.ssa.bit_size);
       LLVMTypeRef vec_type = instr->dest.ssa.num_components == 1
                                 ? comp_type
                                 : LLVMVectorType(comp_type, instr->dest.ssa.num_components);
-      unsigned addr_space = LLVMGetPointerAddressSpace(LLVMTypeOf(ptr));
-      ptr = LLVMBuildBitCast(ctx->ac.builder, ptr, LLVMPointerType(vec_type, addr_space), "");
       result = LLVMBuildLoad2(ctx->ac.builder, vec_type, ptr, "");
       break;
    }
    case nir_intrinsic_store_scratch: {
       LLVMValueRef offset = get_src(ctx, instr->src[1]);
-      LLVMValueRef ptr = ac_build_gep0(&ctx->ac, ctx->scratch, offset);
+      LLVMValueRef ptr = ac_build_gep0_2(&ctx->ac, ctx->scratch.t, ctx->scratch.v, offset);
       LLVMTypeRef comp_type = LLVMIntTypeInContext(ctx->ac.context, instr->src[0].ssa->bit_size);
-      unsigned addr_space = LLVMGetPointerAddressSpace(LLVMTypeOf(ptr));
-      ptr = LLVMBuildBitCast(ctx->ac.builder, ptr, LLVMPointerType(comp_type, addr_space), "");
       LLVMValueRef src = get_src(ctx, instr->src[0]);
       unsigned wrmask = nir_intrinsic_write_mask(instr);
       while (wrmask) {
@@ -4146,9 +4142,6 @@ static bool visit_intrinsic(struct ac_nir_context *ctx, nir_intrinsic_instr *ins
 
          LLVMValueRef offset = LLVMConstInt(ctx->ac.i32, start, false);
          LLVMValueRef offset_ptr = LLVMBuildGEP2(ctx->ac.builder, comp_type, ptr, &offset, 1, "");
-         LLVMTypeRef vec_type = count == 1 ? comp_type : LLVMVectorType(comp_type, count);
-         offset_ptr = LLVMBuildBitCast(ctx->ac.builder, offset_ptr,
-                                       LLVMPointerType(vec_type, addr_space), "");
          LLVMValueRef offset_src = ac_extract_components(&ctx->ac, src, start, count);
          LLVMBuildStore(ctx->ac.builder, offset_src, offset_ptr);
       }
@@ -4168,13 +4161,11 @@ static bool visit_intrinsic(struct ac_nir_context *ctx, nir_intrinsic_instr *ins
       LLVMValueRef cond = LLVMBuildICmp(ctx->ac.builder, LLVMIntULT, offset, size, "");
       offset = LLVMBuildSelect(ctx->ac.builder, cond, offset, size, "");
 
-      LLVMValueRef ptr = ac_build_gep0(&ctx->ac, ctx->constant_data, offset);
+      LLVMValueRef ptr = ac_build_gep0_2(&ctx->ac, ctx->constant_data.t, ctx->constant_data.v, offset);
       LLVMTypeRef comp_type = LLVMIntTypeInContext(ctx->ac.context, instr->dest.ssa.bit_size);
       LLVMTypeRef vec_type = instr->dest.ssa.num_components == 1
                                 ? comp_type
                                 : LLVMVectorType(comp_type, instr->dest.ssa.num_components);
-      unsigned addr_space = LLVMGetPointerAddressSpace(LLVMTypeOf(ptr));
-      ptr = LLVMBuildBitCast(ctx->ac.builder, ptr, LLVMPointerType(vec_type, addr_space), "");
       result = LLVMBuildLoad2(ctx->ac.builder, vec_type, ptr, "");
       break;
    }
@@ -4334,12 +4325,10 @@ static bool visit_intrinsic(struct ac_nir_context *ctx, nir_intrinsic_instr *ins
       LLVMValueRef offset = get_src(ctx, instr->src[1]);
 
       LLVMTypeRef result_type = get_def_type(ctx, &instr->dest.ssa);
-      LLVMTypeRef ptr_type = LLVMPointerType(result_type, AC_ADDR_SPACE_CONST);
       LLVMTypeRef byte_ptr_type = LLVMPointerType(ctx->ac.i8, AC_ADDR_SPACE_CONST);
 
       LLVMValueRef addr = LLVMBuildIntToPtr(ctx->ac.builder, base, byte_ptr_type, "");
       addr = LLVMBuildGEP2(ctx->ac.builder, ctx->ac.i8, addr, &offset, 1, "");
-      addr = LLVMBuildBitCast(ctx->ac.builder, addr, ptr_type, "");
 
       LLVMSetMetadata(addr, ctx->ac.uniform_md_kind, ctx->ac.empty_md);
       result = LLVMBuildLoad2(ctx->ac.builder, result_type, addr, "");
@@ -5336,8 +5325,11 @@ static void setup_scratch(struct ac_nir_context *ctx, struct nir_shader *shader)
    if (shader->scratch_size == 0)
       return;
 
-   ctx->scratch =
-      ac_build_alloca_undef(&ctx->ac, LLVMArrayType(ctx->ac.i8, shader->scratch_size), "scratch");
+   LLVMTypeRef type = LLVMArrayType(ctx->ac.i8, shader->scratch_size);
+   ctx->scratch = (struct ac_llvm_pointer) {
+      .value = ac_build_alloca_undef(&ctx->ac, type, "scratch"),
+      .pointee_type = type
+   };
 }
 
 static void setup_constant_data(struct ac_nir_context *ctx, struct nir_shader *shader)
@@ -5354,7 +5346,10 @@ static void setup_constant_data(struct ac_nir_context *ctx, struct nir_shader *s
    LLVMSetInitializer(global, data);
    LLVMSetGlobalConstant(global, true);
    LLVMSetVisibility(global, LLVMHiddenVisibility);
-   ctx->constant_data = global;
+   ctx->constant_data = (struct ac_llvm_pointer) {
+      .value = global,
+      .pointee_type = type
+   };
 }
 
 static void setup_shared(struct ac_nir_context *ctx, struct nir_shader *nir)
-- 
GitLab


From 7486a48ebb2eb78bb5c27c4ebb0be501a08cf52b Mon Sep 17 00:00:00 2001
From: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
Date: Mon, 10 Oct 2022 12:28:49 +0200
Subject: [PATCH 16/26] ac/llvm: remove unneeded casts
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

The only useful information in pointer types is the address space and these
casts don't change it.
The type information is explicitely passed by the caller of GEP2 and similar
functions.

Reviewed-by: Mihai Preda <mhpreda@gmail.com>
Reviewed-by: Dave Airlie <airlied@redhat.com>
Reviewed-by: Qiang Yu <yuq825@gmail.com>
Reviewed-by: Marek Olšák <marek.olsak@amd.com>
Acked-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
---
 src/amd/llvm/ac_nir_to_llvm.c | 8 --------
 1 file changed, 8 deletions(-)

diff --git a/src/amd/llvm/ac_nir_to_llvm.c b/src/amd/llvm/ac_nir_to_llvm.c
index a47ed8e21ee1..2f46db6cdfc2 100644
--- a/src/amd/llvm/ac_nir_to_llvm.c
+++ b/src/amd/llvm/ac_nir_to_llvm.c
@@ -3170,10 +3170,6 @@ static LLVMValueRef visit_var_atomic(struct ac_nir_context *ctx, const nir_intri
       src = ac_to_float(&ctx->ac, src);
       src_type = LLVMTypeOf(src);
 
-      LLVMTypeRef ptr_type =
-         LLVMPointerType(src_type, LLVMGetPointerAddressSpace(LLVMTypeOf(ptr)));
-      ptr = LLVMBuildBitCast(ctx->ac.builder, ptr, ptr_type, "");
-
       params[arg_count++] = ptr;
       params[arg_count++] = src;
       params[arg_count++] = ctx->ac.i32_0;
@@ -3226,10 +3222,6 @@ static LLVMValueRef visit_var_atomic(struct ac_nir_context *ctx, const nir_intri
 
       if (instr->intrinsic == nir_intrinsic_shared_atomic_fadd) {
          val = ac_to_float(&ctx->ac, src);
-
-         LLVMTypeRef ptr_type =
-            LLVMPointerType(LLVMTypeOf(val), LLVMGetPointerAddressSpace(LLVMTypeOf(ptr)));
-         ptr = LLVMBuildBitCast(ctx->ac.builder, ptr, ptr_type, "");
       } else {
          val = ac_to_integer(&ctx->ac, src);
       }
-- 
GitLab


From 5bf829af1f2a8aa13c7eec4647a2af37d7074232 Mon Sep 17 00:00:00 2001
From: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
Date: Mon, 10 Oct 2022 12:30:26 +0200
Subject: [PATCH 17/26] radv/llvm: use ac_build_gep0_type to get args types
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Reviewed-by: Mihai Preda <mhpreda@gmail.com>
Reviewed-by: Dave Airlie <airlied@redhat.com>
Reviewed-by: Qiang Yu <yuq825@gmail.com>
Reviewed-by: Marek Olšák <marek.olsak@amd.com>
Acked-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
---
 src/amd/vulkan/radv_nir_to_llvm.c | 23 +++++++++++++----------
 1 file changed, 13 insertions(+), 10 deletions(-)

diff --git a/src/amd/vulkan/radv_nir_to_llvm.c b/src/amd/vulkan/radv_nir_to_llvm.c
index c736926d2cbc..64acae0508b2 100644
--- a/src/amd/vulkan/radv_nir_to_llvm.c
+++ b/src/amd/vulkan/radv_nir_to_llvm.c
@@ -108,12 +108,13 @@ load_descriptor_sets(struct radv_shader_context *ctx)
    uint32_t mask = ctx->shader_info->desc_set_used_mask;
 
    if (user_sgprs_locs->shader_data[AC_UD_INDIRECT_DESCRIPTOR_SETS].sgpr_idx != -1) {
+      LLVMTypeRef type = ac_get_arg_pointee_type(&ctx->ac, &ctx->args->ac, ctx->args->descriptor_sets[0]);
       LLVMValueRef desc_sets = ac_get_arg(&ctx->ac, ctx->args->descriptor_sets[0]);
       while (mask) {
          int i = u_bit_scan(&mask);
 
          ctx->descriptor_sets[i] =
-            ac_build_load_to_sgpr(&ctx->ac, desc_sets, LLVMConstInt(ctx->ac.i32, i, false));
+            ac_build_load_to_sgpr2(&ctx->ac, type, desc_sets, LLVMConstInt(ctx->ac.i32, i, false));
          LLVMSetAlignment(ctx->descriptor_sets[i], 4);
       }
    } else {
@@ -347,6 +348,7 @@ static void
 load_vs_input(struct radv_shader_context *ctx, unsigned driver_location, LLVMTypeRef dest_type,
               LLVMValueRef out[4])
 {
+   LLVMTypeRef t_list_type = ac_get_arg_pointee_type(&ctx->ac, &ctx->args->ac, ctx->args->ac.vertex_buffers);
    LLVMValueRef t_list_ptr = ac_get_arg(&ctx->ac, ctx->args->ac.vertex_buffers);
    LLVMValueRef t_offset;
    LLVMValueRef t_list;
@@ -398,7 +400,7 @@ load_vs_input(struct radv_shader_context *ctx, unsigned driver_location, LLVMTyp
    desc_index = util_bitcount(ctx->shader_info->vs.vb_desc_usage_mask &
                               u_bit_consecutive(0, desc_index));
    t_offset = LLVMConstInt(ctx->ac.i32, desc_index, false);
-   t_list = ac_build_load_to_sgpr(&ctx->ac, t_list_ptr, t_offset);
+   t_list = ac_build_load_to_sgpr2(&ctx->ac, t_list_type, t_list_ptr, t_offset);
 
    /* Always split typed vertex buffer loads on GFX6 and GFX10+ to avoid any alignment issues that
     * triggers memory violations and eventually a GPU hang. This can happen if the stride (static or
@@ -794,6 +796,7 @@ radv_emit_streamout(struct radv_shader_context *ctx, unsigned stream)
        */
       LLVMValueRef so_write_offset[4] = {0};
       LLVMValueRef so_buffers[4] = {0};
+      LLVMTypeRef type = ac_get_arg_pointee_type(&ctx->ac, &ctx->args->ac, ctx->args->streamout_buffers);
       LLVMValueRef buf_ptr = ac_get_arg(&ctx->ac, ctx->args->streamout_buffers);
 
       for (i = 0; i < 4; i++) {
@@ -804,7 +807,7 @@ radv_emit_streamout(struct radv_shader_context *ctx, unsigned stream)
 
          LLVMValueRef offset = LLVMConstInt(ctx->ac.i32, i, false);
 
-         so_buffers[i] = ac_build_load_to_sgpr(&ctx->ac, buf_ptr, offset);
+         so_buffers[i] = ac_build_load_to_sgpr2(&ctx->ac, type, buf_ptr, offset);
 
          LLVMValueRef so_offset = ac_get_arg(&ctx->ac, ctx->args->ac.streamout_offset[i]);
 
@@ -1178,11 +1181,11 @@ ac_setup_rings(struct radv_shader_context *ctx)
       unsigned ring = ctx->stage == MESA_SHADER_GEOMETRY ? RING_ESGS_GS : RING_ESGS_VS;
       LLVMValueRef offset = LLVMConstInt(ctx->ac.i32, ring, false);
 
-      ctx->esgs_ring = ac_build_load_to_sgpr(&ctx->ac, ctx->ring_offsets, offset);
+      ctx->esgs_ring = ac_build_load_to_sgpr2(&ctx->ac, ctx->ac.i8, ctx->ring_offsets, offset);
    }
 
    if (ctx->args->is_gs_copy_shader) {
-      ctx->gsvs_ring[0] = ac_build_load_to_sgpr(&ctx->ac, ctx->ring_offsets,
+      ctx->gsvs_ring[0] = ac_build_load_to_sgpr2(&ctx->ac, ctx->ac.i8, ctx->ring_offsets,
                                                 LLVMConstInt(ctx->ac.i32, RING_GSVS_VS, false));
    }
 
@@ -1200,7 +1203,7 @@ ac_setup_rings(struct radv_shader_context *ctx)
       unsigned num_records = ctx->ac.wave_size;
       LLVMValueRef base_ring;
 
-      base_ring = ac_build_load_to_sgpr(&ctx->ac, ctx->ring_offsets,
+      base_ring = ac_build_load_to_sgpr2(&ctx->ac, ctx->ac.i8, ctx->ring_offsets,
                                         LLVMConstInt(ctx->ac.i32, RING_GSVS_GS, false));
 
       for (unsigned stream = 0; stream < 4; stream++) {
@@ -1240,10 +1243,10 @@ ac_setup_rings(struct radv_shader_context *ctx)
    }
 
    if (ctx->stage == MESA_SHADER_TESS_CTRL || ctx->stage == MESA_SHADER_TESS_EVAL) {
-      ctx->hs_ring_tess_offchip = ac_build_load_to_sgpr(
-         &ctx->ac, ctx->ring_offsets, LLVMConstInt(ctx->ac.i32, RING_HS_TESS_OFFCHIP, false));
-      ctx->hs_ring_tess_factor = ac_build_load_to_sgpr(
-         &ctx->ac, ctx->ring_offsets, LLVMConstInt(ctx->ac.i32, RING_HS_TESS_FACTOR, false));
+      ctx->hs_ring_tess_offchip = ac_build_load_to_sgpr2(
+         &ctx->ac, ctx->ac.i8, ctx->ring_offsets, LLVMConstInt(ctx->ac.i32, RING_HS_TESS_OFFCHIP, false));
+      ctx->hs_ring_tess_factor = ac_build_load_to_sgpr2(
+         &ctx->ac, ctx->ac.i8, ctx->ring_offsets, LLVMConstInt(ctx->ac.i32, RING_HS_TESS_FACTOR, false));
    }
 }
 
-- 
GitLab


From 1f4b870b33ce669725dd789a57620ef0bce13671 Mon Sep 17 00:00:00 2001
From: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
Date: Mon, 10 Oct 2022 12:32:31 +0200
Subject: [PATCH 18/26] radeonsi: use ac_get_arg_pointee_type to get the right
 type
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

And switch to the xxx2 versions of the ac/llvm functions.

Reviewed-by: Mihai Preda <mhpreda@gmail.com>
Reviewed-by: Dave Airlie <airlied@redhat.com>
Reviewed-by: Qiang Yu <yuq825@gmail.com>
Reviewed-by: Marek Olšák <marek.olsak@amd.com>
Acked-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
---
 .../drivers/radeonsi/gfx10_shader_ngg.c       | 20 +++++------
 src/gallium/drivers/radeonsi/si_shader_llvm.c | 19 +++++++----
 .../drivers/radeonsi/si_shader_llvm_gs.c      | 11 +++---
 .../drivers/radeonsi/si_shader_llvm_ps.c      | 11 +++---
 .../radeonsi/si_shader_llvm_resources.c       | 34 ++++++++++++-------
 .../drivers/radeonsi/si_shader_llvm_vs.c      | 17 ++++++----
 6 files changed, 68 insertions(+), 44 deletions(-)

diff --git a/src/gallium/drivers/radeonsi/gfx10_shader_ngg.c b/src/gallium/drivers/radeonsi/gfx10_shader_ngg.c
index a8e4f654aaec..3fa5330352b2 100644
--- a/src/gallium/drivers/radeonsi/gfx10_shader_ngg.c
+++ b/src/gallium/drivers/radeonsi/gfx10_shader_ngg.c
@@ -66,17 +66,18 @@ static LLVMValueRef ngg_get_ordered_id(struct si_shader_context *ctx)
 static LLVMValueRef ngg_get_query_buf(struct si_shader_context *ctx)
 {
    LLVMValueRef buf_ptr = ac_get_arg(&ctx->ac, ctx->internal_bindings);
-
-   return ac_build_load_to_sgpr(&ctx->ac, buf_ptr,
-                                LLVMConstInt(ctx->ac.i32, SI_GS_QUERY_BUF, false));
+   LLVMTypeRef type = ac_get_arg_pointee_type(&ctx->ac, &ctx->args, ctx->internal_bindings);
+   return ac_build_load_to_sgpr2(&ctx->ac, type, buf_ptr,
+                                 LLVMConstInt(ctx->ac.i32, SI_GS_QUERY_BUF, false));
 }
 
 static LLVMValueRef ngg_get_emulated_counters_buf(struct si_shader_context *ctx)
 {
    LLVMValueRef buf_ptr = ac_get_arg(&ctx->ac, ctx->internal_bindings);
+   LLVMTypeRef type = ac_get_arg_pointee_type(&ctx->ac, &ctx->args, ctx->internal_bindings);
 
-   return ac_build_load_to_sgpr(&ctx->ac, buf_ptr,
-                                LLVMConstInt(ctx->ac.i32, SI_GS_QUERY_EMULATED_COUNTERS_BUF, false));
+   return ac_build_load_to_sgpr2(&ctx->ac, type, buf_ptr,
+                                 LLVMConstInt(ctx->ac.i32, SI_GS_QUERY_EMULATED_COUNTERS_BUF, false));
 }
 
 /**
@@ -945,9 +946,10 @@ static void cull_primitive(struct si_shader_context *ctx,
    /* Load the viewport state for small prim culling. */
    bool prim_is_lines = shader->key.ge.opt.ngg_culling & SI_NGG_CULL_LINES;
    LLVMValueRef ptr = ac_get_arg(&ctx->ac, ctx->small_prim_cull_info);
+   LLVMTypeRef type = ac_get_arg_pointee_type(&ctx->ac, &ctx->args, ctx->small_prim_cull_info);
    /* Lines will always use the non-AA viewport transformation. */
-   LLVMValueRef vp = ac_build_load_to_sgpr(&ctx->ac, ptr,
-                                           prim_is_lines ? ctx->ac.i32_1 : ctx->ac.i32_0);
+   LLVMValueRef vp = ac_build_load_to_sgpr2(&ctx->ac, type, ptr,
+                                            prim_is_lines ? ctx->ac.i32_1 : ctx->ac.i32_0);
    vp = LLVMBuildBitCast(builder, vp, ctx->ac.v4f32, "");
    vp_scale[0] = ac_llvm_extract_elem(&ctx->ac, vp, 0);
    vp_scale[1] = ac_llvm_extract_elem(&ctx->ac, vp, 1);
@@ -960,9 +962,7 @@ static void cull_primitive(struct si_shader_context *ctx,
    options.cull_w = true;
 
    if (prim_is_lines) {
-      ptr = LLVMBuildPointerCast(ctx->ac.builder, ptr,
-                                 LLVMPointerType(ctx->ac.v2f32, AC_ADDR_SPACE_CONST_32BIT), "");
-      LLVMValueRef terms = ac_build_load_to_sgpr(&ctx->ac, ptr, LLVMConstInt(ctx->ac.i32, 4, 0));
+      LLVMValueRef terms = ac_build_load_to_sgpr2(&ctx->ac, ctx->ac.v2f32, ptr, LLVMConstInt(ctx->ac.i32, 4, 0));
       terms = LLVMBuildBitCast(builder, terms, ctx->ac.v2f32, "");
       clip_half_line_width[0] = ac_llvm_extract_elem(&ctx->ac, terms, 0);
       clip_half_line_width[1] = ac_llvm_extract_elem(&ctx->ac, terms, 1);
diff --git a/src/gallium/drivers/radeonsi/si_shader_llvm.c b/src/gallium/drivers/radeonsi/si_shader_llvm.c
index 41fabf19476a..376c0227fd5a 100644
--- a/src/gallium/drivers/radeonsi/si_shader_llvm.c
+++ b/src/gallium/drivers/radeonsi/si_shader_llvm.c
@@ -766,7 +766,8 @@ static LLVMValueRef si_llvm_load_intrinsic(struct ac_shader_abi *abi, nir_intrin
    case nir_intrinsic_load_tess_level_inner_default: {
       LLVMValueRef slot = LLVMConstInt(ctx->ac.i32, SI_HS_CONST_DEFAULT_TESS_LEVELS, 0);
       LLVMValueRef buf = ac_get_arg(&ctx->ac, ctx->internal_bindings);
-      buf = ac_build_load_to_sgpr(&ctx->ac, buf, slot);
+      LLVMTypeRef type = ac_get_arg_pointee_type(&ctx->ac, &ctx->args, ctx->internal_bindings);
+      buf = ac_build_load_to_sgpr2(&ctx->ac, type, buf, slot);
       int offset = op == nir_intrinsic_load_tess_level_inner_default ? 4 : 0;
       LLVMValueRef val[4];
 
@@ -823,8 +824,9 @@ static LLVMValueRef si_llvm_load_intrinsic(struct ac_shader_abi *abi, nir_intrin
    case nir_intrinsic_load_viewport_xy_scale_and_offset: {
       bool prim_is_lines = ctx->shader->key.ge.opt.ngg_culling & SI_NGG_CULL_LINES;
       LLVMValueRef ptr = ac_get_arg(&ctx->ac, ctx->small_prim_cull_info);
+      LLVMTypeRef type = ac_get_arg_pointee_type(&ctx->ac, &ctx->args, ctx->small_prim_cull_info);
       LLVMValueRef terms =
-         ac_build_load_to_sgpr(&ctx->ac, ptr, prim_is_lines ? ctx->ac.i32_1 : ctx->ac.i32_0);
+         ac_build_load_to_sgpr2(&ctx->ac, type, ptr, prim_is_lines ? ctx->ac.i32_1 : ctx->ac.i32_0);
       return LLVMBuildBitCast(ctx->ac.builder, terms, ctx->ac.v4f32, "");
    }
 
@@ -879,8 +881,9 @@ static LLVMValueRef si_llvm_load_user_clip_plane(struct ac_shader_abi *abi, unsi
 {
    struct si_shader_context *ctx = si_shader_context_from_abi(abi);
    LLVMValueRef ptr = ac_get_arg(&ctx->ac, ctx->internal_bindings);
+   LLVMTypeRef type = ac_get_arg_pointee_type(&ctx->ac, &ctx->args, ctx->internal_bindings);
    LLVMValueRef constbuf_index = LLVMConstInt(ctx->ac.i32, SI_VS_CONST_CLIP_PLANES, 0);
-   LLVMValueRef const_resource = ac_build_load_to_sgpr(&ctx->ac, ptr, constbuf_index);
+   LLVMValueRef const_resource = ac_build_load_to_sgpr2(&ctx->ac, type, ptr, constbuf_index);
    LLVMValueRef addr = LLVMConstInt(ctx->ac.i32, ucp_id * 16, 0);
    return ac_build_buffer_load(&ctx->ac, const_resource, 4, NULL, addr, NULL,
                                ctx->ac.f32, 0, true, true);
@@ -890,9 +893,10 @@ static LLVMValueRef si_llvm_load_streamout_buffer(struct ac_shader_abi *abi, uns
 {
    struct si_shader_context *ctx = si_shader_context_from_abi(abi);
    LLVMValueRef buf_ptr = ac_get_arg(&ctx->ac, ctx->internal_bindings);
+   LLVMTypeRef type = ac_get_arg_pointee_type(&ctx->ac, &ctx->args, ctx->internal_bindings);
 
-   return ac_build_load_to_sgpr(
-      &ctx->ac, buf_ptr, LLVMConstInt(ctx->ac.i32, SI_VS_STREAMOUT_BUF0 + buffer, false));
+   return ac_build_load_to_sgpr2(
+      &ctx->ac, type, buf_ptr, LLVMConstInt(ctx->ac.i32, SI_VS_STREAMOUT_BUF0 + buffer, false));
 }
 
 bool si_llvm_translate_nir(struct si_shader_context *ctx, struct si_shader *shader,
@@ -929,9 +933,10 @@ bool si_llvm_translate_nir(struct si_shader_context *ctx, struct si_shader *shad
       if (ctx->shader->key.ge.opt.ngg_culling &&
           ctx->shader->key.ge.part.vs.prolog.instance_divisor_is_fetched) {
          LLVMValueRef buf = ac_get_arg(&ctx->ac, ctx->internal_bindings);
+         LLVMTypeRef type = ac_get_arg_pointee_type(&ctx->ac, &ctx->args, ctx->internal_bindings);
          ctx->instance_divisor_constbuf =
-            ac_build_load_to_sgpr(
-               &ctx->ac, buf, LLVMConstInt(ctx->ac.i32, SI_VS_CONST_INSTANCE_DIVISORS, 0));
+            ac_build_load_to_sgpr2(
+               &ctx->ac, type, buf, LLVMConstInt(ctx->ac.i32, SI_VS_CONST_INSTANCE_DIVISORS, 0));
       }
       break;
 
diff --git a/src/gallium/drivers/radeonsi/si_shader_llvm_gs.c b/src/gallium/drivers/radeonsi/si_shader_llvm_gs.c
index 4634fdf4c8d0..4bc12bd1c88b 100644
--- a/src/gallium/drivers/radeonsi/si_shader_llvm_gs.c
+++ b/src/gallium/drivers/radeonsi/si_shader_llvm_gs.c
@@ -99,9 +99,10 @@ static LLVMValueRef si_get_gs_wave_id(struct si_shader_context *ctx)
 static LLVMValueRef ngg_get_emulated_counters_buf(struct si_shader_context *ctx)
 {
    LLVMValueRef buf_ptr = ac_get_arg(&ctx->ac, ctx->internal_bindings);
+   LLVMTypeRef type = ac_get_arg_pointee_type(&ctx->ac, &ctx->args, ctx->internal_bindings);
 
-   return ac_build_load_to_sgpr(&ctx->ac, buf_ptr,
-                                LLVMConstInt(ctx->ac.i32, SI_GS_QUERY_EMULATED_COUNTERS_BUF, false));
+   return ac_build_load_to_sgpr2(&ctx->ac, type, buf_ptr,
+                                 LLVMConstInt(ctx->ac.i32, SI_GS_QUERY_EMULATED_COUNTERS_BUF, false));
 }
 
 void si_llvm_gs_build_end(struct si_shader_context *ctx)
@@ -306,7 +307,8 @@ void si_preload_gs_rings(struct si_shader_context *ctx)
    LLVMBuilderRef builder = ctx->ac.builder;
    LLVMValueRef offset = LLVMConstInt(ctx->ac.i32, SI_RING_GSVS, 0);
    LLVMValueRef buf_ptr = ac_get_arg(&ctx->ac, ctx->internal_bindings);
-   LLVMValueRef base_ring = ac_build_load_to_sgpr(&ctx->ac, buf_ptr, offset);
+   LLVMTypeRef type = ac_get_arg_pointee_type(&ctx->ac, &ctx->args, ctx->internal_bindings);
+   LLVMValueRef base_ring = ac_build_load_to_sgpr2(&ctx->ac, type, buf_ptr, offset);
 
    /* The conceptual layout of the GSVS ring is
     *   v0c0 .. vLv0 v0c1 .. vLc1 ..
@@ -433,8 +435,9 @@ struct si_shader *si_generate_gs_copy_shader(struct si_screen *sscreen,
    si_llvm_create_main_func(&ctx, false);
 
    LLVMValueRef buf_ptr = ac_get_arg(&ctx.ac, ctx.internal_bindings);
+   LLVMTypeRef type = ac_get_arg_pointee_type(&ctx.ac, &ctx.args, ctx.internal_bindings);
    ctx.gsvs_ring[0] =
-      ac_build_load_to_sgpr(&ctx.ac, buf_ptr, LLVMConstInt(ctx.ac.i32, SI_RING_GSVS, 0));
+      ac_build_load_to_sgpr2(&ctx.ac, type, buf_ptr, LLVMConstInt(ctx.ac.i32, SI_RING_GSVS, 0));
 
    LLVMValueRef voffset =
       LLVMBuildMul(ctx.ac.builder, ctx.abi.vertex_id, LLVMConstInt(ctx.ac.i32, 4, 0), "");
diff --git a/src/gallium/drivers/radeonsi/si_shader_llvm_ps.c b/src/gallium/drivers/radeonsi/si_shader_llvm_ps.c
index cd622a220b80..9277124096a9 100644
--- a/src/gallium/drivers/radeonsi/si_shader_llvm_ps.c
+++ b/src/gallium/drivers/radeonsi/si_shader_llvm_ps.c
@@ -36,7 +36,8 @@ static LLVMValueRef load_sample_position(struct ac_shader_abi *abi, LLVMValueRef
    struct si_shader_context *ctx = si_shader_context_from_abi(abi);
    LLVMValueRef desc = ac_get_arg(&ctx->ac, ctx->internal_bindings);
    LLVMValueRef buf_index = LLVMConstInt(ctx->ac.i32, SI_PS_CONST_SAMPLE_POSITIONS, 0);
-   LLVMValueRef resource = ac_build_load_to_sgpr(&ctx->ac, desc, buf_index);
+   LLVMTypeRef type = ac_get_arg_pointee_type(&ctx->ac, &ctx->args, ctx->internal_bindings);
+   LLVMValueRef resource = ac_build_load_to_sgpr2(&ctx->ac, type, desc, buf_index);
 
    /* offset = sample_id * 8  (8 = 2 floats containing samplepos.xy) */
    LLVMValueRef offset0 =
@@ -69,7 +70,7 @@ static LLVMValueRef si_nir_emit_fbfetch(struct ac_shader_abi *abi)
    ptr =
       LLVMBuildPointerCast(ctx->ac.builder, ptr, ac_array_in_const32_addr_space(ctx->ac.v8i32), "");
    image =
-      ac_build_load_to_sgpr(&ctx->ac, ptr, LLVMConstInt(ctx->ac.i32, SI_PS_IMAGE_COLORBUF0 / 2, 0));
+      ac_build_load_to_sgpr2(&ctx->ac, ctx->ac.v8i32, ptr, LLVMConstInt(ctx->ac.i32, SI_PS_IMAGE_COLORBUF0 / 2, 0));
 
    unsigned chan = 0;
 
@@ -88,7 +89,8 @@ static LLVMValueRef si_nir_emit_fbfetch(struct ac_shader_abi *abi)
    if (ctx->screen->info.gfx_level < GFX11 &&
        ctx->shader->key.ps.mono.fbfetch_msaa &&
        !(ctx->screen->debug_flags & DBG(NO_FMASK))) {
-      fmask = ac_build_load_to_sgpr(&ctx->ac, ptr,
+
+      fmask = ac_build_load_to_sgpr2(&ctx->ac, ctx->ac.v8i32, ptr,
                                     LLVMConstInt(ctx->ac.i32, SI_PS_IMAGE_COLORBUF0_FMASK / 2, 0));
 
       ac_apply_fmask_to_sample(&ctx->ac, fmask, args.coords,
@@ -547,7 +549,8 @@ static void si_llvm_emit_polygon_stipple(struct si_shader_context *ctx,
 
    /* Load the buffer descriptor. */
    slot = LLVMConstInt(ctx->ac.i32, SI_PS_CONST_POLY_STIPPLE, 0);
-   desc = ac_build_load_to_sgpr(&ctx->ac, param_internal_bindings, slot);
+
+   desc = ac_build_load_to_sgpr2(&ctx->ac, ctx->ac.v4i32, param_internal_bindings, slot);
 
    /* The stipple pattern is 32x32, each row has 32 bits. */
    offset = LLVMBuildMul(builder, address[1], LLVMConstInt(ctx->ac.i32, 4, 0), "");
diff --git a/src/gallium/drivers/radeonsi/si_shader_llvm_resources.c b/src/gallium/drivers/radeonsi/si_shader_llvm_resources.c
index 8cbc8e5ca6f2..bac1143d4828 100644
--- a/src/gallium/drivers/radeonsi/si_shader_llvm_resources.c
+++ b/src/gallium/drivers/radeonsi/si_shader_llvm_resources.c
@@ -104,7 +104,10 @@ static LLVMValueRef load_ubo(struct ac_shader_abi *abi, LLVMValueRef index)
    index =
       LLVMBuildAdd(ctx->ac.builder, index, LLVMConstInt(ctx->ac.i32, SI_NUM_SHADER_BUFFERS, 0), "");
 
-   return ac_build_load_to_sgpr(&ctx->ac, ptr, index);
+   return ac_build_load_to_sgpr2(&ctx->ac,
+                                 ac_get_arg_pointee_type(&ctx->ac, &ctx->args, ctx->const_and_shader_buffers),
+                                 ptr,
+                                 index);
 }
 
 static LLVMValueRef load_ssbo(struct ac_shader_abi *abi, LLVMValueRef index, bool write, bool non_uniform)
@@ -117,12 +120,13 @@ static LLVMValueRef load_ssbo(struct ac_shader_abi *abi, LLVMValueRef index, boo
       return ac_get_arg(&ctx->ac, ctx->cs_shaderbuf[LLVMConstIntGetZExtValue(index)]);
 
    LLVMValueRef rsrc_ptr = ac_get_arg(&ctx->ac, ctx->const_and_shader_buffers);
-
    index = si_llvm_bound_index(ctx, index, ctx->num_shader_buffers);
    index = LLVMBuildSub(ctx->ac.builder, LLVMConstInt(ctx->ac.i32, SI_NUM_SHADER_BUFFERS - 1, 0),
                         index, "");
 
-   return ac_build_load_to_sgpr(&ctx->ac, rsrc_ptr, index);
+   return ac_build_load_to_sgpr2(&ctx->ac,
+                                 ac_get_arg_pointee_type(&ctx->ac, &ctx->args, ctx->const_and_shader_buffers),
+                                 rsrc_ptr, index);
 }
 
 /**
@@ -177,7 +181,7 @@ static LLVMValueRef fixup_image_desc(struct si_shader_context *ctx, LLVMValueRef
 
 /* AC_DESC_FMASK is handled exactly like AC_DESC_IMAGE. The caller should
  * adjust "index" to point to FMASK. */
-static LLVMValueRef si_load_image_desc(struct si_shader_context *ctx, LLVMValueRef list,
+static LLVMValueRef si_load_image_desc(struct si_shader_context *ctx, LLVMTypeRef type, LLVMValueRef list,
                                        LLVMValueRef index, enum ac_descriptor_type desc_type,
                                        bool uses_store, bool bindless)
 {
@@ -187,14 +191,15 @@ static LLVMValueRef si_load_image_desc(struct si_shader_context *ctx, LLVMValueR
    if (desc_type == AC_DESC_BUFFER) {
       index = ac_build_imad(&ctx->ac, index, LLVMConstInt(ctx->ac.i32, 2, 0), ctx->ac.i32_1);
       list = LLVMBuildPointerCast(builder, list, ac_array_in_const32_addr_space(ctx->ac.v4i32), "");
+      type = ctx->ac.v4i32;
    } else {
       assert(desc_type == AC_DESC_IMAGE || desc_type == AC_DESC_FMASK);
    }
 
    if (bindless)
-      rsrc = ac_build_load_to_sgpr_uint_wraparound(&ctx->ac, list, index);
+      rsrc = ac_build_load_to_sgpr_uint_wraparound2(&ctx->ac, type, list, index);
    else
-      rsrc = ac_build_load_to_sgpr(&ctx->ac, list, index);
+      rsrc = ac_build_load_to_sgpr2(&ctx->ac, type, list, index);
 
    if (desc_type == AC_DESC_IMAGE)
       rsrc = fixup_image_desc(ctx, rsrc, uses_store);
@@ -205,7 +210,8 @@ static LLVMValueRef si_load_image_desc(struct si_shader_context *ctx, LLVMValueR
 /**
  * Load an image view, fmask view. or sampler state descriptor.
  */
-static LLVMValueRef si_load_sampler_desc(struct si_shader_context *ctx, LLVMValueRef list,
+static LLVMValueRef si_load_sampler_desc(struct si_shader_context *ctx, LLVMTypeRef list_type,
+                                         LLVMValueRef list,
                                          LLVMValueRef index, enum ac_descriptor_type type)
 {
    LLVMBuilderRef builder = ctx->ac.builder;
@@ -219,6 +225,7 @@ static LLVMValueRef si_load_sampler_desc(struct si_shader_context *ctx, LLVMValu
       /* The buffer is in [4:7]. */
       index = ac_build_imad(&ctx->ac, index, LLVMConstInt(ctx->ac.i32, 4, 0), ctx->ac.i32_1);
       list = LLVMBuildPointerCast(builder, list, ac_array_in_const32_addr_space(ctx->ac.v4i32), "");
+      list_type = ctx->ac.v4i32;
       break;
    case AC_DESC_FMASK:
       /* The FMASK is at [8:15]. */
@@ -230,6 +237,7 @@ static LLVMValueRef si_load_sampler_desc(struct si_shader_context *ctx, LLVMValu
       index = ac_build_imad(&ctx->ac, index, LLVMConstInt(ctx->ac.i32, 4, 0),
                             LLVMConstInt(ctx->ac.i32, 3, 0));
       list = LLVMBuildPointerCast(builder, list, ac_array_in_const32_addr_space(ctx->ac.v4i32), "");
+      list_type = ctx->ac.v4i32;
       break;
    case AC_DESC_PLANE_0:
    case AC_DESC_PLANE_1:
@@ -240,7 +248,7 @@ static LLVMValueRef si_load_sampler_desc(struct si_shader_context *ctx, LLVMValu
       unreachable("Plane descriptor requested in radeonsi.");
    }
 
-   return ac_build_load_to_sgpr(&ctx->ac, list, index);
+   return ac_build_load_to_sgpr2(&ctx->ac, list_type, list, index);
 }
 
 static LLVMValueRef si_nir_load_sampler_desc(struct ac_shader_abi *abi, unsigned descriptor_set,
@@ -258,6 +266,7 @@ static LLVMValueRef si_nir_load_sampler_desc(struct ac_shader_abi *abi, unsigned
 
    if (bindless) {
       LLVMValueRef list = ac_get_arg(&ctx->ac, ctx->bindless_samplers_and_images);
+      LLVMTypeRef type = ac_get_arg_pointee_type(&ctx->ac, &ctx->args, ctx->bindless_samplers_and_images);
 
       /* dynamic_index is the bindless handle */
       if (image) {
@@ -269,7 +278,7 @@ static LLVMValueRef si_nir_load_sampler_desc(struct ac_shader_abi *abi, unsigned
             dynamic_index = LLVMBuildAdd(ctx->ac.builder, dynamic_index, ctx->ac.i32_1, "");
          }
 
-         return si_load_image_desc(ctx, list, dynamic_index, desc_type, write, true);
+         return si_load_image_desc(ctx, type, list, dynamic_index, desc_type, write, true);
       }
 
       /* Since bindless handle arithmetic can contain an unsigned integer
@@ -280,7 +289,7 @@ static LLVMValueRef si_nir_load_sampler_desc(struct ac_shader_abi *abi, unsigned
       dynamic_index =
          LLVMBuildMul(ctx->ac.builder, dynamic_index, LLVMConstInt(ctx->ac.i64, 2, 0), "");
       list = ac_build_pointer_add(&ctx->ac, ctx->ac.v8i32, list, dynamic_index);
-      return si_load_sampler_desc(ctx, list, ctx->ac.i32_0, desc_type);
+      return si_load_sampler_desc(ctx, type, list, ctx->ac.i32_0, desc_type);
    }
 
    unsigned num_slots = image ? ctx->num_images : ctx->num_samplers;
@@ -290,6 +299,7 @@ static LLVMValueRef si_nir_load_sampler_desc(struct ac_shader_abi *abi, unsigned
       const_index = base_index;
 
    LLVMValueRef list = ac_get_arg(&ctx->ac, ctx->samplers_and_images);
+   LLVMTypeRef type = ac_get_arg_pointee_type(&ctx->ac, &ctx->args, ctx->samplers_and_images);
    LLVMValueRef index = LLVMConstInt(ctx->ac.i32, const_index, false);
 
    if (dynamic_index) {
@@ -326,12 +336,12 @@ static LLVMValueRef si_nir_load_sampler_desc(struct ac_shader_abi *abi, unsigned
       }
       index = LLVMBuildSub(ctx->ac.builder, LLVMConstInt(ctx->ac.i32, SI_NUM_IMAGE_SLOTS - 1, 0),
                            index, "");
-      return si_load_image_desc(ctx, list, index, desc_type, write, false);
+      return si_load_image_desc(ctx, type, list, index, desc_type, write, false);
    }
 
    index = LLVMBuildAdd(ctx->ac.builder, index,
                         LLVMConstInt(ctx->ac.i32, SI_NUM_IMAGE_SLOTS / 2, 0), "");
-   return si_load_sampler_desc(ctx, list, index, desc_type);
+   return si_load_sampler_desc(ctx, type, list, index, desc_type);
 }
 
 void si_llvm_init_resource_callbacks(struct si_shader_context *ctx)
diff --git a/src/gallium/drivers/radeonsi/si_shader_llvm_vs.c b/src/gallium/drivers/radeonsi/si_shader_llvm_vs.c
index ce0d34b25158..f9ddea92c992 100644
--- a/src/gallium/drivers/radeonsi/si_shader_llvm_vs.c
+++ b/src/gallium/drivers/radeonsi/si_shader_llvm_vs.c
@@ -168,8 +168,9 @@ static void load_input_vs(struct si_shader_context *ctx, unsigned input_index, L
       vb_desc = ac_get_arg(&ctx->ac, ctx->vb_descriptors[input_index]);
    } else {
       unsigned index = input_index - num_vbos_in_user_sgprs;
-      vb_desc = ac_build_load_to_sgpr(&ctx->ac, ac_get_arg(&ctx->ac, ctx->args.vertex_buffers),
-                                      LLVMConstInt(ctx->ac.i32, index, 0));
+      LLVMTypeRef type = ac_get_arg_pointee_type(&ctx->ac, &ctx->args, ctx->args.vertex_buffers);
+      vb_desc = ac_build_load_to_sgpr2(&ctx->ac, type, ac_get_arg(&ctx->ac, ctx->args.vertex_buffers),
+                                       LLVMConstInt(ctx->ac.i32, index, 0));
    }
 
    if (ctx->abi.vertex_id_replaced) {
@@ -409,6 +410,7 @@ void si_llvm_emit_streamout(struct si_shader_context *ctx, struct si_shader_outp
       LLVMValueRef so_write_offset[4] = {};
       LLVMValueRef so_buffers[4];
       LLVMValueRef buf_ptr = ac_get_arg(&ctx->ac, ctx->internal_bindings);
+      LLVMTypeRef type = ac_get_arg_pointee_type(&ctx->ac, &ctx->args, ctx->internal_bindings);
 
       for (i = 0; i < 4; i++) {
          if (!so->stride[i])
@@ -416,7 +418,7 @@ void si_llvm_emit_streamout(struct si_shader_context *ctx, struct si_shader_outp
 
          LLVMValueRef offset = LLVMConstInt(ctx->ac.i32, SI_VS_STREAMOUT_BUF0 + i, 0);
 
-         so_buffers[i] = ac_build_load_to_sgpr(&ctx->ac, buf_ptr, offset);
+         so_buffers[i] = ac_build_load_to_sgpr2(&ctx->ac, type, buf_ptr, offset);
 
          LLVMValueRef so_offset = ac_get_arg(&ctx->ac, ctx->args.streamout_offset[i]);
          so_offset = LLVMBuildMul(builder, so_offset, LLVMConstInt(ctx->ac.i32, 4, 0), "");
@@ -450,8 +452,9 @@ void si_llvm_clipvertex_to_clipdist(struct si_shader_context *ctx,
    unsigned const_chan;
    LLVMValueRef base_elt;
    LLVMValueRef ptr = ac_get_arg(&ctx->ac, ctx->internal_bindings);
+   LLVMTypeRef type = ac_get_arg_pointee_type(&ctx->ac, &ctx->args, ctx->internal_bindings);
    LLVMValueRef constbuf_index = LLVMConstInt(ctx->ac.i32, SI_VS_CONST_CLIP_PLANES, 0);
-   LLVMValueRef const_resource = ac_build_load_to_sgpr(&ctx->ac, ptr, constbuf_index);
+   LLVMValueRef const_resource = ac_build_load_to_sgpr2(&ctx->ac, type, ptr, constbuf_index);
    unsigned clipdist_mask = ctx->shader->selector->info.clipdist_mask &
                             ~ctx->shader->key.ge.opt.kill_clip_distances;
 
@@ -816,8 +819,8 @@ void si_llvm_build_vs_exports(struct si_shader_context *ctx, LLVMValueRef num_ex
             LLVMBuildPointerCast(ctx->ac.builder,
                                  ac_get_arg(&ctx->ac, ctx->internal_bindings),
                                  LLVMPointerType(ctx->ac.i32, AC_ADDR_SPACE_CONST_32BIT), "");
-         attr_address = ac_build_load_to_sgpr(&ctx->ac, ptr,
-                                              LLVMConstInt(ctx->ac.i32, SI_GS_ATTRIBUTE_RING * 4, 0));
+         attr_address = ac_build_load_to_sgpr2(&ctx->ac, ctx->ac.i32, ptr,
+                                               LLVMConstInt(ctx->ac.i32, SI_GS_ATTRIBUTE_RING * 4, 0));
       } else {
          attr_address = ac_get_arg(&ctx->ac, ctx->gs_attr_address);
       }
@@ -1036,7 +1039,7 @@ void si_llvm_build_vs_prolog(struct si_shader_context *ctx, union si_shader_part
    if (key->vs_prolog.states.instance_divisor_is_fetched) {
       LLVMValueRef list = si_prolog_get_internal_bindings(ctx);
       LLVMValueRef buf_index = LLVMConstInt(ctx->ac.i32, SI_VS_CONST_INSTANCE_DIVISORS, 0);
-      instance_divisor_constbuf = ac_build_load_to_sgpr(&ctx->ac, list, buf_index);
+      instance_divisor_constbuf = ac_build_load_to_sgpr2(&ctx->ac, ctx->ac.v4i32, list, buf_index);
    }
 
    for (i = 0; i < key->vs_prolog.num_inputs; i++) {
-- 
GitLab


From 69ed7644b5695a63614876f45c63b695351e357d Mon Sep 17 00:00:00 2001
From: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
Date: Mon, 10 Oct 2022 12:33:06 +0200
Subject: [PATCH 19/26] radeonsi: use LLVMBuildGEP2 in si_build_gep_i8_var
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Reviewed-by: Mihai Preda <mhpreda@gmail.com>
Reviewed-by: Dave Airlie <airlied@redhat.com>
Reviewed-by: Qiang Yu <yuq825@gmail.com>
Reviewed-by: Marek Olšák <marek.olsak@amd.com>
Acked-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
---
 src/gallium/drivers/radeonsi/gfx10_shader_ngg.c | 6 ++++--
 1 file changed, 4 insertions(+), 2 deletions(-)

diff --git a/src/gallium/drivers/radeonsi/gfx10_shader_ngg.c b/src/gallium/drivers/radeonsi/gfx10_shader_ngg.c
index 3fa5330352b2..15d1543fb758 100644
--- a/src/gallium/drivers/radeonsi/gfx10_shader_ngg.c
+++ b/src/gallium/drivers/radeonsi/gfx10_shader_ngg.c
@@ -677,10 +677,12 @@ enum
 static LLVMValueRef si_build_gep_i8_var(struct si_shader_context *ctx, LLVMValueRef ptr,
                                         LLVMValueRef index)
 {
+#if LLVM_VERSION_MAJOR < 14
    LLVMTypeRef pi8 = LLVMPointerType(ctx->ac.i8, AC_ADDR_SPACE_LDS);
+   ptr = LLVMBuildPointerCast(ctx->ac.builder, ptr, pi8, "");
+#endif
 
-   return LLVMBuildGEP(ctx->ac.builder, LLVMBuildPointerCast(ctx->ac.builder, ptr, pi8, ""), &index,
-                       1, "");
+   return LLVMBuildGEP2(ctx->ac.builder, ctx->ac.i8, ptr, &index, 1, "");
 }
 
 static LLVMValueRef si_build_gep_i8(struct si_shader_context *ctx, LLVMValueRef ptr,
-- 
GitLab


From ad4e1dcc2c8ba24b28ac64b4d01a4e519436be79 Mon Sep 17 00:00:00 2001
From: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
Date: Mon, 10 Oct 2022 14:39:50 +0200
Subject: [PATCH 20/26] radeonsi: make ngg_gs_get_vertex_storage return a
 ac_llvm_pointer
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

gs_ngg_emit is declared as a 0-size array so we can't store it as a
ac_llvm_pointer.

Instead, we simply modify the ngg_gs_get_vertex_storage to return
a properly typed pointer, when num_outputs is known.

Reviewed-by: Mihai Preda <mhpreda@gmail.com>
Reviewed-by: Dave Airlie <airlied@redhat.com>
Reviewed-by: Qiang Yu <yuq825@gmail.com>
Reviewed-by: Marek Olšák <marek.olsak@amd.com>
Acked-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
---
 src/gallium/drivers/radeonsi/gfx10_shader_ngg.c | 12 +++++++-----
 1 file changed, 7 insertions(+), 5 deletions(-)

diff --git a/src/gallium/drivers/radeonsi/gfx10_shader_ngg.c b/src/gallium/drivers/radeonsi/gfx10_shader_ngg.c
index 15d1543fb758..a9fd5c0de952 100644
--- a/src/gallium/drivers/radeonsi/gfx10_shader_ngg.c
+++ b/src/gallium/drivers/radeonsi/gfx10_shader_ngg.c
@@ -1752,7 +1752,7 @@ void gfx10_ngg_build_end(struct si_shader_context *ctx)
    ac_build_endif(&ctx->ac, 6002);
 }
 
-static LLVMValueRef ngg_gs_get_vertex_storage(struct si_shader_context *ctx)
+static struct ac_llvm_pointer ngg_gs_get_vertex_storage(struct si_shader_context *ctx)
 {
    const struct si_shader_selector *sel = ctx->shader->selector;
    const struct si_shader_info *info = &sel->info;
@@ -1762,8 +1762,10 @@ static LLVMValueRef ngg_gs_get_vertex_storage(struct si_shader_context *ctx)
       LLVMArrayType(ctx->ac.i8, 4),
    };
    LLVMTypeRef type = LLVMStructTypeInContext(ctx->ac.context, elements, 2, false);
-   type = LLVMPointerType(LLVMArrayType(type, 0), AC_ADDR_SPACE_LDS);
-   return LLVMBuildBitCast(ctx->ac.builder, ctx->gs_ngg_emit, type, "");
+   return (struct ac_llvm_pointer) {
+      .value = ctx->gs_ngg_emit,
+      .pointee_type = LLVMArrayType(type, 0)
+   };
 }
 
 /**
@@ -1800,7 +1802,7 @@ static LLVMValueRef ngg_gs_vertex_ptr(struct si_shader_context *ctx, LLVMValueRe
 {
    struct si_shader_selector *sel = ctx->shader->selector;
    LLVMBuilderRef builder = ctx->ac.builder;
-   LLVMValueRef storage = ngg_gs_get_vertex_storage(ctx);
+   struct ac_llvm_pointer storage = ngg_gs_get_vertex_storage(ctx);
 
    /* gs.vertices_out = 2^(write_stride_2exp) * some odd number */
    unsigned write_stride_2exp = ffs(sel->info.base.gs.vertices_out) - 1;
@@ -1811,7 +1813,7 @@ static LLVMValueRef ngg_gs_vertex_ptr(struct si_shader_context *ctx, LLVMValueRe
       vertexidx = LLVMBuildXor(builder, vertexidx, swizzle, "");
    }
 
-   return ac_build_gep0(&ctx->ac, storage, vertexidx);
+   return ac_build_gep0(&ctx->ac, storage.value, vertexidx);
 }
 
 static LLVMValueRef ngg_gs_emit_vertex_ptr(struct si_shader_context *ctx, LLVMValueRef gsthread,
-- 
GitLab


From 0908911cf8b7a774d027a3ff7b2f3c0b0a102c94 Mon Sep 17 00:00:00 2001
From: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
Date: Mon, 10 Oct 2022 17:40:45 +0200
Subject: [PATCH 21/26] radeonsi: port the remaining code to opaque pointers
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Mechanical changes (= use ac_llvm_pointer and adapt the callers/callees)

Reviewed-by: Mihai Preda <mhpreda@gmail.com>
Reviewed-by: Dave Airlie <airlied@redhat.com>
Reviewed-by: Qiang Yu <yuq825@gmail.com>
Reviewed-by: Marek Olšák <marek.olsak@amd.com>
Acked-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
---
 .../drivers/radeonsi/gfx10_shader_ngg.c       | 221 ++++++++++--------
 .../drivers/radeonsi/si_shader_internal.h     |   2 +-
 src/gallium/drivers/radeonsi/si_shader_llvm.c |  30 +--
 .../drivers/radeonsi/si_shader_llvm_gs.c      |   3 +-
 4 files changed, 138 insertions(+), 118 deletions(-)

diff --git a/src/gallium/drivers/radeonsi/gfx10_shader_ngg.c b/src/gallium/drivers/radeonsi/gfx10_shader_ngg.c
index a9fd5c0de952..aae8a23379f9 100644
--- a/src/gallium/drivers/radeonsi/gfx10_shader_ngg.c
+++ b/src/gallium/drivers/radeonsi/gfx10_shader_ngg.c
@@ -225,7 +225,7 @@ void gfx10_ngg_build_export_prim(struct si_shader_context *ctx, LLVMValueRef use
 
 static void build_streamout_vertex(struct si_shader_context *ctx, LLVMValueRef *so_buffer,
                                    LLVMValueRef *wg_offset_dw, unsigned stream,
-                                   LLVMValueRef offset_vtx, LLVMValueRef vertexptr)
+                                   LLVMValueRef offset_vtx, struct ac_llvm_pointer vertexptr)
 {
    struct si_shader_info *info = &ctx->shader->selector->info;
    struct pipe_stream_output_info *so = &ctx->so;
@@ -252,8 +252,9 @@ static void build_streamout_vertex(struct si_shader_context *ctx, LLVMValueRef *
       out.semantic = info->output_semantic[reg];
 
       for (unsigned comp = 0; comp < 4; comp++) {
-         tmp = ac_build_gep0(&ctx->ac, vertexptr, LLVMConstInt(ctx->ac.i32, 4 * reg + comp, false));
-         out.values[comp] = LLVMBuildLoad(builder, tmp, "");
+         LLVMValueRef idx = LLVMConstInt(ctx->ac.i32, 4 * reg + comp, false);
+         LLVMValueRef v = ac_build_gep0_2(&ctx->ac, vertexptr.t, vertexptr.v, idx);
+         out.values[comp] = LLVMBuildLoad2(builder, ac_build_gep0_type(vertexptr.t, idx), v, "");
          out.vertex_streams = info->output_streams[reg];
       }
 
@@ -265,8 +266,8 @@ struct ngg_streamout {
    LLVMValueRef num_vertices;
 
    /* per-thread data */
-   LLVMValueRef prim_enable[4]; /* i1 per stream */
-   LLVMValueRef vertices[3];    /* [N x i32] addrspace(LDS)* */
+   LLVMValueRef prim_enable[4];        /* i1 per stream */
+   struct ac_llvm_pointer vertices[3]; /* [N x i32] addrspace(LDS)* */
 
    /* Output */
    LLVMValueRef emit[4]; /* per-stream emitted primitives (only valid for used streams) */
@@ -287,13 +288,14 @@ static void build_streamout(struct si_shader_context *ctx, struct ngg_streamout
    struct pipe_stream_output_info *so = &ctx->so;
    LLVMBuilderRef builder = ctx->ac.builder;
    LLVMValueRef buf_ptr = ac_get_arg(&ctx->ac, ctx->internal_bindings);
+   LLVMTypeRef type = ac_get_arg_pointee_type(&ctx->ac, &ctx->args, ctx->internal_bindings);
    LLVMValueRef tid = gfx10_get_thread_id_in_tg(ctx);
    LLVMValueRef tmp, tmp2;
    LLVMValueRef i32_2 = LLVMConstInt(ctx->ac.i32, 2, false);
    LLVMValueRef i32_4 = LLVMConstInt(ctx->ac.i32, 4, false);
    LLVMValueRef i32_8 = LLVMConstInt(ctx->ac.i32, 8, false);
    LLVMValueRef so_buffer[4] = {};
-   unsigned max_num_vertices = 1 + (nggso->vertices[1] ? 1 : 0) + (nggso->vertices[2] ? 1 : 0);
+   unsigned max_num_vertices = 1 + (nggso->vertices[1].value ? 1 : 0) + (nggso->vertices[2].value ? 1 : 0);
    LLVMValueRef prim_stride_dw[4] = {};
    LLVMValueRef prim_stride_dw_vgpr = LLVMGetUndef(ctx->ac.i32);
    int stream_for_buffer[4] = {-1, -1, -1, -1};
@@ -325,8 +327,8 @@ static void build_streamout(struct si_shader_context *ctx, struct ngg_streamout
          ac_build_writelane(&ctx->ac, prim_stride_dw_vgpr, prim_stride_dw[buffer],
                             LLVMConstInt(ctx->ac.i32, buffer, false));
 
-      so_buffer[buffer] = ac_build_load_to_sgpr(
-         &ctx->ac, buf_ptr, LLVMConstInt(ctx->ac.i32, SI_VS_STREAMOUT_BUF0 + buffer, false));
+      so_buffer[buffer] = ac_build_load_to_sgpr2(
+         &ctx->ac, type, buf_ptr, LLVMConstInt(ctx->ac.i32, SI_VS_STREAMOUT_BUF0 + buffer, false));
    }
 
    tmp = LLVMBuildICmp(builder, LLVMIntEQ, get_wave_id_in_tg(ctx), ctx->ac.i32_0, "");
@@ -343,8 +345,8 @@ static void build_streamout(struct si_shader_context *ctx, struct ngg_streamout
       ac_build_ifcc(&ctx->ac, tmp, 5210);
       {
          if (isgs) {
-            tmp = ac_build_gep0(&ctx->ac, ctx->gs_ngg_scratch, tid);
-            tmp = LLVMBuildLoad2(builder, ctx->ac.i32, tmp, "");
+            LLVMValueRef vt = ac_build_gep0_2(&ctx->ac, ctx->gs_ngg_scratch.t, ctx->gs_ngg_scratch.v, tid);
+            tmp = LLVMBuildLoad2(builder, ac_build_gep0_type(ctx->gs_ngg_scratch.t, tid), vt, "");
          } else {
             tmp = ac_build_writelane(&ctx->ac, ctx->ac.i32_0, ngg_get_prim_cnt(ctx), ctx->ac.i32_0);
          }
@@ -450,7 +452,7 @@ static void build_streamout(struct si_shader_context *ctx, struct ngg_streamout
          LLVMBuildStore(builder, tmp, offsets_vgpr);
 
          tmp2 = LLVMBuildAdd(builder, ac_get_thread_id(&ctx->ac), scratch_offset_basev, "");
-         tmp2 = ac_build_gep0(&ctx->ac, ctx->gs_ngg_scratch, tmp2);
+         tmp2 = ac_build_gep0_2(&ctx->ac, ctx->gs_ngg_scratch.t, ctx->gs_ngg_scratch.v, tmp2);
          LLVMBuildStore(builder, tmp, tmp2);
       }
       ac_build_endif(&ctx->ac, 5210);
@@ -525,14 +527,14 @@ static void build_streamout(struct si_shader_context *ctx, struct ngg_streamout
 
                      ac_build_ifcc(&ctx->ac, LLVMBuildICmp(builder, LLVMIntEQ, tid, index, ""), 0);
                      LLVMBuildAtomicRMW(builder, LLVMAtomicRMWBinOpSub,
-                                        LLVMBuildGEP(builder, gdsbase, &index, 1, ""),
+                                        LLVMBuildGEP2(builder, gdsptr, gdsbase, &index, 1, ""),
                                         tmp, LLVMAtomicOrderingMonotonic, false);
                      ac_build_endif(&ctx->ac, 0);
                   }
                }
             } else {
                LLVMBuildAtomicRMW(builder, LLVMAtomicRMWBinOpSub,
-                                  LLVMBuildGEP(builder, gdsbase, &tid, 1, ""),
+                                  LLVMBuildGEP2(builder, gdsptr, gdsbase, &tid, 1, ""),
                                   tmp, LLVMAtomicOrderingMonotonic, false);
             }
          }
@@ -544,7 +546,7 @@ static void build_streamout(struct si_shader_context *ctx, struct ngg_streamout
       ac_build_ifcc(&ctx->ac, tmp, 5225);
       {
          tmp = LLVMBuildAdd(builder, ac_get_thread_id(&ctx->ac), scratch_emit_basev, "");
-         tmp = ac_build_gep0(&ctx->ac, ctx->gs_ngg_scratch, tmp);
+         tmp = ac_build_gep0_2(&ctx->ac, ctx->gs_ngg_scratch.t, ctx->gs_ngg_scratch.v, tmp);
          LLVMBuildStore(builder, emit_vgpr, tmp);
       }
       ac_build_endif(&ctx->ac, 5225);
@@ -564,8 +566,9 @@ static void build_streamout(struct si_shader_context *ctx, struct ngg_streamout
          primemit_scan[stream].enable_exclusive = true;
          primemit_scan[stream].op = nir_op_iadd;
          primemit_scan[stream].src = nggso->prim_enable[stream];
-         primemit_scan[stream].scratch = ac_build_gep0(
-            &ctx->ac, ctx->gs_ngg_scratch, LLVMConstInt(ctx->ac.i32, 12 + 8 * stream, false));
+         primemit_scan[stream].scratch = ac_build_gep0_2(
+            &ctx->ac, ctx->gs_ngg_scratch.t, ctx->gs_ngg_scratch.v,
+            LLVMConstInt(ctx->ac.i32, 12 + 8 * stream, false));
          primemit_scan[stream].waveidx = get_wave_id_in_tg(ctx);
          primemit_scan[stream].numwaves = get_tgsize(ctx);
          if (ctx->stage == MESA_SHADER_GEOMETRY) {
@@ -588,8 +591,9 @@ static void build_streamout(struct si_shader_context *ctx, struct ngg_streamout
    {
       LLVMValueRef scratch_vgpr;
 
-      tmp = ac_build_gep0(&ctx->ac, ctx->gs_ngg_scratch, ac_get_thread_id(&ctx->ac));
-      scratch_vgpr = LLVMBuildLoad2(builder, ctx->ac.i32, tmp, "");
+      LLVMValueRef idx = ac_get_thread_id(&ctx->ac);
+      LLVMValueRef v = ac_build_gep0_2(&ctx->ac, ctx->gs_ngg_scratch.t, ctx->gs_ngg_scratch.v, idx);
+      scratch_vgpr = LLVMBuildLoad2(builder, ac_build_gep0_type(ctx->gs_ngg_scratch.t, idx), v, "");
 
       for (unsigned buffer = 0; buffer < 4; ++buffer) {
          if (stream_for_buffer[buffer] >= 0) {
@@ -735,14 +739,15 @@ static unsigned ngg_nogs_vertex_size(struct si_shader *shader)
  * Returns an `[N x i32] addrspace(LDS)*` pointing at contiguous LDS storage
  * for the vertex outputs.
  */
-static LLVMValueRef ngg_nogs_vertex_ptr(struct si_shader_context *ctx, LLVMValueRef vtxid)
+static struct ac_llvm_pointer ngg_nogs_vertex_ptr(struct si_shader_context *ctx, LLVMValueRef vtxid)
 {
    /* The extra dword is used to avoid LDS bank conflicts. */
    unsigned vertex_size = ngg_nogs_vertex_size(ctx->shader);
    LLVMTypeRef ai32 = LLVMArrayType(ctx->ac.i32, vertex_size);
-   LLVMTypeRef pai32 = LLVMPointerType(ai32, AC_ADDR_SPACE_LDS);
-   LLVMValueRef tmp = LLVMBuildBitCast(ctx->ac.builder, ctx->esgs_ring, pai32, "");
-   return LLVMBuildGEP(ctx->ac.builder, tmp, &vtxid, 1, "");
+   return (struct ac_llvm_pointer) {
+      .value = LLVMBuildGEP2(ctx->ac.builder, ai32, ctx->esgs_ring, &vtxid, 1, ""),
+      .pointee_type = ai32
+   };
 }
 
 static LLVMValueRef si_insert_input_v4i32(struct si_shader_context *ctx, LLVMValueRef ret,
@@ -757,7 +762,7 @@ static LLVMValueRef si_insert_input_v4i32(struct si_shader_context *ctx, LLVMVal
    return ret;
 }
 
-static void load_vertex_counts(struct si_shader_context *ctx, LLVMValueRef lds,
+static void load_vertex_counts(struct si_shader_context *ctx, struct ac_llvm_pointer lds,
                                unsigned max_waves, LLVMValueRef tid,
                                LLVMValueRef *total_count,
                                LLVMValueRef *prefix_sum)
@@ -774,7 +779,8 @@ static void load_vertex_counts(struct si_shader_context *ctx, LLVMValueRef lds,
     */
    ac_build_ifcc(&ctx->ac, LLVMBuildICmp(builder, LLVMIntULT, tid,
                                          LLVMConstInt(ctx->ac.i32, num_i8vec4, 0), ""), 17771);
-   LLVMBuildStore(builder, LLVMBuildLoad2(builder, ctx->ac.i32, ac_build_gep0(&ctx->ac, lds, tid), ""), i8vec4_lane);
+   LLVMValueRef v = ac_build_gep0_2(&ctx->ac, lds.t, lds.v, tid);
+   LLVMBuildStore(builder, LLVMBuildLoad2(builder, ac_build_gep0_type(lds.t, tid), v, ""), i8vec4_lane);
    ac_build_endif(&ctx->ac, 17771);
 
    /* Compute the number of ES waves. */
@@ -887,7 +893,7 @@ static void gfx10_build_primitive_accepted(struct ac_llvm_context *ac, LLVMValue
    struct si_shader_context *ctx = container_of(ac, struct si_shader_context, ac);
    LLVMValueRef *params = (LLVMValueRef *)userdata;
    LLVMValueRef gs_accepted = params[0];
-   LLVMValueRef *gs_vtxptr = (LLVMValueRef *)params[1];
+   struct ac_llvm_pointer *gs_vtxptr = (struct ac_llvm_pointer *)params[1];
 
    unsigned num_vertices;
    ngg_get_vertices_per_prim(ctx, &num_vertices);
@@ -898,7 +904,7 @@ static void gfx10_build_primitive_accepted(struct ac_llvm_context *ac, LLVMValue
    if (gs_vtxptr) {
       for (unsigned vtx = 0; vtx < num_vertices; vtx++) {
          LLVMBuildStore(ctx->ac.builder, ctx->ac.i8_1,
-                        si_build_gep_i8(ctx, gs_vtxptr[vtx], lds_byte0_accept_flag));
+                        si_build_gep_i8(ctx, gs_vtxptr[vtx].value, lds_byte0_accept_flag));
       }
    }
    ac_build_endif(&ctx->ac, 0);
@@ -937,7 +943,7 @@ static bool add_clipdist_bits_for_clipvertex(struct si_shader_context *ctx,
 
 static void cull_primitive(struct si_shader_context *ctx,
                            LLVMValueRef pos[3][4], LLVMValueRef clipdist_accepted,
-                           LLVMValueRef out_prim_accepted, LLVMValueRef gs_vtxptr_accept[3])
+                           LLVMValueRef out_prim_accepted, struct ac_llvm_pointer gs_vtxptr_accept[3])
 {
    struct si_shader *shader = ctx->shader;
    LLVMBuilderRef builder = ctx->ac.builder;
@@ -1023,7 +1029,7 @@ void gfx10_ngg_culling_build_end(struct si_shader_context *ctx)
    assert(sel->stage == MESA_SHADER_VERTEX ||
           (sel->stage == MESA_SHADER_TESS_EVAL && !shader->key.ge.as_es));
 
-   LLVMValueRef es_vtxptr = ngg_nogs_vertex_ptr(ctx, gfx10_get_thread_id_in_tg(ctx));
+   struct ac_llvm_pointer es_vtxptr = ngg_nogs_vertex_ptr(ctx, gfx10_get_thread_id_in_tg(ctx));
    LLVMValueRef packed_data = ctx->ac.i32_0;
    LLVMValueRef position[4] = {};
    unsigned pos_index = 0;
@@ -1056,14 +1062,14 @@ void gfx10_ngg_culling_build_end(struct si_shader_context *ctx)
          /* Store Position.W into LDS. */
          LLVMBuildStore(
             builder, ac_to_integer(&ctx->ac, position[3]),
-            ac_build_gep0(&ctx->ac, es_vtxptr, LLVMConstInt(ctx->ac.i32, lds_pos_cull_w, 0)));
+            ac_build_gep0_2(&ctx->ac, es_vtxptr.t, es_vtxptr.v, LLVMConstInt(ctx->ac.i32, lds_pos_cull_w, 0)));
 
          /* Store Position.XY / W into LDS. */
          for (unsigned chan = 0; chan < 2; chan++) {
             LLVMValueRef val = ac_build_fdiv(&ctx->ac, position[chan], position[3]);
             LLVMBuildStore(
                builder, ac_to_integer(&ctx->ac, val),
-               ac_build_gep0(&ctx->ac, es_vtxptr, LLVMConstInt(ctx->ac.i32, lds_pos_cull_x_div_w + chan, 0)));
+               ac_build_gep0_2(&ctx->ac, es_vtxptr.t, es_vtxptr.v, LLVMConstInt(ctx->ac.i32, lds_pos_cull_x_div_w + chan, 0)));
          }
          break;
 
@@ -1105,7 +1111,7 @@ void gfx10_ngg_culling_build_end(struct si_shader_context *ctx)
    /* Initialize the packed data. */
    LLVMBuildStore(
       builder, packed_data,
-      ac_build_gep0(&ctx->ac, es_vtxptr, LLVMConstInt(ctx->ac.i32, lds_packed_data, 0)));
+      ac_build_gep0_2(&ctx->ac, es_vtxptr.t, es_vtxptr.v, LLVMConstInt(ctx->ac.i32, lds_packed_data, 0)));
    ac_build_endif(&ctx->ac, ctx->merged_wrap_if_label);
 
    ac_build_waitcnt(&ctx->ac, AC_WAIT_LGKM);
@@ -1148,7 +1154,7 @@ void gfx10_ngg_culling_build_end(struct si_shader_context *ctx)
    for (unsigned i = 0; i < num_vertices; ++i)
       vtxindex[i] = si_unpack_param(ctx, ctx->args.gs_vtx_offset[i / 2], (i & 1) * 16, 16);
 
-   LLVMValueRef gs_vtxptr[3];
+   struct ac_llvm_pointer gs_vtxptr[3];
    for (unsigned i = 0; i < num_vertices; i++)
       gs_vtxptr[i] = ngg_nogs_vertex_ptr(ctx, vtxindex[i]);
 
@@ -1180,7 +1186,7 @@ void gfx10_ngg_culling_build_end(struct si_shader_context *ctx)
     * - v_mul_u32_u24_e32 v18, 28, v10
     */
    for (unsigned i = 0; i < num_vertices; i++)
-      ac_build_optimization_barrier(&ctx->ac, &gs_vtxptr[i], false);
+      ac_build_optimization_barrier(&ctx->ac, &gs_vtxptr[i].value, false);
 
    LLVMValueRef gs_accepted = ac_build_alloca(&ctx->ac, ctx->ac.i32, "");
 
@@ -1201,9 +1207,9 @@ void gfx10_ngg_culling_build_end(struct si_shader_context *ctx)
             else
                continue;
 
-            LLVMValueRef addr =
-               ac_build_gep0(&ctx->ac, gs_vtxptr[vtx], LLVMConstInt(ctx->ac.i32, index, 0));
-            pos[vtx][chan] = LLVMBuildLoad(builder, addr, "");
+            LLVMValueRef idx = LLVMConstInt(ctx->ac.i32, index, 0);
+            LLVMValueRef v = ac_build_gep0_2(&ctx->ac, gs_vtxptr[vtx].t, gs_vtxptr[vtx].v, idx);
+            pos[vtx][chan] = LLVMBuildLoad2(builder, ac_build_gep0_type(gs_vtxptr[vtx].t, idx), v, "");
             pos[vtx][chan] = ac_to_float(&ctx->ac, pos[vtx][chan]);
          }
 
@@ -1212,7 +1218,7 @@ void gfx10_ngg_culling_build_end(struct si_shader_context *ctx)
              * negative. If all masks are AND'ed and the result is 0, the primitive isn't culled
              * by clip distances.
              */
-            LLVMValueRef addr = si_build_gep_i8(ctx, gs_vtxptr[vtx], lds_byte3_clipdist_neg_mask);
+            LLVMValueRef addr = si_build_gep_i8(ctx, gs_vtxptr[vtx].value, lds_byte3_clipdist_neg_mask);
             LLVMValueRef mask = LLVMBuildLoad2(builder, ctx->ac.i8, addr, "");
             if (!clipdist_neg_mask)
                clipdist_neg_mask = mask;
@@ -1241,7 +1247,7 @@ void gfx10_ngg_culling_build_end(struct si_shader_context *ctx)
    ac_build_ifcc(&ctx->ac, si_is_es_thread(ctx), 16007);
    {
       LLVMValueRef accepted =
-         LLVMBuildLoad2(builder, ctx->ac.i8, si_build_gep_i8(ctx, es_vtxptr, lds_byte0_accept_flag), "");
+         LLVMBuildLoad2(builder, ctx->ac.i8, si_build_gep_i8(ctx, es_vtxptr.value, lds_byte0_accept_flag), "");
       accepted = LLVMBuildICmp(builder, LLVMIntNE, accepted, ctx->ac.i8_0, "");
       LLVMValueRef mask = ac_get_i1_sgpr_mask(&ctx->ac, accepted);
 
@@ -1256,7 +1262,7 @@ void gfx10_ngg_culling_build_end(struct si_shader_context *ctx)
    {
       LLVMValueRef vertex_count = ac_build_bit_count(&ctx->ac, vertex_mask);
       LLVMBuildStore(builder, LLVMBuildTrunc(builder, vertex_count, ctx->ac.i8, ""),
-                     si_build_gep_i8_var(ctx, ctx->gs_ngg_scratch, get_wave_id_in_tg(ctx)));
+                     si_build_gep_i8_var(ctx, ctx->gs_ngg_scratch.value, get_wave_id_in_tg(ctx)));
    }
    ac_build_endif(&ctx->ac, 16008);
 
@@ -1289,17 +1295,17 @@ void gfx10_ngg_culling_build_end(struct si_shader_context *ctx)
       prefix_sum = LLVMBuildAdd(builder, prefix_sum, ac_build_mbcnt(&ctx->ac, vertex_mask), "");
 
       LLVMValueRef new_id = prefix_sum;
-      LLVMValueRef new_vtx = ngg_nogs_vertex_ptr(ctx, new_id);
+      struct ac_llvm_pointer new_vtx = ngg_nogs_vertex_ptr(ctx, new_id);
 
       LLVMBuildStore(builder, LLVMBuildTrunc(builder, new_id, ctx->ac.i8, ""),
-                     si_build_gep_i8(ctx, es_vtxptr, lds_byte1_new_thread_id));
+                     si_build_gep_i8(ctx, es_vtxptr.value, lds_byte1_new_thread_id));
 
       /* Store Position.XYZW into LDS. */
       for (unsigned chan = 0; chan < 4; chan++) {
          LLVMBuildStore(
             builder, ac_to_integer(&ctx->ac,
                                    LLVMBuildLoad2(builder, ctx->ac.f32, addrs[4 * pos_index + chan], "")),
-            ac_build_gep0(&ctx->ac, new_vtx, LLVMConstInt(ctx->ac.i32, lds_pos_x + chan, 0)));
+            ac_build_gep0_2(&ctx->ac, new_vtx.t, new_vtx.v, LLVMConstInt(ctx->ac.i32, lds_pos_x + chan, 0)));
       }
 
       /* Store VertexID and InstanceID into LDS. ES threads will have to load them
@@ -1309,24 +1315,24 @@ void gfx10_ngg_culling_build_end(struct si_shader_context *ctx)
       if (ctx->stage == MESA_SHADER_VERTEX) {
          LLVMBuildStore(
             builder, ctx->abi.vertex_id,
-            ac_build_gep0(&ctx->ac, new_vtx, LLVMConstInt(ctx->ac.i32, lds_vertex_id, 0)));
+            ac_build_gep0_2(&ctx->ac, new_vtx.t, new_vtx.v, LLVMConstInt(ctx->ac.i32, lds_vertex_id, 0)));
          if (uses_instance_id) {
             LLVMBuildStore(
                builder, ctx->abi.instance_id,
-               ac_build_gep0(&ctx->ac, new_vtx, LLVMConstInt(ctx->ac.i32, lds_instance_id, 0)));
+               ac_build_gep0_2(&ctx->ac, new_vtx.t, new_vtx.v, LLVMConstInt(ctx->ac.i32, lds_instance_id, 0)));
          }
       } else {
          assert(ctx->stage == MESA_SHADER_TESS_EVAL);
          LLVMBuildStore(builder, ac_to_integer(&ctx->ac, ac_get_arg(&ctx->ac, ctx->args.tes_u)),
-                        ac_build_gep0(&ctx->ac, new_vtx, LLVMConstInt(ctx->ac.i32, lds_tes_u, 0)));
+                        ac_build_gep0_2(&ctx->ac, new_vtx.t, new_vtx.v, LLVMConstInt(ctx->ac.i32, lds_tes_u, 0)));
          LLVMBuildStore(builder, ac_to_integer(&ctx->ac, ac_get_arg(&ctx->ac, ctx->args.tes_v)),
-                        ac_build_gep0(&ctx->ac, new_vtx, LLVMConstInt(ctx->ac.i32, lds_tes_v, 0)));
+                        ac_build_gep0_2(&ctx->ac, new_vtx.t, new_vtx.v, LLVMConstInt(ctx->ac.i32, lds_tes_v, 0)));
          LLVMBuildStore(builder, LLVMBuildTrunc(builder, ac_get_arg(&ctx->ac, ctx->args.tes_rel_patch_id), ctx->ac.i8, ""),
-                        si_build_gep_i8(ctx, new_vtx, lds_byte2_tes_rel_patch_id));
+                        si_build_gep_i8(ctx, new_vtx.value, lds_byte2_tes_rel_patch_id));
          if (uses_tes_prim_id) {
             LLVMBuildStore(
                builder, ac_get_arg(&ctx->ac, ctx->args.tes_patch_id),
-               ac_build_gep0(&ctx->ac, new_vtx, LLVMConstInt(ctx->ac.i32, lds_tes_patch_id, 0)));
+               ac_build_gep0_2(&ctx->ac, new_vtx.t, new_vtx.v, LLVMConstInt(ctx->ac.i32, lds_tes_patch_id, 0)));
          }
       }
    }
@@ -1391,7 +1397,7 @@ void gfx10_ngg_culling_build_end(struct si_shader_context *ctx)
 
       for (unsigned vtx = 0; vtx < num_vertices; vtx++) {
          prim.index[vtx] = LLVMBuildLoad2(
-            builder, ctx->ac.i8, si_build_gep_i8(ctx, gs_vtxptr[vtx], lds_byte1_new_thread_id), "");
+            builder, ctx->ac.i8, si_build_gep_i8(ctx, gs_vtxptr[vtx].value, lds_byte1_new_thread_id), "");
          prim.index[vtx] = LLVMBuildZExt(builder, prim.index[vtx], ctx->ac.i32, "");
       }
 
@@ -1405,13 +1411,13 @@ void gfx10_ngg_culling_build_end(struct si_shader_context *ctx)
 
    /* Prepare LDS addresses of the new ES input VGPRs. */
    LLVMValueRef input_vgpr_addresses[4] = {
-      ac_build_gep0(&ctx->ac, es_vtxptr, LLVMConstInt(ctx->ac.i32, lds_vertex_id, 0)),
-      ac_build_gep0(&ctx->ac, es_vtxptr, LLVMConstInt(ctx->ac.i32, lds_instance_id, 0)),
+      ac_build_gep0_2(&ctx->ac, es_vtxptr.t, es_vtxptr.v, LLVMConstInt(ctx->ac.i32, lds_vertex_id, 0)),
+      ac_build_gep0_2(&ctx->ac, es_vtxptr.t, es_vtxptr.v, LLVMConstInt(ctx->ac.i32, lds_instance_id, 0)),
    };
    if (ctx->stage == MESA_SHADER_TESS_EVAL) {
-      input_vgpr_addresses[2] = si_build_gep_i8(ctx, es_vtxptr, lds_byte2_tes_rel_patch_id);
+      input_vgpr_addresses[2] = si_build_gep_i8(ctx, es_vtxptr.v, lds_byte2_tes_rel_patch_id);
       if (uses_tes_prim_id) {
-         input_vgpr_addresses[3] = ac_build_gep0(&ctx->ac, es_vtxptr,
+         input_vgpr_addresses[3] = ac_build_gep0_2(&ctx->ac, es_vtxptr.t, es_vtxptr.v,
                                                  LLVMConstInt(ctx->ac.i32, lds_tes_patch_id, 0));
       }
    }
@@ -1523,7 +1529,7 @@ void gfx10_ngg_build_end(struct si_shader_context *ctx)
    assert(!ctx->shader->is_gs_copy_shader);
    assert(info->num_outputs <= AC_LLVM_MAX_OUTPUTS);
 
-   LLVMValueRef vertex_ptr = NULL;
+   struct ac_llvm_pointer vertex_ptr = {};
 
    if (ctx->so.num_outputs || gfx10_ngg_writes_user_edgeflags(ctx->shader))
       vertex_ptr = ngg_nogs_vertex_ptr(ctx, gfx10_get_thread_id_in_tg(ctx));
@@ -1538,8 +1544,9 @@ void gfx10_ngg_build_end(struct si_shader_context *ctx)
           * but streamout performance isn't that important.
           */
          if (ctx->so.num_outputs) {
-            tmp = ac_build_gep0(&ctx->ac, vertex_ptr, LLVMConstInt(ctx->ac.i32, 4 * i + j, false));
-            tmp2 = LLVMBuildLoad2(builder, ctx->ac.f32, addrs[4 * i + j], "");
+            LLVMValueRef idx = LLVMConstInt(ctx->ac.i32, 4 * i + j, false);
+            tmp = ac_build_gep0_2(&ctx->ac, vertex_ptr.t, vertex_ptr.v, idx);
+            tmp2 = LLVMBuildLoad2(builder, ac_build_gep0_type(vertex_ptr.t, idx), addrs[4 * i + j], "");
             LLVMTypeRef type = ac_to_integer_type(&ctx->ac, ctx->ac.f32);
             tmp2 = LLVMBuildBitCast(ctx->ac.builder, tmp2, type, "");
             LLVMBuildStore(builder, tmp2, tmp);
@@ -1554,7 +1561,7 @@ void gfx10_ngg_build_end(struct si_shader_context *ctx)
          edgeflag = ac_build_umin(&ctx->ac, edgeflag, ctx->ac.i32_1);
 
          tmp = LLVMConstInt(ctx->ac.i32, ngg_nogs_vertex_size(ctx->shader) - 1, 0);
-         tmp = ac_build_gep0(&ctx->ac, vertex_ptr, tmp);
+         tmp = ac_build_gep0_2(&ctx->ac, vertex_ptr.t, vertex_ptr.v, tmp);
          LLVMBuildStore(builder, edgeflag, tmp);
       }
    }
@@ -1614,10 +1621,10 @@ void gfx10_ngg_build_end(struct si_shader_context *ctx)
       ac_build_ifcc(&ctx->ac, is_gs_thread, 5400);
       /* Load edge flags from ES threads and store them into VGPRs in GS threads. */
       for (unsigned i = 0; i < num_vertices; i++) {
-         tmp = ngg_nogs_vertex_ptr(ctx, vtxindex[i]);
+         struct ac_llvm_pointer vt = ngg_nogs_vertex_ptr(ctx, vtxindex[i]);
          tmp2 = LLVMConstInt(ctx->ac.i32, ngg_nogs_vertex_size(ctx->shader) - 1, 0);
-         tmp = ac_build_gep0(&ctx->ac, tmp, tmp2);
-         tmp = LLVMBuildLoad2(builder, ctx->ac.i32, tmp, "");
+         tmp = LLVMBuildLoad2(builder, ac_build_gep0_type(vt.t, tmp2),
+                              ac_build_gep0_2(&ctx->ac, vt.t, vt.v, tmp2), "");
          tmp = LLVMBuildTrunc(builder, tmp, ctx->ac.i1, "");
 
          user_edgeflags[i] = ac_build_alloca_init(&ctx->ac, tmp, "");
@@ -1645,10 +1652,10 @@ void gfx10_ngg_build_end(struct si_shader_context *ctx)
       LLVMValueRef indices = ac_build_gather_values(&ctx->ac, vtxindex, 3);
       LLVMValueRef provoking_vtx_index =
          LLVMBuildExtractElement(builder, indices, provoking_vtx_in_prim, "");
-      LLVMValueRef vertex_ptr = ngg_nogs_vertex_ptr(ctx, provoking_vtx_index);
+      struct ac_llvm_pointer vertex_ptr = ngg_nogs_vertex_ptr(ctx, provoking_vtx_index);
 
       LLVMBuildStore(builder, ac_get_arg(&ctx->ac, ctx->args.gs_prim_id),
-                     ac_build_gep0(&ctx->ac, vertex_ptr, ctx->ac.i32_0));
+                     ac_build_gep0_2(&ctx->ac, vertex_ptr.t, vertex_ptr.v, ctx->ac.i32_0));
       ac_build_endif(&ctx->ac, 5400);
    }
 
@@ -1712,10 +1719,10 @@ void gfx10_ngg_build_end(struct si_shader_context *ctx)
 
             for (unsigned j = 0; j < 4; j++) {
                tmp = LLVMConstInt(ctx->ac.i32, lds_pos_x + j, 0);
-               tmp = ac_build_gep0(&ctx->ac, vertex_ptr, tmp);
-               tmp = LLVMBuildLoad2(builder, ctx->ac.i32, tmp, "");
+               LLVMValueRef v = ac_build_gep0_2(&ctx->ac, vertex_ptr.t, vertex_ptr.v, tmp);
+               tmp = LLVMBuildLoad2(builder, ac_build_gep0_type(vertex_ptr.t, tmp), v, "");
                outputs[i].values[j] = LLVMBuildBitCast(ctx->ac.builder, tmp,
-                                                       ac_to_float_type(&ctx->ac, ctx->ac.i32), "");
+                                                       ac_to_float_type(&ctx->ac, ctx->ac.f32), "");
             }
          } else {
             for (unsigned j = 0; j < 4; j++) {
@@ -1733,9 +1740,9 @@ void gfx10_ngg_build_end(struct si_shader_context *ctx)
             ac_build_waitcnt(&ctx->ac, AC_WAIT_LGKM);
             ac_build_s_barrier(&ctx->ac, ctx->stage);
 
-            tmp = ngg_nogs_vertex_ptr(ctx, gfx10_get_thread_id_in_tg(ctx));
-            tmp = ac_build_gep0(&ctx->ac, tmp, ctx->ac.i32_0);
-            outputs[i].values[0] = LLVMBuildLoad2(builder, ctx->ac.i32, tmp, "");
+            struct ac_llvm_pointer vt = ngg_nogs_vertex_ptr(ctx, gfx10_get_thread_id_in_tg(ctx));
+            outputs[i].values[0] = LLVMBuildLoad2(
+               builder, ac_build_gep0_type(vt.t, ctx->ac.i32_0), ac_build_gep0_2(&ctx->ac, vt.t, vt.v, ctx->ac.i32_0), "");
          } else {
             assert(ctx->stage == MESA_SHADER_TESS_EVAL);
             outputs[i].values[0] = si_get_primitive_id(ctx, 0);
@@ -1798,7 +1805,7 @@ static struct ac_llvm_pointer ngg_gs_get_vertex_storage(struct si_shader_context
  *
  * \return an LDS pointer to type {[N x i32], [4 x i8]}
  */
-static LLVMValueRef ngg_gs_vertex_ptr(struct si_shader_context *ctx, LLVMValueRef vertexidx)
+static struct ac_llvm_pointer ngg_gs_vertex_ptr(struct si_shader_context *ctx, LLVMValueRef vertexidx)
 {
    struct si_shader_selector *sel = ctx->shader->selector;
    LLVMBuilderRef builder = ctx->ac.builder;
@@ -1813,11 +1820,14 @@ static LLVMValueRef ngg_gs_vertex_ptr(struct si_shader_context *ctx, LLVMValueRe
       vertexidx = LLVMBuildXor(builder, vertexidx, swizzle, "");
    }
 
-   return ac_build_gep0(&ctx->ac, storage.value, vertexidx);
+   return (struct ac_llvm_pointer) {
+      .value = ac_build_gep0_2(&ctx->ac, storage.t, storage.v, vertexidx),
+      .pointee_type = ac_build_gep0_type(storage.t, vertexidx)
+   };
 }
 
-static LLVMValueRef ngg_gs_emit_vertex_ptr(struct si_shader_context *ctx, LLVMValueRef gsthread,
-                                           LLVMValueRef emitidx)
+static struct ac_llvm_pointer ngg_gs_emit_vertex_ptr(struct si_shader_context *ctx, LLVMValueRef gsthread,
+                                                        LLVMValueRef emitidx)
 {
    struct si_shader_selector *sel = ctx->shader->selector;
    LLVMBuilderRef builder = ctx->ac.builder;
@@ -1830,25 +1840,25 @@ static LLVMValueRef ngg_gs_emit_vertex_ptr(struct si_shader_context *ctx, LLVMVa
 }
 
 static LLVMValueRef ngg_gs_get_emit_output_ptr(struct si_shader_context *ctx,
-                                               LLVMValueRef vertexptr, unsigned out_idx)
+                                               struct ac_llvm_pointer vertexptr, unsigned out_idx)
 {
    LLVMValueRef gep_idx[3] = {
       ctx->ac.i32_0, /* implied C-style array */
       ctx->ac.i32_0, /* first struct entry */
       LLVMConstInt(ctx->ac.i32, out_idx, false),
    };
-   return LLVMBuildGEP(ctx->ac.builder, vertexptr, gep_idx, 3, "");
+   return LLVMBuildGEP2(ctx->ac.builder, vertexptr.pointee_type, vertexptr.value, gep_idx, 3, "");
 }
 
 static LLVMValueRef ngg_gs_get_emit_primflag_ptr(struct si_shader_context *ctx,
-                                                 LLVMValueRef vertexptr, unsigned stream)
+                                                 struct ac_llvm_pointer vertexptr, unsigned stream)
 {
    LLVMValueRef gep_idx[3] = {
       ctx->ac.i32_0, /* implied C-style array */
       ctx->ac.i32_1, /* second struct entry */
       LLVMConstInt(ctx->ac.i32, stream, false),
    };
-   return LLVMBuildGEP(ctx->ac.builder, vertexptr, gep_idx, 3, "");
+   return LLVMBuildGEP2(ctx->ac.builder, vertexptr.pointee_type, vertexptr.value, gep_idx, 3, "");
 }
 
 void gfx10_ngg_gs_emit_vertex(struct si_shader_context *ctx, unsigned stream, LLVMValueRef *addrs)
@@ -1873,7 +1883,7 @@ void gfx10_ngg_gs_emit_vertex(struct si_shader_context *ctx, unsigned stream, LL
 
    ac_build_ifcc(&ctx->ac, can_emit, 9001);
 
-   const LLVMValueRef vertexptr = ngg_gs_emit_vertex_ptr(ctx, gfx10_get_thread_id_in_tg(ctx), vertexidx);
+   const struct ac_llvm_pointer vertexptr = ngg_gs_emit_vertex_ptr(ctx, gfx10_get_thread_id_in_tg(ctx), vertexidx);
    unsigned out_idx = 0;
    for (unsigned i = 0; i < info->num_outputs; i++) {
       for (unsigned chan = 0; chan < 4; chan++, out_idx++) {
@@ -1931,14 +1941,14 @@ void gfx10_ngg_gs_emit_begin(struct si_shader_context *ctx)
     * per-stream generated primitive count.
     */
    LLVMBuilderRef builder = ctx->ac.builder;
-   LLVMValueRef scratchptr = ctx->gs_ngg_scratch;
+   struct ac_llvm_pointer scratchptr = ctx->gs_ngg_scratch;
    LLVMValueRef tid = gfx10_get_thread_id_in_tg(ctx);
    LLVMValueRef tmp;
 
    tmp = LLVMBuildICmp(builder, LLVMIntULT, tid, LLVMConstInt(ctx->ac.i32, 4, false), "");
    ac_build_ifcc(&ctx->ac, tmp, 5090);
    {
-      LLVMValueRef ptr = ac_build_gep0(&ctx->ac, scratchptr, tid);
+      LLVMValueRef ptr = ac_build_gep0_2(&ctx->ac, scratchptr.t, scratchptr.v, tid);
       LLVMBuildStore(builder, ctx->ac.i32_0, ptr);
    }
    ac_build_endif(&ctx->ac, 5090);
@@ -2004,8 +2014,8 @@ void gfx10_ngg_gs_build_end(struct si_shader_context *ctx)
       tmp = LLVMBuildAdd(builder, vertexidx, ctx->ac.i32_1, "");
       LLVMBuildStore(builder, tmp, ctx->gs_next_vertex[stream]);
 
-      tmp = ngg_gs_emit_vertex_ptr(ctx, gsthread, vertexidx);
-      LLVMBuildStore(builder, i8_0, ngg_gs_get_emit_primflag_ptr(ctx, tmp, stream));
+      struct ac_llvm_pointer vt = ngg_gs_emit_vertex_ptr(ctx, gsthread, vertexidx);
+      LLVMBuildStore(builder, i8_0, ngg_gs_get_emit_primflag_ptr(ctx, vt, stream));
 
       ac_build_endloop(&ctx->ac, 5100);
    }
@@ -2023,7 +2033,7 @@ void gfx10_ngg_gs_build_end(struct si_shader_context *ctx)
       {
          LLVMBuildAtomicRMW(
             builder, LLVMAtomicRMWBinOpAdd,
-            ac_build_gep0(&ctx->ac, ctx->gs_ngg_scratch, LLVMConstInt(ctx->ac.i32, stream, false)),
+            ac_build_gep0_2(&ctx->ac, ctx->gs_ngg_scratch.t, ctx->gs_ngg_scratch.v, LLVMConstInt(ctx->ac.i32, stream, false)),
             numprims, LLVMAtomicOrderingMonotonic, false);
       }
       ac_build_endif(&ctx->ac, 5105);
@@ -2043,7 +2053,7 @@ void gfx10_ngg_gs_build_end(struct si_shader_context *ctx)
 
       nggso.num_vertices = LLVMConstInt(ctx->ac.i32, verts_per_prim, false);
 
-      LLVMValueRef vertexptr = ngg_gs_vertex_ptr(ctx, tid);
+      struct ac_llvm_pointer vertexptr = ngg_gs_vertex_ptr(ctx, tid);
       for (unsigned stream = 0; stream < 4; ++stream) {
          if (!info->num_stream_output_components[stream])
             continue;
@@ -2057,8 +2067,9 @@ void gfx10_ngg_gs_build_end(struct si_shader_context *ctx)
       for (unsigned i = 0; i < verts_per_prim; ++i) {
          tmp = LLVMBuildSub(builder, tid, LLVMConstInt(ctx->ac.i32, verts_per_prim - i - 1, false),
                             "");
-         tmp = ngg_gs_vertex_ptr(ctx, tmp);
-         nggso.vertices[i] = ac_build_gep0(&ctx->ac, tmp, ctx->ac.i32_0);
+         struct ac_llvm_pointer vt = ngg_gs_vertex_ptr(ctx, tmp);
+         nggso.vertices[i].t = ac_build_gep0_type(vt.t, ctx->ac.i32_0);
+         nggso.vertices[i].v = ac_build_gep0_2(&ctx->ac, vt.t, vt.v, ctx->ac.i32_0);
       }
 
       build_streamout(ctx, &nggso);
@@ -2085,7 +2096,9 @@ void gfx10_ngg_gs_build_end(struct si_shader_context *ctx)
             offset = LLVMBuildAdd(builder, offset, tmp, "");
          }
 
-         tmp = LLVMBuildLoad2(builder, ctx->ac.i32, ac_build_gep0(&ctx->ac, ctx->gs_ngg_scratch, tid), "");
+         tmp = LLVMBuildLoad2(builder, ctx->ac.i32,
+                              ac_build_gep0_2(&ctx->ac, ctx->gs_ngg_scratch.t, ctx->gs_ngg_scratch.v,
+                                            tid), "");
          LLVMValueRef args[] = {
             tmp,           ngg_get_query_buf(ctx),
             offset,        LLVMConstInt(ctx->ac.i32, 16, false), /* soffset */
@@ -2102,7 +2115,7 @@ void gfx10_ngg_gs_build_end(struct si_shader_context *ctx)
    if (ctx->shader->key.ge.opt.ngg_culling) {
       assert(info->num_stream_output_components[0]);
 
-      LLVMValueRef gs_vtxptr = ngg_gs_vertex_ptr(ctx, tid);
+      struct ac_llvm_pointer gs_vtxptr = ngg_gs_vertex_ptr(ctx, tid);
       LLVMValueRef live = LLVMBuildLoad2(builder, ctx->ac.i8, ngg_gs_get_emit_primflag_ptr(ctx, gs_vtxptr, 0), "");
       live = LLVMBuildTrunc(builder, live, ctx->ac.i1, "");
       LLVMValueRef is_emit = LLVMBuildICmp(builder, LLVMIntULT, tid, num_emit_threads, "");
@@ -2116,12 +2129,14 @@ void gfx10_ngg_gs_build_end(struct si_shader_context *ctx)
 
       ac_build_ifcc(&ctx->ac, prim_enable, 0);
       {
-         LLVMValueRef vtxptr[3] = {};
+         struct ac_llvm_pointer vtxptr[3] = {};
          LLVMValueRef pos[3][4] = {};
 
          for (unsigned i = 0; i < verts_per_prim; i++) {
             tmp = LLVMBuildSub(builder, tid, LLVMConstInt(ctx->ac.i32, verts_per_prim - i - 1, false), "");
-            vtxptr[i] = ac_build_gep0(&ctx->ac, ngg_gs_vertex_ptr(ctx, tmp), ctx->ac.i32_0);
+            struct ac_llvm_pointer vt = ngg_gs_vertex_ptr(ctx, tmp);
+            vtxptr[i].t = ac_build_gep0_type(vt.t, ctx->ac.i32_0);
+            vtxptr[i].v = ac_build_gep0_2(&ctx->ac, vt.t, vt.v, ctx->ac.i32_0);
          }
 
          for (unsigned i = 0; i < info->num_outputs; i++) {
@@ -2141,9 +2156,11 @@ void gfx10_ngg_gs_build_end(struct si_shader_context *ctx)
                      if (comp == 2)
                         continue;
 
-                     tmp = ac_build_gep0(&ctx->ac, vtxptr[vert],
-                                         LLVMConstInt(ctx->ac.i32, 4 * i + comp, false));
-                     pos[vert][comp] = LLVMBuildLoad(builder, tmp, "");
+                     LLVMValueRef idx = LLVMConstInt(ctx->ac.i32, 4 * i + comp, false);
+                     tmp = ac_build_gep0_2(&ctx->ac, vtxptr[vert].t, vtxptr[vert].v, idx);
+                     pos[vert][comp] = LLVMBuildLoad2(builder,
+                                                      ac_build_gep0_type(vtxptr[vert].t, idx),
+                                                      tmp, "");
                      pos[vert][comp] = ac_to_float(&ctx->ac, pos[vert][comp]);
                   }
                }
@@ -2191,8 +2208,8 @@ void gfx10_ngg_gs_build_end(struct si_shader_context *ctx)
          }
 
          /* Load primitive liveness */
-         tmp = ngg_gs_vertex_ptr(ctx, primidx);
-         tmp = LLVMBuildLoad2(builder, ctx->ac.i8, ngg_gs_get_emit_primflag_ptr(ctx, tmp, 0), "");
+         struct ac_llvm_pointer vt = ngg_gs_vertex_ptr(ctx, primidx);
+         tmp = LLVMBuildLoad2(builder, ctx->ac.i8, ngg_gs_get_emit_primflag_ptr(ctx, vt, 0), "");
          const LLVMValueRef primlive = LLVMBuildTrunc(builder, tmp, ctx->ac.i1, "");
 
          tmp = LLVMBuildLoad2(builder, ctx->ac.i1, vertliveptr, "");
@@ -2212,7 +2229,7 @@ void gfx10_ngg_gs_build_end(struct si_shader_context *ctx)
    vertlive_scan.enable_reduce = true;
    vertlive_scan.enable_exclusive = true;
    vertlive_scan.src = vertlive;
-   vertlive_scan.scratch = ac_build_gep0(&ctx->ac, ctx->gs_ngg_scratch, ctx->ac.i32_0);
+   vertlive_scan.scratch = ac_build_gep0_2(&ctx->ac, ctx->gs_ngg_scratch.t, ctx->gs_ngg_scratch.v, ctx->ac.i32_0);
    vertlive_scan.waveidx = get_wave_id_in_tg(ctx);
    vertlive_scan.numwaves = get_tgsize(ctx);
    vertlive_scan.maxwaves = DIV_ROUND_UP(256, ctx->ac.wave_size);
@@ -2235,9 +2252,9 @@ void gfx10_ngg_gs_build_end(struct si_shader_context *ctx)
     * threadgroup can have at most 256 threads. */
    ac_build_ifcc(&ctx->ac, vertlive, 5130);
    {
-      tmp = ngg_gs_vertex_ptr(ctx, vertlive_scan.result_exclusive);
+      struct ac_llvm_pointer vt = ngg_gs_vertex_ptr(ctx, vertlive_scan.result_exclusive);
       tmp2 = LLVMBuildTrunc(builder, tid, ctx->ac.i8, "");
-      LLVMBuildStore(builder, tmp2, ngg_gs_get_emit_primflag_ptr(ctx, tmp, 1));
+      LLVMBuildStore(builder, tmp2, ngg_gs_get_emit_primflag_ptr(ctx, vt, 1));
    }
    ac_build_endif(&ctx->ac, 5130);
 
@@ -2252,8 +2269,8 @@ void gfx10_ngg_gs_build_end(struct si_shader_context *ctx)
       struct ac_ngg_prim prim = {};
       prim.num_vertices = verts_per_prim;
 
-      tmp = ngg_gs_vertex_ptr(ctx, tid);
-      flags = LLVMBuildLoad2(builder, ctx->ac.i8, ngg_gs_get_emit_primflag_ptr(ctx, tmp, 0), "");
+      struct ac_llvm_pointer vt = ngg_gs_vertex_ptr(ctx, tid);
+      flags = LLVMBuildLoad2(builder, ctx->ac.i8, ngg_gs_get_emit_primflag_ptr(ctx, vt, 0), "");
       prim.isnull = LLVMBuildNot(builder, LLVMBuildTrunc(builder, flags, ctx->ac.i1, ""), "");
       prim.edgeflags = ctx->ac.i32_0;
 
@@ -2305,10 +2322,10 @@ void gfx10_ngg_gs_build_end(struct si_shader_context *ctx)
    {
       struct si_shader_output_values outputs[PIPE_MAX_SHADER_OUTPUTS];
 
-      tmp = ngg_gs_vertex_ptr(ctx, tid);
-      tmp = LLVMBuildLoad2(builder, ctx->ac.i8, ngg_gs_get_emit_primflag_ptr(ctx, tmp, 1), "");
+      struct ac_llvm_pointer vertexptr = ngg_gs_vertex_ptr(ctx, tid);
+      tmp = LLVMBuildLoad2(builder, ctx->ac.i8, ngg_gs_get_emit_primflag_ptr(ctx, vertexptr, 1), "");
       tmp = LLVMBuildZExt(builder, tmp, ctx->ac.i32, "");
-      const LLVMValueRef vertexptr = ngg_gs_vertex_ptr(ctx, tmp);
+      vertexptr = ngg_gs_vertex_ptr(ctx, tmp);
 
       unsigned out_idx = 0;
       for (unsigned i = 0; i < info->num_outputs; i++) {
diff --git a/src/gallium/drivers/radeonsi/si_shader_internal.h b/src/gallium/drivers/radeonsi/si_shader_internal.h
index d846c64632f4..2c975ea93577 100644
--- a/src/gallium/drivers/radeonsi/si_shader_internal.h
+++ b/src/gallium/drivers/radeonsi/si_shader_internal.h
@@ -145,7 +145,7 @@ struct si_shader_context {
    LLVMValueRef gs_curprim_verts[4];
    LLVMValueRef gs_generated_prims[4];
    LLVMValueRef gs_ngg_emit;
-   LLVMValueRef gs_ngg_scratch;
+   struct ac_llvm_pointer gs_ngg_scratch;
    LLVMValueRef return_value;
 
    LLVMValueRef gs_emitted_vertices;
diff --git a/src/gallium/drivers/radeonsi/si_shader_llvm.c b/src/gallium/drivers/radeonsi/si_shader_llvm.c
index 376c0227fd5a..2b9d8a13ea0c 100644
--- a/src/gallium/drivers/radeonsi/si_shader_llvm.c
+++ b/src/gallium/drivers/radeonsi/si_shader_llvm.c
@@ -815,10 +815,8 @@ static LLVMValueRef si_llvm_load_intrinsic(struct ac_shader_abi *abi, nir_intrin
       return ac_get_arg(&ctx->ac, ctx->args.es2gs_offset);
 
    case nir_intrinsic_load_clip_half_line_width_amd: {
-      LLVMValueRef ptr =
-         LLVMBuildPointerCast(ctx->ac.builder, ac_get_arg(&ctx->ac, ctx->small_prim_cull_info),
-                              LLVMPointerType(ctx->ac.v2f32, AC_ADDR_SPACE_CONST_32BIT), "");
-      return ac_build_load_to_sgpr(&ctx->ac, ptr, LLVMConstInt(ctx->ac.i32, 4, 0));
+      LLVMValueRef ptr = ac_get_arg(&ctx->ac, ctx->small_prim_cull_info);
+      return ac_build_load_to_sgpr2(&ctx->ac, ctx->ac.v2f32, ptr, LLVMConstInt(ctx->ac.i32, 4, 0));
    }
 
    case nir_intrinsic_load_viewport_xy_scale_and_offset: {
@@ -964,12 +962,14 @@ bool si_llvm_translate_nir(struct si_shader_context *ctx, struct si_shader *shad
             ctx->gs_generated_prims[i] = ac_build_alloca(&ctx->ac, ctx->ac.i32, "");
          }
 
-         assert(!ctx->gs_ngg_scratch);
+         assert(!ctx->gs_ngg_scratch.value);
          LLVMTypeRef ai32 = LLVMArrayType(ctx->ac.i32, gfx10_ngg_get_scratch_dw_size(shader));
-         ctx->gs_ngg_scratch =
-            LLVMAddGlobalInAddressSpace(ctx->ac.module, ai32, "ngg_scratch", AC_ADDR_SPACE_LDS);
-         LLVMSetInitializer(ctx->gs_ngg_scratch, LLVMGetUndef(ai32));
-         LLVMSetAlignment(ctx->gs_ngg_scratch, 4);
+         ctx->gs_ngg_scratch = (struct ac_llvm_pointer) {
+            .value = LLVMAddGlobalInAddressSpace(ctx->ac.module, ai32, "ngg_scratch", AC_ADDR_SPACE_LDS),
+            .pointee_type = ai32
+         };
+         LLVMSetInitializer(ctx->gs_ngg_scratch.value, LLVMGetUndef(ai32));
+         LLVMSetAlignment(ctx->gs_ngg_scratch.value, 4);
 
          ctx->gs_ngg_emit = LLVMAddGlobalInAddressSpace(
             ctx->ac.module, LLVMArrayType(ctx->ac.i32, 0), "ngg_emit", AC_ADDR_SPACE_LDS);
@@ -1047,12 +1047,14 @@ bool si_llvm_translate_nir(struct si_shader_context *ctx, struct si_shader *shad
       /* This is really only needed when streamout and / or vertex
        * compaction is enabled.
        */
-      if (!ctx->gs_ngg_scratch && (ctx->so.num_outputs || shader->key.ge.opt.ngg_culling)) {
+      if (!ctx->gs_ngg_scratch.value && (ctx->so.num_outputs || shader->key.ge.opt.ngg_culling)) {
          LLVMTypeRef asi32 = LLVMArrayType(ctx->ac.i32, gfx10_ngg_get_scratch_dw_size(shader));
-         ctx->gs_ngg_scratch =
-            LLVMAddGlobalInAddressSpace(ctx->ac.module, asi32, "ngg_scratch", AC_ADDR_SPACE_LDS);
-         LLVMSetInitializer(ctx->gs_ngg_scratch, LLVMGetUndef(asi32));
-         LLVMSetAlignment(ctx->gs_ngg_scratch, 4);
+         ctx->gs_ngg_scratch = (struct ac_llvm_pointer) {
+            .value = LLVMAddGlobalInAddressSpace(ctx->ac.module, asi32, "ngg_scratch", AC_ADDR_SPACE_LDS),
+            .pointee_type = asi32
+         };
+         LLVMSetInitializer(ctx->gs_ngg_scratch.value, LLVMGetUndef(asi32));
+         LLVMSetAlignment(ctx->gs_ngg_scratch.value, 4);
       }
    }
 
diff --git a/src/gallium/drivers/radeonsi/si_shader_llvm_gs.c b/src/gallium/drivers/radeonsi/si_shader_llvm_gs.c
index 4bc12bd1c88b..dda09dc38ffd 100644
--- a/src/gallium/drivers/radeonsi/si_shader_llvm_gs.c
+++ b/src/gallium/drivers/radeonsi/si_shader_llvm_gs.c
@@ -264,8 +264,9 @@ void si_preload_esgs_ring(struct si_shader_context *ctx)
    if (ctx->screen->info.gfx_level <= GFX8) {
       LLVMValueRef offset = LLVMConstInt(ctx->ac.i32, SI_RING_ESGS, 0);
       LLVMValueRef buf_ptr = ac_get_arg(&ctx->ac, ctx->internal_bindings);
+      LLVMTypeRef type = ac_get_arg_pointee_type(&ctx->ac, &ctx->args, ctx->internal_bindings);
 
-      ctx->esgs_ring = ac_build_load_to_sgpr(&ctx->ac, buf_ptr, offset);
+      ctx->esgs_ring = ac_build_load_to_sgpr2(&ctx->ac, type, buf_ptr, offset);
 
       if (ctx->stage != MESA_SHADER_GEOMETRY) {
          LLVMValueRef desc1 = LLVMBuildExtractElement(builder, ctx->esgs_ring, ctx->ac.i32_1, "");
-- 
GitLab


From df9c03ebefae0abbafb4c8992672eb50531ec0e6 Mon Sep 17 00:00:00 2001
From: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
Date: Tue, 11 Oct 2022 10:39:18 +0200
Subject: [PATCH 22/26] ac/llvm: remove gep_2 and others temporary functions
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Reviewed-by: Mihai Preda <mhpreda@gmail.com>
Reviewed-by: Dave Airlie <airlied@redhat.com>
Reviewed-by: Qiang Yu <yuq825@gmail.com>
Reviewed-by: Marek Olšák <marek.olsak@amd.com>
Acked-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
---
 src/amd/llvm/ac_llvm_build.c                  | 75 ++++-------------
 src/amd/llvm/ac_llvm_build.h                  | 16 ++--
 src/amd/llvm/ac_nir_to_llvm.c                 |  6 +-
 src/amd/vulkan/radv_nir_to_llvm.c             | 16 ++--
 .../drivers/radeonsi/gfx10_shader_ngg.c       | 84 +++++++++----------
 src/gallium/drivers/radeonsi/si_shader_llvm.c | 12 +--
 .../drivers/radeonsi/si_shader_llvm_gs.c      | 10 +--
 .../drivers/radeonsi/si_shader_llvm_ps.c      |  8 +-
 .../radeonsi/si_shader_llvm_resources.c       | 20 ++---
 .../drivers/radeonsi/si_shader_llvm_vs.c      | 14 ++--
 10 files changed, 104 insertions(+), 157 deletions(-)

diff --git a/src/amd/llvm/ac_llvm_build.c b/src/amd/llvm/ac_llvm_build.c
index 4c09ed8feea9..a5b145397b11 100644
--- a/src/amd/llvm/ac_llvm_build.c
+++ b/src/amd/llvm/ac_llvm_build.c
@@ -1090,15 +1090,6 @@ LLVMValueRef ac_build_gep_ptr(struct ac_llvm_context *ctx, LLVMTypeRef type, LLV
    return LLVMBuildGEP2(ctx->builder, type, base_ptr, &index, 1, "");
 }
 
-LLVMValueRef ac_build_gep0(struct ac_llvm_context *ctx, LLVMValueRef base_ptr, LLVMValueRef index)
-{
-   LLVMValueRef indices[2] = {
-      ctx->i32_0,
-      index,
-   };
-   return LLVMBuildGEP(ctx->builder, base_ptr, indices, 2, "");
-}
-
 LLVMTypeRef ac_build_gep0_type(LLVMTypeRef pointee_type, LLVMValueRef index)
 {
    switch (LLVMGetTypeKind(pointee_type)) {
@@ -1121,7 +1112,7 @@ LLVMTypeRef ac_build_gep0_type(LLVMTypeRef pointee_type, LLVMValueRef index)
    return NULL;
 }
 
-LLVMValueRef ac_build_gep0_2(struct ac_llvm_context *ctx, LLVMTypeRef pointee_type, LLVMValueRef value, LLVMValueRef index)
+LLVMValueRef ac_build_gep0(struct ac_llvm_context *ctx, LLVMTypeRef pointee_type, LLVMValueRef value, LLVMValueRef index)
 {
    LLVMValueRef indices[2] = {
       ctx->i32_0,
@@ -1136,16 +1127,10 @@ LLVMValueRef ac_build_pointer_add(struct ac_llvm_context *ctx, LLVMTypeRef type,
    return LLVMBuildGEP2(ctx->builder, type, ptr, &index, 1, "");
 }
 
-void ac_build_indexed_store(struct ac_llvm_context *ctx, LLVMValueRef base_ptr, LLVMValueRef index,
+void ac_build_indexed_store(struct ac_llvm_context *ctx, LLVMTypeRef type, LLVMValueRef base_ptr, LLVMValueRef index,
                             LLVMValueRef value)
 {
-   LLVMBuildStore(ctx->builder, value, ac_build_gep0(ctx, base_ptr, index));
-}
-
-void ac_build_indexed_store2(struct ac_llvm_context *ctx, LLVMTypeRef type, LLVMValueRef base_ptr, LLVMValueRef index,
-                             LLVMValueRef value)
-{
-   LLVMBuildStore(ctx->builder, value, ac_build_gep0_2(ctx, type, base_ptr, index));
+   LLVMBuildStore(ctx->builder, value, ac_build_gep0(ctx, type, base_ptr, index));
 }
 
 /**
@@ -1176,30 +1161,9 @@ void ac_build_indexed_store2(struct ac_llvm_context *ctx, LLVMTypeRef type, LLVM
  *      ptr2 = LLVMBuildInBoundsGEP(ptr1, 32 / elemsize);
  *      sampler = load(ptr2); // becomes "s_load ptr1, 32" thanks to InBounds
  */
-static LLVMValueRef ac_build_load_custom(struct ac_llvm_context *ctx, LLVMValueRef base_ptr,
-                                         LLVMValueRef index, bool uniform, bool invariant,
-                                         bool no_unsigned_wraparound)
-{
-   LLVMValueRef pointer, result;
-
-   if (no_unsigned_wraparound &&
-       LLVMGetPointerAddressSpace(LLVMTypeOf(base_ptr)) == AC_ADDR_SPACE_CONST_32BIT)
-      pointer = LLVMBuildInBoundsGEP(ctx->builder, base_ptr, &index, 1, "");
-   else
-      pointer = LLVMBuildGEP(ctx->builder, base_ptr, &index, 1, "");
-
-   if (uniform)
-      LLVMSetMetadata(pointer, ctx->uniform_md_kind, ctx->empty_md);
-   result = LLVMBuildLoad(ctx->builder, pointer, "");
-   if (invariant)
-      LLVMSetMetadata(result, ctx->invariant_load_md_kind, ctx->empty_md);
-   LLVMSetAlignment(result, 4);
-   return result;
-}
-
-static LLVMValueRef ac_build_load_custom2(struct ac_llvm_context *ctx, LLVMTypeRef type,
-                                          LLVMValueRef base_ptr, LLVMValueRef index,
-                                          bool uniform, bool invariant, bool no_unsigned_wraparound)
+static LLVMValueRef ac_build_load_custom(struct ac_llvm_context *ctx, LLVMTypeRef type,
+                                         LLVMValueRef base_ptr, LLVMValueRef index,
+                                         bool uniform, bool invariant, bool no_unsigned_wraparound)
 {
    LLVMValueRef pointer, result;
 
@@ -1220,39 +1184,28 @@ static LLVMValueRef ac_build_load_custom2(struct ac_llvm_context *ctx, LLVMTypeR
 
 LLVMValueRef ac_build_load(struct ac_llvm_context *ctx, LLVMTypeRef type, LLVMValueRef base_ptr, LLVMValueRef index)
 {
-   return ac_build_load_custom2(ctx, type, base_ptr, index, false, false, false);
+   return ac_build_load_custom(ctx, type, base_ptr, index, false, false, false);
 }
 
 LLVMValueRef ac_build_load_invariant(struct ac_llvm_context *ctx, LLVMTypeRef type, LLVMValueRef base_ptr,
                                      LLVMValueRef index)
 {
-   return ac_build_load_custom2(ctx, type, base_ptr, index, false, true, false);
+   return ac_build_load_custom(ctx, type, base_ptr, index, false, true, false);
 }
 
 /* This assumes that there is no unsigned integer wraparound during the address
  * computation, excluding all GEPs within base_ptr. */
-LLVMValueRef ac_build_load_to_sgpr(struct ac_llvm_context *ctx, LLVMValueRef base_ptr,
+LLVMValueRef ac_build_load_to_sgpr(struct ac_llvm_context *ctx, LLVMTypeRef type, LLVMValueRef base_ptr,
                                    LLVMValueRef index)
 {
-   return ac_build_load_custom(ctx, base_ptr, index, true, true, true);
-}
-
-LLVMValueRef ac_build_load_to_sgpr2(struct ac_llvm_context *ctx, LLVMTypeRef type, LLVMValueRef base_ptr,
-                                    LLVMValueRef index)
-{
-   return ac_build_load_custom2(ctx, type, base_ptr, index, true, true, true);
+   return ac_build_load_custom(ctx, type, base_ptr, index, true, true, true);
 }
 
 /* See ac_build_load_custom() documentation. */
-LLVMValueRef ac_build_load_to_sgpr_uint_wraparound(struct ac_llvm_context *ctx,
-                                                   LLVMValueRef base_ptr, LLVMValueRef index)
-{
-   return ac_build_load_custom(ctx, base_ptr, index, true, true, false);
-}
-LLVMValueRef ac_build_load_to_sgpr_uint_wraparound2(struct ac_llvm_context *ctx, LLVMTypeRef type,
+LLVMValueRef ac_build_load_to_sgpr_uint_wraparound(struct ac_llvm_context *ctx, LLVMTypeRef type,
                                                    LLVMValueRef base_ptr, LLVMValueRef index)
 {
-   return ac_build_load_custom2(ctx, type, base_ptr, index, true, true, false);
+   return ac_build_load_custom(ctx, type, base_ptr, index, true, true, false);
 }
 
 static unsigned get_load_cache_policy(struct ac_llvm_context *ctx, unsigned cache_policy)
@@ -2830,14 +2783,14 @@ void ac_declare_lds_as_pointer(struct ac_llvm_context *ctx)
 
 LLVMValueRef ac_lds_load(struct ac_llvm_context *ctx, LLVMValueRef dw_addr)
 {
-   LLVMValueRef v = ac_build_gep0_2(ctx, ctx->lds.t, ctx->lds.v, dw_addr);
+   LLVMValueRef v = ac_build_gep0(ctx, ctx->lds.t, ctx->lds.v, dw_addr);
    return LLVMBuildLoad2(ctx->builder, ctx->i32, v, "");
 }
 
 void ac_lds_store(struct ac_llvm_context *ctx, LLVMValueRef dw_addr, LLVMValueRef value)
 {
    value = ac_to_integer(ctx, value);
-   ac_build_indexed_store2(ctx, ctx->lds.t, ctx->lds.v, dw_addr, value);
+   ac_build_indexed_store(ctx, ctx->lds.t, ctx->lds.v, dw_addr, value);
 }
 
 LLVMValueRef ac_find_lsb(struct ac_llvm_context *ctx, LLVMTypeRef dst_type, LLVMValueRef src0)
diff --git a/src/amd/llvm/ac_llvm_build.h b/src/amd/llvm/ac_llvm_build.h
index aeee00ee5176..776faedaa920 100644
--- a/src/amd/llvm/ac_llvm_build.h
+++ b/src/amd/llvm/ac_llvm_build.h
@@ -254,28 +254,22 @@ LLVMValueRef ac_build_fs_interp_mov(struct ac_llvm_context *ctx, LLVMValueRef pa
 LLVMValueRef ac_build_gep_ptr(struct ac_llvm_context *ctx, LLVMTypeRef type, LLVMValueRef base_ptr,
                               LLVMValueRef index);
 
-LLVMValueRef ac_build_gep0(struct ac_llvm_context *ctx, LLVMValueRef value, LLVMValueRef index);
 LLVMValueRef ac_build_pointer_add(struct ac_llvm_context *ctx, LLVMTypeRef type, LLVMValueRef ptr,
                                   LLVMValueRef index);
 
 LLVMTypeRef ac_build_gep0_type(LLVMTypeRef pointee_type, LLVMValueRef index);
-LLVMValueRef ac_build_gep0_2(struct ac_llvm_context *ctx, LLVMTypeRef type, LLVMValueRef value, LLVMValueRef index);
+LLVMValueRef ac_build_gep0(struct ac_llvm_context *ctx, LLVMTypeRef type, LLVMValueRef value, LLVMValueRef index);
 
-void ac_build_indexed_store(struct ac_llvm_context *ctx, LLVMValueRef base_ptr, LLVMValueRef index,
+void ac_build_indexed_store(struct ac_llvm_context *ctx, LLVMTypeRef type, LLVMValueRef base_ptr, LLVMValueRef index,
                             LLVMValueRef value);
-void ac_build_indexed_store2(struct ac_llvm_context *ctx, LLVMTypeRef type, LLVMValueRef base_ptr, LLVMValueRef index,
-                             LLVMValueRef value);
 
 LLVMValueRef ac_build_load(struct ac_llvm_context *ctx, LLVMTypeRef type, LLVMValueRef base_ptr, LLVMValueRef index);
 LLVMValueRef ac_build_load_invariant(struct ac_llvm_context *ctx, LLVMTypeRef type, LLVMValueRef base_ptr,
                                      LLVMValueRef index);
-LLVMValueRef ac_build_load_to_sgpr(struct ac_llvm_context *ctx, LLVMValueRef base_ptr,
+LLVMValueRef ac_build_load_to_sgpr(struct ac_llvm_context *ctx, LLVMTypeRef type, LLVMValueRef base_ptr,
                                    LLVMValueRef index);
-LLVMValueRef ac_build_load_to_sgpr2(struct ac_llvm_context *ctx, LLVMTypeRef type, LLVMValueRef base_ptr,
-                                    LLVMValueRef index);
-LLVMValueRef ac_build_load_to_sgpr_uint_wraparound(struct ac_llvm_context *ctx,
-                                                   LLVMValueRef base_ptr, LLVMValueRef index);
-LLVMValueRef ac_build_load_to_sgpr_uint_wraparound2(struct ac_llvm_context *ctx, LLVMTypeRef type,
+
+LLVMValueRef ac_build_load_to_sgpr_uint_wraparound(struct ac_llvm_context *ctx, LLVMTypeRef type,
                                                    LLVMValueRef base_ptr, LLVMValueRef index);
 
 void ac_build_buffer_store_dword(struct ac_llvm_context *ctx, LLVMValueRef rsrc, LLVMValueRef vdata,
diff --git a/src/amd/llvm/ac_nir_to_llvm.c b/src/amd/llvm/ac_nir_to_llvm.c
index 2f46db6cdfc2..47f944bafd8e 100644
--- a/src/amd/llvm/ac_nir_to_llvm.c
+++ b/src/amd/llvm/ac_nir_to_llvm.c
@@ -4114,7 +4114,7 @@ static bool visit_intrinsic(struct ac_nir_context *ctx, nir_intrinsic_instr *ins
       break;
    case nir_intrinsic_load_scratch: {
       LLVMValueRef offset = get_src(ctx, instr->src[0]);
-      LLVMValueRef ptr = ac_build_gep0_2(&ctx->ac, ctx->scratch.t, ctx->scratch.v, offset);
+      LLVMValueRef ptr = ac_build_gep0(&ctx->ac, ctx->scratch.t, ctx->scratch.v, offset);
       LLVMTypeRef comp_type = LLVMIntTypeInContext(ctx->ac.context, instr->dest.ssa.bit_size);
       LLVMTypeRef vec_type = instr->dest.ssa.num_components == 1
                                 ? comp_type
@@ -4124,7 +4124,7 @@ static bool visit_intrinsic(struct ac_nir_context *ctx, nir_intrinsic_instr *ins
    }
    case nir_intrinsic_store_scratch: {
       LLVMValueRef offset = get_src(ctx, instr->src[1]);
-      LLVMValueRef ptr = ac_build_gep0_2(&ctx->ac, ctx->scratch.t, ctx->scratch.v, offset);
+      LLVMValueRef ptr = ac_build_gep0(&ctx->ac, ctx->scratch.t, ctx->scratch.v, offset);
       LLVMTypeRef comp_type = LLVMIntTypeInContext(ctx->ac.context, instr->src[0].ssa->bit_size);
       LLVMValueRef src = get_src(ctx, instr->src[0]);
       unsigned wrmask = nir_intrinsic_write_mask(instr);
@@ -4153,7 +4153,7 @@ static bool visit_intrinsic(struct ac_nir_context *ctx, nir_intrinsic_instr *ins
       LLVMValueRef cond = LLVMBuildICmp(ctx->ac.builder, LLVMIntULT, offset, size, "");
       offset = LLVMBuildSelect(ctx->ac.builder, cond, offset, size, "");
 
-      LLVMValueRef ptr = ac_build_gep0_2(&ctx->ac, ctx->constant_data.t, ctx->constant_data.v, offset);
+      LLVMValueRef ptr = ac_build_gep0(&ctx->ac, ctx->constant_data.t, ctx->constant_data.v, offset);
       LLVMTypeRef comp_type = LLVMIntTypeInContext(ctx->ac.context, instr->dest.ssa.bit_size);
       LLVMTypeRef vec_type = instr->dest.ssa.num_components == 1
                                 ? comp_type
diff --git a/src/amd/vulkan/radv_nir_to_llvm.c b/src/amd/vulkan/radv_nir_to_llvm.c
index 64acae0508b2..46c1f8646cd3 100644
--- a/src/amd/vulkan/radv_nir_to_llvm.c
+++ b/src/amd/vulkan/radv_nir_to_llvm.c
@@ -114,7 +114,7 @@ load_descriptor_sets(struct radv_shader_context *ctx)
          int i = u_bit_scan(&mask);
 
          ctx->descriptor_sets[i] =
-            ac_build_load_to_sgpr2(&ctx->ac, type, desc_sets, LLVMConstInt(ctx->ac.i32, i, false));
+            ac_build_load_to_sgpr(&ctx->ac, type, desc_sets, LLVMConstInt(ctx->ac.i32, i, false));
          LLVMSetAlignment(ctx->descriptor_sets[i], 4);
       }
    } else {
@@ -400,7 +400,7 @@ load_vs_input(struct radv_shader_context *ctx, unsigned driver_location, LLVMTyp
    desc_index = util_bitcount(ctx->shader_info->vs.vb_desc_usage_mask &
                               u_bit_consecutive(0, desc_index));
    t_offset = LLVMConstInt(ctx->ac.i32, desc_index, false);
-   t_list = ac_build_load_to_sgpr2(&ctx->ac, t_list_type, t_list_ptr, t_offset);
+   t_list = ac_build_load_to_sgpr(&ctx->ac, t_list_type, t_list_ptr, t_offset);
 
    /* Always split typed vertex buffer loads on GFX6 and GFX10+ to avoid any alignment issues that
     * triggers memory violations and eventually a GPU hang. This can happen if the stride (static or
@@ -807,7 +807,7 @@ radv_emit_streamout(struct radv_shader_context *ctx, unsigned stream)
 
          LLVMValueRef offset = LLVMConstInt(ctx->ac.i32, i, false);
 
-         so_buffers[i] = ac_build_load_to_sgpr2(&ctx->ac, type, buf_ptr, offset);
+         so_buffers[i] = ac_build_load_to_sgpr(&ctx->ac, type, buf_ptr, offset);
 
          LLVMValueRef so_offset = ac_get_arg(&ctx->ac, ctx->args->ac.streamout_offset[i]);
 
@@ -1181,11 +1181,11 @@ ac_setup_rings(struct radv_shader_context *ctx)
       unsigned ring = ctx->stage == MESA_SHADER_GEOMETRY ? RING_ESGS_GS : RING_ESGS_VS;
       LLVMValueRef offset = LLVMConstInt(ctx->ac.i32, ring, false);
 
-      ctx->esgs_ring = ac_build_load_to_sgpr2(&ctx->ac, ctx->ac.i8, ctx->ring_offsets, offset);
+      ctx->esgs_ring = ac_build_load_to_sgpr(&ctx->ac, ctx->ac.i8, ctx->ring_offsets, offset);
    }
 
    if (ctx->args->is_gs_copy_shader) {
-      ctx->gsvs_ring[0] = ac_build_load_to_sgpr2(&ctx->ac, ctx->ac.i8, ctx->ring_offsets,
+      ctx->gsvs_ring[0] = ac_build_load_to_sgpr(&ctx->ac, ctx->ac.i8, ctx->ring_offsets,
                                                 LLVMConstInt(ctx->ac.i32, RING_GSVS_VS, false));
    }
 
@@ -1203,7 +1203,7 @@ ac_setup_rings(struct radv_shader_context *ctx)
       unsigned num_records = ctx->ac.wave_size;
       LLVMValueRef base_ring;
 
-      base_ring = ac_build_load_to_sgpr2(&ctx->ac, ctx->ac.i8, ctx->ring_offsets,
+      base_ring = ac_build_load_to_sgpr(&ctx->ac, ctx->ac.i8, ctx->ring_offsets,
                                         LLVMConstInt(ctx->ac.i32, RING_GSVS_GS, false));
 
       for (unsigned stream = 0; stream < 4; stream++) {
@@ -1243,9 +1243,9 @@ ac_setup_rings(struct radv_shader_context *ctx)
    }
 
    if (ctx->stage == MESA_SHADER_TESS_CTRL || ctx->stage == MESA_SHADER_TESS_EVAL) {
-      ctx->hs_ring_tess_offchip = ac_build_load_to_sgpr2(
+      ctx->hs_ring_tess_offchip = ac_build_load_to_sgpr(
          &ctx->ac, ctx->ac.i8, ctx->ring_offsets, LLVMConstInt(ctx->ac.i32, RING_HS_TESS_OFFCHIP, false));
-      ctx->hs_ring_tess_factor = ac_build_load_to_sgpr2(
+      ctx->hs_ring_tess_factor = ac_build_load_to_sgpr(
          &ctx->ac, ctx->ac.i8, ctx->ring_offsets, LLVMConstInt(ctx->ac.i32, RING_HS_TESS_FACTOR, false));
    }
 }
diff --git a/src/gallium/drivers/radeonsi/gfx10_shader_ngg.c b/src/gallium/drivers/radeonsi/gfx10_shader_ngg.c
index aae8a23379f9..27b907cdd557 100644
--- a/src/gallium/drivers/radeonsi/gfx10_shader_ngg.c
+++ b/src/gallium/drivers/radeonsi/gfx10_shader_ngg.c
@@ -67,8 +67,8 @@ static LLVMValueRef ngg_get_query_buf(struct si_shader_context *ctx)
 {
    LLVMValueRef buf_ptr = ac_get_arg(&ctx->ac, ctx->internal_bindings);
    LLVMTypeRef type = ac_get_arg_pointee_type(&ctx->ac, &ctx->args, ctx->internal_bindings);
-   return ac_build_load_to_sgpr2(&ctx->ac, type, buf_ptr,
-                                 LLVMConstInt(ctx->ac.i32, SI_GS_QUERY_BUF, false));
+   return ac_build_load_to_sgpr(&ctx->ac, type, buf_ptr,
+                                LLVMConstInt(ctx->ac.i32, SI_GS_QUERY_BUF, false));
 }
 
 static LLVMValueRef ngg_get_emulated_counters_buf(struct si_shader_context *ctx)
@@ -76,8 +76,8 @@ static LLVMValueRef ngg_get_emulated_counters_buf(struct si_shader_context *ctx)
    LLVMValueRef buf_ptr = ac_get_arg(&ctx->ac, ctx->internal_bindings);
    LLVMTypeRef type = ac_get_arg_pointee_type(&ctx->ac, &ctx->args, ctx->internal_bindings);
 
-   return ac_build_load_to_sgpr2(&ctx->ac, type, buf_ptr,
-                                 LLVMConstInt(ctx->ac.i32, SI_GS_QUERY_EMULATED_COUNTERS_BUF, false));
+   return ac_build_load_to_sgpr(&ctx->ac, type, buf_ptr,
+                                LLVMConstInt(ctx->ac.i32, SI_GS_QUERY_EMULATED_COUNTERS_BUF, false));
 }
 
 /**
@@ -253,7 +253,7 @@ static void build_streamout_vertex(struct si_shader_context *ctx, LLVMValueRef *
 
       for (unsigned comp = 0; comp < 4; comp++) {
          LLVMValueRef idx = LLVMConstInt(ctx->ac.i32, 4 * reg + comp, false);
-         LLVMValueRef v = ac_build_gep0_2(&ctx->ac, vertexptr.t, vertexptr.v, idx);
+         LLVMValueRef v = ac_build_gep0(&ctx->ac, vertexptr.t, vertexptr.v, idx);
          out.values[comp] = LLVMBuildLoad2(builder, ac_build_gep0_type(vertexptr.t, idx), v, "");
          out.vertex_streams = info->output_streams[reg];
       }
@@ -327,7 +327,7 @@ static void build_streamout(struct si_shader_context *ctx, struct ngg_streamout
          ac_build_writelane(&ctx->ac, prim_stride_dw_vgpr, prim_stride_dw[buffer],
                             LLVMConstInt(ctx->ac.i32, buffer, false));
 
-      so_buffer[buffer] = ac_build_load_to_sgpr2(
+      so_buffer[buffer] = ac_build_load_to_sgpr(
          &ctx->ac, type, buf_ptr, LLVMConstInt(ctx->ac.i32, SI_VS_STREAMOUT_BUF0 + buffer, false));
    }
 
@@ -345,7 +345,7 @@ static void build_streamout(struct si_shader_context *ctx, struct ngg_streamout
       ac_build_ifcc(&ctx->ac, tmp, 5210);
       {
          if (isgs) {
-            LLVMValueRef vt = ac_build_gep0_2(&ctx->ac, ctx->gs_ngg_scratch.t, ctx->gs_ngg_scratch.v, tid);
+            LLVMValueRef vt = ac_build_gep0(&ctx->ac, ctx->gs_ngg_scratch.t, ctx->gs_ngg_scratch.v, tid);
             tmp = LLVMBuildLoad2(builder, ac_build_gep0_type(ctx->gs_ngg_scratch.t, tid), vt, "");
          } else {
             tmp = ac_build_writelane(&ctx->ac, ctx->ac.i32_0, ngg_get_prim_cnt(ctx), ctx->ac.i32_0);
@@ -452,7 +452,7 @@ static void build_streamout(struct si_shader_context *ctx, struct ngg_streamout
          LLVMBuildStore(builder, tmp, offsets_vgpr);
 
          tmp2 = LLVMBuildAdd(builder, ac_get_thread_id(&ctx->ac), scratch_offset_basev, "");
-         tmp2 = ac_build_gep0_2(&ctx->ac, ctx->gs_ngg_scratch.t, ctx->gs_ngg_scratch.v, tmp2);
+         tmp2 = ac_build_gep0(&ctx->ac, ctx->gs_ngg_scratch.t, ctx->gs_ngg_scratch.v, tmp2);
          LLVMBuildStore(builder, tmp, tmp2);
       }
       ac_build_endif(&ctx->ac, 5210);
@@ -546,7 +546,7 @@ static void build_streamout(struct si_shader_context *ctx, struct ngg_streamout
       ac_build_ifcc(&ctx->ac, tmp, 5225);
       {
          tmp = LLVMBuildAdd(builder, ac_get_thread_id(&ctx->ac), scratch_emit_basev, "");
-         tmp = ac_build_gep0_2(&ctx->ac, ctx->gs_ngg_scratch.t, ctx->gs_ngg_scratch.v, tmp);
+         tmp = ac_build_gep0(&ctx->ac, ctx->gs_ngg_scratch.t, ctx->gs_ngg_scratch.v, tmp);
          LLVMBuildStore(builder, emit_vgpr, tmp);
       }
       ac_build_endif(&ctx->ac, 5225);
@@ -566,7 +566,7 @@ static void build_streamout(struct si_shader_context *ctx, struct ngg_streamout
          primemit_scan[stream].enable_exclusive = true;
          primemit_scan[stream].op = nir_op_iadd;
          primemit_scan[stream].src = nggso->prim_enable[stream];
-         primemit_scan[stream].scratch = ac_build_gep0_2(
+         primemit_scan[stream].scratch = ac_build_gep0(
             &ctx->ac, ctx->gs_ngg_scratch.t, ctx->gs_ngg_scratch.v,
             LLVMConstInt(ctx->ac.i32, 12 + 8 * stream, false));
          primemit_scan[stream].waveidx = get_wave_id_in_tg(ctx);
@@ -592,7 +592,7 @@ static void build_streamout(struct si_shader_context *ctx, struct ngg_streamout
       LLVMValueRef scratch_vgpr;
 
       LLVMValueRef idx = ac_get_thread_id(&ctx->ac);
-      LLVMValueRef v = ac_build_gep0_2(&ctx->ac, ctx->gs_ngg_scratch.t, ctx->gs_ngg_scratch.v, idx);
+      LLVMValueRef v = ac_build_gep0(&ctx->ac, ctx->gs_ngg_scratch.t, ctx->gs_ngg_scratch.v, idx);
       scratch_vgpr = LLVMBuildLoad2(builder, ac_build_gep0_type(ctx->gs_ngg_scratch.t, idx), v, "");
 
       for (unsigned buffer = 0; buffer < 4; ++buffer) {
@@ -779,7 +779,7 @@ static void load_vertex_counts(struct si_shader_context *ctx, struct ac_llvm_poi
     */
    ac_build_ifcc(&ctx->ac, LLVMBuildICmp(builder, LLVMIntULT, tid,
                                          LLVMConstInt(ctx->ac.i32, num_i8vec4, 0), ""), 17771);
-   LLVMValueRef v = ac_build_gep0_2(&ctx->ac, lds.t, lds.v, tid);
+   LLVMValueRef v = ac_build_gep0(&ctx->ac, lds.t, lds.v, tid);
    LLVMBuildStore(builder, LLVMBuildLoad2(builder, ac_build_gep0_type(lds.t, tid), v, ""), i8vec4_lane);
    ac_build_endif(&ctx->ac, 17771);
 
@@ -956,8 +956,8 @@ static void cull_primitive(struct si_shader_context *ctx,
    LLVMValueRef ptr = ac_get_arg(&ctx->ac, ctx->small_prim_cull_info);
    LLVMTypeRef type = ac_get_arg_pointee_type(&ctx->ac, &ctx->args, ctx->small_prim_cull_info);
    /* Lines will always use the non-AA viewport transformation. */
-   LLVMValueRef vp = ac_build_load_to_sgpr2(&ctx->ac, type, ptr,
-                                            prim_is_lines ? ctx->ac.i32_1 : ctx->ac.i32_0);
+   LLVMValueRef vp = ac_build_load_to_sgpr(&ctx->ac, type, ptr,
+                                           prim_is_lines ? ctx->ac.i32_1 : ctx->ac.i32_0);
    vp = LLVMBuildBitCast(builder, vp, ctx->ac.v4f32, "");
    vp_scale[0] = ac_llvm_extract_elem(&ctx->ac, vp, 0);
    vp_scale[1] = ac_llvm_extract_elem(&ctx->ac, vp, 1);
@@ -970,7 +970,7 @@ static void cull_primitive(struct si_shader_context *ctx,
    options.cull_w = true;
 
    if (prim_is_lines) {
-      LLVMValueRef terms = ac_build_load_to_sgpr2(&ctx->ac, ctx->ac.v2f32, ptr, LLVMConstInt(ctx->ac.i32, 4, 0));
+      LLVMValueRef terms = ac_build_load_to_sgpr(&ctx->ac, ctx->ac.v2f32, ptr, LLVMConstInt(ctx->ac.i32, 4, 0));
       terms = LLVMBuildBitCast(builder, terms, ctx->ac.v2f32, "");
       clip_half_line_width[0] = ac_llvm_extract_elem(&ctx->ac, terms, 0);
       clip_half_line_width[1] = ac_llvm_extract_elem(&ctx->ac, terms, 1);
@@ -1062,14 +1062,14 @@ void gfx10_ngg_culling_build_end(struct si_shader_context *ctx)
          /* Store Position.W into LDS. */
          LLVMBuildStore(
             builder, ac_to_integer(&ctx->ac, position[3]),
-            ac_build_gep0_2(&ctx->ac, es_vtxptr.t, es_vtxptr.v, LLVMConstInt(ctx->ac.i32, lds_pos_cull_w, 0)));
+            ac_build_gep0(&ctx->ac, es_vtxptr.t, es_vtxptr.v, LLVMConstInt(ctx->ac.i32, lds_pos_cull_w, 0)));
 
          /* Store Position.XY / W into LDS. */
          for (unsigned chan = 0; chan < 2; chan++) {
             LLVMValueRef val = ac_build_fdiv(&ctx->ac, position[chan], position[3]);
             LLVMBuildStore(
                builder, ac_to_integer(&ctx->ac, val),
-               ac_build_gep0_2(&ctx->ac, es_vtxptr.t, es_vtxptr.v, LLVMConstInt(ctx->ac.i32, lds_pos_cull_x_div_w + chan, 0)));
+               ac_build_gep0(&ctx->ac, es_vtxptr.t, es_vtxptr.v, LLVMConstInt(ctx->ac.i32, lds_pos_cull_x_div_w + chan, 0)));
          }
          break;
 
@@ -1111,7 +1111,7 @@ void gfx10_ngg_culling_build_end(struct si_shader_context *ctx)
    /* Initialize the packed data. */
    LLVMBuildStore(
       builder, packed_data,
-      ac_build_gep0_2(&ctx->ac, es_vtxptr.t, es_vtxptr.v, LLVMConstInt(ctx->ac.i32, lds_packed_data, 0)));
+      ac_build_gep0(&ctx->ac, es_vtxptr.t, es_vtxptr.v, LLVMConstInt(ctx->ac.i32, lds_packed_data, 0)));
    ac_build_endif(&ctx->ac, ctx->merged_wrap_if_label);
 
    ac_build_waitcnt(&ctx->ac, AC_WAIT_LGKM);
@@ -1208,7 +1208,7 @@ void gfx10_ngg_culling_build_end(struct si_shader_context *ctx)
                continue;
 
             LLVMValueRef idx = LLVMConstInt(ctx->ac.i32, index, 0);
-            LLVMValueRef v = ac_build_gep0_2(&ctx->ac, gs_vtxptr[vtx].t, gs_vtxptr[vtx].v, idx);
+            LLVMValueRef v = ac_build_gep0(&ctx->ac, gs_vtxptr[vtx].t, gs_vtxptr[vtx].v, idx);
             pos[vtx][chan] = LLVMBuildLoad2(builder, ac_build_gep0_type(gs_vtxptr[vtx].t, idx), v, "");
             pos[vtx][chan] = ac_to_float(&ctx->ac, pos[vtx][chan]);
          }
@@ -1305,7 +1305,7 @@ void gfx10_ngg_culling_build_end(struct si_shader_context *ctx)
          LLVMBuildStore(
             builder, ac_to_integer(&ctx->ac,
                                    LLVMBuildLoad2(builder, ctx->ac.f32, addrs[4 * pos_index + chan], "")),
-            ac_build_gep0_2(&ctx->ac, new_vtx.t, new_vtx.v, LLVMConstInt(ctx->ac.i32, lds_pos_x + chan, 0)));
+            ac_build_gep0(&ctx->ac, new_vtx.t, new_vtx.v, LLVMConstInt(ctx->ac.i32, lds_pos_x + chan, 0)));
       }
 
       /* Store VertexID and InstanceID into LDS. ES threads will have to load them
@@ -1315,24 +1315,24 @@ void gfx10_ngg_culling_build_end(struct si_shader_context *ctx)
       if (ctx->stage == MESA_SHADER_VERTEX) {
          LLVMBuildStore(
             builder, ctx->abi.vertex_id,
-            ac_build_gep0_2(&ctx->ac, new_vtx.t, new_vtx.v, LLVMConstInt(ctx->ac.i32, lds_vertex_id, 0)));
+            ac_build_gep0(&ctx->ac, new_vtx.t, new_vtx.v, LLVMConstInt(ctx->ac.i32, lds_vertex_id, 0)));
          if (uses_instance_id) {
             LLVMBuildStore(
                builder, ctx->abi.instance_id,
-               ac_build_gep0_2(&ctx->ac, new_vtx.t, new_vtx.v, LLVMConstInt(ctx->ac.i32, lds_instance_id, 0)));
+               ac_build_gep0(&ctx->ac, new_vtx.t, new_vtx.v, LLVMConstInt(ctx->ac.i32, lds_instance_id, 0)));
          }
       } else {
          assert(ctx->stage == MESA_SHADER_TESS_EVAL);
          LLVMBuildStore(builder, ac_to_integer(&ctx->ac, ac_get_arg(&ctx->ac, ctx->args.tes_u)),
-                        ac_build_gep0_2(&ctx->ac, new_vtx.t, new_vtx.v, LLVMConstInt(ctx->ac.i32, lds_tes_u, 0)));
+                        ac_build_gep0(&ctx->ac, new_vtx.t, new_vtx.v, LLVMConstInt(ctx->ac.i32, lds_tes_u, 0)));
          LLVMBuildStore(builder, ac_to_integer(&ctx->ac, ac_get_arg(&ctx->ac, ctx->args.tes_v)),
-                        ac_build_gep0_2(&ctx->ac, new_vtx.t, new_vtx.v, LLVMConstInt(ctx->ac.i32, lds_tes_v, 0)));
+                        ac_build_gep0(&ctx->ac, new_vtx.t, new_vtx.v, LLVMConstInt(ctx->ac.i32, lds_tes_v, 0)));
          LLVMBuildStore(builder, LLVMBuildTrunc(builder, ac_get_arg(&ctx->ac, ctx->args.tes_rel_patch_id), ctx->ac.i8, ""),
                         si_build_gep_i8(ctx, new_vtx.value, lds_byte2_tes_rel_patch_id));
          if (uses_tes_prim_id) {
             LLVMBuildStore(
                builder, ac_get_arg(&ctx->ac, ctx->args.tes_patch_id),
-               ac_build_gep0_2(&ctx->ac, new_vtx.t, new_vtx.v, LLVMConstInt(ctx->ac.i32, lds_tes_patch_id, 0)));
+               ac_build_gep0(&ctx->ac, new_vtx.t, new_vtx.v, LLVMConstInt(ctx->ac.i32, lds_tes_patch_id, 0)));
          }
       }
    }
@@ -1411,13 +1411,13 @@ void gfx10_ngg_culling_build_end(struct si_shader_context *ctx)
 
    /* Prepare LDS addresses of the new ES input VGPRs. */
    LLVMValueRef input_vgpr_addresses[4] = {
-      ac_build_gep0_2(&ctx->ac, es_vtxptr.t, es_vtxptr.v, LLVMConstInt(ctx->ac.i32, lds_vertex_id, 0)),
-      ac_build_gep0_2(&ctx->ac, es_vtxptr.t, es_vtxptr.v, LLVMConstInt(ctx->ac.i32, lds_instance_id, 0)),
+      ac_build_gep0(&ctx->ac, es_vtxptr.t, es_vtxptr.v, LLVMConstInt(ctx->ac.i32, lds_vertex_id, 0)),
+      ac_build_gep0(&ctx->ac, es_vtxptr.t, es_vtxptr.v, LLVMConstInt(ctx->ac.i32, lds_instance_id, 0)),
    };
    if (ctx->stage == MESA_SHADER_TESS_EVAL) {
       input_vgpr_addresses[2] = si_build_gep_i8(ctx, es_vtxptr.v, lds_byte2_tes_rel_patch_id);
       if (uses_tes_prim_id) {
-         input_vgpr_addresses[3] = ac_build_gep0_2(&ctx->ac, es_vtxptr.t, es_vtxptr.v,
+         input_vgpr_addresses[3] = ac_build_gep0(&ctx->ac, es_vtxptr.t, es_vtxptr.v,
                                                  LLVMConstInt(ctx->ac.i32, lds_tes_patch_id, 0));
       }
    }
@@ -1545,7 +1545,7 @@ void gfx10_ngg_build_end(struct si_shader_context *ctx)
           */
          if (ctx->so.num_outputs) {
             LLVMValueRef idx = LLVMConstInt(ctx->ac.i32, 4 * i + j, false);
-            tmp = ac_build_gep0_2(&ctx->ac, vertex_ptr.t, vertex_ptr.v, idx);
+            tmp = ac_build_gep0(&ctx->ac, vertex_ptr.t, vertex_ptr.v, idx);
             tmp2 = LLVMBuildLoad2(builder, ac_build_gep0_type(vertex_ptr.t, idx), addrs[4 * i + j], "");
             LLVMTypeRef type = ac_to_integer_type(&ctx->ac, ctx->ac.f32);
             tmp2 = LLVMBuildBitCast(ctx->ac.builder, tmp2, type, "");
@@ -1561,7 +1561,7 @@ void gfx10_ngg_build_end(struct si_shader_context *ctx)
          edgeflag = ac_build_umin(&ctx->ac, edgeflag, ctx->ac.i32_1);
 
          tmp = LLVMConstInt(ctx->ac.i32, ngg_nogs_vertex_size(ctx->shader) - 1, 0);
-         tmp = ac_build_gep0_2(&ctx->ac, vertex_ptr.t, vertex_ptr.v, tmp);
+         tmp = ac_build_gep0(&ctx->ac, vertex_ptr.t, vertex_ptr.v, tmp);
          LLVMBuildStore(builder, edgeflag, tmp);
       }
    }
@@ -1624,7 +1624,7 @@ void gfx10_ngg_build_end(struct si_shader_context *ctx)
          struct ac_llvm_pointer vt = ngg_nogs_vertex_ptr(ctx, vtxindex[i]);
          tmp2 = LLVMConstInt(ctx->ac.i32, ngg_nogs_vertex_size(ctx->shader) - 1, 0);
          tmp = LLVMBuildLoad2(builder, ac_build_gep0_type(vt.t, tmp2),
-                              ac_build_gep0_2(&ctx->ac, vt.t, vt.v, tmp2), "");
+                              ac_build_gep0(&ctx->ac, vt.t, vt.v, tmp2), "");
          tmp = LLVMBuildTrunc(builder, tmp, ctx->ac.i1, "");
 
          user_edgeflags[i] = ac_build_alloca_init(&ctx->ac, tmp, "");
@@ -1655,7 +1655,7 @@ void gfx10_ngg_build_end(struct si_shader_context *ctx)
       struct ac_llvm_pointer vertex_ptr = ngg_nogs_vertex_ptr(ctx, provoking_vtx_index);
 
       LLVMBuildStore(builder, ac_get_arg(&ctx->ac, ctx->args.gs_prim_id),
-                     ac_build_gep0_2(&ctx->ac, vertex_ptr.t, vertex_ptr.v, ctx->ac.i32_0));
+                     ac_build_gep0(&ctx->ac, vertex_ptr.t, vertex_ptr.v, ctx->ac.i32_0));
       ac_build_endif(&ctx->ac, 5400);
    }
 
@@ -1719,7 +1719,7 @@ void gfx10_ngg_build_end(struct si_shader_context *ctx)
 
             for (unsigned j = 0; j < 4; j++) {
                tmp = LLVMConstInt(ctx->ac.i32, lds_pos_x + j, 0);
-               LLVMValueRef v = ac_build_gep0_2(&ctx->ac, vertex_ptr.t, vertex_ptr.v, tmp);
+               LLVMValueRef v = ac_build_gep0(&ctx->ac, vertex_ptr.t, vertex_ptr.v, tmp);
                tmp = LLVMBuildLoad2(builder, ac_build_gep0_type(vertex_ptr.t, tmp), v, "");
                outputs[i].values[j] = LLVMBuildBitCast(ctx->ac.builder, tmp,
                                                        ac_to_float_type(&ctx->ac, ctx->ac.f32), "");
@@ -1742,7 +1742,7 @@ void gfx10_ngg_build_end(struct si_shader_context *ctx)
 
             struct ac_llvm_pointer vt = ngg_nogs_vertex_ptr(ctx, gfx10_get_thread_id_in_tg(ctx));
             outputs[i].values[0] = LLVMBuildLoad2(
-               builder, ac_build_gep0_type(vt.t, ctx->ac.i32_0), ac_build_gep0_2(&ctx->ac, vt.t, vt.v, ctx->ac.i32_0), "");
+               builder, ac_build_gep0_type(vt.t, ctx->ac.i32_0), ac_build_gep0(&ctx->ac, vt.t, vt.v, ctx->ac.i32_0), "");
          } else {
             assert(ctx->stage == MESA_SHADER_TESS_EVAL);
             outputs[i].values[0] = si_get_primitive_id(ctx, 0);
@@ -1821,7 +1821,7 @@ static struct ac_llvm_pointer ngg_gs_vertex_ptr(struct si_shader_context *ctx, L
    }
 
    return (struct ac_llvm_pointer) {
-      .value = ac_build_gep0_2(&ctx->ac, storage.t, storage.v, vertexidx),
+      .value = ac_build_gep0(&ctx->ac, storage.t, storage.v, vertexidx),
       .pointee_type = ac_build_gep0_type(storage.t, vertexidx)
    };
 }
@@ -1948,7 +1948,7 @@ void gfx10_ngg_gs_emit_begin(struct si_shader_context *ctx)
    tmp = LLVMBuildICmp(builder, LLVMIntULT, tid, LLVMConstInt(ctx->ac.i32, 4, false), "");
    ac_build_ifcc(&ctx->ac, tmp, 5090);
    {
-      LLVMValueRef ptr = ac_build_gep0_2(&ctx->ac, scratchptr.t, scratchptr.v, tid);
+      LLVMValueRef ptr = ac_build_gep0(&ctx->ac, scratchptr.t, scratchptr.v, tid);
       LLVMBuildStore(builder, ctx->ac.i32_0, ptr);
    }
    ac_build_endif(&ctx->ac, 5090);
@@ -2033,7 +2033,7 @@ void gfx10_ngg_gs_build_end(struct si_shader_context *ctx)
       {
          LLVMBuildAtomicRMW(
             builder, LLVMAtomicRMWBinOpAdd,
-            ac_build_gep0_2(&ctx->ac, ctx->gs_ngg_scratch.t, ctx->gs_ngg_scratch.v, LLVMConstInt(ctx->ac.i32, stream, false)),
+            ac_build_gep0(&ctx->ac, ctx->gs_ngg_scratch.t, ctx->gs_ngg_scratch.v, LLVMConstInt(ctx->ac.i32, stream, false)),
             numprims, LLVMAtomicOrderingMonotonic, false);
       }
       ac_build_endif(&ctx->ac, 5105);
@@ -2069,7 +2069,7 @@ void gfx10_ngg_gs_build_end(struct si_shader_context *ctx)
                             "");
          struct ac_llvm_pointer vt = ngg_gs_vertex_ptr(ctx, tmp);
          nggso.vertices[i].t = ac_build_gep0_type(vt.t, ctx->ac.i32_0);
-         nggso.vertices[i].v = ac_build_gep0_2(&ctx->ac, vt.t, vt.v, ctx->ac.i32_0);
+         nggso.vertices[i].v = ac_build_gep0(&ctx->ac, vt.t, vt.v, ctx->ac.i32_0);
       }
 
       build_streamout(ctx, &nggso);
@@ -2097,7 +2097,7 @@ void gfx10_ngg_gs_build_end(struct si_shader_context *ctx)
          }
 
          tmp = LLVMBuildLoad2(builder, ctx->ac.i32,
-                              ac_build_gep0_2(&ctx->ac, ctx->gs_ngg_scratch.t, ctx->gs_ngg_scratch.v,
+                              ac_build_gep0(&ctx->ac, ctx->gs_ngg_scratch.t, ctx->gs_ngg_scratch.v,
                                             tid), "");
          LLVMValueRef args[] = {
             tmp,           ngg_get_query_buf(ctx),
@@ -2136,7 +2136,7 @@ void gfx10_ngg_gs_build_end(struct si_shader_context *ctx)
             tmp = LLVMBuildSub(builder, tid, LLVMConstInt(ctx->ac.i32, verts_per_prim - i - 1, false), "");
             struct ac_llvm_pointer vt = ngg_gs_vertex_ptr(ctx, tmp);
             vtxptr[i].t = ac_build_gep0_type(vt.t, ctx->ac.i32_0);
-            vtxptr[i].v = ac_build_gep0_2(&ctx->ac, vt.t, vt.v, ctx->ac.i32_0);
+            vtxptr[i].v = ac_build_gep0(&ctx->ac, vt.t, vt.v, ctx->ac.i32_0);
          }
 
          for (unsigned i = 0; i < info->num_outputs; i++) {
@@ -2157,7 +2157,7 @@ void gfx10_ngg_gs_build_end(struct si_shader_context *ctx)
                         continue;
 
                      LLVMValueRef idx = LLVMConstInt(ctx->ac.i32, 4 * i + comp, false);
-                     tmp = ac_build_gep0_2(&ctx->ac, vtxptr[vert].t, vtxptr[vert].v, idx);
+                     tmp = ac_build_gep0(&ctx->ac, vtxptr[vert].t, vtxptr[vert].v, idx);
                      pos[vert][comp] = LLVMBuildLoad2(builder,
                                                       ac_build_gep0_type(vtxptr[vert].t, idx),
                                                       tmp, "");
@@ -2229,7 +2229,7 @@ void gfx10_ngg_gs_build_end(struct si_shader_context *ctx)
    vertlive_scan.enable_reduce = true;
    vertlive_scan.enable_exclusive = true;
    vertlive_scan.src = vertlive;
-   vertlive_scan.scratch = ac_build_gep0_2(&ctx->ac, ctx->gs_ngg_scratch.t, ctx->gs_ngg_scratch.v, ctx->ac.i32_0);
+   vertlive_scan.scratch = ac_build_gep0(&ctx->ac, ctx->gs_ngg_scratch.t, ctx->gs_ngg_scratch.v, ctx->ac.i32_0);
    vertlive_scan.waveidx = get_wave_id_in_tg(ctx);
    vertlive_scan.numwaves = get_tgsize(ctx);
    vertlive_scan.maxwaves = DIV_ROUND_UP(256, ctx->ac.wave_size);
diff --git a/src/gallium/drivers/radeonsi/si_shader_llvm.c b/src/gallium/drivers/radeonsi/si_shader_llvm.c
index 2b9d8a13ea0c..e0d6cfaa713e 100644
--- a/src/gallium/drivers/radeonsi/si_shader_llvm.c
+++ b/src/gallium/drivers/radeonsi/si_shader_llvm.c
@@ -767,7 +767,7 @@ static LLVMValueRef si_llvm_load_intrinsic(struct ac_shader_abi *abi, nir_intrin
       LLVMValueRef slot = LLVMConstInt(ctx->ac.i32, SI_HS_CONST_DEFAULT_TESS_LEVELS, 0);
       LLVMValueRef buf = ac_get_arg(&ctx->ac, ctx->internal_bindings);
       LLVMTypeRef type = ac_get_arg_pointee_type(&ctx->ac, &ctx->args, ctx->internal_bindings);
-      buf = ac_build_load_to_sgpr2(&ctx->ac, type, buf, slot);
+      buf = ac_build_load_to_sgpr(&ctx->ac, type, buf, slot);
       int offset = op == nir_intrinsic_load_tess_level_inner_default ? 4 : 0;
       LLVMValueRef val[4];
 
@@ -816,7 +816,7 @@ static LLVMValueRef si_llvm_load_intrinsic(struct ac_shader_abi *abi, nir_intrin
 
    case nir_intrinsic_load_clip_half_line_width_amd: {
       LLVMValueRef ptr = ac_get_arg(&ctx->ac, ctx->small_prim_cull_info);
-      return ac_build_load_to_sgpr2(&ctx->ac, ctx->ac.v2f32, ptr, LLVMConstInt(ctx->ac.i32, 4, 0));
+      return ac_build_load_to_sgpr(&ctx->ac, ctx->ac.v2f32, ptr, LLVMConstInt(ctx->ac.i32, 4, 0));
    }
 
    case nir_intrinsic_load_viewport_xy_scale_and_offset: {
@@ -824,7 +824,7 @@ static LLVMValueRef si_llvm_load_intrinsic(struct ac_shader_abi *abi, nir_intrin
       LLVMValueRef ptr = ac_get_arg(&ctx->ac, ctx->small_prim_cull_info);
       LLVMTypeRef type = ac_get_arg_pointee_type(&ctx->ac, &ctx->args, ctx->small_prim_cull_info);
       LLVMValueRef terms =
-         ac_build_load_to_sgpr2(&ctx->ac, type, ptr, prim_is_lines ? ctx->ac.i32_1 : ctx->ac.i32_0);
+         ac_build_load_to_sgpr(&ctx->ac, type, ptr, prim_is_lines ? ctx->ac.i32_1 : ctx->ac.i32_0);
       return LLVMBuildBitCast(ctx->ac.builder, terms, ctx->ac.v4f32, "");
    }
 
@@ -881,7 +881,7 @@ static LLVMValueRef si_llvm_load_user_clip_plane(struct ac_shader_abi *abi, unsi
    LLVMValueRef ptr = ac_get_arg(&ctx->ac, ctx->internal_bindings);
    LLVMTypeRef type = ac_get_arg_pointee_type(&ctx->ac, &ctx->args, ctx->internal_bindings);
    LLVMValueRef constbuf_index = LLVMConstInt(ctx->ac.i32, SI_VS_CONST_CLIP_PLANES, 0);
-   LLVMValueRef const_resource = ac_build_load_to_sgpr2(&ctx->ac, type, ptr, constbuf_index);
+   LLVMValueRef const_resource = ac_build_load_to_sgpr(&ctx->ac, type, ptr, constbuf_index);
    LLVMValueRef addr = LLVMConstInt(ctx->ac.i32, ucp_id * 16, 0);
    return ac_build_buffer_load(&ctx->ac, const_resource, 4, NULL, addr, NULL,
                                ctx->ac.f32, 0, true, true);
@@ -893,7 +893,7 @@ static LLVMValueRef si_llvm_load_streamout_buffer(struct ac_shader_abi *abi, uns
    LLVMValueRef buf_ptr = ac_get_arg(&ctx->ac, ctx->internal_bindings);
    LLVMTypeRef type = ac_get_arg_pointee_type(&ctx->ac, &ctx->args, ctx->internal_bindings);
 
-   return ac_build_load_to_sgpr2(
+   return ac_build_load_to_sgpr(
       &ctx->ac, type, buf_ptr, LLVMConstInt(ctx->ac.i32, SI_VS_STREAMOUT_BUF0 + buffer, false));
 }
 
@@ -933,7 +933,7 @@ bool si_llvm_translate_nir(struct si_shader_context *ctx, struct si_shader *shad
          LLVMValueRef buf = ac_get_arg(&ctx->ac, ctx->internal_bindings);
          LLVMTypeRef type = ac_get_arg_pointee_type(&ctx->ac, &ctx->args, ctx->internal_bindings);
          ctx->instance_divisor_constbuf =
-            ac_build_load_to_sgpr2(
+            ac_build_load_to_sgpr(
                &ctx->ac, type, buf, LLVMConstInt(ctx->ac.i32, SI_VS_CONST_INSTANCE_DIVISORS, 0));
       }
       break;
diff --git a/src/gallium/drivers/radeonsi/si_shader_llvm_gs.c b/src/gallium/drivers/radeonsi/si_shader_llvm_gs.c
index dda09dc38ffd..60c028761aef 100644
--- a/src/gallium/drivers/radeonsi/si_shader_llvm_gs.c
+++ b/src/gallium/drivers/radeonsi/si_shader_llvm_gs.c
@@ -101,8 +101,8 @@ static LLVMValueRef ngg_get_emulated_counters_buf(struct si_shader_context *ctx)
    LLVMValueRef buf_ptr = ac_get_arg(&ctx->ac, ctx->internal_bindings);
    LLVMTypeRef type = ac_get_arg_pointee_type(&ctx->ac, &ctx->args, ctx->internal_bindings);
 
-   return ac_build_load_to_sgpr2(&ctx->ac, type, buf_ptr,
-                                 LLVMConstInt(ctx->ac.i32, SI_GS_QUERY_EMULATED_COUNTERS_BUF, false));
+   return ac_build_load_to_sgpr(&ctx->ac, type, buf_ptr,
+                                LLVMConstInt(ctx->ac.i32, SI_GS_QUERY_EMULATED_COUNTERS_BUF, false));
 }
 
 void si_llvm_gs_build_end(struct si_shader_context *ctx)
@@ -266,7 +266,7 @@ void si_preload_esgs_ring(struct si_shader_context *ctx)
       LLVMValueRef buf_ptr = ac_get_arg(&ctx->ac, ctx->internal_bindings);
       LLVMTypeRef type = ac_get_arg_pointee_type(&ctx->ac, &ctx->args, ctx->internal_bindings);
 
-      ctx->esgs_ring = ac_build_load_to_sgpr2(&ctx->ac, type, buf_ptr, offset);
+      ctx->esgs_ring = ac_build_load_to_sgpr(&ctx->ac, type, buf_ptr, offset);
 
       if (ctx->stage != MESA_SHADER_GEOMETRY) {
          LLVMValueRef desc1 = LLVMBuildExtractElement(builder, ctx->esgs_ring, ctx->ac.i32_1, "");
@@ -309,7 +309,7 @@ void si_preload_gs_rings(struct si_shader_context *ctx)
    LLVMValueRef offset = LLVMConstInt(ctx->ac.i32, SI_RING_GSVS, 0);
    LLVMValueRef buf_ptr = ac_get_arg(&ctx->ac, ctx->internal_bindings);
    LLVMTypeRef type = ac_get_arg_pointee_type(&ctx->ac, &ctx->args, ctx->internal_bindings);
-   LLVMValueRef base_ring = ac_build_load_to_sgpr2(&ctx->ac, type, buf_ptr, offset);
+   LLVMValueRef base_ring = ac_build_load_to_sgpr(&ctx->ac, type, buf_ptr, offset);
 
    /* The conceptual layout of the GSVS ring is
     *   v0c0 .. vLv0 v0c1 .. vLc1 ..
@@ -438,7 +438,7 @@ struct si_shader *si_generate_gs_copy_shader(struct si_screen *sscreen,
    LLVMValueRef buf_ptr = ac_get_arg(&ctx.ac, ctx.internal_bindings);
    LLVMTypeRef type = ac_get_arg_pointee_type(&ctx.ac, &ctx.args, ctx.internal_bindings);
    ctx.gsvs_ring[0] =
-      ac_build_load_to_sgpr2(&ctx.ac, type, buf_ptr, LLVMConstInt(ctx.ac.i32, SI_RING_GSVS, 0));
+      ac_build_load_to_sgpr(&ctx.ac, type, buf_ptr, LLVMConstInt(ctx.ac.i32, SI_RING_GSVS, 0));
 
    LLVMValueRef voffset =
       LLVMBuildMul(ctx.ac.builder, ctx.abi.vertex_id, LLVMConstInt(ctx.ac.i32, 4, 0), "");
diff --git a/src/gallium/drivers/radeonsi/si_shader_llvm_ps.c b/src/gallium/drivers/radeonsi/si_shader_llvm_ps.c
index 9277124096a9..c7660a3caa03 100644
--- a/src/gallium/drivers/radeonsi/si_shader_llvm_ps.c
+++ b/src/gallium/drivers/radeonsi/si_shader_llvm_ps.c
@@ -37,7 +37,7 @@ static LLVMValueRef load_sample_position(struct ac_shader_abi *abi, LLVMValueRef
    LLVMValueRef desc = ac_get_arg(&ctx->ac, ctx->internal_bindings);
    LLVMValueRef buf_index = LLVMConstInt(ctx->ac.i32, SI_PS_CONST_SAMPLE_POSITIONS, 0);
    LLVMTypeRef type = ac_get_arg_pointee_type(&ctx->ac, &ctx->args, ctx->internal_bindings);
-   LLVMValueRef resource = ac_build_load_to_sgpr2(&ctx->ac, type, desc, buf_index);
+   LLVMValueRef resource = ac_build_load_to_sgpr(&ctx->ac, type, desc, buf_index);
 
    /* offset = sample_id * 8  (8 = 2 floats containing samplepos.xy) */
    LLVMValueRef offset0 =
@@ -70,7 +70,7 @@ static LLVMValueRef si_nir_emit_fbfetch(struct ac_shader_abi *abi)
    ptr =
       LLVMBuildPointerCast(ctx->ac.builder, ptr, ac_array_in_const32_addr_space(ctx->ac.v8i32), "");
    image =
-      ac_build_load_to_sgpr2(&ctx->ac, ctx->ac.v8i32, ptr, LLVMConstInt(ctx->ac.i32, SI_PS_IMAGE_COLORBUF0 / 2, 0));
+      ac_build_load_to_sgpr(&ctx->ac, ctx->ac.v8i32, ptr, LLVMConstInt(ctx->ac.i32, SI_PS_IMAGE_COLORBUF0 / 2, 0));
 
    unsigned chan = 0;
 
@@ -90,7 +90,7 @@ static LLVMValueRef si_nir_emit_fbfetch(struct ac_shader_abi *abi)
        ctx->shader->key.ps.mono.fbfetch_msaa &&
        !(ctx->screen->debug_flags & DBG(NO_FMASK))) {
 
-      fmask = ac_build_load_to_sgpr2(&ctx->ac, ctx->ac.v8i32, ptr,
+      fmask = ac_build_load_to_sgpr(&ctx->ac, ctx->ac.v8i32, ptr,
                                     LLVMConstInt(ctx->ac.i32, SI_PS_IMAGE_COLORBUF0_FMASK / 2, 0));
 
       ac_apply_fmask_to_sample(&ctx->ac, fmask, args.coords,
@@ -550,7 +550,7 @@ static void si_llvm_emit_polygon_stipple(struct si_shader_context *ctx,
    /* Load the buffer descriptor. */
    slot = LLVMConstInt(ctx->ac.i32, SI_PS_CONST_POLY_STIPPLE, 0);
 
-   desc = ac_build_load_to_sgpr2(&ctx->ac, ctx->ac.v4i32, param_internal_bindings, slot);
+   desc = ac_build_load_to_sgpr(&ctx->ac, ctx->ac.v4i32, param_internal_bindings, slot);
 
    /* The stipple pattern is 32x32, each row has 32 bits. */
    offset = LLVMBuildMul(builder, address[1], LLVMConstInt(ctx->ac.i32, 4, 0), "");
diff --git a/src/gallium/drivers/radeonsi/si_shader_llvm_resources.c b/src/gallium/drivers/radeonsi/si_shader_llvm_resources.c
index bac1143d4828..23ce4f0e5c03 100644
--- a/src/gallium/drivers/radeonsi/si_shader_llvm_resources.c
+++ b/src/gallium/drivers/radeonsi/si_shader_llvm_resources.c
@@ -104,10 +104,10 @@ static LLVMValueRef load_ubo(struct ac_shader_abi *abi, LLVMValueRef index)
    index =
       LLVMBuildAdd(ctx->ac.builder, index, LLVMConstInt(ctx->ac.i32, SI_NUM_SHADER_BUFFERS, 0), "");
 
-   return ac_build_load_to_sgpr2(&ctx->ac,
-                                 ac_get_arg_pointee_type(&ctx->ac, &ctx->args, ctx->const_and_shader_buffers),
-                                 ptr,
-                                 index);
+   return ac_build_load_to_sgpr(&ctx->ac,
+                                ac_get_arg_pointee_type(&ctx->ac, &ctx->args, ctx->const_and_shader_buffers),
+                                ptr,
+                                index);
 }
 
 static LLVMValueRef load_ssbo(struct ac_shader_abi *abi, LLVMValueRef index, bool write, bool non_uniform)
@@ -124,9 +124,9 @@ static LLVMValueRef load_ssbo(struct ac_shader_abi *abi, LLVMValueRef index, boo
    index = LLVMBuildSub(ctx->ac.builder, LLVMConstInt(ctx->ac.i32, SI_NUM_SHADER_BUFFERS - 1, 0),
                         index, "");
 
-   return ac_build_load_to_sgpr2(&ctx->ac,
-                                 ac_get_arg_pointee_type(&ctx->ac, &ctx->args, ctx->const_and_shader_buffers),
-                                 rsrc_ptr, index);
+   return ac_build_load_to_sgpr(&ctx->ac,
+                                ac_get_arg_pointee_type(&ctx->ac, &ctx->args, ctx->const_and_shader_buffers),
+                                rsrc_ptr, index);
 }
 
 /**
@@ -197,9 +197,9 @@ static LLVMValueRef si_load_image_desc(struct si_shader_context *ctx, LLVMTypeRe
    }
 
    if (bindless)
-      rsrc = ac_build_load_to_sgpr_uint_wraparound2(&ctx->ac, type, list, index);
+      rsrc = ac_build_load_to_sgpr_uint_wraparound(&ctx->ac, type, list, index);
    else
-      rsrc = ac_build_load_to_sgpr2(&ctx->ac, type, list, index);
+      rsrc = ac_build_load_to_sgpr(&ctx->ac, type, list, index);
 
    if (desc_type == AC_DESC_IMAGE)
       rsrc = fixup_image_desc(ctx, rsrc, uses_store);
@@ -248,7 +248,7 @@ static LLVMValueRef si_load_sampler_desc(struct si_shader_context *ctx, LLVMType
       unreachable("Plane descriptor requested in radeonsi.");
    }
 
-   return ac_build_load_to_sgpr2(&ctx->ac, list_type, list, index);
+   return ac_build_load_to_sgpr(&ctx->ac, list_type, list, index);
 }
 
 static LLVMValueRef si_nir_load_sampler_desc(struct ac_shader_abi *abi, unsigned descriptor_set,
diff --git a/src/gallium/drivers/radeonsi/si_shader_llvm_vs.c b/src/gallium/drivers/radeonsi/si_shader_llvm_vs.c
index f9ddea92c992..d11ad9ffef66 100644
--- a/src/gallium/drivers/radeonsi/si_shader_llvm_vs.c
+++ b/src/gallium/drivers/radeonsi/si_shader_llvm_vs.c
@@ -169,8 +169,8 @@ static void load_input_vs(struct si_shader_context *ctx, unsigned input_index, L
    } else {
       unsigned index = input_index - num_vbos_in_user_sgprs;
       LLVMTypeRef type = ac_get_arg_pointee_type(&ctx->ac, &ctx->args, ctx->args.vertex_buffers);
-      vb_desc = ac_build_load_to_sgpr2(&ctx->ac, type, ac_get_arg(&ctx->ac, ctx->args.vertex_buffers),
-                                       LLVMConstInt(ctx->ac.i32, index, 0));
+      vb_desc = ac_build_load_to_sgpr(&ctx->ac, type, ac_get_arg(&ctx->ac, ctx->args.vertex_buffers),
+                                      LLVMConstInt(ctx->ac.i32, index, 0));
    }
 
    if (ctx->abi.vertex_id_replaced) {
@@ -418,7 +418,7 @@ void si_llvm_emit_streamout(struct si_shader_context *ctx, struct si_shader_outp
 
          LLVMValueRef offset = LLVMConstInt(ctx->ac.i32, SI_VS_STREAMOUT_BUF0 + i, 0);
 
-         so_buffers[i] = ac_build_load_to_sgpr2(&ctx->ac, type, buf_ptr, offset);
+         so_buffers[i] = ac_build_load_to_sgpr(&ctx->ac, type, buf_ptr, offset);
 
          LLVMValueRef so_offset = ac_get_arg(&ctx->ac, ctx->args.streamout_offset[i]);
          so_offset = LLVMBuildMul(builder, so_offset, LLVMConstInt(ctx->ac.i32, 4, 0), "");
@@ -454,7 +454,7 @@ void si_llvm_clipvertex_to_clipdist(struct si_shader_context *ctx,
    LLVMValueRef ptr = ac_get_arg(&ctx->ac, ctx->internal_bindings);
    LLVMTypeRef type = ac_get_arg_pointee_type(&ctx->ac, &ctx->args, ctx->internal_bindings);
    LLVMValueRef constbuf_index = LLVMConstInt(ctx->ac.i32, SI_VS_CONST_CLIP_PLANES, 0);
-   LLVMValueRef const_resource = ac_build_load_to_sgpr2(&ctx->ac, type, ptr, constbuf_index);
+   LLVMValueRef const_resource = ac_build_load_to_sgpr(&ctx->ac, type, ptr, constbuf_index);
    unsigned clipdist_mask = ctx->shader->selector->info.clipdist_mask &
                             ~ctx->shader->key.ge.opt.kill_clip_distances;
 
@@ -819,8 +819,8 @@ void si_llvm_build_vs_exports(struct si_shader_context *ctx, LLVMValueRef num_ex
             LLVMBuildPointerCast(ctx->ac.builder,
                                  ac_get_arg(&ctx->ac, ctx->internal_bindings),
                                  LLVMPointerType(ctx->ac.i32, AC_ADDR_SPACE_CONST_32BIT), "");
-         attr_address = ac_build_load_to_sgpr2(&ctx->ac, ctx->ac.i32, ptr,
-                                               LLVMConstInt(ctx->ac.i32, SI_GS_ATTRIBUTE_RING * 4, 0));
+         attr_address = ac_build_load_to_sgpr(&ctx->ac, ctx->ac.i32, ptr,
+                                              LLVMConstInt(ctx->ac.i32, SI_GS_ATTRIBUTE_RING * 4, 0));
       } else {
          attr_address = ac_get_arg(&ctx->ac, ctx->gs_attr_address);
       }
@@ -1039,7 +1039,7 @@ void si_llvm_build_vs_prolog(struct si_shader_context *ctx, union si_shader_part
    if (key->vs_prolog.states.instance_divisor_is_fetched) {
       LLVMValueRef list = si_prolog_get_internal_bindings(ctx);
       LLVMValueRef buf_index = LLVMConstInt(ctx->ac.i32, SI_VS_CONST_INSTANCE_DIVISORS, 0);
-      instance_divisor_constbuf = ac_build_load_to_sgpr2(&ctx->ac, ctx->ac.v4i32, list, buf_index);
+      instance_divisor_constbuf = ac_build_load_to_sgpr(&ctx->ac, ctx->ac.v4i32, list, buf_index);
    }
 
    for (i = 0; i < key->vs_prolog.num_inputs; i++) {
-- 
GitLab


From 33f75b5052e457cd35d7de12f607063b2d6f6922 Mon Sep 17 00:00:00 2001
From: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
Date: Tue, 11 Oct 2022 10:48:01 +0200
Subject: [PATCH 23/26] radv/llvm: replace LLVMBuildLoad by LLVMBuildLoad2
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Reviewed-by: Mihai Preda <mhpreda@gmail.com>
Reviewed-by: Dave Airlie <airlied@redhat.com>
Reviewed-by: Qiang Yu <yuq825@gmail.com>
Reviewed-by: Marek Olšák <marek.olsak@amd.com>
Acked-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
---
 src/amd/vulkan/radv_nir_to_llvm.c | 12 ++++++++----
 1 file changed, 8 insertions(+), 4 deletions(-)

diff --git a/src/amd/vulkan/radv_nir_to_llvm.c b/src/amd/vulkan/radv_nir_to_llvm.c
index 46c1f8646cd3..95d0cebd903b 100644
--- a/src/amd/vulkan/radv_nir_to_llvm.c
+++ b/src/amd/vulkan/radv_nir_to_llvm.c
@@ -202,6 +202,7 @@ visit_emit_vertex_with_counter(struct ac_shader_abi *abi, unsigned stream, LLVMV
       unsigned output_usage_mask = ctx->shader_info->gs.output_usage_mask[i];
       uint8_t output_stream = ctx->shader_info->gs.output_streams[i];
       LLVMValueRef *out_ptr = &addrs[i * 4];
+      bool *is_16bit_ptr = &abi->is_16bit[i * 4];
       int length = util_last_bit(output_usage_mask);
 
       if (!(ctx->output_mask & (1ull << i)) || output_stream != stream)
@@ -211,7 +212,8 @@ visit_emit_vertex_with_counter(struct ac_shader_abi *abi, unsigned stream, LLVMV
          if (!(output_usage_mask & (1 << j)))
             continue;
 
-         LLVMValueRef out_val = LLVMBuildLoad(ctx->ac.builder, out_ptr[j], "");
+         LLVMTypeRef type = is_16bit_ptr[j] ? ctx->ac.f16 : ctx->ac.f32;
+         LLVMValueRef out_val = LLVMBuildLoad2(ctx->ac.builder, type, out_ptr[j], "");
          LLVMValueRef voffset =
             LLVMConstInt(ctx->ac.i32, offset * ctx->shader->info.gs.vertices_out, false);
 
@@ -258,7 +260,7 @@ radv_load_rsrc(struct radv_shader_context *ctx, LLVMValueRef ptr, LLVMTypeRef ty
       ptr = LLVMBuildIntToPtr(ctx->ac.builder, ptr, ptr_type, "");
       LLVMSetMetadata(ptr, ctx->ac.uniform_md_kind, ctx->ac.empty_md);
 
-      result = LLVMBuildLoad(ctx->ac.builder, ptr, "");
+      result = LLVMBuildLoad2(ctx->ac.builder, type, ptr, "");
       LLVMSetMetadata(result, ctx->ac.invariant_load_md_kind, ctx->ac.empty_md);
 
       return result;
@@ -711,8 +713,10 @@ radv_export_param(struct radv_shader_context *ctx, unsigned index, LLVMValueRef
 static LLVMValueRef
 radv_load_output(struct radv_shader_context *ctx, unsigned index, unsigned chan)
 {
-   LLVMValueRef output = ctx->abi.outputs[ac_llvm_reg_index_soa(index, chan)];
-   return LLVMBuildLoad(ctx->ac.builder, output, "");
+   int idx = ac_llvm_reg_index_soa(index, chan);
+   LLVMValueRef output = ctx->abi.outputs[idx];
+   LLVMTypeRef type = ctx->abi.is_16bit[idx] ? ctx->ac.f16 : ctx->ac.f32;
+   return LLVMBuildLoad2(ctx->ac.builder, type, output, "");
 }
 
 static void
-- 
GitLab


From 42c72fb50dd3a1213fe05003b1bf2fdf68fd5d9a Mon Sep 17 00:00:00 2001
From: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
Date: Fri, 14 Oct 2022 15:08:12 +0200
Subject: [PATCH 24/26] ac/llvm: add ac_get_ptr_arg
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

For argument of type AC_AR_..._PTR, this returns a ac_llvm_pointer.

Reviewed-by: Qiang Yu <yuq825@gmail.com>
Reviewed-by: Marek Olšák <marek.olsak@amd.com>
Acked-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
---
 src/amd/llvm/ac_llvm_build.h | 9 ++++++---
 1 file changed, 6 insertions(+), 3 deletions(-)

diff --git a/src/amd/llvm/ac_llvm_build.h b/src/amd/llvm/ac_llvm_build.h
index 776faedaa920..6055a7d494a6 100644
--- a/src/amd/llvm/ac_llvm_build.h
+++ b/src/amd/llvm/ac_llvm_build.h
@@ -601,10 +601,13 @@ static inline LLVMValueRef ac_get_arg(struct ac_llvm_context *ctx, struct ac_arg
    return LLVMGetParam(ctx->main_function.value, arg.arg_index);
 }
 
-static inline LLVMTypeRef ac_get_arg_pointee_type(struct ac_llvm_context *ctx, const struct ac_shader_args *args, struct ac_arg arg)
+static inline struct ac_llvm_pointer
+ac_get_ptr_arg(struct ac_llvm_context *ctx, const struct ac_shader_args *args, struct ac_arg arg)
 {
-   assert(arg.used);
-   return ac_arg_type_to_pointee_type(ctx, args->args[arg.arg_index].type);
+   struct ac_llvm_pointer ptr;
+   ptr.pointee_type = ac_arg_type_to_pointee_type(ctx, args->args[arg.arg_index].type);
+   ptr.value = LLVMGetParam(ctx->main_function.value, arg.arg_index);
+   return ptr;
 }
 
 enum ac_llvm_calling_convention
-- 
GitLab


From 311e725a22b0ae708f9372ac5d21693c5cfa9b7b Mon Sep 17 00:00:00 2001
From: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
Date: Thu, 13 Oct 2022 11:40:52 +0200
Subject: [PATCH 25/26] ac/llvm: pass ac_llvm_ptr instead of separate type/ptr
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

This simplifies the API.

Reviewed-by: Qiang Yu <yuq825@gmail.com>
Reviewed-by: Marek Olšák <marek.olsak@amd.com>
Acked-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
---
 src/amd/llvm/ac_llvm_build.c                  | 29 +++---
 src/amd/llvm/ac_llvm_build.h                  | 14 +--
 src/amd/llvm/ac_nir_to_llvm.c                 | 14 +--
 src/amd/vulkan/radv_nir_to_llvm.c             | 28 +++---
 .../drivers/radeonsi/gfx10_shader_ngg.c       | 92 +++++++++----------
 src/gallium/drivers/radeonsi/si_shader_llvm.c | 27 +++---
 .../drivers/radeonsi/si_shader_llvm_gs.c      | 20 ++--
 .../drivers/radeonsi/si_shader_llvm_ps.c      | 15 ++-
 .../radeonsi/si_shader_llvm_resources.c       | 47 ++++------
 .../drivers/radeonsi/si_shader_llvm_vs.c      | 27 +++---
 10 files changed, 138 insertions(+), 175 deletions(-)

diff --git a/src/amd/llvm/ac_llvm_build.c b/src/amd/llvm/ac_llvm_build.c
index a5b145397b11..3cc556e71041 100644
--- a/src/amd/llvm/ac_llvm_build.c
+++ b/src/amd/llvm/ac_llvm_build.c
@@ -1112,14 +1112,14 @@ LLVMTypeRef ac_build_gep0_type(LLVMTypeRef pointee_type, LLVMValueRef index)
    return NULL;
 }
 
-LLVMValueRef ac_build_gep0(struct ac_llvm_context *ctx, LLVMTypeRef pointee_type, LLVMValueRef value, LLVMValueRef index)
+LLVMValueRef ac_build_gep0(struct ac_llvm_context *ctx, struct ac_llvm_pointer ptr, LLVMValueRef index)
 {
    LLVMValueRef indices[2] = {
       ctx->i32_0,
       index,
    };
 
-   return LLVMBuildGEP2(ctx->builder, pointee_type, value, indices, 2, "");
+   return LLVMBuildGEP2(ctx->builder, ptr.t, ptr.v, indices, 2, "");
 }
 
 LLVMValueRef ac_build_pointer_add(struct ac_llvm_context *ctx, LLVMTypeRef type, LLVMValueRef ptr, LLVMValueRef index)
@@ -1127,10 +1127,10 @@ LLVMValueRef ac_build_pointer_add(struct ac_llvm_context *ctx, LLVMTypeRef type,
    return LLVMBuildGEP2(ctx->builder, type, ptr, &index, 1, "");
 }
 
-void ac_build_indexed_store(struct ac_llvm_context *ctx, LLVMTypeRef type, LLVMValueRef base_ptr, LLVMValueRef index,
+void ac_build_indexed_store(struct ac_llvm_context *ctx, struct ac_llvm_pointer ptr, LLVMValueRef index,
                             LLVMValueRef value)
 {
-   LLVMBuildStore(ctx->builder, value, ac_build_gep0(ctx, type, base_ptr, index));
+   LLVMBuildStore(ctx->builder, value, ac_build_gep0(ctx, ptr, index));
 }
 
 /**
@@ -1182,30 +1182,29 @@ static LLVMValueRef ac_build_load_custom(struct ac_llvm_context *ctx, LLVMTypeRe
    return result;
 }
 
-LLVMValueRef ac_build_load(struct ac_llvm_context *ctx, LLVMTypeRef type, LLVMValueRef base_ptr, LLVMValueRef index)
+LLVMValueRef ac_build_load(struct ac_llvm_context *ctx, struct ac_llvm_pointer ptr, LLVMValueRef index)
 {
-   return ac_build_load_custom(ctx, type, base_ptr, index, false, false, false);
+   return ac_build_load_custom(ctx, ptr.t, ptr.v, index, false, false, false);
 }
 
-LLVMValueRef ac_build_load_invariant(struct ac_llvm_context *ctx, LLVMTypeRef type, LLVMValueRef base_ptr,
+LLVMValueRef ac_build_load_invariant(struct ac_llvm_context *ctx, struct ac_llvm_pointer ptr,
                                      LLVMValueRef index)
 {
-   return ac_build_load_custom(ctx, type, base_ptr, index, false, true, false);
+   return ac_build_load_custom(ctx, ptr.t, ptr.v, index, false, true, false);
 }
 
 /* This assumes that there is no unsigned integer wraparound during the address
  * computation, excluding all GEPs within base_ptr. */
-LLVMValueRef ac_build_load_to_sgpr(struct ac_llvm_context *ctx, LLVMTypeRef type, LLVMValueRef base_ptr,
+LLVMValueRef ac_build_load_to_sgpr(struct ac_llvm_context *ctx, struct ac_llvm_pointer ptr,
                                    LLVMValueRef index)
 {
-   return ac_build_load_custom(ctx, type, base_ptr, index, true, true, true);
+   return ac_build_load_custom(ctx, ptr.t, ptr.v, index, true, true, true);
 }
 
 /* See ac_build_load_custom() documentation. */
-LLVMValueRef ac_build_load_to_sgpr_uint_wraparound(struct ac_llvm_context *ctx, LLVMTypeRef type,
-                                                   LLVMValueRef base_ptr, LLVMValueRef index)
+LLVMValueRef ac_build_load_to_sgpr_uint_wraparound(struct ac_llvm_context *ctx, struct ac_llvm_pointer ptr, LLVMValueRef index)
 {
-   return ac_build_load_custom(ctx, type, base_ptr, index, true, true, false);
+   return ac_build_load_custom(ctx, ptr.t, ptr.v, index, true, true, false);
 }
 
 static unsigned get_load_cache_policy(struct ac_llvm_context *ctx, unsigned cache_policy)
@@ -2783,14 +2782,14 @@ void ac_declare_lds_as_pointer(struct ac_llvm_context *ctx)
 
 LLVMValueRef ac_lds_load(struct ac_llvm_context *ctx, LLVMValueRef dw_addr)
 {
-   LLVMValueRef v = ac_build_gep0(ctx, ctx->lds.t, ctx->lds.v, dw_addr);
+   LLVMValueRef v = ac_build_gep0(ctx, ctx->lds, dw_addr);
    return LLVMBuildLoad2(ctx->builder, ctx->i32, v, "");
 }
 
 void ac_lds_store(struct ac_llvm_context *ctx, LLVMValueRef dw_addr, LLVMValueRef value)
 {
    value = ac_to_integer(ctx, value);
-   ac_build_indexed_store(ctx, ctx->lds.t, ctx->lds.v, dw_addr, value);
+   ac_build_indexed_store(ctx, ctx->lds, dw_addr, value);
 }
 
 LLVMValueRef ac_find_lsb(struct ac_llvm_context *ctx, LLVMTypeRef dst_type, LLVMValueRef src0)
diff --git a/src/amd/llvm/ac_llvm_build.h b/src/amd/llvm/ac_llvm_build.h
index 6055a7d494a6..d3f2ea99a2ce 100644
--- a/src/amd/llvm/ac_llvm_build.h
+++ b/src/amd/llvm/ac_llvm_build.h
@@ -258,19 +258,19 @@ LLVMValueRef ac_build_pointer_add(struct ac_llvm_context *ctx, LLVMTypeRef type,
                                   LLVMValueRef index);
 
 LLVMTypeRef ac_build_gep0_type(LLVMTypeRef pointee_type, LLVMValueRef index);
-LLVMValueRef ac_build_gep0(struct ac_llvm_context *ctx, LLVMTypeRef type, LLVMValueRef value, LLVMValueRef index);
+LLVMValueRef ac_build_gep0(struct ac_llvm_context *ctx, struct ac_llvm_pointer ptr, LLVMValueRef index);
 
-void ac_build_indexed_store(struct ac_llvm_context *ctx, LLVMTypeRef type, LLVMValueRef base_ptr, LLVMValueRef index,
+void ac_build_indexed_store(struct ac_llvm_context *ctx, struct ac_llvm_pointer ptr, LLVMValueRef index,
                             LLVMValueRef value);
 
-LLVMValueRef ac_build_load(struct ac_llvm_context *ctx, LLVMTypeRef type, LLVMValueRef base_ptr, LLVMValueRef index);
-LLVMValueRef ac_build_load_invariant(struct ac_llvm_context *ctx, LLVMTypeRef type, LLVMValueRef base_ptr,
+LLVMValueRef ac_build_load(struct ac_llvm_context *ctx, struct ac_llvm_pointer ptr, LLVMValueRef index);
+LLVMValueRef ac_build_load_invariant(struct ac_llvm_context *ctx, struct ac_llvm_pointer ptr,
                                      LLVMValueRef index);
-LLVMValueRef ac_build_load_to_sgpr(struct ac_llvm_context *ctx, LLVMTypeRef type, LLVMValueRef base_ptr,
+LLVMValueRef ac_build_load_to_sgpr(struct ac_llvm_context *ctx, struct ac_llvm_pointer ptr,
                                    LLVMValueRef index);
 
-LLVMValueRef ac_build_load_to_sgpr_uint_wraparound(struct ac_llvm_context *ctx, LLVMTypeRef type,
-                                                   LLVMValueRef base_ptr, LLVMValueRef index);
+LLVMValueRef ac_build_load_to_sgpr_uint_wraparound(struct ac_llvm_context *ctx, struct ac_llvm_pointer ptr,
+                                                   LLVMValueRef index);
 
 void ac_build_buffer_store_dword(struct ac_llvm_context *ctx, LLVMValueRef rsrc, LLVMValueRef vdata,
                                  LLVMValueRef vindex, LLVMValueRef voffset, LLVMValueRef soffset,
diff --git a/src/amd/llvm/ac_nir_to_llvm.c b/src/amd/llvm/ac_nir_to_llvm.c
index 47f944bafd8e..8d9c79cf6262 100644
--- a/src/amd/llvm/ac_nir_to_llvm.c
+++ b/src/amd/llvm/ac_nir_to_llvm.c
@@ -1667,8 +1667,8 @@ static LLVMValueRef visit_load_push_constant(struct ac_nir_context *ctx, nir_int
       }
    }
 
-   LLVMTypeRef type = ac_get_arg_pointee_type(&ctx->ac, ctx->args, ctx->args->push_constants);
-   ptr = LLVMBuildGEP2(ctx->ac.builder, type, ac_get_arg(&ctx->ac, ctx->args->push_constants), &addr, 1, "");
+   struct ac_llvm_pointer pc = ac_get_ptr_arg(&ctx->ac, ctx->args, ctx->args->push_constants);
+   ptr = LLVMBuildGEP2(ctx->ac.builder, pc.t, pc.v, &addr, 1, "");
 
    if (instr->dest.ssa.bit_size == 8) {
       unsigned load_dwords = instr->dest.ssa.num_components > 1 ? 2 : 1;
@@ -3716,8 +3716,8 @@ static bool visit_intrinsic(struct ac_nir_context *ctx, nir_intrinsic_instr *ins
       if (ctx->abi->load_grid_size_from_user_sgpr) {
          result = ac_get_arg(&ctx->ac, ctx->args->num_work_groups);
       } else {
-         LLVMValueRef ptr = ac_get_arg(&ctx->ac, ctx->args->num_work_groups);
-         result = ac_build_load_invariant(&ctx->ac, ctx->ac.v3i32, ptr, ctx->ac.i32_0);
+         result = ac_build_load_invariant(&ctx->ac,
+            ac_get_ptr_arg(&ctx->ac, ctx->args, ctx->args->num_work_groups), ctx->ac.i32_0);
       }
       if (nir_dest_bit_size(instr->dest) == 64)
          result = LLVMBuildZExt(ctx->ac.builder, result, LLVMVectorType(ctx->ac.i64, 3), "");
@@ -4114,7 +4114,7 @@ static bool visit_intrinsic(struct ac_nir_context *ctx, nir_intrinsic_instr *ins
       break;
    case nir_intrinsic_load_scratch: {
       LLVMValueRef offset = get_src(ctx, instr->src[0]);
-      LLVMValueRef ptr = ac_build_gep0(&ctx->ac, ctx->scratch.t, ctx->scratch.v, offset);
+      LLVMValueRef ptr = ac_build_gep0(&ctx->ac, ctx->scratch, offset);
       LLVMTypeRef comp_type = LLVMIntTypeInContext(ctx->ac.context, instr->dest.ssa.bit_size);
       LLVMTypeRef vec_type = instr->dest.ssa.num_components == 1
                                 ? comp_type
@@ -4124,7 +4124,7 @@ static bool visit_intrinsic(struct ac_nir_context *ctx, nir_intrinsic_instr *ins
    }
    case nir_intrinsic_store_scratch: {
       LLVMValueRef offset = get_src(ctx, instr->src[1]);
-      LLVMValueRef ptr = ac_build_gep0(&ctx->ac, ctx->scratch.t, ctx->scratch.v, offset);
+      LLVMValueRef ptr = ac_build_gep0(&ctx->ac, ctx->scratch, offset);
       LLVMTypeRef comp_type = LLVMIntTypeInContext(ctx->ac.context, instr->src[0].ssa->bit_size);
       LLVMValueRef src = get_src(ctx, instr->src[0]);
       unsigned wrmask = nir_intrinsic_write_mask(instr);
@@ -4153,7 +4153,7 @@ static bool visit_intrinsic(struct ac_nir_context *ctx, nir_intrinsic_instr *ins
       LLVMValueRef cond = LLVMBuildICmp(ctx->ac.builder, LLVMIntULT, offset, size, "");
       offset = LLVMBuildSelect(ctx->ac.builder, cond, offset, size, "");
 
-      LLVMValueRef ptr = ac_build_gep0(&ctx->ac, ctx->constant_data.t, ctx->constant_data.v, offset);
+      LLVMValueRef ptr = ac_build_gep0(&ctx->ac, ctx->constant_data, offset);
       LLVMTypeRef comp_type = LLVMIntTypeInContext(ctx->ac.context, instr->dest.ssa.bit_size);
       LLVMTypeRef vec_type = instr->dest.ssa.num_components == 1
                                 ? comp_type
diff --git a/src/amd/vulkan/radv_nir_to_llvm.c b/src/amd/vulkan/radv_nir_to_llvm.c
index 95d0cebd903b..47ae7128529d 100644
--- a/src/amd/vulkan/radv_nir_to_llvm.c
+++ b/src/amd/vulkan/radv_nir_to_llvm.c
@@ -108,13 +108,12 @@ load_descriptor_sets(struct radv_shader_context *ctx)
    uint32_t mask = ctx->shader_info->desc_set_used_mask;
 
    if (user_sgprs_locs->shader_data[AC_UD_INDIRECT_DESCRIPTOR_SETS].sgpr_idx != -1) {
-      LLVMTypeRef type = ac_get_arg_pointee_type(&ctx->ac, &ctx->args->ac, ctx->args->descriptor_sets[0]);
-      LLVMValueRef desc_sets = ac_get_arg(&ctx->ac, ctx->args->descriptor_sets[0]);
+      struct ac_llvm_pointer desc_sets = ac_get_ptr_arg(&ctx->ac, &ctx->args->ac, ctx->args->descriptor_sets[0]);
       while (mask) {
          int i = u_bit_scan(&mask);
 
          ctx->descriptor_sets[i] =
-            ac_build_load_to_sgpr(&ctx->ac, type, desc_sets, LLVMConstInt(ctx->ac.i32, i, false));
+            ac_build_load_to_sgpr(&ctx->ac, desc_sets, LLVMConstInt(ctx->ac.i32, i, false));
          LLVMSetAlignment(ctx->descriptor_sets[i], 4);
       }
    } else {
@@ -350,8 +349,7 @@ static void
 load_vs_input(struct radv_shader_context *ctx, unsigned driver_location, LLVMTypeRef dest_type,
               LLVMValueRef out[4])
 {
-   LLVMTypeRef t_list_type = ac_get_arg_pointee_type(&ctx->ac, &ctx->args->ac, ctx->args->ac.vertex_buffers);
-   LLVMValueRef t_list_ptr = ac_get_arg(&ctx->ac, ctx->args->ac.vertex_buffers);
+   struct ac_llvm_pointer t_list_ptr = ac_get_ptr_arg(&ctx->ac, &ctx->args->ac, ctx->args->ac.vertex_buffers);
    LLVMValueRef t_offset;
    LLVMValueRef t_list;
    LLVMValueRef input;
@@ -402,7 +400,7 @@ load_vs_input(struct radv_shader_context *ctx, unsigned driver_location, LLVMTyp
    desc_index = util_bitcount(ctx->shader_info->vs.vb_desc_usage_mask &
                               u_bit_consecutive(0, desc_index));
    t_offset = LLVMConstInt(ctx->ac.i32, desc_index, false);
-   t_list = ac_build_load_to_sgpr(&ctx->ac, t_list_type, t_list_ptr, t_offset);
+   t_list = ac_build_load_to_sgpr(&ctx->ac, t_list_ptr, t_offset);
 
    /* Always split typed vertex buffer loads on GFX6 and GFX10+ to avoid any alignment issues that
     * triggers memory violations and eventually a GPU hang. This can happen if the stride (static or
@@ -800,8 +798,7 @@ radv_emit_streamout(struct radv_shader_context *ctx, unsigned stream)
        */
       LLVMValueRef so_write_offset[4] = {0};
       LLVMValueRef so_buffers[4] = {0};
-      LLVMTypeRef type = ac_get_arg_pointee_type(&ctx->ac, &ctx->args->ac, ctx->args->streamout_buffers);
-      LLVMValueRef buf_ptr = ac_get_arg(&ctx->ac, ctx->args->streamout_buffers);
+      struct ac_llvm_pointer buf_ptr = ac_get_ptr_arg(&ctx->ac, &ctx->args->ac, ctx->args->streamout_buffers);
 
       for (i = 0; i < 4; i++) {
          uint16_t stride = ctx->shader_info->so.strides[i];
@@ -811,7 +808,7 @@ radv_emit_streamout(struct radv_shader_context *ctx, unsigned stream)
 
          LLVMValueRef offset = LLVMConstInt(ctx->ac.i32, i, false);
 
-         so_buffers[i] = ac_build_load_to_sgpr(&ctx->ac, type, buf_ptr, offset);
+         so_buffers[i] = ac_build_load_to_sgpr(&ctx->ac, buf_ptr, offset);
 
          LLVMValueRef so_offset = ac_get_arg(&ctx->ac, ctx->args->ac.streamout_offset[i]);
 
@@ -1178,6 +1175,8 @@ radv_llvm_visit_export_vertex(struct ac_shader_abi *abi)
 static void
 ac_setup_rings(struct radv_shader_context *ctx)
 {
+   struct ac_llvm_pointer ring_offsets = { .t = ctx->ac.i8, .v = ctx->ring_offsets };
+
    if (ctx->options->gfx_level <= GFX8 &&
        (ctx->stage == MESA_SHADER_GEOMETRY ||
         (ctx->stage == MESA_SHADER_VERTEX && ctx->shader_info->vs.as_es) ||
@@ -1185,12 +1184,11 @@ ac_setup_rings(struct radv_shader_context *ctx)
       unsigned ring = ctx->stage == MESA_SHADER_GEOMETRY ? RING_ESGS_GS : RING_ESGS_VS;
       LLVMValueRef offset = LLVMConstInt(ctx->ac.i32, ring, false);
 
-      ctx->esgs_ring = ac_build_load_to_sgpr(&ctx->ac, ctx->ac.i8, ctx->ring_offsets, offset);
+      ctx->esgs_ring = ac_build_load_to_sgpr(&ctx->ac, ring_offsets, offset);
    }
 
    if (ctx->args->is_gs_copy_shader) {
-      ctx->gsvs_ring[0] = ac_build_load_to_sgpr(&ctx->ac, ctx->ac.i8, ctx->ring_offsets,
-                                                LLVMConstInt(ctx->ac.i32, RING_GSVS_VS, false));
+      ctx->gsvs_ring[0] = ac_build_load_to_sgpr(&ctx->ac, ring_offsets, LLVMConstInt(ctx->ac.i32, RING_GSVS_VS, false));
    }
 
    if (ctx->stage == MESA_SHADER_GEOMETRY) {
@@ -1207,7 +1205,7 @@ ac_setup_rings(struct radv_shader_context *ctx)
       unsigned num_records = ctx->ac.wave_size;
       LLVMValueRef base_ring;
 
-      base_ring = ac_build_load_to_sgpr(&ctx->ac, ctx->ac.i8, ctx->ring_offsets,
+      base_ring = ac_build_load_to_sgpr(&ctx->ac, ring_offsets,
                                         LLVMConstInt(ctx->ac.i32, RING_GSVS_GS, false));
 
       for (unsigned stream = 0; stream < 4; stream++) {
@@ -1248,9 +1246,9 @@ ac_setup_rings(struct radv_shader_context *ctx)
 
    if (ctx->stage == MESA_SHADER_TESS_CTRL || ctx->stage == MESA_SHADER_TESS_EVAL) {
       ctx->hs_ring_tess_offchip = ac_build_load_to_sgpr(
-         &ctx->ac, ctx->ac.i8, ctx->ring_offsets, LLVMConstInt(ctx->ac.i32, RING_HS_TESS_OFFCHIP, false));
+         &ctx->ac, ring_offsets, LLVMConstInt(ctx->ac.i32, RING_HS_TESS_OFFCHIP, false));
       ctx->hs_ring_tess_factor = ac_build_load_to_sgpr(
-         &ctx->ac, ctx->ac.i8, ctx->ring_offsets, LLVMConstInt(ctx->ac.i32, RING_HS_TESS_FACTOR, false));
+         &ctx->ac, ring_offsets, LLVMConstInt(ctx->ac.i32, RING_HS_TESS_FACTOR, false));
    }
 }
 
diff --git a/src/gallium/drivers/radeonsi/gfx10_shader_ngg.c b/src/gallium/drivers/radeonsi/gfx10_shader_ngg.c
index 27b907cdd557..004d9ede6261 100644
--- a/src/gallium/drivers/radeonsi/gfx10_shader_ngg.c
+++ b/src/gallium/drivers/radeonsi/gfx10_shader_ngg.c
@@ -65,18 +65,13 @@ static LLVMValueRef ngg_get_ordered_id(struct si_shader_context *ctx)
 
 static LLVMValueRef ngg_get_query_buf(struct si_shader_context *ctx)
 {
-   LLVMValueRef buf_ptr = ac_get_arg(&ctx->ac, ctx->internal_bindings);
-   LLVMTypeRef type = ac_get_arg_pointee_type(&ctx->ac, &ctx->args, ctx->internal_bindings);
-   return ac_build_load_to_sgpr(&ctx->ac, type, buf_ptr,
+   return ac_build_load_to_sgpr(&ctx->ac, ac_get_ptr_arg(&ctx->ac, &ctx->args, ctx->internal_bindings),
                                 LLVMConstInt(ctx->ac.i32, SI_GS_QUERY_BUF, false));
 }
 
 static LLVMValueRef ngg_get_emulated_counters_buf(struct si_shader_context *ctx)
 {
-   LLVMValueRef buf_ptr = ac_get_arg(&ctx->ac, ctx->internal_bindings);
-   LLVMTypeRef type = ac_get_arg_pointee_type(&ctx->ac, &ctx->args, ctx->internal_bindings);
-
-   return ac_build_load_to_sgpr(&ctx->ac, type, buf_ptr,
+   return ac_build_load_to_sgpr(&ctx->ac, ac_get_ptr_arg(&ctx->ac, &ctx->args, ctx->internal_bindings),
                                 LLVMConstInt(ctx->ac.i32, SI_GS_QUERY_EMULATED_COUNTERS_BUF, false));
 }
 
@@ -253,7 +248,7 @@ static void build_streamout_vertex(struct si_shader_context *ctx, LLVMValueRef *
 
       for (unsigned comp = 0; comp < 4; comp++) {
          LLVMValueRef idx = LLVMConstInt(ctx->ac.i32, 4 * reg + comp, false);
-         LLVMValueRef v = ac_build_gep0(&ctx->ac, vertexptr.t, vertexptr.v, idx);
+         LLVMValueRef v = ac_build_gep0(&ctx->ac, vertexptr, idx);
          out.values[comp] = LLVMBuildLoad2(builder, ac_build_gep0_type(vertexptr.t, idx), v, "");
          out.vertex_streams = info->output_streams[reg];
       }
@@ -287,8 +282,7 @@ static void build_streamout(struct si_shader_context *ctx, struct ngg_streamout
    struct si_shader_info *info = &ctx->shader->selector->info;
    struct pipe_stream_output_info *so = &ctx->so;
    LLVMBuilderRef builder = ctx->ac.builder;
-   LLVMValueRef buf_ptr = ac_get_arg(&ctx->ac, ctx->internal_bindings);
-   LLVMTypeRef type = ac_get_arg_pointee_type(&ctx->ac, &ctx->args, ctx->internal_bindings);
+   struct ac_llvm_pointer arg = ac_get_ptr_arg(&ctx->ac, &ctx->args, ctx->internal_bindings);
    LLVMValueRef tid = gfx10_get_thread_id_in_tg(ctx);
    LLVMValueRef tmp, tmp2;
    LLVMValueRef i32_2 = LLVMConstInt(ctx->ac.i32, 2, false);
@@ -328,7 +322,7 @@ static void build_streamout(struct si_shader_context *ctx, struct ngg_streamout
                             LLVMConstInt(ctx->ac.i32, buffer, false));
 
       so_buffer[buffer] = ac_build_load_to_sgpr(
-         &ctx->ac, type, buf_ptr, LLVMConstInt(ctx->ac.i32, SI_VS_STREAMOUT_BUF0 + buffer, false));
+         &ctx->ac, arg, LLVMConstInt(ctx->ac.i32, SI_VS_STREAMOUT_BUF0 + buffer, false));
    }
 
    tmp = LLVMBuildICmp(builder, LLVMIntEQ, get_wave_id_in_tg(ctx), ctx->ac.i32_0, "");
@@ -345,7 +339,7 @@ static void build_streamout(struct si_shader_context *ctx, struct ngg_streamout
       ac_build_ifcc(&ctx->ac, tmp, 5210);
       {
          if (isgs) {
-            LLVMValueRef vt = ac_build_gep0(&ctx->ac, ctx->gs_ngg_scratch.t, ctx->gs_ngg_scratch.v, tid);
+            LLVMValueRef vt = ac_build_gep0(&ctx->ac, ctx->gs_ngg_scratch, tid);
             tmp = LLVMBuildLoad2(builder, ac_build_gep0_type(ctx->gs_ngg_scratch.t, tid), vt, "");
          } else {
             tmp = ac_build_writelane(&ctx->ac, ctx->ac.i32_0, ngg_get_prim_cnt(ctx), ctx->ac.i32_0);
@@ -452,7 +446,7 @@ static void build_streamout(struct si_shader_context *ctx, struct ngg_streamout
          LLVMBuildStore(builder, tmp, offsets_vgpr);
 
          tmp2 = LLVMBuildAdd(builder, ac_get_thread_id(&ctx->ac), scratch_offset_basev, "");
-         tmp2 = ac_build_gep0(&ctx->ac, ctx->gs_ngg_scratch.t, ctx->gs_ngg_scratch.v, tmp2);
+         tmp2 = ac_build_gep0(&ctx->ac, ctx->gs_ngg_scratch, tmp2);
          LLVMBuildStore(builder, tmp, tmp2);
       }
       ac_build_endif(&ctx->ac, 5210);
@@ -546,7 +540,7 @@ static void build_streamout(struct si_shader_context *ctx, struct ngg_streamout
       ac_build_ifcc(&ctx->ac, tmp, 5225);
       {
          tmp = LLVMBuildAdd(builder, ac_get_thread_id(&ctx->ac), scratch_emit_basev, "");
-         tmp = ac_build_gep0(&ctx->ac, ctx->gs_ngg_scratch.t, ctx->gs_ngg_scratch.v, tmp);
+         tmp = ac_build_gep0(&ctx->ac, ctx->gs_ngg_scratch, tmp);
          LLVMBuildStore(builder, emit_vgpr, tmp);
       }
       ac_build_endif(&ctx->ac, 5225);
@@ -567,7 +561,7 @@ static void build_streamout(struct si_shader_context *ctx, struct ngg_streamout
          primemit_scan[stream].op = nir_op_iadd;
          primemit_scan[stream].src = nggso->prim_enable[stream];
          primemit_scan[stream].scratch = ac_build_gep0(
-            &ctx->ac, ctx->gs_ngg_scratch.t, ctx->gs_ngg_scratch.v,
+            &ctx->ac, ctx->gs_ngg_scratch,
             LLVMConstInt(ctx->ac.i32, 12 + 8 * stream, false));
          primemit_scan[stream].waveidx = get_wave_id_in_tg(ctx);
          primemit_scan[stream].numwaves = get_tgsize(ctx);
@@ -592,7 +586,7 @@ static void build_streamout(struct si_shader_context *ctx, struct ngg_streamout
       LLVMValueRef scratch_vgpr;
 
       LLVMValueRef idx = ac_get_thread_id(&ctx->ac);
-      LLVMValueRef v = ac_build_gep0(&ctx->ac, ctx->gs_ngg_scratch.t, ctx->gs_ngg_scratch.v, idx);
+      LLVMValueRef v = ac_build_gep0(&ctx->ac, ctx->gs_ngg_scratch, idx);
       scratch_vgpr = LLVMBuildLoad2(builder, ac_build_gep0_type(ctx->gs_ngg_scratch.t, idx), v, "");
 
       for (unsigned buffer = 0; buffer < 4; ++buffer) {
@@ -779,7 +773,7 @@ static void load_vertex_counts(struct si_shader_context *ctx, struct ac_llvm_poi
     */
    ac_build_ifcc(&ctx->ac, LLVMBuildICmp(builder, LLVMIntULT, tid,
                                          LLVMConstInt(ctx->ac.i32, num_i8vec4, 0), ""), 17771);
-   LLVMValueRef v = ac_build_gep0(&ctx->ac, lds.t, lds.v, tid);
+   LLVMValueRef v = ac_build_gep0(&ctx->ac, lds, tid);
    LLVMBuildStore(builder, LLVMBuildLoad2(builder, ac_build_gep0_type(lds.t, tid), v, ""), i8vec4_lane);
    ac_build_endif(&ctx->ac, 17771);
 
@@ -953,10 +947,9 @@ static void cull_primitive(struct si_shader_context *ctx,
 
    /* Load the viewport state for small prim culling. */
    bool prim_is_lines = shader->key.ge.opt.ngg_culling & SI_NGG_CULL_LINES;
-   LLVMValueRef ptr = ac_get_arg(&ctx->ac, ctx->small_prim_cull_info);
-   LLVMTypeRef type = ac_get_arg_pointee_type(&ctx->ac, &ctx->args, ctx->small_prim_cull_info);
+   struct ac_llvm_pointer small_prim_cull_info_arg = ac_get_ptr_arg(&ctx->ac, &ctx->args, ctx->small_prim_cull_info);
    /* Lines will always use the non-AA viewport transformation. */
-   LLVMValueRef vp = ac_build_load_to_sgpr(&ctx->ac, type, ptr,
+   LLVMValueRef vp = ac_build_load_to_sgpr(&ctx->ac, small_prim_cull_info_arg,
                                            prim_is_lines ? ctx->ac.i32_1 : ctx->ac.i32_0);
    vp = LLVMBuildBitCast(builder, vp, ctx->ac.v4f32, "");
    vp_scale[0] = ac_llvm_extract_elem(&ctx->ac, vp, 0);
@@ -970,7 +963,8 @@ static void cull_primitive(struct si_shader_context *ctx,
    options.cull_w = true;
 
    if (prim_is_lines) {
-      LLVMValueRef terms = ac_build_load_to_sgpr(&ctx->ac, ctx->ac.v2f32, ptr, LLVMConstInt(ctx->ac.i32, 4, 0));
+      small_prim_cull_info_arg.t = ctx->ac.v2f32;
+      LLVMValueRef terms = ac_build_load_to_sgpr(&ctx->ac, small_prim_cull_info_arg, LLVMConstInt(ctx->ac.i32, 4, 0));
       terms = LLVMBuildBitCast(builder, terms, ctx->ac.v2f32, "");
       clip_half_line_width[0] = ac_llvm_extract_elem(&ctx->ac, terms, 0);
       clip_half_line_width[1] = ac_llvm_extract_elem(&ctx->ac, terms, 1);
@@ -1062,14 +1056,14 @@ void gfx10_ngg_culling_build_end(struct si_shader_context *ctx)
          /* Store Position.W into LDS. */
          LLVMBuildStore(
             builder, ac_to_integer(&ctx->ac, position[3]),
-            ac_build_gep0(&ctx->ac, es_vtxptr.t, es_vtxptr.v, LLVMConstInt(ctx->ac.i32, lds_pos_cull_w, 0)));
+            ac_build_gep0(&ctx->ac, es_vtxptr, LLVMConstInt(ctx->ac.i32, lds_pos_cull_w, 0)));
 
          /* Store Position.XY / W into LDS. */
          for (unsigned chan = 0; chan < 2; chan++) {
             LLVMValueRef val = ac_build_fdiv(&ctx->ac, position[chan], position[3]);
             LLVMBuildStore(
                builder, ac_to_integer(&ctx->ac, val),
-               ac_build_gep0(&ctx->ac, es_vtxptr.t, es_vtxptr.v, LLVMConstInt(ctx->ac.i32, lds_pos_cull_x_div_w + chan, 0)));
+               ac_build_gep0(&ctx->ac, es_vtxptr, LLVMConstInt(ctx->ac.i32, lds_pos_cull_x_div_w + chan, 0)));
          }
          break;
 
@@ -1111,7 +1105,7 @@ void gfx10_ngg_culling_build_end(struct si_shader_context *ctx)
    /* Initialize the packed data. */
    LLVMBuildStore(
       builder, packed_data,
-      ac_build_gep0(&ctx->ac, es_vtxptr.t, es_vtxptr.v, LLVMConstInt(ctx->ac.i32, lds_packed_data, 0)));
+      ac_build_gep0(&ctx->ac, es_vtxptr, LLVMConstInt(ctx->ac.i32, lds_packed_data, 0)));
    ac_build_endif(&ctx->ac, ctx->merged_wrap_if_label);
 
    ac_build_waitcnt(&ctx->ac, AC_WAIT_LGKM);
@@ -1208,7 +1202,7 @@ void gfx10_ngg_culling_build_end(struct si_shader_context *ctx)
                continue;
 
             LLVMValueRef idx = LLVMConstInt(ctx->ac.i32, index, 0);
-            LLVMValueRef v = ac_build_gep0(&ctx->ac, gs_vtxptr[vtx].t, gs_vtxptr[vtx].v, idx);
+            LLVMValueRef v = ac_build_gep0(&ctx->ac, gs_vtxptr[vtx], idx);
             pos[vtx][chan] = LLVMBuildLoad2(builder, ac_build_gep0_type(gs_vtxptr[vtx].t, idx), v, "");
             pos[vtx][chan] = ac_to_float(&ctx->ac, pos[vtx][chan]);
          }
@@ -1305,7 +1299,7 @@ void gfx10_ngg_culling_build_end(struct si_shader_context *ctx)
          LLVMBuildStore(
             builder, ac_to_integer(&ctx->ac,
                                    LLVMBuildLoad2(builder, ctx->ac.f32, addrs[4 * pos_index + chan], "")),
-            ac_build_gep0(&ctx->ac, new_vtx.t, new_vtx.v, LLVMConstInt(ctx->ac.i32, lds_pos_x + chan, 0)));
+            ac_build_gep0(&ctx->ac, new_vtx, LLVMConstInt(ctx->ac.i32, lds_pos_x + chan, 0)));
       }
 
       /* Store VertexID and InstanceID into LDS. ES threads will have to load them
@@ -1315,24 +1309,24 @@ void gfx10_ngg_culling_build_end(struct si_shader_context *ctx)
       if (ctx->stage == MESA_SHADER_VERTEX) {
          LLVMBuildStore(
             builder, ctx->abi.vertex_id,
-            ac_build_gep0(&ctx->ac, new_vtx.t, new_vtx.v, LLVMConstInt(ctx->ac.i32, lds_vertex_id, 0)));
+            ac_build_gep0(&ctx->ac, new_vtx, LLVMConstInt(ctx->ac.i32, lds_vertex_id, 0)));
          if (uses_instance_id) {
             LLVMBuildStore(
                builder, ctx->abi.instance_id,
-               ac_build_gep0(&ctx->ac, new_vtx.t, new_vtx.v, LLVMConstInt(ctx->ac.i32, lds_instance_id, 0)));
+               ac_build_gep0(&ctx->ac, new_vtx, LLVMConstInt(ctx->ac.i32, lds_instance_id, 0)));
          }
       } else {
          assert(ctx->stage == MESA_SHADER_TESS_EVAL);
          LLVMBuildStore(builder, ac_to_integer(&ctx->ac, ac_get_arg(&ctx->ac, ctx->args.tes_u)),
-                        ac_build_gep0(&ctx->ac, new_vtx.t, new_vtx.v, LLVMConstInt(ctx->ac.i32, lds_tes_u, 0)));
+                        ac_build_gep0(&ctx->ac, new_vtx, LLVMConstInt(ctx->ac.i32, lds_tes_u, 0)));
          LLVMBuildStore(builder, ac_to_integer(&ctx->ac, ac_get_arg(&ctx->ac, ctx->args.tes_v)),
-                        ac_build_gep0(&ctx->ac, new_vtx.t, new_vtx.v, LLVMConstInt(ctx->ac.i32, lds_tes_v, 0)));
+                        ac_build_gep0(&ctx->ac, new_vtx, LLVMConstInt(ctx->ac.i32, lds_tes_v, 0)));
          LLVMBuildStore(builder, LLVMBuildTrunc(builder, ac_get_arg(&ctx->ac, ctx->args.tes_rel_patch_id), ctx->ac.i8, ""),
                         si_build_gep_i8(ctx, new_vtx.value, lds_byte2_tes_rel_patch_id));
          if (uses_tes_prim_id) {
             LLVMBuildStore(
                builder, ac_get_arg(&ctx->ac, ctx->args.tes_patch_id),
-               ac_build_gep0(&ctx->ac, new_vtx.t, new_vtx.v, LLVMConstInt(ctx->ac.i32, lds_tes_patch_id, 0)));
+               ac_build_gep0(&ctx->ac, new_vtx, LLVMConstInt(ctx->ac.i32, lds_tes_patch_id, 0)));
          }
       }
    }
@@ -1411,13 +1405,13 @@ void gfx10_ngg_culling_build_end(struct si_shader_context *ctx)
 
    /* Prepare LDS addresses of the new ES input VGPRs. */
    LLVMValueRef input_vgpr_addresses[4] = {
-      ac_build_gep0(&ctx->ac, es_vtxptr.t, es_vtxptr.v, LLVMConstInt(ctx->ac.i32, lds_vertex_id, 0)),
-      ac_build_gep0(&ctx->ac, es_vtxptr.t, es_vtxptr.v, LLVMConstInt(ctx->ac.i32, lds_instance_id, 0)),
+      ac_build_gep0(&ctx->ac, es_vtxptr, LLVMConstInt(ctx->ac.i32, lds_vertex_id, 0)),
+      ac_build_gep0(&ctx->ac, es_vtxptr, LLVMConstInt(ctx->ac.i32, lds_instance_id, 0)),
    };
    if (ctx->stage == MESA_SHADER_TESS_EVAL) {
       input_vgpr_addresses[2] = si_build_gep_i8(ctx, es_vtxptr.v, lds_byte2_tes_rel_patch_id);
       if (uses_tes_prim_id) {
-         input_vgpr_addresses[3] = ac_build_gep0(&ctx->ac, es_vtxptr.t, es_vtxptr.v,
+         input_vgpr_addresses[3] = ac_build_gep0(&ctx->ac, es_vtxptr,
                                                  LLVMConstInt(ctx->ac.i32, lds_tes_patch_id, 0));
       }
    }
@@ -1545,7 +1539,7 @@ void gfx10_ngg_build_end(struct si_shader_context *ctx)
           */
          if (ctx->so.num_outputs) {
             LLVMValueRef idx = LLVMConstInt(ctx->ac.i32, 4 * i + j, false);
-            tmp = ac_build_gep0(&ctx->ac, vertex_ptr.t, vertex_ptr.v, idx);
+            tmp = ac_build_gep0(&ctx->ac, vertex_ptr, idx);
             tmp2 = LLVMBuildLoad2(builder, ac_build_gep0_type(vertex_ptr.t, idx), addrs[4 * i + j], "");
             LLVMTypeRef type = ac_to_integer_type(&ctx->ac, ctx->ac.f32);
             tmp2 = LLVMBuildBitCast(ctx->ac.builder, tmp2, type, "");
@@ -1561,7 +1555,7 @@ void gfx10_ngg_build_end(struct si_shader_context *ctx)
          edgeflag = ac_build_umin(&ctx->ac, edgeflag, ctx->ac.i32_1);
 
          tmp = LLVMConstInt(ctx->ac.i32, ngg_nogs_vertex_size(ctx->shader) - 1, 0);
-         tmp = ac_build_gep0(&ctx->ac, vertex_ptr.t, vertex_ptr.v, tmp);
+         tmp = ac_build_gep0(&ctx->ac, vertex_ptr, tmp);
          LLVMBuildStore(builder, edgeflag, tmp);
       }
    }
@@ -1624,7 +1618,7 @@ void gfx10_ngg_build_end(struct si_shader_context *ctx)
          struct ac_llvm_pointer vt = ngg_nogs_vertex_ptr(ctx, vtxindex[i]);
          tmp2 = LLVMConstInt(ctx->ac.i32, ngg_nogs_vertex_size(ctx->shader) - 1, 0);
          tmp = LLVMBuildLoad2(builder, ac_build_gep0_type(vt.t, tmp2),
-                              ac_build_gep0(&ctx->ac, vt.t, vt.v, tmp2), "");
+                              ac_build_gep0(&ctx->ac, vt, tmp2), "");
          tmp = LLVMBuildTrunc(builder, tmp, ctx->ac.i1, "");
 
          user_edgeflags[i] = ac_build_alloca_init(&ctx->ac, tmp, "");
@@ -1655,7 +1649,7 @@ void gfx10_ngg_build_end(struct si_shader_context *ctx)
       struct ac_llvm_pointer vertex_ptr = ngg_nogs_vertex_ptr(ctx, provoking_vtx_index);
 
       LLVMBuildStore(builder, ac_get_arg(&ctx->ac, ctx->args.gs_prim_id),
-                     ac_build_gep0(&ctx->ac, vertex_ptr.t, vertex_ptr.v, ctx->ac.i32_0));
+                     ac_build_gep0(&ctx->ac, vertex_ptr, ctx->ac.i32_0));
       ac_build_endif(&ctx->ac, 5400);
    }
 
@@ -1719,7 +1713,7 @@ void gfx10_ngg_build_end(struct si_shader_context *ctx)
 
             for (unsigned j = 0; j < 4; j++) {
                tmp = LLVMConstInt(ctx->ac.i32, lds_pos_x + j, 0);
-               LLVMValueRef v = ac_build_gep0(&ctx->ac, vertex_ptr.t, vertex_ptr.v, tmp);
+               LLVMValueRef v = ac_build_gep0(&ctx->ac, vertex_ptr, tmp);
                tmp = LLVMBuildLoad2(builder, ac_build_gep0_type(vertex_ptr.t, tmp), v, "");
                outputs[i].values[j] = LLVMBuildBitCast(ctx->ac.builder, tmp,
                                                        ac_to_float_type(&ctx->ac, ctx->ac.f32), "");
@@ -1742,7 +1736,7 @@ void gfx10_ngg_build_end(struct si_shader_context *ctx)
 
             struct ac_llvm_pointer vt = ngg_nogs_vertex_ptr(ctx, gfx10_get_thread_id_in_tg(ctx));
             outputs[i].values[0] = LLVMBuildLoad2(
-               builder, ac_build_gep0_type(vt.t, ctx->ac.i32_0), ac_build_gep0(&ctx->ac, vt.t, vt.v, ctx->ac.i32_0), "");
+               builder, ac_build_gep0_type(vt.t, ctx->ac.i32_0), ac_build_gep0(&ctx->ac, vt, ctx->ac.i32_0), "");
          } else {
             assert(ctx->stage == MESA_SHADER_TESS_EVAL);
             outputs[i].values[0] = si_get_primitive_id(ctx, 0);
@@ -1821,7 +1815,7 @@ static struct ac_llvm_pointer ngg_gs_vertex_ptr(struct si_shader_context *ctx, L
    }
 
    return (struct ac_llvm_pointer) {
-      .value = ac_build_gep0(&ctx->ac, storage.t, storage.v, vertexidx),
+      .value = ac_build_gep0(&ctx->ac, storage, vertexidx),
       .pointee_type = ac_build_gep0_type(storage.t, vertexidx)
    };
 }
@@ -1948,7 +1942,7 @@ void gfx10_ngg_gs_emit_begin(struct si_shader_context *ctx)
    tmp = LLVMBuildICmp(builder, LLVMIntULT, tid, LLVMConstInt(ctx->ac.i32, 4, false), "");
    ac_build_ifcc(&ctx->ac, tmp, 5090);
    {
-      LLVMValueRef ptr = ac_build_gep0(&ctx->ac, scratchptr.t, scratchptr.v, tid);
+      LLVMValueRef ptr = ac_build_gep0(&ctx->ac, scratchptr, tid);
       LLVMBuildStore(builder, ctx->ac.i32_0, ptr);
    }
    ac_build_endif(&ctx->ac, 5090);
@@ -2033,7 +2027,7 @@ void gfx10_ngg_gs_build_end(struct si_shader_context *ctx)
       {
          LLVMBuildAtomicRMW(
             builder, LLVMAtomicRMWBinOpAdd,
-            ac_build_gep0(&ctx->ac, ctx->gs_ngg_scratch.t, ctx->gs_ngg_scratch.v, LLVMConstInt(ctx->ac.i32, stream, false)),
+            ac_build_gep0(&ctx->ac, ctx->gs_ngg_scratch, LLVMConstInt(ctx->ac.i32, stream, false)),
             numprims, LLVMAtomicOrderingMonotonic, false);
       }
       ac_build_endif(&ctx->ac, 5105);
@@ -2069,7 +2063,7 @@ void gfx10_ngg_gs_build_end(struct si_shader_context *ctx)
                             "");
          struct ac_llvm_pointer vt = ngg_gs_vertex_ptr(ctx, tmp);
          nggso.vertices[i].t = ac_build_gep0_type(vt.t, ctx->ac.i32_0);
-         nggso.vertices[i].v = ac_build_gep0(&ctx->ac, vt.t, vt.v, ctx->ac.i32_0);
+         nggso.vertices[i].v = ac_build_gep0(&ctx->ac, vt, ctx->ac.i32_0);
       }
 
       build_streamout(ctx, &nggso);
@@ -2096,9 +2090,7 @@ void gfx10_ngg_gs_build_end(struct si_shader_context *ctx)
             offset = LLVMBuildAdd(builder, offset, tmp, "");
          }
 
-         tmp = LLVMBuildLoad2(builder, ctx->ac.i32,
-                              ac_build_gep0(&ctx->ac, ctx->gs_ngg_scratch.t, ctx->gs_ngg_scratch.v,
-                                            tid), "");
+         tmp = LLVMBuildLoad2(builder, ctx->ac.i32, ac_build_gep0(&ctx->ac, ctx->gs_ngg_scratch, tid), "");
          LLVMValueRef args[] = {
             tmp,           ngg_get_query_buf(ctx),
             offset,        LLVMConstInt(ctx->ac.i32, 16, false), /* soffset */
@@ -2136,7 +2128,7 @@ void gfx10_ngg_gs_build_end(struct si_shader_context *ctx)
             tmp = LLVMBuildSub(builder, tid, LLVMConstInt(ctx->ac.i32, verts_per_prim - i - 1, false), "");
             struct ac_llvm_pointer vt = ngg_gs_vertex_ptr(ctx, tmp);
             vtxptr[i].t = ac_build_gep0_type(vt.t, ctx->ac.i32_0);
-            vtxptr[i].v = ac_build_gep0(&ctx->ac, vt.t, vt.v, ctx->ac.i32_0);
+            vtxptr[i].v = ac_build_gep0(&ctx->ac, vt, ctx->ac.i32_0);
          }
 
          for (unsigned i = 0; i < info->num_outputs; i++) {
@@ -2157,7 +2149,7 @@ void gfx10_ngg_gs_build_end(struct si_shader_context *ctx)
                         continue;
 
                      LLVMValueRef idx = LLVMConstInt(ctx->ac.i32, 4 * i + comp, false);
-                     tmp = ac_build_gep0(&ctx->ac, vtxptr[vert].t, vtxptr[vert].v, idx);
+                     tmp = ac_build_gep0(&ctx->ac, vtxptr[vert], idx);
                      pos[vert][comp] = LLVMBuildLoad2(builder,
                                                       ac_build_gep0_type(vtxptr[vert].t, idx),
                                                       tmp, "");
@@ -2229,7 +2221,7 @@ void gfx10_ngg_gs_build_end(struct si_shader_context *ctx)
    vertlive_scan.enable_reduce = true;
    vertlive_scan.enable_exclusive = true;
    vertlive_scan.src = vertlive;
-   vertlive_scan.scratch = ac_build_gep0(&ctx->ac, ctx->gs_ngg_scratch.t, ctx->gs_ngg_scratch.v, ctx->ac.i32_0);
+   vertlive_scan.scratch = ac_build_gep0(&ctx->ac, ctx->gs_ngg_scratch, ctx->ac.i32_0);
    vertlive_scan.waveidx = get_wave_id_in_tg(ctx);
    vertlive_scan.numwaves = get_tgsize(ctx);
    vertlive_scan.maxwaves = DIV_ROUND_UP(256, ctx->ac.wave_size);
diff --git a/src/gallium/drivers/radeonsi/si_shader_llvm.c b/src/gallium/drivers/radeonsi/si_shader_llvm.c
index e0d6cfaa713e..c4213ff27ab1 100644
--- a/src/gallium/drivers/radeonsi/si_shader_llvm.c
+++ b/src/gallium/drivers/radeonsi/si_shader_llvm.c
@@ -765,9 +765,7 @@ static LLVMValueRef si_llvm_load_intrinsic(struct ac_shader_abi *abi, nir_intrin
    case nir_intrinsic_load_tess_level_outer_default:
    case nir_intrinsic_load_tess_level_inner_default: {
       LLVMValueRef slot = LLVMConstInt(ctx->ac.i32, SI_HS_CONST_DEFAULT_TESS_LEVELS, 0);
-      LLVMValueRef buf = ac_get_arg(&ctx->ac, ctx->internal_bindings);
-      LLVMTypeRef type = ac_get_arg_pointee_type(&ctx->ac, &ctx->args, ctx->internal_bindings);
-      buf = ac_build_load_to_sgpr(&ctx->ac, type, buf, slot);
+      LLVMValueRef buf = ac_build_load_to_sgpr(&ctx->ac, ac_get_ptr_arg(&ctx->ac, &ctx->args, ctx->internal_bindings), slot);
       int offset = op == nir_intrinsic_load_tess_level_inner_default ? 4 : 0;
       LLVMValueRef val[4];
 
@@ -816,15 +814,15 @@ static LLVMValueRef si_llvm_load_intrinsic(struct ac_shader_abi *abi, nir_intrin
 
    case nir_intrinsic_load_clip_half_line_width_amd: {
       LLVMValueRef ptr = ac_get_arg(&ctx->ac, ctx->small_prim_cull_info);
-      return ac_build_load_to_sgpr(&ctx->ac, ctx->ac.v2f32, ptr, LLVMConstInt(ctx->ac.i32, 4, 0));
+      return ac_build_load_to_sgpr(&ctx->ac,
+         (struct ac_llvm_pointer) { .t = ctx->ac.v2f32, .v = ptr }, LLVMConstInt(ctx->ac.i32, 4, 0));
    }
 
    case nir_intrinsic_load_viewport_xy_scale_and_offset: {
       bool prim_is_lines = ctx->shader->key.ge.opt.ngg_culling & SI_NGG_CULL_LINES;
-      LLVMValueRef ptr = ac_get_arg(&ctx->ac, ctx->small_prim_cull_info);
-      LLVMTypeRef type = ac_get_arg_pointee_type(&ctx->ac, &ctx->args, ctx->small_prim_cull_info);
+      struct ac_llvm_pointer ptr = ac_get_ptr_arg(&ctx->ac, &ctx->args, ctx->small_prim_cull_info);
       LLVMValueRef terms =
-         ac_build_load_to_sgpr(&ctx->ac, type, ptr, prim_is_lines ? ctx->ac.i32_1 : ctx->ac.i32_0);
+         ac_build_load_to_sgpr(&ctx->ac, ptr, prim_is_lines ? ctx->ac.i32_1 : ctx->ac.i32_0);
       return LLVMBuildBitCast(ctx->ac.builder, terms, ctx->ac.v4f32, "");
    }
 
@@ -878,10 +876,9 @@ static LLVMValueRef si_llvm_load_intrinsic(struct ac_shader_abi *abi, nir_intrin
 static LLVMValueRef si_llvm_load_user_clip_plane(struct ac_shader_abi *abi, unsigned ucp_id)
 {
    struct si_shader_context *ctx = si_shader_context_from_abi(abi);
-   LLVMValueRef ptr = ac_get_arg(&ctx->ac, ctx->internal_bindings);
-   LLVMTypeRef type = ac_get_arg_pointee_type(&ctx->ac, &ctx->args, ctx->internal_bindings);
+   struct ac_llvm_pointer ptr = ac_get_ptr_arg(&ctx->ac, &ctx->args, ctx->internal_bindings);
    LLVMValueRef constbuf_index = LLVMConstInt(ctx->ac.i32, SI_VS_CONST_CLIP_PLANES, 0);
-   LLVMValueRef const_resource = ac_build_load_to_sgpr(&ctx->ac, type, ptr, constbuf_index);
+   LLVMValueRef const_resource = ac_build_load_to_sgpr(&ctx->ac, ptr, constbuf_index);
    LLVMValueRef addr = LLVMConstInt(ctx->ac.i32, ucp_id * 16, 0);
    return ac_build_buffer_load(&ctx->ac, const_resource, 4, NULL, addr, NULL,
                                ctx->ac.f32, 0, true, true);
@@ -890,11 +887,10 @@ static LLVMValueRef si_llvm_load_user_clip_plane(struct ac_shader_abi *abi, unsi
 static LLVMValueRef si_llvm_load_streamout_buffer(struct ac_shader_abi *abi, unsigned buffer)
 {
    struct si_shader_context *ctx = si_shader_context_from_abi(abi);
-   LLVMValueRef buf_ptr = ac_get_arg(&ctx->ac, ctx->internal_bindings);
-   LLVMTypeRef type = ac_get_arg_pointee_type(&ctx->ac, &ctx->args, ctx->internal_bindings);
+   struct ac_llvm_pointer buf_ptr = ac_get_ptr_arg(&ctx->ac, &ctx->args, ctx->internal_bindings);
 
    return ac_build_load_to_sgpr(
-      &ctx->ac, type, buf_ptr, LLVMConstInt(ctx->ac.i32, SI_VS_STREAMOUT_BUF0 + buffer, false));
+      &ctx->ac, buf_ptr, LLVMConstInt(ctx->ac.i32, SI_VS_STREAMOUT_BUF0 + buffer, false));
 }
 
 bool si_llvm_translate_nir(struct si_shader_context *ctx, struct si_shader *shader,
@@ -930,11 +926,10 @@ bool si_llvm_translate_nir(struct si_shader_context *ctx, struct si_shader *shad
       /* preload instance_divisor_constbuf to be used for input load after culling */
       if (ctx->shader->key.ge.opt.ngg_culling &&
           ctx->shader->key.ge.part.vs.prolog.instance_divisor_is_fetched) {
-         LLVMValueRef buf = ac_get_arg(&ctx->ac, ctx->internal_bindings);
-         LLVMTypeRef type = ac_get_arg_pointee_type(&ctx->ac, &ctx->args, ctx->internal_bindings);
+         struct ac_llvm_pointer buf = ac_get_ptr_arg(&ctx->ac, &ctx->args, ctx->internal_bindings);
          ctx->instance_divisor_constbuf =
             ac_build_load_to_sgpr(
-               &ctx->ac, type, buf, LLVMConstInt(ctx->ac.i32, SI_VS_CONST_INSTANCE_DIVISORS, 0));
+               &ctx->ac, buf, LLVMConstInt(ctx->ac.i32, SI_VS_CONST_INSTANCE_DIVISORS, 0));
       }
       break;
 
diff --git a/src/gallium/drivers/radeonsi/si_shader_llvm_gs.c b/src/gallium/drivers/radeonsi/si_shader_llvm_gs.c
index 60c028761aef..0daea376085f 100644
--- a/src/gallium/drivers/radeonsi/si_shader_llvm_gs.c
+++ b/src/gallium/drivers/radeonsi/si_shader_llvm_gs.c
@@ -98,10 +98,7 @@ static LLVMValueRef si_get_gs_wave_id(struct si_shader_context *ctx)
 
 static LLVMValueRef ngg_get_emulated_counters_buf(struct si_shader_context *ctx)
 {
-   LLVMValueRef buf_ptr = ac_get_arg(&ctx->ac, ctx->internal_bindings);
-   LLVMTypeRef type = ac_get_arg_pointee_type(&ctx->ac, &ctx->args, ctx->internal_bindings);
-
-   return ac_build_load_to_sgpr(&ctx->ac, type, buf_ptr,
+   return ac_build_load_to_sgpr(&ctx->ac, ac_get_ptr_arg(&ctx->ac, &ctx->args, ctx->internal_bindings),
                                 LLVMConstInt(ctx->ac.i32, SI_GS_QUERY_EMULATED_COUNTERS_BUF, false));
 }
 
@@ -263,10 +260,9 @@ void si_preload_esgs_ring(struct si_shader_context *ctx)
 
    if (ctx->screen->info.gfx_level <= GFX8) {
       LLVMValueRef offset = LLVMConstInt(ctx->ac.i32, SI_RING_ESGS, 0);
-      LLVMValueRef buf_ptr = ac_get_arg(&ctx->ac, ctx->internal_bindings);
-      LLVMTypeRef type = ac_get_arg_pointee_type(&ctx->ac, &ctx->args, ctx->internal_bindings);
 
-      ctx->esgs_ring = ac_build_load_to_sgpr(&ctx->ac, type, buf_ptr, offset);
+      ctx->esgs_ring = ac_build_load_to_sgpr(&ctx->ac,
+         ac_get_ptr_arg(&ctx->ac, &ctx->args, ctx->internal_bindings), offset);
 
       if (ctx->stage != MESA_SHADER_GEOMETRY) {
          LLVMValueRef desc1 = LLVMBuildExtractElement(builder, ctx->esgs_ring, ctx->ac.i32_1, "");
@@ -307,9 +303,8 @@ void si_preload_gs_rings(struct si_shader_context *ctx)
    const struct si_shader_selector *sel = ctx->shader->selector;
    LLVMBuilderRef builder = ctx->ac.builder;
    LLVMValueRef offset = LLVMConstInt(ctx->ac.i32, SI_RING_GSVS, 0);
-   LLVMValueRef buf_ptr = ac_get_arg(&ctx->ac, ctx->internal_bindings);
-   LLVMTypeRef type = ac_get_arg_pointee_type(&ctx->ac, &ctx->args, ctx->internal_bindings);
-   LLVMValueRef base_ring = ac_build_load_to_sgpr(&ctx->ac, type, buf_ptr, offset);
+   LLVMValueRef base_ring = ac_build_load_to_sgpr(&ctx->ac,
+      ac_get_ptr_arg(&ctx->ac, &ctx->args, ctx->internal_bindings), offset);
 
    /* The conceptual layout of the GSVS ring is
     *   v0c0 .. vLv0 v0c1 .. vLc1 ..
@@ -435,10 +430,9 @@ struct si_shader *si_generate_gs_copy_shader(struct si_screen *sscreen,
    /* Build the main function. */
    si_llvm_create_main_func(&ctx, false);
 
-   LLVMValueRef buf_ptr = ac_get_arg(&ctx.ac, ctx.internal_bindings);
-   LLVMTypeRef type = ac_get_arg_pointee_type(&ctx.ac, &ctx.args, ctx.internal_bindings);
    ctx.gsvs_ring[0] =
-      ac_build_load_to_sgpr(&ctx.ac, type, buf_ptr, LLVMConstInt(ctx.ac.i32, SI_RING_GSVS, 0));
+      ac_build_load_to_sgpr(&ctx.ac,
+         ac_get_ptr_arg(&ctx.ac, &ctx.args, ctx.internal_bindings), LLVMConstInt(ctx.ac.i32, SI_RING_GSVS, 0));
 
    LLVMValueRef voffset =
       LLVMBuildMul(ctx.ac.builder, ctx.abi.vertex_id, LLVMConstInt(ctx.ac.i32, 4, 0), "");
diff --git a/src/gallium/drivers/radeonsi/si_shader_llvm_ps.c b/src/gallium/drivers/radeonsi/si_shader_llvm_ps.c
index c7660a3caa03..218a3c2a3001 100644
--- a/src/gallium/drivers/radeonsi/si_shader_llvm_ps.c
+++ b/src/gallium/drivers/radeonsi/si_shader_llvm_ps.c
@@ -34,10 +34,9 @@ LLVMValueRef si_get_sample_id(struct si_shader_context *ctx)
 static LLVMValueRef load_sample_position(struct ac_shader_abi *abi, LLVMValueRef sample_id)
 {
    struct si_shader_context *ctx = si_shader_context_from_abi(abi);
-   LLVMValueRef desc = ac_get_arg(&ctx->ac, ctx->internal_bindings);
    LLVMValueRef buf_index = LLVMConstInt(ctx->ac.i32, SI_PS_CONST_SAMPLE_POSITIONS, 0);
-   LLVMTypeRef type = ac_get_arg_pointee_type(&ctx->ac, &ctx->args, ctx->internal_bindings);
-   LLVMValueRef resource = ac_build_load_to_sgpr(&ctx->ac, type, desc, buf_index);
+   LLVMValueRef resource = ac_build_load_to_sgpr(
+      &ctx->ac, ac_get_ptr_arg(&ctx->ac, &ctx->args, ctx->internal_bindings), buf_index);
 
    /* offset = sample_id * 8  (8 = 2 floats containing samplepos.xy) */
    LLVMValueRef offset0 =
@@ -69,8 +68,9 @@ static LLVMValueRef si_nir_emit_fbfetch(struct ac_shader_abi *abi)
    ptr = ac_get_arg(&ctx->ac, ctx->internal_bindings);
    ptr =
       LLVMBuildPointerCast(ctx->ac.builder, ptr, ac_array_in_const32_addr_space(ctx->ac.v8i32), "");
-   image =
-      ac_build_load_to_sgpr(&ctx->ac, ctx->ac.v8i32, ptr, LLVMConstInt(ctx->ac.i32, SI_PS_IMAGE_COLORBUF0 / 2, 0));
+   struct ac_llvm_pointer desc = { .v = ptr, .t = ctx->ac.v8i32 };
+
+   image = ac_build_load_to_sgpr(&ctx->ac, desc, LLVMConstInt(ctx->ac.i32, SI_PS_IMAGE_COLORBUF0 / 2, 0));
 
    unsigned chan = 0;
 
@@ -90,8 +90,7 @@ static LLVMValueRef si_nir_emit_fbfetch(struct ac_shader_abi *abi)
        ctx->shader->key.ps.mono.fbfetch_msaa &&
        !(ctx->screen->debug_flags & DBG(NO_FMASK))) {
 
-      fmask = ac_build_load_to_sgpr(&ctx->ac, ctx->ac.v8i32, ptr,
-                                    LLVMConstInt(ctx->ac.i32, SI_PS_IMAGE_COLORBUF0_FMASK / 2, 0));
+      fmask = ac_build_load_to_sgpr(&ctx->ac, desc, LLVMConstInt(ctx->ac.i32, SI_PS_IMAGE_COLORBUF0_FMASK / 2, 0));
 
       ac_apply_fmask_to_sample(&ctx->ac, fmask, args.coords,
                                ctx->shader->key.ps.mono.fbfetch_layered);
@@ -550,7 +549,7 @@ static void si_llvm_emit_polygon_stipple(struct si_shader_context *ctx,
    /* Load the buffer descriptor. */
    slot = LLVMConstInt(ctx->ac.i32, SI_PS_CONST_POLY_STIPPLE, 0);
 
-   desc = ac_build_load_to_sgpr(&ctx->ac, ctx->ac.v4i32, param_internal_bindings, slot);
+   desc = ac_build_load_to_sgpr(&ctx->ac, (struct ac_llvm_pointer) { .t = ctx->ac.v4i32, .v = param_internal_bindings }, slot);
 
    /* The stipple pattern is 32x32, each row has 32 bits. */
    offset = LLVMBuildMul(builder, address[1], LLVMConstInt(ctx->ac.i32, 4, 0), "");
diff --git a/src/gallium/drivers/radeonsi/si_shader_llvm_resources.c b/src/gallium/drivers/radeonsi/si_shader_llvm_resources.c
index 23ce4f0e5c03..7900ba9da861 100644
--- a/src/gallium/drivers/radeonsi/si_shader_llvm_resources.c
+++ b/src/gallium/drivers/radeonsi/si_shader_llvm_resources.c
@@ -94,8 +94,6 @@ static LLVMValueRef load_ubo(struct ac_shader_abi *abi, LLVMValueRef index)
    struct si_shader_context *ctx = si_shader_context_from_abi(abi);
    struct si_shader_selector *sel = ctx->shader->selector;
 
-   LLVMValueRef ptr = ac_get_arg(&ctx->ac, ctx->const_and_shader_buffers);
-
    if (sel->info.base.num_ubos == 1 && sel->info.base.num_ssbos == 0) {
       return load_const_buffer_desc_fast_path(ctx);
    }
@@ -105,8 +103,7 @@ static LLVMValueRef load_ubo(struct ac_shader_abi *abi, LLVMValueRef index)
       LLVMBuildAdd(ctx->ac.builder, index, LLVMConstInt(ctx->ac.i32, SI_NUM_SHADER_BUFFERS, 0), "");
 
    return ac_build_load_to_sgpr(&ctx->ac,
-                                ac_get_arg_pointee_type(&ctx->ac, &ctx->args, ctx->const_and_shader_buffers),
-                                ptr,
+                                ac_get_ptr_arg(&ctx->ac, &ctx->args, ctx->const_and_shader_buffers),
                                 index);
 }
 
@@ -119,14 +116,13 @@ static LLVMValueRef load_ssbo(struct ac_shader_abi *abi, LLVMValueRef index, boo
        LLVMConstIntGetZExtValue(index) < ctx->shader->selector->cs_num_shaderbufs_in_user_sgprs)
       return ac_get_arg(&ctx->ac, ctx->cs_shaderbuf[LLVMConstIntGetZExtValue(index)]);
 
-   LLVMValueRef rsrc_ptr = ac_get_arg(&ctx->ac, ctx->const_and_shader_buffers);
    index = si_llvm_bound_index(ctx, index, ctx->num_shader_buffers);
    index = LLVMBuildSub(ctx->ac.builder, LLVMConstInt(ctx->ac.i32, SI_NUM_SHADER_BUFFERS - 1, 0),
                         index, "");
 
    return ac_build_load_to_sgpr(&ctx->ac,
-                                ac_get_arg_pointee_type(&ctx->ac, &ctx->args, ctx->const_and_shader_buffers),
-                                rsrc_ptr, index);
+                                ac_get_ptr_arg(&ctx->ac, &ctx->args, ctx->const_and_shader_buffers),
+                                index);
 }
 
 /**
@@ -181,25 +177,23 @@ static LLVMValueRef fixup_image_desc(struct si_shader_context *ctx, LLVMValueRef
 
 /* AC_DESC_FMASK is handled exactly like AC_DESC_IMAGE. The caller should
  * adjust "index" to point to FMASK. */
-static LLVMValueRef si_load_image_desc(struct si_shader_context *ctx, LLVMTypeRef type, LLVMValueRef list,
+static LLVMValueRef si_load_image_desc(struct si_shader_context *ctx, struct ac_llvm_pointer list,
                                        LLVMValueRef index, enum ac_descriptor_type desc_type,
                                        bool uses_store, bool bindless)
 {
-   LLVMBuilderRef builder = ctx->ac.builder;
    LLVMValueRef rsrc;
 
    if (desc_type == AC_DESC_BUFFER) {
       index = ac_build_imad(&ctx->ac, index, LLVMConstInt(ctx->ac.i32, 2, 0), ctx->ac.i32_1);
-      list = LLVMBuildPointerCast(builder, list, ac_array_in_const32_addr_space(ctx->ac.v4i32), "");
-      type = ctx->ac.v4i32;
+      list.pointee_type = ctx->ac.v4i32;
    } else {
       assert(desc_type == AC_DESC_IMAGE || desc_type == AC_DESC_FMASK);
    }
 
    if (bindless)
-      rsrc = ac_build_load_to_sgpr_uint_wraparound(&ctx->ac, type, list, index);
+      rsrc = ac_build_load_to_sgpr_uint_wraparound(&ctx->ac, list, index);
    else
-      rsrc = ac_build_load_to_sgpr(&ctx->ac, type, list, index);
+      rsrc = ac_build_load_to_sgpr(&ctx->ac, list, index);
 
    if (desc_type == AC_DESC_IMAGE)
       rsrc = fixup_image_desc(ctx, rsrc, uses_store);
@@ -210,8 +204,7 @@ static LLVMValueRef si_load_image_desc(struct si_shader_context *ctx, LLVMTypeRe
 /**
  * Load an image view, fmask view. or sampler state descriptor.
  */
-static LLVMValueRef si_load_sampler_desc(struct si_shader_context *ctx, LLVMTypeRef list_type,
-                                         LLVMValueRef list,
+static LLVMValueRef si_load_sampler_desc(struct si_shader_context *ctx, struct ac_llvm_pointer list,
                                          LLVMValueRef index, enum ac_descriptor_type type)
 {
    LLVMBuilderRef builder = ctx->ac.builder;
@@ -224,8 +217,7 @@ static LLVMValueRef si_load_sampler_desc(struct si_shader_context *ctx, LLVMType
    case AC_DESC_BUFFER:
       /* The buffer is in [4:7]. */
       index = ac_build_imad(&ctx->ac, index, LLVMConstInt(ctx->ac.i32, 4, 0), ctx->ac.i32_1);
-      list = LLVMBuildPointerCast(builder, list, ac_array_in_const32_addr_space(ctx->ac.v4i32), "");
-      list_type = ctx->ac.v4i32;
+      list.pointee_type = ctx->ac.v4i32;
       break;
    case AC_DESC_FMASK:
       /* The FMASK is at [8:15]. */
@@ -236,8 +228,7 @@ static LLVMValueRef si_load_sampler_desc(struct si_shader_context *ctx, LLVMType
       /* The sampler state is at [12:15]. */
       index = ac_build_imad(&ctx->ac, index, LLVMConstInt(ctx->ac.i32, 4, 0),
                             LLVMConstInt(ctx->ac.i32, 3, 0));
-      list = LLVMBuildPointerCast(builder, list, ac_array_in_const32_addr_space(ctx->ac.v4i32), "");
-      list_type = ctx->ac.v4i32;
+      list.pointee_type = ctx->ac.v4i32;
       break;
    case AC_DESC_PLANE_0:
    case AC_DESC_PLANE_1:
@@ -248,7 +239,7 @@ static LLVMValueRef si_load_sampler_desc(struct si_shader_context *ctx, LLVMType
       unreachable("Plane descriptor requested in radeonsi.");
    }
 
-   return ac_build_load_to_sgpr(&ctx->ac, list_type, list, index);
+   return ac_build_load_to_sgpr(&ctx->ac, list, index);
 }
 
 static LLVMValueRef si_nir_load_sampler_desc(struct ac_shader_abi *abi, unsigned descriptor_set,
@@ -265,8 +256,7 @@ static LLVMValueRef si_nir_load_sampler_desc(struct ac_shader_abi *abi, unsigned
    assert(desc_type <= AC_DESC_BUFFER);
 
    if (bindless) {
-      LLVMValueRef list = ac_get_arg(&ctx->ac, ctx->bindless_samplers_and_images);
-      LLVMTypeRef type = ac_get_arg_pointee_type(&ctx->ac, &ctx->args, ctx->bindless_samplers_and_images);
+      struct ac_llvm_pointer list = ac_get_ptr_arg(&ctx->ac, &ctx->args, ctx->bindless_samplers_and_images);
 
       /* dynamic_index is the bindless handle */
       if (image) {
@@ -278,7 +268,7 @@ static LLVMValueRef si_nir_load_sampler_desc(struct ac_shader_abi *abi, unsigned
             dynamic_index = LLVMBuildAdd(ctx->ac.builder, dynamic_index, ctx->ac.i32_1, "");
          }
 
-         return si_load_image_desc(ctx, type, list, dynamic_index, desc_type, write, true);
+         return si_load_image_desc(ctx, list, dynamic_index, desc_type, write, true);
       }
 
       /* Since bindless handle arithmetic can contain an unsigned integer
@@ -288,8 +278,8 @@ static LLVMValueRef si_nir_load_sampler_desc(struct ac_shader_abi *abi, unsigned
        */
       dynamic_index =
          LLVMBuildMul(ctx->ac.builder, dynamic_index, LLVMConstInt(ctx->ac.i64, 2, 0), "");
-      list = ac_build_pointer_add(&ctx->ac, ctx->ac.v8i32, list, dynamic_index);
-      return si_load_sampler_desc(ctx, type, list, ctx->ac.i32_0, desc_type);
+      list.v = ac_build_pointer_add(&ctx->ac, ctx->ac.v8i32, list.v, dynamic_index);
+      return si_load_sampler_desc(ctx, list, ctx->ac.i32_0, desc_type);
    }
 
    unsigned num_slots = image ? ctx->num_images : ctx->num_samplers;
@@ -298,8 +288,7 @@ static LLVMValueRef si_nir_load_sampler_desc(struct ac_shader_abi *abi, unsigned
    if (const_index >= num_slots)
       const_index = base_index;
 
-   LLVMValueRef list = ac_get_arg(&ctx->ac, ctx->samplers_and_images);
-   LLVMTypeRef type = ac_get_arg_pointee_type(&ctx->ac, &ctx->args, ctx->samplers_and_images);
+   struct ac_llvm_pointer list = ac_get_ptr_arg(&ctx->ac, &ctx->args, ctx->samplers_and_images);
    LLVMValueRef index = LLVMConstInt(ctx->ac.i32, const_index, false);
 
    if (dynamic_index) {
@@ -336,12 +325,12 @@ static LLVMValueRef si_nir_load_sampler_desc(struct ac_shader_abi *abi, unsigned
       }
       index = LLVMBuildSub(ctx->ac.builder, LLVMConstInt(ctx->ac.i32, SI_NUM_IMAGE_SLOTS - 1, 0),
                            index, "");
-      return si_load_image_desc(ctx, type, list, index, desc_type, write, false);
+      return si_load_image_desc(ctx, list, index, desc_type, write, false);
    }
 
    index = LLVMBuildAdd(ctx->ac.builder, index,
                         LLVMConstInt(ctx->ac.i32, SI_NUM_IMAGE_SLOTS / 2, 0), "");
-   return si_load_sampler_desc(ctx, type, list, index, desc_type);
+   return si_load_sampler_desc(ctx, list, index, desc_type);
 }
 
 void si_llvm_init_resource_callbacks(struct si_shader_context *ctx)
diff --git a/src/gallium/drivers/radeonsi/si_shader_llvm_vs.c b/src/gallium/drivers/radeonsi/si_shader_llvm_vs.c
index d11ad9ffef66..950daf49febf 100644
--- a/src/gallium/drivers/radeonsi/si_shader_llvm_vs.c
+++ b/src/gallium/drivers/radeonsi/si_shader_llvm_vs.c
@@ -168,9 +168,9 @@ static void load_input_vs(struct si_shader_context *ctx, unsigned input_index, L
       vb_desc = ac_get_arg(&ctx->ac, ctx->vb_descriptors[input_index]);
    } else {
       unsigned index = input_index - num_vbos_in_user_sgprs;
-      LLVMTypeRef type = ac_get_arg_pointee_type(&ctx->ac, &ctx->args, ctx->args.vertex_buffers);
-      vb_desc = ac_build_load_to_sgpr(&ctx->ac, type, ac_get_arg(&ctx->ac, ctx->args.vertex_buffers),
-                                      LLVMConstInt(ctx->ac.i32, index, 0));
+      vb_desc = ac_build_load_to_sgpr(
+         &ctx->ac, ac_get_ptr_arg(&ctx->ac, &ctx->args, ctx->args.vertex_buffers),
+         LLVMConstInt(ctx->ac.i32, index, 0));
    }
 
    if (ctx->abi.vertex_id_replaced) {
@@ -409,8 +409,7 @@ void si_llvm_emit_streamout(struct si_shader_context *ctx, struct si_shader_outp
        * enabled buffer. */
       LLVMValueRef so_write_offset[4] = {};
       LLVMValueRef so_buffers[4];
-      LLVMValueRef buf_ptr = ac_get_arg(&ctx->ac, ctx->internal_bindings);
-      LLVMTypeRef type = ac_get_arg_pointee_type(&ctx->ac, &ctx->args, ctx->internal_bindings);
+      struct ac_llvm_pointer arg = ac_get_ptr_arg(&ctx->ac, &ctx->args, ctx->internal_bindings);
 
       for (i = 0; i < 4; i++) {
          if (!so->stride[i])
@@ -418,7 +417,7 @@ void si_llvm_emit_streamout(struct si_shader_context *ctx, struct si_shader_outp
 
          LLVMValueRef offset = LLVMConstInt(ctx->ac.i32, SI_VS_STREAMOUT_BUF0 + i, 0);
 
-         so_buffers[i] = ac_build_load_to_sgpr(&ctx->ac, type, buf_ptr, offset);
+         so_buffers[i] = ac_build_load_to_sgpr(&ctx->ac, arg, offset);
 
          LLVMValueRef so_offset = ac_get_arg(&ctx->ac, ctx->args.streamout_offset[i]);
          so_offset = LLVMBuildMul(builder, so_offset, LLVMConstInt(ctx->ac.i32, 4, 0), "");
@@ -451,10 +450,9 @@ void si_llvm_clipvertex_to_clipdist(struct si_shader_context *ctx,
    unsigned chan;
    unsigned const_chan;
    LLVMValueRef base_elt;
-   LLVMValueRef ptr = ac_get_arg(&ctx->ac, ctx->internal_bindings);
-   LLVMTypeRef type = ac_get_arg_pointee_type(&ctx->ac, &ctx->args, ctx->internal_bindings);
    LLVMValueRef constbuf_index = LLVMConstInt(ctx->ac.i32, SI_VS_CONST_CLIP_PLANES, 0);
-   LLVMValueRef const_resource = ac_build_load_to_sgpr(&ctx->ac, type, ptr, constbuf_index);
+   LLVMValueRef const_resource = ac_build_load_to_sgpr(
+      &ctx->ac, ac_get_ptr_arg(&ctx->ac, &ctx->args, ctx->internal_bindings), constbuf_index);
    unsigned clipdist_mask = ctx->shader->selector->info.clipdist_mask &
                             ~ctx->shader->key.ge.opt.kill_clip_distances;
 
@@ -815,11 +813,9 @@ void si_llvm_build_vs_exports(struct si_shader_context *ctx, LLVMValueRef num_ex
       /* Get the attribute ring address and descriptor. */
       LLVMValueRef attr_address;
       if (ctx->stage == MESA_SHADER_VERTEX && shader->selector->info.base.vs.blit_sgprs_amd) {
-         LLVMValueRef ptr =
-            LLVMBuildPointerCast(ctx->ac.builder,
-                                 ac_get_arg(&ctx->ac, ctx->internal_bindings),
-                                 LLVMPointerType(ctx->ac.i32, AC_ADDR_SPACE_CONST_32BIT), "");
-         attr_address = ac_build_load_to_sgpr(&ctx->ac, ctx->ac.i32, ptr,
+         struct ac_llvm_pointer ring_ptr = ac_get_ptr_arg(&ctx->ac, &ctx->args, ctx->internal_bindings);
+         ring_ptr.pointee_type = ctx->ac.i32;
+         attr_address = ac_build_load_to_sgpr(&ctx->ac, ring_ptr,
                                               LLVMConstInt(ctx->ac.i32, SI_GS_ATTRIBUTE_RING * 4, 0));
       } else {
          attr_address = ac_get_arg(&ctx->ac, ctx->gs_attr_address);
@@ -1039,7 +1035,8 @@ void si_llvm_build_vs_prolog(struct si_shader_context *ctx, union si_shader_part
    if (key->vs_prolog.states.instance_divisor_is_fetched) {
       LLVMValueRef list = si_prolog_get_internal_bindings(ctx);
       LLVMValueRef buf_index = LLVMConstInt(ctx->ac.i32, SI_VS_CONST_INSTANCE_DIVISORS, 0);
-      instance_divisor_constbuf = ac_build_load_to_sgpr(&ctx->ac, ctx->ac.v4i32, list, buf_index);
+      instance_divisor_constbuf = ac_build_load_to_sgpr(&ctx->ac,
+         (struct ac_llvm_pointer) { .v = list, .t = ctx->ac.v4i32 }, buf_index);
    }
 
    for (i = 0; i < key->vs_prolog.num_inputs; i++) {
-- 
GitLab


From ebffeb323f04b9de872afae13d4db5635e09e697 Mon Sep 17 00:00:00 2001
From: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
Date: Tue, 11 Oct 2022 10:33:19 +0200
Subject: [PATCH 26/26] Revert "ac: use LLVMContextSetOpaquePointers if
 available"
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

This reverts commit 940734630de229d98630e4398fd68e95c105177a.

radeonsi and radv now support opaque pointers.

Reviewed-by: Mihai Preda <mhpreda@gmail.com>
Reviewed-by: Dave Airlie <airlied@redhat.com>
Reviewed-by: Qiang Yu <yuq825@gmail.com>
Reviewed-by: Marek Olšák <marek.olsak@amd.com>
Acked-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
---
 src/amd/llvm/ac_llvm_build.c | 3 ---
 1 file changed, 3 deletions(-)

diff --git a/src/amd/llvm/ac_llvm_build.c b/src/amd/llvm/ac_llvm_build.c
index 3cc556e71041..6bdfb2735e87 100644
--- a/src/amd/llvm/ac_llvm_build.c
+++ b/src/amd/llvm/ac_llvm_build.c
@@ -62,9 +62,6 @@ void ac_llvm_context_init(struct ac_llvm_context *ctx, struct ac_llvm_compiler *
                           unsigned ballot_mask_bits)
 {
    ctx->context = LLVMContextCreate();
-   #if LLVM_VERSION_MAJOR >= 15
-   LLVMContextSetOpaquePointers(ctx->context, false);
-   #endif
 
    ctx->gfx_level = gfx_level;
    ctx->family = family;
-- 
GitLab

