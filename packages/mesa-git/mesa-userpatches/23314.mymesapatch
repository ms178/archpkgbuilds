From a6aedaadb73b61fc9a8cf4f7974a16786bc9ed79 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Tue, 30 May 2023 15:47:20 +0800
Subject: [PATCH 1/2] ac/nir,radv: add 1 dword to LS/HS vertex stride

This reduce LDS bank conflict and align with radeonsi,
so we don't assume LDS access 16 byte aligned for both
driver.

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/amd/common/ac_nir_lower_tess_io_to_mem.c | 18 ++++++------------
 src/amd/vulkan/nir/radv_nir_lower_abi.c      |  6 +++++-
 src/amd/vulkan/radv_shader.h                 |  8 ++++++++
 3 files changed, 19 insertions(+), 13 deletions(-)

diff --git a/src/amd/common/ac_nir_lower_tess_io_to_mem.c b/src/amd/common/ac_nir_lower_tess_io_to_mem.c
index d1dbee3e0ae00..29167499e0a30 100644
--- a/src/amd/common/ac_nir_lower_tess_io_to_mem.c
+++ b/src/amd/common/ac_nir_lower_tess_io_to_mem.c
@@ -245,8 +245,7 @@ lower_ls_output_store(nir_builder *b,
    unsigned write_mask = nir_intrinsic_write_mask(intrin);
 
    nir_ssa_def *off = nir_iadd_nuw(b, base_off_var, io_off);
-   nir_store_shared(b, intrin->src[0].ssa, off, .write_mask = write_mask,
-                    .align_mul = 16u, .align_offset = (nir_intrinsic_component(intrin) * 4u) % 16u);
+   nir_store_shared(b, intrin->src[0].ssa, off, .write_mask = write_mask);
 
    /* NOTE: don't remove the store_output intrinsic on GFX9+ when tcs_in_out_eq,
     * it will be used by same-invocation TCS input loads.
@@ -403,8 +402,7 @@ lower_hs_per_vertex_input_load(nir_builder *b,
    nir_intrinsic_instr *intrin = nir_instr_as_intrinsic(instr);
 
    nir_ssa_def *off = hs_per_vertex_input_lds_offset(b, st, intrin);
-   return nir_load_shared(b, intrin->dest.ssa.num_components, intrin->dest.ssa.bit_size, off,
-                          .align_mul = 16u, .align_offset = (nir_intrinsic_component(intrin) * 4u) % 16u);
+   return nir_load_shared(b, intrin->dest.ssa.num_components, intrin->dest.ssa.bit_size, off);
 }
 
 static nir_ssa_def *
@@ -453,8 +451,7 @@ lower_hs_output_store(nir_builder *b,
 
    if (write_to_lds) {
       nir_ssa_def *lds_off = hs_output_lds_offset(b, st, intrin);
-      nir_store_shared(b, store_val, lds_off, .write_mask = write_mask,
-                       .align_mul = 16u, .align_offset = (component * 4u) % 16u);
+      nir_store_shared(b, store_val, lds_off, .write_mask = write_mask);
    }
 
    nir_ssa_def *ret = NIR_LOWER_INSTR_PROGRESS_REPLACE;
@@ -483,8 +480,7 @@ lower_hs_output_load(nir_builder *b,
                      lower_tess_io_state *st)
 {
    nir_ssa_def *off = hs_output_lds_offset(b, st, intrin);
-   return nir_load_shared(b, intrin->dest.ssa.num_components, intrin->dest.ssa.bit_size, off,
-                          .align_mul = 16u, .align_offset = (nir_intrinsic_component(intrin) * 4u) % 16u);
+   return nir_load_shared(b, intrin->dest.ssa.num_components, intrin->dest.ssa.bit_size, off);
 }
 
 static void
@@ -611,14 +607,12 @@ hs_emit_write_tess_factors(nir_shader *shader,
       /* Load all tessellation factors (aka. tess levels) from LDS. */
       if (tess_lvl_out_written) {
          tessfactors_outer = nir_load_shared(b, outer_comps, 32, lds_base,
-                                             .base = st->tcs_tess_lvl_out_loc,
-                                             .align_mul = 16u);
+                                             .base = st->tcs_tess_lvl_out_loc);
       }
 
       if (inner_comps && tess_lvl_in_written) {
          tessfactors_inner = nir_load_shared(b, inner_comps, 32, lds_base,
-                                             .base = st->tcs_tess_lvl_in_loc,
-                                             .align_mul = 16u);
+                                             .base = st->tcs_tess_lvl_in_loc);
       }
    }
 
diff --git a/src/amd/vulkan/nir/radv_nir_lower_abi.c b/src/amd/vulkan/nir/radv_nir_lower_abi.c
index 898affcbdc684..3a7cf9ae5a83b 100644
--- a/src/amd/vulkan/nir/radv_nir_lower_abi.c
+++ b/src/amd/vulkan/nir/radv_nir_lower_abi.c
@@ -277,7 +277,11 @@ lower_abi_instr(nir_builder *b, nir_instr *instr, void *state)
    case nir_intrinsic_load_lshs_vertex_stride_amd: {
       unsigned io_num = stage == MESA_SHADER_VERTEX ? s->info->vs.num_linked_outputs
                                                     : s->info->tcs.num_linked_inputs;
-      replacement = nir_imm_int(b, io_num * 16);
+      unsigned stride = io_num * 16;
+      /* Add 1 dowrd to reduce LDS bank conflicts. */
+      if (stride)
+         stride += 4;
+      replacement = nir_imm_int(b, stride);
       break;
    }
    case nir_intrinsic_load_esgs_vertex_stride_amd: {
diff --git a/src/amd/vulkan/radv_shader.h b/src/amd/vulkan/radv_shader.h
index 5e893e5746994..bc28243b46513 100644
--- a/src/amd/vulkan/radv_shader.h
+++ b/src/amd/vulkan/radv_shader.h
@@ -691,6 +691,10 @@ calculate_tess_lds_size(enum amd_gfx_level gfx_level, unsigned tcs_num_input_ver
    unsigned input_vertex_size = tcs_num_inputs * 16;
    unsigned output_vertex_size = tcs_num_outputs * 16;
 
+   /* Add 1 dowrd to reduce LDS bank conflicts. */
+   if (input_vertex_size)
+      input_vertex_size += 4;
+
    unsigned input_patch_size = tcs_num_input_vertices * input_vertex_size;
 
    unsigned pervertex_output_patch_size = tcs_num_output_vertices * output_vertex_size;
@@ -718,6 +722,10 @@ get_tcs_num_patches(unsigned tcs_num_input_vertices, unsigned tcs_num_output_ver
                     enum amd_gfx_level gfx_level, enum radeon_family family)
 {
    uint32_t input_vertex_size = tcs_num_inputs * 16;
+   /* Add 1 dowrd to reduce LDS bank conflicts. */
+   if (input_vertex_size)
+      input_vertex_size += 4;
+
    uint32_t input_patch_size = tcs_num_input_vertices * input_vertex_size;
    uint32_t output_vertex_size = tcs_num_outputs * 16;
    uint32_t pervertex_output_patch_size = tcs_num_output_vertices * output_vertex_size;
-- 
GitLab


From b360591c241d65e46dd5c0684487af9585548018 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Wed, 31 May 2023 16:33:34 +0800
Subject: [PATCH 2/2] ac/nir,radv: add 1 dword to ES/GS item size

This reduce LDS bank conflict and align with radeonsi,
so we don't assume LDS access 16 byte aligned for both
driver.

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/amd/common/ac_nir_lower_esgs_io_to_mem.c | 6 ++----
 src/amd/vulkan/radv_shader_info.c            | 6 ++++++
 2 files changed, 8 insertions(+), 4 deletions(-)

diff --git a/src/amd/common/ac_nir_lower_esgs_io_to_mem.c b/src/amd/common/ac_nir_lower_esgs_io_to_mem.c
index 45b64177b0985..badeb07db165a 100644
--- a/src/amd/common/ac_nir_lower_esgs_io_to_mem.c
+++ b/src/amd/common/ac_nir_lower_esgs_io_to_mem.c
@@ -166,8 +166,7 @@ lower_es_output_store(nir_builder *b,
       /* GFX9+: ES is merged into GS, data is passed through LDS. */
       nir_ssa_def *vertex_idx = nir_build_load_local_invocation_index(b);
       nir_ssa_def *off = nir_iadd(b, nir_imul_imm(b, vertex_idx, st->esgs_itemsize), io_off);
-      nir_build_store_shared(b, intrin->src[0].ssa, off, .write_mask = write_mask,
-                             .align_mul = 16u, .align_offset = (nir_intrinsic_component(intrin) * 4u) % 16u);
+      nir_build_store_shared(b, intrin->src[0].ssa, off, .write_mask = write_mask);
    }
 
    nir_instr_remove(instr);
@@ -273,8 +272,7 @@ lower_gs_per_vertex_input_load(nir_builder *b,
    nir_ssa_def *off = gs_per_vertex_input_offset(b, st, intrin);
 
    if (st->gfx_level >= GFX9)
-      return nir_build_load_shared(b, intrin->dest.ssa.num_components, intrin->dest.ssa.bit_size, off,
-                                   .align_mul = 16u, .align_offset = (nir_intrinsic_component(intrin) * 4u) % 16u);
+      return nir_build_load_shared(b, intrin->dest.ssa.num_components, intrin->dest.ssa.bit_size, off);
 
    unsigned wave_size = 64u; /* GFX6-8 only support wave64 */
    nir_ssa_def *ring = nir_build_load_ring_esgs_amd(b);
diff --git a/src/amd/vulkan/radv_shader_info.c b/src/amd/vulkan/radv_shader_info.c
index 2deb4496b0ef1..c8f73ad7597fe 100644
--- a/src/amd/vulkan/radv_shader_info.c
+++ b/src/amd/vulkan/radv_shader_info.c
@@ -1478,6 +1478,12 @@ radv_link_shaders_info(struct radv_device *device,
 
          /* Compute the ESGS item size for VS or TES as ES. */
          producer->info.esgs_itemsize = num_outputs_written * 16;
+
+          /* For the ESGS ring in LDS, add 1 dword to reduce LDS bank
+           * conflicts, i.e. each vertex will start on a different bank.
+           */
+         if (device->physical_device->rad_info.gfx_level >= GFX9 && producer->info.esgs_itemsize)
+            producer->info.esgs_itemsize += 4;
       }
 
       /* Compute NGG info (GFX10+) or GS info. */
-- 
GitLab

