From b77bece39ec4414282bae6122bfae25c9942b4ab Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Thu, 4 Jan 2024 22:15:09 -0500
Subject: [PATCH 01/17] gallium/u_threaded: expose helpers for filling
 set_vertex_buffers externally

---
 .../auxiliary/util/u_threaded_context.c       | 37 ++++++++-------
 .../auxiliary/util/u_threaded_context.h       | 45 +++++++++++++++++++
 2 files changed, 63 insertions(+), 19 deletions(-)

diff --git a/src/gallium/auxiliary/util/u_threaded_context.c b/src/gallium/auxiliary/util/u_threaded_context.c
index 8da515805b0f9..53be4a37966e0 100644
--- a/src/gallium/auxiliary/util/u_threaded_context.c
+++ b/src/gallium/auxiliary/util/u_threaded_context.c
@@ -835,22 +835,6 @@ tc_add_to_buffer_list(struct tc_buffer_list *next, struct pipe_resource *buf)
    BITSET_SET(next->buffer_list, id & TC_BUFFER_ID_MASK);
 }
 
-/* Set a buffer binding and add it to the buffer list. */
-static void
-tc_bind_buffer(uint32_t *binding, struct tc_buffer_list *next, struct pipe_resource *buf)
-{
-   uint32_t id = threaded_resource(buf)->buffer_id_unique;
-   *binding = id;
-   BITSET_SET(next->buffer_list, id & TC_BUFFER_ID_MASK);
-}
-
-/* Reset a buffer binding. */
-static void
-tc_unbind_buffer(uint32_t *binding)
-{
-   *binding = 0;
-}
-
 /* Reset a range of buffer binding slots. */
 static void
 tc_unbind_buffers(uint32_t *binding, unsigned count)
@@ -2174,9 +2158,8 @@ tc_call_set_vertex_buffers(struct pipe_context *pipe, void *call)
    return p->base.num_slots;
 }
 
-static void
-tc_set_vertex_buffers(struct pipe_context *_pipe,
-                      unsigned count,
+void
+tc_set_vertex_buffers(struct pipe_context *_pipe, unsigned count,
                       bool take_ownership,
                       const struct pipe_vertex_buffer *buffers)
 {
@@ -2233,6 +2216,22 @@ tc_set_vertex_buffers(struct pipe_context *_pipe,
    tc->num_vertex_buffers = count;
 }
 
+struct pipe_vertex_buffer *
+tc_add_set_vertex_buffers_call(struct pipe_context *_pipe, unsigned count)
+{
+   struct threaded_context *tc = threaded_context(_pipe);
+
+   /* We don't need to unbind trailing buffers because we never touch bindings
+    * after num_vertex_buffers.
+    */
+   tc->num_vertex_buffers = count;
+
+   struct tc_vertex_buffers *p =
+      tc_add_slot_based_call(tc, TC_CALL_set_vertex_buffers, tc_vertex_buffers, count);
+   p->count = count;
+   return p->slot;
+}
+
 struct tc_stream_outputs {
    struct tc_call_base base;
    unsigned count;
diff --git a/src/gallium/auxiliary/util/u_threaded_context.h b/src/gallium/auxiliary/util/u_threaded_context.h
index 8fa6cfd4443d7..ccd94d9b11a48 100644
--- a/src/gallium/auxiliary/util/u_threaded_context.h
+++ b/src/gallium/auxiliary/util/u_threaded_context.h
@@ -692,6 +692,8 @@ threaded_context_flush(struct pipe_context *_pipe,
 struct tc_draw_single *
 tc_add_draw_single_call(struct pipe_context *_pipe,
                         struct pipe_resource *index_bo);
+struct pipe_vertex_buffer *
+tc_add_set_vertex_buffers_call(struct pipe_context *_pipe, unsigned count);
 
 void
 tc_draw_vbo(struct pipe_context *_pipe, const struct pipe_draw_info *info,
@@ -700,6 +702,11 @@ tc_draw_vbo(struct pipe_context *_pipe, const struct pipe_draw_info *info,
             const struct pipe_draw_start_count_bias *draws,
             unsigned num_draws);
 
+void
+tc_set_vertex_buffers(struct pipe_context *_pipe, unsigned count,
+                      bool take_ownership,
+                      const struct pipe_vertex_buffer *buffers);
+
 static inline struct threaded_context *
 threaded_context(struct pipe_context *pipe)
 {
@@ -777,6 +784,44 @@ tc_buffer_write(struct pipe_context *pipe,
    pipe->buffer_subdata(pipe, buf, PIPE_MAP_WRITE | TC_TRANSFER_MAP_NO_INVALIDATE, offset, size, data);
 }
 
+static inline struct tc_buffer_list *
+tc_get_next_buffer_list(struct pipe_context *_pipe)
+{
+   struct threaded_context *tc = threaded_context(_pipe);
+
+   return &tc->buffer_lists[tc->next_buf_list];
+}
+
+/* Set a buffer binding and add it to the buffer list. */
+static inline void
+tc_bind_buffer(uint32_t *binding, struct tc_buffer_list *next, struct pipe_resource *buf)
+{
+   uint32_t id = threaded_resource(buf)->buffer_id_unique;
+   *binding = id;
+   BITSET_SET(next->buffer_list, id & TC_BUFFER_ID_MASK);
+}
+
+/* Reset a buffer binding. */
+static inline void
+tc_unbind_buffer(uint32_t *binding)
+{
+   *binding = 0;
+}
+
+static inline void
+tc_track_vertex_buffer(struct pipe_context *_pipe, unsigned index,
+                         struct pipe_resource *buf,
+                         struct tc_buffer_list *next_buffer_list)
+{
+   struct threaded_context *tc = threaded_context(_pipe);
+
+   if (buf) {
+      tc_bind_buffer(&tc->vertex_buffers[index], next_buffer_list, buf);
+   } else {
+      tc_unbind_buffer(&tc->vertex_buffers[index]);
+   }
+}
+
 #ifdef __cplusplus
 }
 #endif
-- 
GitLab


From fbe8f09f47a38334623187cad1271719c82fd781 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Wed, 3 Jan 2024 20:57:57 -0500
Subject: [PATCH 02/17] st/mesa: rename attribs -> arrays in st_atom_array to
 indicate non-zero strides

---
 src/mesa/state_tracker/st_atom_array.cpp | 54 ++++++++++++------------
 1 file changed, 27 insertions(+), 27 deletions(-)

diff --git a/src/mesa/state_tracker/st_atom_array.cpp b/src/mesa/state_tracker/st_atom_array.cpp
index 74bc6e6e8c5f3..152942caca0b8 100644
--- a/src/mesa/state_tracker/st_atom_array.cpp
+++ b/src/mesa/state_tracker/st_atom_array.cpp
@@ -81,14 +81,14 @@ setup_arrays(struct st_context *st,
              const struct gl_vertex_array_object *vao,
              const GLbitfield dual_slot_inputs,
              const GLbitfield inputs_read,
-             const GLbitfield enabled_attribs,
+             const GLbitfield enabled_arrays,
              struct cso_velems_state *velements,
              struct pipe_vertex_buffer *vbuffer, unsigned *num_vbuffers)
 {
    struct gl_context *ctx = st->ctx;
 
    /* Process attribute array data. */
-   GLbitfield mask = inputs_read & enabled_attribs;
+   GLbitfield mask = inputs_read & enabled_arrays;
 
    if (vao->IsDynamic) {
       while (mask) {
@@ -179,11 +179,11 @@ st_setup_arrays(struct st_context *st,
                 struct pipe_vertex_buffer *vbuffer, unsigned *num_vbuffers)
 {
    struct gl_context *ctx = st->ctx;
-   GLbitfield enabled_attribs = _mesa_get_enabled_vertex_arrays(ctx);
+   GLbitfield enabled_arrays = _mesa_get_enabled_vertex_arrays(ctx);
 
    setup_arrays<POPCNT_NO, UPDATE_ALL>
       (st, ctx->Array._DrawVAO, vp->Base.DualSlotInputs,
-       vp_variant->vert_attrib_mask, enabled_attribs,
+       vp_variant->vert_attrib_mask, enabled_arrays,
        velements, vbuffer, num_vbuffers);
 }
 
@@ -197,14 +197,14 @@ template<util_popcnt POPCNT, st_update_flag UPDATE> void ALWAYS_INLINE
 st_setup_current(struct st_context *st,
                  const GLbitfield inputs_read,
                  const GLbitfield dual_slot_inputs,
-                 const GLbitfield enabled_attribs,
+                 const GLbitfield enabled_arrays,
                  struct cso_velems_state *velements,
                  struct pipe_vertex_buffer *vbuffer, unsigned *num_vbuffers)
 {
    struct gl_context *ctx = st->ctx;
 
    /* Process values that should have better been uniforms in the application */
-   GLbitfield curmask = inputs_read & ~enabled_attribs;
+   GLbitfield curmask = inputs_read & ~enabled_arrays;
    if (curmask) {
       unsigned num_attribs = util_bitcount_fast<POPCNT>(curmask);
       unsigned num_dual_attribs = util_bitcount_fast<POPCNT>(curmask &
@@ -274,12 +274,12 @@ st_setup_current_user(struct st_context *st,
                       struct pipe_vertex_buffer *vbuffer, unsigned *num_vbuffers)
 {
    struct gl_context *ctx = st->ctx;
-   const GLbitfield enabled_attribs = _mesa_get_enabled_vertex_arrays(ctx);
+   const GLbitfield enabled_arrays = _mesa_get_enabled_vertex_arrays(ctx);
    const GLbitfield inputs_read = vp_variant->vert_attrib_mask;
    const GLbitfield dual_slot_inputs = vp->Base.DualSlotInputs;
 
    /* Process values that should have better been uniforms in the application */
-   GLbitfield curmask = inputs_read & ~enabled_attribs;
+   GLbitfield curmask = inputs_read & ~enabled_arrays;
    /* For each attribute, make an own user buffer binding. */
    while (curmask) {
       const gl_vert_attrib attr = (gl_vert_attrib)u_bit_scan(&curmask);
@@ -299,9 +299,9 @@ st_setup_current_user(struct st_context *st,
 
 template<util_popcnt POPCNT, st_update_flag UPDATE> void ALWAYS_INLINE
 st_update_array_templ(struct st_context *st,
-                      const GLbitfield enabled_attribs,
-                      const GLbitfield enabled_user_attribs,
-                      const GLbitfield nonzero_divisor_attribs)
+                      const GLbitfield enabled_arrays,
+                      const GLbitfield enabled_user_arrays,
+                      const GLbitfield nonzero_divisor_arrays)
 {
    struct gl_context *ctx = st->ctx;
 
@@ -312,11 +312,11 @@ st_update_array_templ(struct st_context *st,
    const struct st_common_variant *vp_variant = st->vp_variant;
    const GLbitfield inputs_read = vp_variant->vert_attrib_mask;
    const GLbitfield dual_slot_inputs = vp->Base.DualSlotInputs;
-   const GLbitfield userbuf_attribs = inputs_read & enabled_user_attribs;
-   bool uses_user_vertex_buffers = userbuf_attribs != 0;
+   const GLbitfield userbuf_arrays = inputs_read & enabled_user_arrays;
+   bool uses_user_vertex_buffers = userbuf_arrays != 0;
 
    st->draw_needs_minmax_index =
-      (userbuf_attribs & ~nonzero_divisor_attribs) != 0;
+      (userbuf_arrays & ~nonzero_divisor_arrays) != 0;
 
    struct pipe_vertex_buffer vbuffer[PIPE_MAX_ATTRIBS];
    unsigned num_vbuffers = 0;
@@ -326,12 +326,12 @@ st_update_array_templ(struct st_context *st,
    /* Setup arrays */
    setup_arrays<POPCNT, UPDATE>
       (st, ctx->Array._DrawVAO, dual_slot_inputs, inputs_read,
-       enabled_attribs, &velements, vbuffer, &num_vbuffers);
+       enabled_arrays, &velements, vbuffer, &num_vbuffers);
 
    /* _NEW_CURRENT_ATTRIB */
    /* Setup zero-stride attribs. */
    st_setup_current<POPCNT, UPDATE>(st, inputs_read, dual_slot_inputs,
-                                    enabled_attribs,
+                                    enabled_arrays,
                                     &velements, vbuffer, &num_vbuffers);
 
    struct cso_context *cso = st->cso_context;
@@ -358,9 +358,9 @@ st_update_array_impl(struct st_context *st)
 {
    struct gl_context *ctx = st->ctx;
    struct gl_vertex_array_object *vao = ctx->Array._DrawVAO;
-   const GLbitfield enabled_attribs = _mesa_get_enabled_vertex_arrays(ctx);
-   GLbitfield enabled_user_attribs;
-   GLbitfield nonzero_divisor_attribs;
+   const GLbitfield enabled_arrays = _mesa_get_enabled_vertex_arrays(ctx);
+   GLbitfield enabled_user_arrays;
+   GLbitfield nonzero_divisor_arrays;
 
    assert(vao->_EnabledWithMapMode ==
           _mesa_vao_enable_to_vp_inputs(vao->_AttributeMapMode, vao->Enabled));
@@ -368,8 +368,8 @@ st_update_array_impl(struct st_context *st)
    if (!vao->IsDynamic && !vao->SharedAndImmutable)
       _mesa_update_vao_derived_arrays(ctx, vao);
 
-   _mesa_get_derived_vao_masks(ctx, enabled_attribs, &enabled_user_attribs,
-                               &nonzero_divisor_attribs);
+   _mesa_get_derived_vao_masks(ctx, enabled_arrays, &enabled_user_arrays,
+                               &nonzero_divisor_arrays);
 
    /* Changing from user to non-user buffers and vice versa can switch between
     * cso and u_vbuf, which means that we need to update vertex elements even
@@ -377,12 +377,12 @@ st_update_array_impl(struct st_context *st)
     */
    if (ctx->Array.NewVertexElements ||
        st->uses_user_vertex_buffers !=
-       !!(st->vp_variant->vert_attrib_mask & enabled_user_attribs)) {
+       !!(st->vp_variant->vert_attrib_mask & enabled_user_arrays)) {
       st_update_array_templ<POPCNT, UPDATE_ALL>
-         (st, enabled_attribs, enabled_user_attribs, nonzero_divisor_attribs);
+         (st, enabled_arrays, enabled_user_arrays, nonzero_divisor_arrays);
    } else {
       st_update_array_templ<POPCNT, UPDATE_BUFFERS_ONLY>
-         (st, enabled_attribs, enabled_user_attribs, nonzero_divisor_attribs);
+         (st, enabled_arrays, enabled_user_arrays, nonzero_divisor_arrays);
    }
 }
 
@@ -402,10 +402,10 @@ struct pipe_vertex_state *
 st_create_gallium_vertex_state(struct gl_context *ctx,
                                const struct gl_vertex_array_object *vao,
                                struct gl_buffer_object *indexbuf,
-                               uint32_t enabled_attribs)
+                               uint32_t enabled_arrays)
 {
    struct st_context *st = st_context(ctx);
-   const GLbitfield inputs_read = enabled_attribs;
+   const GLbitfield inputs_read = enabled_arrays;
    const GLbitfield dual_slot_inputs = 0; /* always zero */
    struct pipe_vertex_buffer vbuffer[PIPE_MAX_ATTRIBS];
    unsigned num_vbuffers = 0;
@@ -427,7 +427,7 @@ st_create_gallium_vertex_state(struct gl_context *ctx,
                                   velements.count,
                                   indexbuf ?
                                   indexbuf->buffer : NULL,
-                                  enabled_attribs);
+                                  enabled_arrays);
 
    for (unsigned i = 0; i < num_vbuffers; i++)
       pipe_vertex_buffer_unreference(&vbuffer[i]);
-- 
GitLab


From 606163fdfc72d7642ef38760fba7592355bf7638 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Wed, 3 Jan 2024 21:34:28 -0500
Subject: [PATCH 03/17] st/mesa: do (inputs_read & enabled_arrays) outside
 setup_arrays

---
 src/mesa/state_tracker/st_atom_array.cpp | 9 ++++-----
 1 file changed, 4 insertions(+), 5 deletions(-)

diff --git a/src/mesa/state_tracker/st_atom_array.cpp b/src/mesa/state_tracker/st_atom_array.cpp
index 152942caca0b8..cd560a11e1d94 100644
--- a/src/mesa/state_tracker/st_atom_array.cpp
+++ b/src/mesa/state_tracker/st_atom_array.cpp
@@ -81,15 +81,13 @@ setup_arrays(struct st_context *st,
              const struct gl_vertex_array_object *vao,
              const GLbitfield dual_slot_inputs,
              const GLbitfield inputs_read,
-             const GLbitfield enabled_arrays,
+             GLbitfield mask,
              struct cso_velems_state *velements,
              struct pipe_vertex_buffer *vbuffer, unsigned *num_vbuffers)
 {
    struct gl_context *ctx = st->ctx;
 
    /* Process attribute array data. */
-   GLbitfield mask = inputs_read & enabled_arrays;
-
    if (vao->IsDynamic) {
       while (mask) {
          const gl_vert_attrib attr = (gl_vert_attrib)u_bit_scan(&mask);
@@ -183,7 +181,8 @@ st_setup_arrays(struct st_context *st,
 
    setup_arrays<POPCNT_NO, UPDATE_ALL>
       (st, ctx->Array._DrawVAO, vp->Base.DualSlotInputs,
-       vp_variant->vert_attrib_mask, enabled_arrays,
+       vp_variant->vert_attrib_mask,
+       vp_variant->vert_attrib_mask & enabled_arrays,
        velements, vbuffer, num_vbuffers);
 }
 
@@ -326,7 +325,7 @@ st_update_array_templ(struct st_context *st,
    /* Setup arrays */
    setup_arrays<POPCNT, UPDATE>
       (st, ctx->Array._DrawVAO, dual_slot_inputs, inputs_read,
-       enabled_arrays, &velements, vbuffer, &num_vbuffers);
+       inputs_read & enabled_arrays, &velements, vbuffer, &num_vbuffers);
 
    /* _NEW_CURRENT_ATTRIB */
    /* Setup zero-stride attribs. */
-- 
GitLab


From e78ff78b036a35ea91ea70bb6002b9de0e26c64d Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Wed, 3 Jan 2024 21:38:18 -0500
Subject: [PATCH 04/17] st/mesa: do (inputs_read & ~enabled_arrays) outside
 st_setup_current

also move dual_slot_inputs before inputs_read to match st_setup_array.
---
 src/mesa/state_tracker/st_atom_array.cpp | 9 ++++-----
 1 file changed, 4 insertions(+), 5 deletions(-)

diff --git a/src/mesa/state_tracker/st_atom_array.cpp b/src/mesa/state_tracker/st_atom_array.cpp
index cd560a11e1d94..b779f62f4f7a0 100644
--- a/src/mesa/state_tracker/st_atom_array.cpp
+++ b/src/mesa/state_tracker/st_atom_array.cpp
@@ -194,16 +194,15 @@ st_setup_arrays(struct st_context *st,
  */
 template<util_popcnt POPCNT, st_update_flag UPDATE> void ALWAYS_INLINE
 st_setup_current(struct st_context *st,
-                 const GLbitfield inputs_read,
                  const GLbitfield dual_slot_inputs,
-                 const GLbitfield enabled_arrays,
+                 const GLbitfield inputs_read,
+                 GLbitfield curmask,
                  struct cso_velems_state *velements,
                  struct pipe_vertex_buffer *vbuffer, unsigned *num_vbuffers)
 {
    struct gl_context *ctx = st->ctx;
 
    /* Process values that should have better been uniforms in the application */
-   GLbitfield curmask = inputs_read & ~enabled_arrays;
    if (curmask) {
       unsigned num_attribs = util_bitcount_fast<POPCNT>(curmask);
       unsigned num_dual_attribs = util_bitcount_fast<POPCNT>(curmask &
@@ -329,8 +328,8 @@ st_update_array_templ(struct st_context *st,
 
    /* _NEW_CURRENT_ATTRIB */
    /* Setup zero-stride attribs. */
-   st_setup_current<POPCNT, UPDATE>(st, inputs_read, dual_slot_inputs,
-                                    enabled_arrays,
+   st_setup_current<POPCNT, UPDATE>(st, dual_slot_inputs, inputs_read,
+                                    inputs_read & ~enabled_arrays,
                                     &velements, vbuffer, &num_vbuffers);
 
    struct cso_context *cso = st->cso_context;
-- 
GitLab


From 616516cc92d743f9617f032b769e7076575ea3f6 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Thu, 4 Jan 2024 02:30:11 -0500
Subject: [PATCH 05/17] st/mesa: move a piece of _mesa_draw_array_attrib out of
 the loop in setup_arrays

This inlines _mesa_draw_array_attrib and moves attribute_map out of
the loop. The compiler doesn't do this automatically.
---
 src/mesa/state_tracker/st_atom_array.cpp | 5 ++++-
 1 file changed, 4 insertions(+), 1 deletion(-)

diff --git a/src/mesa/state_tracker/st_atom_array.cpp b/src/mesa/state_tracker/st_atom_array.cpp
index b779f62f4f7a0..d6ecd609dfdbc 100644
--- a/src/mesa/state_tracker/st_atom_array.cpp
+++ b/src/mesa/state_tracker/st_atom_array.cpp
@@ -89,10 +89,13 @@ setup_arrays(struct st_context *st,
 
    /* Process attribute array data. */
    if (vao->IsDynamic) {
+      const GLubyte *attribute_map =
+         _mesa_vao_attribute_map[vao->_AttributeMapMode];
+
       while (mask) {
          const gl_vert_attrib attr = (gl_vert_attrib)u_bit_scan(&mask);
          const struct gl_array_attributes *const attrib =
-            _mesa_draw_array_attrib(vao, attr);
+            &vao->VertexAttrib[attribute_map[attr]];
          const struct gl_vertex_buffer_binding *const binding =
             &vao->BufferBinding[attrib->BufferBindingIndex];
          const unsigned bufidx = (*num_vbuffers)++;
-- 
GitLab


From 99a43a95afdb4ae488ebfc89cc64c5e075413964 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Thu, 4 Jan 2024 11:50:03 -0500
Subject: [PATCH 06/17] st/mesa: cosmetic touchups in st_atom_array.cpp

---
 src/mesa/state_tracker/st_atom_array.cpp | 17 +++++++----------
 1 file changed, 7 insertions(+), 10 deletions(-)

diff --git a/src/mesa/state_tracker/st_atom_array.cpp b/src/mesa/state_tracker/st_atom_array.cpp
index d6ecd609dfdbc..a2dfae5be4c91 100644
--- a/src/mesa/state_tracker/st_atom_array.cpp
+++ b/src/mesa/state_tracker/st_atom_array.cpp
@@ -1,4 +1,3 @@
-
 /**************************************************************************
  *
  * Copyright 2007 VMware, Inc.
@@ -77,7 +76,7 @@ init_velement(struct pipe_vertex_element *velements,
  * on the stack.
  */
 template<util_popcnt POPCNT, st_update_flag UPDATE> void ALWAYS_INLINE
-setup_arrays(struct st_context *st,
+setup_arrays(struct gl_context *ctx,
              const struct gl_vertex_array_object *vao,
              const GLbitfield dual_slot_inputs,
              const GLbitfield inputs_read,
@@ -85,8 +84,6 @@ setup_arrays(struct st_context *st,
              struct cso_velems_state *velements,
              struct pipe_vertex_buffer *vbuffer, unsigned *num_vbuffers)
 {
-   struct gl_context *ctx = st->ctx;
-
    /* Process attribute array data. */
    if (vao->IsDynamic) {
       const GLubyte *attribute_map =
@@ -183,7 +180,7 @@ st_setup_arrays(struct st_context *st,
    GLbitfield enabled_arrays = _mesa_get_enabled_vertex_arrays(ctx);
 
    setup_arrays<POPCNT_NO, UPDATE_ALL>
-      (st, ctx->Array._DrawVAO, vp->Base.DualSlotInputs,
+      (ctx, ctx->Array._DrawVAO, vp->Base.DualSlotInputs,
        vp_variant->vert_attrib_mask,
        vp_variant->vert_attrib_mask & enabled_arrays,
        velements, vbuffer, num_vbuffers);
@@ -203,10 +200,9 @@ st_setup_current(struct st_context *st,
                  struct cso_velems_state *velements,
                  struct pipe_vertex_buffer *vbuffer, unsigned *num_vbuffers)
 {
-   struct gl_context *ctx = st->ctx;
-
    /* Process values that should have better been uniforms in the application */
    if (curmask) {
+      struct gl_context *ctx = st->ctx;
       unsigned num_attribs = util_bitcount_fast<POPCNT>(curmask);
       unsigned num_dual_attribs = util_bitcount_fast<POPCNT>(curmask &
                                                              dual_slot_inputs);
@@ -326,7 +322,7 @@ st_update_array_templ(struct st_context *st,
    /* ST_NEW_VERTEX_ARRAYS */
    /* Setup arrays */
    setup_arrays<POPCNT, UPDATE>
-      (st, ctx->Array._DrawVAO, dual_slot_inputs, inputs_read,
+      (ctx, ctx->Array._DrawVAO, dual_slot_inputs, inputs_read,
        inputs_read & enabled_arrays, &velements, vbuffer, &num_vbuffers);
 
    /* _NEW_CURRENT_ATTRIB */
@@ -412,8 +408,9 @@ st_create_gallium_vertex_state(struct gl_context *ctx,
    unsigned num_vbuffers = 0;
    struct cso_velems_state velements;
 
-   setup_arrays<POPCNT_NO, UPDATE_ALL>(st, vao, dual_slot_inputs, inputs_read,
-                                inputs_read, &velements, vbuffer, &num_vbuffers);
+   setup_arrays<POPCNT_NO, UPDATE_ALL>
+      (ctx, vao, dual_slot_inputs, inputs_read, inputs_read, &velements,
+       vbuffer, &num_vbuffers);
 
    if (num_vbuffers != 1) {
       assert(!"this should never happen with display lists");
-- 
GitLab


From a04aee2fccc3cc4410b68e76e09660ed1a2ade9d Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Thu, 4 Jan 2024 12:25:44 -0500
Subject: [PATCH 07/17] st/mesa: change the update enum of vertex elements

more enums will be added following the ON/OFF pattern.
---
 src/mesa/state_tracker/st_atom_array.cpp | 36 ++++++++++++------------
 1 file changed, 18 insertions(+), 18 deletions(-)

diff --git a/src/mesa/state_tracker/st_atom_array.cpp b/src/mesa/state_tracker/st_atom_array.cpp
index a2dfae5be4c91..3bc4cda9c8279 100644
--- a/src/mesa/state_tracker/st_atom_array.cpp
+++ b/src/mesa/state_tracker/st_atom_array.cpp
@@ -48,9 +48,9 @@
 #include "main/varray.h"
 #include "main/arrayobj.h"
 
-enum st_update_flag {
-   UPDATE_ALL,
-   UPDATE_BUFFERS_ONLY,
+enum st_update_velems {
+   UPDATE_VELEMS_OFF,         /* specialized version (faster) */
+   UPDATE_VELEMS_ON,          /* always works */
 };
 
 /* Always inline the non-64bit element code, so that the compiler can see
@@ -75,7 +75,7 @@ init_velement(struct pipe_vertex_element *velements,
 /* ALWAYS_INLINE helps the compiler realize that most of the parameters are
  * on the stack.
  */
-template<util_popcnt POPCNT, st_update_flag UPDATE> void ALWAYS_INLINE
+template<util_popcnt POPCNT, st_update_velems UPDATE_VELEMS> void ALWAYS_INLINE
 setup_arrays(struct gl_context *ctx,
              const struct gl_vertex_array_object *vao,
              const GLbitfield dual_slot_inputs,
@@ -110,7 +110,7 @@ setup_arrays(struct gl_context *ctx,
             vbuffer[bufidx].buffer_offset = 0;
          }
 
-         if (UPDATE == UPDATE_BUFFERS_ONLY)
+         if (!UPDATE_VELEMS)
             continue;
 
          /* Set the vertex element. */
@@ -151,7 +151,7 @@ setup_arrays(struct gl_context *ctx,
       /* We can assume that we have array for the binding */
       assert(attrmask);
 
-      if (UPDATE == UPDATE_BUFFERS_ONLY)
+      if (!UPDATE_VELEMS)
          continue;
 
       /* Walk attributes belonging to the binding */
@@ -179,7 +179,7 @@ st_setup_arrays(struct st_context *st,
    struct gl_context *ctx = st->ctx;
    GLbitfield enabled_arrays = _mesa_get_enabled_vertex_arrays(ctx);
 
-   setup_arrays<POPCNT_NO, UPDATE_ALL>
+   setup_arrays<POPCNT_NO, UPDATE_VELEMS_ON>
       (ctx, ctx->Array._DrawVAO, vp->Base.DualSlotInputs,
        vp_variant->vert_attrib_mask,
        vp_variant->vert_attrib_mask & enabled_arrays,
@@ -192,7 +192,7 @@ st_setup_arrays(struct st_context *st,
  * Return the index of the vertex buffer where current attribs have been
  * uploaded.
  */
-template<util_popcnt POPCNT, st_update_flag UPDATE> void ALWAYS_INLINE
+template<util_popcnt POPCNT, st_update_velems UPDATE_VELEMS> void ALWAYS_INLINE
 st_setup_current(struct st_context *st,
                  const GLbitfield dual_slot_inputs,
                  const GLbitfield inputs_read,
@@ -248,7 +248,7 @@ st_setup_current(struct st_context *st,
          assert(size % 4 == 0); /* assume a hw-friendly alignment */
          memcpy(cursor, attrib->Ptr, size);
 
-         if (UPDATE == UPDATE_ALL) {
+         if (UPDATE_VELEMS) {
             init_velement(velements->velems, &attrib->Format, cursor - ptr,
                           0, 0, bufidx, dual_slot_inputs & BITFIELD_BIT(attr),
                           util_bitcount_fast<POPCNT>(inputs_read & BITFIELD_MASK(attr)));
@@ -294,7 +294,7 @@ st_setup_current_user(struct st_context *st,
    }
 }
 
-template<util_popcnt POPCNT, st_update_flag UPDATE> void ALWAYS_INLINE
+template<util_popcnt POPCNT, st_update_velems UPDATE_VELEMS> void ALWAYS_INLINE
 st_update_array_templ(struct st_context *st,
                       const GLbitfield enabled_arrays,
                       const GLbitfield enabled_user_arrays,
@@ -321,19 +321,19 @@ st_update_array_templ(struct st_context *st,
 
    /* ST_NEW_VERTEX_ARRAYS */
    /* Setup arrays */
-   setup_arrays<POPCNT, UPDATE>
+   setup_arrays<POPCNT, UPDATE_VELEMS>
       (ctx, ctx->Array._DrawVAO, dual_slot_inputs, inputs_read,
        inputs_read & enabled_arrays, &velements, vbuffer, &num_vbuffers);
 
    /* _NEW_CURRENT_ATTRIB */
    /* Setup zero-stride attribs. */
-   st_setup_current<POPCNT, UPDATE>(st, dual_slot_inputs, inputs_read,
-                                    inputs_read & ~enabled_arrays,
-                                    &velements, vbuffer, &num_vbuffers);
+   st_setup_current<POPCNT, UPDATE_VELEMS>
+      (st, dual_slot_inputs, inputs_read, inputs_read & ~enabled_arrays,
+       &velements, vbuffer, &num_vbuffers);
 
    struct cso_context *cso = st->cso_context;
 
-   if (UPDATE == UPDATE_ALL) {
+   if (UPDATE_VELEMS) {
       velements.count = vp->num_inputs + vp_variant->key.passthrough_edgeflags;
 
       /* Set vertex buffers and elements. */
@@ -375,10 +375,10 @@ st_update_array_impl(struct st_context *st)
    if (ctx->Array.NewVertexElements ||
        st->uses_user_vertex_buffers !=
        !!(st->vp_variant->vert_attrib_mask & enabled_user_arrays)) {
-      st_update_array_templ<POPCNT, UPDATE_ALL>
+      st_update_array_templ<POPCNT, UPDATE_VELEMS_ON>
          (st, enabled_arrays, enabled_user_arrays, nonzero_divisor_arrays);
    } else {
-      st_update_array_templ<POPCNT, UPDATE_BUFFERS_ONLY>
+      st_update_array_templ<POPCNT, UPDATE_VELEMS_OFF>
          (st, enabled_arrays, enabled_user_arrays, nonzero_divisor_arrays);
    }
 }
@@ -408,7 +408,7 @@ st_create_gallium_vertex_state(struct gl_context *ctx,
    unsigned num_vbuffers = 0;
    struct cso_velems_state velements;
 
-   setup_arrays<POPCNT_NO, UPDATE_ALL>
+   setup_arrays<POPCNT_NO, UPDATE_VELEMS_ON>
       (ctx, vao, dual_slot_inputs, inputs_read, inputs_read, &velements,
        vbuffer, &num_vbuffers);
 
-- 
GitLab


From 5ee1f8e9ba6d472c15ae76033629f65bd0a877f8 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Sat, 24 Dec 2022 12:51:16 -0500
Subject: [PATCH 08/17] st/mesa: move st_update_functions into st_context

st_update_array will be set differently based on driver CAPs.
---
 src/mesa/state_tracker/st_context.c | 28 ++++++++++------------------
 src/mesa/state_tracker/st_context.h |  8 ++++----
 src/mesa/state_tracker/st_util.h    |  8 +++++---
 3 files changed, 19 insertions(+), 25 deletions(-)

diff --git a/src/mesa/state_tracker/st_context.c b/src/mesa/state_tracker/st_context.c
index ad0608c2d6f4c..54e01352e8407 100644
--- a/src/mesa/state_tracker/st_context.c
+++ b/src/mesa/state_tracker/st_context.c
@@ -71,22 +71,6 @@
 
 DEBUG_GET_ONCE_BOOL_OPTION(mesa_mvp_dp4, "MESA_MVP_DP4", false)
 
-/* The list of state update functions. */
-st_update_func_t st_update_functions[ST_NUM_ATOMS];
-
-static void
-init_atoms_once(void)
-{
-   STATIC_ASSERT(ARRAY_SIZE(st_update_functions) <= 64);
-
-#define ST_STATE(FLAG, st_update) st_update_functions[FLAG##_INDEX] = st_update;
-#include "st_atom_list.h"
-#undef ST_STATE
-
-   if (util_get_cpu_caps()->has_popcnt)
-      st_update_functions[ST_NEW_VERTEX_ARRAYS_INDEX] = st_update_array_with_popcnt;
-}
-
 void
 st_invalidate_buffers(struct st_context *st)
 {
@@ -486,8 +470,16 @@ st_create_context_priv(struct gl_context *ctx, struct pipe_context *pipe,
    st->cso_context = cso_create_context(pipe, cso_flags);
    ctx->cso_context = st->cso_context;
 
-   static once_flag flag = ONCE_FLAG_INIT;
-   call_once(&flag, init_atoms_once);
+   STATIC_ASSERT(ARRAY_SIZE(st->update_functions) <= 64);
+
+#define ST_STATE(FLAG, st_update) st->update_functions[FLAG##_INDEX] = st_update;
+#include "st_atom_list.h"
+#undef ST_STATE
+
+   if (util_get_cpu_caps()->has_popcnt) {
+      st->update_functions[ST_NEW_VERTEX_ARRAYS_INDEX] =
+         st_update_array_with_popcnt;
+   }
 
    st_init_clear(st);
    {
diff --git a/src/mesa/state_tracker/st_context.h b/src/mesa/state_tracker/st_context.h
index 45a71b77d0c4a..3cdcdb58994ad 100644
--- a/src/mesa/state_tracker/st_context.h
+++ b/src/mesa/state_tracker/st_context.h
@@ -120,6 +120,7 @@ struct st_zombie_shader_node
    struct list_head node;
 };
 
+typedef void (*st_update_func_t)(struct st_context *st);
 
 struct st_context
 {
@@ -128,6 +129,9 @@ struct st_context
    struct pipe_context *pipe;
    struct cso_context *cso_context;
 
+   /* The list of state update functions. */
+   st_update_func_t update_functions[ST_NUM_ATOMS];
+
    struct pipe_frontend_screen *frontend_screen; /* e.g. dri_screen */
    void *frontend_context; /* e.g. dri_context */
 
@@ -514,10 +518,6 @@ st_api_destroy_drawable(struct pipe_frontend_drawable *drawable);
 void
 st_screen_destroy(struct pipe_frontend_screen *fscreen);
 
-typedef void (*st_update_func_t)(struct st_context *st);
-
-extern st_update_func_t st_update_functions[ST_NUM_ATOMS];
-
 #ifdef __cplusplus
 }
 #endif
diff --git a/src/mesa/state_tracker/st_util.h b/src/mesa/state_tracker/st_util.h
index 48d2d92f69597..73179e7da6460 100644
--- a/src/mesa/state_tracker/st_util.h
+++ b/src/mesa/state_tracker/st_util.h
@@ -124,18 +124,20 @@ st_validate_state(struct st_context *st, uint64_t pipeline_state_mask)
        * x86_64: u_bit_scan64 is negligibly faster than u_bit_scan
        * i386:   u_bit_scan64 is noticably slower than u_bit_scan
        */
+      st_update_func_t *update_state = st->update_functions;
+
       if (sizeof(void*) == 8) {
          while (dirty)
-            st_update_functions[u_bit_scan64(&dirty)](st);
+            update_state[u_bit_scan64(&dirty)](st);
       } else {
          /* Split u_bit_scan64 into 2x u_bit_scan32 for i386. */
          uint32_t dirty_lo = dirty;
          uint32_t dirty_hi = dirty >> 32;
 
          while (dirty_lo)
-            st_update_functions[u_bit_scan(&dirty_lo)](st);
+            update_state[u_bit_scan(&dirty_lo)](st);
          while (dirty_hi)
-            st_update_functions[32 + u_bit_scan(&dirty_hi)](st);
+            update_state[32 + u_bit_scan(&dirty_hi)](st);
       }
    }
 }
-- 
GitLab


From 46f8f95a4817d5cf904cc284dd070e56da508f77 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Sat, 31 Dec 2022 12:35:37 -0500
Subject: [PATCH 09/17] st/mesa: constify the pipe_draw_info parameter and
 remove obsolete comments

---
 src/gallium/auxiliary/cso_cache/cso_context.h |  2 +-
 src/mesa/main/dd.h                            | 13 +++----------
 src/mesa/state_tracker/st_draw.c              | 10 ++++++----
 src/mesa/state_tracker/st_draw.h              |  4 ++--
 src/mesa/state_tracker/st_draw_feedback.c     |  2 +-
 5 files changed, 13 insertions(+), 18 deletions(-)

diff --git a/src/gallium/auxiliary/cso_cache/cso_context.h b/src/gallium/auxiliary/cso_cache/cso_context.h
index fcd3585718b40..a6de7a7144664 100644
--- a/src/gallium/auxiliary/cso_cache/cso_context.h
+++ b/src/gallium/auxiliary/cso_cache/cso_context.h
@@ -220,7 +220,7 @@ cso_draw_arrays(struct cso_context *cso, unsigned mode, unsigned start, unsigned
 
 static ALWAYS_INLINE void
 cso_draw_vbo(struct cso_context *cso,
-             struct pipe_draw_info *info,
+             const struct pipe_draw_info *info,
              unsigned drawid_offset,
              const struct pipe_draw_indirect_info *indirect,
              const struct pipe_draw_start_count_bias *draws,
diff --git a/src/mesa/main/dd.h b/src/mesa/main/dd.h
index fea734db1e7c5..87f8978a8f35f 100644
--- a/src/mesa/main/dd.h
+++ b/src/mesa/main/dd.h
@@ -143,20 +143,13 @@ struct dd_function_table {
     */
 
    /**
-    * Optimal Gallium version of Draw() that doesn't require translation
-    * of draw info in the state tracker.
+    * The basic draw function used to implement glDrawArrays, glDrawElements,
+    * multidraws, and instancing.
     *
     * The interface is identical to pipe_context::draw_vbo.
-    *
-    * "info" is not const and the following fields can be changed by
-    * the callee, so callers should be aware:
-    * - info->index_bounds_valid (if false)
-    * - info->min_index (if index_bounds_valid is false)
-    * - info->max_index (if index_bounds_valid is false)
-    * - info->drawid (if increment_draw_id is true)
     */
    void (*DrawGallium)(struct gl_context *ctx,
-                       struct pipe_draw_info *info,
+                       const struct pipe_draw_info *info,
                        unsigned drawid_offset,
                        const struct pipe_draw_indirect_info *indirect,
                        const struct pipe_draw_start_count_bias *draws,
diff --git a/src/mesa/state_tracker/st_draw.c b/src/mesa/state_tracker/st_draw.c
index f310efe781026..493a969a70ddd 100644
--- a/src/mesa/state_tracker/st_draw.c
+++ b/src/mesa/state_tracker/st_draw.c
@@ -113,7 +113,7 @@ st_prepare_draw(struct gl_context *ctx, uint64_t state_mask)
 
 void
 st_draw_gallium(struct gl_context *ctx,
-                struct pipe_draw_info *info,
+                const struct pipe_draw_info *info,
                 unsigned drawid_offset,
                 const struct pipe_draw_indirect_info *indirect,
                 const struct pipe_draw_start_count_bias *draws,
@@ -437,7 +437,7 @@ st_draw_quad(struct st_context *st,
 
 static void
 st_hw_select_draw_gallium(struct gl_context *ctx,
-                          struct pipe_draw_info *info,
+                          const struct pipe_draw_info *info,
                           unsigned drawid_offset,
                           const struct pipe_draw_indirect_info *indirect,
                           const struct pipe_draw_start_count_bias *draws,
@@ -447,12 +447,14 @@ st_hw_select_draw_gallium(struct gl_context *ctx,
    enum mesa_prim old_mode = info->mode;
 
    if (st_draw_hw_select_prepare_common(ctx) &&
-       st_draw_hw_select_prepare_mode(ctx, info)) {
+       /* Removing "const" is fine because we restore the changed mode
+        * at the end. */
+       st_draw_hw_select_prepare_mode(ctx, ((struct pipe_draw_info*)info))) {
       cso_draw_vbo(st->cso_context, info, drawid_offset, indirect, draws,
                    num_draws);
    }
 
-   info->mode = old_mode;
+   ((struct pipe_draw_info*)info)->mode = old_mode;
 }
 
 static void
diff --git a/src/mesa/state_tracker/st_draw.h b/src/mesa/state_tracker/st_draw.h
index fb847a86b5791..6bcaa02cb1446 100644
--- a/src/mesa/state_tracker/st_draw.h
+++ b/src/mesa/state_tracker/st_draw.h
@@ -48,7 +48,7 @@ struct draw_context *st_get_draw_context(struct st_context *st);
 
 void
 st_feedback_draw_vbo(struct gl_context *ctx,
-                     struct pipe_draw_info *info,
+                     const struct pipe_draw_info *info,
                      unsigned drawid_offset,
                      const struct pipe_draw_indirect_info *indirect,
                      const struct pipe_draw_start_count_bias *draws,
@@ -79,7 +79,7 @@ st_prepare_draw(struct gl_context *ctx, uint64_t state_mask);
 
 void
 st_draw_gallium(struct gl_context *ctx,
-                struct pipe_draw_info *info,
+                const struct pipe_draw_info *info,
                 unsigned drawid_offset,
                 const struct pipe_draw_indirect_info *indirect,
                 const struct pipe_draw_start_count_bias *draws,
diff --git a/src/mesa/state_tracker/st_draw_feedback.c b/src/mesa/state_tracker/st_draw_feedback.c
index 725062653c6ed..db98fe008f402 100644
--- a/src/mesa/state_tracker/st_draw_feedback.c
+++ b/src/mesa/state_tracker/st_draw_feedback.c
@@ -93,7 +93,7 @@ set_feedback_vertex_format(struct gl_context *ctx)
  */
 void
 st_feedback_draw_vbo(struct gl_context *ctx,
-                     struct pipe_draw_info *info,
+                     const struct pipe_draw_info *info,
                      unsigned drawid_offset,
                      const struct pipe_draw_indirect_info *indirect,
                      const struct pipe_draw_start_count_bias *draws,
-- 
GitLab


From 635a861141940dcafc6be528e7e6d0d7929d674e Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Sat, 31 Dec 2022 13:01:17 -0500
Subject: [PATCH 10/17] mesa: inline {Create,Draw}GalliumVertexState callbacks

They are always constant.
---
 src/mesa/main/consts_exts.h            |  4 +++
 src/mesa/main/dd.h                     | 13 --------
 src/mesa/state_tracker/st_draw.c       | 42 --------------------------
 src/mesa/state_tracker/st_extensions.c |  3 ++
 src/mesa/vbo/vbo_save_api.c            | 10 +++---
 src/mesa/vbo/vbo_save_draw.c           | 38 ++++++++++++++++++-----
 6 files changed, 42 insertions(+), 68 deletions(-)

diff --git a/src/mesa/main/consts_exts.h b/src/mesa/main/consts_exts.h
index 657df07132417..1101f7b9680e8 100644
--- a/src/mesa/main/consts_exts.h
+++ b/src/mesa/main/consts_exts.h
@@ -1018,5 +1018,9 @@ struct gl_constants
 
    /** Allow GLThread to convert glBuffer */
    bool AllowGLThreadBufferSubDataOpt;
+
+   /** Whether pipe_context::draw_vertex_state is supported. */
+   bool HasDrawVertexState;
 };
+
 #endif
diff --git a/src/mesa/main/dd.h b/src/mesa/main/dd.h
index 87f8978a8f35f..c97e7182d519d 100644
--- a/src/mesa/main/dd.h
+++ b/src/mesa/main/dd.h
@@ -169,21 +169,8 @@ struct dd_function_table {
                                 const struct pipe_draw_start_count_bias *draws,
                                 const unsigned char *mode,
                                 unsigned num_draws);
-
-   void (*DrawGalliumVertexState)(struct gl_context *ctx,
-                                  struct pipe_vertex_state *state,
-                                  struct pipe_draw_vertex_state_info info,
-                                  const struct pipe_draw_start_count_bias *draws,
-                                  const uint8_t *mode,
-                                  unsigned num_draws);
    /*@}*/
 
-   struct pipe_vertex_state *
-      (*CreateGalliumVertexState)(struct gl_context *ctx,
-                                  const struct gl_vertex_array_object *vao,
-                                  struct gl_buffer_object *indexbuf,
-                                  uint32_t enabled_attribs);
-
    /**
     * \name Support for multiple T&L engines
     */
diff --git a/src/mesa/state_tracker/st_draw.c b/src/mesa/state_tracker/st_draw.c
index 493a969a70ddd..f9246c2f7282c 100644
--- a/src/mesa/state_tracker/st_draw.c
+++ b/src/mesa/state_tracker/st_draw.c
@@ -271,43 +271,6 @@ st_indirect_draw_vbo(struct gl_context *ctx,
       _mesa_flush(ctx);
 }
 
-static void
-st_draw_gallium_vertex_state(struct gl_context *ctx,
-                             struct pipe_vertex_state *state,
-                             struct pipe_draw_vertex_state_info info,
-                             const struct pipe_draw_start_count_bias *draws,
-                             const uint8_t *mode,
-                             unsigned num_draws)
-{
-   struct st_context *st = st_context(ctx);
-
-   st_prepare_draw(ctx, ST_PIPELINE_RENDER_STATE_MASK_NO_VARRAYS);
-
-   struct pipe_context *pipe = st->pipe;
-   uint32_t velem_mask = ctx->VertexProgram._Current->info.inputs_read;
-
-   if (!mode) {
-      pipe->draw_vertex_state(pipe, state, velem_mask, info, draws, num_draws);
-   } else {
-      /* Find consecutive draws where mode doesn't vary. */
-      for (unsigned i = 0, first = 0; i <= num_draws; i++) {
-         if (i == num_draws || mode[i] != mode[first]) {
-            unsigned current_num_draws = i - first;
-
-            /* Increase refcount to be able to use take_vertex_state_ownership
-             * with all draws.
-             */
-            if (i != num_draws && info.take_vertex_state_ownership)
-               p_atomic_inc(&state->reference.count);
-
-            info.mode = mode[first];
-            pipe->draw_vertex_state(pipe, state, velem_mask, info, &draws[first],
-                                    current_num_draws);
-            first = i;
-         }
-      }
-   }
-}
 
 void
 st_init_draw_functions(struct pipe_screen *screen,
@@ -315,11 +278,6 @@ st_init_draw_functions(struct pipe_screen *screen,
 {
    functions->DrawGallium = st_draw_gallium;
    functions->DrawGalliumMultiMode = st_draw_gallium_multimode;
-
-   if (screen->get_param(screen, PIPE_CAP_DRAW_VERTEX_STATE)) {
-      functions->DrawGalliumVertexState = st_draw_gallium_vertex_state;
-      functions->CreateGalliumVertexState = st_create_gallium_vertex_state;
-   }
 }
 
 
diff --git a/src/mesa/state_tracker/st_extensions.c b/src/mesa/state_tracker/st_extensions.c
index 1b36fcf68dcba..5e76a8bd1fc91 100644
--- a/src/mesa/state_tracker/st_extensions.c
+++ b/src/mesa/state_tracker/st_extensions.c
@@ -626,6 +626,9 @@ void st_init_limits(struct pipe_screen *screen,
 
    c->AllowGLThreadBufferSubDataOpt =
       screen->get_param(screen, PIPE_CAP_ALLOW_GLTHREAD_BUFFER_SUBDATA_OPT);
+
+   c->HasDrawVertexState =
+      screen->get_param(screen, PIPE_CAP_DRAW_VERTEX_STATE);
 }
 
 
diff --git a/src/mesa/vbo/vbo_save_api.c b/src/mesa/vbo/vbo_save_api.c
index b609a26246109..9cbb79badb89d 100644
--- a/src/mesa/vbo/vbo_save_api.c
+++ b/src/mesa/vbo/vbo_save_api.c
@@ -953,16 +953,16 @@ end:
       _mesa_reference_vao(ctx, &node->cold->VAO[vpm], save->VAO[vpm]);
    }
 
-   /* Prepare for DrawGalliumVertexState */
-   if (node->num_draws && ctx->Driver.DrawGalliumVertexState) {
+   /* Prepare for draw_vertex_state. */
+   if (node->num_draws && ctx->Const.HasDrawVertexState) {
       for (unsigned i = 0; i < VP_MODE_MAX; i++) {
          uint32_t enabled_attribs = _vbo_get_vao_filter(i) &
                                     node->cold->VAO[i]->_EnabledWithMapMode;
 
          node->state[i] =
-            ctx->Driver.CreateGalliumVertexState(ctx, node->cold->VAO[i],
-                                                 node->cold->ib.obj,
-                                                 enabled_attribs);
+            st_create_gallium_vertex_state(ctx, node->cold->VAO[i],
+                                           node->cold->ib.obj,
+                                           enabled_attribs);
          node->private_refcount[i] = 0;
          node->enabled_attribs[i] = enabled_attribs;
       }
diff --git a/src/mesa/vbo/vbo_save_draw.c b/src/mesa/vbo/vbo_save_draw.c
index 0923db73514d9..d5e640288d108 100644
--- a/src/mesa/vbo/vbo_save_draw.c
+++ b/src/mesa/vbo/vbo_save_draw.c
@@ -39,6 +39,7 @@
 #include "main/varray.h"
 #include "util/bitscan.h"
 #include "state_tracker/st_draw.h"
+#include "pipe/p_context.h"
 
 #include "vbo_private.h"
 
@@ -199,7 +200,7 @@ vbo_save_playback_vertex_list_gallium(struct gl_context *ctx,
    /* Don't use this if selection or feedback mode is enabled. st/mesa can't
     * handle it.
     */
-   if (!ctx->Driver.DrawGalliumVertexState || ctx->RenderMode != GL_RENDER)
+   if (!ctx->Const.HasDrawVertexState || ctx->RenderMode != GL_RENDER)
       return USE_SLOW_PATH;
 
    const gl_vertex_processing_mode mode = ctx->VertexProgram._VPMode;
@@ -280,16 +281,37 @@ vbo_save_playback_vertex_list_gallium(struct gl_context *ctx,
    /* Set edge flags. */
    _mesa_update_edgeflag_state_explicit(ctx, enabled & VERT_BIT_EDGEFLAG);
 
+   st_prepare_draw(ctx, ST_PIPELINE_RENDER_STATE_MASK_NO_VARRAYS);
+
+   struct pipe_context *pipe = ctx->pipe;
+   uint32_t velem_mask = ctx->VertexProgram._Current->info.inputs_read;
+
    /* Fast path using a pre-built gallium vertex buffer state. */
    if (node->modes || node->num_draws > 1) {
-      ctx->Driver.DrawGalliumVertexState(ctx, state, info,
-                                         node->start_counts,
-                                         node->modes,
-                                         node->num_draws);
+      const struct pipe_draw_start_count_bias *draws = node->start_counts;
+      const uint8_t *mode = node->modes;
+      unsigned num_draws = node->num_draws;
+
+      /* Find consecutive draws where mode doesn't vary. */
+      for (unsigned i = 0, first = 0; i <= num_draws; i++) {
+         if (i == num_draws || mode[i] != mode[first]) {
+            unsigned current_num_draws = i - first;
+
+            /* Increase refcount to be able to use take_vertex_state_ownership
+             * with all draws.
+             */
+            if (i != num_draws && info.take_vertex_state_ownership)
+               p_atomic_inc(&state->reference.count);
+
+            info.mode = mode[first];
+            pipe->draw_vertex_state(pipe, state, velem_mask, info, &draws[first],
+                                    current_num_draws);
+            first = i;
+         }
+      }
    } else if (node->num_draws) {
-      ctx->Driver.DrawGalliumVertexState(ctx, state, info,
-                                         &node->start_count,
-                                         NULL, 1);
+      pipe->draw_vertex_state(pipe, state, velem_mask, info,
+                              &node->start_count, 1);
    }
 
    /* Restore edge flag state and ctx->VertexProgram._VaryingInputs. */
-- 
GitLab


From d06024f250cdcb93dedb5aa3968ec0ad50ffe8cb Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Thu, 4 Jan 2024 18:58:44 -0500
Subject: [PATCH 11/17] mesa: inline _mesa_set_vao_immutable

---
 src/mesa/main/arrayobj.c    | 9 ---------
 src/mesa/main/arrayobj.h    | 9 ---------
 src/mesa/vbo/vbo_save_api.c | 3 ++-
 3 files changed, 2 insertions(+), 19 deletions(-)

diff --git a/src/mesa/main/arrayobj.c b/src/mesa/main/arrayobj.c
index 33fbed678ac3e..cb623024b8d45 100644
--- a/src/mesa/main/arrayobj.c
+++ b/src/mesa/main/arrayobj.c
@@ -798,15 +798,6 @@ _mesa_update_vao_derived_arrays(struct gl_context *ctx,
 }
 
 
-void
-_mesa_set_vao_immutable(struct gl_context *ctx,
-                        struct gl_vertex_array_object *vao)
-{
-   _mesa_update_vao_derived_arrays(ctx, vao);
-   vao->SharedAndImmutable = true;
-}
-
-
 /**
  * Map buffer objects used in attribute arrays.
  */
diff --git a/src/mesa/main/arrayobj.h b/src/mesa/main/arrayobj.h
index 3edb4252c918e..87c86b5a1489a 100644
--- a/src/mesa/main/arrayobj.h
+++ b/src/mesa/main/arrayobj.h
@@ -91,15 +91,6 @@ extern void
 _mesa_update_vao_derived_arrays(struct gl_context *ctx,
                                 struct gl_vertex_array_object *vao);
 
-
-/**
- * Mark the vao as shared and immutable, do remaining updates.
- */
-extern void
-_mesa_set_vao_immutable(struct gl_context *ctx,
-                        struct gl_vertex_array_object *vao);
-
-
 extern void
 _mesa_vao_map_arrays(struct gl_context *ctx, struct gl_vertex_array_object *vao,
                      GLbitfield access);
diff --git a/src/mesa/vbo/vbo_save_api.c b/src/mesa/vbo/vbo_save_api.c
index 9cbb79badb89d..d013fac32f2e2 100644
--- a/src/mesa/vbo/vbo_save_api.c
+++ b/src/mesa/vbo/vbo_save_api.c
@@ -389,7 +389,8 @@ update_vao(struct gl_context *ctx,
    assert((vao_enabled & ~(*vao)->VertexAttribBufferMask) == 0);
 
    /* Finalize and freeze the VAO */
-   _mesa_set_vao_immutable(ctx, *vao);
+   _mesa_update_vao_derived_arrays(ctx, *vao);
+   (*vao)->SharedAndImmutable = true;
 }
 
 static void wrap_filled_vertex(struct gl_context *ctx);
-- 
GitLab


From 73ea801174b33227e9da07fefd748194405ce019 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Tue, 18 Oct 2022 01:27:58 -0400
Subject: [PATCH 12/17] mesa: add
 gl_vertex_array_object::NonIdentityBufferAttribMapping

It will be used to skip the indirection from vertex attribs to vertex
buffers.
---
 src/mesa/main/attrib.c |  2 ++
 src/mesa/main/mtypes.h | 15 +++++++++++++++
 src/mesa/main/varray.c | 18 +++++++++++++++---
 3 files changed, 32 insertions(+), 3 deletions(-)

diff --git a/src/mesa/main/attrib.c b/src/mesa/main/attrib.c
index 276bb10de091a..a1bdc6b0bd535 100644
--- a/src/mesa/main/attrib.c
+++ b/src/mesa/main/attrib.c
@@ -1208,6 +1208,8 @@ copy_array_object(struct gl_context *ctx,
    /* The bitmask of bound VBOs needs to match the VertexBinding array */
    dest->VertexAttribBufferMask = src->VertexAttribBufferMask;
    dest->NonZeroDivisorMask = src->NonZeroDivisorMask;
+   dest->NonIdentityBufferAttribMapping = src->NonIdentityBufferAttribMapping;
+   dest->_NonIdentityMapModeAttribMapping = src->_NonIdentityMapModeAttribMapping;
    dest->_AttributeMapMode = src->_AttributeMapMode;
    /* skip NumUpdates and IsDynamic because they can only increase, not decrease */
 }
diff --git a/src/mesa/main/mtypes.h b/src/mesa/main/mtypes.h
index 6eceae83a9cec..63cb917d41602 100644
--- a/src/mesa/main/mtypes.h
+++ b/src/mesa/main/mtypes.h
@@ -1667,6 +1667,21 @@ struct gl_vertex_array_object
    /** Mask of VERT_BIT_* values indicating which arrays are enabled */
    GLbitfield Enabled;
 
+   /**
+    * Mask of vertex attributes that have:
+    *    VertexAttrib[i].BufferBindingIndex != i.
+    */
+   GLbitfield NonIdentityBufferAttribMapping;
+
+   /**
+    * The remapped attribute bit according to gl_attribute_map_mode.
+    *
+    * If POS is remapped to GENERIC0, this contains VERT_BIT_POS.
+    * If GENERIC0 is remapped to POS, this contains GENERIC0.
+    * Else 0.
+    */
+   GLbitfield _NonIdentityMapModeAttribMapping;
+
    /**
     * Mask indicating which VertexAttrib and BufferBinding structures have
     * been changed since the VAO creation. No bit is ever cleared to 0 by
diff --git a/src/mesa/main/varray.c b/src/mesa/main/varray.c
index f428e2a7e945b..a9af83bb0cc50 100644
--- a/src/mesa/main/varray.c
+++ b/src/mesa/main/varray.c
@@ -195,12 +195,16 @@ update_attribute_map_mode(const struct gl_context *ctx,
       return;
    /* The generic0 attribute superseeds the position attribute */
    const GLbitfield enabled = vao->Enabled;
-   if (enabled & VERT_BIT_GENERIC0)
+   if (enabled & VERT_BIT_GENERIC0) {
       vao->_AttributeMapMode = ATTRIBUTE_MAP_MODE_GENERIC0;
-   else if (enabled & VERT_BIT_POS)
+      vao->_NonIdentityMapModeAttribMapping = VERT_BIT_POS; /* remapped attrib */
+   } else if (enabled & VERT_BIT_POS) {
       vao->_AttributeMapMode = ATTRIBUTE_MAP_MODE_POSITION;
-   else
+      vao->_NonIdentityMapModeAttribMapping = VERT_BIT_GENERIC0; /* remapped attrib */
+   } else {
       vao->_AttributeMapMode = ATTRIBUTE_MAP_MODE_IDENTITY;
+      vao->_NonIdentityMapModeAttribMapping = 0;
+   }
 }
 
 
@@ -241,6 +245,11 @@ _mesa_vertex_attrib_binding(struct gl_context *ctx,
       }
 
       vao->NonDefaultStateMask |= array_bit | BITFIELD_BIT(bindingIndex);
+
+      if (attribIndex != bindingIndex)
+         vao->NonIdentityBufferAttribMapping |= array_bit;
+      else
+         vao->NonIdentityBufferAttribMapping &= ~array_bit;
    }
 }
 
@@ -4094,6 +4103,8 @@ init_array(struct gl_context *ctx,
    assert(index < ARRAY_SIZE(vao->BufferBinding));
    struct gl_vertex_buffer_binding *binding = &vao->BufferBinding[index];
 
+   vao->NonIdentityBufferAttribMapping &= ~BITFIELD_BIT(index);
+
    _mesa_set_vertex_format(&array->Format, size, type, GL_RGBA,
                            GL_FALSE, GL_FALSE, GL_FALSE);
    array->Stride = 0;
@@ -4145,6 +4156,7 @@ init_default_vao_state(struct gl_context *ctx)
    }
 
    vao->_AttributeMapMode = ATTRIBUTE_MAP_MODE_IDENTITY;
+   vao->_NonIdentityMapModeAttribMapping = 0;
 }
 
 /**
-- 
GitLab


From d77d407d92f1a9e0658d342e8ba3f8a8dc10b32b Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Thu, 4 Jan 2024 18:44:07 -0500
Subject: [PATCH 13/17] mesa: don't use the slow VAO path except for drivers
 that want to use it

The fast path is the only focus of optimizations, so let's stop using
the slow one if the fast path is allowed. Only display lists with drivers
lacking draw_vertex_state use it, and drivers not exposing
PIPE_CAP_ALLOW_DYNAMIC_VAO_FASTPATH use it.

This changes gl_constants::AllowDynamicVAOFastPath to UseVAOFastPath
because it's no longer turned on/off dynamically, but only one of them
is always used per VAO. It also removes the IsDynamic and NumUpdates
fields of VAOs.
---
 src/mesa/main/arrayobj.c                 | 13 +++----------
 src/mesa/main/arrayobj.h                 |  3 ++-
 src/mesa/main/consts_exts.h              |  7 +++++--
 src/mesa/main/mtypes.h                   | 14 --------------
 src/mesa/main/varray.c                   | 12 +++++++-----
 src/mesa/state_tracker/st_atom_array.cpp |  8 ++++----
 src/mesa/state_tracker/st_cb_rasterpos.c |  4 ++--
 src/mesa/state_tracker/st_extensions.c   |  2 +-
 src/mesa/vbo/vbo_save_api.c              |  2 +-
 9 files changed, 25 insertions(+), 40 deletions(-)

diff --git a/src/mesa/main/arrayobj.c b/src/mesa/main/arrayobj.c
index cb623024b8d45..bf7c7d262d34a 100644
--- a/src/mesa/main/arrayobj.c
+++ b/src/mesa/main/arrayobj.c
@@ -515,9 +515,10 @@ compute_vbo_offset_range(const struct gl_vertex_array_object *vao,
  */
 void
 _mesa_update_vao_derived_arrays(struct gl_context *ctx,
-                                struct gl_vertex_array_object *vao)
+                                struct gl_vertex_array_object *vao,
+                                bool display_list)
 {
-   assert(!vao->IsDynamic);
+   assert(display_list || !ctx->Const.UseVAOFastPath);
    /* Make sure we do not run into problems with shared objects */
    assert(!vao->SharedAndImmutable);
 
@@ -543,14 +544,6 @@ _mesa_update_vao_derived_arrays(struct gl_context *ctx,
    /* VBO array bits. */
    const GLbitfield vbos = vao->VertexAttribBufferMask;
 
-   /* More than 4 updates turn the VAO to dynamic. */
-   if (ctx->Const.AllowDynamicVAOFastPath && ++vao->NumUpdates > 4) {
-      vao->IsDynamic = true;
-      /* IsDynamic changes how vertex elements map to vertex buffers. */
-      ctx->Array.NewVertexElements = true;
-      return;
-   }
-
    /* Walk those enabled arrays that have a real vbo attached */
    GLbitfield mask = enabled;
    while (mask) {
diff --git a/src/mesa/main/arrayobj.h b/src/mesa/main/arrayobj.h
index 87c86b5a1489a..279d7ec2a9aa4 100644
--- a/src/mesa/main/arrayobj.h
+++ b/src/mesa/main/arrayobj.h
@@ -89,7 +89,8 @@ _mesa_initialize_vao(struct gl_context *ctx,
 
 extern void
 _mesa_update_vao_derived_arrays(struct gl_context *ctx,
-                                struct gl_vertex_array_object *vao);
+                                struct gl_vertex_array_object *vao,
+                                bool display_list);
 
 extern void
 _mesa_vao_map_arrays(struct gl_context *ctx, struct gl_vertex_array_object *vao,
diff --git a/src/mesa/main/consts_exts.h b/src/mesa/main/consts_exts.h
index 1101f7b9680e8..1755125392e7f 100644
--- a/src/mesa/main/consts_exts.h
+++ b/src/mesa/main/consts_exts.h
@@ -972,8 +972,11 @@ struct gl_constants
    /** Whether out-of-order draw (Begin/End) optimizations are allowed. */
    bool AllowDrawOutOfOrder;
 
-   /** Whether to allow the fast path for frequently updated VAOs. */
-   bool AllowDynamicVAOFastPath;
+   /** Whether to force the fast path for binding VAOs. It has much lower
+    *  overhead due to not spending CPU cycles on trying to find interleaved
+    *  vertex attribs and binding them.
+    */
+   bool UseVAOFastPath;
 
    /** Whether the driver can support primitive restart with a fixed index.
     * This is essentially a subset of NV_primitive_restart with enough support
diff --git a/src/mesa/main/mtypes.h b/src/mesa/main/mtypes.h
index 63cb917d41602..4f7271500f76c 100644
--- a/src/mesa/main/mtypes.h
+++ b/src/mesa/main/mtypes.h
@@ -1631,14 +1631,6 @@ struct gl_vertex_array_object
     */
    GLboolean EverBound;
 
-   /**
-    * Whether the VAO is changed by the application so often that some of
-    * the derived fields are not updated at all to decrease overhead.
-    * Also, interleaved arrays are not detected, because it's too expensive
-    * to do that before every draw call.
-    */
-   bool IsDynamic;
-
    /**
     * Marked to true if the object is shared between contexts and immutable.
     * Then reference counting is done using atomics and thread safe.
@@ -1646,12 +1638,6 @@ struct gl_vertex_array_object
     */
    bool SharedAndImmutable;
 
-   /**
-    * Number of updates that were done by the application. This is used to
-    * decide whether the VAO is static or dynamic.
-    */
-   unsigned NumUpdates;
-
    /** Vertex attribute arrays */
    struct gl_array_attributes VertexAttrib[VERT_ATTRIB_MAX];
 
diff --git a/src/mesa/main/varray.c b/src/mesa/main/varray.c
index a9af83bb0cc50..e350e38c50509 100644
--- a/src/mesa/main/varray.c
+++ b/src/mesa/main/varray.c
@@ -308,10 +308,10 @@ _mesa_bind_vertex_buffer(struct gl_context *ctx,
 
       if (vao->Enabled & binding->_BoundArrays) {
          ctx->NewDriverState |= ST_NEW_VERTEX_ARRAYS;
-         /* Non-dynamic VAOs merge vertex buffers, which affects vertex elements.
-          * stride changes also require new vertex elements
+         /* The slow path merges vertex buffers, which affects vertex elements.
+          * Stride changes also require new vertex elements.
           */
-         if (!vao->IsDynamic || stride_changed)
+         if (!ctx->Const.UseVAOFastPath || stride_changed)
             ctx->Array.NewVertexElements = true;
       }
 
@@ -1127,8 +1127,10 @@ update_array(struct gl_context *ctx,
 
       if (vao->Enabled & VERT_BIT(attrib)) {
          ctx->NewDriverState |= ST_NEW_VERTEX_ARRAYS;
-         /* Non-dynamic VAOs merge vertex buffers, which affects vertex elements. */
-         if (!vao->IsDynamic)
+         /* The slow path merges vertex buffers, which affects vertex
+          * elements.
+          */
+         if (!ctx->Const.UseVAOFastPath)
             ctx->Array.NewVertexElements = true;
       }
 
diff --git a/src/mesa/state_tracker/st_atom_array.cpp b/src/mesa/state_tracker/st_atom_array.cpp
index 3bc4cda9c8279..cc1cfa1b29ec9 100644
--- a/src/mesa/state_tracker/st_atom_array.cpp
+++ b/src/mesa/state_tracker/st_atom_array.cpp
@@ -84,8 +84,8 @@ setup_arrays(struct gl_context *ctx,
              struct cso_velems_state *velements,
              struct pipe_vertex_buffer *vbuffer, unsigned *num_vbuffers)
 {
-   /* Process attribute array data. */
-   if (vao->IsDynamic) {
+   /* Set up enabled vertex arrays. */
+   if (ctx->Const.UseVAOFastPath) {
       const GLubyte *attribute_map =
          _mesa_vao_attribute_map[vao->_AttributeMapMode];
 
@@ -362,8 +362,8 @@ st_update_array_impl(struct st_context *st)
    assert(vao->_EnabledWithMapMode ==
           _mesa_vao_enable_to_vp_inputs(vao->_AttributeMapMode, vao->Enabled));
 
-   if (!vao->IsDynamic && !vao->SharedAndImmutable)
-      _mesa_update_vao_derived_arrays(ctx, vao);
+   if (!ctx->Const.UseVAOFastPath && !vao->SharedAndImmutable)
+      _mesa_update_vao_derived_arrays(ctx, vao, false);
 
    _mesa_get_derived_vao_masks(ctx, enabled_arrays, &enabled_user_arrays,
                                &nonzero_divisor_arrays);
diff --git a/src/mesa/state_tracker/st_cb_rasterpos.c b/src/mesa/state_tracker/st_cb_rasterpos.c
index fe8ec093f8c7f..e249d6c5b111f 100644
--- a/src/mesa/state_tracker/st_cb_rasterpos.c
+++ b/src/mesa/state_tracker/st_cb_rasterpos.c
@@ -263,8 +263,8 @@ st_RasterPos(struct gl_context *ctx, const GLfloat v[4])
    rs->VAO->VertexAttrib[VERT_ATTRIB_POS].Ptr = (GLubyte *) v;
    ctx->NewDriverState |= ST_NEW_VERTEX_ARRAYS;
 
-   /* Non-dynamic VAOs merge vertex buffers, which changes vertex elements. */
-   if (!rs->VAO->IsDynamic) {
+   /* The slow path merges vertex buffers, which changes vertex elements. */
+   if (!ctx->Const.UseVAOFastPath) {
       ctx->Array.NewVertexElements = true;
    }
 
diff --git a/src/mesa/state_tracker/st_extensions.c b/src/mesa/state_tracker/st_extensions.c
index 5e76a8bd1fc91..3630d07796604 100644
--- a/src/mesa/state_tracker/st_extensions.c
+++ b/src/mesa/state_tracker/st_extensions.c
@@ -606,7 +606,7 @@ void st_init_limits(struct pipe_screen *screen,
    c->VertexBufferOffsetIsInt32 =
       screen->get_param(screen, PIPE_CAP_SIGNED_VERTEX_BUFFER_OFFSET);
 
-   c->AllowDynamicVAOFastPath =
+   c->UseVAOFastPath =
          screen->get_param(screen, PIPE_CAP_ALLOW_DYNAMIC_VAO_FASTPATH);
 
    c->glBeginEndBufferSize =
diff --git a/src/mesa/vbo/vbo_save_api.c b/src/mesa/vbo/vbo_save_api.c
index d013fac32f2e2..583f79e09dd91 100644
--- a/src/mesa/vbo/vbo_save_api.c
+++ b/src/mesa/vbo/vbo_save_api.c
@@ -389,7 +389,7 @@ update_vao(struct gl_context *ctx,
    assert((vao_enabled & ~(*vao)->VertexAttribBufferMask) == 0);
 
    /* Finalize and freeze the VAO */
-   _mesa_update_vao_derived_arrays(ctx, *vao);
+   _mesa_update_vao_derived_arrays(ctx, *vao, true);
    (*vao)->SharedAndImmutable = true;
 }
 
-- 
GitLab


From 61c0d4433e716e4b59f419266c6f9508aa8d6441 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Thu, 4 Jan 2024 01:51:51 -0500
Subject: [PATCH 14/17] st/mesa: merge 3 unlikely blocks in
 _mesa_get_bufferobj_reference

---
 src/mesa/main/bufferobj.h | 34 ++++++++++++++++++++--------------
 1 file changed, 20 insertions(+), 14 deletions(-)

diff --git a/src/mesa/main/bufferobj.h b/src/mesa/main/bufferobj.h
index 197636ee01850..d8bd0796d2291 100644
--- a/src/mesa/main/bufferobj.h
+++ b/src/mesa/main/bufferobj.h
@@ -44,26 +44,32 @@ _mesa_get_bufferobj_reference(struct gl_context *ctx, struct gl_buffer_object *o
 
    struct pipe_resource *buffer = obj->buffer;
 
-   if (unlikely(!buffer))
-      return NULL;
-
    /* Only one context is using the fast path. All other contexts must use
     * the slow path.
     */
-   if (unlikely(obj->private_refcount_ctx != ctx)) {
-      p_atomic_inc(&buffer->reference.count);
+   if (unlikely(obj->private_refcount_ctx != ctx ||
+                obj->private_refcount <= 0)) {
+      if (buffer) {
+         if (obj->private_refcount_ctx != ctx) {
+            p_atomic_inc(&buffer->reference.count);
+         } else {
+            /* This is the number of atomic increments we will skip. */
+            const unsigned count = 100000000;
+            p_atomic_add(&buffer->reference.count, count);
+
+            /* Remove the reference that we return. */
+            assert(obj->private_refcount == 0);
+            obj->private_refcount = count - 1;
+         }
+      }
       return buffer;
    }
 
-   if (unlikely(obj->private_refcount <= 0)) {
-      assert(obj->private_refcount == 0);
-
-      /* This is the number of atomic increments we will skip. */
-      obj->private_refcount = 100000000;
-      p_atomic_add(&buffer->reference.count, obj->private_refcount);
-   }
-
-   /* Return a buffer reference while decrementing the private refcount. */
+   /* Return a buffer reference while decrementing the private refcount.
+    * The buffer must be non-NULL, which is implied by private_refcount_ctx
+    * being non-NULL.
+    */
+   assert(buffer);
    obj->private_refcount--;
    return buffer;
 }
-- 
GitLab


From 6f70cab3293bdfc65c3c03b427a955a9f14bb788 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Thu, 4 Jan 2024 02:22:05 -0500
Subject: [PATCH 15/17] st/mesa: remove !obj checking in
 _mesa_get_bufferobj_reference when it's useless

There is at least one case in a future commit where the compiler can't do
this automatically.
---
 src/mesa/main/bufferobj.h                 | 6 ++----
 src/mesa/state_tracker/st_atom_constbuf.c | 7 ++++++-
 2 files changed, 8 insertions(+), 5 deletions(-)

diff --git a/src/mesa/main/bufferobj.h b/src/mesa/main/bufferobj.h
index d8bd0796d2291..8a589a09ccd85 100644
--- a/src/mesa/main/bufferobj.h
+++ b/src/mesa/main/bufferobj.h
@@ -36,12 +36,10 @@
  * Internal functions
  */
 
-static inline struct pipe_resource *
+static ALWAYS_INLINE struct pipe_resource *
 _mesa_get_bufferobj_reference(struct gl_context *ctx, struct gl_buffer_object *obj)
 {
-   if (unlikely(!obj))
-      return NULL;
-
+   assert(obj);
    struct pipe_resource *buffer = obj->buffer;
 
    /* Only one context is using the fast path. All other contexts must use
diff --git a/src/mesa/state_tracker/st_atom_constbuf.c b/src/mesa/state_tracker/st_atom_constbuf.c
index 50937acbebae8..bd4903a51609b 100644
--- a/src/mesa/state_tracker/st_atom_constbuf.c
+++ b/src/mesa/state_tracker/st_atom_constbuf.c
@@ -282,7 +282,12 @@ st_bind_ubos(struct st_context *st, struct gl_program *prog,
       binding =
          &st->ctx->UniformBufferBindings[prog->sh.UniformBlocks[i]->Binding];
 
-      cb.buffer = _mesa_get_bufferobj_reference(st->ctx, binding->BufferObject);
+      if (binding->BufferObject) {
+         cb.buffer = _mesa_get_bufferobj_reference(st->ctx,
+                                                   binding->BufferObject);
+      } else {
+         cb.buffer = NULL;
+      }
 
       if (cb.buffer) {
          cb.buffer_offset = binding->Offset;
-- 
GitLab


From 651711652dca97d94391533d1daa158fbaf16f64 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Thu, 4 Jan 2024 20:49:38 -0500
Subject: [PATCH 16/17] st/mesa: add VAO fast path C++ template variants for
 st_update_array callback

This way we execute 1 half of setup_arrays with the fast path enabled,
and the other half with the fast path disabled, so it's not that much
of code duplication, and it will facilitate further optimizations.
---
 src/mesa/state_tracker/st_atom.h         |  2 +-
 src/mesa/state_tracker/st_atom_array.cpp | 60 +++++++++++++++++++-----
 src/mesa/state_tracker/st_context.c      |  6 +--
 3 files changed, 49 insertions(+), 19 deletions(-)

diff --git a/src/mesa/state_tracker/st_atom.h b/src/mesa/state_tracker/st_atom.h
index 3afee88bfb778..214fae9ddbe55 100644
--- a/src/mesa/state_tracker/st_atom.h
+++ b/src/mesa/state_tracker/st_atom.h
@@ -63,7 +63,7 @@ st_setup_current_user(struct st_context *st,
                       struct pipe_vertex_buffer *vbuffer, unsigned *num_vbuffers);
 
 void
-st_update_array_with_popcnt(struct st_context *st);
+st_init_update_array(struct st_context *st);
 
 struct pipe_vertex_state *
 st_create_gallium_vertex_state(struct gl_context *ctx,
diff --git a/src/mesa/state_tracker/st_atom_array.cpp b/src/mesa/state_tracker/st_atom_array.cpp
index cc1cfa1b29ec9..1fdf0eba006ff 100644
--- a/src/mesa/state_tracker/st_atom_array.cpp
+++ b/src/mesa/state_tracker/st_atom_array.cpp
@@ -41,6 +41,7 @@
 #include "st_program.h"
 
 #include "cso_cache/cso_context.h"
+#include "util/u_cpu_detect.h"
 #include "util/u_math.h"
 #include "util/u_upload_mgr.h"
 #include "main/bufferobj.h"
@@ -48,6 +49,11 @@
 #include "main/varray.h"
 #include "main/arrayobj.h"
 
+enum st_use_vao_fast_path {
+   VAO_FAST_PATH_OFF,         /* more complicated version (slower) */
+   VAO_FAST_PATH_ON,          /* always works (faster) */
+};
+
 enum st_update_velems {
    UPDATE_VELEMS_OFF,         /* specialized version (faster) */
    UPDATE_VELEMS_ON,          /* always works */
@@ -75,7 +81,9 @@ init_velement(struct pipe_vertex_element *velements,
 /* ALWAYS_INLINE helps the compiler realize that most of the parameters are
  * on the stack.
  */
-template<util_popcnt POPCNT, st_update_velems UPDATE_VELEMS> void ALWAYS_INLINE
+template<util_popcnt POPCNT,
+         st_use_vao_fast_path USE_VAO_FAST_PATH,
+         st_update_velems UPDATE_VELEMS> void ALWAYS_INLINE
 setup_arrays(struct gl_context *ctx,
              const struct gl_vertex_array_object *vao,
              const GLbitfield dual_slot_inputs,
@@ -85,7 +93,7 @@ setup_arrays(struct gl_context *ctx,
              struct pipe_vertex_buffer *vbuffer, unsigned *num_vbuffers)
 {
    /* Set up enabled vertex arrays. */
-   if (ctx->Const.UseVAOFastPath) {
+   if (USE_VAO_FAST_PATH) {
       const GLubyte *attribute_map =
          _mesa_vao_attribute_map[vao->_AttributeMapMode];
 
@@ -123,6 +131,11 @@ setup_arrays(struct gl_context *ctx,
       return;
    }
 
+   /* The slow path needs more fields initialized, which is not done if it's
+    * disabled.
+    */
+   assert(!ctx->Const.UseVAOFastPath || vao->SharedAndImmutable);
+
    while (mask) {
       /* The attribute index to start pulling a binding */
       const gl_vert_attrib i = (gl_vert_attrib)(ffs(mask) - 1);
@@ -179,7 +192,7 @@ st_setup_arrays(struct st_context *st,
    struct gl_context *ctx = st->ctx;
    GLbitfield enabled_arrays = _mesa_get_enabled_vertex_arrays(ctx);
 
-   setup_arrays<POPCNT_NO, UPDATE_VELEMS_ON>
+   setup_arrays<POPCNT_NO, VAO_FAST_PATH_ON, UPDATE_VELEMS_ON>
       (ctx, ctx->Array._DrawVAO, vp->Base.DualSlotInputs,
        vp_variant->vert_attrib_mask,
        vp_variant->vert_attrib_mask & enabled_arrays,
@@ -294,7 +307,9 @@ st_setup_current_user(struct st_context *st,
    }
 }
 
-template<util_popcnt POPCNT, st_update_velems UPDATE_VELEMS> void ALWAYS_INLINE
+template<util_popcnt POPCNT,
+         st_use_vao_fast_path USE_VAO_FAST_PATH,
+         st_update_velems UPDATE_VELEMS> void ALWAYS_INLINE
 st_update_array_templ(struct st_context *st,
                       const GLbitfield enabled_arrays,
                       const GLbitfield enabled_user_arrays,
@@ -321,7 +336,7 @@ st_update_array_templ(struct st_context *st,
 
    /* ST_NEW_VERTEX_ARRAYS */
    /* Setup arrays */
-   setup_arrays<POPCNT, UPDATE_VELEMS>
+   setup_arrays<POPCNT, USE_VAO_FAST_PATH, UPDATE_VELEMS>
       (ctx, ctx->Array._DrawVAO, dual_slot_inputs, inputs_read,
        inputs_read & enabled_arrays, &velements, vbuffer, &num_vbuffers);
 
@@ -350,7 +365,8 @@ st_update_array_templ(struct st_context *st,
    }
 }
 
-template<util_popcnt POPCNT> void ALWAYS_INLINE
+template<util_popcnt POPCNT,
+         st_use_vao_fast_path USE_VAO_FAST_PATH> void ALWAYS_INLINE
 st_update_array_impl(struct st_context *st)
 {
    struct gl_context *ctx = st->ctx;
@@ -362,7 +378,7 @@ st_update_array_impl(struct st_context *st)
    assert(vao->_EnabledWithMapMode ==
           _mesa_vao_enable_to_vp_inputs(vao->_AttributeMapMode, vao->Enabled));
 
-   if (!ctx->Const.UseVAOFastPath && !vao->SharedAndImmutable)
+   if (!USE_VAO_FAST_PATH && !vao->SharedAndImmutable)
       _mesa_update_vao_derived_arrays(ctx, vao, false);
 
    _mesa_get_derived_vao_masks(ctx, enabled_arrays, &enabled_user_arrays,
@@ -375,24 +391,39 @@ st_update_array_impl(struct st_context *st)
    if (ctx->Array.NewVertexElements ||
        st->uses_user_vertex_buffers !=
        !!(st->vp_variant->vert_attrib_mask & enabled_user_arrays)) {
-      st_update_array_templ<POPCNT, UPDATE_VELEMS_ON>
+      st_update_array_templ<POPCNT, USE_VAO_FAST_PATH, UPDATE_VELEMS_ON>
          (st, enabled_arrays, enabled_user_arrays, nonzero_divisor_arrays);
    } else {
-      st_update_array_templ<POPCNT, UPDATE_VELEMS_OFF>
+      st_update_array_templ<POPCNT, USE_VAO_FAST_PATH, UPDATE_VELEMS_OFF>
          (st, enabled_arrays, enabled_user_arrays, nonzero_divisor_arrays);
    }
 }
 
+/* The default callback that must be present before st_init_update_array
+ * selects the driver-dependent variant.
+ */
 void
 st_update_array(struct st_context *st)
 {
-   st_update_array_impl<POPCNT_NO>(st);
+   unreachable("st_init_update_array not called");
 }
 
 void
-st_update_array_with_popcnt(struct st_context *st)
+st_init_update_array(struct st_context *st)
 {
-   st_update_array_impl<POPCNT_YES>(st);
+   st_update_func_t *func = &st->update_functions[ST_NEW_VERTEX_ARRAYS_INDEX];
+
+   if (util_get_cpu_caps()->has_popcnt) {
+      if (st->ctx->Const.UseVAOFastPath)
+         *func = st_update_array_impl<POPCNT_YES, VAO_FAST_PATH_ON>;
+      else
+         *func = st_update_array_impl<POPCNT_YES, VAO_FAST_PATH_OFF>;
+   } else {
+      if (st->ctx->Const.UseVAOFastPath)
+         *func = st_update_array_impl<POPCNT_NO, VAO_FAST_PATH_ON>;
+      else
+         *func = st_update_array_impl<POPCNT_NO, VAO_FAST_PATH_OFF>;
+   }
 }
 
 struct pipe_vertex_state *
@@ -408,7 +439,10 @@ st_create_gallium_vertex_state(struct gl_context *ctx,
    unsigned num_vbuffers = 0;
    struct cso_velems_state velements;
 
-   setup_arrays<POPCNT_NO, UPDATE_VELEMS_ON>
+   /* This should use the slow path because there is only 1 interleaved
+    * vertex buffers.
+    */
+   setup_arrays<POPCNT_NO, VAO_FAST_PATH_OFF, UPDATE_VELEMS_ON>
       (ctx, vao, dual_slot_inputs, inputs_read, inputs_read, &velements,
        vbuffer, &num_vbuffers);
 
diff --git a/src/mesa/state_tracker/st_context.c b/src/mesa/state_tracker/st_context.c
index 54e01352e8407..dfdae38fd57af 100644
--- a/src/mesa/state_tracker/st_context.c
+++ b/src/mesa/state_tracker/st_context.c
@@ -476,11 +476,6 @@ st_create_context_priv(struct gl_context *ctx, struct pipe_context *pipe,
 #include "st_atom_list.h"
 #undef ST_STATE
 
-   if (util_get_cpu_caps()->has_popcnt) {
-      st->update_functions[ST_NEW_VERTEX_ARRAYS_INDEX] =
-         st_update_array_with_popcnt;
-   }
-
    st_init_clear(st);
    {
       enum pipe_texture_transfer_mode val = screen->get_param(screen, PIPE_CAP_TEXTURE_TRANSFER_MODES);
@@ -775,6 +770,7 @@ st_create_context_priv(struct gl_context *ctx, struct pipe_context *pipe,
    _vbo_CreateContext(ctx);
 
    st_init_driver_flags(st);
+   st_init_update_array(st);
 
    /* Initialize context's winsys buffers list */
    list_inithead(&st->winsys_buffers);
-- 
GitLab


From e119d7859685041e1a8901ff1371bd14e5033203 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Thu, 4 Jan 2024 12:44:12 -0500
Subject: [PATCH 17/17] st/mesa: optimize st_update_arrays using lots of C++
 template variants

This adds the following template options:
- add an option to fill TC set_vertex_buffers from st_update_array directly
  (always true without u_vbuf, so always used with radeonsi)
- add an option saying that there are no zero-stride attribs
- add an option saying that there are no user buffers
  (always true with glthread, so always used with radeonsi)
- add an option saying that there is an identity mapping between vertex
  buffers and vertex attribs

I have specifically chosen those options because they improve performance.
I also had other options that didn't, like unrolling the setup_arrays loop.

This adds a total of 42 variants of st_update_array_templ for various cases.
Usually only a few of them are used in practice.

Overhead of st_prepare_draw in VP2020/Catia:
    Before: 8.5% of CPU used
    After: 6.13% of CPU used

That's 2.37% improvement. Since there are 4 threads using the CPU and
the percentage includes all threads in the system, the improvement for
the GL thread is about 8% (roughly 2.17% * 4; each thread at 25% of global
utilization means 100% utilization in 4 cores).
---
 src/mesa/state_tracker/st_atom_array.cpp | 311 ++++++++++++++++++++---
 src/util/bitscan.h                       |   1 +
 2 files changed, 274 insertions(+), 38 deletions(-)

diff --git a/src/mesa/state_tracker/st_atom_array.cpp b/src/mesa/state_tracker/st_atom_array.cpp
index 1fdf0eba006ff..47cbafe6287b9 100644
--- a/src/mesa/state_tracker/st_atom_array.cpp
+++ b/src/mesa/state_tracker/st_atom_array.cpp
@@ -44,16 +44,38 @@
 #include "util/u_cpu_detect.h"
 #include "util/u_math.h"
 #include "util/u_upload_mgr.h"
+#include "util/u_threaded_context.h"
 #include "main/bufferobj.h"
 #include "main/glformats.h"
 #include "main/varray.h"
 #include "main/arrayobj.h"
 
+enum st_fill_tc_set_vb {
+   FILL_TC_SET_VB_OFF,        /* always works */
+   FILL_TC_SET_VB_ON,         /* specialized version (faster) */
+};
+
 enum st_use_vao_fast_path {
    VAO_FAST_PATH_OFF,         /* more complicated version (slower) */
    VAO_FAST_PATH_ON,          /* always works (faster) */
 };
 
+enum st_allow_zero_stride_attribs {
+   ZERO_STRIDE_ATTRIBS_OFF,   /* specialized version (faster) */
+   ZERO_STRIDE_ATTRIBS_ON,    /* always works */
+};
+
+/* Whether vertex attrib indices are equal to their vertex buffer indices. */
+enum st_identity_attrib_mapping {
+   IDENTITY_ATTRIB_MAPPING_OFF,  /* always works */
+   IDENTITY_ATTRIB_MAPPING_ON,   /* specialized version (faster) */
+};
+
+enum st_allow_user_buffers {
+   USER_BUFFERS_OFF,          /* specialized version (faster) */
+   USER_BUFFERS_ON,           /* always works */
+};
+
 enum st_update_velems {
    UPDATE_VELEMS_OFF,         /* specialized version (faster) */
    UPDATE_VELEMS_ON,          /* always works */
@@ -82,7 +104,11 @@ init_velement(struct pipe_vertex_element *velements,
  * on the stack.
  */
 template<util_popcnt POPCNT,
+         st_fill_tc_set_vb FILL_TC_SET_VB,
          st_use_vao_fast_path USE_VAO_FAST_PATH,
+         st_allow_zero_stride_attribs ALLOW_ZERO_STRIDE_ATTRIBS,
+         st_identity_attrib_mapping HAS_IDENTITY_ATTRIB_MAPPING,
+         st_allow_user_buffers ALLOW_USER_BUFFERS,
          st_update_velems UPDATE_VELEMS> void ALWAYS_INLINE
 setup_arrays(struct gl_context *ctx,
              const struct gl_vertex_array_object *vao,
@@ -95,38 +121,73 @@ setup_arrays(struct gl_context *ctx,
    /* Set up enabled vertex arrays. */
    if (USE_VAO_FAST_PATH) {
       const GLubyte *attribute_map =
-         _mesa_vao_attribute_map[vao->_AttributeMapMode];
+         !HAS_IDENTITY_ATTRIB_MAPPING ?
+               _mesa_vao_attribute_map[vao->_AttributeMapMode] : NULL;
+      struct pipe_context *pipe = ctx->pipe;
+      struct tc_buffer_list *next_buffer_list = NULL;
+
+      if (FILL_TC_SET_VB)
+         next_buffer_list = tc_get_next_buffer_list(pipe);
 
+      /* Note: I did try to unroll this loop by passing the number of
+       * iterations as a template parameter, but it resulted in more overhead.
+       */
       while (mask) {
          const gl_vert_attrib attr = (gl_vert_attrib)u_bit_scan(&mask);
-         const struct gl_array_attributes *const attrib =
-            &vao->VertexAttrib[attribute_map[attr]];
-         const struct gl_vertex_buffer_binding *const binding =
-            &vao->BufferBinding[attrib->BufferBindingIndex];
+         const struct gl_array_attributes *attrib;
+         const struct gl_vertex_buffer_binding *binding;
+
+         if (HAS_IDENTITY_ATTRIB_MAPPING) {
+            attrib = &vao->VertexAttrib[attr];
+            binding = &vao->BufferBinding[attr];
+         } else {
+            attrib = &vao->VertexAttrib[attribute_map[attr]];
+            binding = &vao->BufferBinding[attrib->BufferBindingIndex];
+         }
          const unsigned bufidx = (*num_vbuffers)++;
 
          /* Set the vertex buffer. */
-         if (binding->BufferObj) {
-            vbuffer[bufidx].buffer.resource =
+         if (!ALLOW_USER_BUFFERS || binding->BufferObj) {
+            assert(binding->BufferObj);
+            struct pipe_resource *buf =
                _mesa_get_bufferobj_reference(ctx, binding->BufferObj);
+            vbuffer[bufidx].buffer.resource = buf;
             vbuffer[bufidx].is_user_buffer = false;
             vbuffer[bufidx].buffer_offset = binding->Offset +
                                             attrib->RelativeOffset;
+            if (FILL_TC_SET_VB)
+               tc_track_vertex_buffer(pipe, bufidx, buf, next_buffer_list);
          } else {
             vbuffer[bufidx].buffer.user = attrib->Ptr;
             vbuffer[bufidx].is_user_buffer = true;
             vbuffer[bufidx].buffer_offset = 0;
+            assert(!FILL_TC_SET_VB);
          }
 
          if (!UPDATE_VELEMS)
             continue;
 
+         /* Determine the vertex element index without popcnt
+          * if !ALLOW_ZERO_STRIDE_ATTRIBS, which means that we don't need
+          * to leave any holes for zero-stride attribs, thus the mapping from
+          * vertex elements to vertex buffers is identity.
+          */
+         unsigned index;
+
+         if (ALLOW_ZERO_STRIDE_ATTRIBS) {
+            assert(POPCNT != POPCNT_INVALID);
+            index = util_bitcount_fast<POPCNT>(inputs_read &
+                                               BITFIELD_MASK(attr));
+         } else {
+            index = bufidx;
+            assert(index == util_bitcount(inputs_read &
+                                          BITFIELD_MASK(attr)));
+         }
+
          /* Set the vertex element. */
-         init_velement(velements->velems, &attrib->Format, 0,
-                       binding->Stride,
+         init_velement(velements->velems, &attrib->Format, 0, binding->Stride,
                        binding->InstanceDivisor, bufidx,
-                       dual_slot_inputs & BITFIELD_BIT(attr),
-                       util_bitcount_fast<POPCNT>(inputs_read & BITFIELD_MASK(attr)));
+                       dual_slot_inputs & BITFIELD_BIT(attr), index);
       }
       return;
    }
@@ -136,6 +197,15 @@ setup_arrays(struct gl_context *ctx,
     */
    assert(!ctx->Const.UseVAOFastPath || vao->SharedAndImmutable);
 
+   /* Require these because we don't use them here and we don't want to
+    * generate identical template variants.
+    */
+   assert(!FILL_TC_SET_VB);
+   assert(ALLOW_ZERO_STRIDE_ATTRIBS);
+   assert(!HAS_IDENTITY_ATTRIB_MAPPING);
+   assert(ALLOW_USER_BUFFERS);
+   assert(UPDATE_VELEMS);
+
    while (mask) {
       /* The attribute index to start pulling a binding */
       const gl_vert_attrib i = (gl_vert_attrib)(ffs(mask) - 1);
@@ -164,8 +234,6 @@ setup_arrays(struct gl_context *ctx,
       /* We can assume that we have array for the binding */
       assert(attrmask);
 
-      if (!UPDATE_VELEMS)
-         continue;
 
       /* Walk attributes belonging to the binding */
       do {
@@ -173,10 +241,13 @@ setup_arrays(struct gl_context *ctx,
          const struct gl_array_attributes *const attrib
             = _mesa_draw_array_attrib(vao, attr);
          const GLuint off = _mesa_draw_attributes_relative_offset(attrib);
+         assert(POPCNT != POPCNT_INVALID);
+
          init_velement(velements->velems, &attrib->Format, off,
                        binding->Stride, binding->InstanceDivisor, bufidx,
                        dual_slot_inputs & BITFIELD_BIT(attr),
-                       util_bitcount_fast<POPCNT>(inputs_read & BITFIELD_MASK(attr)));
+                       util_bitcount_fast<POPCNT>(inputs_read &
+                                                  BITFIELD_MASK(attr)));
       } while (attrmask);
    }
 }
@@ -192,7 +263,9 @@ st_setup_arrays(struct st_context *st,
    struct gl_context *ctx = st->ctx;
    GLbitfield enabled_arrays = _mesa_get_enabled_vertex_arrays(ctx);
 
-   setup_arrays<POPCNT_NO, VAO_FAST_PATH_ON, UPDATE_VELEMS_ON>
+   setup_arrays<POPCNT_NO, FILL_TC_SET_VB_OFF, VAO_FAST_PATH_ON,
+                ZERO_STRIDE_ATTRIBS_ON, IDENTITY_ATTRIB_MAPPING_OFF,
+                USER_BUFFERS_ON, UPDATE_VELEMS_ON>
       (ctx, ctx->Array._DrawVAO, vp->Base.DualSlotInputs,
        vp_variant->vert_attrib_mask,
        vp_variant->vert_attrib_mask & enabled_arrays,
@@ -205,7 +278,9 @@ st_setup_arrays(struct st_context *st,
  * Return the index of the vertex buffer where current attribs have been
  * uploaded.
  */
-template<util_popcnt POPCNT, st_update_velems UPDATE_VELEMS> void ALWAYS_INLINE
+template<util_popcnt POPCNT,
+         st_fill_tc_set_vb FILL_TC_SET_VB,
+         st_update_velems UPDATE_VELEMS> void ALWAYS_INLINE
 st_setup_current(struct st_context *st,
                  const GLbitfield dual_slot_inputs,
                  const GLbitfield inputs_read,
@@ -216,6 +291,7 @@ st_setup_current(struct st_context *st,
    /* Process values that should have better been uniforms in the application */
    if (curmask) {
       struct gl_context *ctx = st->ctx;
+      assert(POPCNT != POPCNT_INVALID);
       unsigned num_attribs = util_bitcount_fast<POPCNT>(curmask);
       unsigned num_dual_attribs = util_bitcount_fast<POPCNT>(curmask &
                                                              dual_slot_inputs);
@@ -245,6 +321,12 @@ st_setup_current(struct st_context *st,
                      &vbuffer[bufidx].buffer.resource, (void**)&ptr);
       uint8_t *cursor = ptr;
 
+      if (FILL_TC_SET_VB) {
+         struct pipe_context *pipe = ctx->pipe;
+         tc_track_vertex_buffer(pipe, bufidx, vbuffer[bufidx].buffer.resource,
+                                tc_get_next_buffer_list(pipe));
+      }
+
       do {
          const gl_vert_attrib attr = (gl_vert_attrib)u_bit_scan(&curmask);
          const struct gl_array_attributes *const attrib
@@ -264,7 +346,8 @@ st_setup_current(struct st_context *st,
          if (UPDATE_VELEMS) {
             init_velement(velements->velems, &attrib->Format, cursor - ptr,
                           0, 0, bufidx, dual_slot_inputs & BITFIELD_BIT(attr),
-                          util_bitcount_fast<POPCNT>(inputs_read & BITFIELD_MASK(attr)));
+                          util_bitcount_fast<POPCNT>(inputs_read &
+                                                     BITFIELD_MASK(attr)));
          }
 
          cursor += size;
@@ -308,7 +391,11 @@ st_setup_current_user(struct st_context *st,
 }
 
 template<util_popcnt POPCNT,
+         st_fill_tc_set_vb FILL_TC_SET_VB,
          st_use_vao_fast_path USE_VAO_FAST_PATH,
+         st_allow_zero_stride_attribs ALLOW_ZERO_STRIDE_ATTRIBS,
+         st_identity_attrib_mapping HAS_IDENTITY_ATTRIB_MAPPING,
+         st_allow_user_buffers ALLOW_USER_BUFFERS,
          st_update_velems UPDATE_VELEMS> void ALWAYS_INLINE
 st_update_array_templ(struct st_context *st,
                       const GLbitfield enabled_arrays,
@@ -324,47 +411,174 @@ st_update_array_templ(struct st_context *st,
    const struct st_common_variant *vp_variant = st->vp_variant;
    const GLbitfield inputs_read = vp_variant->vert_attrib_mask;
    const GLbitfield dual_slot_inputs = vp->Base.DualSlotInputs;
-   const GLbitfield userbuf_arrays = inputs_read & enabled_user_arrays;
+   const GLbitfield userbuf_arrays =
+      ALLOW_USER_BUFFERS ? inputs_read & enabled_user_arrays : 0;
    bool uses_user_vertex_buffers = userbuf_arrays != 0;
 
    st->draw_needs_minmax_index =
       (userbuf_arrays & ~nonzero_divisor_arrays) != 0;
 
-   struct pipe_vertex_buffer vbuffer[PIPE_MAX_ATTRIBS];
-   unsigned num_vbuffers = 0;
+   struct pipe_vertex_buffer vbuffer_local[PIPE_MAX_ATTRIBS];
+   struct pipe_vertex_buffer *vbuffer;
+   unsigned num_vbuffers = 0, num_vbuffers_tc;
    struct cso_velems_state velements;
 
+   if (FILL_TC_SET_VB) {
+      assert(!uses_user_vertex_buffers);
+      assert(POPCNT != POPCNT_INVALID);
+      num_vbuffers_tc = util_bitcount_fast<POPCNT>(inputs_read &
+                                                   enabled_arrays);
+
+      /* Add up to 1 vertex buffer for zero-stride vertex attribs. */
+      num_vbuffers_tc += ALLOW_ZERO_STRIDE_ATTRIBS &&
+                         inputs_read & ~enabled_arrays;
+      vbuffer = tc_add_set_vertex_buffers_call(st->pipe, num_vbuffers_tc);
+   } else {
+      vbuffer = vbuffer_local;
+   }
+
    /* ST_NEW_VERTEX_ARRAYS */
    /* Setup arrays */
-   setup_arrays<POPCNT, USE_VAO_FAST_PATH, UPDATE_VELEMS>
+   setup_arrays<POPCNT, FILL_TC_SET_VB, USE_VAO_FAST_PATH,
+                ALLOW_ZERO_STRIDE_ATTRIBS, HAS_IDENTITY_ATTRIB_MAPPING,
+                ALLOW_USER_BUFFERS, UPDATE_VELEMS>
       (ctx, ctx->Array._DrawVAO, dual_slot_inputs, inputs_read,
        inputs_read & enabled_arrays, &velements, vbuffer, &num_vbuffers);
 
    /* _NEW_CURRENT_ATTRIB */
    /* Setup zero-stride attribs. */
-   st_setup_current<POPCNT, UPDATE_VELEMS>
-      (st, dual_slot_inputs, inputs_read, inputs_read & ~enabled_arrays,
-       &velements, vbuffer, &num_vbuffers);
+   if (ALLOW_ZERO_STRIDE_ATTRIBS) {
+      st_setup_current<POPCNT, FILL_TC_SET_VB, UPDATE_VELEMS>
+         (st, dual_slot_inputs, inputs_read, inputs_read & ~enabled_arrays,
+          &velements, vbuffer, &num_vbuffers);
+   } else {
+      assert(!(inputs_read & ~enabled_arrays));
+   }
 
-   struct cso_context *cso = st->cso_context;
+   if (FILL_TC_SET_VB)
+         assert(num_vbuffers == num_vbuffers_tc);
 
    if (UPDATE_VELEMS) {
+      struct cso_context *cso = st->cso_context;
       velements.count = vp->num_inputs + vp_variant->key.passthrough_edgeflags;
 
       /* Set vertex buffers and elements. */
-      cso_set_vertex_buffers_and_elements(cso, &velements, num_vbuffers, true,
-                                          uses_user_vertex_buffers, vbuffer);
+      if (FILL_TC_SET_VB) {
+         cso_set_vertex_elements(cso, &velements);
+      } else {
+         cso_set_vertex_buffers_and_elements(cso, &velements, num_vbuffers, true,
+                                             uses_user_vertex_buffers, vbuffer);
+      }
       /* The driver should clear this after it has processed the update. */
       ctx->Array.NewVertexElements = false;
       st->uses_user_vertex_buffers = uses_user_vertex_buffers;
    } else {
       /* Only vertex buffers. */
-      cso_set_vertex_buffers(cso, num_vbuffers, true, vbuffer);
+      if (!FILL_TC_SET_VB)
+         cso_set_vertex_buffers(st->cso_context, num_vbuffers, true, vbuffer);
+
       /* This can change only when we update vertex elements. */
       assert(st->uses_user_vertex_buffers == uses_user_vertex_buffers);
    }
 }
 
+typedef void (*update_array_func)(struct st_context *st,
+                                  const GLbitfield enabled_arrays,
+                                  const GLbitfield enabled_user_attribs,
+                                  const GLbitfield nonzero_divisor_attribs);
+
+/* This just initializes the table of all st_update_array variants. */
+struct st_update_array_table {
+   update_array_func funcs[2][2][2][2][2][2];
+
+   template<util_popcnt POPCNT,
+            st_fill_tc_set_vb FILL_TC_SET_VB,
+            st_allow_zero_stride_attribs ALLOW_ZERO_STRIDE_ATTRIBS,
+            st_identity_attrib_mapping HAS_IDENTITY_ATTRIB_MAPPING,
+            st_allow_user_buffers ALLOW_USER_BUFFERS,
+            st_update_velems UPDATE_VELEMS>
+   void init_one()
+   {
+      /* These conditions reduce the number of compiled variants. */
+      /* The TC path is only valid without user buffers.
+       */
+      constexpr st_fill_tc_set_vb fill_tc_set_vb =
+         !ALLOW_USER_BUFFERS ? FILL_TC_SET_VB : FILL_TC_SET_VB_OFF;
+
+      /* POPCNT is unused without zero-stride attribs and without TC. */
+      constexpr util_popcnt popcnt =
+         !ALLOW_ZERO_STRIDE_ATTRIBS && !fill_tc_set_vb ?
+            POPCNT_INVALID : POPCNT;
+
+      funcs[POPCNT][FILL_TC_SET_VB][ALLOW_ZERO_STRIDE_ATTRIBS]
+           [HAS_IDENTITY_ATTRIB_MAPPING][ALLOW_USER_BUFFERS][UPDATE_VELEMS] =
+         st_update_array_templ<
+            popcnt,
+            fill_tc_set_vb,
+            VAO_FAST_PATH_ON,
+            ALLOW_ZERO_STRIDE_ATTRIBS,
+            HAS_IDENTITY_ATTRIB_MAPPING,
+            ALLOW_USER_BUFFERS,
+            UPDATE_VELEMS>;
+   }
+
+   /* We have to do this in stages because of the combinatorial explosion of
+    * variants.
+    */
+   template<util_popcnt POPCNT,
+            st_fill_tc_set_vb FILL_TC_SET_VB,
+            st_allow_zero_stride_attribs ALLOW_ZERO_STRIDE_ATTRIBS>
+   void init_last_3_args()
+   {
+      init_one<POPCNT, FILL_TC_SET_VB, ALLOW_ZERO_STRIDE_ATTRIBS,
+               IDENTITY_ATTRIB_MAPPING_OFF, USER_BUFFERS_OFF,
+               UPDATE_VELEMS_OFF>();
+      init_one<POPCNT, FILL_TC_SET_VB, ALLOW_ZERO_STRIDE_ATTRIBS,
+               IDENTITY_ATTRIB_MAPPING_OFF,
+               USER_BUFFERS_OFF, UPDATE_VELEMS_ON>();
+      init_one<POPCNT, FILL_TC_SET_VB, ALLOW_ZERO_STRIDE_ATTRIBS,
+               IDENTITY_ATTRIB_MAPPING_OFF,
+               USER_BUFFERS_ON,  UPDATE_VELEMS_OFF>();
+      init_one<POPCNT, FILL_TC_SET_VB, ALLOW_ZERO_STRIDE_ATTRIBS,
+               IDENTITY_ATTRIB_MAPPING_OFF,
+               USER_BUFFERS_ON,  UPDATE_VELEMS_ON>();
+      init_one<POPCNT, FILL_TC_SET_VB, ALLOW_ZERO_STRIDE_ATTRIBS,
+               IDENTITY_ATTRIB_MAPPING_ON,
+               USER_BUFFERS_OFF, UPDATE_VELEMS_OFF>();
+      init_one<POPCNT, FILL_TC_SET_VB, ALLOW_ZERO_STRIDE_ATTRIBS,
+               IDENTITY_ATTRIB_MAPPING_ON,
+               USER_BUFFERS_OFF, UPDATE_VELEMS_ON>();
+      init_one<POPCNT, FILL_TC_SET_VB, ALLOW_ZERO_STRIDE_ATTRIBS,
+               IDENTITY_ATTRIB_MAPPING_ON,
+               USER_BUFFERS_ON,  UPDATE_VELEMS_OFF>();
+      init_one<POPCNT, FILL_TC_SET_VB, ALLOW_ZERO_STRIDE_ATTRIBS,
+               IDENTITY_ATTRIB_MAPPING_ON,
+               USER_BUFFERS_ON,  UPDATE_VELEMS_ON>();
+   }
+
+   st_update_array_table()
+   {
+      init_last_3_args<POPCNT_NO,  FILL_TC_SET_VB_OFF,
+                       ZERO_STRIDE_ATTRIBS_OFF>();
+      init_last_3_args<POPCNT_NO,  FILL_TC_SET_VB_OFF,
+                       ZERO_STRIDE_ATTRIBS_ON>();
+      init_last_3_args<POPCNT_NO,  FILL_TC_SET_VB_ON,
+                       ZERO_STRIDE_ATTRIBS_OFF>();
+      init_last_3_args<POPCNT_NO,  FILL_TC_SET_VB_ON,
+                       ZERO_STRIDE_ATTRIBS_ON>();
+      init_last_3_args<POPCNT_YES, FILL_TC_SET_VB_OFF,
+                       ZERO_STRIDE_ATTRIBS_OFF>();
+      init_last_3_args<POPCNT_YES, FILL_TC_SET_VB_OFF,
+                       ZERO_STRIDE_ATTRIBS_ON>();
+      init_last_3_args<POPCNT_YES, FILL_TC_SET_VB_ON,
+                       ZERO_STRIDE_ATTRIBS_OFF>();
+      init_last_3_args<POPCNT_YES, FILL_TC_SET_VB_ON,
+                       ZERO_STRIDE_ATTRIBS_ON>();
+   }
+};
+
+static st_update_array_table update_array_table;
+
 template<util_popcnt POPCNT,
          st_use_vao_fast_path USE_VAO_FAST_PATH> void ALWAYS_INLINE
 st_update_array_impl(struct st_context *st)
@@ -384,19 +598,38 @@ st_update_array_impl(struct st_context *st)
    _mesa_get_derived_vao_masks(ctx, enabled_arrays, &enabled_user_arrays,
                                &nonzero_divisor_arrays);
 
+   /* Execute the slow path without using multiple C++ template variants. */
+   if (!USE_VAO_FAST_PATH) {
+      st_update_array_templ<POPCNT, FILL_TC_SET_VB_OFF, VAO_FAST_PATH_OFF,
+                            ZERO_STRIDE_ATTRIBS_ON, IDENTITY_ATTRIB_MAPPING_OFF,
+                            USER_BUFFERS_ON, UPDATE_VELEMS_ON>
+         (st, enabled_arrays, enabled_user_arrays, nonzero_divisor_arrays);
+      return;
+   }
+
+   /* The fast path that selects from multiple C++ template variants. */
+   const GLbitfield inputs_read = st->vp_variant->vert_attrib_mask;
+   const GLbitfield enabled_arrays_read = inputs_read & enabled_arrays;
+
+   /* Check cso_context whether it goes directly to TC. */
+   bool fill_tc_set_vbs = st->cso_context->draw_vbo == tc_draw_vbo;
+   bool has_zero_stride_attribs = inputs_read & ~enabled_arrays;
+   bool has_identity_mapping = !(enabled_arrays_read &
+                                 (vao->NonIdentityBufferAttribMapping |
+                                  vao->_NonIdentityMapModeAttribMapping));
+   /* has_user_buffers is always false with glthread. */
+   bool has_user_buffers = inputs_read & enabled_user_arrays;
    /* Changing from user to non-user buffers and vice versa can switch between
     * cso and u_vbuf, which means that we need to update vertex elements even
     * when they have not changed.
     */
-   if (ctx->Array.NewVertexElements ||
-       st->uses_user_vertex_buffers !=
-       !!(st->vp_variant->vert_attrib_mask & enabled_user_arrays)) {
-      st_update_array_templ<POPCNT, USE_VAO_FAST_PATH, UPDATE_VELEMS_ON>
-         (st, enabled_arrays, enabled_user_arrays, nonzero_divisor_arrays);
-   } else {
-      st_update_array_templ<POPCNT, USE_VAO_FAST_PATH, UPDATE_VELEMS_OFF>
-         (st, enabled_arrays, enabled_user_arrays, nonzero_divisor_arrays);
-   }
+   bool update_velems = ctx->Array.NewVertexElements ||
+                        st->uses_user_vertex_buffers != has_user_buffers;
+
+   update_array_table.funcs[POPCNT][fill_tc_set_vbs][has_zero_stride_attribs]
+                           [has_identity_mapping][has_user_buffers]
+                           [update_velems]
+      (st, enabled_arrays, enabled_user_arrays, nonzero_divisor_arrays);
 }
 
 /* The default callback that must be present before st_init_update_array
@@ -442,7 +675,9 @@ st_create_gallium_vertex_state(struct gl_context *ctx,
    /* This should use the slow path because there is only 1 interleaved
     * vertex buffers.
     */
-   setup_arrays<POPCNT_NO, VAO_FAST_PATH_OFF, UPDATE_VELEMS_ON>
+   setup_arrays<POPCNT_NO, FILL_TC_SET_VB_OFF, VAO_FAST_PATH_OFF,
+                ZERO_STRIDE_ATTRIBS_ON, IDENTITY_ATTRIB_MAPPING_OFF,
+                USER_BUFFERS_ON, UPDATE_VELEMS_ON>
       (ctx, vao, dual_slot_inputs, inputs_read, inputs_read, &velements,
        vbuffer, &num_vbuffers);
 
diff --git a/src/util/bitscan.h b/src/util/bitscan.h
index ae0e721e61c60..01f6d80b1c3bb 100644
--- a/src/util/bitscan.h
+++ b/src/util/bitscan.h
@@ -399,6 +399,7 @@ util_widen_mask(uint32_t mask, unsigned multiplier)
 enum util_popcnt {
    POPCNT_NO,
    POPCNT_YES,
+   POPCNT_INVALID,
 };
 
 /* Convenient function to select popcnt through a C++ template argument.
-- 
GitLab

