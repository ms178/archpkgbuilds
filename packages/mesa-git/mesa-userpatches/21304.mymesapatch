From 6f05a7bb1844955a559668e816a88a4cac187caf Mon Sep 17 00:00:00 2001
From: Timothy Arceri <tarceri@itsqueeze.com>
Date: Mon, 28 Nov 2022 12:57:30 +1100
Subject: [PATCH 1/4] util/disk_cache: add data sizes to cache_item_metadata
 struct

These will be used to implement a dual layer cache allowing us
to avoid duplicate shaders within different pipelines in Vulkan
drivers.
---
 src/util/disk_cache.h | 9 +++++++++
 1 file changed, 9 insertions(+)

diff --git a/src/util/disk_cache.h b/src/util/disk_cache.h
index 026ca42f03ce..9a3bdf50ae67 100644
--- a/src/util/disk_cache.h
+++ b/src/util/disk_cache.h
@@ -40,6 +40,8 @@
 extern "C" {
 #endif
 
+#define CACHE_MAX_SHADERS 14
+
 /* Size of cache keys in bytes. */
 #define CACHE_KEY_SIZE 20
 
@@ -75,6 +77,13 @@ struct cache_item_metadata {
    /** GLSL cache item metadata */
    cache_key *keys;   /* sha1 list of shaders that make up the cache item */
    uint32_t num_keys;
+
+   /* The size of the cache items header before the shader data */
+   uint32_t header_size;
+
+   /* Size of each shader in the cache item */
+   uint32_t shader_sizes[CACHE_MAX_SHADERS];
+   uint32_t num_shaders;
 };
 
 struct disk_cache;
-- 
GitLab


From 36dc2a534e58337ab1f84847f6419aaa7c4bb45f Mon Sep 17 00:00:00 2001
From: Timothy Arceri <tarceri@itsqueeze.com>
Date: Mon, 28 Nov 2022 16:49:14 +1100
Subject: [PATCH 2/4] util/disk_cache: add helper
 create_put_job_and_add_to_queue()

This just removes some duplicate code and will make some of the
following patches cleaner.
---
 src/util/disk_cache.c | 39 +++++++++++++++++++++++----------------
 1 file changed, 23 insertions(+), 16 deletions(-)

diff --git a/src/util/disk_cache.c b/src/util/disk_cache.c
index e4e03131b0ae..5e5a24066a07 100644
--- a/src/util/disk_cache.c
+++ b/src/util/disk_cache.c
@@ -531,6 +531,25 @@ blob_get_compressed(struct disk_cache *cache, const cache_key key,
    return data;
 }
 
+static void
+create_put_job_and_add_to_queue(struct disk_cache *cache, const cache_key key,
+                                const void *data, size_t size,
+                                struct cache_item_metadata *cache_item_metadata,
+                                util_queue_execute_func destroy_put_job,
+                                bool take_ownership)
+{
+   struct disk_cache_put_job *dc_job =
+      create_put_job(cache, key, (void*)data, size, cache_item_metadata,
+                     take_ownership);
+
+   if (dc_job) {
+      util_queue_fence_init(&dc_job->fence);
+      util_queue_add_job(&cache->cache_queue, dc_job, &dc_job->fence,
+                         cache_put, destroy_put_job, dc_job->size);
+   }
+}
+
+
 void
 disk_cache_put(struct disk_cache *cache, const cache_key key,
                const void *data, size_t size,
@@ -544,14 +563,8 @@ disk_cache_put(struct disk_cache *cache, const cache_key key,
    if (cache->path_init_failed)
       return;
 
-   struct disk_cache_put_job *dc_job =
-      create_put_job(cache, key, (void*)data, size, cache_item_metadata, false);
-
-   if (dc_job) {
-      util_queue_fence_init(&dc_job->fence);
-      util_queue_add_job(&cache->cache_queue, dc_job, &dc_job->fence,
-                         cache_put, destroy_put_job, dc_job->size);
-   }
+   create_put_job_and_add_to_queue(cache, key, data, size, cache_item_metadata,
+                                   destroy_put_job, false);
 }
 
 void
@@ -570,14 +583,8 @@ disk_cache_put_nocopy(struct disk_cache *cache, const cache_key key,
       return;
    }
 
-   struct disk_cache_put_job *dc_job =
-      create_put_job(cache, key, data, size, cache_item_metadata, true);
-
-   if (dc_job) {
-      util_queue_fence_init(&dc_job->fence);
-      util_queue_add_job(&cache->cache_queue, dc_job, &dc_job->fence,
-                         cache_put, destroy_put_job_nocopy, dc_job->size);
-   }
+   create_put_job_and_add_to_queue(cache, key, data, size, cache_item_metadata,
+                                   destroy_put_job_nocopy, true);
 }
 
 void *
-- 
GitLab


From 940a93c3bc75e3d728bc88a6d542dfc9aaf8e735 Mon Sep 17 00:00:00 2001
From: Timothy Arceri <tarceri@itsqueeze.com>
Date: Mon, 28 Nov 2022 13:04:31 +1100
Subject: [PATCH 3/4] util/disk_cache: implement support for a dual layer cache

Cache metadata is currently only used by Steam to rebuild the glsl
caches index file. Here we use it to also add support for a dual
cache layer to help avoid duplicate shader binaries across the db.

This is useful for Vulkan drivers such as RADV which send the
pipeline as a single binary for storage in the cache.
---
 src/util/disk_cache.c    | 90 +++++++++++++++++++++++++++++++++++---
 src/util/disk_cache.h    | 16 ++++---
 src/util/disk_cache_os.c | 94 +++++++++++++++++++++++++++++++++-------
 3 files changed, 172 insertions(+), 28 deletions(-)

diff --git a/src/util/disk_cache.c b/src/util/disk_cache.c
index 5e5a24066a07..e46c1ab35f76 100644
--- a/src/util/disk_cache.c
+++ b/src/util/disk_cache.c
@@ -371,7 +371,7 @@ create_put_job(struct disk_cache *cache, const cache_key key,
       /* Copy the cache item metadata */
       if (cache_item_metadata) {
          dc_job->cache_item_metadata.type = cache_item_metadata->type;
-         if (cache_item_metadata->type == CACHE_ITEM_TYPE_GLSL) {
+         if (cache_item_metadata->type != CACHE_ITEM_TYPE_UNKNOWN) {
             dc_job->cache_item_metadata.num_keys =
                cache_item_metadata->num_keys;
             dc_job->cache_item_metadata.keys = (cache_key *)
@@ -549,6 +549,86 @@ create_put_job_and_add_to_queue(struct disk_cache *cache, const cache_key key,
    }
 }
 
+static void
+add_data_to_cache(struct disk_cache *cache, const cache_key key,
+                  const void *data, size_t size,
+                  struct cache_item_metadata *cache_item_metadata,
+                  util_queue_execute_func destroy_put_job, bool take_ownership)
+{
+   unsigned num_jobs;
+   if (cache_item_metadata &&
+       cache_item_metadata->type == CACHE_ITEM_TYPE_MULTI_SHADER_IDX &&
+       debug_get_bool_option("MESA_DISK_CACHE_SINGLE_FILE", false)) {
+      num_jobs = cache_item_metadata->num_shaders + 1;
+   } else {
+      cache_item_metadata = NULL;
+      num_jobs = 1;
+   }
+
+   assert(!cache_item_metadata ||
+          CACHE_MAX_SHADERS >= cache_item_metadata->num_shaders);
+   uint32_t data_offset = 0;
+   size_t data_size;
+   cache_key keys[CACHE_MAX_SHADERS];
+   for (unsigned i = 0; i < num_jobs; i++) {
+      if (i == 0) {
+         if (cache_item_metadata &&
+             cache_item_metadata->type == CACHE_ITEM_TYPE_MULTI_SHADER_IDX) {
+            assert(cache_item_metadata->keys == NULL);
+
+            /* Get a hash of the individual shader binaries */
+            data_offset = cache_item_metadata->header_size;
+            cache_item_metadata->num_keys = cache_item_metadata->num_shaders;
+            for (unsigned j = 0; j < cache_item_metadata->num_shaders; j++) {
+               data_size = cache_item_metadata->shader_sizes[j];
+               assert(data_size > 0);
+
+               struct mesa_sha1 ctx;
+               _mesa_sha1_init(&ctx);
+               _mesa_sha1_update(&ctx, ((uint8_t *) data) + data_offset, data_size);
+               _mesa_sha1_final(&ctx, keys[j]);
+               data_offset += cache_item_metadata->shader_sizes[j];
+            }
+            cache_item_metadata->keys =
+               malloc(sizeof(cache_key) * cache_item_metadata->num_keys);
+            memcpy(cache_item_metadata->keys, keys,
+                   sizeof(cache_key) * cache_item_metadata->num_keys);
+
+            /* We only need to store the the header here, the shader binaries
+             * will be stored separately below.
+             */
+            data_size = cache_item_metadata->header_size;
+
+            /* Reset data offset ready for when we store the shader binaries */
+            data_offset = cache_item_metadata->header_size;
+         } else {
+            data_size = size;
+         }
+
+         create_put_job_and_add_to_queue(cache, key, (void*)data,
+                                         data_size, cache_item_metadata,
+                                         destroy_put_job, take_ownership);
+      } else {
+         assert(cache_item_metadata->type == CACHE_ITEM_TYPE_MULTI_SHADER_IDX);
+
+         data_size = cache_item_metadata->shader_sizes[i - 1];
+         key = keys[i - 1];
+
+         create_put_job_and_add_to_queue(cache, key,
+                                         ((uint8_t *) data) + data_offset,
+                                         data_size, NULL, destroy_put_job,
+                                         take_ownership);
+         data_offset += data_size;
+      }
+   }
+
+   if (cache_item_metadata &&
+       cache_item_metadata->type == CACHE_ITEM_TYPE_MULTI_SHADER_IDX &&
+       debug_get_bool_option("MESA_DISK_CACHE_SINGLE_FILE", false)) {
+      free(cache_item_metadata->keys);
+   }
+}
+
 
 void
 disk_cache_put(struct disk_cache *cache, const cache_key key,
@@ -563,8 +643,8 @@ disk_cache_put(struct disk_cache *cache, const cache_key key,
    if (cache->path_init_failed)
       return;
 
-   create_put_job_and_add_to_queue(cache, key, data, size, cache_item_metadata,
-                                   destroy_put_job, false);
+   add_data_to_cache(cache, key, data, size, cache_item_metadata,
+                     destroy_put_job, false);
 }
 
 void
@@ -583,8 +663,8 @@ disk_cache_put_nocopy(struct disk_cache *cache, const cache_key key,
       return;
    }
 
-   create_put_job_and_add_to_queue(cache, key, data, size, cache_item_metadata,
-                                   destroy_put_job_nocopy, true);
+   add_data_to_cache(cache, key, data, size, cache_item_metadata,
+                     destroy_put_job_nocopy, true);
 }
 
 void *
diff --git a/src/util/disk_cache.h b/src/util/disk_cache.h
index 9a3bdf50ae67..b72c7c69a117 100644
--- a/src/util/disk_cache.h
+++ b/src/util/disk_cache.h
@@ -55,8 +55,9 @@ typedef uint8_t cache_key[CACHE_KEY_SIZE];
  * Do not change these values without making the change widely known.
  * Please contact Valve developers and make them aware of this change.
  */
-#define CACHE_ITEM_TYPE_UNKNOWN  0x0
-#define CACHE_ITEM_TYPE_GLSL     0x1
+#define CACHE_ITEM_TYPE_UNKNOWN          0x0
+#define CACHE_ITEM_TYPE_GLSL             0x1
+#define CACHE_ITEM_TYPE_MULTI_SHADER_IDX 0x2
 
 typedef void
 (*disk_cache_put_cb) (const void *key, signed long keySize,
@@ -68,14 +69,15 @@ typedef signed long
 
 struct cache_item_metadata {
    /**
-    * The cache item type. This could be used to identify a GLSL cache item,
-    * a certain type of IR (tgsi, nir, etc), or signal that it is the final
-    * binary form of the shader.
+    * The cache item type. This identifies what is stored in the cache item,
+    * for example it could be glsl program metadata, a shader binary or a
+    * number of cache keys that represent all the the shaders of a
+    * pipeline/program.
     */
    uint32_t type;
 
-   /** GLSL cache item metadata */
-   cache_key *keys;   /* sha1 list of shaders that make up the cache item */
+   /* sha1 list of shaders that make up the cache item */
+   cache_key *keys;
    uint32_t num_keys;
 
    /* The size of the cache items header before the shader data */
diff --git a/src/util/disk_cache_os.c b/src/util/disk_cache_os.c
index 27a139260597..3eab045c90bd 100644
--- a/src/util/disk_cache_os.c
+++ b/src/util/disk_cache_os.c
@@ -504,7 +504,8 @@ disk_cache_evict_item(struct disk_cache *cache, char *filename)
 
 static void *
 parse_and_validate_cache_item(struct disk_cache *cache, void *cache_item,
-                              size_t cache_item_size, size_t *size)
+                              size_t cache_item_size, size_t *size,
+                              struct cache_item_metadata *md)
 {
    uint8_t *uncompressed_data = NULL;
 
@@ -526,21 +527,22 @@ parse_and_validate_cache_item(struct disk_cache *cache, void *cache_item,
    if (ci_blob_reader.overrun)
       goto fail;
 
-   if (md_type == CACHE_ITEM_TYPE_GLSL) {
+   if (md_type != CACHE_ITEM_TYPE_UNKNOWN) {
       uint32_t num_keys = blob_read_uint32(&ci_blob_reader);
       if (ci_blob_reader.overrun)
          goto fail;
 
-      /* The cache item metadata is currently just used for distributing
-       * precompiled shaders, they are not used by Mesa so just skip them for
-       * now.
-       * TODO: pass the metadata back to the caller and do some basic
-       * validation.
-       */
-      const void UNUSED *metadata =
+      const void *metadata =
          blob_read_bytes(&ci_blob_reader, num_keys * sizeof(cache_key));
       if (ci_blob_reader.overrun)
          goto fail;
+
+      if (md && md_type == CACHE_ITEM_TYPE_MULTI_SHADER_IDX) {
+         md->type = CACHE_ITEM_TYPE_MULTI_SHADER_IDX;
+         md->keys = malloc(num_keys * sizeof(cache_key));
+         md->num_keys = num_keys;
+         memcpy(md->keys, metadata, sizeof(cache_key) * num_keys);
+      }
    }
 
    /* Load the CRC that was created when the file was written. */
@@ -608,7 +610,7 @@ disk_cache_load_item(struct disk_cache *cache, char *filename, size_t *size)
       goto fail;
 
     uint8_t *uncompressed_data =
-       parse_and_validate_cache_item(cache, data, sb.st_size, size);
+       parse_and_validate_cache_item(cache, data, sb.st_size, size, NULL);
    if (!uncompressed_data)
       goto fail;
 
@@ -689,7 +691,7 @@ create_cache_item_header_and_blob(struct disk_cache_put_job *dc_job,
    if (!blob_write_uint32(cache_blob, dc_job->cache_item_metadata.type))
       goto fail;
 
-   if (dc_job->cache_item_metadata.type == CACHE_ITEM_TYPE_GLSL) {
+   if (dc_job->cache_item_metadata.type != CACHE_ITEM_TYPE_UNKNOWN) {
       if (!blob_write_uint32(cache_blob, dc_job->cache_item_metadata.num_keys))
          goto fail;
 
@@ -958,22 +960,81 @@ disk_cache_enabled()
    return true;
 }
 
-void *
-disk_cache_load_item_foz(struct disk_cache *cache, const cache_key key,
-                         size_t *size)
+static void *
+load_item_foz(struct disk_cache *cache, const cache_key key, size_t *size,
+              struct cache_item_metadata *md)
 {
    size_t cache_tem_size = 0;
    void *cache_item = foz_read_entry(&cache->foz_db, key, &cache_tem_size);
    if (!cache_item)
       return NULL;
 
+   md->type = CACHE_ITEM_TYPE_UNKNOWN;
    uint8_t *uncompressed_data =
-       parse_and_validate_cache_item(cache, cache_item, cache_tem_size, size);
+      parse_and_validate_cache_item(cache, cache_item, cache_tem_size, size, md);
    free(cache_item);
 
    return uncompressed_data;
 }
 
+void *
+disk_cache_load_item_foz(struct disk_cache *cache, const cache_key key,
+                         size_t *size)
+{
+   struct cache_item_metadata md;
+   md.num_keys = 0;
+   md.keys = NULL;
+   md.type = CACHE_ITEM_TYPE_UNKNOWN;
+
+   size_t item_size = 0;
+   uint8_t *uncompressed_data = load_item_foz(cache, key, &item_size, &md);
+
+   assert(CACHE_MAX_SHADERS >= md.num_keys);
+   uint8_t *data[CACHE_MAX_SHADERS];
+   size_t data_size[CACHE_MAX_SHADERS];
+   if (md.type == CACHE_ITEM_TYPE_MULTI_SHADER_IDX) {
+      /* Load individual shaders */
+      size_t full_size = item_size;
+      for (unsigned i = 0; i < md.num_keys; i++) {
+         data[i] = load_item_foz(cache, md.keys[i], &data_size[i], &md);
+
+         /* If the shader data hasn't been written yet or was removed free
+          * the temp memory and return NULL.
+          */
+         if (!data[i]) {
+            for (unsigned j = 0; j < i; j++) {
+               free(data[j]);
+            }
+            free(uncompressed_data);
+            free(md.keys);
+
+            return NULL;
+         }
+         full_size += data_size[i];
+      }
+      free(md.keys);
+
+      /* Rebuild a single cache item */
+      uint32_t offset = item_size;
+      uint8_t *rebuilt_data = malloc(full_size);
+      memcpy(rebuilt_data, uncompressed_data, item_size);
+      for (unsigned i = 0; i < md.num_keys; i++) {
+         memcpy(rebuilt_data + offset, data[i], data_size[i]);
+         offset += data_size[i];
+         free(data[i]);
+      }
+      free(uncompressed_data);
+      uncompressed_data = rebuilt_data;
+
+      item_size = full_size;
+   }
+
+   if (size)
+      *size = item_size;
+
+   return uncompressed_data;
+}
+
 bool
 disk_cache_write_item_to_disk_foz(struct disk_cache_put_job *dc_job)
 {
@@ -1072,7 +1133,8 @@ disk_cache_db_load_item(struct disk_cache *cache, const cache_key key,
       return NULL;
 
    uint8_t *uncompressed_data =
-       parse_and_validate_cache_item(cache, cache_item, cache_tem_size, size);
+       parse_and_validate_cache_item(cache, cache_item, cache_tem_size, size,
+                                     NULL);
    free(cache_item);
 
    return uncompressed_data;
-- 
GitLab


From 3a51d83a788804c1ca4182c92d4ff1b1daaca6eb Mon Sep 17 00:00:00 2001
From: Timothy Arceri <tarceri@itsqueeze.com>
Date: Mon, 13 Feb 2023 10:55:26 +1100
Subject: [PATCH 4/4] radv: make use of dual layer disk cache

This reduces the size of the mesa single file cache after running
the fossils in https://gitlab.freedesktop.org/pendingchaos/radv_fossils
from 188.5MB -> 115.5MB
---
 src/amd/vulkan/radv_pipeline_cache.c | 9 ++++++++-
 1 file changed, 8 insertions(+), 1 deletion(-)

diff --git a/src/amd/vulkan/radv_pipeline_cache.c b/src/amd/vulkan/radv_pipeline_cache.c
index dba7143546b9..729e9047c891 100644
--- a/src/amd/vulkan/radv_pipeline_cache.c
+++ b/src/amd/vulkan/radv_pipeline_cache.c
@@ -472,6 +472,11 @@ radv_pipeline_cache_insert_shaders(struct radv_device *device, struct radv_pipel
 
    char *p = entry->code;
 
+   struct cache_item_metadata cm;
+   cm.num_shaders = 0;
+   cm.keys = NULL;
+   cm.header_size = entry->code - (char *)entry;
+   cm.type = CACHE_ITEM_TYPE_MULTI_SHADER_IDX;
    for (int i = 0; i < MESA_VULKAN_SHADER_STAGES; ++i) {
       if (!pipeline->shaders[i])
          continue;
@@ -480,6 +485,8 @@ radv_pipeline_cache_insert_shaders(struct radv_device *device, struct radv_pipel
 
       memcpy(p, binaries[i], binaries[i]->total_size);
       p += binaries[i]->total_size;
+
+      cm.shader_sizes[cm.num_shaders++] = binaries[i]->total_size;
    }
 
    if (num_stack_sizes) {
@@ -504,7 +511,7 @@ radv_pipeline_cache_insert_shaders(struct radv_device *device, struct radv_pipel
       disk_cache_compute_key(device->physical_device->vk.disk_cache, sha1, SHA1_DIGEST_LENGTH, disk_sha1);
 
       disk_cache_put(device->physical_device->vk.disk_cache, disk_sha1, entry, entry_size(entry),
-                     NULL);
+                     &cm);
    }
 
    if (device->instance->debug_flags & RADV_DEBUG_NO_MEMORY_CACHE && cache == device->mem_cache) {
-- 
GitLab

