From ba24c93a07340b027e23983f5aecc6d8a245cfeb Mon Sep 17 00:00:00 2001
From: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
Date: Fri, 18 Aug 2023 11:53:34 +0200
Subject: [PATCH 1/3] radeonsi/sdma: use multiple commands if required

Instead of failing the copy we can use multiple chunks.

This codepath shouldn't really be used since the source
image should usually be tiled but it still better to not
fail when possible.
---
 .../drivers/radeonsi/si_sdma_copy_image.c     | 30 +++++++++++--------
 1 file changed, 18 insertions(+), 12 deletions(-)

diff --git a/src/gallium/drivers/radeonsi/si_sdma_copy_image.c b/src/gallium/drivers/radeonsi/si_sdma_copy_image.c
index e5d4506c9f03..b42d1e40afb3 100644
--- a/src/gallium/drivers/radeonsi/si_sdma_copy_image.c
+++ b/src/gallium/drivers/radeonsi/si_sdma_copy_image.c
@@ -73,23 +73,29 @@ static bool si_sdma_v4_v5_copy_texture(struct si_context *sctx, struct si_textur
       struct radeon_cmdbuf *cs = sctx->sdma_cs;
 
       uint64_t bytes = (uint64_t)src_pitch * copy_height * bpp;
-
-      if (!(bytes <= (1u << (is_v5_2 ? 30 : 22))))
-         return false;
+      uint32_t chunk_size = 1u << (is_v5_2 ? 30 : 22);
+      uint32_t chunk_count = DIV_ROUND_UP(bytes, chunk_size);
 
       src_address += ssrc->surface.u.gfx9.offset[0];
       dst_address += sdst->surface.u.gfx9.offset[0];
 
       radeon_begin(cs);
-      radeon_emit(CIK_SDMA_PACKET(CIK_SDMA_OPCODE_COPY,
-                                  CIK_SDMA_COPY_SUB_OPCODE_LINEAR,
-                                  (tmz ? 4 : 0)));
-      radeon_emit(bytes - 1);
-      radeon_emit(0);
-      radeon_emit(src_address);
-      radeon_emit(src_address >> 32);
-      radeon_emit(dst_address);
-      radeon_emit(dst_address >> 32);
+      for (int i = 0; i < chunk_count; i++) {
+         uint32_t size = MIN2(chunk_size, bytes);
+         radeon_emit(CIK_SDMA_PACKET(CIK_SDMA_OPCODE_COPY,
+                                     CIK_SDMA_COPY_SUB_OPCODE_LINEAR,
+                                     (tmz ? 4 : 0)));
+         radeon_emit(size - 1);
+         radeon_emit(0);
+         radeon_emit(src_address);
+         radeon_emit(src_address >> 32);
+         radeon_emit(dst_address);
+         radeon_emit(dst_address >> 32);
+
+         src_address += size;
+         dst_address += size;
+         bytes -= size;
+      }
       radeon_end();
       return true;
    }
-- 
GitLab


From 101bff9c0b6feb7772b5cb4f3b34b0f5fd7c6e65 Mon Sep 17 00:00:00 2001
From: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
Date: Fri, 18 Aug 2023 11:57:27 +0200
Subject: [PATCH 2/3] radv/sdma: use multiple commands if required

Instead of failing the copy we can use multiple chunks.

This codepath shouldn't really be used since the source
image should usually be tiled but it still better to not
fail when possible.
---
 src/amd/vulkan/radv_sdma_copy_image.c | 28 +++++++++++++++++----------
 1 file changed, 18 insertions(+), 10 deletions(-)

diff --git a/src/amd/vulkan/radv_sdma_copy_image.c b/src/amd/vulkan/radv_sdma_copy_image.c
index d81dc12057f5..a567eb2c3183 100644
--- a/src/amd/vulkan/radv_sdma_copy_image.c
+++ b/src/amd/vulkan/radv_sdma_copy_image.c
@@ -22,6 +22,7 @@
  * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
  * USE OR OTHER DEALINGS IN THE SOFTWARE.
  */
+#include "util/macros.h"
 #include "util/u_memory.h"
 #include "radv_cs.h"
 #include "radv_private.h"
@@ -41,21 +42,28 @@ radv_sdma_v4_v5_copy_image_to_buffer(struct radv_device *device, struct radeon_c
 
    /* Linear -> linear sub-window copy. */
    if (image->planes[0].surface.is_linear) {
-      ASSERTED unsigned cdw_max = radeon_check_space(device->ws, cs, 7);
       uint64_t bytes = (uint64_t)src_pitch * copy_height * bpp;
+      uint32_t chunk_size = 1u << 22;
+      uint32_t chunk_count = DIV_ROUND_UP(bytes, chunk_size);
 
-      if (!(bytes < (1u << 22)))
-         return false;
+      ASSERTED unsigned cdw_max = radeon_check_space(device->ws, cs, 7 * chunk_count);
 
       src_address += image->planes[0].surface.u.gfx9.offset[0];
 
-      radeon_emit(cs, CIK_SDMA_PACKET(CIK_SDMA_OPCODE_COPY, CIK_SDMA_COPY_SUB_OPCODE_LINEAR, (tmz ? 4 : 0)));
-      radeon_emit(cs, bytes - 1);
-      radeon_emit(cs, 0);
-      radeon_emit(cs, src_address);
-      radeon_emit(cs, src_address >> 32);
-      radeon_emit(cs, dst_address);
-      radeon_emit(cs, dst_address >> 32);
+      for (int i = 0; i < chunk_count; i++) {
+         uint32_t size = MIN2(chunk_size, bytes);
+         radeon_emit(cs, CIK_SDMA_PACKET(CIK_SDMA_OPCODE_COPY, CIK_SDMA_COPY_SUB_OPCODE_LINEAR, (tmz ? 4 : 0)));
+         radeon_emit(cs, size - 1);
+         radeon_emit(cs, 0);
+         radeon_emit(cs, src_address);
+         radeon_emit(cs, src_address >> 32);
+         radeon_emit(cs, dst_address);
+         radeon_emit(cs, dst_address >> 32);
+
+         src_address += size;
+         dst_address += size;
+         bytes -= size;
+      }
 
       assert(cs->cdw <= cdw_max);
 
-- 
GitLab


From aff3b3c3472a3da6de618ea7f5df0d959a3253ce Mon Sep 17 00:00:00 2001
From: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
Date: Fri, 18 Aug 2023 11:58:27 +0200
Subject: [PATCH 3/3] radv/sdma: use correct limits for gfx10.3

---
 src/amd/vulkan/radv_sdma_copy_image.c | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/src/amd/vulkan/radv_sdma_copy_image.c b/src/amd/vulkan/radv_sdma_copy_image.c
index a567eb2c3183..1a5d1584f1b9 100644
--- a/src/amd/vulkan/radv_sdma_copy_image.c
+++ b/src/amd/vulkan/radv_sdma_copy_image.c
@@ -42,8 +42,9 @@ radv_sdma_v4_v5_copy_image_to_buffer(struct radv_device *device, struct radeon_c
 
    /* Linear -> linear sub-window copy. */
    if (image->planes[0].surface.is_linear) {
+      bool is_v5_2 = device->physical_device->rad_info.gfx_level >= GFX10_3;
       uint64_t bytes = (uint64_t)src_pitch * copy_height * bpp;
-      uint32_t chunk_size = 1u << 22;
+      uint32_t chunk_size = 1u << (is_v5_2 ? 30 : 22);
       uint32_t chunk_count = DIV_ROUND_UP(bytes, chunk_size);
 
       ASSERTED unsigned cdw_max = radeon_check_space(device->ws, cs, 7 * chunk_count);
-- 
GitLab

