From 2ffdd8e6e495f03b990ba13b1d0f665d233ee8d7 Mon Sep 17 00:00:00 2001
From: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
Date: Fri, 7 Apr 2023 09:47:09 +0200
Subject: [PATCH 1/5] amd: update amdgpu_drm.h

---
 include/drm-uapi/amdgpu_drm.h | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/include/drm-uapi/amdgpu_drm.h b/include/drm-uapi/amdgpu_drm.h
index b6eb90df5d05..3d820750c1c9 100644
--- a/include/drm-uapi/amdgpu_drm.h
+++ b/include/drm-uapi/amdgpu_drm.h
@@ -245,6 +245,8 @@ union drm_amdgpu_bo_list {
 /* indicate some errors are detected by RAS */
 #define AMDGPU_CTX_QUERY2_FLAGS_RAS_CE   (1<<3)
 #define AMDGPU_CTX_QUERY2_FLAGS_RAS_UE   (1<<4)
+/* indicate that the reset hasn't completed yet */
+#define AMDGPU_CTX_QUERY2_FLAGS_RESET_IN_PROGRESS (1<<5)
 
 /* Context priority level */
 #define AMDGPU_CTX_PRIORITY_UNSET       -2048
-- 
GitLab


From 354961777b79be7064e8a4ac3383b37869f0e4eb Mon Sep 17 00:00:00 2001
From: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
Date: Fri, 7 Apr 2023 09:48:02 +0200
Subject: [PATCH 2/5] radeonsi: stop reporting reset to app once gpu recovery
 is done

This way apps know they can recreate their contexts when
the status go back to NO_ERROR.

This depends on new UAPI in the kernel; for older kernel, radeonsi
will stop reporting a reset after 3 seconds. Apps will be able to
create new contexts but they'll have to handle not being able to
submit tasks.

Closes: https://gitlab.freedesktop.org/mesa/mesa/-/issues/7460
---
 src/gallium/drivers/radeonsi/si_gfx_cs.c      |  2 +-
 src/gallium/drivers/radeonsi/si_pipe.c        | 24 +++++++++++++------
 src/gallium/drivers/radeonsi/si_pipe.h        |  1 +
 src/gallium/include/winsys/radeon_winsys.h    |  2 +-
 src/gallium/winsys/amdgpu/drm/amdgpu_cs.c     | 14 ++++++++++-
 src/gallium/winsys/radeon/drm/radeon_drm_cs.c |  2 +-
 6 files changed, 34 insertions(+), 11 deletions(-)

diff --git a/src/gallium/drivers/radeonsi/si_gfx_cs.c b/src/gallium/drivers/radeonsi/si_gfx_cs.c
index e6e94ce64d09..011f4d2497c0 100644
--- a/src/gallium/drivers/radeonsi/si_gfx_cs.c
+++ b/src/gallium/drivers/radeonsi/si_gfx_cs.c
@@ -80,7 +80,7 @@ void si_flush_gfx_cs(struct si_context *ctx, unsigned flags, struct pipe_fence_h
     * while si_get_reset_status can't. */
    if (!(ctx->context_flags & SI_CONTEXT_FLAG_AUX) &&
        ctx->device_reset_callback.reset) {
-      enum pipe_reset_status status = ctx->ws->ctx_query_reset_status(ctx->ctx, true, NULL);
+      enum pipe_reset_status status = ctx->ws->ctx_query_reset_status(ctx->ctx, true, NULL, NULL);
       if (status != PIPE_NO_RESET)
          ctx->device_reset_callback.reset(ctx->device_reset_callback.data, status);
    }
diff --git a/src/gallium/drivers/radeonsi/si_pipe.c b/src/gallium/drivers/radeonsi/si_pipe.c
index 737675848f01..02d1a0cee06c 100644
--- a/src/gallium/drivers/radeonsi/si_pipe.c
+++ b/src/gallium/drivers/radeonsi/si_pipe.c
@@ -26,6 +26,7 @@
 #include "si_pipe.h"
 
 #include "driver_ddebug/dd_util.h"
+#include "pipe/p_defines.h"
 #include "radeon_uvd.h"
 #include "si_compute.h"
 #include "si_public.h"
@@ -380,18 +381,27 @@ static void si_destroy_context(struct pipe_context *context)
 static enum pipe_reset_status si_get_reset_status(struct pipe_context *ctx)
 {
    struct si_context *sctx = (struct si_context *)ctx;
+
    if (sctx->context_flags & SI_CONTEXT_FLAG_AUX)
       return PIPE_NO_RESET;
 
-   bool needs_reset;
-   enum pipe_reset_status status = sctx->ws->ctx_query_reset_status(sctx->ctx, false, &needs_reset);
+   bool needs_reset, reset_completed;
+   enum pipe_reset_status status = sctx->ws->ctx_query_reset_status(sctx->ctx, false,
+                                                                    &needs_reset, &reset_completed);
+
+   if (status != PIPE_NO_RESET) {
+      if (sctx->has_reset_been_notified && reset_completed)
+         return PIPE_NO_RESET;
 
-   if (status != PIPE_NO_RESET && needs_reset && !(sctx->context_flags & SI_CONTEXT_FLAG_AUX)) {
-      /* Call the gallium frontend to set a no-op API dispatch. */
-      if (sctx->device_reset_callback.reset) {
-         sctx->device_reset_callback.reset(sctx->device_reset_callback.data, status);
+      sctx->has_reset_been_notified = true;
+
+      if (!(sctx->context_flags & SI_CONTEXT_FLAG_AUX)) {
+         /* Call the gallium frontend to set a no-op API dispatch. */
+         if (needs_reset && sctx->device_reset_callback.reset)
+            sctx->device_reset_callback.reset(sctx->device_reset_callback.data, status);
       }
    }
+
    return status;
 }
 
@@ -816,7 +826,7 @@ static struct pipe_context *si_create_context(struct pipe_screen *screen, unsign
       struct si_context *saux = si_get_aux_context(sscreen);
 
       enum pipe_reset_status status = sctx->ws->ctx_query_reset_status(
-         saux->ctx, true, NULL);
+         saux->ctx, true, NULL, NULL);
       if (status != PIPE_NO_RESET) {
          /* We lost the aux_context, create a new one */
          struct u_log_context *aux_log = (saux)->log;
diff --git a/src/gallium/drivers/radeonsi/si_pipe.h b/src/gallium/drivers/radeonsi/si_pipe.h
index 91efb8b188d1..6680d0ebbdc9 100644
--- a/src/gallium/drivers/radeonsi/si_pipe.h
+++ b/src/gallium/drivers/radeonsi/si_pipe.h
@@ -1208,6 +1208,7 @@ struct si_context {
    bool dpbb_force_off_profile_ps;
    bool vs_writes_viewport_index;
    bool vs_disables_clipping_viewport;
+   bool has_reset_been_notified;
 
    /* Precomputed IA_MULTI_VGT_PARAM */
    union si_vgt_param_key ia_multi_vgt_param_key;
diff --git a/src/gallium/include/winsys/radeon_winsys.h b/src/gallium/include/winsys/radeon_winsys.h
index ad5810872d03..735d7ac34440 100644
--- a/src/gallium/include/winsys/radeon_winsys.h
+++ b/src/gallium/include/winsys/radeon_winsys.h
@@ -527,7 +527,7 @@ struct radeon_winsys {
     */
    enum pipe_reset_status (*ctx_query_reset_status)(struct radeon_winsys_ctx *ctx,
                                                     bool full_reset_only,
-                                                    bool *needs_reset);
+                                                    bool *needs_reset, bool *reset_completed);
 
    /**
     * Create a command stream.
diff --git a/src/gallium/winsys/amdgpu/drm/amdgpu_cs.c b/src/gallium/winsys/amdgpu/drm/amdgpu_cs.c
index 7ac0118d7ada..b5ab7dbe8128 100644
--- a/src/gallium/winsys/amdgpu/drm/amdgpu_cs.c
+++ b/src/gallium/winsys/amdgpu/drm/amdgpu_cs.c
@@ -349,7 +349,7 @@ static void amdgpu_ctx_destroy(struct radeon_winsys_ctx *rwctx)
 
 static enum pipe_reset_status
 amdgpu_ctx_query_reset_status(struct radeon_winsys_ctx *rwctx, bool full_reset_only,
-                              bool *needs_reset)
+                              bool *needs_reset, bool *reset_completed)
 {
    struct amdgpu_ctx *ctx = (struct amdgpu_ctx*)rwctx;
    int r;
@@ -376,6 +376,18 @@ amdgpu_ctx_query_reset_status(struct radeon_winsys_ctx *rwctx, bool full_reset_o
       }
 
       if (flags & AMDGPU_CTX_QUERY2_FLAGS_RESET) {
+         if (reset_completed) {
+            /* The ARB_robustness spec says:
+             *
+             *    If a reset status other than NO_ERROR is returned and subsequent
+             *    calls return NO_ERROR, the context reset was encountered and
+             *    completed. If a reset status is repeatedly returned, the context may
+             *    be in the process of resetting.
+             *
+             */
+            if (!(flags & AMDGPU_CTX_QUERY2_FLAGS_RESET_IN_PROGRESS))
+               *reset_completed = true;
+         }
          if (needs_reset)
                *needs_reset = flags & AMDGPU_CTX_QUERY2_FLAGS_VRAMLOST;
          if (flags & AMDGPU_CTX_QUERY2_FLAGS_GUILTY)
diff --git a/src/gallium/winsys/radeon/drm/radeon_drm_cs.c b/src/gallium/winsys/radeon/drm/radeon_drm_cs.c
index 45342a68095b..b50f964c34fe 100644
--- a/src/gallium/winsys/radeon/drm/radeon_drm_cs.c
+++ b/src/gallium/winsys/radeon/drm/radeon_drm_cs.c
@@ -89,7 +89,7 @@ static void radeon_drm_ctx_destroy(struct radeon_winsys_ctx *ctx)
 
 static enum pipe_reset_status
 radeon_drm_ctx_query_reset_status(struct radeon_winsys_ctx *rctx, bool full_reset_only,
-                                  bool *needs_reset)
+                                  bool *needs_reset, bool *reset_completed)
 {
    struct radeon_ctx *ctx = (struct radeon_ctx*)rctx;
 
-- 
GitLab


From 72cbf6c1665746c173277d92ab9202331d909f1c Mon Sep 17 00:00:00 2001
From: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
Date: Fri, 7 Apr 2023 09:23:04 +0200
Subject: [PATCH 3/5] winsys/amdgpu: add a helper function to submit a no-op
 job

This will be used in the next commit.
---
 src/gallium/winsys/amdgpu/drm/amdgpu_cs.c | 83 +++++++++++++++++++++++
 1 file changed, 83 insertions(+)

diff --git a/src/gallium/winsys/amdgpu/drm/amdgpu_cs.c b/src/gallium/winsys/amdgpu/drm/amdgpu_cs.c
index b5ab7dbe8128..dd78d60205c8 100644
--- a/src/gallium/winsys/amdgpu/drm/amdgpu_cs.c
+++ b/src/gallium/winsys/amdgpu/drm/amdgpu_cs.c
@@ -347,6 +347,89 @@ static void amdgpu_ctx_destroy(struct radeon_winsys_ctx *rwctx)
    amdgpu_ctx_unref((struct amdgpu_ctx*)rwctx);
 }
 
+static int amdgpu_submit_gfx_nop(amdgpu_device_handle dev)
+{
+   struct amdgpu_bo_alloc_request request = {0};
+   struct drm_amdgpu_bo_list_in bo_list_in;
+   struct drm_amdgpu_cs_chunk_ib ib_in = {0};
+   amdgpu_bo_handle buf_handle;
+   amdgpu_va_handle va_handle = NULL;
+   struct drm_amdgpu_cs_chunk chunks[2];
+   void *cpu = NULL;
+   uint64_t seq_no;
+   uint64_t va;
+   int r;
+
+   /* Older amdgpu doesn't report if the reset is complete or not. Detect
+    * it by submitting a no-op job. If it reports an error, then assume
+    * that the reset is not complete.
+    */
+   amdgpu_context_handle temp_ctx;
+   r = amdgpu_cs_ctx_create2(dev, AMDGPU_CTX_PRIORITY_NORMAL, &temp_ctx);
+   if (r)
+      return r;
+
+   request.preferred_heap = AMDGPU_GEM_DOMAIN_VRAM;
+   request.alloc_size = 4096;
+   request.phys_alignment = 4096;
+   r = amdgpu_bo_alloc(dev, &request, &buf_handle);
+   if (r)
+      goto destroy_ctx;
+
+   r = amdgpu_va_range_alloc(dev, amdgpu_gpu_va_range_general,
+                 request.alloc_size, request.phys_alignment,
+                 0, &va, &va_handle,
+                 AMDGPU_VA_RANGE_32_BIT | AMDGPU_VA_RANGE_HIGH);
+   if (r)
+      goto destroy_bo;
+   r = amdgpu_bo_va_op_raw(dev, buf_handle, 0, request.alloc_size, va,
+                           AMDGPU_VM_PAGE_READABLE | AMDGPU_VM_PAGE_WRITEABLE | AMDGPU_VM_PAGE_EXECUTABLE,
+                           AMDGPU_VA_OP_MAP);
+   if (r)
+      goto destroy_bo;
+
+   r = amdgpu_bo_cpu_map(buf_handle, &cpu);
+   if (r)
+      goto destroy_bo;
+
+   /* Use a single NOP. */
+   ((uint32_t*)cpu)[0] = PKT3_NOP_PAD;
+
+   amdgpu_bo_cpu_unmap(buf_handle);
+
+   struct drm_amdgpu_bo_list_entry list;
+   amdgpu_bo_export(buf_handle, amdgpu_bo_handle_type_kms, &list.bo_handle);
+   list.bo_priority = 0;
+
+   bo_list_in.list_handle = ~0;
+   bo_list_in.bo_number = 1;
+   bo_list_in.bo_info_size = sizeof(struct drm_amdgpu_bo_list_entry);
+   bo_list_in.bo_info_ptr = (uint64_t)(uintptr_t)&list;
+
+   ib_in.ip_type = AMD_IP_GFX;
+   ib_in.ib_bytes = 4;
+   ib_in.va_start = va;
+
+   chunks[0].chunk_id = AMDGPU_CHUNK_ID_BO_HANDLES;
+   chunks[0].length_dw = sizeof(struct drm_amdgpu_bo_list_in) / 4;
+   chunks[0].chunk_data = (uintptr_t)&bo_list_in;
+
+   chunks[1].chunk_id = AMDGPU_CHUNK_ID_IB;
+   chunks[1].length_dw = sizeof(struct drm_amdgpu_cs_chunk_ib) / 4;
+   chunks[1].chunk_data = (uintptr_t)&ib_in;
+
+   r = amdgpu_cs_submit_raw2(dev, temp_ctx, 0, 2, chunks, &seq_no);
+
+destroy_bo:
+   if (va_handle)
+      amdgpu_va_range_free(va_handle);
+   amdgpu_bo_free(buf_handle);
+destroy_ctx:
+   amdgpu_cs_ctx_free(temp_ctx);
+
+   return r;
+}
+
 static enum pipe_reset_status
 amdgpu_ctx_query_reset_status(struct radeon_winsys_ctx *rwctx, bool full_reset_only,
                               bool *needs_reset, bool *reset_completed)
-- 
GitLab


From f2339f7083975a34965045630e84625334cd82f3 Mon Sep 17 00:00:00 2001
From: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
Date: Fri, 7 Apr 2023 09:24:03 +0200
Subject: [PATCH 4/5] winsys/amdgpu: use the no-op helper to detect if reset
 completion

On older kernel the completion of the reset isn't signalled to userspace,
yet we need it to implement the EXT_robustness extension correctly.

In this situation, try to create a new context and submit a no-op job. If
the reset isn't done the kernel will reject the submission (-ECANCELED);
otherwise the submission will go through and we'll know that the reset is
done.
---
 src/gallium/winsys/amdgpu/drm/amdgpu_cs.c | 7 +++++++
 1 file changed, 7 insertions(+)

diff --git a/src/gallium/winsys/amdgpu/drm/amdgpu_cs.c b/src/gallium/winsys/amdgpu/drm/amdgpu_cs.c
index dd78d60205c8..0e7bb2b11891 100644
--- a/src/gallium/winsys/amdgpu/drm/amdgpu_cs.c
+++ b/src/gallium/winsys/amdgpu/drm/amdgpu_cs.c
@@ -467,10 +467,17 @@ amdgpu_ctx_query_reset_status(struct radeon_winsys_ctx *rwctx, bool full_reset_o
              *    completed. If a reset status is repeatedly returned, the context may
              *    be in the process of resetting.
              *
+             * Starting with drm_minor >= 53 amdgpu reports if the reset is complete,
+             * so don't do anything special. On older kernels, submit a no-op cs. If it
+             * succeeds then assume the reset is complete.
              */
             if (!(flags & AMDGPU_CTX_QUERY2_FLAGS_RESET_IN_PROGRESS))
                *reset_completed = true;
+
+            if (ctx->ws->info.drm_minor < 53 && ctx->ws->info.has_graphics)
+               *reset_completed = amdgpu_submit_gfx_nop(ctx->ws->dev) == 0;
          }
+
          if (needs_reset)
                *needs_reset = flags & AMDGPU_CTX_QUERY2_FLAGS_VRAMLOST;
          if (flags & AMDGPU_CTX_QUERY2_FLAGS_GUILTY)
-- 
GitLab


From 3da53248db9a1f6e488c166b2ab13f587bee037d Mon Sep 17 00:00:00 2001
From: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
Date: Fri, 7 Apr 2023 09:28:43 +0200
Subject: [PATCH 5/5] mesa: don't share reset status across contexts

If Driver.GetGraphicsResetStatus exists for one context, other contexts
will be able to use it; so there's no need to inherit reset status from
the other contexts.

This also prevented implementing the spec correctly: we're supposed to
report GL_NO_ERROR when the reset is completed (after reporting GL_*_RESET
at least once):

    If a reset status other than NO_ERROR is returned and subsequent
    calls return NO_ERROR, the context reset was encountered and
    completed. If a reset status is repeatedly returned, the context may
    be in the process of resetting.

With the existing code, the contexts will report INNOCENT_CONTEXT_RESET
forever.
---
 src/mesa/main/robustness.c | 23 ++---------------------
 1 file changed, 2 insertions(+), 21 deletions(-)

diff --git a/src/mesa/main/robustness.c b/src/mesa/main/robustness.c
index 6f0b984d7e04..abe6d0f6afec 100644
--- a/src/mesa/main/robustness.c
+++ b/src/mesa/main/robustness.c
@@ -133,29 +133,10 @@ _mesa_GetGraphicsResetStatusARB( void )
       return GL_NO_ERROR;
    }
 
-   if (ctx->Driver.GetGraphicsResetStatus) {
-      /* Query the reset status of this context from the driver core.
-       */
+   /* Query the reset status of this context from the driver core. */
+   if (ctx->Driver.GetGraphicsResetStatus)
       status = ctx->Driver.GetGraphicsResetStatus(ctx);
 
-      simple_mtx_lock(&ctx->Shared->Mutex);
-
-      /* If this context has not been affected by a GPU reset, check to see if
-       * some other context in the share group has been affected by a reset.
-       * If another context saw a reset but this context did not, assume that
-       * this context was not guilty.
-       */
-      if (status != GL_NO_ERROR) {
-         ctx->Shared->ShareGroupReset = true;
-         ctx->Shared->DisjointOperation = true;
-      } else if (ctx->Shared->ShareGroupReset && !ctx->ShareGroupReset) {
-         status = GL_INNOCENT_CONTEXT_RESET_ARB;
-      }
-
-      ctx->ShareGroupReset = ctx->Shared->ShareGroupReset;
-      simple_mtx_unlock(&ctx->Shared->Mutex);
-   }
-
    if (status != GL_NO_ERROR)
       _mesa_set_context_lost_dispatch(ctx);
 
-- 
GitLab

