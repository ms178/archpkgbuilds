From 633877f3f5c0967dce3965eab1872ae8c5e4b2e0 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Mon, 26 Dec 2022 10:03:59 +0800
Subject: [PATCH 1/3] radeonsi: only init llvm output when needed.

These are the cases which still uses nir_store_output.

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/gallium/drivers/radeonsi/si_shader_llvm.c | 33 +++++++++++--------
 1 file changed, 19 insertions(+), 14 deletions(-)

diff --git a/src/gallium/drivers/radeonsi/si_shader_llvm.c b/src/gallium/drivers/radeonsi/si_shader_llvm.c
index 3c199e58b7f4..692222a809e7 100644
--- a/src/gallium/drivers/radeonsi/si_shader_llvm.c
+++ b/src/gallium/drivers/radeonsi/si_shader_llvm.c
@@ -1025,23 +1025,28 @@ bool si_llvm_translate_nir(struct si_shader_context *ctx, struct si_shader *shad
    ctx->abi.use_waterfall_for_divergent_tex_samplers = true;
    ctx->abi.disable_aniso_single_level = true;
 
-   unsigned num_outputs = info->num_outputs;
-   /* need extra output to hold primitive id added by nir lower */
-   if (ctx->stage <= MESA_SHADER_GEOMETRY &&
-       ctx->shader->key.ge.mono.u.vs_export_prim_id)
-      num_outputs++;
+   bool ls_need_output =
+      ctx->stage == MESA_SHADER_VERTEX && shader->key.ge.as_ls &&
+      shader->key.ge.opt.same_patch_vertices;
+
+   bool tcs_need_output =
+      ctx->stage == MESA_SHADER_TESS_CTRL && info->tessfactors_are_def_in_all_invocs;
 
-   for (unsigned i = 0; i < num_outputs; i++) {
-      LLVMTypeRef type = ctx->ac.f32;
+   bool ps_need_output = ctx->stage == MESA_SHADER_FRAGMENT;
 
-      /* Only FS uses unpacked f16. Other stages pack 16-bit outputs into low and high bits of f32. */
-      if (nir->info.stage == MESA_SHADER_FRAGMENT &&
-          nir_alu_type_get_type_size(ctx->shader->selector->info.output_type[i]) == 16)
-         type = ctx->ac.f16;
+   if (ls_need_output || tcs_need_output || ps_need_output) {
+      for (unsigned i = 0; i < info->num_outputs; i++) {
+         LLVMTypeRef type = ctx->ac.f32;
 
-      for (unsigned j = 0; j < 4; j++) {
-         ctx->abi.outputs[i * 4 + j] = ac_build_alloca_undef(&ctx->ac, type, "");
-         ctx->abi.is_16bit[i * 4 + j] = type == ctx->ac.f16;
+         /* Only FS uses unpacked f16. Other stages pack 16-bit outputs into low and high bits of f32. */
+         if (nir->info.stage == MESA_SHADER_FRAGMENT &&
+             nir_alu_type_get_type_size(ctx->shader->selector->info.output_type[i]) == 16)
+            type = ctx->ac.f16;
+
+         for (unsigned j = 0; j < 4; j++) {
+            ctx->abi.outputs[i * 4 + j] = ac_build_alloca_undef(&ctx->ac, type, "");
+            ctx->abi.is_16bit[i * 4 + j] = type == ctx->ac.f16;
+         }
       }
    }
 
-- 
GitLab


From 06726b6ed3e855c23de737d4c2490d23b2bc6eab Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Mon, 26 Dec 2022 11:38:56 +0800
Subject: [PATCH 2/3] ac/llvm: only init outputs when fragment shader for radv

LS pass output to TCS by reg is not enabled when LLVM.

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/amd/llvm/ac_nir_to_llvm.c | 31 ++++++++-----------------------
 src/amd/llvm/ac_nir_to_llvm.h |  4 ----
 2 files changed, 8 insertions(+), 27 deletions(-)

diff --git a/src/amd/llvm/ac_nir_to_llvm.c b/src/amd/llvm/ac_nir_to_llvm.c
index 30e5dc4c6aa2..48b6a36644b7 100644
--- a/src/amd/llvm/ac_nir_to_llvm.c
+++ b/src/amd/llvm/ac_nir_to_llvm.c
@@ -5026,30 +5026,12 @@ static bool visit_cf_list(struct ac_nir_context *ctx, struct exec_list *list)
    return true;
 }
 
-void ac_handle_shader_output_decl(struct ac_llvm_context *ctx, struct ac_shader_abi *abi,
-                                  struct nir_shader *nir, struct nir_variable *variable,
-                                  gl_shader_stage stage)
+static void ac_handle_shader_output_decl(struct ac_llvm_context *ctx, struct ac_shader_abi *abi,
+                                         struct nir_shader *nir, struct nir_variable *variable,
+                                         gl_shader_stage stage)
 {
    unsigned output_loc = variable->data.driver_location;
    unsigned attrib_count = glsl_count_attribute_slots(variable->type, false);
-
-   /* tess ctrl has it's own load/store paths for outputs */
-   if (stage == MESA_SHADER_TESS_CTRL)
-      return;
-
-   if (stage == MESA_SHADER_VERTEX || stage == MESA_SHADER_TESS_EVAL ||
-       stage == MESA_SHADER_GEOMETRY) {
-      int idx = variable->data.location + variable->data.index;
-      if (idx == VARYING_SLOT_CLIP_DIST0) {
-         int length = nir->info.clip_distance_array_size + nir->info.cull_distance_array_size;
-
-         if (length > 4)
-            attrib_count = 2;
-         else
-            attrib_count = 1;
-      }
-   }
-
    bool is_16bit = glsl_type_is_16bit(glsl_without_array(variable->type));
    LLVMTypeRef type = is_16bit ? ctx->f16 : ctx->f32;
    for (unsigned i = 0; i < attrib_count; ++i) {
@@ -5151,8 +5133,11 @@ bool ac_nir_translate(struct ac_llvm_context *ac, struct ac_shader_abi *abi,
 
    ctx.main_function = LLVMGetBasicBlockParent(LLVMGetInsertBlock(ctx.ac.builder));
 
-   /* TODO: remove this after RADV switches to lowered IO */
-   if (!nir->info.io_lowered) {
+   /* TODO: remove this after RADV switches to lowered IO.
+    *
+    * Only fragment shader still uses store output for RADV.
+    */
+   if (!nir->info.io_lowered && ctx.stage == MESA_SHADER_FRAGMENT) {
       nir_foreach_shader_out_variable(variable, nir)
       {
          ac_handle_shader_output_decl(&ctx.ac, ctx.abi, nir, variable, ctx.stage);
diff --git a/src/amd/llvm/ac_nir_to_llvm.h b/src/amd/llvm/ac_nir_to_llvm.h
index 7d00fc285be6..33888f1f0157 100644
--- a/src/amd/llvm/ac_nir_to_llvm.h
+++ b/src/amd/llvm/ac_nir_to_llvm.h
@@ -50,8 +50,4 @@ static inline unsigned ac_llvm_reg_index_soa(unsigned index, unsigned chan)
 bool ac_nir_translate(struct ac_llvm_context *ac, struct ac_shader_abi *abi,
                       const struct ac_shader_args *args, struct nir_shader *nir);
 
-void ac_handle_shader_output_decl(struct ac_llvm_context *ctx, struct ac_shader_abi *abi,
-                                  struct nir_shader *nir, struct nir_variable *variable,
-                                  gl_shader_stage stage);
-
 #endif /* AC_NIR_TO_LLVM_H */
-- 
GitLab


From 19c54539a84d1d3bddbf598e66bde050140df6ce Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Mon, 26 Dec 2022 13:01:03 +0800
Subject: [PATCH 3/3] aco: only ls and ps use store output now

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/amd/compiler/aco_instruction_selection.cpp | 11 +++++++----
 1 file changed, 7 insertions(+), 4 deletions(-)

diff --git a/src/amd/compiler/aco_instruction_selection.cpp b/src/amd/compiler/aco_instruction_selection.cpp
index 9ea40736d178..c36747154459 100644
--- a/src/amd/compiler/aco_instruction_selection.cpp
+++ b/src/amd/compiler/aco_instruction_selection.cpp
@@ -5276,10 +5276,13 @@ load_input_from_temps(isel_context* ctx, nir_intrinsic_instr* instr, Temp dst)
 void
 visit_store_output(isel_context* ctx, nir_intrinsic_instr* instr)
 {
-   if (ctx->stage == vertex_vs || ctx->stage == tess_eval_vs || ctx->stage == fragment_fs ||
-       ctx->stage == vertex_ngg || ctx->stage == tess_eval_ngg || ctx->stage == mesh_ngg ||
-       (ctx->stage == vertex_tess_control_hs && ctx->shader->info.stage == MESA_SHADER_VERTEX) ||
-       ctx->shader->info.stage == MESA_SHADER_GEOMETRY) {
+   /* LS pass output to TCS by temp if they have same in/out patch size. */
+   bool ls_need_output = ctx->stage == vertex_tess_control_hs &&
+      ctx->shader->info.stage == MESA_SHADER_VERTEX && ctx->tcs_in_out_eq;
+
+   bool ps_need_output = ctx->stage == fragment_fs;
+
+   if (ls_need_output || ps_need_output) {
       bool stored_to_temps = store_output_to_temps(ctx, instr);
       if (!stored_to_temps) {
          isel_err(instr->src[1].ssa->parent_instr, "Unimplemented output offset instruction");
-- 
GitLab

