From faa257a378fdc9fd8c4fc001a3d6b980b334c897 Mon Sep 17 00:00:00 2001
From: Adam Jackson <ajax@redhat.com>
Date: Wed, 20 Jul 2022 12:09:52 -0400
Subject: [PATCH 1/2] wsi/x11: Unswitchify Present completion event handling

This reads a bit more clearly, I think.
---
 src/vulkan/wsi/wsi_common_x11.c | 23 ++++++++---------------
 1 file changed, 8 insertions(+), 15 deletions(-)

diff --git a/src/vulkan/wsi/wsi_common_x11.c b/src/vulkan/wsi/wsi_common_x11.c
index 4554dac98080..e76ab7723386 100644
--- a/src/vulkan/wsi/wsi_common_x11.c
+++ b/src/vulkan/wsi/wsi_common_x11.c
@@ -1060,32 +1060,25 @@ x11_handle_dri3_present_event(struct x11_swapchain *chain,
          chain->last_present_msc = complete->msc;
       }
 
-      VkResult result = VK_SUCCESS;
-      switch (complete->mode) {
-      case XCB_PRESENT_COMPLETE_MODE_COPY:
-         if (chain->copy_is_suboptimal)
-            result = VK_SUBOPTIMAL_KHR;
-         break;
-      case XCB_PRESENT_COMPLETE_MODE_FLIP:
+      if (complete->mode == XCB_PRESENT_COMPLETE_MODE_COPY && chain->copy_is_suboptimal)
+         return VK_SUBOPTIMAL_KHR;
+
+      else if (complete->mode == XCB_PRESENT_COMPLETE_MODE_FLIP)
          /* If we ever go from flipping to copying, the odds are very likely
           * that we could reallocate in a more optimal way if we didn't have
           * to care about scanout, so we always do this.
           */
          chain->copy_is_suboptimal = true;
-         break;
+
 #ifdef HAVE_DRI3_MODIFIERS
-      case XCB_PRESENT_COMPLETE_MODE_SUBOPTIMAL_COPY:
+      else if (complete->mode == XCB_PRESENT_COMPLETE_MODE_SUBOPTIMAL_COPY)
          /* The winsys is now trying to flip directly and cannot due to our
           * configuration. Request the user reallocate.
           */
-         result = VK_SUBOPTIMAL_KHR;
-         break;
+         return VK_SUBOPTIMAL_KHR;
 #endif
-      default:
-         break;
-      }
 
-      return result;
+      return VK_SUCCESS;
    }
 
    default:
-- 
GitLab


From e4ac159c96d198a73eb15f21ed70fffe6acf2b52 Mon Sep 17 00:00:00 2001
From: Adam Jackson <ajax@redhat.com>
Date: Tue, 19 Jul 2022 14:56:55 -0400
Subject: [PATCH 2/2] wsi/x11: Uncork enqueueing multiple presents

The conditional being deleted here is "the image we just presented is
still not presented yet", we clear present_queued when we receive a
PresentCompleteNotify indicating that the server now thinks the pixmap
is presented (but maybe not idle). The spec, however, says:

    Queueing an image for presentation defines a set of queue
    operations, including waiting on the semaphores and submitting a
    presentation request to the presentation engine. However, the scope
    of this set of queue operations does not include the actual
    processing of the image by the presentation engine.

PresentCompleteNotify is precisely "the presentation engine thinks this
has been done" so we're blocking longer than we should. Remove that, and
move the msc tracking from event handling to present submit.
---
 src/vulkan/wsi/wsi_common_x11.c | 28 ++++------------------------
 1 file changed, 4 insertions(+), 24 deletions(-)

diff --git a/src/vulkan/wsi/wsi_common_x11.c b/src/vulkan/wsi/wsi_common_x11.c
index e76ab7723386..bb6676d798c4 100644
--- a/src/vulkan/wsi/wsi_common_x11.c
+++ b/src/vulkan/wsi/wsi_common_x11.c
@@ -914,7 +914,6 @@ struct x11_image {
    xcb_xfixes_region_t                       update_region; /* long lived XID */
    xcb_xfixes_region_t                       update_area;   /* the above or None */
    bool                                      busy;
-   bool                                      present_queued;
    struct xshmfence *                        shm_fence;
    uint32_t                                  sync_fence;
    uint32_t                                  serial;
@@ -938,7 +937,7 @@ struct x11_swapchain {
    xcb_present_event_t                          event_id;
    xcb_special_event_t *                        special_event;
    uint64_t                                     send_sbc;
-   uint64_t                                     last_present_msc;
+   uint64_t                                     send_msc;
    uint32_t                                     stamp;
    atomic_int                                   sent_image_count;
 
@@ -1050,15 +1049,6 @@ x11_handle_dri3_present_event(struct x11_swapchain *chain,
 
    case XCB_PRESENT_EVENT_COMPLETE_NOTIFY: {
       xcb_present_complete_notify_event_t *complete = (void *) event;
-      if (complete->kind == XCB_PRESENT_COMPLETE_KIND_PIXMAP) {
-         unsigned i;
-         for (i = 0; i < chain->base.image_count; i++) {
-            struct x11_image *image = &chain->images[i];
-            if (image->present_queued && image->serial == complete->serial)
-               image->present_queued = false;
-         }
-         chain->last_present_msc = complete->msc;
-      }
 
       if (complete->mode == XCB_PRESENT_COMPLETE_MODE_COPY && chain->copy_is_suboptimal)
          return VK_SUBOPTIMAL_KHR;
@@ -1250,7 +1240,6 @@ x11_present_to_x11_dri3(struct x11_swapchain *chain, uint32_t image_index,
    assert(chain->sent_image_count <= chain->base.image_count);
 
    ++chain->send_sbc;
-   image->present_queued = true;
    image->serial = (uint32_t) chain->send_sbc;
 
    xcb_void_cookie_t cookie =
@@ -1525,7 +1514,7 @@ x11_manage_fifo_queues(void *state)
 
       uint64_t target_msc = 0;
       if (chain->has_acquire_queue)
-         target_msc = chain->last_present_msc + 1;
+         target_msc = chain->send_msc++;
 
       result = x11_present_to_x11(chain, image_index, target_msc);
       if (result < 0)
@@ -1553,16 +1542,7 @@ x11_manage_fifo_queues(void *state)
          unsigned forward_progress_guaranteed_acquired_images =
             chain->base.image_count - min_image_count + 1;
 
-         /* Wait for our presentation to occur and ensure we have at least one
-          * image that can be acquired by the client afterwards. This ensures we
-          * can pull on the present-queue on the next loop.
-          */
-         while (chain->images[image_index].present_queued ||
-                /* If we have images in the present queue the outer loop won't block and a break
-                 * here would end up at this loop again, otherwise a break here satisfies
-                 * VUID-vkAcquireNextImageKHR-swapchain-01802 */
-                x11_driver_owned_images(chain) < forward_progress_guaranteed_acquired_images) {
-
+         while (x11_driver_owned_images(chain) < forward_progress_guaranteed_acquired_images) {
             xcb_generic_event_t *event =
                xcb_wait_for_special_event(chain->conn, chain->special_event);
             if (!event) {
@@ -2000,8 +1980,8 @@ x11_surface_create_swapchain(VkIcdSurfaceBase *icd_surface,
    chain->depth = bit_depth;
    chain->extent = pCreateInfo->imageExtent;
    chain->send_sbc = 0;
+   chain->send_msc = 0;
    chain->sent_image_count = 0;
-   chain->last_present_msc = 0;
    chain->has_acquire_queue = false;
    chain->has_present_queue = false;
    chain->status = VK_SUCCESS;
-- 
GitLab

