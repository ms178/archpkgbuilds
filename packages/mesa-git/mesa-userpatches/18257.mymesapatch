From 5ba9dc6396055a0afbe26fe5392f89de0bc57e6e Mon Sep 17 00:00:00 2001
From: Nanley Chery <nanley.g.chery@intel.com>
Date: Wed, 24 Aug 2022 11:30:14 -0700
Subject: [PATCH 1/6] mesa/st: Set PIPE_MAP_DISCARD_RANGE in
 fallback_copy_image

Enables some drivers to avoid reading from the destination when mapping it.
---
 src/mesa/state_tracker/st_cb_copyimage.c | 5 +++--
 1 file changed, 3 insertions(+), 2 deletions(-)

diff --git a/src/mesa/state_tracker/st_cb_copyimage.c b/src/mesa/state_tracker/st_cb_copyimage.c
index 1a1f3536ad47..15e98e619dbb 100644
--- a/src/mesa/state_tracker/st_cb_copyimage.c
+++ b/src/mesa/state_tracker/st_cb_copyimage.c
@@ -593,10 +593,11 @@ fallback_copy_image(struct st_context *st,
       st_MapTextureImage(
             st->ctx, dst_image, dst_z,
             dst_x, dst_y, dst_w, dst_h,
-            GL_MAP_WRITE_BIT, &dst, &dst_stride);
+            GL_MAP_WRITE_BIT | GL_MAP_INVALIDATE_RANGE_BIT,
+            &dst, &dst_stride);
    } else {
       dst = pipe_texture_map(st->pipe, dst_res, 0, dst_z,
-                              PIPE_MAP_WRITE,
+                              PIPE_MAP_WRITE | PIPE_MAP_DISCARD_RANGE,
                               dst_x, dst_y, dst_w, dst_h,
                               &dst_transfer);
       dst_stride = dst_transfer->stride;
-- 
GitLab


From bccee0a4738426f7a7f3e8f96b7ddc35df1dc05e Mon Sep 17 00:00:00 2001
From: Nanley Chery <nanley.g.chery@intel.com>
Date: Mon, 22 Aug 2022 09:08:13 -0700
Subject: [PATCH 2/6] mesa/st: Add and use st_texture_image_insert_transfer

Split out the transfer array reallocation and insertion functionality from
st_texture_image_map.
---
 src/mesa/state_tracker/st_texture.c | 38 +++++++++++++++++------------
 src/mesa/state_tracker/st_texture.h |  8 ++++++
 2 files changed, 31 insertions(+), 15 deletions(-)

diff --git a/src/mesa/state_tracker/st_texture.c b/src/mesa/state_tracker/st_texture.c
index dc96f6cc41f8..be45445d543e 100644
--- a/src/mesa/state_tracker/st_texture.c
+++ b/src/mesa/state_tracker/st_texture.c
@@ -238,6 +238,26 @@ st_texture_match_image(struct st_context *st,
    return GL_TRUE;
 }
 
+void
+st_texture_image_insert_transfer(struct gl_texture_image *stImage,
+                                 unsigned index,
+                                 struct pipe_transfer *transfer)
+{
+   /* Enlarge the transfer array if it's not large enough. */
+   if (index >= stImage->num_transfers) {
+      unsigned new_size = index + 1;
+
+      stImage->transfer = realloc(stImage->transfer,
+                  new_size * sizeof(struct st_texture_image_transfer));
+      memset(&stImage->transfer[stImage->num_transfers], 0,
+             (new_size - stImage->num_transfers) *
+             sizeof(struct st_texture_image_transfer));
+      stImage->num_transfers = new_size;
+   }
+
+   assert(!stImage->transfer[index].transfer);
+   stImage->transfer[index].transfer = transfer;
+}
 
 /**
  * Map a texture image and return the address for a particular 2D face/slice/
@@ -279,22 +299,10 @@ st_texture_image_map(struct st_context *st, struct gl_texture_image *stImage,
 
    map = pipe_texture_map_3d(st->pipe, stImage->pt, level, usage,
                               x, y, z, w, h, d, transfer);
-   if (map) {
-      /* Enlarge the transfer array if it's not large enough. */
-      if (z >= stImage->num_transfers) {
-         unsigned new_size = z + 1;
-
-         stImage->transfer = realloc(stImage->transfer,
-                     new_size * sizeof(struct st_texture_image_transfer));
-         memset(&stImage->transfer[stImage->num_transfers], 0,
-                (new_size - stImage->num_transfers) *
-                sizeof(struct st_texture_image_transfer));
-         stImage->num_transfers = new_size;
-      }
 
-      assert(!stImage->transfer[z].transfer);
-      stImage->transfer[z].transfer = *transfer;
-   }
+   if (map)
+      st_texture_image_insert_transfer(stImage, z, *transfer);
+
    return map;
 }
 
diff --git a/src/mesa/state_tracker/st_texture.h b/src/mesa/state_tracker/st_texture.h
index 10ac6fb892f4..757a288f5c2c 100644
--- a/src/mesa/state_tracker/st_texture.h
+++ b/src/mesa/state_tracker/st_texture.h
@@ -178,6 +178,14 @@ st_texture_match_image(struct st_context *st,
                        const struct pipe_resource *pt,
                        const struct gl_texture_image *image);
 
+/* Insert a transfer pointer into the image's transfer array at the specified
+ * index. The array is reallocated if necessary.
+ */
+void
+st_texture_image_insert_transfer(struct gl_texture_image *stImage,
+                                 unsigned index,
+                                 struct pipe_transfer *transfer);
+
 /* Return a pointer to an image within a texture.  Return image stride as
  * well.
  */
-- 
GitLab


From ec1ee7e3e4cd5ebf09a105762d6cf225686b1e1c Mon Sep 17 00:00:00 2001
From: Nanley Chery <nanley.g.chery@intel.com>
Date: Mon, 22 Aug 2022 11:56:43 -0700
Subject: [PATCH 3/6] mesa/st: Add and use st_texture_image_transfer::box

Use this field to determine which parts of the compressed texture fallback
resource needs updating. Drops a dependency on the
st_texture_image_transfer::transfer pointer.
---
 src/mesa/state_tracker/st_cb_texture.c | 10 +++++++++-
 src/mesa/state_tracker/st_texture.h    |  1 +
 2 files changed, 10 insertions(+), 1 deletion(-)

diff --git a/src/mesa/state_tracker/st_cb_texture.c b/src/mesa/state_tracker/st_cb_texture.c
index 2515c54bc3cc..5a4913736e3e 100644
--- a/src/mesa/state_tracker/st_cb_texture.c
+++ b/src/mesa/state_tracker/st_cb_texture.c
@@ -504,6 +504,10 @@ st_MapTextureImage(struct gl_context *ctx,
          unsigned z = transfer->box.z;
          struct st_texture_image_transfer *itransfer = &texImage->transfer[z];
 
+         assert(itransfer->box.depth == 0);
+         if (transfer_flags & PIPE_MAP_WRITE)
+            u_box_2d_zslice(x, y, z, w, h, &itransfer->box);
+
          unsigned blk_w, blk_h;
          _mesa_get_format_block_size(texImage->TexFormat, &blk_w, &blk_h);
 
@@ -548,7 +552,9 @@ st_UnmapTextureImage(struct gl_context *ctx,
 
       assert(z == transfer->box.z);
 
-      if (transfer->usage & PIPE_MAP_WRITE) {
+      if (itransfer->box.depth != 0) {
+         assert(itransfer->box.depth == 1);
+
          if (util_format_is_compressed(texImage->pt->format)) {
             /* Transcode into a different compressed format. */
             unsigned size =
@@ -622,6 +628,8 @@ st_UnmapTextureImage(struct gl_context *ctx,
                unreachable("unexpected format for a compressed format fallback");
             }
          }
+
+         memset(&itransfer->box, 0, sizeof(struct pipe_box));
       }
 
       itransfer->temp_data = NULL;
diff --git a/src/mesa/state_tracker/st_texture.h b/src/mesa/state_tracker/st_texture.h
index 757a288f5c2c..c6ef7694da42 100644
--- a/src/mesa/state_tracker/st_texture.h
+++ b/src/mesa/state_tracker/st_texture.h
@@ -47,6 +47,7 @@ struct st_texture_image_transfer
    GLubyte *temp_data; /**< Temporary compressed texture storage. */
    unsigned temp_stride; /**< Stride of the compressed texture storage. */
    GLubyte *map; /**< Saved map pointer of the uncompressed transfer. */
+   struct pipe_box box; /**< Region of the transfer's resource to write. */
 };
 
 
-- 
GitLab


From cb4462a31017865af5a3ce87967aabc2eaf47e65 Mon Sep 17 00:00:00 2001
From: Nanley Chery <nanley.g.chery@intel.com>
Date: Mon, 22 Aug 2022 11:56:43 -0700
Subject: [PATCH 4/6] mesa/st: Don't map compressed texture fallbacks for reads

We don't need to map the compressed texture's fallback resource for operations
which will only read from the texture (e.g., glGetCompressedTexImage2D and
glCopyImageSubData).

For compressed textures using a fallback, delay the map until
st_UnmapTextureImage and only do the map if it's being written to.

To help identify what's being changed, the expected indentation changes are
split out into the next patch.
---
 src/mesa/state_tracker/st_cb_texture.c | 52 ++++++++++++++++----------
 1 file changed, 32 insertions(+), 20 deletions(-)

diff --git a/src/mesa/state_tracker/st_cb_texture.c b/src/mesa/state_tracker/st_cb_texture.c
index 5a4913736e3e..2d32ebae84d5 100644
--- a/src/mesa/state_tracker/st_cb_texture.c
+++ b/src/mesa/state_tracker/st_cb_texture.c
@@ -479,8 +479,6 @@ st_MapTextureImage(struct gl_context *ctx,
                    GLubyte **mapOut, GLint *rowStrideOut)
 {
    struct st_context *st = st_context(ctx);
-   GLubyte *map;
-   struct pipe_transfer *transfer;
 
    /* Check for unexpected flags */
    assert((mode & ~(GL_MAP_READ_BIT |
@@ -490,9 +488,6 @@ st_MapTextureImage(struct gl_context *ctx,
    const enum pipe_map_flags transfer_flags =
       _mesa_access_flags_to_transfer_flags(mode, false);
 
-   map = st_texture_image_map(st, texImage, transfer_flags, x, y, slice, w, h, 1,
-                              &transfer);
-   if (map) {
       if (st_compressed_format_fallback(st, texImage->TexFormat)) {
          /* Some compressed formats don't have to be supported by drivers,
           * and st/mesa transparently handles decompression on upload (Unmap),
@@ -501,7 +496,12 @@ st_MapTextureImage(struct gl_context *ctx,
           * We store the compressed data (it's needed for glGetCompressedTex-
           * Image and image copies in OES_copy_image).
           */
-         unsigned z = transfer->box.z;
+         unsigned z = slice + texImage->Face +
+                      texImage->TexObject->Attrib.MinLayer;
+
+         /* Enlarge the transfer array if it's not large enough. */
+         st_texture_image_insert_transfer(texImage, z, NULL);
+
          struct st_texture_image_transfer *itransfer = &texImage->transfer[z];
 
          assert(itransfer->box.depth == 0);
@@ -521,18 +521,13 @@ st_MapTextureImage(struct gl_context *ctx,
             texImage->compressed_data->ptr +
             (z * y_blocks + (y / blk_h)) * stride +
             (x / blk_w) * block_size;
-         itransfer->map = map;
       }
       else {
-         /* supported mapping */
-         *mapOut = map;
-         *rowStrideOut = transfer->stride;
+         struct pipe_transfer *transfer;
+         *mapOut = st_texture_image_map(st, texImage, transfer_flags,
+                                        x, y, slice, w, h, 1, &transfer);
+         *rowStrideOut = *mapOut ? transfer->stride : 0;
       }
-   }
-   else {
-      *mapOut = NULL;
-      *rowStrideOut = 0;
-   }
 }
 
 
@@ -548,13 +543,29 @@ st_UnmapTextureImage(struct gl_context *ctx,
        * support the compressed format. */
       unsigned z = slice + texImage->Face;
       struct st_texture_image_transfer *itransfer = &texImage->transfer[z];
-      struct pipe_transfer *transfer = itransfer->transfer;
-
-      assert(z == transfer->box.z);
 
       if (itransfer->box.depth != 0) {
          assert(itransfer->box.depth == 1);
 
+         struct pipe_transfer *transfer;
+         GLubyte *map = st_texture_image_map(st, texImage,
+                                             PIPE_MAP_WRITE |
+                                             PIPE_MAP_DISCARD_RANGE,
+                                             itransfer->box.x,
+                                             itransfer->box.y, slice,
+                                             itransfer->box.width,
+                                             itransfer->box.height, 1,
+                                             &transfer);
+
+         if (!map) {
+            _mesa_error(ctx, GL_OUT_OF_MEMORY, "compressed fallback map");
+            return;
+         }
+
+         assert(z == transfer->box.z);
+
+         itransfer->map = map;
+
          if (util_format_is_compressed(texImage->pt->format)) {
             /* Transcode into a different compressed format. */
             unsigned size =
@@ -629,15 +640,16 @@ st_UnmapTextureImage(struct gl_context *ctx,
             }
          }
 
+         st_texture_image_unmap(st, texImage, slice);
          memset(&itransfer->box, 0, sizeof(struct pipe_box));
       }
 
       itransfer->temp_data = NULL;
       itransfer->temp_stride = 0;
       itransfer->map = NULL;
+   } else {
+      st_texture_image_unmap(st, texImage, slice);
    }
-
-   st_texture_image_unmap(st, texImage, slice);
 }
 
 
-- 
GitLab


From 12e48e385500403ddb6f49ae2668e14960c29174 Mon Sep 17 00:00:00 2001
From: Nanley Chery <nanley.g.chery@intel.com>
Date: Mon, 22 Aug 2022 14:36:38 -0700
Subject: [PATCH 5/6] mesa/st: Fix indentation in st_MapTextureImage

Dedent an if-else block and setup the else braces according to the coding
style.
---
 src/mesa/state_tracker/st_cb_texture.c | 67 +++++++++++++-------------
 1 file changed, 33 insertions(+), 34 deletions(-)

diff --git a/src/mesa/state_tracker/st_cb_texture.c b/src/mesa/state_tracker/st_cb_texture.c
index 2d32ebae84d5..4a77c373be67 100644
--- a/src/mesa/state_tracker/st_cb_texture.c
+++ b/src/mesa/state_tracker/st_cb_texture.c
@@ -488,46 +488,45 @@ st_MapTextureImage(struct gl_context *ctx,
    const enum pipe_map_flags transfer_flags =
       _mesa_access_flags_to_transfer_flags(mode, false);
 
-      if (st_compressed_format_fallback(st, texImage->TexFormat)) {
-         /* Some compressed formats don't have to be supported by drivers,
-          * and st/mesa transparently handles decompression on upload (Unmap),
-          * so that drivers don't see the compressed formats.
-          *
-          * We store the compressed data (it's needed for glGetCompressedTex-
-          * Image and image copies in OES_copy_image).
-          */
-         unsigned z = slice + texImage->Face +
-                      texImage->TexObject->Attrib.MinLayer;
+   if (st_compressed_format_fallback(st, texImage->TexFormat)) {
+      /* Some compressed formats don't have to be supported by drivers,
+       * and st/mesa transparently handles decompression on upload (Unmap),
+       * so that drivers don't see the compressed formats.
+       *
+       * We store the compressed data (it's needed for glGetCompressedTexImage
+       * and image copies in OES_copy_image).
+       */
+      unsigned z = slice + texImage->Face +
+                   texImage->TexObject->Attrib.MinLayer;
 
-         /* Enlarge the transfer array if it's not large enough. */
-         st_texture_image_insert_transfer(texImage, z, NULL);
+      /* Enlarge the transfer array if it's not large enough. */
+      st_texture_image_insert_transfer(texImage, z, NULL);
 
-         struct st_texture_image_transfer *itransfer = &texImage->transfer[z];
+      struct st_texture_image_transfer *itransfer = &texImage->transfer[z];
 
-         assert(itransfer->box.depth == 0);
-         if (transfer_flags & PIPE_MAP_WRITE)
-            u_box_2d_zslice(x, y, z, w, h, &itransfer->box);
+      assert(itransfer->box.depth == 0);
+      if (transfer_flags & PIPE_MAP_WRITE)
+         u_box_2d_zslice(x, y, z, w, h, &itransfer->box);
 
-         unsigned blk_w, blk_h;
-         _mesa_get_format_block_size(texImage->TexFormat, &blk_w, &blk_h);
+      unsigned blk_w, blk_h;
+      _mesa_get_format_block_size(texImage->TexFormat, &blk_w, &blk_h);
 
-         unsigned y_blocks = DIV_ROUND_UP(texImage->Height2, blk_h);
-         unsigned stride = *rowStrideOut = itransfer->temp_stride =
-            _mesa_format_row_stride(texImage->TexFormat, texImage->Width2);
-         unsigned block_size = _mesa_get_format_bytes(texImage->TexFormat);
+      unsigned y_blocks = DIV_ROUND_UP(texImage->Height2, blk_h);
+      unsigned stride = *rowStrideOut = itransfer->temp_stride =
+         _mesa_format_row_stride(texImage->TexFormat, texImage->Width2);
+      unsigned block_size = _mesa_get_format_bytes(texImage->TexFormat);
 
-         assert(texImage->compressed_data);
-         *mapOut = itransfer->temp_data =
-            texImage->compressed_data->ptr +
-            (z * y_blocks + (y / blk_h)) * stride +
-            (x / blk_w) * block_size;
-      }
-      else {
-         struct pipe_transfer *transfer;
-         *mapOut = st_texture_image_map(st, texImage, transfer_flags,
-                                        x, y, slice, w, h, 1, &transfer);
-         *rowStrideOut = *mapOut ? transfer->stride : 0;
-      }
+      assert(texImage->compressed_data);
+      *mapOut = itransfer->temp_data =
+         texImage->compressed_data->ptr +
+         (z * y_blocks + (y / blk_h)) * stride +
+         (x / blk_w) * block_size;
+   } else {
+      struct pipe_transfer *transfer;
+      *mapOut = st_texture_image_map(st, texImage, transfer_flags,
+                                     x, y, slice, w, h, 1, &transfer);
+      *rowStrideOut = *mapOut ? transfer->stride : 0;
+   }
 }
 
 
-- 
GitLab


From 27a757617771d7c0ff06ad668b58915ea0dcf4e4 Mon Sep 17 00:00:00 2001
From: Nanley Chery <nanley.g.chery@intel.com>
Date: Mon, 22 Aug 2022 15:28:54 -0700
Subject: [PATCH 6/6] mesa/st: Drop st_texture_image_transfer::map

It's only used in the scope of a single function, st_UnmapTextureImage. Use
a local variable instead.
---
 src/mesa/state_tracker/st_cb_texture.c | 11 ++++-------
 src/mesa/state_tracker/st_texture.h    |  1 -
 2 files changed, 4 insertions(+), 8 deletions(-)

diff --git a/src/mesa/state_tracker/st_cb_texture.c b/src/mesa/state_tracker/st_cb_texture.c
index 4a77c373be67..b46b0b00371f 100644
--- a/src/mesa/state_tracker/st_cb_texture.c
+++ b/src/mesa/state_tracker/st_cb_texture.c
@@ -563,8 +563,6 @@ st_UnmapTextureImage(struct gl_context *ctx,
 
          assert(z == transfer->box.z);
 
-         itransfer->map = map;
-
          if (util_format_is_compressed(texImage->pt->format)) {
             /* Transcode into a different compressed format. */
             unsigned size =
@@ -606,7 +604,7 @@ st_UnmapTextureImage(struct gl_context *ctx,
             pack.Alignment = 4;
 
             _mesa_texstore(ctx, 2, GL_RGBA, texImage->pt->format,
-                           transfer->stride, &itransfer->map,
+                           transfer->stride, &map,
                            transfer->box.width,
                            transfer->box.height, 1, GL_RGBA,
                            GL_UNSIGNED_BYTE, tmp, &pack);
@@ -614,7 +612,7 @@ st_UnmapTextureImage(struct gl_context *ctx,
          } else {
             /* Decompress into an uncompressed format. */
             if (texImage->TexFormat == MESA_FORMAT_ETC1_RGB8) {
-               _mesa_etc1_unpack_rgba8888(itransfer->map, transfer->stride,
+               _mesa_etc1_unpack_rgba8888(map, transfer->stride,
                                           itransfer->temp_data,
                                           itransfer->temp_stride,
                                           transfer->box.width,
@@ -622,14 +620,14 @@ st_UnmapTextureImage(struct gl_context *ctx,
             } else if (_mesa_is_format_etc2(texImage->TexFormat)) {
                bool bgra = texImage->pt->format == PIPE_FORMAT_B8G8R8A8_SRGB;
 
-               _mesa_unpack_etc2_format(itransfer->map, transfer->stride,
+               _mesa_unpack_etc2_format(map, transfer->stride,
                                         itransfer->temp_data,
                                         itransfer->temp_stride,
                                         transfer->box.width, transfer->box.height,
                                         texImage->TexFormat,
                                         bgra);
             } else if (_mesa_is_format_astc_2d(texImage->TexFormat)) {
-               _mesa_unpack_astc_2d_ldr(itransfer->map, transfer->stride,
+               _mesa_unpack_astc_2d_ldr(map, transfer->stride,
                                         itransfer->temp_data,
                                         itransfer->temp_stride,
                                         transfer->box.width, transfer->box.height,
@@ -645,7 +643,6 @@ st_UnmapTextureImage(struct gl_context *ctx,
 
       itransfer->temp_data = NULL;
       itransfer->temp_stride = 0;
-      itransfer->map = NULL;
    } else {
       st_texture_image_unmap(st, texImage, slice);
    }
diff --git a/src/mesa/state_tracker/st_texture.h b/src/mesa/state_tracker/st_texture.h
index c6ef7694da42..064200d07da4 100644
--- a/src/mesa/state_tracker/st_texture.h
+++ b/src/mesa/state_tracker/st_texture.h
@@ -46,7 +46,6 @@ struct st_texture_image_transfer
    /* For compressed texture fallback. */
    GLubyte *temp_data; /**< Temporary compressed texture storage. */
    unsigned temp_stride; /**< Stride of the compressed texture storage. */
-   GLubyte *map; /**< Saved map pointer of the uncompressed transfer. */
    struct pipe_box box; /**< Region of the transfer's resource to write. */
 };
 
-- 
GitLab

