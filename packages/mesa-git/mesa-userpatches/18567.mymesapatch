From ef109149e22b35b83ebc3f7ed598e79a2e62d2be Mon Sep 17 00:00:00 2001
From: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date: Mon, 12 Sep 2022 18:37:04 +0200
Subject: [PATCH 1/5] radv: stop setting redundant viewport/scissor for
 internal operations

Only emit them when it's needed.

Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Reviewed-By: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
---
 src/amd/vulkan/radv_meta_blit.c       | 56 +++++++++++++--------------
 src/amd/vulkan/radv_meta_blit2d.c     | 28 +++++++-------
 src/amd/vulkan/radv_meta_resolve.c    | 49 ++++++++++++++---------
 src/amd/vulkan/radv_meta_resolve_fs.c | 53 ++++++++++++++-----------
 4 files changed, 103 insertions(+), 83 deletions(-)

diff --git a/src/amd/vulkan/radv_meta_blit.c b/src/amd/vulkan/radv_meta_blit.c
index 53151351f308..3076f9263e0e 100644
--- a/src/amd/vulkan/radv_meta_blit.c
+++ b/src/amd/vulkan/radv_meta_blit.c
@@ -241,8 +241,7 @@ meta_emit_blit(struct radv_cmd_buffer *cmd_buffer, struct radv_image *src_image,
                struct radv_image_view *src_iview, VkImageLayout src_image_layout,
                float src_offset_0[3], float src_offset_1[3], struct radv_image *dest_image,
                struct radv_image_view *dest_iview, VkImageLayout dest_image_layout,
-               VkOffset2D dest_offset_0, VkOffset2D dest_offset_1, VkRect2D dest_box,
-               VkSampler sampler)
+               VkRect2D dest_box, VkSampler sampler)
 {
    struct radv_device *device = cmd_buffer->device;
    uint32_t src_width = radv_minify(src_iview->image->info.width, src_iview->vk.base_mip_level);
@@ -357,22 +356,6 @@ meta_emit_blit(struct radv_cmd_buffer *cmd_buffer, struct radv_image *src_image,
                                    },
                                 }}});
 
-   radv_CmdSetViewport(radv_cmd_buffer_to_handle(cmd_buffer), 0, 1,
-                       &(VkViewport){.x = dest_offset_0.x,
-                                     .y = dest_offset_0.y,
-                                     .width = dest_offset_1.x - dest_offset_0.x,
-                                     .height = dest_offset_1.y - dest_offset_0.y,
-                                     .minDepth = 0.0f,
-                                     .maxDepth = 1.0f});
-
-   radv_CmdSetScissor(radv_cmd_buffer_to_handle(cmd_buffer), 0, 1,
-                      &(VkRect2D){
-                         .offset = (VkOffset2D){MIN2(dest_offset_0.x, dest_offset_1.x),
-                                                MIN2(dest_offset_0.y, dest_offset_1.y)},
-                         .extent = (VkExtent2D){abs(dest_offset_1.x - dest_offset_0.x),
-                                                abs(dest_offset_1.y - dest_offset_0.y)},
-                      });
-
    VkRenderingInfo rendering_info = {
       .sType = VK_STRUCTURE_TYPE_RENDERING_INFO,
       .renderArea = {
@@ -543,19 +526,35 @@ blit_image(struct radv_cmd_buffer *cmd_buffer, struct radv_image *src_image,
    dst_box.extent.width = dst_x1 - dst_x0;
    dst_box.extent.height = dst_y1 - dst_y0;
 
+   const VkOffset2D dst_offset_0 = {
+      .x = dst_x0,
+      .y = dst_y0,
+   };
+   const VkOffset2D dst_offset_1 = {
+      .x = dst_x1,
+      .y = dst_y1,
+   };
+
+   radv_CmdSetViewport(radv_cmd_buffer_to_handle(cmd_buffer), 0, 1,
+                       &(VkViewport){.x = dst_offset_0.x,
+                                     .y = dst_offset_0.y,
+                                     .width = dst_offset_1.x - dst_offset_0.x,
+                                     .height = dst_offset_1.y - dst_offset_0.y,
+                                     .minDepth = 0.0f,
+                                     .maxDepth = 1.0f});
+
+   radv_CmdSetScissor(radv_cmd_buffer_to_handle(cmd_buffer), 0, 1,
+                      &(VkRect2D){
+                         .offset = (VkOffset2D){MIN2(dst_offset_0.x, dst_offset_1.x),
+                                                MIN2(dst_offset_0.y, dst_offset_1.y)},
+                         .extent = (VkExtent2D){abs(dst_offset_1.x - dst_offset_0.x),
+                                                abs(dst_offset_1.y - dst_offset_0.y)},
+                      });
+
    const unsigned num_layers = dst_end - dst_start;
    for (unsigned i = 0; i < num_layers; i++) {
       struct radv_image_view dst_iview, src_iview;
 
-      const VkOffset2D dst_offset_0 = {
-         .x = dst_x0,
-         .y = dst_y0,
-      };
-      const VkOffset2D dst_offset_1 = {
-         .x = dst_x1,
-         .y = dst_y1,
-      };
-
       float src_offset_0[3] = {
          src_x0,
          src_y0,
@@ -598,8 +597,7 @@ blit_image(struct radv_cmd_buffer *cmd_buffer, struct radv_image *src_image,
                            },
                            0, NULL);
       meta_emit_blit(cmd_buffer, src_image, &src_iview, src_image_layout, src_offset_0,
-                     src_offset_1, dst_image, &dst_iview, dst_image_layout, dst_offset_0,
-                     dst_offset_1, dst_box, sampler);
+                     src_offset_1, dst_image, &dst_iview, dst_image_layout, dst_box, sampler);
 
       radv_image_view_finish(&dst_iview);
       radv_image_view_finish(&src_iview);
diff --git a/src/amd/vulkan/radv_meta_blit2d.c b/src/amd/vulkan/radv_meta_blit2d.c
index 2690b4a685e9..7b69c7b3f602 100644
--- a/src/amd/vulkan/radv_meta_blit2d.c
+++ b/src/amd/vulkan/radv_meta_blit2d.c
@@ -204,6 +204,20 @@ radv_meta_blit2d_normal_dst(struct radv_cmd_buffer *cmd_buffer,
    struct radv_device *device = cmd_buffer->device;
 
    for (unsigned r = 0; r < num_rects; ++r) {
+      radv_CmdSetViewport(radv_cmd_buffer_to_handle(cmd_buffer), 0, 1,
+                          &(VkViewport){.x = rects[r].dst_x,
+                                        .y = rects[r].dst_y,
+                                        .width = rects[r].width,
+                                        .height = rects[r].height,
+                                        .minDepth = 0.0f,
+                                        .maxDepth = 1.0f});
+
+      radv_CmdSetScissor(radv_cmd_buffer_to_handle(cmd_buffer), 0, 1,
+                         &(VkRect2D){
+                            .offset = (VkOffset2D){rects[r].dst_x, rects[r].dst_y},
+                            .extent = (VkExtent2D){rects[r].width, rects[r].height},
+                         });
+
       u_foreach_bit(i, dst->aspect_mask)
       {
          unsigned aspect_mask = 1u << i;
@@ -342,20 +356,6 @@ radv_meta_blit2d_normal_dst(struct radv_cmd_buffer *cmd_buffer,
          } else
             unreachable("Processing blit2d with multiple aspects.");
 
-         radv_CmdSetViewport(radv_cmd_buffer_to_handle(cmd_buffer), 0, 1,
-                             &(VkViewport){.x = rects[r].dst_x,
-                                           .y = rects[r].dst_y,
-                                           .width = rects[r].width,
-                                           .height = rects[r].height,
-                                           .minDepth = 0.0f,
-                                           .maxDepth = 1.0f});
-
-         radv_CmdSetScissor(radv_cmd_buffer_to_handle(cmd_buffer), 0, 1,
-                            &(VkRect2D){
-                               .offset = (VkOffset2D){rects[r].dst_x, rects[r].dst_y},
-                               .extent = (VkExtent2D){rects[r].width, rects[r].height},
-                            });
-
          radv_CmdDraw(radv_cmd_buffer_to_handle(cmd_buffer), 3, 1, 0, 0);
 
          radv_CmdEndRendering(radv_cmd_buffer_to_handle(cmd_buffer));
diff --git a/src/amd/vulkan/radv_meta_resolve.c b/src/amd/vulkan/radv_meta_resolve.c
index 351c82316db0..c5b04d609d78 100644
--- a/src/amd/vulkan/radv_meta_resolve.c
+++ b/src/amd/vulkan/radv_meta_resolve.c
@@ -231,7 +231,7 @@ cleanup:
 
 static void
 emit_resolve(struct radv_cmd_buffer *cmd_buffer, const struct radv_image *src_image,
-             const struct radv_image *dst_image, VkFormat vk_format, const VkRect2D *resolve_area)
+             const struct radv_image *dst_image, VkFormat vk_format)
 {
    struct radv_device *device = cmd_buffer->device;
    VkCommandBuffer cmd_buffer_h = radv_cmd_buffer_to_handle(cmd_buffer);
@@ -245,16 +245,6 @@ emit_resolve(struct radv_cmd_buffer *cmd_buffer, const struct radv_image *src_im
    radv_CmdBindPipeline(cmd_buffer_h, VK_PIPELINE_BIND_POINT_GRAPHICS,
                         device->meta_state.resolve.pipeline[fs_key]);
 
-   radv_CmdSetViewport(radv_cmd_buffer_to_handle(cmd_buffer), 0, 1,
-                       &(VkViewport){.x = resolve_area->offset.x,
-                                     .y = resolve_area->offset.y,
-                                     .width = resolve_area->extent.width,
-                                     .height = resolve_area->extent.height,
-                                     .minDepth = 0.0f,
-                                     .maxDepth = 1.0f});
-
-   radv_CmdSetScissor(radv_cmd_buffer_to_handle(cmd_buffer), 0, 1, resolve_area);
-
    radv_CmdDraw(cmd_buffer_h, 3, 1, 0, 0);
    cmd_buffer->state.flush_bits |=
       radv_src_access_flush(cmd_buffer, VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT, dst_image);
@@ -411,6 +401,21 @@ radv_meta_resolve_hardware_image(struct radv_cmd_buffer *cmd_buffer, struct radv
       cmd_buffer->state.flush_bits |= radv_init_dcc(cmd_buffer, dst_image, &range, 0xffffffff);
    }
 
+   VkRect2D resolve_area = {
+      .offset = { dstOffset.x, dstOffset.y },
+      .extent = { extent.width, extent.height },
+   };
+
+   radv_CmdSetViewport(radv_cmd_buffer_to_handle(cmd_buffer), 0, 1,
+                       &(VkViewport){.x = resolve_area.offset.x,
+                                     .y = resolve_area.offset.y,
+                                     .width = resolve_area.extent.width,
+                                     .height = resolve_area.extent.height,
+                                     .minDepth = 0.0f,
+                                     .maxDepth = 1.0f});
+
+   radv_CmdSetScissor(radv_cmd_buffer_to_handle(cmd_buffer), 0, 1, &resolve_area);
+
    for (uint32_t layer = 0; layer < region->srcSubresource.layerCount; ++layer) {
 
       VkResult ret = build_resolve_pipeline(device, fs_key);
@@ -474,10 +479,7 @@ radv_meta_resolve_hardware_image(struct radv_cmd_buffer *cmd_buffer, struct radv
 
       const VkRenderingInfo rendering_info = {
          .sType = VK_STRUCTURE_TYPE_RENDERING_INFO,
-         .renderArea = {
-            .offset = { dstOffset.x, dstOffset.y },
-            .extent = { extent.width, extent.height },
-         },
+         .renderArea = resolve_area,
          .layerCount = 1,
          .colorAttachmentCount = 2,
          .pColorAttachments = color_atts,
@@ -485,8 +487,7 @@ radv_meta_resolve_hardware_image(struct radv_cmd_buffer *cmd_buffer, struct radv
 
       radv_CmdBeginRendering(radv_cmd_buffer_to_handle(cmd_buffer), &rendering_info);
 
-      emit_resolve(cmd_buffer, src_image, dst_image, dst_iview.vk.format,
-                   &rendering_info.renderArea);
+      emit_resolve(cmd_buffer, src_image, dst_image, dst_iview.vk.format);
 
       radv_CmdEndRendering(radv_cmd_buffer_to_handle(cmd_buffer));
 
@@ -570,6 +571,18 @@ radv_cmd_buffer_resolve_rendering_hw(struct radv_cmd_buffer *cmd_buffer)
    radv_meta_save(&saved_state, cmd_buffer,
                   RADV_META_SAVE_GRAPHICS_PIPELINE | RADV_META_SAVE_RENDER);
 
+   VkRect2D *resolve_area = &saved_state.render.area;
+
+   radv_CmdSetViewport(radv_cmd_buffer_to_handle(cmd_buffer), 0, 1,
+                       &(VkViewport){.x = resolve_area->offset.x,
+                                     .y = resolve_area->offset.y,
+                                     .width = resolve_area->extent.width,
+                                     .height = resolve_area->extent.height,
+                                     .minDepth = 0.0f,
+                                     .maxDepth = 1.0f});
+
+   radv_CmdSetScissor(radv_cmd_buffer_to_handle(cmd_buffer), 0, 1, resolve_area);
+
    for (uint32_t i = 0; i < saved_state.render.color_att_count; ++i) {
       if (saved_state.render.color_att[i].resolve_iview == NULL)
          continue;
@@ -633,7 +646,7 @@ radv_cmd_buffer_resolve_rendering_hw(struct radv_cmd_buffer *cmd_buffer)
          continue;
       }
 
-      emit_resolve(cmd_buffer, src_img, dst_img, dst_iview->vk.format, &saved_state.render.area);
+      emit_resolve(cmd_buffer, src_img, dst_img, dst_iview->vk.format);
 
       radv_CmdEndRendering(radv_cmd_buffer_to_handle(cmd_buffer));
    }
diff --git a/src/amd/vulkan/radv_meta_resolve_fs.c b/src/amd/vulkan/radv_meta_resolve_fs.c
index 733f05383183..971a82f230be 100644
--- a/src/amd/vulkan/radv_meta_resolve_fs.c
+++ b/src/amd/vulkan/radv_meta_resolve_fs.c
@@ -636,7 +636,7 @@ radv_get_resolve_pipeline(struct radv_cmd_buffer *cmd_buffer, struct radv_image_
 static void
 emit_resolve(struct radv_cmd_buffer *cmd_buffer, struct radv_image_view *src_iview,
              struct radv_image_view *dest_iview, const VkOffset2D *src_offset,
-             const VkOffset2D *dest_offset, const VkExtent2D *resolve_extent)
+             const VkOffset2D *dest_offset)
 {
    struct radv_device *device = cmd_buffer->device;
    VkCommandBuffer cmd_buffer_h = radv_cmd_buffer_to_handle(cmd_buffer);
@@ -678,20 +678,6 @@ emit_resolve(struct radv_cmd_buffer *cmd_buffer, struct radv_image_view *src_ivi
 
    radv_CmdBindPipeline(cmd_buffer_h, VK_PIPELINE_BIND_POINT_GRAPHICS, *pipeline);
 
-   radv_CmdSetViewport(radv_cmd_buffer_to_handle(cmd_buffer), 0, 1,
-                       &(VkViewport){.x = dest_offset->x,
-                                     .y = dest_offset->y,
-                                     .width = resolve_extent->width,
-                                     .height = resolve_extent->height,
-                                     .minDepth = 0.0f,
-                                     .maxDepth = 1.0f});
-
-   radv_CmdSetScissor(radv_cmd_buffer_to_handle(cmd_buffer), 0, 1,
-                      &(VkRect2D){
-                         .offset = *dest_offset,
-                         .extent = *resolve_extent,
-                      });
-
    radv_CmdDraw(cmd_buffer_h, 3, 1, 0, 0);
    cmd_buffer->state.flush_bits |=
       radv_src_access_flush(cmd_buffer, VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT, dest_iview->image);
@@ -815,6 +801,21 @@ radv_meta_resolve_fragment_image(struct radv_cmd_buffer *cmd_buffer, struct radv
    const struct VkOffset3D srcOffset = vk_image_sanitize_offset(&src_image->vk, region->srcOffset);
    const struct VkOffset3D dstOffset = vk_image_sanitize_offset(&dest_image->vk, region->dstOffset);
 
+   VkRect2D resolve_area = {
+      .offset = { dstOffset.x, dstOffset.y },
+      .extent = { extent.width, extent.height },
+   };
+
+   radv_CmdSetViewport(radv_cmd_buffer_to_handle(cmd_buffer), 0, 1,
+                       &(VkViewport){.x = resolve_area.offset.x,
+                                     .y = resolve_area.offset.y,
+                                     .width = resolve_area.extent.width,
+                                     .height = resolve_area.extent.height,
+                                     .minDepth = 0.0f,
+                                     .maxDepth = 1.0f});
+
+   radv_CmdSetScissor(radv_cmd_buffer_to_handle(cmd_buffer), 0, 1, &resolve_area);
+
    for (uint32_t layer = 0; layer < region->srcSubresource.layerCount; ++layer) {
 
       struct radv_image_view src_iview;
@@ -863,10 +864,7 @@ radv_meta_resolve_fragment_image(struct radv_cmd_buffer *cmd_buffer, struct radv
 
       const VkRenderingInfo rendering_info = {
          .sType = VK_STRUCTURE_TYPE_RENDERING_INFO,
-         .renderArea = {
-            .offset = { dstOffset.x, dstOffset.y },
-            .extent = { extent.width, extent.height }
-         },
+         .renderArea = resolve_area,
          .layerCount = 1,
          .colorAttachmentCount = 1,
          .pColorAttachments = &color_att,
@@ -875,8 +873,7 @@ radv_meta_resolve_fragment_image(struct radv_cmd_buffer *cmd_buffer, struct radv
       radv_CmdBeginRendering(radv_cmd_buffer_to_handle(cmd_buffer), &rendering_info);
 
       emit_resolve(cmd_buffer, &src_iview, &dest_iview, &(VkOffset2D){srcOffset.x, srcOffset.y},
-                   &(VkOffset2D){dstOffset.x, dstOffset.y},
-                   &(VkExtent2D){extent.width, extent.height});
+                   &(VkOffset2D){dstOffset.x, dstOffset.y});
 
       radv_CmdEndRendering(radv_cmd_buffer_to_handle(cmd_buffer));
 
@@ -909,6 +906,18 @@ radv_cmd_buffer_resolve_rendering_fs(struct radv_cmd_buffer *cmd_buffer)
       RADV_META_SAVE_GRAPHICS_PIPELINE | RADV_META_SAVE_CONSTANTS | RADV_META_SAVE_DESCRIPTORS |
       RADV_META_SAVE_RENDER);
 
+   VkRect2D *resolve_area = &saved_state.render.area;
+
+   radv_CmdSetViewport(radv_cmd_buffer_to_handle(cmd_buffer), 0, 1,
+                       &(VkViewport){.x = resolve_area->offset.x,
+                                     .y = resolve_area->offset.y,
+                                     .width = resolve_area->extent.width,
+                                     .height = resolve_area->extent.height,
+                                     .minDepth = 0.0f,
+                                     .maxDepth = 1.0f});
+
+   radv_CmdSetScissor(radv_cmd_buffer_to_handle(cmd_buffer), 0, 1, resolve_area);
+
    for (uint32_t i = 0; i < saved_state.render.color_att_count; ++i) {
       if (saved_state.render.color_att[i].resolve_iview == NULL)
          continue;
@@ -936,7 +945,7 @@ radv_cmd_buffer_resolve_rendering_fs(struct radv_cmd_buffer *cmd_buffer)
       radv_CmdBeginRendering(radv_cmd_buffer_to_handle(cmd_buffer), &rendering_info);
 
       emit_resolve(cmd_buffer, src_iview, dst_iview, &saved_state.render.area.offset,
-                   &saved_state.render.area.offset, &saved_state.render.area.extent);
+                   &saved_state.render.area.offset);
 
       radv_CmdEndRendering(radv_cmd_buffer_to_handle(cmd_buffer));
    }
-- 
GitLab


From 8d4b407575c2194da7dde6330b50bbf98564bdd5 Mon Sep 17 00:00:00 2001
From: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date: Tue, 13 Sep 2022 09:21:17 +0200
Subject: [PATCH 2/5] radv: do not bind NULL graphics pipeline when restoring
 the meta state

It's invalid to bind NULL pipelines, but make sure to reset it to
its previous NULL state.

Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Reviewed-By: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
---
 src/amd/vulkan/radv_meta.c | 8 ++++++--
 1 file changed, 6 insertions(+), 2 deletions(-)

diff --git a/src/amd/vulkan/radv_meta.c b/src/amd/vulkan/radv_meta.c
index 13dbeaabdb06..6e57022cbb5e 100644
--- a/src/amd/vulkan/radv_meta.c
+++ b/src/amd/vulkan/radv_meta.c
@@ -145,8 +145,12 @@ radv_meta_restore(const struct radv_meta_saved_state *state, struct radv_cmd_buf
                                        : VK_PIPELINE_BIND_POINT_COMPUTE;
 
    if (state->flags & RADV_META_SAVE_GRAPHICS_PIPELINE) {
-      radv_CmdBindPipeline(radv_cmd_buffer_to_handle(cmd_buffer), VK_PIPELINE_BIND_POINT_GRAPHICS,
-                           radv_pipeline_to_handle(&state->old_graphics_pipeline->base));
+      if (state->old_graphics_pipeline) {
+         radv_CmdBindPipeline(radv_cmd_buffer_to_handle(cmd_buffer), VK_PIPELINE_BIND_POINT_GRAPHICS,
+                              radv_pipeline_to_handle(&state->old_graphics_pipeline->base));
+      } else {
+         cmd_buffer->state.graphics_pipeline = NULL;
+      }
 
       cmd_buffer->state.dirty |= RADV_CMD_DIRTY_PIPELINE;
 
-- 
GitLab


From aa46dff4c0f358f5ad5339e35b351e1e102bbd2c Mon Sep 17 00:00:00 2001
From: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date: Tue, 13 Sep 2022 09:21:48 +0200
Subject: [PATCH 3/5] radv: reset the compute pipeline when the saved one was
 NULL

Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Reviewed-By: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
---
 src/amd/vulkan/radv_meta.c | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/src/amd/vulkan/radv_meta.c b/src/amd/vulkan/radv_meta.c
index 6e57022cbb5e..2ed1b4b044fe 100644
--- a/src/amd/vulkan/radv_meta.c
+++ b/src/amd/vulkan/radv_meta.c
@@ -163,6 +163,8 @@ radv_meta_restore(const struct radv_meta_saved_state *state, struct radv_cmd_buf
       if (state->old_compute_pipeline) {
          radv_CmdBindPipeline(radv_cmd_buffer_to_handle(cmd_buffer), VK_PIPELINE_BIND_POINT_COMPUTE,
                               radv_pipeline_to_handle(&state->old_compute_pipeline->base));
+      } else {
+         cmd_buffer->state.compute_pipeline = NULL;
       }
    }
 
-- 
GitLab


From 353eac6706a8961a8943700522520f5c5c854fd8 Mon Sep 17 00:00:00 2001
From: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date: Tue, 13 Sep 2022 09:23:08 +0200
Subject: [PATCH 4/5] radv: stop dirtying the graphics pipeline when restoring
 it

radv_CmdBindPipeline() does it already.

Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Reviewed-By: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
---
 src/amd/vulkan/radv_meta.c | 2 --
 1 file changed, 2 deletions(-)

diff --git a/src/amd/vulkan/radv_meta.c b/src/amd/vulkan/radv_meta.c
index 2ed1b4b044fe..2ea349ddacdb 100644
--- a/src/amd/vulkan/radv_meta.c
+++ b/src/amd/vulkan/radv_meta.c
@@ -152,8 +152,6 @@ radv_meta_restore(const struct radv_meta_saved_state *state, struct radv_cmd_buf
          cmd_buffer->state.graphics_pipeline = NULL;
       }
 
-      cmd_buffer->state.dirty |= RADV_CMD_DIRTY_PIPELINE;
-
       /* Restore all dynamic states. */
       cmd_buffer->state.dynamic = state->dynamic;
       cmd_buffer->state.dirty |= RADV_DYNAMIC_ALL;
-- 
GitLab


From 07e97c74b47ce489d655a729275dae0f42cefb7e Mon Sep 17 00:00:00 2001
From: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date: Tue, 13 Sep 2022 09:24:52 +0200
Subject: [PATCH 5/5] radv: stop checking for NULL pipelines in
 radv_CmdBindPipeline()

This should never happen now.

Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Reviewed-By: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
---
 src/amd/vulkan/radv_cmd_buffer.c | 2 --
 1 file changed, 2 deletions(-)

diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index d03265a9783b..4abcbb8daf6b 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -5127,8 +5127,6 @@ radv_CmdBindPipeline(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipeline
          cmd_buffer->state.graphics_pipeline->vtx_emit_num != graphics_pipeline->vtx_emit_num ||
          cmd_buffer->state.graphics_pipeline->vtx_base_sgpr != graphics_pipeline->vtx_base_sgpr;
       cmd_buffer->state.graphics_pipeline = graphics_pipeline;
-      if (!pipeline)
-         break;
 
       bool mesh_shading = radv_pipeline_has_stage(graphics_pipeline, MESA_SHADER_MESH);
       if (mesh_shading != cmd_buffer->state.mesh_shading) {
-- 
GitLab

