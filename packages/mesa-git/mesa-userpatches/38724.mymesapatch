From 7e655b30513417fee794442ab52ae5044f5835d9 Mon Sep 17 00:00:00 2001
From: Georg Lehmann <dadschoorse@gmail.com>
Date: Wed, 19 Mar 2025 14:19:50 +0100
Subject: [PATCH 1/2] aco/optimizer: fix uses in to_uniform_bool_instr

---
 src/amd/compiler/aco_optimizer.cpp | 5 ++++-
 1 file changed, 4 insertions(+), 1 deletion(-)

diff --git a/src/amd/compiler/aco_optimizer.cpp b/src/amd/compiler/aco_optimizer.cpp
index a48988c00293e..a96f7ffedc54c 100644
--- a/src/amd/compiler/aco_optimizer.cpp
+++ b/src/amd/compiler/aco_optimizer.cpp
@@ -4485,6 +4485,7 @@ to_uniform_bool_instr(opt_ctx& ctx, aco_ptr<Instruction>& instr)
          continue;
 
       ctx.uses[op.tempId()]--;
+      bool increase_uses = ctx.uses[op.tempId()];
 
       if (ctx.info[op.tempId()].is_uniform_bool()) {
          /* Just use the uniform boolean temp. */
@@ -4500,11 +4501,13 @@ to_uniform_bool_instr(opt_ctx& ctx, aco_ptr<Instruction>& instr)
          assert(pred_instr->definitions[1].isFixed() &&
                 pred_instr->definitions[1].physReg() == scc);
          op.setTemp(pred_instr->definitions[1].getTemp());
+         increase_uses = true;
       } else {
          UNREACHABLE("Invalid operand on uniform bitwise instruction.");
       }
 
-      ctx.uses[op.tempId()]++;
+      if (increase_uses)
+         ctx.uses[op.tempId()]++;
    }
 
    instr->definitions[0].setTemp(Temp(instr->definitions[0].tempId(), s1));
-- 
GitLab


From 77946f8ddf49ded9827f679ac3ea8cfc641e4b46 Mon Sep 17 00:00:00 2001
From: Georg Lehmann <dadschoorse@gmail.com>
Date: Fri, 9 Aug 2024 16:32:01 +0200
Subject: [PATCH 2/2] aco/optimizer: validate uses

---
 src/amd/compiler/aco_dead_code_analysis.cpp |  2 ++
 src/amd/compiler/aco_optimizer.cpp          | 36 ++++++++++++++-------
 2 files changed, 27 insertions(+), 11 deletions(-)

diff --git a/src/amd/compiler/aco_dead_code_analysis.cpp b/src/amd/compiler/aco_dead_code_analysis.cpp
index 2fdddace4fadb..6a620efcaf585 100644
--- a/src/amd/compiler/aco_dead_code_analysis.cpp
+++ b/src/amd/compiler/aco_dead_code_analysis.cpp
@@ -37,6 +37,8 @@ process_block(std::vector<uint16_t>& uses, Block& block)
 {
    for (auto it = block.instructions.rbegin(); it != block.instructions.rend(); it++) {
       aco_ptr<Instruction>& instr = *it;
+      if (!instr.get())
+         continue;
       if ((block.kind & block_kind_loop_header) && is_phi(instr))
          break;
 
diff --git a/src/amd/compiler/aco_optimizer.cpp b/src/amd/compiler/aco_optimizer.cpp
index a96f7ffedc54c..f801bce50c96f 100644
--- a/src/amd/compiler/aco_optimizer.cpp
+++ b/src/amd/compiler/aco_optimizer.cpp
@@ -5147,7 +5147,7 @@ apply_literals(opt_ctx& ctx, aco_ptr<Instruction>& instr)
 }
 
 void
-validate_opt_ctx(opt_ctx& ctx)
+validate_opt_ctx(opt_ctx& ctx, bool incorrect_uses_lits)
 {
    if (!(debug_flags & DEBUG_VALIDATE_OPT))
       return;
@@ -5166,7 +5166,8 @@ validate_opt_ctx(opt_ctx& ctx)
          FILE* const memf = u_memstream_get(&mem);
 
          fprintf(memf, "Optimizer: %s: ", msg);
-         aco_print_instr(program->gfx_level, instr, memf);
+         if (instr)
+            aco_print_instr(program->gfx_level, instr, memf);
          u_memstream_close(&mem);
 
          aco_err(program, "%s", out);
@@ -5186,9 +5187,24 @@ validate_opt_ctx(opt_ctx& ctx)
          }
       }
    }
-   if (!is_valid) {
+
+   std::vector<uint16_t> actual_uses = dead_code_analysis(program);
+   check(ctx.uses.size() == actual_uses.size(), "ctx.uses has wrong size", nullptr);
+   check(ctx.info.size() == actual_uses.size(), "ctx.info has wrong size", nullptr);
+
+   if (!is_valid)
       abort();
+
+   for (unsigned i = 0; i < ctx.uses.size(); i++) {
+      if (incorrect_uses_lits && (ctx.info[i].label & label_constant))
+         check(ctx.uses[i] <= actual_uses[i], "ctx.uses[i] is too high for a literal",
+               ctx.info[i].parent_instr);
+      else
+         check(ctx.uses[i] == actual_uses[i], "ctx.uses[i] is incorrect", ctx.info[i].parent_instr);
    }
+
+   if (!is_valid)
+      abort();
 }
 
 void rename_loop_header_phis(opt_ctx& ctx) {
@@ -5230,18 +5246,16 @@ optimize(Program* program)
          label_instruction(ctx, instr);
    }
 
-   validate_opt_ctx(ctx);
-
    rename_loop_header_phis(ctx);
 
-   validate_opt_ctx(ctx);
-
    ctx.uses = dead_code_analysis(program);
 
+   validate_opt_ctx(ctx, false);
+
    /* 2. Rematerialize constants in every block. */
    rematerialize_constants(ctx);
 
-   validate_opt_ctx(ctx);
+   validate_opt_ctx(ctx, false);
 
    /* 3. Combine v_mad, omod, clamp and propagate sgpr on VALU instructions */
    for (Block& block : program->blocks) {
@@ -5258,7 +5272,7 @@ optimize(Program* program)
       }
    }
 
-   validate_opt_ctx(ctx);
+   validate_opt_ctx(ctx, false);
 
    /* 4. Top-Down DAG pass (backward) to select instructions (includes DCE) */
    for (auto block_rit = program->blocks.rbegin(); block_rit != program->blocks.rend();
@@ -5270,7 +5284,7 @@ optimize(Program* program)
          select_instruction(ctx, *instr_rit);
    }
 
-   validate_opt_ctx(ctx);
+   validate_opt_ctx(ctx, true);
 
    /* 5. Add literals to instructions */
    for (Block& block : program->blocks) {
@@ -5281,7 +5295,7 @@ optimize(Program* program)
       block.instructions = std::move(ctx.instructions);
    }
 
-   validate_opt_ctx(ctx);
+   validate_opt_ctx(ctx, true);
 }
 
 } // namespace aco
-- 
GitLab

