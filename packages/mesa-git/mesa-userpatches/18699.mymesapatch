From 6c95f15b092778acf4eefe87e235274ff2396cd9 Mon Sep 17 00:00:00 2001
From: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date: Tue, 20 Sep 2022 12:46:15 +0200
Subject: [PATCH 1/4] radv: rework multiview lowering in NIR slightly

This will be used to export multiview unconditionally with GPL.

Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
---
 src/amd/vulkan/radv_pipeline.c | 36 ++++++++++++++++++++++------------
 1 file changed, 23 insertions(+), 13 deletions(-)

diff --git a/src/amd/vulkan/radv_pipeline.c b/src/amd/vulkan/radv_pipeline.c
index 1eb3d5d0b15a..ecc8240d5247 100644
--- a/src/amd/vulkan/radv_pipeline.c
+++ b/src/amd/vulkan/radv_pipeline.c
@@ -2066,15 +2066,19 @@ find_layer_out_var(nir_shader *nir)
 }
 
 static bool
-radv_lower_multiview(nir_shader *nir)
+radv_should_export_multiview(const struct radv_pipeline_stage *producer,
+                             const struct radv_pipeline_stage *consumer,
+                             const struct radv_pipeline_key *pipeline_key)
 {
-   /* This pass is not suitable for mesh shaders, because it can't know
-    * the mapping between API mesh shader invocations and output primitives.
-    * Needs to be handled in ac_nir_lower_ngg.
-    */
-   if (nir->info.stage == MESA_SHADER_MESH)
-      return false;
+   /* Export the layer in the last VGT stage if multiview is used. */
+   return pipeline_key->has_multiview_view_index &&
+          !(producer->nir->info.outputs_written & VARYING_BIT_LAYER) &&
+          consumer->stage == MESA_SHADER_FRAGMENT;
+}
 
+static bool
+radv_export_multiview(nir_shader *nir)
+{
    nir_function_impl *impl = nir_shader_get_entrypoint(nir);
    bool progress = false;
 
@@ -2339,12 +2343,6 @@ radv_pipeline_link_shaders(const struct radv_device *device,
          NIR_PASS(_, consumer, radv_lower_viewport_to_zero);
       }
 
-      /* Export the layer in the last VGT stage if multiview is used. */
-      if (pipeline_key->has_multiview_view_index &&
-          !(producer->info.outputs_written & VARYING_BIT_LAYER)) {
-         NIR_PASS(_, producer, radv_lower_multiview);
-      }
-
       /* Lower the view index to map on the layer. */
       NIR_PASS(_, consumer, radv_lower_view_index, producer->info.stage == MESA_SHADER_MESH);
    }
@@ -2460,6 +2458,10 @@ radv_pipeline_link_vs(const struct radv_device *device, struct radv_pipeline_sta
          NIR_PASS(_, vs_stage->nir, radv_export_implicit_primitive_id);
       }
 
+      if (radv_should_export_multiview(vs_stage, next_stage, pipeline_key)) {
+         NIR_PASS(_, vs_stage->nir, radv_export_multiview);
+      }
+
       radv_pipeline_link_shaders(device, vs_stage->nir, next_stage->nir, pipeline_key);
    }
 
@@ -2525,6 +2527,10 @@ radv_pipeline_link_tes(const struct radv_device *device, struct radv_pipeline_st
          NIR_PASS(_, tes_stage->nir, radv_export_implicit_primitive_id);
       }
 
+      if (radv_should_export_multiview(tes_stage, next_stage, pipeline_key)) {
+         NIR_PASS(_, tes_stage->nir, radv_export_multiview);
+      }
+
       radv_pipeline_link_shaders(device, tes_stage->nir, next_stage->nir, pipeline_key);
    }
 
@@ -2551,6 +2557,10 @@ radv_pipeline_link_gs(const struct radv_device *device, struct radv_pipeline_sta
    if (fs_stage) {
       assert(fs_stage->nir->info.stage == MESA_SHADER_FRAGMENT);
 
+      if (radv_should_export_multiview(gs_stage, fs_stage, pipeline_key)) {
+         NIR_PASS(_, gs_stage->nir, radv_export_multiview);
+      }
+
       radv_pipeline_link_shaders(device, gs_stage->nir, fs_stage->nir, pipeline_key);
    }
 
-- 
GitLab


From 147119830a0afd10aa758a4b62ad5d7c0f03eff2 Mon Sep 17 00:00:00 2001
From: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date: Tue, 20 Sep 2022 11:40:35 +0200
Subject: [PATCH 2/4] radv: fix handling ViewportIndex with GPL

When the fragment shader reads the viewport index as input and the last
pre-rasterization stage doesn't export it, it should be implicitly
zero (ie. first viewport). When the next stage is known, it's already
lowered in NIR, but with GPL we can't because we don't know if the FS
reads it. To fix this use AC_EXP_PARAM_DEFAULT_VAL_000.

Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
---
 src/amd/vulkan/radv_pipeline.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/src/amd/vulkan/radv_pipeline.c b/src/amd/vulkan/radv_pipeline.c
index ecc8240d5247..26e2b9b3538d 100644
--- a/src/amd/vulkan/radv_pipeline.c
+++ b/src/amd/vulkan/radv_pipeline.c
@@ -5413,7 +5413,7 @@ radv_pipeline_emit_ps_inputs(struct radeon_cmdbuf *ctx_cs,
 
    if (ps->info.ps.viewport_index_input && !mesh)
       single_slot_to_ps_input(outinfo, VARYING_SLOT_VIEWPORT, ps_input_cntl, &ps_offset,
-                              false, false, true);
+                              false, true, true);
 
    if (ps->info.ps.has_pcoord)
       ps_input_cntl[ps_offset++] = S_028644_PT_SPRITE_TEX(1) | S_028644_OFFSET(0x20);
@@ -5442,7 +5442,7 @@ radv_pipeline_emit_ps_inputs(struct radeon_cmdbuf *ctx_cs,
 
    if (ps->info.ps.viewport_index_input && mesh)
       single_slot_to_ps_input(outinfo, VARYING_SLOT_VIEWPORT, ps_input_cntl, &ps_offset,
-                              false, false, false);
+                              false, true, false);
 
    input_mask_to_ps_inputs(outinfo, ps, ps->info.ps.input_per_primitive_mask,
                            ps_input_cntl, &ps_offset);
-- 
GitLab


From c28fce4c0b40de259cc88eea327095d05a185a53 Mon Sep 17 00:00:00 2001
From: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date: Tue, 20 Sep 2022 11:19:13 +0200
Subject: [PATCH 3/4] radv: fix handling primitive ID and clip/cull distances
 with GPL

When compiling the pre-rasterization stages with GPL, we can't know if
the fragment shader reads the primitive ID or the clip/cull distances
as inputs and we have to export them unconditionally.

Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
---
 src/amd/vulkan/radv_pipeline.c    | 34 ++++++++++++++++++-------------
 src/amd/vulkan/radv_shader_info.c | 10 +++++----
 2 files changed, 26 insertions(+), 18 deletions(-)

diff --git a/src/amd/vulkan/radv_pipeline.c b/src/amd/vulkan/radv_pipeline.c
index 26e2b9b3538d..aa0f6d83f984 100644
--- a/src/amd/vulkan/radv_pipeline.c
+++ b/src/amd/vulkan/radv_pipeline.c
@@ -2142,14 +2142,20 @@ radv_should_export_implicit_primitive_id(const struct radv_pipeline_stage *produ
                                          const struct radv_pipeline_stage *consumer)
 {
    /* When the primitive ID is read by FS, we must ensure that it's exported by the previous vertex
-    * stage because it's implicit for VS or TES (but required by the Vulkan spec for GS or MS). Note
-    * that when the pipeline uses NGG, it's exported later during the lowering pass.
+    * stage because it's implicit for VS or TES (but required by the Vulkan spec for GS or MS).
+    *
+    * There is two situations to handle:
+    *  - when the next stage is unknown (with graphics pipeline library), the primitive ID is
+    *  exported unconditionally
+    *  - when the pipeline uses NGG, the primitive ID is exported during NGG lowering
     */
    assert(producer->stage == MESA_SHADER_VERTEX || producer->stage == MESA_SHADER_TESS_EVAL);
-   return (consumer->stage == MESA_SHADER_FRAGMENT &&
-           (consumer->nir->info.inputs_read & VARYING_BIT_PRIMITIVE_ID) &&
-           !(producer->nir->info.outputs_written & VARYING_BIT_PRIMITIVE_ID) &&
-           !producer->info.is_ngg);
+
+   if ((producer->nir->info.outputs_written & VARYING_BIT_PRIMITIVE_ID) || producer->info.is_ngg)
+      return false;
+
+   return !consumer || (consumer->stage == MESA_SHADER_FRAGMENT &&
+          (consumer->nir->info.inputs_read & VARYING_BIT_PRIMITIVE_ID));
 }
 
 static bool
@@ -2449,15 +2455,15 @@ radv_pipeline_link_vs(const struct radv_device *device, struct radv_pipeline_sta
 {
    assert(vs_stage->nir->info.stage == MESA_SHADER_VERTEX);
 
+   if (radv_should_export_implicit_primitive_id(vs_stage, next_stage)) {
+      NIR_PASS(_, vs_stage->nir, radv_export_implicit_primitive_id);
+   }
+
    if (next_stage) {
       assert(next_stage->nir->info.stage == MESA_SHADER_TESS_CTRL ||
              next_stage->nir->info.stage == MESA_SHADER_GEOMETRY ||
              next_stage->nir->info.stage == MESA_SHADER_FRAGMENT);
 
-      if (radv_should_export_implicit_primitive_id(vs_stage, next_stage)) {
-         NIR_PASS(_, vs_stage->nir, radv_export_implicit_primitive_id);
-      }
-
       if (radv_should_export_multiview(vs_stage, next_stage, pipeline_key)) {
          NIR_PASS(_, vs_stage->nir, radv_export_multiview);
       }
@@ -2519,14 +2525,14 @@ radv_pipeline_link_tes(const struct radv_device *device, struct radv_pipeline_st
 {
    assert(tes_stage->nir->info.stage == MESA_SHADER_TESS_EVAL);
 
+   if (radv_should_export_implicit_primitive_id(tes_stage, next_stage)) {
+      NIR_PASS(_, tes_stage->nir, radv_export_implicit_primitive_id);
+   }
+
    if (next_stage) {
       assert(next_stage->nir->info.stage == MESA_SHADER_GEOMETRY ||
              next_stage->nir->info.stage == MESA_SHADER_FRAGMENT);
 
-      if (radv_should_export_implicit_primitive_id(tes_stage, next_stage)) {
-         NIR_PASS(_, tes_stage->nir, radv_export_implicit_primitive_id);
-      }
-
       if (radv_should_export_multiview(tes_stage, next_stage, pipeline_key)) {
          NIR_PASS(_, tes_stage->nir, radv_export_multiview);
       }
diff --git a/src/amd/vulkan/radv_shader_info.c b/src/amd/vulkan/radv_shader_info.c
index 8d31675b3096..a7438daca38a 100644
--- a/src/amd/vulkan/radv_shader_info.c
+++ b/src/amd/vulkan/radv_shader_info.c
@@ -1250,11 +1250,13 @@ radv_link_shaders_info(struct radv_device *device,
                        struct radv_pipeline_stage *producer, struct radv_pipeline_stage *consumer,
                        const struct radv_pipeline_key *pipeline_key)
 {
-   /* Export primitive ID or clip/cull distances if necessary. */
-   if (consumer && consumer->stage == MESA_SHADER_FRAGMENT) {
+   /* Export primitive ID and clip/cull distances if read by the FS, or export unconditionally when
+    * the next stage is unknown (with graphics pipeline library).
+    */
+   if (!consumer || consumer->stage == MESA_SHADER_FRAGMENT) {
       struct radv_vs_output_info *outinfo = &producer->info.outinfo;
-      const bool ps_prim_id_in = consumer->info.ps.prim_id_input;
-      const bool ps_clip_dists_in = !!consumer->info.ps.num_input_clips_culls;
+      const bool ps_prim_id_in = !consumer ? true : consumer->info.ps.prim_id_input;
+      const bool ps_clip_dists_in = !consumer ? true : !!consumer->info.ps.num_input_clips_culls;
 
       if (ps_prim_id_in &&
           (producer->stage == MESA_SHADER_VERTEX || producer->stage == MESA_SHADER_TESS_EVAL)) {
-- 
GitLab


From b8d78c19bda4afe8a490645c629e29524a982cd2 Mon Sep 17 00:00:00 2001
From: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date: Tue, 20 Sep 2022 12:53:11 +0200
Subject: [PATCH 4/4] radv: fix handling multiview with GPL

When multiview is used, the last pre-rasterization stage should export
the layer to the fragment shader. With GPL, the next stage is
implicitly FS.

Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
---
 src/amd/vulkan/radv_pipeline.c | 30 ++++++++++++++++--------------
 1 file changed, 16 insertions(+), 14 deletions(-)

diff --git a/src/amd/vulkan/radv_pipeline.c b/src/amd/vulkan/radv_pipeline.c
index aa0f6d83f984..c1dc410b5677 100644
--- a/src/amd/vulkan/radv_pipeline.c
+++ b/src/amd/vulkan/radv_pipeline.c
@@ -2070,10 +2070,12 @@ radv_should_export_multiview(const struct radv_pipeline_stage *producer,
                              const struct radv_pipeline_stage *consumer,
                              const struct radv_pipeline_key *pipeline_key)
 {
-   /* Export the layer in the last VGT stage if multiview is used. */
+   /* Export the layer in the last VGT stage if multiview is used. When the next stage is unknown
+    * (with graphics pipeline library), the layer is exported unconditionally.
+    */
    return pipeline_key->has_multiview_view_index &&
           !(producer->nir->info.outputs_written & VARYING_BIT_LAYER) &&
-          consumer->stage == MESA_SHADER_FRAGMENT;
+          (!consumer || consumer->stage == MESA_SHADER_FRAGMENT);
 }
 
 static bool
@@ -2459,15 +2461,15 @@ radv_pipeline_link_vs(const struct radv_device *device, struct radv_pipeline_sta
       NIR_PASS(_, vs_stage->nir, radv_export_implicit_primitive_id);
    }
 
+   if (radv_should_export_multiview(vs_stage, next_stage, pipeline_key)) {
+      NIR_PASS(_, vs_stage->nir, radv_export_multiview);
+   }
+
    if (next_stage) {
       assert(next_stage->nir->info.stage == MESA_SHADER_TESS_CTRL ||
              next_stage->nir->info.stage == MESA_SHADER_GEOMETRY ||
              next_stage->nir->info.stage == MESA_SHADER_FRAGMENT);
 
-      if (radv_should_export_multiview(vs_stage, next_stage, pipeline_key)) {
-         NIR_PASS(_, vs_stage->nir, radv_export_multiview);
-      }
-
       radv_pipeline_link_shaders(device, vs_stage->nir, next_stage->nir, pipeline_key);
    }
 
@@ -2529,14 +2531,14 @@ radv_pipeline_link_tes(const struct radv_device *device, struct radv_pipeline_st
       NIR_PASS(_, tes_stage->nir, radv_export_implicit_primitive_id);
    }
 
+   if (radv_should_export_multiview(tes_stage, next_stage, pipeline_key)) {
+      NIR_PASS(_, tes_stage->nir, radv_export_multiview);
+   }
+
    if (next_stage) {
       assert(next_stage->nir->info.stage == MESA_SHADER_GEOMETRY ||
              next_stage->nir->info.stage == MESA_SHADER_FRAGMENT);
 
-      if (radv_should_export_multiview(tes_stage, next_stage, pipeline_key)) {
-         NIR_PASS(_, tes_stage->nir, radv_export_multiview);
-      }
-
       radv_pipeline_link_shaders(device, tes_stage->nir, next_stage->nir, pipeline_key);
    }
 
@@ -2560,13 +2562,13 @@ radv_pipeline_link_gs(const struct radv_device *device, struct radv_pipeline_sta
 {
    assert(gs_stage->nir->info.stage == MESA_SHADER_GEOMETRY);
 
+   if (radv_should_export_multiview(gs_stage, fs_stage, pipeline_key)) {
+      NIR_PASS(_, gs_stage->nir, radv_export_multiview);
+   }
+
    if (fs_stage) {
       assert(fs_stage->nir->info.stage == MESA_SHADER_FRAGMENT);
 
-      if (radv_should_export_multiview(gs_stage, fs_stage, pipeline_key)) {
-         NIR_PASS(_, gs_stage->nir, radv_export_multiview);
-      }
-
       radv_pipeline_link_shaders(device, gs_stage->nir, fs_stage->nir, pipeline_key);
    }
 
-- 
GitLab

