From 6d648db53433daf5272d9ae611e4a067c4a45a98 Mon Sep 17 00:00:00 2001
From: Patrick Lerda <patrick9876@free.fr>
Date: Mon, 10 Apr 2023 03:35:46 +0200
Subject: [PATCH] util/hash_table: fix hash_table_u64 memory leak for 32-bit
 architecture

Indeed, on a non 64-bit architecture "hash_key_u64" is allocated.
It should be freed accordingly.

For instance, this issue is triggered on an arm32 compiled
"piglit/bin/ext_transform_feedback-output-type mat3  -auto -fbo":
Direct leak of 64 byte(s) in 8 object(s) allocated from:
    #0 0xf7a34152 in calloc (/usr/lib/libasan.so.6+0x84152)
    #1 0xef2a3dd4 in _mesa_hash_table_u64_insert ../src/util/hash_table.c:844
...
SUMMARY: AddressSanitizer: 336 byte(s) leaked in 42 allocation(s).

Fixes: ff494361bee7 ("util: rzalloc and free hash_table_u64")
Signed-off-by: Patrick Lerda <patrick9876@free.fr>
---
 src/util/hash_table.c | 30 +++++++++++++++++++++++-------
 1 file changed, 23 insertions(+), 7 deletions(-)

diff --git a/src/util/hash_table.c b/src/util/hash_table.c
index dc00b2de8e9f..ac7bc159c7b8 100644
--- a/src/util/hash_table.c
+++ b/src/util/hash_table.c
@@ -357,8 +357,9 @@ _mesa_hash_table_search_pre_hashed(struct hash_table *ht, uint32_t hash,
 }
 
 static struct hash_entry *
-hash_table_insert(struct hash_table *ht, uint32_t hash,
-                  const void *key, void *data);
+hash_table_insert(struct hash_table *ht, uint32_t hash, const void *key,
+                  void *data,
+                  void (*delete_function)(struct hash_entry *entry));
 
 static void
 hash_table_insert_rehash(struct hash_table *ht, uint32_t hash,
@@ -427,8 +428,8 @@ _mesa_hash_table_rehash(struct hash_table *ht, unsigned new_size_index)
 }
 
 static struct hash_entry *
-hash_table_insert(struct hash_table *ht, uint32_t hash,
-                  const void *key, void *data)
+hash_table_insert(struct hash_table *ht, uint32_t hash, const void *key,
+                  void *data, void (*delete_function)(struct hash_entry *entry))
 {
    struct hash_entry *available_entry = NULL;
 
@@ -470,6 +471,8 @@ hash_table_insert(struct hash_table *ht, uint32_t hash,
       if (!entry_is_deleted(ht, entry) &&
           entry->hash == hash &&
           ht->key_equals_function(key, entry->key)) {
+         if (delete_function)
+            delete_function(entry);
          entry->key = key;
          entry->data = data;
          return entry;
@@ -506,7 +509,7 @@ struct hash_entry *
 _mesa_hash_table_insert(struct hash_table *ht, const void *key, void *data)
 {
    assert(ht->key_hash_function);
-   return hash_table_insert(ht, ht->key_hash_function(key), key, data);
+   return hash_table_insert(ht, ht->key_hash_function(key), key, data, NULL);
 }
 
 struct hash_entry *
@@ -514,7 +517,7 @@ _mesa_hash_table_insert_pre_hashed(struct hash_table *ht, uint32_t hash,
                                    const void *key, void *data)
 {
    assert(ht->key_hash_function == NULL || hash == ht->key_hash_function(key));
-   return hash_table_insert(ht, hash, key, data);
+   return hash_table_insert(ht, hash, key, data, NULL);
 }
 
 /**
@@ -816,11 +819,22 @@ _mesa_hash_table_u64_clear(struct hash_table_u64 *ht)
    ht->deleted_key_data = NULL;
 }
 
+static void
+entry_free(struct hash_entry *entry)
+{
+   if (entry->key)
+      FREE((void *)entry->key);
+}
+
 void
 _mesa_hash_table_u64_destroy(struct hash_table_u64 *ht)
 {
    if (!ht)
       return;
+
+   if (sizeof(void *) != 8)
+      _mesa_hash_table_destroy(ht->table, entry_free);
+
    ralloc_free(ht);
 }
 
@@ -847,7 +861,9 @@ _mesa_hash_table_u64_insert(struct hash_table_u64 *ht, uint64_t key,
          return;
       _key->value = key;
 
-      _mesa_hash_table_insert(ht->table, _key, data);
+      assert(ht->table->key_hash_function);
+      hash_table_insert(ht->table, ht->table->key_hash_function(_key), _key,
+                        data, entry_free);
    }
 }
 
-- 
GitLab

