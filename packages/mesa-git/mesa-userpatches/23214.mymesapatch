From 0f07acc45cb67de857074be8cce973713fe21d1f Mon Sep 17 00:00:00 2001
From: Rob Clark <robdclark@chromium.org>
Date: Wed, 24 May 2023 10:03:24 -0700
Subject: [PATCH] gbm: Allow GBM allocation of YUV surfaces

YUV surfaces may potentially not be renderable by the GPU itself, but
they can be sampled from the GPU, and exported to other devices such as
video decoder which can render into them.

This is required by chrome/chromium v4l2 based video decode stack.  In
the context of ChromeOS, minigbm allows for allocating YUV gbm BOs.
This brings parity to minigbm, so that the v4l2 codec stack can also be
used on linux.

Suggested-by: https://gitlab.freedesktop.org/mesa/mesa/-/issues/7745
Closes: https://gitlab.freedesktop.org/mesa/mesa/-/issues/9079
Signed-off-by: Rob Clark <robdclark@chromium.org>
---
 src/egl/drivers/dri2/platform_drm.c |  6 +++
 src/gbm/backends/dri/gbm_dri.c      | 76 +++++++++++++++++++++++++++++
 src/gbm/backends/dri/gbm_driint.h   |  1 +
 3 files changed, 83 insertions(+)

diff --git a/src/egl/drivers/dri2/platform_drm.c b/src/egl/drivers/dri2/platform_drm.c
index ebc73db525202..f4ee45b8c3790 100644
--- a/src/egl/drivers/dri2/platform_drm.c
+++ b/src/egl/drivers/dri2/platform_drm.c
@@ -117,6 +117,9 @@ dri2_drm_config_is_compatible(struct dri2_egl_display *dri2_dpy,
          break;
    }
 
+   if (visual->is_yuv)
+      return false;
+
    if (i == dri2_dpy->gbm_dri->num_visuals)
       return false;
 
@@ -631,6 +634,9 @@ drm_add_configs_for_visuals(_EGLDisplay *disp)
       for (unsigned j = 0; j < num_visuals; j++) {
          struct dri2_egl_config *dri2_conf;
 
+         if (visuals[j].is_yuv)
+            continue;
+
          if (visuals[j].rgba_shifts.red != shifts[0] ||
              visuals[j].rgba_shifts.green != shifts[1] ||
              visuals[j].rgba_shifts.blue != shifts[2] ||
diff --git a/src/gbm/backends/dri/gbm_dri.c b/src/gbm/backends/dri/gbm_dri.c
index ed76087b20b75..02a6117e03865 100644
--- a/src/gbm/backends/dri/gbm_dri.c
+++ b/src/gbm/backends/dri/gbm_dri.c
@@ -522,6 +522,82 @@ static const struct gbm_dri_visual gbm_dri_visuals_table[] = {
      { 16, 16, 16, 16 },
      true,
    },
+   {
+     GBM_FORMAT_YUYV, __DRI_IMAGE_FORMAT_NONE,
+     .is_yuv = true,
+   },
+   {
+     GBM_FORMAT_YVYU, __DRI_IMAGE_FORMAT_NONE,
+     .is_yuv = true,
+   },
+   {
+     GBM_FORMAT_UYVY, __DRI_IMAGE_FORMAT_NONE,
+     .is_yuv = true,
+   },
+   {
+     GBM_FORMAT_VYUY, __DRI_IMAGE_FORMAT_NONE,
+     .is_yuv = true,
+   },
+   {
+     GBM_FORMAT_AYUV, __DRI_IMAGE_FORMAT_NONE,
+     .is_yuv = true,
+   },
+   {
+     GBM_FORMAT_NV12, __DRI_IMAGE_FORMAT_NONE,
+     .is_yuv = true,
+   },
+   {
+     GBM_FORMAT_NV21, __DRI_IMAGE_FORMAT_NONE,
+     .is_yuv = true,
+   },
+   {
+     GBM_FORMAT_NV16, __DRI_IMAGE_FORMAT_NONE,
+     .is_yuv = true,
+   },
+   {
+     GBM_FORMAT_NV61, __DRI_IMAGE_FORMAT_NONE,
+     .is_yuv = true,
+   },
+   {
+     GBM_FORMAT_YUV410, __DRI_IMAGE_FORMAT_NONE,
+     .is_yuv = true,
+   },
+   {
+     GBM_FORMAT_YVU410, __DRI_IMAGE_FORMAT_NONE,
+     .is_yuv = true,
+   },
+   {
+     GBM_FORMAT_YUV411, __DRI_IMAGE_FORMAT_NONE,
+     .is_yuv = true,
+   },
+   {
+     GBM_FORMAT_YVU411, __DRI_IMAGE_FORMAT_NONE,
+     .is_yuv = true,
+   },
+   {
+     GBM_FORMAT_YUV420, __DRI_IMAGE_FORMAT_NONE,
+     .is_yuv = true,
+   },
+   {
+     GBM_FORMAT_YVU420, __DRI_IMAGE_FORMAT_NONE,
+     .is_yuv = true,
+   },
+   {
+     GBM_FORMAT_YUV422, __DRI_IMAGE_FORMAT_NONE,
+     .is_yuv = true,
+   },
+   {
+     GBM_FORMAT_YVU422, __DRI_IMAGE_FORMAT_NONE,
+     .is_yuv = true,
+   },
+   {
+     GBM_FORMAT_YUV444, __DRI_IMAGE_FORMAT_NONE,
+     .is_yuv = true,
+   },
+   {
+     GBM_FORMAT_YVU444, __DRI_IMAGE_FORMAT_NONE,
+     .is_yuv = true,
+   },
 };
 
 static int
diff --git a/src/gbm/backends/dri/gbm_driint.h b/src/gbm/backends/dri/gbm_driint.h
index def6debd32c1e..01af66ac03385 100644
--- a/src/gbm/backends/dri/gbm_driint.h
+++ b/src/gbm/backends/dri/gbm_driint.h
@@ -58,6 +58,7 @@ struct gbm_dri_visual {
       unsigned int alpha;
    } rgba_sizes;
    bool is_float;
+   bool is_yuv;
 };
 
 struct gbm_dri_device {
-- 
GitLab

From c3a318016df57858eec2ff54828e01f9bd43744a Mon Sep 17 00:00:00 2001
From: Hannes Mann <hannesmann2000@gmail.com>
Date: Sun, 8 Oct 2023 04:31:35 +0200
Subject: [PATCH] frontends/va: Export one descriptor for contiguous planes

This is required for Chromium's VaapiVideoDecoder to work on AMD.
---
 src/gallium/frontends/va/surface.c | 68 ++++++++++++++++++++----------
 1 file changed, 45 insertions(+), 23 deletions(-)

diff --git a/src/gallium/frontends/va/surface.c b/src/gallium/frontends/va/surface.c
index baddba39bbcd..ed3a3710dc10 100644
--- a/src/gallium/frontends/va/surface.c
+++ b/src/gallium/frontends/va/surface.c
@@ -1628,8 +1628,14 @@ vlVaExportSurfaceHandle(VADriverContextP ctx,
 #else
    VADRMPRIMESurfaceDescriptor *desc = descriptor;
    desc->fourcc = PipeFormatToVaFourcc(buffer->buffer_format);
-   desc->width  = surf->templat.width;
+   desc->width = surf->templat.width;
    desc->height = surf->templat.height;
+   desc->num_objects = 0;
+
+   bool supports_contiguous_planes = screen->resource_get_info &&
+      screen->get_video_param(screen, PIPE_VIDEO_PROFILE_UNKNOWN,
+                              PIPE_VIDEO_ENTRYPOINT_BITSTREAM,
+                              PIPE_VIDEO_CAP_SUPPORTS_CONTIGUOUS_PLANES_MAP);

    for (p = 0; p < ARRAY_SIZE(desc->objects); p++) {
       struct winsys_handle whandle;
@@ -1647,37 +1653,53 @@ vlVaExportSurfaceHandle(VADriverContextP ctx,
          goto fail;
       }

-      memset(&whandle, 0, sizeof(whandle));
-      whandle.type = WINSYS_HANDLE_TYPE_FD;
+      /* If the driver stores all planes in the same buffer, only one descriptor
+       * needs to be exported. resource_get_info is used to obtain pitch and
+       * offset for each plane. */
+      bool surface_needs_descriptor = (p == 0) || !supports_contiguous_planes;
+      if (surface_needs_descriptor) {
+         memset(&whandle, 0, sizeof(whandle));
+         whandle.type = WINSYS_HANDLE_TYPE_FD;
+
+         if (!screen->resource_get_handle(screen, drv->pipe, resource,
+                                          &whandle, usage)) {
+            ret = VA_STATUS_ERROR_INVALID_SURFACE;
+            goto fail;
+         }

-      if (!screen->resource_get_handle(screen, drv->pipe, resource,
-                                       &whandle, usage)) {
-         ret = VA_STATUS_ERROR_INVALID_SURFACE;
-         goto fail;
-      }
+         desc->objects[p].fd = (int)whandle.handle;
+         desc->num_objects++;

-      desc->objects[p].fd   = (int)whandle.handle;
-      /* As per VADRMPRIMESurfaceDescriptor documentation, size must be the
-       * "Total size of this object (may include regions which are not part
-       * of the surface)."" */
-      desc->objects[p].size = (uint32_t) whandle.size;
-      desc->objects[p].drm_format_modifier = whandle.modifier;
+         /* As per VADRMPRIMESurfaceDescriptor documentation, size must be the
+         * "Total size of this object (may include regions which are not part
+         * of the surface)."" */
+         desc->objects[p].size = (uint32_t) whandle.size;
+         desc->objects[p].drm_format_modifier = whandle.modifier;
+      }

       if (flags & VA_EXPORT_SURFACE_COMPOSED_LAYERS) {
-         desc->layers[0].object_index[p] = p;
-         desc->layers[0].offset[p]       = whandle.offset;
-         desc->layers[0].pitch[p]        = whandle.stride;
+         desc->layers[0].object_index[p] = desc->num_objects - 1;
+
+         if (supports_contiguous_planes) {
+            screen->resource_get_info(screen, resource, &desc->layers[0].pitch[p], &desc->layers[0].offset[p]);
+         } else {
+            desc->layers[0].pitch[p] = whandle.stride;
+            desc->layers[0].offset[p] = whandle.offset;
+         }
       } else {
          desc->layers[p].drm_format      = drm_format;
          desc->layers[p].num_planes      = 1;
-         desc->layers[p].object_index[0] = p;
-         desc->layers[p].offset[0]       = whandle.offset;
-         desc->layers[p].pitch[0]        = whandle.stride;
+         desc->layers[p].object_index[0] = desc->num_objects - 1;
+
+         if (supports_contiguous_planes) {
+            screen->resource_get_info(screen, resource, &desc->layers[p].pitch[0], &desc->layers[p].offset[0]);
+         } else {
+            desc->layers[p].pitch[0] = whandle.stride;
+            desc->layers[p].offset[0] = whandle.offset;
+         }
       }
    }

-   desc->num_objects = p;
-
    if (flags & VA_EXPORT_SURFACE_COMPOSED_LAYERS) {
       uint32_t drm_format = pipe_format_to_drm_format(buffer->buffer_format);
       if (drm_format == DRM_FORMAT_INVALID) {
@@ -1699,7 +1721,7 @@ vlVaExportSurfaceHandle(VADriverContextP ctx,

 fail:
 #ifndef _WIN32
-   for (i = 0; i < p; i++)
+   for (i = 0; i < desc->num_objects; i++)
       close(desc->objects[i].fd);
 #else
    if(whandle.handle)

From 99f5bf72000de3ed49bd3f8acdac1bd162361986 Mon Sep 17 00:00:00 2001
From: Hannes Mann <hannesmann2000@gmail.com>
Date: Mon, 9 Oct 2023 20:33:28 +0200
Subject: [PATCH] driconf: Force linear filter for YUV textures on ANGLE

Chromium incorrectly sets VK_FILTER_NEAREST for imported VA-API textures.

All video textures should have sampler->vk.ycbcr_conversion set since video
is either YUV420 or YUV444.
---
 src/amd/vulkan/radv_instance.c |  3 +++
 src/amd/vulkan/radv_private.h  |  1 +
 src/amd/vulkan/radv_sampler.c  | 13 +++++++++++--
 src/util/00-radv-defaults.conf |  4 ++++
 src/util/driconf.h             |  4 ++++
 5 files changed, 23 insertions(+), 2 deletions(-)

diff --git a/src/amd/vulkan/radv_instance.c b/src/amd/vulkan/radv_instance.c
index b0b593dd43ef..8922205e1fe9 100644
--- a/src/amd/vulkan/radv_instance.c
+++ b/src/amd/vulkan/radv_instance.c
@@ -150,6 +150,7 @@ static const driOptionDescription radv_dri_options[] = {
       DRI_CONF_RADV_TEX_NON_UNIFORM(false)
       DRI_CONF_RADV_FLUSH_BEFORE_TIMESTAMP_WRITE(false)
       DRI_CONF_RADV_RT_WAVE64(false)
+      DRI_CONF_RADV_FORCE_YUV_LINEAR(false)
       DRI_CONF_DUAL_COLOR_BLEND_BY_LOCATION(false)
       DRI_CONF_RADV_APP_LAYER()
    DRI_CONF_SECTION_END
@@ -206,6 +207,8 @@ radv_init_dri_options(struct radv_instance *instance)

    instance->force_rt_wave64 = driQueryOptionb(&instance->dri_options, "radv_rt_wave64");

+   instance->force_yuv_linear = driQueryOptionb(&instance->dri_options, "radv_force_yuv_linear");
+
    instance->dual_color_blend_by_location = driQueryOptionb(&instance->dri_options, "dual_color_blend_by_location");
 }

diff --git a/src/amd/vulkan/radv_private.h b/src/amd/vulkan/radv_private.h
index c06078275f82..617f7e0ebcaf 100644
--- a/src/amd/vulkan/radv_private.h
+++ b/src/amd/vulkan/radv_private.h
@@ -413,6 +413,7 @@ struct radv_instance {
    bool tex_non_uniform;
    bool flush_before_timestamp_write;
    bool force_rt_wave64;
+   bool force_yuv_linear;
    bool dual_color_blend_by_location;
    char *app_layer;
 };
diff --git a/src/amd/vulkan/radv_sampler.c b/src/amd/vulkan/radv_sampler.c
index 19fb0ef44e6c..feae2e80939e 100644
--- a/src/amd/vulkan/radv_sampler.c
+++ b/src/amd/vulkan/radv_sampler.c
@@ -238,8 +238,17 @@ radv_init_sampler(struct radv_device *device, struct radv_sampler *sampler, cons
    sampler->state[1] = (S_008F34_MIN_LOD(radv_float_to_ufixed(CLAMP(pCreateInfo->minLod, 0, 15), 8)) |
                         S_008F34_MAX_LOD(radv_float_to_ufixed(CLAMP(pCreateInfo->maxLod, 0, 15), 8)) |
                         S_008F34_PERF_MIP(max_aniso_ratio ? max_aniso_ratio + 6 : 0));
-   sampler->state[2] = (S_008F38_XY_MAG_FILTER(radv_tex_filter(pCreateInfo->magFilter, max_aniso)) |
-                        S_008F38_XY_MIN_FILTER(radv_tex_filter(pCreateInfo->minFilter, max_aniso)) |
+
+   VkFilter mag_filter = pCreateInfo->magFilter;
+   VkFilter min_filter = pCreateInfo->minFilter;
+
+   if(device->instance->force_yuv_linear && sampler->vk.ycbcr_conversion) {
+      mag_filter = VK_FILTER_LINEAR;
+      min_filter = VK_FILTER_LINEAR;
+   }
+
+   sampler->state[2] = (S_008F38_XY_MAG_FILTER(radv_tex_filter(mag_filter, max_aniso)) |
+                        S_008F38_XY_MIN_FILTER(radv_tex_filter(min_filter, max_aniso)) |
                         S_008F38_MIP_FILTER(radv_tex_mipfilter(pCreateInfo->mipmapMode)));
    sampler->state[3] = S_008F3C_BORDER_COLOR_TYPE(radv_tex_bordercolor(border_color));

diff --git a/src/util/00-radv-defaults.conf b/src/util/00-radv-defaults.conf
index f928bf7dcc58..2d8bd7c8782c 100644
--- a/src/util/00-radv-defaults.conf
+++ b/src/util/00-radv-defaults.conf
@@ -61,6 +61,10 @@ Application bugs worked around in this file:
             <option name="radv_tex_non_uniform" value="true" />
         </engine>

+        <engine engine_name_match="ANGLE">
+            <option name="radv_force_yuv_linear" value="true" />
+        </engine>
+
         <!-- Game workarounds -->
         <application name="Shadow Of The Tomb Raider (Native)" application_name_match="ShadowOfTheTomb">
             <option name="radv_report_llvm9_version_string" value="true" />
diff --git a/src/util/driconf.h b/src/util/driconf.h
index dca737c977e5..2d871f102fca 100644
--- a/src/util/driconf.h
+++ b/src/util/driconf.h
@@ -674,6 +674,10 @@
    DRI_CONF_OPT_B(radv_rt_wave64, def, \
                   "Force wave64 in RT shaders")

+#define DRI_CONF_RADV_FORCE_YUV_LINEAR(def) \
+   DRI_CONF_OPT_B(radv_force_yuv_linear, def, \
+                  "Force VK_FILTER_LINEAR for all textures that have ycbcr_conversion set")
+
 #define DRI_CONF_RADV_APP_LAYER() DRI_CONF_OPT_S_NODEF(radv_app_layer, "Select an application layer.")

 /**
