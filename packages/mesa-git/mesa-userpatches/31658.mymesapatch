From 0d7499ea4d500520e6f3b6b496bcbf466e12f9f4 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Tue, 15 Oct 2024 10:48:16 +0800
Subject: [PATCH 01/11] egl: decouple dmabuf import/export cap from xserver
 support
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

multibuffers_available denotes xserver side support for
DRI3 and Present protocols which should not affect client
side support for dmabuf import/export.

This is for xserver with amdgpu DDX in which case
multibuffers_available will be false, but dmabuf import/export
should be enabled to support applications like mpv which use
dmabuf import for vaapi decoded buffer.

Reviewed-by: Marek Olšák <marek.olsak@amd.com>
Acked-by: Daniel Stone <daniels@collabora.com>
---
 src/egl/drivers/dri2/egl_dri2.c | 7 ++-----
 1 file changed, 2 insertions(+), 5 deletions(-)

diff --git a/src/egl/drivers/dri2/egl_dri2.c b/src/egl/drivers/dri2/egl_dri2.c
index e813aa61f527d..0819b7c66a018 100644
--- a/src/egl/drivers/dri2/egl_dri2.c
+++ b/src/egl/drivers/dri2/egl_dri2.c
@@ -629,11 +629,8 @@ dri2_setup_screen(_EGLDisplay *disp)
 
 #ifdef HAVE_LIBDRM
    unsigned caps = pscreen->caps.dmabuf;
-   /* set if both import and export are suported */
-   if (dri2_dpy->multibuffers_available) {
-      dri2_dpy->has_dmabuf_import = (caps & DRM_PRIME_CAP_IMPORT) > 0;
-      dri2_dpy->has_dmabuf_export = (caps & DRM_PRIME_CAP_EXPORT) > 0;
-   }
+   dri2_dpy->has_dmabuf_import = (caps & DRM_PRIME_CAP_IMPORT) > 0;
+   dri2_dpy->has_dmabuf_export = (caps & DRM_PRIME_CAP_EXPORT) > 0;
 #endif
 #ifdef HAVE_ANDROID_PLATFORM
    dri2_dpy->has_native_fence_fd = pscreen->caps.native_fence_fd;
-- 
GitLab


From 2e99fa9d64906e7052f99ddd9324d369339672ae Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Mon, 30 Dec 2024 21:10:18 +0800
Subject: [PATCH 02/11] dri: dmabuf cap does not rely on winsys multibuffer
 support

dmabuf cap is client side cap, should not rely on whether window
system support multibuffer (i.e. DRI2 multi plane with modifier).

Acked-by: Daniel Stone <daniels@collabora.com>
---
 src/gallium/frontends/dri/dri_screen.c | 14 ++++++--------
 src/gallium/frontends/dri/dri_screen.h |  1 +
 src/gallium/frontends/dri/kopper.c     |  2 +-
 3 files changed, 8 insertions(+), 9 deletions(-)

diff --git a/src/gallium/frontends/dri/dri_screen.c b/src/gallium/frontends/dri/dri_screen.c
index 6235fd84ba6dd..1f1748896e518 100644
--- a/src/gallium/frontends/dri/dri_screen.c
+++ b/src/gallium/frontends/dri/dri_screen.c
@@ -646,16 +646,14 @@ dri_init_screen(struct dri_screen *screen,
    if (pscreen->caps.device_protected_context)
       screen->has_protected_context = true;
    screen->has_reset_status_query = pscreen->caps.device_reset_status_query;
-
+   screen->has_multibuffer = has_multibuffer;
 
 #ifdef HAVE_LIBDRM
-   if (has_multibuffer) {
-      int dmabuf_caps = pscreen->caps.dmabuf;
-      if (dmabuf_caps & DRM_PRIME_CAP_IMPORT)
-         screen->dmabuf_import = true;
-      if (screen->dmabuf_import && dmabuf_caps & DRM_PRIME_CAP_EXPORT)
-         screen->has_dmabuf = true;
-   }
+   unsigned dmabuf_caps = pscreen->caps.dmabuf;
+   if (dmabuf_caps & DRM_PRIME_CAP_IMPORT)
+      screen->dmabuf_import = true;
+   if (screen->dmabuf_import && dmabuf_caps & DRM_PRIME_CAP_EXPORT)
+      screen->has_dmabuf = true;
 #endif
 
    return dri_fill_in_modes(screen);
diff --git a/src/gallium/frontends/dri/dri_screen.h b/src/gallium/frontends/dri/dri_screen.h
index bdb64ddf9ddc2..b01fcb46f4813 100644
--- a/src/gallium/frontends/dri/dri_screen.h
+++ b/src/gallium/frontends/dri/dri_screen.h
@@ -92,6 +92,7 @@ struct dri_screen
 
    bool throttle;
    bool dmabuf_import;
+   bool has_multibuffer;
 
    struct st_config_options options;
 
diff --git a/src/gallium/frontends/dri/kopper.c b/src/gallium/frontends/dri/kopper.c
index 99916e231d729..9593064a6f69a 100644
--- a/src/gallium/frontends/dri/kopper.c
+++ b/src/gallium/frontends/dri/kopper.c
@@ -158,7 +158,7 @@ kopper_get_pixmap_buffer(struct dri_drawable *drawable,
 
 #ifndef GLX_USE_APPLE
    drawable->image = loader_dri3_get_pixmap_buffer(conn, pixmap, screen,
-                                                   fourcc, drawable->screen->dmabuf_import, &width, &height, drawable);
+                                                   fourcc, drawable->screen->has_multibuffer, &width, &height, drawable);
 #else
    drawable->image = NULL;
 #endif
-- 
GitLab


From 6b75bd73ae3b74c5175a3c7886cf31ab579bc496 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Tue, 15 Oct 2024 11:24:13 +0800
Subject: [PATCH 03/11] glx/egl/x11: fix x11_dri3_check_multibuffer
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

glx/egl "multibuffers" denotes if server side support DRI3
multi plane and modifiers which is version >= 1.2. But now
it returns true just when DRI3 version >= 1.

This causes problem when xserver with amdgpu DDX which only
support DRI3 1.0, so "multibuffers" gets set unexpectedly,
and client send DRI3 >= 1.2 request to server which gets
unimplemented error.

Reviewed-by: Marek Olšák <marek.olsak@amd.com>
Acked-by: Daniel Stone <daniels@collabora.com>
---
 src/egl/drivers/dri2/platform_x11.c         |  3 +--
 src/gallium/auxiliary/vl/vl_winsys_kopper.c |  6 ++----
 src/glx/glxclient.h                         |  1 -
 src/glx/glxext.c                            |  4 ++--
 src/x11/loader_x11.c                        | 23 +++++++--------------
 src/x11/loader_x11.h                        |  2 +-
 6 files changed, 13 insertions(+), 26 deletions(-)

diff --git a/src/egl/drivers/dri2/platform_x11.c b/src/egl/drivers/dri2/platform_x11.c
index 4895e6d24fddf..639c83641580a 100644
--- a/src/egl/drivers/dri2/platform_x11.c
+++ b/src/egl/drivers/dri2/platform_x11.c
@@ -1789,8 +1789,7 @@ dri2_x11_check_multibuffers(_EGLDisplay *disp)
    struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
 
 #ifdef HAVE_X11_DRM
-   bool err;
-   dri2_dpy->multibuffers_available = x11_dri3_check_multibuffer(dri2_dpy->conn, &err, &dri2_dpy->explicit_modifiers);
+   dri2_dpy->multibuffers_available = x11_dri3_has_multibuffer(dri2_dpy->conn);
 
    if (disp->Options.Zink && !disp->Options.ForceSoftware &&
        !dri2_dpy->multibuffers_available &&
diff --git a/src/gallium/auxiliary/vl/vl_winsys_kopper.c b/src/gallium/auxiliary/vl/vl_winsys_kopper.c
index f8565b0a4b5d3..ca2edb28673d3 100644
--- a/src/gallium/auxiliary/vl/vl_winsys_kopper.c
+++ b/src/gallium/auxiliary/vl/vl_winsys_kopper.c
@@ -168,7 +168,6 @@ vl_kopper_screen_create_x11(Display *display, int screen)
    xcb_get_geometry_cookie_t geom_cookie;
    xcb_get_geometry_reply_t *geom_reply;
    struct vl_kopper_screen *scrn = CALLOC_STRUCT(vl_kopper_screen);
-   bool err = false;
    if (!scrn)
       goto error;
 
@@ -177,9 +176,8 @@ vl_kopper_screen_create_x11(Display *display, int screen)
       goto error;
 
    int fd = x11_dri3_open(scrn->conn, RootWindow(display, screen), 0);
-   bool explicit_modifiers = false;
-   x11_dri3_check_multibuffer(scrn->conn, &err, &explicit_modifiers);
-   if (fd < 0 || !explicit_modifiers) {
+   bool has_multibuffer = x11_dri3_has_multibuffer(scrn->conn);
+   if (fd < 0 || !has_multibuffer) {
       goto error;
    }
 
diff --git a/src/glx/glxclient.h b/src/glx/glxclient.h
index 97c5bc093f9bd..121f09707ea11 100644
--- a/src/glx/glxclient.h
+++ b/src/glx/glxclient.h
@@ -600,7 +600,6 @@ struct glx_display
 
    __glxHashTable *dri2Hash;
    bool has_multibuffer;
-   bool has_explicit_modifiers;
 #endif
 #ifdef GLX_USE_WINDOWSGL
    __GLXDRIdisplay *windowsdriDisplay;
diff --git a/src/glx/glxext.c b/src/glx/glxext.c
index f56b530c856c7..fa2399c513bf5 100644
--- a/src/glx/glxext.c
+++ b/src/glx/glxext.c
@@ -1016,7 +1016,7 @@ __glXInitialize(Display * dpy)
 #if defined(GLX_USE_DRM)
    bool dri3_err = false;
    if (glx_direct && glx_accel && dri3)
-      dpyPriv->has_multibuffer = x11_dri3_check_multibuffer(XGetXCBConnection(dpy), &dri3_err, &dpyPriv->has_explicit_modifiers);
+      dpyPriv->has_multibuffer = x11_dri3_has_multibuffer(XGetXCBConnection(dpy));
    if (glx_direct && glx_accel &&
        (!(glx_driver & GLX_DRIVER_ZINK_YES) || !kopper)) {
       if (dri3) {
@@ -1043,7 +1043,7 @@ __glXInitialize(Display * dpy)
       glx_driver |= GLX_DRIVER_SW;
 
 #if !defined(GLX_USE_APPLE)
-   if (!dpyPriv->has_explicit_modifiers && glx_accel && !debug_get_bool_option("LIBGL_KOPPER_DRI2", false)) {
+   if (!dpyPriv->has_multibuffer && glx_accel && !debug_get_bool_option("LIBGL_KOPPER_DRI2", false)) {
       if (glx_driver & GLX_DRIVER_ZINK_YES) {
          /* only print error if zink was explicitly requested */
          CriticalErrorMessageF("DRI3 not available\n");
diff --git a/src/x11/loader_x11.c b/src/x11/loader_x11.c
index 75eb560595fdd..9477ec9a4046e 100644
--- a/src/x11/loader_x11.c
+++ b/src/x11/loader_x11.c
@@ -93,7 +93,7 @@ x11_dri3_open(xcb_connection_t *conn,
 #endif
 
 bool
-x11_dri3_check_multibuffer(xcb_connection_t *c, bool *err, bool *explicit_modifiers)
+x11_dri3_has_multibuffer(xcb_connection_t *c)
 {
    xcb_dri3_query_version_cookie_t      dri3_cookie;
    xcb_dri3_query_version_reply_t       *dri3_reply;
@@ -107,11 +107,11 @@ x11_dri3_check_multibuffer(xcb_connection_t *c, bool *err, bool *explicit_modifi
 
    extension = xcb_get_extension_data(c, &xcb_dri3_id);
    if (!(extension && extension->present))
-      goto error;
+      return false;
 
    extension = xcb_get_extension_data(c, &xcb_present_id);
    if (!(extension && extension->present))
-      goto error;
+      return false;
 
    dri3_cookie = xcb_dri3_query_version(c,
                                         DRI3_SUPPORTED_MAJOR,
@@ -123,7 +123,7 @@ x11_dri3_check_multibuffer(xcb_connection_t *c, bool *err, bool *explicit_modifi
    dri3_reply = xcb_dri3_query_version_reply(c, dri3_cookie, &error);
    if (!dri3_reply) {
       free(error);
-      goto error;
+      return false;
    }
 
    int dri3Major = dri3_reply->major_version;
@@ -133,21 +133,12 @@ x11_dri3_check_multibuffer(xcb_connection_t *c, bool *err, bool *explicit_modifi
    present_reply = xcb_present_query_version_reply(c, present_cookie, &error);
    if (!present_reply) {
       free(error);
-      goto error;
+      return false;
    }
    int presentMajor = present_reply->major_version;
    int presentMinor = present_reply->minor_version;
    free(present_reply);
 
-#ifdef HAVE_X11_DRM
-   if (presentMajor > 1 || (presentMajor == 1 && presentMinor >= 2)) {
-      *explicit_modifiers = dri3Major > 1 || (dri3Major == 1 && dri3Minor >= 2);
-      if (dri3Major >= 1)
-         return true;
-   }
-#endif
-   return false;
-error:
-   *err = true;
-   return false;
+   return (presentMajor > 1 || (presentMajor == 1 && presentMinor >= 2)) &&
+      (dri3Major > 1 || (dri3Major == 1 && dri3Minor >= 2));
 }
diff --git a/src/x11/loader_x11.h b/src/x11/loader_x11.h
index 5aa6262aa1dc7..c1cfa7e2ea65e 100644
--- a/src/x11/loader_x11.h
+++ b/src/x11/loader_x11.h
@@ -27,6 +27,6 @@
 #include <xcb/xcb.h>
 #include <inttypes.h>
 int x11_dri3_open(xcb_connection_t *conn, xcb_window_t root, uint32_t provider);
-bool x11_dri3_check_multibuffer(xcb_connection_t *c, bool *err, bool *explicit_modifiers);
+bool x11_dri3_has_multibuffer(xcb_connection_t *c);
 
 #endif
-- 
GitLab


From c0b02c81542a66f2aa9f183c45c5857477bcf0a8 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Mon, 30 Dec 2024 21:16:11 +0800
Subject: [PATCH 04/11] kopper: remove unused function definition

Acked-by: Daniel Stone <daniels@collabora.com>
---
 src/gallium/frontends/dri/kopper.c | 4 ----
 1 file changed, 4 deletions(-)

diff --git a/src/gallium/frontends/dri/kopper.c b/src/gallium/frontends/dri/kopper.c
index 9593064a6f69a..4a5f77481753b 100644
--- a/src/gallium/frontends/dri/kopper.c
+++ b/src/gallium/frontends/dri/kopper.c
@@ -52,10 +52,6 @@
 #include "loader_dri3_helper.h"
 #endif
 
-static struct dri_drawable *
-kopper_create_drawable(struct dri_screen *screen, const struct gl_config *visual,
-                       bool isPixmap, void *loaderPrivate);
-
 struct pipe_screen *
 kopper_init_screen(struct dri_screen *screen, bool driver_name_is_inferred)
 {
-- 
GitLab


From bf1ec8201e315f1d63ae91c4e89b08f08cf739e6 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Mon, 30 Dec 2024 21:34:52 +0800
Subject: [PATCH 05/11] dri,egl,glx: remove redundant usage of HAVE_X11_DRM

These files are build or used only when drm platform is
available, no need to check this macro inside them.

Acked-by: Daniel Stone <daniels@collabora.com>
---
 src/egl/drivers/dri2/platform_x11_dri3.c      |  6 -----
 .../frontends/dri/loader_dri3_helper.c        | 22 ++++---------------
 .../frontends/dri/loader_dri3_helper.h        |  3 +--
 src/glx/dri3_glx.c                            |  2 --
 4 files changed, 5 insertions(+), 28 deletions(-)

diff --git a/src/egl/drivers/dri2/platform_x11_dri3.c b/src/egl/drivers/dri2/platform_x11_dri3.c
index d9b518f2a8e65..db5e64c667896 100644
--- a/src/egl/drivers/dri2/platform_x11_dri3.c
+++ b/src/egl/drivers/dri2/platform_x11_dri3.c
@@ -331,7 +331,6 @@ dri3_create_image_khr_pixmap(_EGLDisplay *disp, _EGLContext *ctx,
    return &dri2_img->base;
 }
 
-#ifdef HAVE_X11_DRM
 static _EGLImage *
 dri3_create_image_khr_pixmap_from_buffers(_EGLDisplay *disp, _EGLContext *ctx,
                                           EGLClientBuffer buffer,
@@ -384,23 +383,18 @@ dri3_create_image_khr_pixmap_from_buffers(_EGLDisplay *disp, _EGLContext *ctx,
 
    return &dri2_img->base;
 }
-#endif
 
 static _EGLImage *
 dri3_create_image_khr(_EGLDisplay *disp, _EGLContext *ctx, EGLenum target,
                       EGLClientBuffer buffer, const EGLint *attr_list)
 {
-#ifdef HAVE_X11_DRM
    struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
-#endif
 
    switch (target) {
    case EGL_NATIVE_PIXMAP_KHR:
-#ifdef HAVE_X11_DRM
       if (dri2_dpy->multibuffers_available)
          return dri3_create_image_khr_pixmap_from_buffers(disp, ctx, buffer,
                                                           attr_list);
-#endif
       return dri3_create_image_khr_pixmap(disp, ctx, buffer, attr_list);
    default:
       return dri2_create_image_khr(disp, ctx, target, buffer, attr_list);
diff --git a/src/gallium/frontends/dri/loader_dri3_helper.c b/src/gallium/frontends/dri/loader_dri3_helper.c
index 9e4ca3f570761..37970f4fa3376 100644
--- a/src/gallium/frontends/dri/loader_dri3_helper.c
+++ b/src/gallium/frontends/dri/loader_dri3_helper.c
@@ -535,7 +535,6 @@ dri3_handle_present_event(struct loader_dri3_drawable *draw,
          /* If the server tells us that our allocation is suboptimal, we
           * reallocate once.
           */
-#ifdef HAVE_X11_DRM
          if (ce->mode == XCB_PRESENT_COMPLETE_MODE_SUBOPTIMAL_COPY &&
              draw->last_present_mode != ce->mode) {
             for (int b = 0; b < ARRAY_SIZE(draw->buffers); b++) {
@@ -543,7 +542,6 @@ dri3_handle_present_event(struct loader_dri3_drawable *draw,
                   draw->buffers[b]->reallocate = true;
             }
          }
-#endif
          draw->last_present_mode = ce->mode;
 
          draw->ust = ce->ust;
@@ -1136,10 +1134,10 @@ loader_dri3_swap_buffers_msc(struct loader_dri3_drawable *draw,
        */
       if (draw->cur_blit_source != -1)
          options |= XCB_PRESENT_OPTION_COPY;
-#ifdef HAVE_X11_DRM
+
       if (draw->multiplanes_available)
          options |= XCB_PRESENT_OPTION_SUBOPTIMAL;
-#endif
+
       back->busy = 1;
       back->last_swap = draw->send_sbc;
 
@@ -1340,7 +1338,6 @@ dri3_linear_format_for_format(struct loader_dri3_drawable *draw, uint32_t format
    }
 }
 
-#ifdef HAVE_X11_DRM
 static bool
 has_supported_modifier(struct loader_dri3_drawable *draw, unsigned int format,
                        uint64_t *modifiers, uint32_t count)
@@ -1375,7 +1372,6 @@ has_supported_modifier(struct loader_dri3_drawable *draw, unsigned int format,
    free(supported_modifiers);
    return found;
 }
-#endif
 
 /** loader_dri3_alloc_render_buffer
  *
@@ -1424,7 +1420,6 @@ dri3_alloc_render_buffer(struct loader_dri3_drawable *draw, unsigned int fourcc,
       goto no_image;
 
    if (draw->dri_screen_render_gpu == draw->dri_screen_display_gpu) {
-#ifdef HAVE_X11_DRM
       if (draw->multiplanes_available && draw->dri_screen_render_gpu->base.screen->resource_create_with_modifiers) {
          xcb_dri3_get_supported_modifiers_cookie_t mod_cookie;
          xcb_dri3_get_supported_modifiers_reply_t *mod_reply;
@@ -1473,7 +1468,6 @@ dri3_alloc_render_buffer(struct loader_dri3_drawable *draw, unsigned int fourcc,
 
          free(mod_reply);
       }
-#endif
       buffer->image = dri_create_image_with_modifiers(draw->dri_screen_render_gpu,
                                               width, height, format,
                                               __DRI_IMAGE_USE_SHARE |
@@ -1599,7 +1593,6 @@ dri3_alloc_render_buffer(struct loader_dri3_drawable *draw, unsigned int fourcc,
    pixmap = xcb_generate_id(draw->conn);
 
    xcb_void_cookie_t cookie_pix, cookie_fence;
-#ifdef HAVE_X11_DRM
    if (draw->multiplanes_available &&
        buffer->modifier != DRM_FORMAT_MOD_INVALID) {
       cookie_pix = xcb_dri3_pixmap_from_buffers_checked(draw->conn,
@@ -1614,9 +1607,7 @@ dri3_alloc_render_buffer(struct loader_dri3_drawable *draw, unsigned int fourcc,
                                                         depth, buffer->cpp * 8,
                                                         buffer->modifier,
                                                         buffer_fds);
-   } else
-#endif
-   {
+   } else {
       cookie_pix = xcb_dri3_pixmap_from_buffer_checked(draw->conn,
                                                        pixmap,
                                                        draw->drawable,
@@ -1835,7 +1826,6 @@ loader_dri3_create_image(xcb_connection_t *c,
    return ret;
 }
 
-#ifdef HAVE_X11_DRM
 struct dri_image *
 loader_dri3_create_image_from_buffers(xcb_connection_t *c,
                                       xcb_dri3_buffers_from_pixmap_reply_t *bp_reply,
@@ -1876,7 +1866,6 @@ loader_dri3_create_image_from_buffers(xcb_connection_t *c,
 
    return ret;
 }
-#endif
 
 struct dri_image *
 loader_dri3_get_pixmap_buffer(xcb_connection_t *conn, xcb_drawable_t pixmap, struct dri_screen *screen,
@@ -1884,7 +1873,6 @@ loader_dri3_get_pixmap_buffer(xcb_connection_t *conn, xcb_drawable_t pixmap, str
                               int *width, int *height, void *loader_data)
 {
    struct dri_image *image;
-#ifdef HAVE_X11_DRM
    if (multiplanes_available) {
       xcb_dri3_buffers_from_pixmap_cookie_t bps_cookie;
       xcb_dri3_buffers_from_pixmap_reply_t *bps_reply;
@@ -1899,9 +1887,7 @@ loader_dri3_get_pixmap_buffer(xcb_connection_t *conn, xcb_drawable_t pixmap, str
       *width = bps_reply->width;
       *height = bps_reply->height;
       free(bps_reply);
-   } else
-#endif
-   {
+   } else {
       xcb_dri3_buffer_from_pixmap_cookie_t bp_cookie;
       xcb_dri3_buffer_from_pixmap_reply_t *bp_reply;
 
diff --git a/src/gallium/frontends/dri/loader_dri3_helper.h b/src/gallium/frontends/dri/loader_dri3_helper.h
index 9061e9755e2be..4da19d7309031 100644
--- a/src/gallium/frontends/dri/loader_dri3_helper.h
+++ b/src/gallium/frontends/dri/loader_dri3_helper.h
@@ -256,14 +256,13 @@ loader_dri3_create_image(xcb_connection_t *c,
                          struct dri_screen *dri_screen,
                          void *loaderPrivate);
 
-#ifdef HAVE_X11_DRM
 PUBLIC struct dri_image *
 loader_dri3_create_image_from_buffers(xcb_connection_t *c,
                                       xcb_dri3_buffers_from_pixmap_reply_t *bp_reply,
                                       unsigned int fourcc,
                                       struct dri_screen *dri_screen,
                                       void *loaderPrivate);
-#endif
+
 PUBLIC int
 loader_dri3_get_buffers(struct dri_drawable *driDrawable,
                         unsigned int format,
diff --git a/src/glx/dri3_glx.c b/src/glx/dri3_glx.c
index dc4eb843526d1..e3ad92bc450cb 100644
--- a/src/glx/dri3_glx.c
+++ b/src/glx/dri3_glx.c
@@ -189,9 +189,7 @@ dri3_create_drawable(struct glx_screen *base, XID xDrawable,
    pdraw->base.drawable = drawable;
    pdraw->base.psc = &psc->base;
 
-#ifdef HAVE_X11_DRM
    has_multibuffer = base->display->has_multibuffer;
-#endif
 
    (void) __glXInitialize(psc->base.dpy);
 
-- 
GitLab


From 0290add6ce6099cdc5b06374786e6ec16a86c5f6 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Wed, 23 Oct 2024 19:16:34 +0800
Subject: [PATCH 06/11] ac/surface: refine supported modifier list for multi
 block size
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Reference KMD convert_tiling_flags_to_modifier(). And we are
going to add 4K block size.

Acked-by: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
Reviewed-by: Marek Olšák <marek.olsak@amd.com>
Acked-by: Daniel Stone <daniels@collabora.com>
---
 src/amd/common/ac_surface.c | 76 ++++++++++++++++++++++---------------
 1 file changed, 46 insertions(+), 30 deletions(-)

diff --git a/src/amd/common/ac_surface.c b/src/amd/common/ac_surface.c
index fe201377895ec..ceeb7b921f348 100644
--- a/src/amd/common/ac_surface.c
+++ b/src/amd/common/ac_surface.c
@@ -322,30 +322,41 @@ bool ac_get_supported_modifiers(const struct radeon_info *info,
       ++current_mod;                                         \
    }
 
+   const unsigned block_size_bits_64k = 16;
+   const unsigned block_size_bits_256k = 18;
+
+   const unsigned pipes = G_0098F8_NUM_PIPES(info->gb_addr_config);
+   const unsigned banks = G_0098F8_NUM_BANKS(info->gb_addr_config);
+   const unsigned se = G_0098F8_NUM_SHADER_ENGINES_GFX9(info->gb_addr_config);
+   const unsigned rb_per_se = G_0098F8_NUM_RB_PER_SE(info->gb_addr_config);
+   const unsigned pkrs = G_0098F8_NUM_PKRS(info->gb_addr_config);
+
    /* The modifiers have to be added in descending order of estimated
     * performance. The drivers will prefer modifiers that come earlier
     * in the list. */
    switch (info->gfx_level) {
    case GFX9: {
-      unsigned pipe_xor_bits = MIN2(G_0098F8_NUM_PIPES(info->gb_addr_config) +
-                                    G_0098F8_NUM_SHADER_ENGINES_GFX9(info->gb_addr_config), 8);
-      unsigned bank_xor_bits =  MIN2(G_0098F8_NUM_BANKS(info->gb_addr_config), 8 - pipe_xor_bits);
-      unsigned pipes = G_0098F8_NUM_PIPES(info->gb_addr_config);
-      unsigned rb = G_0098F8_NUM_RB_PER_SE(info->gb_addr_config) +
-                    G_0098F8_NUM_SHADER_ENGINES_GFX9(info->gb_addr_config);
-
-      uint64_t common_dcc = AMD_FMT_MOD_SET(DCC, 1) |
-                            AMD_FMT_MOD_SET(DCC_INDEPENDENT_64B, 1) |
-                            AMD_FMT_MOD_SET(DCC_MAX_COMPRESSED_BLOCK, AMD_FMT_MOD_DCC_BLOCK_64B) |
-                            AMD_FMT_MOD_SET(DCC_CONSTANT_ENCODE, info->has_dcc_constant_encode) |
-                            AMD_FMT_MOD_SET(PIPE_XOR_BITS, pipe_xor_bits) |
-                            AMD_FMT_MOD_SET(BANK_XOR_BITS, bank_xor_bits);
+      unsigned pipe_xor_bits_64k = MIN2(pipes + se, block_size_bits_64k - 8);
+      unsigned bank_xor_bits_64k = MIN2(banks, block_size_bits_64k - 8 - pipe_xor_bits_64k);
+
+      unsigned rb = rb_per_se + se;
+
+      uint64_t common_dcc =
+         AMD_FMT_MOD_SET(DCC, 1) |
+         AMD_FMT_MOD_SET(DCC_INDEPENDENT_64B, 1) |
+         AMD_FMT_MOD_SET(DCC_MAX_COMPRESSED_BLOCK, AMD_FMT_MOD_DCC_BLOCK_64B) |
+         AMD_FMT_MOD_SET(DCC_CONSTANT_ENCODE, info->has_dcc_constant_encode);
+
+      uint64_t dcc_64k =
+         common_dcc |
+         AMD_FMT_MOD_SET(PIPE_XOR_BITS, pipe_xor_bits_64k) |
+         AMD_FMT_MOD_SET(BANK_XOR_BITS, bank_xor_bits_64k);
 
       ADD_MOD(AMD_FMT_MOD |
               AMD_FMT_MOD_SET(TILE, AMD_FMT_MOD_TILE_GFX9_64K_D_X) |
               AMD_FMT_MOD_SET(TILE_VERSION, AMD_FMT_MOD_TILE_VER_GFX9) |
               AMD_FMT_MOD_SET(DCC_PIPE_ALIGN, 1) |
-              common_dcc |
+              dcc_64k |
               AMD_FMT_MOD_SET(PIPE, pipes) |
               AMD_FMT_MOD_SET(RB, rb))
 
@@ -353,7 +364,7 @@ bool ac_get_supported_modifiers(const struct radeon_info *info,
               AMD_FMT_MOD_SET(TILE, AMD_FMT_MOD_TILE_GFX9_64K_S_X) |
               AMD_FMT_MOD_SET(TILE_VERSION, AMD_FMT_MOD_TILE_VER_GFX9) |
               AMD_FMT_MOD_SET(DCC_PIPE_ALIGN, 1) |
-              common_dcc |
+              dcc_64k |
               AMD_FMT_MOD_SET(PIPE, pipes) |
               AMD_FMT_MOD_SET(RB, rb))
 
@@ -362,7 +373,7 @@ bool ac_get_supported_modifiers(const struct radeon_info *info,
             ADD_MOD(AMD_FMT_MOD |
                     AMD_FMT_MOD_SET(TILE, AMD_FMT_MOD_TILE_GFX9_64K_S_X) |
                     AMD_FMT_MOD_SET(TILE_VERSION, AMD_FMT_MOD_TILE_VER_GFX9) |
-                    common_dcc);
+                    dcc_64k);
          }
 
 
@@ -370,7 +381,7 @@ bool ac_get_supported_modifiers(const struct radeon_info *info,
                  AMD_FMT_MOD_SET(TILE, AMD_FMT_MOD_TILE_GFX9_64K_S_X) |
                  AMD_FMT_MOD_SET(TILE_VERSION, AMD_FMT_MOD_TILE_VER_GFX9) |
                  AMD_FMT_MOD_SET(DCC_RETILE, 1) |
-                 common_dcc |
+                 dcc_64k |
                  AMD_FMT_MOD_SET(PIPE, pipes) |
                  AMD_FMT_MOD_SET(RB, rb))
       }
@@ -379,14 +390,14 @@ bool ac_get_supported_modifiers(const struct radeon_info *info,
       ADD_MOD(AMD_FMT_MOD |
               AMD_FMT_MOD_SET(TILE, AMD_FMT_MOD_TILE_GFX9_64K_D_X) |
               AMD_FMT_MOD_SET(TILE_VERSION, AMD_FMT_MOD_TILE_VER_GFX9) |
-              AMD_FMT_MOD_SET(PIPE_XOR_BITS, pipe_xor_bits) |
-              AMD_FMT_MOD_SET(BANK_XOR_BITS, bank_xor_bits));
+              AMD_FMT_MOD_SET(PIPE_XOR_BITS, pipe_xor_bits_64k) |
+              AMD_FMT_MOD_SET(BANK_XOR_BITS, bank_xor_bits_64k));
 
       ADD_MOD(AMD_FMT_MOD |
               AMD_FMT_MOD_SET(TILE, AMD_FMT_MOD_TILE_GFX9_64K_S_X) |
               AMD_FMT_MOD_SET(TILE_VERSION, AMD_FMT_MOD_TILE_VER_GFX9) |
-              AMD_FMT_MOD_SET(PIPE_XOR_BITS, pipe_xor_bits) |
-              AMD_FMT_MOD_SET(BANK_XOR_BITS, bank_xor_bits));
+              AMD_FMT_MOD_SET(PIPE_XOR_BITS, pipe_xor_bits_64k) |
+              AMD_FMT_MOD_SET(BANK_XOR_BITS, bank_xor_bits_64k));
 
       ADD_MOD(AMD_FMT_MOD |
               AMD_FMT_MOD_SET(TILE, AMD_FMT_MOD_TILE_GFX9_64K_D) |
@@ -402,16 +413,18 @@ bool ac_get_supported_modifiers(const struct radeon_info *info,
    case GFX10:
    case GFX10_3: {
       bool rbplus = info->gfx_level >= GFX10_3;
-      unsigned pipe_xor_bits = G_0098F8_NUM_PIPES(info->gb_addr_config);
-      unsigned pkrs = rbplus ? G_0098F8_NUM_PKRS(info->gb_addr_config) : 0;
+
+      unsigned pipe_xor_bits_64k = MIN2(pipes, block_size_bits_64k - 8);
+      unsigned pkrs_64k =
+         rbplus ? MIN2(pkrs, block_size_bits_64k - 8 - pipe_xor_bits_64k) : 0;
 
       unsigned version = rbplus ? AMD_FMT_MOD_TILE_VER_GFX10_RBPLUS : AMD_FMT_MOD_TILE_VER_GFX10;
       uint64_t common_dcc = AMD_FMT_MOD_SET(TILE_VERSION, version) |
                             AMD_FMT_MOD_SET(TILE, AMD_FMT_MOD_TILE_GFX9_64K_R_X) |
                             AMD_FMT_MOD_SET(DCC, 1) |
                             AMD_FMT_MOD_SET(DCC_CONSTANT_ENCODE, 1) |
-                            AMD_FMT_MOD_SET(PIPE_XOR_BITS, pipe_xor_bits) |
-                            AMD_FMT_MOD_SET(PACKERS, pkrs);
+                            AMD_FMT_MOD_SET(PIPE_XOR_BITS, pipe_xor_bits_64k) |
+                            AMD_FMT_MOD_SET(PACKERS, pkrs_64k);
 
       ADD_MOD(AMD_FMT_MOD | common_dcc |
               AMD_FMT_MOD_SET(DCC_PIPE_ALIGN, 1) |
@@ -434,8 +447,8 @@ bool ac_get_supported_modifiers(const struct radeon_info *info,
       ADD_MOD(AMD_FMT_MOD |
               AMD_FMT_MOD_SET(TILE_VERSION, version) |
               AMD_FMT_MOD_SET(TILE, AMD_FMT_MOD_TILE_GFX9_64K_R_X) |
-              AMD_FMT_MOD_SET(PIPE_XOR_BITS, pipe_xor_bits) |
-              AMD_FMT_MOD_SET(PACKERS, pkrs))
+              AMD_FMT_MOD_SET(PIPE_XOR_BITS, pipe_xor_bits_64k) |
+              AMD_FMT_MOD_SET(PACKERS, pkrs_64k))
 
       if (util_format_get_blocksizebits(format) != 32) {
          ADD_MOD(AMD_FMT_MOD |
@@ -453,9 +466,9 @@ bool ac_get_supported_modifiers(const struct radeon_info *info,
    case GFX11:
    case GFX11_5: {
       /* GFX11 has new microblock organization. No S modes for 2D. */
-      unsigned pipe_xor_bits = G_0098F8_NUM_PIPES(info->gb_addr_config);
-      unsigned pkrs = G_0098F8_NUM_PKRS(info->gb_addr_config);
-      unsigned num_pipes = 1 << pipe_xor_bits;
+      unsigned pipe_xor_bits_64k = MIN2(pipes, block_size_bits_64k - 8);
+      unsigned pipe_xor_bits_256k = MIN2(pipes, block_size_bits_256k - 8);
+      unsigned num_pipes = 1 << pipes;
 
       /* R_X swizzle modes are the best for rendering and DCC requires them. */
       for (unsigned i = 0; i < 2; i++) {
@@ -471,6 +484,9 @@ bool ac_get_supported_modifiers(const struct radeon_info *info,
          if (!info->has_dedicated_vram && swizzle_r_x == AMD_FMT_MOD_TILE_GFX11_256K_R_X)
             continue;
 
+         unsigned pipe_xor_bits = swizzle_r_x == AMD_FMT_MOD_TILE_GFX11_256K_R_X ?
+            pipe_xor_bits_256k : pipe_xor_bits_64k;
+
          uint64_t modifier_r_x = AMD_FMT_MOD |
                                  AMD_FMT_MOD_SET(TILE_VERSION, AMD_FMT_MOD_TILE_VER_GFX11) |
                                  AMD_FMT_MOD_SET(TILE, swizzle_r_x) |
-- 
GitLab


From bad5330ea731432c8140f8b40889dcdc4be86f7a Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Mon, 21 Oct 2024 16:29:55 +0800
Subject: [PATCH 07/11] ac/surface: add radeonsi exported modifiers to
 supported list
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

radeonsi will export texture with these modifiers.

piglit tests:
spec@ext_image_dma_buf_import@ext_image_dma_buf_import-export-tex
spec@ext_image_dma_buf_import@ext_image_dma_buf_import-tex-modifier

Acked-by: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
Reviewed-by: Marek Olšák <marek.olsak@amd.com>
Acked-by: Daniel Stone <daniels@collabora.com>
---
 src/amd/common/ac_drm_fourcc.h |  1 +
 src/amd/common/ac_surface.c    | 45 +++++++++++++++++++++++++++++++++-
 2 files changed, 45 insertions(+), 1 deletion(-)

diff --git a/src/amd/common/ac_drm_fourcc.h b/src/amd/common/ac_drm_fourcc.h
index ec453de91c936..9ef140645a7ce 100644
--- a/src/amd/common/ac_drm_fourcc.h
+++ b/src/amd/common/ac_drm_fourcc.h
@@ -26,6 +26,7 @@ typedef uint64_t __u64;
 #define AMD_FMT_MOD_TILE_VER_GFX12 5
 #define AMD_FMT_MOD_TILE_GFX9_64K_S 9
 #define AMD_FMT_MOD_TILE_GFX9_64K_D 10
+#define AMD_FMT_MOD_TILE_GFX9_4K_D_X 22
 #define AMD_FMT_MOD_TILE_GFX9_64K_S_X 25
 #define AMD_FMT_MOD_TILE_GFX9_64K_D_X 26
 #define AMD_FMT_MOD_TILE_GFX9_64K_R_X 27
diff --git a/src/amd/common/ac_surface.c b/src/amd/common/ac_surface.c
index ceeb7b921f348..efa6e400cd345 100644
--- a/src/amd/common/ac_surface.c
+++ b/src/amd/common/ac_surface.c
@@ -264,7 +264,7 @@ bool ac_is_modifier_supported(const struct radeon_info *info,
    uint32_t allowed_swizzles = 0xFFFFFFFF;
    switch(info->gfx_level) {
    case GFX9:
-      allowed_swizzles = ac_modifier_has_dcc(modifier) ? 0x06000000 : 0x06660660;
+      allowed_swizzles = ac_modifier_has_dcc(modifier) ? 0x06400000 : 0x06660660;
       break;
    case GFX10:
    case GFX10_3:
@@ -322,6 +322,7 @@ bool ac_get_supported_modifiers(const struct radeon_info *info,
       ++current_mod;                                         \
    }
 
+   const unsigned block_size_bits_4k = 12;
    const unsigned block_size_bits_64k = 16;
    const unsigned block_size_bits_256k = 18;
 
@@ -336,6 +337,9 @@ bool ac_get_supported_modifiers(const struct radeon_info *info,
     * in the list. */
    switch (info->gfx_level) {
    case GFX9: {
+      unsigned pipe_xor_bits_4k = MIN2(pipes + se, block_size_bits_4k - 8);
+      unsigned bank_xor_bits_4k = MIN2(banks, block_size_bits_4k - 8 - pipe_xor_bits_4k);
+
       unsigned pipe_xor_bits_64k = MIN2(pipes + se, block_size_bits_64k - 8);
       unsigned bank_xor_bits_64k = MIN2(banks, block_size_bits_64k - 8 - pipe_xor_bits_64k);
 
@@ -352,6 +356,11 @@ bool ac_get_supported_modifiers(const struct radeon_info *info,
          AMD_FMT_MOD_SET(PIPE_XOR_BITS, pipe_xor_bits_64k) |
          AMD_FMT_MOD_SET(BANK_XOR_BITS, bank_xor_bits_64k);
 
+      uint64_t dcc_4k =
+         common_dcc |
+         AMD_FMT_MOD_SET(PIPE_XOR_BITS, pipe_xor_bits_4k) |
+         AMD_FMT_MOD_SET(BANK_XOR_BITS, bank_xor_bits_4k);
+
       ADD_MOD(AMD_FMT_MOD |
               AMD_FMT_MOD_SET(TILE, AMD_FMT_MOD_TILE_GFX9_64K_D_X) |
               AMD_FMT_MOD_SET(TILE_VERSION, AMD_FMT_MOD_TILE_VER_GFX9) |
@@ -386,6 +395,14 @@ bool ac_get_supported_modifiers(const struct radeon_info *info,
                  AMD_FMT_MOD_SET(RB, rb))
       }
 
+      /* OpenGL exported modifier for small textures. */
+      ADD_MOD(AMD_FMT_MOD |
+              AMD_FMT_MOD_SET(TILE, AMD_FMT_MOD_TILE_GFX9_4K_D_X) |
+              AMD_FMT_MOD_SET(TILE_VERSION, AMD_FMT_MOD_TILE_VER_GFX9) |
+              AMD_FMT_MOD_SET(DCC_PIPE_ALIGN, 1) |
+              dcc_4k |
+              AMD_FMT_MOD_SET(PIPE, pipes) |
+              AMD_FMT_MOD_SET(RB, rb))
 
       ADD_MOD(AMD_FMT_MOD |
               AMD_FMT_MOD_SET(TILE, AMD_FMT_MOD_TILE_GFX9_64K_D_X) |
@@ -399,6 +416,13 @@ bool ac_get_supported_modifiers(const struct radeon_info *info,
               AMD_FMT_MOD_SET(PIPE_XOR_BITS, pipe_xor_bits_64k) |
               AMD_FMT_MOD_SET(BANK_XOR_BITS, bank_xor_bits_64k));
 
+      /* OpenGL exported modifier for small textures. */
+      ADD_MOD(AMD_FMT_MOD |
+              AMD_FMT_MOD_SET(TILE, AMD_FMT_MOD_TILE_GFX9_4K_D_X) |
+              AMD_FMT_MOD_SET(TILE_VERSION, AMD_FMT_MOD_TILE_VER_GFX9) |
+              AMD_FMT_MOD_SET(PIPE_XOR_BITS, pipe_xor_bits_4k) |
+              AMD_FMT_MOD_SET(BANK_XOR_BITS, bank_xor_bits_4k))
+
       ADD_MOD(AMD_FMT_MOD |
               AMD_FMT_MOD_SET(TILE, AMD_FMT_MOD_TILE_GFX9_64K_D) |
               AMD_FMT_MOD_SET(TILE_VERSION, AMD_FMT_MOD_TILE_VER_GFX9));
@@ -414,6 +438,10 @@ bool ac_get_supported_modifiers(const struct radeon_info *info,
    case GFX10_3: {
       bool rbplus = info->gfx_level >= GFX10_3;
 
+      unsigned pipe_xor_bits_4k = MIN2(pipes, block_size_bits_4k - 8);
+      unsigned pkrs_4k =
+         rbplus ? MIN2(pkrs, block_size_bits_4k - 8 - pipe_xor_bits_4k) : 0;
+
       unsigned pipe_xor_bits_64k = MIN2(pipes, block_size_bits_64k - 8);
       unsigned pkrs_64k =
          rbplus ? MIN2(pkrs, block_size_bits_64k - 8 - pipe_xor_bits_64k) : 0;
@@ -450,6 +478,13 @@ bool ac_get_supported_modifiers(const struct radeon_info *info,
               AMD_FMT_MOD_SET(PIPE_XOR_BITS, pipe_xor_bits_64k) |
               AMD_FMT_MOD_SET(PACKERS, pkrs_64k))
 
+      /* OpenGL exported modifier for small textures. */
+      ADD_MOD(AMD_FMT_MOD |
+              AMD_FMT_MOD_SET(TILE_VERSION, version) |
+              AMD_FMT_MOD_SET(TILE, AMD_FMT_MOD_TILE_GFX9_4K_D_X) |
+              AMD_FMT_MOD_SET(PIPE_XOR_BITS, pipe_xor_bits_4k) |
+              AMD_FMT_MOD_SET(PACKERS, pkrs_4k))
+
       if (util_format_get_blocksizebits(format) != 32) {
          ADD_MOD(AMD_FMT_MOD |
                  AMD_FMT_MOD_SET(TILE, AMD_FMT_MOD_TILE_GFX9_64K_D) |
@@ -466,6 +501,7 @@ bool ac_get_supported_modifiers(const struct radeon_info *info,
    case GFX11:
    case GFX11_5: {
       /* GFX11 has new microblock organization. No S modes for 2D. */
+      unsigned pipe_xor_bits_4k = MIN2(pipes, block_size_bits_4k - 8);
       unsigned pipe_xor_bits_64k = MIN2(pipes, block_size_bits_64k - 8);
       unsigned pipe_xor_bits_256k = MIN2(pipes, block_size_bits_256k - 8);
       unsigned num_pipes = 1 << pipes;
@@ -538,6 +574,13 @@ bool ac_get_supported_modifiers(const struct radeon_info *info,
          ADD_MOD(modifier_r_x)
       }
 
+      /* OpenGL exported modifier for small textures. */
+      ADD_MOD(AMD_FMT_MOD |
+              AMD_FMT_MOD_SET(TILE_VERSION, AMD_FMT_MOD_TILE_VER_GFX11) |
+              AMD_FMT_MOD_SET(TILE, AMD_FMT_MOD_TILE_GFX9_4K_D_X) |
+              AMD_FMT_MOD_SET(PIPE_XOR_BITS, pipe_xor_bits_4k) |
+              AMD_FMT_MOD_SET(PACKERS, pkrs))
+
       /* Add one that is compatible with other gfx11 chips. */
       ADD_MOD(AMD_FMT_MOD |
               AMD_FMT_MOD_SET(TILE_VERSION, AMD_FMT_MOD_TILE_VER_GFX11) |
-- 
GitLab


From 8296ceff965121c5b0cc43242bd40952407ffaf2 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Tue, 15 Oct 2024 14:43:14 +0800
Subject: [PATCH 08/11] ac/surface: add ac_compute_surface_modifier
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Used by radeonsi to export existing texture modifier.

Acked-by: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
Reviewed-by: Marek Olšák <marek.olsak@amd.com>
Acked-by: Daniel Stone <daniels@collabora.com>
---
 src/amd/common/ac_surface.c | 143 ++++++++++++++++++++++++++++++++++++
 src/amd/common/ac_surface.h |   3 +
 2 files changed, 146 insertions(+)

diff --git a/src/amd/common/ac_surface.c b/src/amd/common/ac_surface.c
index efa6e400cd345..66fd7069b61ea 100644
--- a/src/amd/common/ac_surface.c
+++ b/src/amd/common/ac_surface.c
@@ -3401,6 +3401,149 @@ static bool gfx12_compute_surface(struct ac_addrlib *addrlib, const struct radeo
    return true;
 }
 
+static void gfx9_compute_surface_modifier(const struct radeon_info *info,
+                                          struct radeon_surf *surf)
+{
+   unsigned block_size_bits = 0;
+   switch (surf->u.gfx9.swizzle_mode >> 2) {
+   case 0: /* 256B */
+      block_size_bits = 8;
+      break;
+   case 1: /* 4KiB */
+   case 5: /* 4KiB _X */
+      block_size_bits = 12;
+      break;
+   case 2: /* 64KiB */
+   case 4: /* 64 KiB _T */
+   case 6: /* 64 KiB _X */
+      block_size_bits = 16;
+      break;
+   case 7: /* 256 KiB */
+      block_size_bits = 18;
+      break;
+   default:
+      unreachable("invalid tile mode");
+   }
+
+   bool is_xor = surf->u.gfx9.swizzle_mode >= 16;
+   if (is_xor) {
+      if (info->gfx_level == GFX9) {
+         unsigned pipe_xor_bits =
+            MIN2(G_0098F8_NUM_PIPES(info->gb_addr_config) +
+                 G_0098F8_NUM_SHADER_ENGINES_GFX9(info->gb_addr_config),
+                 block_size_bits - 8);
+
+         unsigned bank_xor_bits =
+            MIN2(G_0098F8_NUM_BANKS(info->gb_addr_config),
+                 block_size_bits - 8 - pipe_xor_bits);
+
+         surf->modifier |=
+            AMD_FMT_MOD_SET(PIPE_XOR_BITS, pipe_xor_bits) |
+            AMD_FMT_MOD_SET(BANK_XOR_BITS, bank_xor_bits);
+      } else {
+         unsigned pipe_xor_bits =
+            MIN2(G_0098F8_NUM_PIPES(info->gb_addr_config), block_size_bits - 8);
+
+         unsigned pkrs = 0;
+         if (info->gfx_level == GFX10_3) {
+            pkrs = MIN2(G_0098F8_NUM_PKRS(info->gb_addr_config),
+                        block_size_bits - 8 - pipe_xor_bits);
+         } else if (info->gfx_level == GFX11) {
+            pkrs = G_0098F8_NUM_PKRS(info->gb_addr_config);
+         }
+
+         surf->modifier |=
+            AMD_FMT_MOD_SET(PIPE_XOR_BITS, pipe_xor_bits) |
+            AMD_FMT_MOD_SET(PACKERS, pkrs);
+      }
+   }
+
+   bool is_dcc = !!surf->meta_offset;
+   if (is_dcc) {
+      surf->modifier |=
+         AMD_FMT_MOD_SET(DCC, 1) |
+         AMD_FMT_MOD_SET(DCC_INDEPENDENT_64B, surf->u.gfx9.color.dcc.independent_64B_blocks) |
+         AMD_FMT_MOD_SET(DCC_INDEPENDENT_128B, surf->u.gfx9.color.dcc.independent_128B_blocks) |
+         AMD_FMT_MOD_SET(DCC_MAX_COMPRESSED_BLOCK, surf->u.gfx9.color.dcc.max_compressed_block_size) |
+         AMD_FMT_MOD_SET(DCC_PIPE_ALIGN, surf->u.gfx9.color.dcc.pipe_aligned);
+
+      if (info->gfx_level < GFX11)
+         surf->modifier |= AMD_FMT_MOD_SET(DCC_CONSTANT_ENCODE, info->has_dcc_constant_encode);
+
+      if (surf->display_dcc_offset)
+         surf->modifier |= AMD_FMT_MOD_SET(DCC_RETILE, 1);
+
+      if (info->gfx_level == GFX9 &&
+          (surf->u.gfx9.color.dcc.pipe_aligned || surf->display_dcc_offset)) {
+         unsigned pipes = G_0098F8_NUM_PIPES(info->gb_addr_config);
+         unsigned rb = G_0098F8_NUM_RB_PER_SE(info->gb_addr_config) +
+            G_0098F8_NUM_SHADER_ENGINES_GFX9(info->gb_addr_config);
+
+         surf->modifier |= AMD_FMT_MOD_SET(PIPE, pipes) | AMD_FMT_MOD_SET(RB, rb);
+      }
+   }
+}
+
+static void gfx12_compute_surface_modifier(struct radeon_surf *surf)
+{
+   if (surf->u.gfx9.gfx12_enable_dcc) {
+      surf->modifier |=
+         AMD_FMT_MOD_SET(DCC, 1) |
+         AMD_FMT_MOD_SET(DCC_MAX_COMPRESSED_BLOCK, surf->u.gfx9.color.dcc.max_compressed_block_size);
+   }
+}
+
+void ac_compute_surface_modifier(const struct radeon_info *info,
+                                 struct radeon_surf *surf,
+                                 unsigned samples)
+{
+   if (info->gfx_level < GFX9 || surf->modifier != DRM_FORMAT_MOD_INVALID)
+      return;
+
+   /* skip depth/stencil, PRT, VRS, 1D/3D and MSAA surface */
+   if (surf->flags & (RADEON_SURF_Z_OR_SBUFFER | RADEON_SURF_PRT | RADEON_SURF_VRS_RATE) ||
+       surf->u.gfx9.resource_type != RADEON_RESOURCE_2D ||
+       samples > 1)
+      return;
+
+   if (surf->is_linear) {
+      surf->modifier = DRM_FORMAT_MOD_LINEAR;
+      return;
+   }
+
+   unsigned version = 0;
+   switch (info->gfx_level) {
+   case GFX9:
+      version = AMD_FMT_MOD_TILE_VER_GFX9;
+      break;
+   case GFX10:
+      version = AMD_FMT_MOD_TILE_VER_GFX10;
+      break;
+   case GFX10_3:
+      version = AMD_FMT_MOD_TILE_VER_GFX10_RBPLUS;
+      break;
+   case GFX11:
+   case GFX11_5:
+      version = AMD_FMT_MOD_TILE_VER_GFX11;
+      break;
+   case GFX12:
+      version = AMD_FMT_MOD_TILE_VER_GFX12;
+      break;
+   default:
+      unreachable("invalid gfx level");
+   }
+
+   surf->modifier =
+      AMD_FMT_MOD |
+      AMD_FMT_MOD_SET(TILE_VERSION, version) |
+      AMD_FMT_MOD_SET(TILE, surf->u.gfx9.swizzle_mode);
+
+   if (info->gfx_level >= GFX12)
+      gfx12_compute_surface_modifier(surf);
+   else
+      gfx9_compute_surface_modifier(info, surf);
+}
+
 int ac_compute_surface(struct ac_addrlib *addrlib, const struct radeon_info *info,
                        const struct ac_surf_config *config, enum radeon_surf_mode mode,
                        struct radeon_surf *surf)
diff --git a/src/amd/common/ac_surface.h b/src/amd/common/ac_surface.h
index d960a44c499ee..76d1d423ba99e 100644
--- a/src/amd/common/ac_surface.h
+++ b/src/amd/common/ac_surface.h
@@ -515,6 +515,9 @@ void ac_surface_print_info(FILE *out, const struct radeon_info *info,
 bool ac_surface_supports_dcc_image_stores(enum amd_gfx_level gfx_level,
                                           const struct radeon_surf *surf);
 
+void ac_compute_surface_modifier(const struct radeon_info *info, struct radeon_surf *surf,
+                                 unsigned samples);
+
 #ifdef AC_SURFACE_INCLUDE_NIR
 nir_def *ac_nir_dcc_addr_from_coord(nir_builder *b, const struct radeon_info *info,
                                     unsigned bpe, const struct gfx9_meta_equation *equation,
-- 
GitLab


From fa05b1de3c8c6228caaefb2a63b65e8dd73fdd05 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Sat, 14 Sep 2024 15:07:15 +0800
Subject: [PATCH 09/11] gallium: add PIPE_RESOURCE_PARAM_DISJOINT_PLANES
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

To query if a DRI_IMAGE has separate plane buffer handle.

radeonsi's DCC compressed dri image has multiple planes
(compressed data and metadata). But they share the same
buffer with different offsets, so we only need one buffer
handle for them.

This attribute is used to distinguish single buffer multi
plane image from multi buffer multi plane image.

Acked-by: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
Reviewed-by: Marek Olšák <marek.olsak@amd.com>
Acked-by: Daniel Stone <daniels@collabora.com>
---
 src/gallium/drivers/radeonsi/si_texture.c | 6 ++++++
 src/gallium/drivers/zink/zink_resource.c  | 6 ++++++
 src/gallium/frontends/dri/dri2.c          | 4 ++++
 src/gallium/include/mesa_interface.h      | 2 ++
 src/gallium/include/pipe/p_defines.h      | 2 ++
 5 files changed, 20 insertions(+)

diff --git a/src/gallium/drivers/radeonsi/si_texture.c b/src/gallium/drivers/radeonsi/si_texture.c
index c5d7357ab2859..bc4c3f8f44375 100644
--- a/src/gallium/drivers/radeonsi/si_texture.c
+++ b/src/gallium/drivers/radeonsi/si_texture.c
@@ -720,6 +720,12 @@ static bool si_resource_get_param(struct pipe_screen *screen, struct pipe_contex
       return true;
    case PIPE_RESOURCE_PARAM_LAYER_STRIDE:
       break;
+   case PIPE_RESOURCE_PARAM_DISJOINT_PLANES:
+      if (resource->target == PIPE_BUFFER)
+         *value = false;
+      else
+         *value = tex->num_planes > 1;
+      break;
    }
    return false;
 }
diff --git a/src/gallium/drivers/zink/zink_resource.c b/src/gallium/drivers/zink/zink_resource.c
index de46d53e5506c..b97826b9e4b45 100644
--- a/src/gallium/drivers/zink/zink_resource.c
+++ b/src/gallium/drivers/zink/zink_resource.c
@@ -1893,6 +1893,12 @@ zink_resource_get_param(struct pipe_screen *pscreen, struct pipe_context *pctx,
       return false;
 #endif
    }
+   case PIPE_RESOURCE_PARAM_DISJOINT_PLANES:
+      if (pres->target == PIPE_BUFFER)
+         *value = false;
+      else
+         *value = util_format_get_num_planes(pres->format) > 1;
+      break;
    }
    return true;
 }
diff --git a/src/gallium/frontends/dri/dri2.c b/src/gallium/frontends/dri/dri2.c
index d7d0b177a7c98..0f1b648043a46 100644
--- a/src/gallium/frontends/dri/dri2.c
+++ b/src/gallium/frontends/dri/dri2.c
@@ -1323,6 +1323,9 @@ dri2_query_image_by_resource_param(struct dri_image *image, int attrib, int *val
    case __DRI_IMAGE_ATTRIB_FD:
       param = PIPE_RESOURCE_PARAM_HANDLE_TYPE_FD;
       break;
+   case __DRI_IMAGE_ATTRIB_DISJOINT_PLANES:
+      param = PIPE_RESOURCE_PARAM_DISJOINT_PLANES;
+      break;
    default:
       return false;
    }
@@ -1336,6 +1339,7 @@ dri2_query_image_by_resource_param(struct dri_image *image, int attrib, int *val
    case __DRI_IMAGE_ATTRIB_STRIDE:
    case __DRI_IMAGE_ATTRIB_OFFSET:
    case __DRI_IMAGE_ATTRIB_NUM_PLANES:
+   case __DRI_IMAGE_ATTRIB_DISJOINT_PLANES:
       if (res_param > INT_MAX)
          return false;
       *value = (int)res_param;
diff --git a/src/gallium/include/mesa_interface.h b/src/gallium/include/mesa_interface.h
index 7e7432d1edf54..7e90fe8b2ca3d 100644
--- a/src/gallium/include/mesa_interface.h
+++ b/src/gallium/include/mesa_interface.h
@@ -848,6 +848,8 @@ typedef struct {
 #define __DRI_IMAGE_ATTRIB_MODIFIER_LOWER 0x200B /* available in versions 14 */
 #define __DRI_IMAGE_ATTRIB_MODIFIER_UPPER 0x200C /* available in versions 14 */
 #define __DRI_IMAGE_ATTRIB_COMPRESSION_RATE 0x200D /* available in versions 22 */
+/* If DRI IMAGE has separate plane buffers. */
+#define __DRI_IMAGE_ATTRIB_DISJOINT_PLANES 0x200E
 
 enum __DRIYUVColorSpace {
    __DRI_YUV_COLOR_SPACE_UNDEFINED = 0,
diff --git a/src/gallium/include/pipe/p_defines.h b/src/gallium/include/pipe/p_defines.h
index 68f74d46c9bad..a6a33a720fbfd 100644
--- a/src/gallium/include/pipe/p_defines.h
+++ b/src/gallium/include/pipe/p_defines.h
@@ -1128,6 +1128,8 @@ enum pipe_resource_param
    PIPE_RESOURCE_PARAM_HANDLE_TYPE_KMS,
    PIPE_RESOURCE_PARAM_HANDLE_TYPE_FD,
    PIPE_RESOURCE_PARAM_LAYER_STRIDE,
+   /* If texture/image has separate plane buffers. */
+   PIPE_RESOURCE_PARAM_DISJOINT_PLANES,
 };
 
 /**
-- 
GitLab


From 7e4bd3a7a901425ec85e23d0397325b506a6df86 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Wed, 18 Sep 2024 14:57:59 +0800
Subject: [PATCH 10/11] egl: refine dma buf export to support multi plane
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Acked-by: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
Reviewed-by: Marek Olšák <marek.olsak@amd.com>
Acked-by: Daniel Stone <daniels@collabora.com>
---
 src/egl/drivers/dri2/egl_dri2.c | 55 ++++++++++++++++++---------------
 1 file changed, 30 insertions(+), 25 deletions(-)

diff --git a/src/egl/drivers/dri2/egl_dri2.c b/src/egl/drivers/dri2/egl_dri2.c
index 0819b7c66a018..6699ae23fe47e 100644
--- a/src/egl/drivers/dri2/egl_dri2.c
+++ b/src/egl/drivers/dri2/egl_dri2.c
@@ -2742,41 +2742,46 @@ dri2_export_dma_buf_image_mesa(_EGLDisplay *disp, _EGLImage *img, int *fds,
 {
    struct dri2_egl_display *dri2_dpy = dri2_egl_display_lock(disp);
    struct dri2_egl_image *dri2_img = dri2_egl_image(img);
-   EGLint nplanes;
 
    if (!dri2_can_export_dma_buf_image(disp, img)) {
       mtx_unlock(&dri2_dpy->lock);
       return EGL_FALSE;
    }
 
-   /* EGL_MESA_image_dma_buf_export spec says:
-    *    "If the number of fds is less than the number of planes, then
-    *    subsequent fd slots should contain -1."
-    */
-   if (fds) {
-      /* Query nplanes so that we know how big the given array is. */
-      dri2_query_image(dri2_img->dri_image,
-                                  __DRI_IMAGE_ATTRIB_NUM_PLANES, &nplanes);
-      memset(fds, -1, nplanes * sizeof(int));
+   int nplanes;
+   /* Query nplanes so that we know how big the given array is. */
+   dri2_query_image(dri2_img->dri_image, __DRI_IMAGE_ATTRIB_NUM_PLANES, &nplanes);
+
+   int is_disjoint = true;
+   if (nplanes > 1) {
+      dri2_query_image(dri2_img->dri_image, __DRI_IMAGE_ATTRIB_DISJOINT_PLANES,
+                       &is_disjoint);
    }
 
-   /* rework later to provide multiple fds/strides/offsets */
-   if (fds)
-      dri2_query_image(dri2_img->dri_image, __DRI_IMAGE_ATTRIB_FD,
-                                  fds);
+   for (int i = 0; i < nplanes; i++) {
+      struct dri_image *image = dri2_img->dri_image;
+      if (i)
+         image = dri2_from_planar(image, i, NULL);
 
-   if (strides)
-      dri2_query_image(dri2_img->dri_image,
-                                  __DRI_IMAGE_ATTRIB_STRIDE, strides);
+      if (fds) {
+         /* EGL_MESA_image_dma_buf_export spec says:
+          *    "If the number of fds is less than the number of planes, then
+          *    subsequent fd slots should contain -1."
+          */
+         if (i == 0 || is_disjoint)
+            dri2_query_image(image, __DRI_IMAGE_ATTRIB_FD, &fds[i]);
+         else
+            fds[i] = -1;
+      }
 
-   if (offsets) {
-      int img_offset;
-      bool ret = dri2_query_image(
-         dri2_img->dri_image, __DRI_IMAGE_ATTRIB_OFFSET, &img_offset);
-      if (ret)
-         offsets[0] = img_offset;
-      else
-         offsets[0] = 0;
+      if (strides && !dri2_query_image(image, __DRI_IMAGE_ATTRIB_STRIDE, &strides[i]))
+         strides[i] = 0;
+
+      if (offsets && !dri2_query_image(image, __DRI_IMAGE_ATTRIB_OFFSET, &offsets[i]))
+         offsets[i] = 0;
+
+      if (i)
+         dri2_destroy_image(image);
    }
 
    mtx_unlock(&dri2_dpy->lock);
-- 
GitLab


From 0efef99d52c794eb0f07f0467ef78a811f4109fe Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Tue, 15 Oct 2024 14:48:38 +0800
Subject: [PATCH 11/11] radeonsi: really support eglExportDMABUFImageQueryMESA
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Now it should return explicite modifier and plane number.

Acked-by: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
Reviewed-by: Marek Olšák <marek.olsak@amd.com>
Acked-by: Daniel Stone <daniels@collabora.com>
---
 src/gallium/drivers/radeonsi/si_texture.c | 8 ++++++++
 1 file changed, 8 insertions(+)

diff --git a/src/gallium/drivers/radeonsi/si_texture.c b/src/gallium/drivers/radeonsi/si_texture.c
index bc4c3f8f44375..2266d714c143a 100644
--- a/src/gallium/drivers/radeonsi/si_texture.c
+++ b/src/gallium/drivers/radeonsi/si_texture.c
@@ -667,6 +667,14 @@ static bool si_resource_get_param(struct pipe_screen *screen, struct pipe_contex
    struct si_texture *tex = (struct si_texture *)resource;
    struct winsys_handle whandle;
 
+   /* Compute texture modifier when needed.
+    * This allows to return the correct values for the PIPE_RESOURCE_PARAM_NPLANES and
+    * PIPE_RESOURCE_PARAM_MODIFIER queries.
+    */
+   if ((param == PIPE_RESOURCE_PARAM_NPLANES || param == PIPE_RESOURCE_PARAM_MODIFIER) &&
+       resource->target != PIPE_BUFFER)
+         ac_compute_surface_modifier(&sscreen->info, &tex->surface, resource->nr_samples);
+
    switch (param) {
    case PIPE_RESOURCE_PARAM_NPLANES:
       if (resource->target == PIPE_BUFFER)
-- 
GitLab

