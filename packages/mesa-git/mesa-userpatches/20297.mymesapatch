From 708bf37a11782939dd3e08a9821f8a35ca4333ad Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Tue, 13 Dec 2022 11:03:21 -0500
Subject: [PATCH 1/3] ac/llvm: run the LLVM sinking pass because LLVM will stop
 running it

shader-db was run with the sinking pass disabled in LLVM.

58380 shaders in 35438 tests
Totals:
SGPRS: 2730768 -> 2730768 (0.00 %)
VGPRS: 1592932 -> 1592928 (-0.00 %)
Spilled SGPRs: 2687 -> 2687 (0.00 %)
Spilled VGPRs: 551 -> 551 (0.00 %)
Private memory VGPRs: 253 -> 253 (0.00 %)
Scratch size: 700 -> 700 (0.00 %) dwords per thread
Code Size: 61238872 -> 61238868 (-0.00 %) bytes
Max Waves: 849209 -> 849209 (0.00 %)
Outputs: 127090 -> 127090 (0.00 %)
Patch Outputs: 579 -> 579 (0.00 %)

Totals from affected shaders:
SGPRS: 440 -> 440 (0.00 %)
VGPRS: 396 -> 392 (-1.01 %)
Spilled SGPRs: 0 -> 0 (0.00 %)
Spilled VGPRs: 0 -> 0 (0.00 %)
Private memory VGPRs: 0 -> 0 (0.00 %)
Scratch size: 0 -> 0 (0.00 %) dwords per thread
Code Size: 49880 -> 49876 (-0.01 %) bytes
Max Waves: 105 -> 105 (0.00 %)
Outputs: 14 -> 14 (0.00 %)
Patch Outputs: 0 -> 0 (0.00 %)
---
 src/amd/llvm/ac_llvm_build.h    | 2 ++
 src/amd/llvm/ac_llvm_helper.cpp | 8 ++++++++
 src/amd/llvm/ac_llvm_util.c     | 2 ++
 3 files changed, 12 insertions(+)

diff --git a/src/amd/llvm/ac_llvm_build.h b/src/amd/llvm/ac_llvm_build.h
index 823005ebb370..deccc9d585e9 100644
--- a/src/amd/llvm/ac_llvm_build.h
+++ b/src/amd/llvm/ac_llvm_build.h
@@ -577,6 +577,8 @@ LLVMValueRef ac_build_atomic_rmw(struct ac_llvm_context *ctx, LLVMAtomicRMWBinOp
 LLVMValueRef ac_build_atomic_cmp_xchg(struct ac_llvm_context *ctx, LLVMValueRef ptr,
                                       LLVMValueRef cmp, LLVMValueRef val, const char *sync_scope);
 
+void ac_add_sinking_pass(LLVMPassManagerRef PM);
+
 void ac_export_mrt_z(struct ac_llvm_context *ctx, LLVMValueRef depth, LLVMValueRef stencil,
                      LLVMValueRef samplemask, LLVMValueRef mrt0_alpha, bool is_last,
                      struct ac_export_args *args);
diff --git a/src/amd/llvm/ac_llvm_helper.cpp b/src/amd/llvm/ac_llvm_helper.cpp
index 71ed11a283b9..66fdef876a94 100644
--- a/src/amd/llvm/ac_llvm_helper.cpp
+++ b/src/amd/llvm/ac_llvm_helper.cpp
@@ -31,6 +31,7 @@
 #include <llvm/MC/MCSubtargetInfo.h>
 #include <llvm/Support/CommandLine.h>
 #include <llvm/Transforms/IPO.h>
+#include <llvm/Transforms/Scalar.h>
 
 #include <cstring>
 
@@ -45,6 +46,8 @@
 #include "ac_llvm_build.h"
 #include "util/macros.h"
 
+using namespace llvm;
+
 bool ac_is_llvm_processor_supported(LLVMTargetMachineRef tm, const char *processor)
 {
    llvm::TargetMachine *TM = reinterpret_cast<llvm::TargetMachine *>(tm);
@@ -326,3 +329,8 @@ LLVMValueRef ac_build_atomic_cmp_xchg(struct ac_llvm_context *ctx, LLVMValueRef
                                               llvm::AtomicOrdering::SequentiallyConsistent,
                                               llvm::AtomicOrdering::SequentiallyConsistent, SSID));
 }
+
+void ac_add_sinking_pass(LLVMPassManagerRef PM)
+{
+  unwrap(PM)->add(createLoopSinkPass());
+}
diff --git a/src/amd/llvm/ac_llvm_util.c b/src/amd/llvm/ac_llvm_util.c
index ff936af3195a..832e90868018 100644
--- a/src/amd/llvm/ac_llvm_util.c
+++ b/src/amd/llvm/ac_llvm_util.c
@@ -239,6 +239,8 @@ static LLVMPassManagerRef ac_create_passmgr(LLVMTargetLibraryInfoRef target_libr
    /* This pass should eliminate all the load and store instructions. */
    LLVMAddPromoteMemoryToRegisterPass(passmgr);
    LLVMAddScalarReplAggregatesPass(passmgr);
+   if (LLVM_VERSION_MAJOR >= 16)
+      ac_add_sinking_pass(passmgr);
    LLVMAddLICMPass(passmgr);
    LLVMAddAggressiveDCEPass(passmgr);
    LLVMAddCFGSimplificationPass(passmgr);
-- 
GitLab


From f03397c11ecb844e77d71e6954af635040a7c314 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Tue, 13 Dec 2022 11:28:24 -0500
Subject: [PATCH 2/3] ac/llvm: run the IPSCCP pass

AMDVLK runs it and it seems useful.

https://en.wikipedia.org/wiki/Sparse_conditional_constant_propagation

58380 shaders in 35438 tests
Totals:
SGPRS: 2709080 -> 2709224 (0.01 %)
VGPRS: 1592972 -> 1592808 (-0.01 %)
Spilled SGPRs: 2420 -> 2420 (0.00 %)
Spilled VGPRs: 1077 -> 1077 (0.00 %)
Private memory VGPRs: 253 -> 253 (0.00 %)
Scratch size: 1232 -> 1232 (0.00 %) dwords per thread
Code Size: 61382088 -> 61356504 (-0.04 %) bytes
Max Waves: 849293 -> 849308 (0.00 %)
Outputs: 127090 -> 127090 (0.00 %)
Patch Outputs: 579 -> 579 (0.00 %)

Totals from affected shaders:
SGPRS: 5400 -> 5544 (2.67 %)
VGPRS: 6200 -> 6036 (-2.65 %)
Spilled SGPRs: 0 -> 0 (0.00 %)
Spilled VGPRs: 0 -> 0 (0.00 %)
Private memory VGPRs: 0 -> 0 (0.00 %)
Scratch size: 0 -> 0 (0.00 %) dwords per thread
Code Size: 975824 -> 950240 (-2.62 %) bytes
Max Waves: 1214 -> 1229 (1.24 %)
Outputs: 232 -> 232 (0.00 %)
Patch Outputs: 0 -> 0 (0.00 %)
---
 src/amd/llvm/ac_llvm_util.c | 6 +++++-
 1 file changed, 5 insertions(+), 1 deletion(-)

diff --git a/src/amd/llvm/ac_llvm_util.c b/src/amd/llvm/ac_llvm_util.c
index 832e90868018..1bbb8dc3a5e7 100644
--- a/src/amd/llvm/ac_llvm_util.c
+++ b/src/amd/llvm/ac_llvm_util.c
@@ -228,7 +228,9 @@ static LLVMPassManagerRef ac_create_passmgr(LLVMTargetLibraryInfoRef target_libr
 
    if (check_ir)
       LLVMAddVerifierPass(passmgr);
+
    LLVMAddAlwaysInlinerPass(passmgr);
+
    /* Normally, the pass manager runs all passes on one function before
     * moving onto another. Adding a barrier no-op pass forces the pass
     * manager to run the inliner on all functions first, which makes sure
@@ -236,9 +238,11 @@ static LLVMPassManagerRef ac_create_passmgr(LLVMTargetLibraryInfoRef target_libr
     * function, so it removes useless work done on dead inline functions.
     */
    ac_llvm_add_barrier_noop_pass(passmgr);
-   /* This pass should eliminate all the load and store instructions. */
+
+   /* This pass eliminates all loads and stores on alloca'd pointers. */
    LLVMAddPromoteMemoryToRegisterPass(passmgr);
    LLVMAddScalarReplAggregatesPass(passmgr);
+   LLVMAddIPSCCPPass(passmgr);
    if (LLVM_VERSION_MAJOR >= 16)
       ac_add_sinking_pass(passmgr);
    LLVMAddLICMPass(passmgr);
-- 
GitLab


From b14083cccc73eb1edf3cbcf65e9ec13cf3fadbc2 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Tue, 13 Dec 2022 11:30:21 -0500
Subject: [PATCH 3/3] ac/llvm: remove llvm:: now that we use "using namespace
 llvm"

---
 src/amd/llvm/ac_llvm_helper.cpp | 102 ++++++++++++++++----------------
 1 file changed, 51 insertions(+), 51 deletions(-)

diff --git a/src/amd/llvm/ac_llvm_helper.cpp b/src/amd/llvm/ac_llvm_helper.cpp
index 66fdef876a94..22e5c080e4a7 100644
--- a/src/amd/llvm/ac_llvm_helper.cpp
+++ b/src/amd/llvm/ac_llvm_helper.cpp
@@ -50,42 +50,42 @@ using namespace llvm;
 
 bool ac_is_llvm_processor_supported(LLVMTargetMachineRef tm, const char *processor)
 {
-   llvm::TargetMachine *TM = reinterpret_cast<llvm::TargetMachine *>(tm);
+   TargetMachine *TM = reinterpret_cast<TargetMachine *>(tm);
    return TM->getMCSubtargetInfo()->isCPUStringValid(processor);
 }
 
 void ac_reset_llvm_all_options_occurences()
 {
-   llvm::cl::ResetAllOptionOccurrences();
+   cl::ResetAllOptionOccurrences();
 }
 
 void ac_add_attr_dereferenceable(LLVMValueRef val, uint64_t bytes)
 {
-   llvm::Argument *A = llvm::unwrap<llvm::Argument>(val);
-   A->addAttr(llvm::Attribute::getWithDereferenceableBytes(A->getContext(), bytes));
+   Argument *A = unwrap<Argument>(val);
+   A->addAttr(Attribute::getWithDereferenceableBytes(A->getContext(), bytes));
 }
 
 void ac_add_attr_alignment(LLVMValueRef val, uint64_t bytes)
 {
-   llvm::Argument *A = llvm::unwrap<llvm::Argument>(val);
-   A->addAttr(llvm::Attribute::getWithAlignment(A->getContext(), llvm::Align(bytes)));
+   Argument *A = unwrap<Argument>(val);
+   A->addAttr(Attribute::getWithAlignment(A->getContext(), Align(bytes)));
 }
 
 bool ac_is_sgpr_param(LLVMValueRef arg)
 {
-   llvm::Argument *A = llvm::unwrap<llvm::Argument>(arg);
-   llvm::AttributeList AS = A->getParent()->getAttributes();
+   Argument *A = unwrap<Argument>(arg);
+   AttributeList AS = A->getParent()->getAttributes();
    unsigned ArgNo = A->getArgNo();
-   return AS.hasParamAttr(ArgNo, llvm::Attribute::InReg);
+   return AS.hasParamAttr(ArgNo, Attribute::InReg);
 }
 
 LLVMModuleRef ac_create_module(LLVMTargetMachineRef tm, LLVMContextRef ctx)
 {
-   llvm::TargetMachine *TM = reinterpret_cast<llvm::TargetMachine *>(tm);
+   TargetMachine *TM = reinterpret_cast<TargetMachine *>(tm);
    LLVMModuleRef module = LLVMModuleCreateWithNameInContext("mesa-shader", ctx);
 
-   llvm::unwrap(module)->setTargetTriple(TM->getTargetTriple().getTriple());
-   llvm::unwrap(module)->setDataLayout(TM->createDataLayout());
+   unwrap(module)->setTargetTriple(TM->getTargetTriple().getTriple());
+   unwrap(module)->setDataLayout(TM->createDataLayout());
    return module;
 }
 
@@ -93,7 +93,7 @@ LLVMBuilderRef ac_create_builder(LLVMContextRef ctx, enum ac_float_mode float_mo
 {
    LLVMBuilderRef builder = LLVMCreateBuilderInContext(ctx);
 
-   llvm::FastMathFlags flags;
+   FastMathFlags flags;
 
    switch (float_mode) {
    case AC_FLOAT_MODE_DEFAULT:
@@ -111,7 +111,7 @@ LLVMBuilderRef ac_create_builder(LLVMContextRef ctx, enum ac_float_mode float_mo
        */
       flags.setAllowReciprocal(); /* arcp */
 
-      llvm::unwrap(builder)->setFastMathFlags(flags);
+      unwrap(builder)->setFastMathFlags(flags);
       break;
    }
 
@@ -121,8 +121,8 @@ LLVMBuilderRef ac_create_builder(LLVMContextRef ctx, enum ac_float_mode float_mo
 void ac_enable_signed_zeros(struct ac_llvm_context *ctx)
 {
    if (ctx->float_mode == AC_FLOAT_MODE_DEFAULT_OPENGL) {
-      auto *b = llvm::unwrap(ctx->builder);
-      llvm::FastMathFlags flags = b->getFastMathFlags();
+      auto *b = unwrap(ctx->builder);
+      FastMathFlags flags = b->getFastMathFlags();
 
       /* This disables the optimization of (x + 0), which is used
        * to convert negative zero to positive zero.
@@ -135,8 +135,8 @@ void ac_enable_signed_zeros(struct ac_llvm_context *ctx)
 void ac_disable_signed_zeros(struct ac_llvm_context *ctx)
 {
    if (ctx->float_mode == AC_FLOAT_MODE_DEFAULT_OPENGL) {
-      auto *b = llvm::unwrap(ctx->builder);
-      llvm::FastMathFlags flags = b->getFastMathFlags();
+      auto *b = unwrap(ctx->builder);
+      FastMathFlags flags = b->getFastMathFlags();
 
       flags.setNoSignedZeros();
       b->setFastMathFlags(flags);
@@ -146,17 +146,17 @@ void ac_disable_signed_zeros(struct ac_llvm_context *ctx)
 LLVMTargetLibraryInfoRef ac_create_target_library_info(const char *triple)
 {
    return reinterpret_cast<LLVMTargetLibraryInfoRef>(
-      new llvm::TargetLibraryInfoImpl(llvm::Triple(triple)));
+      new TargetLibraryInfoImpl(Triple(triple)));
 }
 
 void ac_dispose_target_library_info(LLVMTargetLibraryInfoRef library_info)
 {
-   delete reinterpret_cast<llvm::TargetLibraryInfoImpl *>(library_info);
+   delete reinterpret_cast<TargetLibraryInfoImpl *>(library_info);
 }
 
 /* Implementation of raw_pwrite_stream that works on malloc()ed memory for
  * better compatibility with C code. */
-struct raw_memory_ostream : public llvm::raw_pwrite_stream {
+struct raw_memory_ostream : public raw_pwrite_stream {
    char *buffer;
    size_t written;
    size_t bufsize;
@@ -223,7 +223,7 @@ struct raw_memory_ostream : public llvm::raw_pwrite_stream {
  */
 struct ac_compiler_passes {
    raw_memory_ostream ostream;        /* ELF shader binary stream */
-   llvm::legacy::PassManager passmgr; /* list of passes */
+   legacy::PassManager passmgr; /* list of passes */
 };
 
 struct ac_compiler_passes *ac_create_llvm_passes(LLVMTargetMachineRef tm)
@@ -232,10 +232,10 @@ struct ac_compiler_passes *ac_create_llvm_passes(LLVMTargetMachineRef tm)
    if (!p)
       return NULL;
 
-   llvm::TargetMachine *TM = reinterpret_cast<llvm::TargetMachine *>(tm);
+   TargetMachine *TM = reinterpret_cast<TargetMachine *>(tm);
 
    if (TM->addPassesToEmitFile(p->passmgr, p->ostream, nullptr,
-                               llvm::CGFT_ObjectFile)) {
+                               CGFT_ObjectFile)) {
       fprintf(stderr, "amd: TargetMachine can't emit a file of this type!\n");
       delete p;
       return NULL;
@@ -252,82 +252,82 @@ void ac_destroy_llvm_passes(struct ac_compiler_passes *p)
 bool ac_compile_module_to_elf(struct ac_compiler_passes *p, LLVMModuleRef module,
                               char **pelf_buffer, size_t *pelf_size)
 {
-   p->passmgr.run(*llvm::unwrap(module));
+   p->passmgr.run(*unwrap(module));
    p->ostream.take(*pelf_buffer, *pelf_size);
    return true;
 }
 
 void ac_llvm_add_barrier_noop_pass(LLVMPassManagerRef passmgr)
 {
-   llvm::unwrap(passmgr)->add(llvm::createBarrierNoopPass());
+   unwrap(passmgr)->add(createBarrierNoopPass());
 }
 
 LLVMValueRef ac_build_atomic_rmw(struct ac_llvm_context *ctx, LLVMAtomicRMWBinOp op,
                                  LLVMValueRef ptr, LLVMValueRef val, const char *sync_scope)
 {
-   llvm::AtomicRMWInst::BinOp binop;
+   AtomicRMWInst::BinOp binop;
    switch (op) {
    case LLVMAtomicRMWBinOpXchg:
-      binop = llvm::AtomicRMWInst::Xchg;
+      binop = AtomicRMWInst::Xchg;
       break;
    case LLVMAtomicRMWBinOpAdd:
-      binop = llvm::AtomicRMWInst::Add;
+      binop = AtomicRMWInst::Add;
       break;
    case LLVMAtomicRMWBinOpSub:
-      binop = llvm::AtomicRMWInst::Sub;
+      binop = AtomicRMWInst::Sub;
       break;
    case LLVMAtomicRMWBinOpAnd:
-      binop = llvm::AtomicRMWInst::And;
+      binop = AtomicRMWInst::And;
       break;
    case LLVMAtomicRMWBinOpNand:
-      binop = llvm::AtomicRMWInst::Nand;
+      binop = AtomicRMWInst::Nand;
       break;
    case LLVMAtomicRMWBinOpOr:
-      binop = llvm::AtomicRMWInst::Or;
+      binop = AtomicRMWInst::Or;
       break;
    case LLVMAtomicRMWBinOpXor:
-      binop = llvm::AtomicRMWInst::Xor;
+      binop = AtomicRMWInst::Xor;
       break;
    case LLVMAtomicRMWBinOpMax:
-      binop = llvm::AtomicRMWInst::Max;
+      binop = AtomicRMWInst::Max;
       break;
    case LLVMAtomicRMWBinOpMin:
-      binop = llvm::AtomicRMWInst::Min;
+      binop = AtomicRMWInst::Min;
       break;
    case LLVMAtomicRMWBinOpUMax:
-      binop = llvm::AtomicRMWInst::UMax;
+      binop = AtomicRMWInst::UMax;
       break;
    case LLVMAtomicRMWBinOpUMin:
-      binop = llvm::AtomicRMWInst::UMin;
+      binop = AtomicRMWInst::UMin;
       break;
    case LLVMAtomicRMWBinOpFAdd:
-      binop = llvm::AtomicRMWInst::FAdd;
+      binop = AtomicRMWInst::FAdd;
       break;
    default:
       unreachable("invalid LLVMAtomicRMWBinOp");
       break;
    }
-   unsigned SSID = llvm::unwrap(ctx->context)->getOrInsertSyncScopeID(sync_scope);
-   return llvm::wrap(llvm::unwrap(ctx->builder)
-                        ->CreateAtomicRMW(binop, llvm::unwrap(ptr), llvm::unwrap(val),
+   unsigned SSID = unwrap(ctx->context)->getOrInsertSyncScopeID(sync_scope);
+   return wrap(unwrap(ctx->builder)
+                        ->CreateAtomicRMW(binop, unwrap(ptr), unwrap(val),
 #if LLVM_VERSION_MAJOR >= 13
-                                          llvm::MaybeAlign(0),
+                                          MaybeAlign(0),
 #endif
-                                          llvm::AtomicOrdering::SequentiallyConsistent, SSID));
+                                          AtomicOrdering::SequentiallyConsistent, SSID));
 }
 
 LLVMValueRef ac_build_atomic_cmp_xchg(struct ac_llvm_context *ctx, LLVMValueRef ptr,
                                       LLVMValueRef cmp, LLVMValueRef val, const char *sync_scope)
 {
-   unsigned SSID = llvm::unwrap(ctx->context)->getOrInsertSyncScopeID(sync_scope);
-   return llvm::wrap(llvm::unwrap(ctx->builder)
-                        ->CreateAtomicCmpXchg(llvm::unwrap(ptr), llvm::unwrap(cmp),
-                                              llvm::unwrap(val),
+   unsigned SSID = unwrap(ctx->context)->getOrInsertSyncScopeID(sync_scope);
+   return wrap(unwrap(ctx->builder)
+                        ->CreateAtomicCmpXchg(unwrap(ptr), unwrap(cmp),
+                                              unwrap(val),
 #if LLVM_VERSION_MAJOR >= 13
-                                              llvm::MaybeAlign(0),
+                                              MaybeAlign(0),
 #endif
-                                              llvm::AtomicOrdering::SequentiallyConsistent,
-                                              llvm::AtomicOrdering::SequentiallyConsistent, SSID));
+                                              AtomicOrdering::SequentiallyConsistent,
+                                              AtomicOrdering::SequentiallyConsistent, SSID));
 }
 
 void ac_add_sinking_pass(LLVMPassManagerRef PM)
-- 
GitLab

