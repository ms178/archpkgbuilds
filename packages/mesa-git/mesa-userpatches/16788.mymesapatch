From 59b544a1573e09ecf1bc5e4344ff6f614779a7ba Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Fri, 27 May 2022 17:24:41 +0800
Subject: [PATCH 01/30] radeonsi: deserialize nir binary in
 si_check_blend_dst_sampler_noop

We can do this parse with original nir instead of shader key pass
applied nir in si_get_nir_shader.

This can free si_get_nir_shader to just use si_shader as parameter.

Acked-by: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/gallium/drivers/radeonsi/si_nir_optim.c | 25 +++++++++------------
 src/gallium/drivers/radeonsi/si_shader.c    | 19 ++++++++++------
 src/gallium/drivers/radeonsi/si_shader.h    |  1 +
 src/gallium/drivers/radeonsi/si_state.c     | 17 +++++---------
 4 files changed, 29 insertions(+), 33 deletions(-)

diff --git a/src/gallium/drivers/radeonsi/si_nir_optim.c b/src/gallium/drivers/radeonsi/si_nir_optim.c
index 0374c870c5a4..993bb04fb206 100644
--- a/src/gallium/drivers/radeonsi/si_nir_optim.c
+++ b/src/gallium/drivers/radeonsi/si_nir_optim.c
@@ -175,19 +175,16 @@ si_nir_is_output_const_if_tex_is_const(nir_shader *shader, float *in, float *out
        util_bitcount64(shader->info.outputs_written) != 1)
       return false;
 
-   /* Clone the shader */
-   nir_shader *sh = nir_shader_clone(ralloc_parent(shader), shader);
-
    struct replace_param p;
    memcpy(p.value, in, 4 * sizeof(float));
    p.texunit = texunit;
 
    /* Test if the single store_output only depends on constants and a single texture op */
-   if (nir_shader_instructions_pass(sh, store_instr_depends_on_tex, nir_metadata_all, &p)) {
+   if (nir_shader_instructions_pass(shader, store_instr_depends_on_tex, nir_metadata_all, &p)) {
       assert(*p.texunit != -1);
 
       /* Replace nir_tex_instr using texunit by vec4(v) */
-      nir_shader_instructions_pass(sh, replace_tex_by_imm,
+      nir_shader_instructions_pass(shader, replace_tex_by_imm,
                                    nir_metadata_block_index |
                                    nir_metadata_dominance, &p);
 
@@ -195,20 +192,18 @@ si_nir_is_output_const_if_tex_is_const(nir_shader *shader, float *in, float *out
       bool progress;
       do {
          progress = false;
-         NIR_PASS(progress, sh, nir_copy_prop);
-         NIR_PASS(progress, sh, nir_opt_remove_phis);
-         NIR_PASS(progress, sh, nir_opt_dce);
-         NIR_PASS(progress, sh, nir_opt_dead_cf);
-         NIR_PASS(progress, sh, nir_opt_algebraic);
-         NIR_PASS(progress, sh, nir_opt_constant_folding);
+         NIR_PASS(progress, shader, nir_copy_prop);
+         NIR_PASS(progress, shader, nir_opt_remove_phis);
+         NIR_PASS(progress, shader, nir_opt_dce);
+         NIR_PASS(progress, shader, nir_opt_dead_cf);
+         NIR_PASS(progress, shader, nir_opt_algebraic);
+         NIR_PASS(progress, shader, nir_opt_constant_folding);
       } while (progress);
 
       /* Is the output a constant value? */
-      if (get_output_as_const_value(sh, out)) {
-         ralloc_free(sh);
+      if (get_output_as_const_value(shader, out))
          return true;
-      }
    }
-   ralloc_free(sh);
+
    return false;
 }
diff --git a/src/gallium/drivers/radeonsi/si_shader.c b/src/gallium/drivers/radeonsi/si_shader.c
index 68c61ec43053..c4d81298a27f 100644
--- a/src/gallium/drivers/radeonsi/si_shader.c
+++ b/src/gallium/drivers/radeonsi/si_shader.c
@@ -1515,6 +1515,17 @@ static bool si_lower_io_to_mem(const union si_shader_key *key,
    return false;
 }
 
+struct nir_shader *si_deserialize_shader(struct si_shader_selector *sel)
+{
+   struct pipe_screen *screen = &sel->screen->b;
+   const void *options = screen->get_compiler_options(screen, PIPE_SHADER_IR_NIR,
+                                                      pipe_shader_type_from_mesa(sel->stage));
+
+   struct blob_reader blob_reader;
+   blob_reader_init(&blob_reader, sel->nir_binary, sel->nir_size);
+   return nir_deserialize(NULL, options, &blob_reader);
+}
+
 struct nir_shader *si_get_nir_shader(struct si_shader_selector *sel,
                                      const union si_shader_key *key,
                                      bool *free_nir,
@@ -1526,14 +1537,8 @@ struct nir_shader *si_get_nir_shader(struct si_shader_selector *sel,
    if (sel->nir) {
       nir = sel->nir;
    } else if (sel->nir_binary) {
-      struct pipe_screen *screen = &sel->screen->b;
-      const void *options = screen->get_compiler_options(screen, PIPE_SHADER_IR_NIR,
-                                                         pipe_shader_type_from_mesa(sel->stage));
-
-      struct blob_reader blob_reader;
-      blob_reader_init(&blob_reader, sel->nir_binary, sel->nir_size);
+      nir = si_deserialize_shader(sel);
       *free_nir = true;
-      nir = nir_deserialize(NULL, options, &blob_reader);
    } else {
       return NULL;
    }
diff --git a/src/gallium/drivers/radeonsi/si_shader.h b/src/gallium/drivers/radeonsi/si_shader.h
index c86e2f27f2a7..8c38792e6dec 100644
--- a/src/gallium/drivers/radeonsi/si_shader.h
+++ b/src/gallium/drivers/radeonsi/si_shader.h
@@ -979,6 +979,7 @@ void si_shader_dump_stats_for_shader_db(struct si_screen *screen, struct si_shad
 void si_multiwave_lds_size_workaround(struct si_screen *sscreen, unsigned *lds_size);
 const char *si_get_shader_name(const struct si_shader *shader);
 void si_shader_binary_clean(struct si_shader_binary *binary);
+struct nir_shader *si_deserialize_shader(struct si_shader_selector *sel);
 
 /* si_shader_info.c */
 void si_nir_scan_shader(struct si_screen *sscreen,  const struct nir_shader *nir,
diff --git a/src/gallium/drivers/radeonsi/si_state.c b/src/gallium/drivers/radeonsi/si_state.c
index ddbf393f87d0..98cfe655fbd4 100644
--- a/src/gallium/drivers/radeonsi/si_state.c
+++ b/src/gallium/drivers/radeonsi/si_state.c
@@ -656,15 +656,12 @@ static bool si_check_blend_dst_sampler_noop(struct si_context *sctx)
    if (sctx->framebuffer.state.nr_cbufs == 1) {
       struct si_shader_selector *sel = sctx->shader.ps.cso;
 
-      /* Wait for the shader to be ready. */
-      util_queue_fence_wait(&sel->ready);
-
-      assert(!sel->nir);
-
-      bool free_nir;
       if (unlikely(sel->info.writes_1_if_tex_is_1 == 0xff)) {
-         struct nir_shader *nir =
-            si_get_nir_shader(sel, &sctx->shader.ps.key, &free_nir, 0);
+          /* Wait for the shader to be ready. */
+         util_queue_fence_wait(&sel->ready);
+         assert(sel->nir_binary);
+
+         struct nir_shader *nir = si_deserialize_shader(sel);
 
          /* Determine if this fragment shader always writes vec4(1) if a specific texture
           * is all 1s.
@@ -679,9 +676,7 @@ static bool si_check_blend_dst_sampler_noop(struct si_context *sctx)
             sel->info.writes_1_if_tex_is_1 = 0;
          }
 
-         assert(free_nir);
-         if (free_nir)
-            ralloc_free(nir);
+         ralloc_free(nir);
       }
 
       if (sel->info.writes_1_if_tex_is_1 &&
-- 
GitLab


From cc15b710975a61c2994069703514b961ef4497fe Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Fri, 27 May 2022 17:32:45 +0800
Subject: [PATCH 02/30] radeonsi: use si_shader as parameter in
 si_get_nir_shader

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/gallium/drivers/radeonsi/si_shader.c          | 9 +++++----
 src/gallium/drivers/radeonsi/si_shader_internal.h | 4 +---
 src/gallium/drivers/radeonsi/si_shader_llvm.c     | 5 ++---
 3 files changed, 8 insertions(+), 10 deletions(-)

diff --git a/src/gallium/drivers/radeonsi/si_shader.c b/src/gallium/drivers/radeonsi/si_shader.c
index c4d81298a27f..a3f74e519f1a 100644
--- a/src/gallium/drivers/radeonsi/si_shader.c
+++ b/src/gallium/drivers/radeonsi/si_shader.c
@@ -1526,11 +1526,12 @@ struct nir_shader *si_deserialize_shader(struct si_shader_selector *sel)
    return nir_deserialize(NULL, options, &blob_reader);
 }
 
-struct nir_shader *si_get_nir_shader(struct si_shader_selector *sel,
-                                     const union si_shader_key *key,
-                                     bool *free_nir,
+struct nir_shader *si_get_nir_shader(struct si_shader *shader, bool *free_nir,
                                      uint64_t tcs_vgpr_only_inputs)
 {
+   struct si_shader_selector *sel = shader->selector;
+   const union si_shader_key *key = &shader->key;
+
    nir_shader *nir;
    *free_nir = false;
 
@@ -1726,7 +1727,7 @@ bool si_compile_shader(struct si_screen *sscreen, struct ac_llvm_compiler *compi
 {
    struct si_shader_selector *sel = shader->selector;
    bool free_nir;
-   struct nir_shader *nir = si_get_nir_shader(sel, &shader->key, &free_nir, 0);
+   struct nir_shader *nir = si_get_nir_shader(shader, &free_nir, 0);
 
    /* Assign param export indices. */
    if ((sel->stage == MESA_SHADER_VERTEX ||
diff --git a/src/gallium/drivers/radeonsi/si_shader_internal.h b/src/gallium/drivers/radeonsi/si_shader_internal.h
index ee04b3708d7f..3860095e4ba3 100644
--- a/src/gallium/drivers/radeonsi/si_shader_internal.h
+++ b/src/gallium/drivers/radeonsi/si_shader_internal.h
@@ -173,9 +173,7 @@ bool si_vs_needs_prolog(const struct si_shader_selector *sel,
 void si_get_vs_prolog_key(const struct si_shader_info *info, unsigned num_input_sgprs,
                           bool ngg_cull_shader, const struct si_vs_prolog_bits *prolog_key,
                           struct si_shader *shader_out, union si_shader_part_key *key);
-struct nir_shader *si_get_nir_shader(struct si_shader_selector *sel,
-                                     const union si_shader_key *key,
-                                     bool *free_nir,
+struct nir_shader *si_get_nir_shader(struct si_shader *shader, bool *free_nir,
                                      uint64_t tcs_vgpr_only_inputs);
 void si_get_tcs_epilog_key(struct si_shader *shader, union si_shader_part_key *key);
 bool si_need_ps_prolog(const union si_shader_part_key *key);
diff --git a/src/gallium/drivers/radeonsi/si_shader_llvm.c b/src/gallium/drivers/radeonsi/si_shader_llvm.c
index 245ca5c4638e..781352191e52 100644
--- a/src/gallium/drivers/radeonsi/si_shader_llvm.c
+++ b/src/gallium/drivers/radeonsi/si_shader_llvm.c
@@ -1254,8 +1254,7 @@ bool si_llvm_compile_shader(struct si_screen *sscreen, struct ac_llvm_compiler *
          shader_ls.key.ge.opt.inline_uniforms = false; /* only TCS can inline uniforms */
          shader_ls.is_monolithic = true;
 
-         nir = si_get_nir_shader(ls, &shader_ls.key, &free_nir,
-                                 sel->info.tcs_vgpr_only_inputs);
+         nir = si_get_nir_shader(&shader_ls, &free_nir, sel->info.tcs_vgpr_only_inputs);
          si_update_shader_binary_info(shader, nir);
 
          if (!si_llvm_translate_nir(&ctx, &shader_ls, nir, free_nir, false)) {
@@ -1315,7 +1314,7 @@ bool si_llvm_compile_shader(struct si_screen *sscreen, struct ac_llvm_compiler *
          shader_es.key.ge.opt.kill_outputs = 0;
          shader_es.is_monolithic = true;
 
-         nir = si_get_nir_shader(es, &shader_es.key, &free_nir, 0);
+         nir = si_get_nir_shader(&shader_es, &free_nir, 0);
          si_update_shader_binary_info(shader, nir);
 
          if (!si_llvm_translate_nir(&ctx, &shader_es, nir, free_nir, false)) {
-- 
GitLab


From cdf794974d8d4efda1e2c135f7fd24beba4249b5 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Wed, 18 May 2022 16:57:17 +0800
Subject: [PATCH 03/30] radeonsi: support multi stage shader state creation in
 nir shaderlib

For creating tcs passthrough shader.

Acked-by: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 .../drivers/radeonsi/si_shaderlib_nir.c       | 42 +++++++++++++------
 1 file changed, 30 insertions(+), 12 deletions(-)

diff --git a/src/gallium/drivers/radeonsi/si_shaderlib_nir.c b/src/gallium/drivers/radeonsi/si_shaderlib_nir.c
index 86b93b63cf04..a62b246f6b29 100644
--- a/src/gallium/drivers/radeonsi/si_shaderlib_nir.c
+++ b/src/gallium/drivers/radeonsi/si_shaderlib_nir.c
@@ -26,15 +26,33 @@
 #include "ac_surface.h"
 #include "si_pipe.h"
 
-static void *create_nir_cs(struct si_context *sctx, nir_builder *b)
+static void *create_shader_state(struct si_context *sctx, nir_shader *nir)
 {
-   nir_shader_gather_info(b->shader, nir_shader_get_entrypoint(b->shader));
-
-   struct pipe_compute_state state = {0};
-   state.ir_type = PIPE_SHADER_IR_NIR;
-   state.prog = b->shader;
-   sctx->b.screen->finalize_nir(sctx->b.screen, (void*)state.prog);
-   return sctx->b.create_compute_state(&sctx->b, &state);
+   sctx->b.screen->finalize_nir(sctx->b.screen, (void*)nir);
+
+   struct pipe_shader_state state = {0};
+   state.type = PIPE_SHADER_IR_NIR;
+   state.ir.nir = nir;
+
+   switch (nir->info.stage) {
+   case MESA_SHADER_VERTEX:
+      return sctx->b.create_vs_state(&sctx->b, &state);
+   case MESA_SHADER_TESS_CTRL:
+      return sctx->b.create_tcs_state(&sctx->b, &state);
+   case MESA_SHADER_TESS_EVAL:
+      return sctx->b.create_tes_state(&sctx->b, &state);
+   case MESA_SHADER_FRAGMENT:
+      return sctx->b.create_fs_state(&sctx->b, &state);
+   case MESA_SHADER_COMPUTE: {
+      struct pipe_compute_state cs_state = {0};
+      cs_state.ir_type = PIPE_SHADER_IR_NIR;
+      cs_state.prog = nir;
+      return sctx->b.create_compute_state(&sctx->b, &cs_state);
+   }
+   default:
+      unreachable("invalid shader stage");
+      return NULL;
+   }
 }
 
 static nir_ssa_def *get_global_ids(nir_builder *b, unsigned num_components)
@@ -115,7 +133,7 @@ void *si_create_copy_image_cs(struct si_context *sctx, bool src_is_1d_array, boo
 
    nir_image_deref_store(&b, deref_ssa(&b, img_dst), coord_dst, undef32, data, zero);
 
-   return create_nir_cs(sctx, &b);
+   return create_shader_state(sctx, b.shader);
 }
 
 void *si_create_dcc_retile_cs(struct si_context *sctx, struct radeon_surf *surf)
@@ -163,7 +181,7 @@ void *si_create_dcc_retile_cs(struct si_context *sctx, struct radeon_surf *surf)
                                  zero, zero, zero); /* z, sample, pipe_xor */
    nir_store_ssbo(&b, value, zero, dst_offset, .write_mask=0x1, .align_mul=1);
 
-   return create_nir_cs(sctx, &b);
+   return create_shader_state(sctx, b.shader);
 }
 
 void *gfx9_create_clear_dcc_msaa_cs(struct si_context *sctx, struct si_texture *tex)
@@ -209,7 +227,7 @@ void *gfx9_create_clear_dcc_msaa_cs(struct si_context *sctx, struct si_texture *
     */
    nir_store_ssbo(&b, clear_value, zero, offset, .write_mask=0x1, .align_mul=2);
 
-   return create_nir_cs(sctx, &b);
+   return create_shader_state(sctx, b.shader);
 }
 
 /* Create a compute shader implementing clear_buffer or copy_buffer. */
@@ -247,6 +265,6 @@ void *si_create_clear_buffer_rmw_cs(struct si_context *sctx)
       .access = SI_COMPUTE_DST_CACHE_POLICY != L2_LRU ? ACCESS_STREAM_CACHE_POLICY : 0,
       .align_mul = 4);
 
-   return create_nir_cs(sctx, &b);
+   return create_shader_state(sctx, b.shader);
 }
 
-- 
GitLab


From 7dbd1f2f8b495d5ce801482564eb5ac3a311b196 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Wed, 18 May 2022 17:12:58 +0800
Subject: [PATCH 04/30] radeonsi: add si_create_passthrough_tcs

For replacing si_create_fixed_func_tcs.

Acked-by: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/gallium/drivers/radeonsi/si_pipe.h        |  1 +
 .../drivers/radeonsi/si_shaderlib_nir.c       | 79 +++++++++++++++++++
 2 files changed, 80 insertions(+)

diff --git a/src/gallium/drivers/radeonsi/si_pipe.h b/src/gallium/drivers/radeonsi/si_pipe.h
index 092f1f74ee7f..8b588f2b0a0c 100644
--- a/src/gallium/drivers/radeonsi/si_pipe.h
+++ b/src/gallium/drivers/radeonsi/si_pipe.h
@@ -1550,6 +1550,7 @@ void si_resume_queries(struct si_context *sctx);
 void *si_create_copy_image_cs(struct si_context *sctx, bool src_is_1d_array, bool dst_is_1d_array);
 void *si_create_dcc_retile_cs(struct si_context *sctx, struct radeon_surf *surf);
 void *gfx9_create_clear_dcc_msaa_cs(struct si_context *sctx, struct si_texture *tex);
+void *si_create_passthrough_tcs(struct si_context *sctx);
 
 /* si_shaderlib_tgsi.c */
 void *si_get_blitter_vs(struct si_context *sctx, enum blitter_attrib_type type,
diff --git a/src/gallium/drivers/radeonsi/si_shaderlib_nir.c b/src/gallium/drivers/radeonsi/si_shaderlib_nir.c
index a62b246f6b29..f92218b7c8b3 100644
--- a/src/gallium/drivers/radeonsi/si_shaderlib_nir.c
+++ b/src/gallium/drivers/radeonsi/si_shaderlib_nir.c
@@ -268,3 +268,82 @@ void *si_create_clear_buffer_rmw_cs(struct si_context *sctx)
    return create_shader_state(sctx, b.shader);
 }
 
+/* This is used when TCS is NULL in the VS->TCS->TES chain. In this case,
+ * VS passes its outputs to TES directly, so the fixed-function shader only
+ * has to write TESSOUTER and TESSINNER.
+ */
+void *si_create_passthrough_tcs(struct si_context *sctx)
+{
+   const nir_shader_compiler_options *options =
+      sctx->b.screen->get_compiler_options(sctx->b.screen, PIPE_SHADER_IR_NIR,
+                                           PIPE_SHADER_TESS_CTRL);
+
+   nir_builder b = nir_builder_init_simple_shader(MESA_SHADER_TESS_CTRL, options,
+                                                  "tcs passthrough");
+
+   unsigned num_inputs = 0;
+   unsigned num_outputs = 0;
+
+   nir_variable *in_inner =
+      nir_variable_create(b.shader, nir_var_system_value, glsl_vec_type(2),
+                          "tess inner default");
+   in_inner->data.location = SYSTEM_VALUE_TESS_LEVEL_INNER_DEFAULT;
+
+   nir_variable *out_inner =
+      nir_variable_create(b.shader, nir_var_shader_out, glsl_vec_type(2),
+                          "tess inner");
+   out_inner->data.location = VARYING_SLOT_TESS_LEVEL_INNER;
+   out_inner->data.driver_location = num_outputs++;
+
+   nir_ssa_def *inner = nir_load_var(&b, in_inner);
+   nir_store_var(&b, out_inner, inner, 0x3);
+
+   nir_variable *in_outer =
+      nir_variable_create(b.shader, nir_var_system_value, glsl_vec4_type(),
+                          "tess outer default");
+   in_outer->data.location = SYSTEM_VALUE_TESS_LEVEL_OUTER_DEFAULT;
+
+   nir_variable *out_outer =
+      nir_variable_create(b.shader, nir_var_shader_out, glsl_vec4_type(),
+                          "tess outer");
+   out_outer->data.location = VARYING_SLOT_TESS_LEVEL_OUTER;
+   out_outer->data.driver_location = num_outputs++;
+
+   nir_ssa_def *outer = nir_load_var(&b, in_outer);
+   nir_store_var(&b, out_outer, outer, 0xf);
+
+   nir_ssa_def *id = nir_load_invocation_id(&b);
+   struct si_shader_info *info = &sctx->shader.vs.cso->info;
+   for (unsigned i = 0; i < info->num_outputs; i++) {
+      const struct glsl_type *type;
+      unsigned semantic = info->output_semantic[i];
+      if (semantic < VARYING_SLOT_VAR31 && semantic != VARYING_SLOT_EDGE)
+         type = glsl_array_type(glsl_vec4_type(), 0, 0);
+      else if (semantic >= VARYING_SLOT_VAR0_16BIT)
+         type = glsl_array_type(glsl_vector_type(GLSL_TYPE_FLOAT16, 4), 0, 0);
+      else
+         continue;
+
+      char name[10];
+      snprintf(name, sizeof(name), "in_%u", i);
+      nir_variable *in = nir_variable_create(b.shader, nir_var_shader_in, type, name);
+      in->data.location = semantic;
+      in->data.driver_location = num_inputs++;
+
+      snprintf(name, sizeof(name), "out_%u", i);
+      nir_variable *out = nir_variable_create(b.shader, nir_var_shader_out, type, name);
+      out->data.location = semantic;
+      out->data.driver_location = num_outputs++;
+
+      /* no need to use copy_var to save a lower pass */
+      nir_ssa_def *value = nir_load_array_var(&b, in, id);
+      nir_store_array_var(&b, out, id, value, 0xf);
+   }
+
+   b.shader->num_inputs = num_inputs;
+   b.shader->num_outputs = num_outputs;
+
+   b.shader->info.tess.tcs_vertices_out = sctx->patch_vertices;
+
+   return create_shader_state(sctx, b.shader);
+}
-- 
GitLab


From f5a3e5b9704c61c10993468051b4149f442d98de Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Fri, 20 May 2022 17:27:27 +0800
Subject: [PATCH 05/30] radeonsi: replace llvm based fixed tcs with nir

Create nir passthrough shader with explicit input/output and vertex
output count so that it can be handled by compiler same as user tcs.

The drawback is we create more si_shader_selector with different
input/output and vertex output count which was handled by compiler
backend before.

As fixed function tcs can be handled like user tcs, we don't need
the dedicated fixed_func_tcs_shader state either.

Acked-by: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/gallium/drivers/radeonsi/si_debug.c       |  10 +-
 src/gallium/drivers/radeonsi/si_pipe.c        |   9 +-
 src/gallium/drivers/radeonsi/si_pipe.h        |   5 +-
 src/gallium/drivers/radeonsi/si_shader.c      |   8 +-
 src/gallium/drivers/radeonsi/si_shader.h      |   1 -
 src/gallium/drivers/radeonsi/si_shader_llvm.c |   5 +-
 .../drivers/radeonsi/si_shader_llvm_tess.c    |  45 +------
 .../drivers/radeonsi/si_shaderlib_tgsi.c      |  27 -----
 src/gallium/drivers/radeonsi/si_state.h       |   1 +
 .../drivers/radeonsi/si_state_draw.cpp        | 111 ++++++++----------
 .../drivers/radeonsi/si_state_shaders.cpp     |  68 ++++++++---
 11 files changed, 118 insertions(+), 172 deletions(-)

diff --git a/src/gallium/drivers/radeonsi/si_debug.c b/src/gallium/drivers/radeonsi/si_debug.c
index 85f5667f2a76..d1deb09cca63 100644
--- a/src/gallium/drivers/radeonsi/si_debug.c
+++ b/src/gallium/drivers/radeonsi/si_debug.c
@@ -1036,19 +1036,13 @@ static void si_dump_debug_state(struct pipe_context *ctx, FILE *f, unsigned flag
 
 void si_log_draw_state(struct si_context *sctx, struct u_log_context *log)
 {
-   struct si_shader_ctx_state *tcs_shader;
-
    if (!log)
       return;
 
-   tcs_shader = &sctx->shader.tcs;
-   if (sctx->shader.tes.cso && !sctx->shader.tcs.cso)
-      tcs_shader = &sctx->fixed_func_tcs_shader;
-
    si_dump_framebuffer(sctx, log);
 
    si_dump_gfx_shader(sctx, &sctx->shader.vs, log);
-   si_dump_gfx_shader(sctx, tcs_shader, log);
+   si_dump_gfx_shader(sctx, &sctx->shader.tcs, log);
    si_dump_gfx_shader(sctx, &sctx->shader.tes, log);
    si_dump_gfx_shader(sctx, &sctx->shader.gs, log);
    si_dump_gfx_shader(sctx, &sctx->shader.ps, log);
@@ -1057,7 +1051,7 @@ void si_log_draw_state(struct si_context *sctx, struct u_log_context *log)
                            4, sctx->descriptors[SI_DESCS_INTERNAL].num_active_slots, si_identity,
                            log);
    si_dump_gfx_descriptors(sctx, &sctx->shader.vs, log);
-   si_dump_gfx_descriptors(sctx, tcs_shader, log);
+   si_dump_gfx_descriptors(sctx, &sctx->shader.tcs, log);
    si_dump_gfx_descriptors(sctx, &sctx->shader.tes, log);
    si_dump_gfx_descriptors(sctx, &sctx->shader.gs, log);
    si_dump_gfx_descriptors(sctx, &sctx->shader.ps, log);
diff --git a/src/gallium/drivers/radeonsi/si_pipe.c b/src/gallium/drivers/radeonsi/si_pipe.c
index 98d93af749ea..ef7a16619d28 100644
--- a/src/gallium/drivers/radeonsi/si_pipe.c
+++ b/src/gallium/drivers/radeonsi/si_pipe.c
@@ -228,8 +228,13 @@ static void si_destroy_context(struct pipe_context *context)
    for (i = 0; i < ARRAY_SIZE(sctx->vgt_shader_config); i++)
       si_pm4_free_state(sctx, sctx->vgt_shader_config[i], SI_STATE_IDX(vgt_shader_config));
 
-   if (sctx->fixed_func_tcs_shader.cso)
-      sctx->b.delete_tcs_state(&sctx->b, sctx->fixed_func_tcs_shader.cso);
+   if (sctx->fixed_func_tcs_shader_cache) {
+      hash_table_foreach(sctx->fixed_func_tcs_shader_cache, entry) {
+         sctx->b.delete_tcs_state(&sctx->b, entry->data);
+      }
+      _mesa_hash_table_destroy(sctx->fixed_func_tcs_shader_cache, NULL);
+   }
+
    if (sctx->custom_dsa_flush)
       sctx->b.delete_depth_stencil_alpha_state(&sctx->b, sctx->custom_dsa_flush);
    if (sctx->custom_blend_resolve)
diff --git a/src/gallium/drivers/radeonsi/si_pipe.h b/src/gallium/drivers/radeonsi/si_pipe.h
index 8b588f2b0a0c..f8ae3e35fa17 100644
--- a/src/gallium/drivers/radeonsi/si_pipe.h
+++ b/src/gallium/drivers/radeonsi/si_pipe.h
@@ -999,7 +999,7 @@ struct si_context {
    struct si_screen *screen;
    struct util_debug_callback debug;
    struct ac_llvm_compiler compiler; /* only non-threaded compilation */
-   struct si_shader_ctx_state fixed_func_tcs_shader;
+   struct hash_table *fixed_func_tcs_shader_cache;
    struct si_resource *wait_mem_scratch;
    struct si_resource *wait_mem_scratch_tmz;
    unsigned wait_mem_number;
@@ -1076,6 +1076,8 @@ struct si_context {
       struct si_shader_ctx_state shaders[SI_NUM_GRAPHICS_SHADERS];
    };
    struct si_cs_shader_state cs_shader_state;
+   /* if current tcs set by user */
+   bool is_user_tcs;
 
    /* shader information */
    uint64_t ps_inputs_read_or_disabled;
@@ -1555,7 +1557,6 @@ void *si_create_passthrough_tcs(struct si_context *sctx);
 /* si_shaderlib_tgsi.c */
 void *si_get_blitter_vs(struct si_context *sctx, enum blitter_attrib_type type,
                         unsigned num_layers);
-void *si_create_fixed_func_tcs(struct si_context *sctx);
 void *si_create_dma_compute_shader(struct pipe_context *ctx, unsigned num_dwords_per_thread,
                                    bool dst_stream_cache_policy, bool is_copy);
 void *si_create_clear_buffer_rmw_cs(struct si_context *sctx);
diff --git a/src/gallium/drivers/radeonsi/si_shader.c b/src/gallium/drivers/radeonsi/si_shader.c
index a3f74e519f1a..b65cec6b978a 100644
--- a/src/gallium/drivers/radeonsi/si_shader.c
+++ b/src/gallium/drivers/radeonsi/si_shader.c
@@ -1239,8 +1239,6 @@ static void si_dump_shader_key(const struct si_shader *shader, FILE *f)
          si_dump_shader_key_vs(key, &key->ge.part.tcs.ls_prolog, "part.tcs.ls_prolog", f);
       }
       fprintf(f, "  part.tcs.epilog.prim_mode = %u\n", key->ge.part.tcs.epilog.prim_mode);
-      fprintf(f, "  mono.u.ff_tcs_inputs_to_copy = 0x%" PRIx64 "\n",
-              key->ge.mono.u.ff_tcs_inputs_to_copy);
       fprintf(f, "  opt.prefer_mono = %u\n", key->ge.opt.prefer_mono);
       fprintf(f, "  opt.same_patch_vertices = %u\n", key->ge.opt.same_patch_vertices);
       break;
@@ -2018,12 +2016,8 @@ void si_get_tcs_epilog_key(struct si_shader *shader, union si_shader_part_key *k
    key->tcs_epilog.wave32 = shader->wave_size == 32;
    key->tcs_epilog.states = shader->key.ge.part.tcs.epilog;
 
-   /* If output patches are wholly in one wave, we don't need a barrier.
-    * The fixed-func TCS doesn't set tcs_vertices_out, but it won't use a barrier
-    * anyway because tess levels are always defined in all invocations there.
-    */
+   /* If output patches are wholly in one wave, we don't need a barrier. */
    key->tcs_epilog.noop_s_barrier =
-      shader->selector->info.base.tess.tcs_vertices_out &&
       shader->wave_size % shader->selector->info.base.tess.tcs_vertices_out == 0;
 }
 
diff --git a/src/gallium/drivers/radeonsi/si_shader.h b/src/gallium/drivers/radeonsi/si_shader.h
index 8c38792e6dec..8bed98dbd82e 100644
--- a/src/gallium/drivers/radeonsi/si_shader.h
+++ b/src/gallium/drivers/radeonsi/si_shader.h
@@ -686,7 +686,6 @@ struct si_shader_key_ge {
       union si_vs_fix_fetch vs_fix_fetch[SI_MAX_ATTRIBS];
 
       union {
-         uint64_t ff_tcs_inputs_to_copy; /* fixed-func TCS only */
          /* When PS needs PrimID and GS is disabled. */
          unsigned vs_export_prim_id : 1;    /* VS and TES only */
          unsigned gs_tri_strip_adj_fix : 1; /* GS only */
diff --git a/src/gallium/drivers/radeonsi/si_shader_llvm.c b/src/gallium/drivers/radeonsi/si_shader_llvm.c
index 781352191e52..5e9b3d441ab2 100644
--- a/src/gallium/drivers/radeonsi/si_shader_llvm.c
+++ b/src/gallium/drivers/radeonsi/si_shader_llvm.c
@@ -1023,12 +1023,9 @@ bool si_llvm_translate_nir(struct si_shader_context *ctx, struct si_shader *shad
             /* If both input and output patches are wholly in one wave, we don't need a barrier.
              * That's true when both VS and TCS have the same number of patch vertices and
              * the wave size is a multiple of the number of patch vertices.
-             *
-             * The fixed-func TCS doesn't set tcs_vertices_out.
              */
             if (!shader->key.ge.opt.same_patch_vertices ||
-                (sel->info.base.tess.tcs_vertices_out &&
-                 ctx->ac.wave_size % sel->info.base.tess.tcs_vertices_out != 0))
+                ctx->ac.wave_size % sel->info.base.tess.tcs_vertices_out != 0)
                ac_build_s_barrier(&ctx->ac, ctx->stage);
          }
       } else if (ctx->stage == MESA_SHADER_GEOMETRY && !shader->key.ge.as_ngg) {
diff --git a/src/gallium/drivers/radeonsi/si_shader_llvm_tess.c b/src/gallium/drivers/radeonsi/si_shader_llvm_tess.c
index 67e896e1291a..9ef5e241d507 100644
--- a/src/gallium/drivers/radeonsi/si_shader_llvm_tess.c
+++ b/src/gallium/drivers/radeonsi/si_shader_llvm_tess.c
@@ -71,9 +71,6 @@ static unsigned get_tcs_out_vertex_dw_stride_constant(struct si_shader_context *
 {
    assert(ctx->stage == MESA_SHADER_TESS_CTRL);
 
-   if (ctx->shader->key.ge.mono.u.ff_tcs_inputs_to_copy)
-      return util_last_bit64(ctx->shader->key.ge.mono.u.ff_tcs_inputs_to_copy) * 4;
-
    return util_last_bit64(ctx->shader->selector->info.outputs_written) * 4;
 }
 
@@ -86,9 +83,6 @@ static LLVMValueRef get_tcs_out_vertex_dw_stride(struct si_shader_context *ctx)
 
 static LLVMValueRef get_tcs_out_patch_stride(struct si_shader_context *ctx)
 {
-   if (ctx->shader->key.ge.mono.u.ff_tcs_inputs_to_copy)
-      return si_unpack_param(ctx, ctx->tcs_out_lds_layout, 0, 13);
-
    const struct si_shader_info *info = &ctx->shader->selector->info;
    unsigned tcs_out_vertices = info->base.tess.tcs_vertices_out;
    unsigned vertex_dw_stride = get_tcs_out_vertex_dw_stride_constant(ctx);
@@ -141,7 +135,7 @@ LLVMValueRef si_get_num_tcs_out_vertices(struct si_shader_context *ctx)
       ctx->shader->selector ? ctx->shader->selector->info.base.tess.tcs_vertices_out
                             : 0;
 
-   /* If !tcs_out_vertices, it's either the fixed-func TCS or the TCS epilog. */
+   /* If !tcs_out_vertices, it's the TCS epilog. */
    if (ctx->stage == MESA_SHADER_TESS_CTRL && tcs_out_vertices)
       return LLVMConstInt(ctx->ac.i32, tcs_out_vertices, 0);
 
@@ -550,41 +544,6 @@ static void si_nir_store_output_tcs(struct ac_shader_abi *abi,
    }
 }
 
-/**
- * Forward all outputs from the vertex shader to the TES. This is only used
- * for the fixed function TCS.
- */
-static void si_copy_tcs_inputs(struct si_shader_context *ctx)
-{
-   LLVMValueRef invocation_id, buffer, buffer_offset;
-   LLVMValueRef lds_vertex_stride, lds_base;
-   uint64_t inputs;
-
-   invocation_id = si_unpack_param(ctx, ctx->args.tcs_rel_ids, 8, 5);
-   buffer = get_tess_ring_descriptor(ctx, TESS_OFFCHIP_RING_TCS);
-   buffer_offset = ac_get_arg(&ctx->ac, ctx->args.tess_offchip_offset);
-
-   lds_vertex_stride = si_get_tcs_in_vertex_dw_stride(ctx);
-   lds_base = get_tcs_in_current_patch_offset(ctx);
-   lds_base = ac_build_imad(&ctx->ac, invocation_id, lds_vertex_stride, lds_base);
-
-   inputs = ctx->shader->key.ge.mono.u.ff_tcs_inputs_to_copy;
-   while (inputs) {
-      unsigned i = u_bit_scan64(&inputs);
-
-      LLVMValueRef lds_ptr =
-         LLVMBuildAdd(ctx->ac.builder, lds_base, LLVMConstInt(ctx->ac.i32, 4 * i, 0), "");
-
-      LLVMValueRef buffer_addr = get_tcs_tes_buffer_address(
-         ctx, get_rel_patch_id(ctx), invocation_id, LLVMConstInt(ctx->ac.i32, i, 0));
-
-      LLVMValueRef value = lshs_lds_load(ctx, ctx->ac.i32, ~0, lds_ptr);
-
-      ac_build_buffer_store_dword(&ctx->ac, buffer, value, NULL, buffer_addr, buffer_offset,
-                                  ac_glc);
-   }
-}
-
 static void si_write_tess_factors(struct si_shader_context *ctx, union si_shader_part_key *key,
                                   LLVMValueRef rel_patch_id, LLVMValueRef invocation_id,
                                   LLVMValueRef tcs_out_current_patch_data_offset,
@@ -751,8 +710,6 @@ void si_llvm_tcs_build_end(struct si_shader_context *ctx)
    LLVMBuilderRef builder = ctx->ac.builder;
    LLVMValueRef rel_patch_id, invocation_id, tf_lds_offset;
 
-   si_copy_tcs_inputs(ctx);
-
    rel_patch_id = get_rel_patch_id(ctx);
    invocation_id = si_unpack_param(ctx, ctx->args.tcs_rel_ids, 8, 5);
    tf_lds_offset = get_tcs_out_current_patch_data_offset(ctx);
diff --git a/src/gallium/drivers/radeonsi/si_shaderlib_tgsi.c b/src/gallium/drivers/radeonsi/si_shaderlib_tgsi.c
index 045ea934cf49..0cc53483213e 100644
--- a/src/gallium/drivers/radeonsi/si_shaderlib_tgsi.c
+++ b/src/gallium/drivers/radeonsi/si_shaderlib_tgsi.c
@@ -81,33 +81,6 @@ void *si_get_blitter_vs(struct si_context *sctx, enum blitter_attrib_type type,
    return *vs;
 }
 
-/**
- * This is used when TCS is NULL in the VS->TCS->TES chain. In this case,
- * VS passes its outputs to TES directly, so the fixed-function shader only
- * has to write TESSOUTER and TESSINNER.
- */
-void *si_create_fixed_func_tcs(struct si_context *sctx)
-{
-   struct ureg_src outer, inner;
-   struct ureg_dst tessouter, tessinner;
-   struct ureg_program *ureg = ureg_create(PIPE_SHADER_TESS_CTRL);
-
-   if (!ureg)
-      return NULL;
-
-   outer = ureg_DECL_system_value(ureg, TGSI_SEMANTIC_TESS_DEFAULT_OUTER_LEVEL, 0);
-   inner = ureg_DECL_system_value(ureg, TGSI_SEMANTIC_TESS_DEFAULT_INNER_LEVEL, 0);
-
-   tessouter = ureg_DECL_output(ureg, TGSI_SEMANTIC_TESSOUTER, 0);
-   tessinner = ureg_DECL_output(ureg, TGSI_SEMANTIC_TESSINNER, 0);
-
-   ureg_MOV(ureg, tessouter, outer);
-   ureg_MOV(ureg, tessinner, inner);
-   ureg_END(ureg);
-
-   return ureg_create_shader_and_destroy(ureg, &sctx->b);
-}
-
 /* Create a compute shader implementing clear_buffer or copy_buffer. */
 void *si_create_dma_compute_shader(struct pipe_context *ctx, unsigned num_dwords_per_thread,
                                    bool dst_stream_cache_policy, bool is_copy)
diff --git a/src/gallium/drivers/radeonsi/si_state.h b/src/gallium/drivers/radeonsi/si_state.h
index ca8307031986..e48e16650545 100644
--- a/src/gallium/drivers/radeonsi/si_state.h
+++ b/src/gallium/drivers/radeonsi/si_state.h
@@ -597,6 +597,7 @@ void si_init_tess_factor_ring(struct si_context *sctx);
 bool si_update_gs_ring_buffers(struct si_context *sctx);
 bool si_update_spi_tmpring_size(struct si_context *sctx, unsigned bytes);
 unsigned si_calc_inst_pref_size(struct si_shader *shader);
+bool si_set_tcs_to_fixed_func_shader(struct si_context *sctx);
 
 /* si_state_draw.cpp */
 void si_cp_dma_prefetch(struct si_context *sctx, struct pipe_resource *buf,
diff --git a/src/gallium/drivers/radeonsi/si_state_draw.cpp b/src/gallium/drivers/radeonsi/si_state_draw.cpp
index 876d1a93e154..17ee16773267 100644
--- a/src/gallium/drivers/radeonsi/si_state_draw.cpp
+++ b/src/gallium/drivers/radeonsi/si_state_draw.cpp
@@ -126,28 +126,16 @@ static bool si_update_shaders(struct si_context *sctx)
             return false;
       }
 
-      if (sctx->shader.tcs.cso) {
-         r = si_shader_select(ctx, &sctx->shader.tcs);
-         if (r)
-            return false;
-         si_pm4_bind_state(sctx, hs, sctx->shader.tcs.current);
-      } else {
-         if (!sctx->fixed_func_tcs_shader.cso) {
-            sctx->fixed_func_tcs_shader.cso =
-               (struct si_shader_selector*)si_create_fixed_func_tcs(sctx);
-            if (!sctx->fixed_func_tcs_shader.cso)
-               return false;
-
-            sctx->fixed_func_tcs_shader.key.ge.part.tcs.epilog.invoc0_tess_factors_are_def =
-               sctx->fixed_func_tcs_shader.cso->info.tessfactors_are_def_in_all_invocs;
-         }
-
-         r = si_shader_select(ctx, &sctx->fixed_func_tcs_shader);
-         if (r)
+      if (!sctx->is_user_tcs) {
+         if (!si_set_tcs_to_fixed_func_shader(sctx))
             return false;
-         si_pm4_bind_state(sctx, hs, sctx->fixed_func_tcs_shader.current);
       }
 
+      r = si_shader_select(ctx, &sctx->shader.tcs);
+      if (r)
+         return false;
+      si_pm4_bind_state(sctx, hs, sctx->shader.tcs.current);
+
       if (!HAS_GS || GFX_VERSION <= GFX8) {
          r = si_shader_select(ctx, &sctx->shader.tes);
          if (r)
@@ -164,6 +152,10 @@ static bool si_update_shaders(struct si_context *sctx)
          }
       }
    } else {
+      /* Reset TCS to clear fixed function shader. */
+      sctx->shader.tcs.cso = NULL;
+      sctx->shader.tcs.current = NULL;
+
       if (GFX_VERSION <= GFX8) {
          si_pm4_bind_state(sctx, ls, NULL);
          sctx->prefetch_L2_mask &= ~SI_PREFETCH_LS;
@@ -626,10 +618,7 @@ static void si_emit_derived_tess_state(struct si_context *sctx, unsigned *num_pa
 {
    struct si_shader *ls_current;
    struct si_shader_selector *ls;
-   /* The TES pointer will only be used for sctx->last_tcs.
-    * It would be wrong to think that TCS = TES. */
-   struct si_shader_selector *tcs =
-      sctx->shader.tcs.cso ? sctx->shader.tcs.cso : sctx->shader.tes.cso;
+   struct si_shader_selector *tcs = sctx->shader.tcs.cso;
    unsigned tess_uses_primid = sctx->ia_multi_vgt_param_key.u.tess_uses_prim_id;
    bool has_primid_instancing_bug = sctx->gfx_level == GFX6 && sctx->screen->info.max_se == 1;
    unsigned tes_sh_base = sctx->shader_pointers.sh_base[PIPE_SHADER_TESS_EVAL];
@@ -637,11 +626,7 @@ static void si_emit_derived_tess_state(struct si_context *sctx, unsigned *num_pa
 
    /* Since GFX9 has merged LS-HS in the TCS state, set LS = TCS. */
    if (sctx->gfx_level >= GFX9) {
-      if (sctx->shader.tcs.cso)
-         ls_current = sctx->shader.tcs.current;
-      else
-         ls_current = sctx->fixed_func_tcs_shader.current;
-
+      ls_current = sctx->shader.tcs.current;
       ls = ls_current->key.ge.part.tcs.ls;
    } else {
       ls_current = sctx->shader.vs.current;
@@ -663,19 +648,9 @@ static void si_emit_derived_tess_state(struct si_context *sctx, unsigned *num_pa
 
    /* This calculates how shader inputs and outputs among VS, TCS, and TES
     * are laid out in LDS. */
-   unsigned num_tcs_inputs = util_last_bit64(ls->info.outputs_written);
-   unsigned num_tcs_output_cp, num_tcs_outputs, num_tcs_patch_outputs;
-
-   if (sctx->shader.tcs.cso) {
-      num_tcs_outputs = util_last_bit64(tcs->info.outputs_written);
-      num_tcs_output_cp = tcs->info.base.tess.tcs_vertices_out;
-      num_tcs_patch_outputs = util_last_bit64(tcs->info.patch_outputs_written);
-   } else {
-      /* No TCS. Route varyings from LS to TES. */
-      num_tcs_outputs = num_tcs_inputs;
-      num_tcs_output_cp = num_tcs_input_cp;
-      num_tcs_patch_outputs = 2; /* TESSINNER + TESSOUTER */
-   }
+   unsigned num_tcs_outputs = util_last_bit64(tcs->info.outputs_written);
+   unsigned num_tcs_output_cp = tcs->info.base.tess.tcs_vertices_out;
+   unsigned num_tcs_patch_outputs = util_last_bit64(tcs->info.patch_outputs_written);
 
    unsigned input_vertex_size = ls->info.lshs_vertex_stride;
    unsigned output_vertex_size = num_tcs_outputs * 16;
@@ -2223,34 +2198,44 @@ static void si_draw(struct pipe_context *ctx,
    si_need_gfx_cs_space(sctx, num_draws);
 
    if (HAS_TESS) {
-      struct si_shader_selector *tcs = sctx->shader.tcs.cso;
+      if (sctx->is_user_tcs) {
+         struct si_shader_selector *tcs = sctx->shader.tcs.cso;
 
-      /* The rarely occuring tcs == NULL case is not optimized. */
-      bool same_patch_vertices =
-         GFX_VERSION >= GFX9 &&
-         tcs && sctx->patch_vertices == tcs->info.base.tess.tcs_vertices_out;
+         bool same_patch_vertices =
+            GFX_VERSION >= GFX9 &&
+            sctx->patch_vertices == tcs->info.base.tess.tcs_vertices_out;
 
-      if (sctx->shader.tcs.key.ge.opt.same_patch_vertices != same_patch_vertices) {
-         sctx->shader.tcs.key.ge.opt.same_patch_vertices = same_patch_vertices;
-         sctx->do_update_shaders = true;
-      }
+         if (sctx->shader.tcs.key.ge.opt.same_patch_vertices != same_patch_vertices) {
+            sctx->shader.tcs.key.ge.opt.same_patch_vertices = same_patch_vertices;
+            sctx->do_update_shaders = true;
+         }
 
-      if (GFX_VERSION == GFX9 && sctx->screen->info.has_ls_vgpr_init_bug) {
-         /* Determine whether the LS VGPR fix should be applied.
-          *
-          * It is only required when num input CPs > num output CPs,
-          * which cannot happen with the fixed function TCS. We should
-          * also update this bit when switching from TCS to fixed
-          * function TCS.
+         if (GFX_VERSION == GFX9 && sctx->screen->info.has_ls_vgpr_init_bug) {
+            /* Determine whether the LS VGPR fix should be applied.
+             *
+             * It is only required when num input CPs > num output CPs,
+             * which cannot happen with the fixed function TCS.
+             */
+            bool ls_vgpr_fix =
+               sctx->patch_vertices > tcs->info.base.tess.tcs_vertices_out;
+
+            if (ls_vgpr_fix != sctx->shader.tcs.key.ge.part.tcs.ls_prolog.ls_vgpr_fix) {
+               sctx->shader.tcs.key.ge.part.tcs.ls_prolog.ls_vgpr_fix = ls_vgpr_fix;
+               sctx->do_update_shaders = true;
+            }
+         }
+      } else {
+         /* These fields are static for fixed function TCS. So no need to set
+          * do_update_shaders between fixed-TCS draws. As fixed-TCS to user-TCS
+          * or opposite, do_update_shaders should already be set by bind state.
           */
-         bool ls_vgpr_fix =
-            tcs && sctx->patch_vertices > tcs->info.base.tess.tcs_vertices_out;
+         sctx->shader.tcs.key.ge.opt.same_patch_vertices = GFX_VERSION >= GFX9;
+         sctx->shader.tcs.key.ge.part.tcs.ls_prolog.ls_vgpr_fix = false;
 
-         if (ls_vgpr_fix != sctx->shader.tcs.key.ge.part.tcs.ls_prolog.ls_vgpr_fix) {
-            sctx->shader.tcs.key.ge.part.tcs.ls_prolog.ls_vgpr_fix = ls_vgpr_fix;
-            sctx->fixed_func_tcs_shader.key.ge.part.tcs.ls_prolog.ls_vgpr_fix = ls_vgpr_fix;
+         /* User may only change patch vertices, needs to update fixed func TCS. */
+         if (sctx->shader.tcs.cso &&
+             sctx->shader.tcs.cso->info.base.tess.tcs_vertices_out != sctx->patch_vertices)
             sctx->do_update_shaders = true;
-         }
       }
    }
 
diff --git a/src/gallium/drivers/radeonsi/si_state_shaders.cpp b/src/gallium/drivers/radeonsi/si_state_shaders.cpp
index d2901c619398..2cd8e51e7643 100644
--- a/src/gallium/drivers/radeonsi/si_state_shaders.cpp
+++ b/src/gallium/drivers/radeonsi/si_state_shaders.cpp
@@ -3373,7 +3373,6 @@ static void si_bind_vs_shader(struct pipe_context *ctx, void *state)
    sctx->shader.vs.current = (sel && sel->variants_count) ? sel->variants[0] : NULL;
    sctx->num_vs_blit_sgprs = sel ? sel->info.base.vs.blit_sgprs_amd : 0;
    sctx->vs_uses_draw_id = sel ? sel->info.uses_drawid : false;
-   sctx->fixed_func_tcs_shader.key.ge.mono.u.ff_tcs_inputs_to_copy = sel ? sel->info.outputs_written : 0;
 
    if (si_update_ngg(sctx))
       si_shader_change_notify(sctx);
@@ -3486,6 +3485,11 @@ static void si_bind_tcs_shader(struct pipe_context *ctx, void *state)
    struct si_shader_selector *sel = (struct si_shader_selector*)state;
    bool enable_changed = !!sctx->shader.tcs.cso != !!sel;
 
+   /* Note it could happen that user shader sel is same as fixed function shader,
+    * so we should update this field even sctx->shader.tcs.cso == sel.
+    */
+   sctx->is_user_tcs = !!sel;
+
    if (sctx->shader.tcs.cso == sel)
       return;
 
@@ -3518,11 +3522,9 @@ static void si_bind_tes_shader(struct pipe_context *ctx, void *state)
    si_update_tess_uses_prim_id(sctx);
 
    sctx->shader.tcs.key.ge.part.tcs.epilog.prim_mode =
-   sctx->fixed_func_tcs_shader.key.ge.part.tcs.epilog.prim_mode =
       sel ? sel->info.base.tess._primitive_mode : 0;
 
    sctx->shader.tcs.key.ge.part.tcs.epilog.tes_reads_tess_factors =
-   sctx->fixed_func_tcs_shader.key.ge.part.tcs.epilog.tes_reads_tess_factors =
       sel ? sel->info.reads_tess_factors : 0;
 
    si_update_common_shader_state(sctx, sel, PIPE_SHADER_TESS_EVAL);
@@ -3976,17 +3978,8 @@ static int si_update_scratch_buffer(struct si_context *sctx, struct si_shader *s
    return 1;
 }
 
-static struct si_shader *si_get_tcs_current(struct si_context *sctx)
-{
-   if (!sctx->shader.tes.cso)
-      return NULL; /* tessellation disabled */
-
-   return sctx->shader.tcs.cso ? sctx->shader.tcs.current : sctx->fixed_func_tcs_shader.current;
-}
-
 static bool si_update_scratch_relocs(struct si_context *sctx)
 {
-   struct si_shader *tcs = si_get_tcs_current(sctx);
    int r;
 
    /* Update the shaders, so that they are using the latest scratch.
@@ -4006,11 +3999,11 @@ static bool si_update_scratch_relocs(struct si_context *sctx)
    if (r == 1)
       si_pm4_bind_state(sctx, gs, sctx->shader.gs.current);
 
-   r = si_update_scratch_buffer(sctx, tcs);
+   r = si_update_scratch_buffer(sctx, sctx->shader.tcs.current);
    if (r < 0)
       return false;
    if (r == 1)
-      si_pm4_bind_state(sctx, hs, tcs);
+      si_pm4_bind_state(sctx, hs, sctx->shader.tcs.current);
 
    /* VS can be bound as LS, ES, or VS. */
    r = si_update_scratch_buffer(sctx, sctx->shader.vs.current);
@@ -4251,6 +4244,53 @@ static void si_emit_scratch_state(struct si_context *sctx)
    }
 }
 
+struct si_fixed_func_tcs_shader_key {
+   uint64_t outputs_written;
+   uint8_t vertices_out;
+};
+
+static uint32_t si_fixed_func_tcs_shader_key_hash(const void *key)
+{
+   return _mesa_hash_data(key, sizeof(struct si_fixed_func_tcs_shader_key));
+}
+
+static bool si_fixed_func_tcs_shader_key_equals(const void *a, const void *b)
+{
+   return memcmp(a, b, sizeof(struct si_fixed_func_tcs_shader_key)) == 0;
+}
+
+bool si_set_tcs_to_fixed_func_shader(struct si_context *sctx)
+{
+   if (!sctx->fixed_func_tcs_shader_cache) {
+      sctx->fixed_func_tcs_shader_cache = _mesa_hash_table_create(
+         NULL, si_fixed_func_tcs_shader_key_hash,
+         si_fixed_func_tcs_shader_key_equals);
+   }
+
+   struct si_fixed_func_tcs_shader_key key;
+   key.outputs_written = sctx->shader.vs.cso->info.outputs_written;
+   key.vertices_out = sctx->patch_vertices;
+
+   struct hash_entry *entry = _mesa_hash_table_search(
+      sctx->fixed_func_tcs_shader_cache, &key);
+
+   struct si_shader_selector *tcs;
+   if (entry)
+      tcs = (struct si_shader_selector *)entry->data;
+   else {
+      tcs = (struct si_shader_selector *)si_create_passthrough_tcs(sctx);
+      if (!tcs)
+         return false;
+      _mesa_hash_table_insert(sctx->fixed_func_tcs_shader_cache, &key, (void *)tcs);
+   }
+
+   sctx->shader.tcs.cso = tcs;
+   sctx->shader.tcs.key.ge.part.tcs.epilog.invoc0_tess_factors_are_def =
+      tcs->info.tessfactors_are_def_in_all_invocs;
+
+   return true;
+}
+
 void si_init_screen_live_shader_cache(struct si_screen *sscreen)
 {
    util_live_shader_cache_init(&sscreen->live_shader_cache, si_create_shader_selector,
-- 
GitLab


From c76f4ee75bcefcf11abd6c18ecb6deb42bd85b21 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Mon, 23 May 2022 14:42:06 +0800
Subject: [PATCH 06/30] radeonsi: implement
 nir_intrinsic_load_tcs_num_patches_amd
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Used by ac_nir_lower_tess_io_to_mem.c.

Acked-by: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
Reviewed-by: Timur Kristóf <timur.kristof@gmail.com>
Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/amd/llvm/ac_nir_to_llvm.c                 | 1 +
 src/gallium/drivers/radeonsi/si_shader_llvm.c | 5 +++++
 2 files changed, 6 insertions(+)

diff --git a/src/amd/llvm/ac_nir_to_llvm.c b/src/amd/llvm/ac_nir_to_llvm.c
index 074774e982f0..4ceaa7fe1a44 100644
--- a/src/amd/llvm/ac_nir_to_llvm.c
+++ b/src/amd/llvm/ac_nir_to_llvm.c
@@ -3637,6 +3637,7 @@ static void visit_intrinsic(struct ac_nir_context *ctx, nir_intrinsic_instr *ins
    case nir_intrinsic_load_ring_tess_offchip_amd:
    case nir_intrinsic_load_ring_esgs_amd:
    case nir_intrinsic_load_lshs_vertex_stride_amd:
+   case nir_intrinsic_load_tcs_num_patches_amd:
       result = ctx->abi->intrinsic_load(ctx->abi, instr->intrinsic);
       break;
    case nir_intrinsic_load_vertex_id:
diff --git a/src/gallium/drivers/radeonsi/si_shader_llvm.c b/src/gallium/drivers/radeonsi/si_shader_llvm.c
index 5e9b3d441ab2..dd48b83cf6bf 100644
--- a/src/gallium/drivers/radeonsi/si_shader_llvm.c
+++ b/src/gallium/drivers/radeonsi/si_shader_llvm.c
@@ -780,6 +780,11 @@ static LLVMValueRef si_llvm_load_intrinsic(struct ac_shader_abi *abi, nir_intrin
       return LLVMBuildShl(ctx->ac.builder, si_get_tcs_in_vertex_dw_stride(ctx),
                           LLVMConstInt(ctx->ac.i32, 2, 0), "");
 
+   case nir_intrinsic_load_tcs_num_patches_amd:
+      return LLVMBuildAdd(ctx->ac.builder,
+                          si_unpack_param(ctx, ctx->tcs_offchip_layout, 0, 6),
+                          ctx->ac.i32_1, "");
+
    default:
       return NULL;
    }
-- 
GitLab


From 63b4d6c7972b94cabbc976b6f85d41367acc2e0b Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Mon, 23 May 2022 16:25:15 +0800
Subject: [PATCH 07/30] ac/nir: remove unused parameter in tes input lower
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Acked-by: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
Reviewed-by: Timur Kristóf <timur.kristof@gmail.com>
Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/amd/common/ac_nir.h                      | 3 +--
 src/amd/common/ac_nir_lower_tess_io_to_mem.c | 4 +---
 src/amd/vulkan/radv_shader.c                 | 3 +--
 3 files changed, 3 insertions(+), 7 deletions(-)

diff --git a/src/amd/common/ac_nir.h b/src/amd/common/ac_nir.h
index a532db6e2894..2e089f12ce67 100644
--- a/src/amd/common/ac_nir.h
+++ b/src/amd/common/ac_nir.h
@@ -94,8 +94,7 @@ ac_nir_lower_hs_outputs_to_mem(nir_shader *shader,
 void
 ac_nir_lower_tes_inputs_to_mem(nir_shader *shader,
                                ac_nir_map_io_driver_location map,
-                               unsigned num_reserved_tcs_outputs,
-                               unsigned num_reserved_tcs_patch_outputs);
+                               unsigned num_reserved_tcs_outputs);
 
 void
 ac_nir_lower_es_outputs_to_mem(nir_shader *shader,
diff --git a/src/amd/common/ac_nir_lower_tess_io_to_mem.c b/src/amd/common/ac_nir_lower_tess_io_to_mem.c
index bb886f4c38c0..6d72f83faa0b 100644
--- a/src/amd/common/ac_nir_lower_tess_io_to_mem.c
+++ b/src/amd/common/ac_nir_lower_tess_io_to_mem.c
@@ -725,14 +725,12 @@ ac_nir_lower_hs_outputs_to_mem(nir_shader *shader,
 void
 ac_nir_lower_tes_inputs_to_mem(nir_shader *shader,
                                ac_nir_map_io_driver_location map,
-                               unsigned num_reserved_tcs_outputs,
-                               unsigned num_reserved_tcs_patch_outputs)
+                               unsigned num_reserved_tcs_outputs)
 {
    assert(shader->info.stage == MESA_SHADER_TESS_EVAL);
 
    lower_tess_io_state state = {
       .tcs_num_reserved_outputs = num_reserved_tcs_outputs,
-      .tcs_num_reserved_patch_outputs = num_reserved_tcs_patch_outputs,
       .map_io = map,
    };
 
diff --git a/src/amd/vulkan/radv_shader.c b/src/amd/vulkan/radv_shader.c
index 178ca2bf3e3e..48c1db8d7d19 100644
--- a/src/amd/vulkan/radv_shader.c
+++ b/src/amd/vulkan/radv_shader.c
@@ -1080,8 +1080,7 @@ radv_lower_io_to_mem(struct radv_device *device, struct radv_pipeline_stage *sta
 
       return true;
    } else if (nir->info.stage == MESA_SHADER_TESS_EVAL) {
-      NIR_PASS_V(nir, ac_nir_lower_tes_inputs_to_mem, NULL, info->tes.num_linked_inputs,
-                 info->tes.num_linked_patch_inputs);
+      NIR_PASS_V(nir, ac_nir_lower_tes_inputs_to_mem, NULL, info->tes.num_linked_inputs);
 
       if (info->tes.as_es) {
          NIR_PASS_V(nir, ac_nir_lower_es_outputs_to_mem, NULL,
-- 
GitLab


From edf27440d10a67121d5ed656c31f27699a9db92e Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Mon, 23 May 2022 17:23:57 +0800
Subject: [PATCH 08/30] ac/nir: add
 nir_intrinsic_load_hs_out_patch_data_offset_amd
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Also add radv and radeonsi implementation. Will be used in tess lowering.

Acked-by: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
Reviewed-by: Timur Kristóf <timur.kristof@gmail.com>
Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/amd/llvm/ac_nir_to_llvm.c                 |  1 +
 src/amd/vulkan/radv_nir_lower_abi.c           | 12 +++++++++++-
 src/compiler/nir/nir_divergence_analysis.c    |  1 +
 src/compiler/nir/nir_intrinsics.py            |  3 +++
 src/gallium/drivers/radeonsi/si_shader_llvm.c |  3 +++
 5 files changed, 19 insertions(+), 1 deletion(-)

diff --git a/src/amd/llvm/ac_nir_to_llvm.c b/src/amd/llvm/ac_nir_to_llvm.c
index 4ceaa7fe1a44..9c93d9e30d04 100644
--- a/src/amd/llvm/ac_nir_to_llvm.c
+++ b/src/amd/llvm/ac_nir_to_llvm.c
@@ -3638,6 +3638,7 @@ static void visit_intrinsic(struct ac_nir_context *ctx, nir_intrinsic_instr *ins
    case nir_intrinsic_load_ring_esgs_amd:
    case nir_intrinsic_load_lshs_vertex_stride_amd:
    case nir_intrinsic_load_tcs_num_patches_amd:
+   case nir_intrinsic_load_hs_out_patch_data_offset_amd:
       result = ctx->abi->intrinsic_load(ctx->abi, instr->intrinsic);
       break;
    case nir_intrinsic_load_vertex_id:
diff --git a/src/amd/vulkan/radv_nir_lower_abi.c b/src/amd/vulkan/radv_nir_lower_abi.c
index 3aac76bf5669..0cd9fece9478 100644
--- a/src/amd/vulkan/radv_nir_lower_abi.c
+++ b/src/amd/vulkan/radv_nir_lower_abi.c
@@ -197,6 +197,15 @@ lower_abi_instr(nir_builder *b, nir_instr *instr, void *state)
       return nir_imm_int(b, io_num * 16);
    }
 
+   case nir_intrinsic_load_hs_out_patch_data_offset_amd: {
+      unsigned num_patches = s->info->num_tess_patches;
+      unsigned out_vertices_per_patch = b->shader->info.tess.tcs_vertices_out;
+      unsigned num_tcs_outputs = stage == MESA_SHADER_TESS_CTRL ?
+         s->info->tcs.num_linked_outputs : s->info->tes.num_linked_inputs;
+      int per_vertex_output_patch_size = out_vertices_per_patch * num_tcs_outputs * 16u;
+      return nir_imm_int(b, num_patches * per_vertex_output_patch_size);
+   }
+
    default:
       unreachable("invalid NIR RADV ABI intrinsic.");
    }
@@ -243,7 +252,8 @@ filter_abi_instr(const nir_instr *instr,
           intrin->intrinsic == nir_intrinsic_load_task_ring_entry_amd ||
           intrin->intrinsic == nir_intrinsic_load_task_ib_addr ||
           intrin->intrinsic == nir_intrinsic_load_task_ib_stride ||
-          intrin->intrinsic == nir_intrinsic_load_lshs_vertex_stride_amd;
+          intrin->intrinsic == nir_intrinsic_load_lshs_vertex_stride_amd ||
+          intrin->intrinsic == nir_intrinsic_load_hs_out_patch_data_offset_amd;
 }
 
 void
diff --git a/src/compiler/nir/nir_divergence_analysis.c b/src/compiler/nir/nir_divergence_analysis.c
index 48033cc8235f..6099e931b208 100644
--- a/src/compiler/nir/nir_divergence_analysis.c
+++ b/src/compiler/nir/nir_divergence_analysis.c
@@ -180,6 +180,7 @@ visit_intrinsic(nir_shader *shader, nir_intrinsic_instr *instr)
    case nir_intrinsic_load_mesh_inline_data_intel:
    case nir_intrinsic_load_ray_num_dss_rt_stacks_intel:
    case nir_intrinsic_load_lshs_vertex_stride_amd:
+   case nir_intrinsic_load_hs_out_patch_data_offset_amd:
       is_divergent = false;
       break;
 
diff --git a/src/compiler/nir/nir_intrinsics.py b/src/compiler/nir/nir_intrinsics.py
index b5995947f693..197ae599bb3f 100644
--- a/src/compiler/nir/nir_intrinsics.py
+++ b/src/compiler/nir/nir_intrinsics.py
@@ -1399,6 +1399,9 @@ intrinsic("store_shared2_amd", [2, 1], indices=[OFFSET0, OFFSET1, ST64])
 # Vertex stride in LS-HS buffer
 system_value("lshs_vertex_stride_amd", 1)
 
+# Per patch data offset in HS VRAM output buffer
+system_value("hs_out_patch_data_offset_amd", 1)
+
 # V3D-specific instrinc for tile buffer color reads.
 #
 # The hardware requires that we read the samples and components of a pixel
diff --git a/src/gallium/drivers/radeonsi/si_shader_llvm.c b/src/gallium/drivers/radeonsi/si_shader_llvm.c
index dd48b83cf6bf..e00aeda422ea 100644
--- a/src/gallium/drivers/radeonsi/si_shader_llvm.c
+++ b/src/gallium/drivers/radeonsi/si_shader_llvm.c
@@ -785,6 +785,9 @@ static LLVMValueRef si_llvm_load_intrinsic(struct ac_shader_abi *abi, nir_intrin
                           si_unpack_param(ctx, ctx->tcs_offchip_layout, 0, 6),
                           ctx->ac.i32_1, "");
 
+   case nir_intrinsic_load_hs_out_patch_data_offset_amd:
+      return si_unpack_param(ctx, ctx->tcs_offchip_layout, 11, 21);
+
    default:
       return NULL;
    }
-- 
GitLab


From fdb2001bc16e6ab7c147527bf640bffb6a5330b6 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Mon, 23 May 2022 17:26:00 +0800
Subject: [PATCH 09/30] ac/nir: use
 nir_intrinsic_load_hs_out_patch_data_offset_amd in tess lower
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

radeonsi load this from SGPR arg, can't use static value because TCS output
and TES input may not match (TCS output is not a key for TES) and
determined in runtime.

Acked-by: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
Reviewed-by: Timur Kristóf <timur.kristof@gmail.com>
Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/amd/common/ac_nir.h                      |  3 +--
 src/amd/common/ac_nir_lower_tess_io_to_mem.c | 13 +++----------
 src/amd/vulkan/radv_shader.c                 |  2 +-
 3 files changed, 5 insertions(+), 13 deletions(-)

diff --git a/src/amd/common/ac_nir.h b/src/amd/common/ac_nir.h
index 2e089f12ce67..d52e9fbe5c1d 100644
--- a/src/amd/common/ac_nir.h
+++ b/src/amd/common/ac_nir.h
@@ -93,8 +93,7 @@ ac_nir_lower_hs_outputs_to_mem(nir_shader *shader,
 
 void
 ac_nir_lower_tes_inputs_to_mem(nir_shader *shader,
-                               ac_nir_map_io_driver_location map,
-                               unsigned num_reserved_tcs_outputs);
+                               ac_nir_map_io_driver_location map);
 
 void
 ac_nir_lower_es_outputs_to_mem(nir_shader *shader,
diff --git a/src/amd/common/ac_nir_lower_tess_io_to_mem.c b/src/amd/common/ac_nir_lower_tess_io_to_mem.c
index 6d72f83faa0b..f3c3fc2ec1f0 100644
--- a/src/amd/common/ac_nir_lower_tess_io_to_mem.c
+++ b/src/amd/common/ac_nir_lower_tess_io_to_mem.c
@@ -107,7 +107,7 @@
  * attr 1 of patch 0 vertex 2
  * ...
  * ...
- * per-patch attr 0 of patch 0
+ * per-patch attr 0 of patch 0  <─── hs_out_patch_data_offset_amd
  * per-patch attr 0 of patch 1
  * per-patch attr 0 of patch 2  <─── hs_per_patch_output_vmem_offset (attribute slot = 0, rel_patch_id = 2)
  * ...
@@ -373,13 +373,8 @@ hs_per_patch_output_vmem_offset(nir_builder *b,
                                 nir_intrinsic_instr *intrin,
                                 unsigned const_base_offset)
 {
-   nir_ssa_def *out_vertices_per_patch = b->shader->info.stage == MESA_SHADER_TESS_CTRL
-                                         ? nir_imm_int(b, b->shader->info.tess.tcs_vertices_out)
-                                         : nir_load_patch_vertices_in(b);
-
    nir_ssa_def *tcs_num_patches = nir_load_tcs_num_patches_amd(b);
-   nir_ssa_def *per_vertex_output_patch_size = nir_imul_imm(b, out_vertices_per_patch, st->tcs_num_reserved_outputs * 16u);
-   nir_ssa_def *per_patch_data_offset = nir_imul(b, tcs_num_patches, per_vertex_output_patch_size);
+   nir_ssa_def *per_patch_data_offset = nir_load_hs_out_patch_data_offset_amd(b);
 
    nir_ssa_def * off = intrin
                     ? ac_nir_calc_io_offset(b, intrin, nir_imul_imm(b, tcs_num_patches, 16u), 4u, st->map_io)
@@ -724,13 +719,11 @@ ac_nir_lower_hs_outputs_to_mem(nir_shader *shader,
 
 void
 ac_nir_lower_tes_inputs_to_mem(nir_shader *shader,
-                               ac_nir_map_io_driver_location map,
-                               unsigned num_reserved_tcs_outputs)
+                               ac_nir_map_io_driver_location map)
 {
    assert(shader->info.stage == MESA_SHADER_TESS_EVAL);
 
    lower_tess_io_state state = {
-      .tcs_num_reserved_outputs = num_reserved_tcs_outputs,
       .map_io = map,
    };
 
diff --git a/src/amd/vulkan/radv_shader.c b/src/amd/vulkan/radv_shader.c
index 48c1db8d7d19..1d740ec38421 100644
--- a/src/amd/vulkan/radv_shader.c
+++ b/src/amd/vulkan/radv_shader.c
@@ -1080,7 +1080,7 @@ radv_lower_io_to_mem(struct radv_device *device, struct radv_pipeline_stage *sta
 
       return true;
    } else if (nir->info.stage == MESA_SHADER_TESS_EVAL) {
-      NIR_PASS_V(nir, ac_nir_lower_tes_inputs_to_mem, NULL, info->tes.num_linked_inputs);
+      NIR_PASS_V(nir, ac_nir_lower_tes_inputs_to_mem, NULL);
 
       if (info->tes.as_es) {
          NIR_PASS_V(nir, ac_nir_lower_es_outputs_to_mem, NULL,
-- 
GitLab


From e8609c2a0dbbe3ef666ef2ad054034d059f85f1a Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Mon, 23 May 2022 20:27:55 +0800
Subject: [PATCH 10/30] ac/nir: add pass_tessfactors_by_reg param to hs output
 lower
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

radeonsi won't emit tess factor in the lower pass, need to keep
the output for llvm backend to pass it as parameter. This is used
by radeonsi for an optimization to save LDS write.

Acked-by: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
Reviewed-by: Timur Kristóf <timur.kristof@gmail.com>
Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/amd/common/ac_nir.h                      |  1 +
 src/amd/common/ac_nir_lower_tess_io_to_mem.c | 22 ++++++++++++++++----
 src/amd/vulkan/radv_shader.c                 |  2 +-
 3 files changed, 20 insertions(+), 5 deletions(-)

diff --git a/src/amd/common/ac_nir.h b/src/amd/common/ac_nir.h
index d52e9fbe5c1d..f06a7c70634f 100644
--- a/src/amd/common/ac_nir.h
+++ b/src/amd/common/ac_nir.h
@@ -89,6 +89,7 @@ ac_nir_lower_hs_outputs_to_mem(nir_shader *shader,
                                uint64_t tes_patch_inputs_read,
                                unsigned num_reserved_tcs_outputs,
                                unsigned num_reserved_tcs_patch_outputs,
+                               bool pass_tessfactors_by_reg,
                                bool emit_tess_factor_write);
 
 void
diff --git a/src/amd/common/ac_nir_lower_tess_io_to_mem.c b/src/amd/common/ac_nir_lower_tess_io_to_mem.c
index f3c3fc2ec1f0..0da9cdefb9c6 100644
--- a/src/amd/common/ac_nir_lower_tess_io_to_mem.c
+++ b/src/amd/common/ac_nir_lower_tess_io_to_mem.c
@@ -154,6 +154,11 @@ typedef struct {
     * subgroup that reads them.
     */
    bool tcs_out_patch_fits_subgroup;
+
+   /* Set if all invocations will write to all tess factors, so tess factors
+    * can be passed by register.
+    */
+   bool tcs_pass_tessfactors_by_reg;
 } lower_tess_io_state;
 
 static bool
@@ -402,7 +407,7 @@ lower_hs_per_vertex_input_load(nir_builder *b,
                           .align_mul = 16u, .align_offset = (nir_intrinsic_component(intrin) * 4u) % 16u);
 }
 
-static void
+static nir_ssa_def *
 lower_hs_output_store(nir_builder *b,
                       nir_intrinsic_instr *intrin,
                       lower_tess_io_state *st)
@@ -416,7 +421,8 @@ lower_hs_output_store(nir_builder *b,
    bool is_tess_factor = semantics.location == VARYING_SLOT_TESS_LEVEL_INNER ||
                          semantics.location == VARYING_SLOT_TESS_LEVEL_OUTER;
    bool write_to_vmem = !is_tess_factor && tcs_output_needs_vmem(intrin, st);
-   bool write_to_lds = is_tess_factor || tcs_output_needs_lds(intrin, b->shader);
+   bool write_to_lds = (is_tess_factor && !st->tcs_pass_tessfactors_by_reg) ||
+      tcs_output_needs_lds(intrin, b->shader);
 
    if (write_to_vmem) {
       nir_ssa_def *vmem_off = intrin->intrinsic == nir_intrinsic_store_per_vertex_output
@@ -439,6 +445,13 @@ lower_hs_output_store(nir_builder *b,
       nir_store_shared(b, store_val, lds_off, .write_mask = write_mask,
                        .align_mul = 16u, .align_offset = (nir_intrinsic_component(intrin) * 4u) % 16u);
    }
+
+   /* Keep tess factor nir_store_output instruction if it's going to be passed
+    * by reg instead of LDS, because it's used by radeonsi llvm backend to generate
+    * llvm variable which is read by the final llvm tess factor write epilog.
+    */
+   return is_tess_factor && st->tcs_pass_tessfactors_by_reg ?
+      NIR_LOWER_INSTR_PROGRESS : NIR_LOWER_INSTR_PROGRESS_REPLACE;
 }
 
 static nir_ssa_def *
@@ -481,8 +494,7 @@ lower_hs_output_access(nir_builder *b,
 
    if (intrin->intrinsic == nir_intrinsic_store_output ||
        intrin->intrinsic == nir_intrinsic_store_per_vertex_output) {
-      lower_hs_output_store(b, intrin, st);
-      return NIR_LOWER_INSTR_PROGRESS_REPLACE;
+      return lower_hs_output_store(b, intrin, st);
    } else if (intrin->intrinsic == nir_intrinsic_load_output ||
               intrin->intrinsic == nir_intrinsic_load_per_vertex_output) {
       return lower_hs_output_load(b, intrin, st);
@@ -693,6 +705,7 @@ ac_nir_lower_hs_outputs_to_mem(nir_shader *shader,
                                uint64_t tes_patch_inputs_read,
                                unsigned num_reserved_tcs_outputs,
                                unsigned num_reserved_tcs_patch_outputs,
+                               bool pass_tessfactors_by_reg,
                                bool emit_tess_factor_write)
 {
    assert(shader->info.stage == MESA_SHADER_TESS_CTRL);
@@ -705,6 +718,7 @@ ac_nir_lower_hs_outputs_to_mem(nir_shader *shader,
       .tcs_num_reserved_outputs = num_reserved_tcs_outputs,
       .tcs_num_reserved_patch_outputs = num_reserved_tcs_patch_outputs,
       .tcs_out_patch_fits_subgroup = 32 % shader->info.tess.tcs_vertices_out == 0,
+      .tcs_pass_tessfactors_by_reg = pass_tessfactors_by_reg,
       .map_io = map,
    };
 
diff --git a/src/amd/vulkan/radv_shader.c b/src/amd/vulkan/radv_shader.c
index 1d740ec38421..0e0aacd487e3 100644
--- a/src/amd/vulkan/radv_shader.c
+++ b/src/amd/vulkan/radv_shader.c
@@ -1076,7 +1076,7 @@ radv_lower_io_to_mem(struct radv_device *device, struct radv_pipeline_stage *sta
                  device->physical_device->rad_info.gfx_level,
                  info->tcs.tes_reads_tess_factors, info->tcs.tes_inputs_read,
                  info->tcs.tes_patch_inputs_read, info->tcs.num_linked_outputs,
-                 info->tcs.num_linked_patch_outputs, true);
+                 info->tcs.num_linked_patch_outputs, false, true);
 
       return true;
    } else if (nir->info.stage == MESA_SHADER_TESS_EVAL) {
-- 
GitLab


From d41d40f74a6e1d37f290fb38e3babfa23d266d4f Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Fri, 27 May 2022 17:39:18 +0800
Subject: [PATCH 11/30] ac/nir: add wave_size parameter to
 ac_nir_lower_hs_outputs_to_mem
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Used by radeonsi and radv to reflect true wave size used, not minimal size.

Acked-by: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
Reviewed-by: Timur Kristóf <timur.kristof@gmail.com>
Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/amd/common/ac_nir.h                      | 1 +
 src/amd/common/ac_nir_lower_tess_io_to_mem.c | 3 ++-
 src/amd/vulkan/radv_shader.c                 | 2 +-
 3 files changed, 4 insertions(+), 2 deletions(-)

diff --git a/src/amd/common/ac_nir.h b/src/amd/common/ac_nir.h
index f06a7c70634f..c6e08bce0a24 100644
--- a/src/amd/common/ac_nir.h
+++ b/src/amd/common/ac_nir.h
@@ -89,6 +89,7 @@ ac_nir_lower_hs_outputs_to_mem(nir_shader *shader,
                                uint64_t tes_patch_inputs_read,
                                unsigned num_reserved_tcs_outputs,
                                unsigned num_reserved_tcs_patch_outputs,
+                               unsigned wave_size,
                                bool pass_tessfactors_by_reg,
                                bool emit_tess_factor_write);
 
diff --git a/src/amd/common/ac_nir_lower_tess_io_to_mem.c b/src/amd/common/ac_nir_lower_tess_io_to_mem.c
index 0da9cdefb9c6..d2ce7c114798 100644
--- a/src/amd/common/ac_nir_lower_tess_io_to_mem.c
+++ b/src/amd/common/ac_nir_lower_tess_io_to_mem.c
@@ -705,6 +705,7 @@ ac_nir_lower_hs_outputs_to_mem(nir_shader *shader,
                                uint64_t tes_patch_inputs_read,
                                unsigned num_reserved_tcs_outputs,
                                unsigned num_reserved_tcs_patch_outputs,
+                               unsigned wave_size,
                                bool pass_tessfactors_by_reg,
                                bool emit_tess_factor_write)
 {
@@ -717,7 +718,7 @@ ac_nir_lower_hs_outputs_to_mem(nir_shader *shader,
       .tes_patch_inputs_read = tes_patch_inputs_read,
       .tcs_num_reserved_outputs = num_reserved_tcs_outputs,
       .tcs_num_reserved_patch_outputs = num_reserved_tcs_patch_outputs,
-      .tcs_out_patch_fits_subgroup = 32 % shader->info.tess.tcs_vertices_out == 0,
+      .tcs_out_patch_fits_subgroup = wave_size % shader->info.tess.tcs_vertices_out == 0,
       .tcs_pass_tessfactors_by_reg = pass_tessfactors_by_reg,
       .map_io = map,
    };
diff --git a/src/amd/vulkan/radv_shader.c b/src/amd/vulkan/radv_shader.c
index 0e0aacd487e3..1a7f88c6b56d 100644
--- a/src/amd/vulkan/radv_shader.c
+++ b/src/amd/vulkan/radv_shader.c
@@ -1076,7 +1076,7 @@ radv_lower_io_to_mem(struct radv_device *device, struct radv_pipeline_stage *sta
                  device->physical_device->rad_info.gfx_level,
                  info->tcs.tes_reads_tess_factors, info->tcs.tes_inputs_read,
                  info->tcs.tes_patch_inputs_read, info->tcs.num_linked_outputs,
-                 info->tcs.num_linked_patch_outputs, false, true);
+                 info->tcs.num_linked_patch_outputs, info->wave_size, false, true);
 
       return true;
    } else if (nir->info.stage == MESA_SHADER_TESS_EVAL) {
-- 
GitLab


From 0853b3f40a505daccd2a0787868afc3e3aece59e Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Tue, 24 May 2022 14:40:05 +0800
Subject: [PATCH 12/30] radeonsi: preload tess offchip ring for tcs

Acked-by: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
Sigend-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/gallium/drivers/radeonsi/si_shader_internal.h  | 2 +-
 src/gallium/drivers/radeonsi/si_shader_llvm.c      | 3 ++-
 src/gallium/drivers/radeonsi/si_shader_llvm_tess.c | 7 ++++---
 3 files changed, 7 insertions(+), 5 deletions(-)

diff --git a/src/gallium/drivers/radeonsi/si_shader_internal.h b/src/gallium/drivers/radeonsi/si_shader_internal.h
index 3860095e4ba3..8f41bd43c873 100644
--- a/src/gallium/drivers/radeonsi/si_shader_internal.h
+++ b/src/gallium/drivers/radeonsi/si_shader_internal.h
@@ -244,7 +244,7 @@ void si_llvm_init_gs_callbacks(struct si_shader_context *ctx);
 /* si_shader_llvm_tess.c */
 LLVMValueRef si_get_tcs_in_vertex_dw_stride(struct si_shader_context *ctx);
 LLVMValueRef si_get_num_tcs_out_vertices(struct si_shader_context *ctx);
-void si_llvm_preload_tes_rings(struct si_shader_context *ctx);
+void si_llvm_preload_tess_rings(struct si_shader_context *ctx);
 void si_llvm_ls_build_end(struct si_shader_context *ctx);
 void si_llvm_build_tcs_epilog(struct si_shader_context *ctx, union si_shader_part_key *key);
 void si_llvm_tcs_build_end(struct si_shader_context *ctx);
diff --git a/src/gallium/drivers/radeonsi/si_shader_llvm.c b/src/gallium/drivers/radeonsi/si_shader_llvm.c
index e00aeda422ea..7b0f371ba0d1 100644
--- a/src/gallium/drivers/radeonsi/si_shader_llvm.c
+++ b/src/gallium/drivers/radeonsi/si_shader_llvm.c
@@ -824,6 +824,7 @@ bool si_llvm_translate_nir(struct si_shader_context *ctx, struct si_shader *shad
 
    case MESA_SHADER_TESS_CTRL:
       si_llvm_init_tcs_callbacks(ctx);
+      si_llvm_preload_tess_rings(ctx);
 
       if (sel->info.tessfactors_are_def_in_all_invocs) {
          for (unsigned i = 0; i < 6; i++)
@@ -833,7 +834,7 @@ bool si_llvm_translate_nir(struct si_shader_context *ctx, struct si_shader *shad
 
    case MESA_SHADER_TESS_EVAL:
       si_llvm_init_tes_callbacks(ctx, ngg_cull_shader);
-      si_llvm_preload_tes_rings(ctx);
+      si_llvm_preload_tess_rings(ctx);
       break;
 
    case MESA_SHADER_GEOMETRY:
diff --git a/src/gallium/drivers/radeonsi/si_shader_llvm_tess.c b/src/gallium/drivers/radeonsi/si_shader_llvm_tess.c
index 9ef5e241d507..49b2cc614f73 100644
--- a/src/gallium/drivers/radeonsi/si_shader_llvm_tess.c
+++ b/src/gallium/drivers/radeonsi/si_shader_llvm_tess.c
@@ -370,9 +370,10 @@ static LLVMValueRef get_tess_ring_descriptor(struct si_shader_context *ctx, enum
    return ac_build_gather_values(&ctx->ac, desc, 4);
 }
 
-void si_llvm_preload_tes_rings(struct si_shader_context *ctx)
+void si_llvm_preload_tess_rings(struct si_shader_context *ctx)
 {
-   ctx->tess_offchip_ring = get_tess_ring_descriptor(ctx, TESS_OFFCHIP_RING_TES);
+   ctx->tess_offchip_ring = get_tess_ring_descriptor(
+      ctx, ctx->stage == MESA_SHADER_TESS_CTRL ? TESS_OFFCHIP_RING_TCS : TESS_OFFCHIP_RING_TES);
 }
 
 static LLVMValueRef si_nir_load_tcs_varyings(struct ac_shader_abi *abi, LLVMTypeRef type,
@@ -498,7 +499,7 @@ static void si_nir_store_output_tcs(struct ac_shader_abi *abi,
       }
    }
 
-   buffer = get_tess_ring_descriptor(ctx, TESS_OFFCHIP_RING_TCS);
+   buffer = ctx->tess_offchip_ring;
 
    base = ac_get_arg(&ctx->ac, ctx->args.tess_offchip_offset);
 
-- 
GitLab


From 3cc9ef9f6fc4ab88fb233650251506a0b5accebd Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Tue, 24 May 2022 14:43:36 +0800
Subject: [PATCH 13/30] radeonsi: implement
 nir_intrinsic_load_ring_tess_offchip(_offset)_amd
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Used by tess lower latter.

Acked-by: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
Reviewed-by: Timur Kristóf <timur.kristof@gmail.com>
Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/amd/llvm/ac_nir_to_llvm.c                 | 1 +
 src/gallium/drivers/radeonsi/si_shader_llvm.c | 6 ++++++
 2 files changed, 7 insertions(+)

diff --git a/src/amd/llvm/ac_nir_to_llvm.c b/src/amd/llvm/ac_nir_to_llvm.c
index 9c93d9e30d04..793164a980c0 100644
--- a/src/amd/llvm/ac_nir_to_llvm.c
+++ b/src/amd/llvm/ac_nir_to_llvm.c
@@ -3635,6 +3635,7 @@ static void visit_intrinsic(struct ac_nir_context *ctx, nir_intrinsic_instr *ins
    case nir_intrinsic_load_sample_mask_in:
    case nir_intrinsic_load_ring_tess_factors_amd:
    case nir_intrinsic_load_ring_tess_offchip_amd:
+   case nir_intrinsic_load_ring_tess_offchip_offset_amd:
    case nir_intrinsic_load_ring_esgs_amd:
    case nir_intrinsic_load_lshs_vertex_stride_amd:
    case nir_intrinsic_load_tcs_num_patches_amd:
diff --git a/src/gallium/drivers/radeonsi/si_shader_llvm.c b/src/gallium/drivers/radeonsi/si_shader_llvm.c
index 7b0f371ba0d1..136a28d3cd3e 100644
--- a/src/gallium/drivers/radeonsi/si_shader_llvm.c
+++ b/src/gallium/drivers/radeonsi/si_shader_llvm.c
@@ -788,6 +788,12 @@ static LLVMValueRef si_llvm_load_intrinsic(struct ac_shader_abi *abi, nir_intrin
    case nir_intrinsic_load_hs_out_patch_data_offset_amd:
       return si_unpack_param(ctx, ctx->tcs_offchip_layout, 11, 21);
 
+   case nir_intrinsic_load_ring_tess_offchip_amd:
+      return ctx->tess_offchip_ring;
+
+   case nir_intrinsic_load_ring_tess_offchip_offset_amd:
+      return ac_get_arg(&ctx->ac, ctx->args.tess_offchip_offset);
+
    default:
       return NULL;
    }
-- 
GitLab


From f37342f9fd286e91b26d93f17245bccd6338ed1e Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Tue, 24 May 2022 15:09:00 +0800
Subject: [PATCH 14/30] radeonsi: implement
 nir_intrinsic_load_tess_rel_patch_id_amd for both tcs and tes

radv will lower this intrinsic before gets to llvm, so we just need to
implement it in radeonsi.

The tes version will be used in tess lower too.

Acked-by: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/amd/llvm/ac_nir_to_llvm.c                      |  5 +----
 src/gallium/drivers/radeonsi/si_shader_internal.h  |  1 +
 src/gallium/drivers/radeonsi/si_shader_llvm.c      |  3 +++
 src/gallium/drivers/radeonsi/si_shader_llvm_tess.c | 12 ++++++------
 4 files changed, 11 insertions(+), 10 deletions(-)

diff --git a/src/amd/llvm/ac_nir_to_llvm.c b/src/amd/llvm/ac_nir_to_llvm.c
index 793164a980c0..878cdfb1459e 100644
--- a/src/amd/llvm/ac_nir_to_llvm.c
+++ b/src/amd/llvm/ac_nir_to_llvm.c
@@ -3631,6 +3631,7 @@ static void visit_intrinsic(struct ac_nir_context *ctx, nir_intrinsic_instr *ins
    case nir_intrinsic_load_tess_level_inner:
    case nir_intrinsic_load_tess_level_outer_default:
    case nir_intrinsic_load_tess_level_inner_default:
+   case nir_intrinsic_load_tess_rel_patch_id_amd:
    case nir_intrinsic_load_patch_vertices_in:
    case nir_intrinsic_load_sample_mask_in:
    case nir_intrinsic_load_ring_tess_factors_amd:
@@ -4050,10 +4051,6 @@ static void visit_intrinsic(struct ac_nir_context *ctx, nir_intrinsic_instr *ins
       result = ac_build_gather_values(&ctx->ac, coord, 3);
       break;
    }
-   case nir_intrinsic_load_tess_rel_patch_id_amd:
-      assert(ctx->stage == MESA_SHADER_TESS_CTRL);
-      result = ac_unpack_param(&ctx->ac, ac_get_arg(&ctx->ac, ctx->args->tcs_rel_ids), 0, 8);
-      break;
    case nir_intrinsic_vote_all: {
       result = ac_build_vote_all(&ctx->ac, get_src(ctx, instr->src[0]));
       break;
diff --git a/src/gallium/drivers/radeonsi/si_shader_internal.h b/src/gallium/drivers/radeonsi/si_shader_internal.h
index 8f41bd43c873..cbb4a5109126 100644
--- a/src/gallium/drivers/radeonsi/si_shader_internal.h
+++ b/src/gallium/drivers/radeonsi/si_shader_internal.h
@@ -242,6 +242,7 @@ void si_llvm_gs_build_end(struct si_shader_context *ctx);
 void si_llvm_init_gs_callbacks(struct si_shader_context *ctx);
 
 /* si_shader_llvm_tess.c */
+LLVMValueRef si_get_rel_patch_id(struct si_shader_context *ctx);
 LLVMValueRef si_get_tcs_in_vertex_dw_stride(struct si_shader_context *ctx);
 LLVMValueRef si_get_num_tcs_out_vertices(struct si_shader_context *ctx);
 void si_llvm_preload_tess_rings(struct si_shader_context *ctx);
diff --git a/src/gallium/drivers/radeonsi/si_shader_llvm.c b/src/gallium/drivers/radeonsi/si_shader_llvm.c
index 136a28d3cd3e..8f3263ab4b07 100644
--- a/src/gallium/drivers/radeonsi/si_shader_llvm.c
+++ b/src/gallium/drivers/radeonsi/si_shader_llvm.c
@@ -794,6 +794,9 @@ static LLVMValueRef si_llvm_load_intrinsic(struct ac_shader_abi *abi, nir_intrin
    case nir_intrinsic_load_ring_tess_offchip_offset_amd:
       return ac_get_arg(&ctx->ac, ctx->args.tess_offchip_offset);
 
+   case nir_intrinsic_load_tess_rel_patch_id_amd:
+      return si_get_rel_patch_id(ctx);
+
    default:
       return NULL;
    }
diff --git a/src/gallium/drivers/radeonsi/si_shader_llvm_tess.c b/src/gallium/drivers/radeonsi/si_shader_llvm_tess.c
index 49b2cc614f73..70ab6e310a7a 100644
--- a/src/gallium/drivers/radeonsi/si_shader_llvm_tess.c
+++ b/src/gallium/drivers/radeonsi/si_shader_llvm_tess.c
@@ -26,7 +26,7 @@
 #include "si_shader_internal.h"
 #include "sid.h"
 
-static LLVMValueRef get_rel_patch_id(struct si_shader_context *ctx)
+LLVMValueRef si_get_rel_patch_id(struct si_shader_context *ctx)
 {
    switch (ctx->stage) {
    case MESA_SHADER_TESS_CTRL:
@@ -106,7 +106,7 @@ static LLVMValueRef get_tcs_out_patch0_patch_data_offset(struct si_shader_contex
 static LLVMValueRef get_tcs_in_current_patch_offset(struct si_shader_context *ctx)
 {
    LLVMValueRef patch_stride = get_tcs_in_patch_stride(ctx);
-   LLVMValueRef rel_patch_id = get_rel_patch_id(ctx);
+   LLVMValueRef rel_patch_id = si_get_rel_patch_id(ctx);
 
    return LLVMBuildMul(ctx->ac.builder, patch_stride, rel_patch_id, "");
 }
@@ -115,7 +115,7 @@ static LLVMValueRef get_tcs_out_current_patch_offset(struct si_shader_context *c
 {
    LLVMValueRef patch0_offset = get_tcs_out_patch0_offset(ctx);
    LLVMValueRef patch_stride = get_tcs_out_patch_stride(ctx);
-   LLVMValueRef rel_patch_id = get_rel_patch_id(ctx);
+   LLVMValueRef rel_patch_id = si_get_rel_patch_id(ctx);
 
    return ac_build_imad(&ctx->ac, patch_stride, rel_patch_id, patch0_offset);
 }
@@ -124,7 +124,7 @@ static LLVMValueRef get_tcs_out_current_patch_data_offset(struct si_shader_conte
 {
    LLVMValueRef patch0_patch_data_offset = get_tcs_out_patch0_patch_data_offset(ctx);
    LLVMValueRef patch_stride = get_tcs_out_patch_stride(ctx);
-   LLVMValueRef rel_patch_id = get_rel_patch_id(ctx);
+   LLVMValueRef rel_patch_id = si_get_rel_patch_id(ctx);
 
    return ac_build_imad(&ctx->ac, patch_stride, rel_patch_id, patch0_patch_data_offset);
 }
@@ -258,7 +258,7 @@ static LLVMValueRef get_tcs_tes_buffer_address_from_generic_indices(struct si_sh
       param_index = LLVMConstInt(ctx->ac.i32, param_index_base, 0);
    }
 
-   return get_tcs_tes_buffer_address(ctx, get_rel_patch_id(ctx), vertex_index, param_index);
+   return get_tcs_tes_buffer_address(ctx, si_get_rel_patch_id(ctx), vertex_index, param_index);
 }
 
 static LLVMValueRef buffer_load(struct si_shader_context *ctx, LLVMTypeRef type, unsigned swizzle,
@@ -711,7 +711,7 @@ void si_llvm_tcs_build_end(struct si_shader_context *ctx)
    LLVMBuilderRef builder = ctx->ac.builder;
    LLVMValueRef rel_patch_id, invocation_id, tf_lds_offset;
 
-   rel_patch_id = get_rel_patch_id(ctx);
+   rel_patch_id = si_get_rel_patch_id(ctx);
    invocation_id = si_unpack_param(ctx, ctx->args.tcs_rel_ids, 8, 5);
    tf_lds_offset = get_tcs_out_current_patch_data_offset(ctx);
 
-- 
GitLab


From 89752a58e834d6106bcec68a56bdc3f8ba3681e6 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Wed, 25 May 2022 19:35:15 +0800
Subject: [PATCH 15/30] ac/llvm: handle write mask for
 nir_intrinsic_store_buffer_amd

tess lowering may generate buffer store with partial write mask.

Acked-by: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/amd/llvm/ac_nir_to_llvm.c | 17 +++++++++++++----
 1 file changed, 13 insertions(+), 4 deletions(-)

diff --git a/src/amd/llvm/ac_nir_to_llvm.c b/src/amd/llvm/ac_nir_to_llvm.c
index 878cdfb1459e..79546240ccd3 100644
--- a/src/amd/llvm/ac_nir_to_llvm.c
+++ b/src/amd/llvm/ac_nir_to_llvm.c
@@ -4241,10 +4241,19 @@ static void visit_intrinsic(struct ac_nir_context *ctx, nir_intrinsic_instr *ins
       if (slc)
          cache_policy |= ac_slc;
 
-      LLVMValueRef voffset = LLVMBuildAdd(ctx->ac.builder, addr_voffset,
-                                          LLVMConstInt(ctx->ac.i32, const_offset, 0), "");
-      ac_build_buffer_store_dword(&ctx->ac, descriptor, store_data, NULL, voffset, addr_soffset,
-                                  cache_policy);
+      unsigned writemask = nir_intrinsic_write_mask(instr);
+      while (writemask) {
+         int start, count;
+         u_bit_scan_consecutive_range(&writemask, &start, &count);
+
+         LLVMValueRef voffset = LLVMBuildAdd(
+            ctx->ac.builder, addr_voffset,
+            LLVMConstInt(ctx->ac.i32, const_offset + start * 4, 0), "");
+
+         LLVMValueRef data = extract_vector_range(&ctx->ac, store_data, start, count);
+         ac_build_buffer_store_dword(&ctx->ac, descriptor, data, NULL, voffset, addr_soffset,
+                                     cache_policy);
+      }
       break;
    }
    case nir_intrinsic_has_input_vertex_amd: {
-- 
GitLab


From f928908a4f2069ae24e2378475a66a28f2417ddc Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Wed, 1 Jun 2022 17:13:00 +0800
Subject: [PATCH 16/30] ac/nir: add no_input_lds_space param to hs output lower

This is used by radeonsi to save some lds space when all LS output
is passed by register.

Acked-by: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/amd/common/ac_nir.h                      |  1 +
 src/amd/common/ac_nir_lower_tess_io_to_mem.c | 25 +++++++++++++++-----
 src/amd/vulkan/radv_shader.c                 |  3 ++-
 3 files changed, 22 insertions(+), 7 deletions(-)

diff --git a/src/amd/common/ac_nir.h b/src/amd/common/ac_nir.h
index c6e08bce0a24..437c2ca13528 100644
--- a/src/amd/common/ac_nir.h
+++ b/src/amd/common/ac_nir.h
@@ -90,6 +90,7 @@ ac_nir_lower_hs_outputs_to_mem(nir_shader *shader,
                                unsigned num_reserved_tcs_outputs,
                                unsigned num_reserved_tcs_patch_outputs,
                                unsigned wave_size,
+                               bool no_inputs_in_lds,
                                bool pass_tessfactors_by_reg,
                                bool emit_tess_factor_write);
 
diff --git a/src/amd/common/ac_nir_lower_tess_io_to_mem.c b/src/amd/common/ac_nir_lower_tess_io_to_mem.c
index d2ce7c114798..e14ddc3b06e5 100644
--- a/src/amd/common/ac_nir_lower_tess_io_to_mem.c
+++ b/src/amd/common/ac_nir_lower_tess_io_to_mem.c
@@ -159,6 +159,11 @@ typedef struct {
     * can be passed by register.
     */
    bool tcs_pass_tessfactors_by_reg;
+
+   /* Whether all TCS inputs are accessed using gl_InvocationID and passed via VGPRs.
+    * In that case, no LDS is allocated for TCS inputs.
+    */
+   bool tcs_no_inputs_in_lds;
 } lower_tess_io_state;
 
 static bool
@@ -325,18 +330,24 @@ hs_output_lds_offset(nir_builder *b,
    unsigned pervertex_output_patch_size = b->shader->info.tess.tcs_vertices_out * output_vertex_size;
    unsigned output_patch_stride = pervertex_output_patch_size + st->tcs_num_reserved_patch_outputs * 16u;
 
-   nir_ssa_def *tcs_in_vtxcnt = nir_load_patch_vertices_in(b);
-   nir_ssa_def *tcs_num_patches = nir_load_tcs_num_patches_amd(b);
-   nir_ssa_def *input_patch_size = nir_imul(b, tcs_in_vtxcnt, nir_load_lshs_vertex_stride_amd(b));
-   nir_ssa_def *output_patch0_offset = nir_imul(b, input_patch_size, tcs_num_patches);
-
    nir_ssa_def *off = intrin
                     ? ac_nir_calc_io_offset(b, intrin, nir_imm_int(b, 16u), 4u, st->map_io)
                     : nir_imm_int(b, 0);
 
    nir_ssa_def *rel_patch_id = nir_load_tess_rel_patch_id_amd(b);
    nir_ssa_def *patch_offset = nir_imul_imm(b, rel_patch_id, output_patch_stride);
-   nir_ssa_def *output_patch_offset = nir_iadd_nuw(b, patch_offset, output_patch0_offset);
+
+   nir_ssa_def *output_patch_offset;
+   if (st->tcs_no_inputs_in_lds)
+      output_patch_offset = patch_offset;
+   else {
+      nir_ssa_def *tcs_in_vtxcnt = nir_load_patch_vertices_in(b);
+      nir_ssa_def *tcs_num_patches = nir_load_tcs_num_patches_amd(b);
+      nir_ssa_def *input_patch_size =
+         nir_imul(b, tcs_in_vtxcnt, nir_load_lshs_vertex_stride_amd(b));
+      nir_ssa_def *output_patch0_offset = nir_imul(b, input_patch_size, tcs_num_patches);
+      output_patch_offset = nir_iadd_nuw(b, patch_offset, output_patch0_offset);
+   }
 
    if (per_vertex) {
       nir_ssa_def *vertex_index = nir_ssa_for_src(b, *nir_get_io_arrayed_index_src(intrin), 1);
@@ -706,6 +717,7 @@ ac_nir_lower_hs_outputs_to_mem(nir_shader *shader,
                                unsigned num_reserved_tcs_outputs,
                                unsigned num_reserved_tcs_patch_outputs,
                                unsigned wave_size,
+                               bool no_inputs_in_lds,
                                bool pass_tessfactors_by_reg,
                                bool emit_tess_factor_write)
 {
@@ -720,6 +732,7 @@ ac_nir_lower_hs_outputs_to_mem(nir_shader *shader,
       .tcs_num_reserved_patch_outputs = num_reserved_tcs_patch_outputs,
       .tcs_out_patch_fits_subgroup = wave_size % shader->info.tess.tcs_vertices_out == 0,
       .tcs_pass_tessfactors_by_reg = pass_tessfactors_by_reg,
+      .tcs_no_inputs_in_lds = no_inputs_in_lds,
       .map_io = map,
    };
 
diff --git a/src/amd/vulkan/radv_shader.c b/src/amd/vulkan/radv_shader.c
index 1a7f88c6b56d..6690fdf04918 100644
--- a/src/amd/vulkan/radv_shader.c
+++ b/src/amd/vulkan/radv_shader.c
@@ -1076,7 +1076,8 @@ radv_lower_io_to_mem(struct radv_device *device, struct radv_pipeline_stage *sta
                  device->physical_device->rad_info.gfx_level,
                  info->tcs.tes_reads_tess_factors, info->tcs.tes_inputs_read,
                  info->tcs.tes_patch_inputs_read, info->tcs.num_linked_outputs,
-                 info->tcs.num_linked_patch_outputs, info->wave_size, false, true);
+                 info->tcs.num_linked_patch_outputs, info->wave_size,
+                 false, false, true);
 
       return true;
    } else if (nir->info.stage == MESA_SHADER_TESS_EVAL) {
-- 
GitLab


From 683cb14a9a3c60266ca07758e2fe3b279457a254 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Sat, 28 May 2022 17:52:35 +0800
Subject: [PATCH 17/30] radeonsi: replace llvm tcs output with nir lower pass

Remove the store_tcs_outputs abi, we can use common output abi
to handle the tessfactor pass as vgpr.

Acked-by: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/amd/llvm/ac_nir_to_llvm.c                 |  20 +--
 src/amd/llvm/ac_shader_abi.h                  |   6 -
 src/gallium/drivers/radeonsi/si_shader.c      |  24 ++-
 .../drivers/radeonsi/si_shader_internal.h     |   1 -
 src/gallium/drivers/radeonsi/si_shader_llvm.c |   5 -
 .../drivers/radeonsi/si_shader_llvm_tess.c    | 152 +++---------------
 6 files changed, 49 insertions(+), 159 deletions(-)

diff --git a/src/amd/llvm/ac_nir_to_llvm.c b/src/amd/llvm/ac_nir_to_llvm.c
index 79546240ccd3..c104c2165a9d 100644
--- a/src/amd/llvm/ac_nir_to_llvm.c
+++ b/src/amd/llvm/ac_nir_to_llvm.c
@@ -2367,12 +2367,9 @@ static void visit_store_output(struct ac_nir_context *ctx, nir_intrinsic_instr *
    unsigned component = nir_intrinsic_component(instr);
    LLVMValueRef src = ac_to_float(&ctx->ac, get_src(ctx, instr->src[0]));
    nir_src offset = *nir_get_io_offset_src(instr);
-   LLVMValueRef indir_index = NULL;
 
-   if (nir_src_is_const(offset))
-      assert(nir_src_as_uint(offset) == 0);
-   else
-      indir_index = get_src(ctx, offset);
+   /* No indirect indexing is allowed here. */
+   assert(nir_src_is_const(offset) && nir_src_as_uint(offset) == 0);
 
    switch (ac_get_elem_bits(&ctx->ac, LLVMTypeOf(src))) {
    case 16:
@@ -2388,19 +2385,6 @@ static void visit_store_output(struct ac_nir_context *ctx, nir_intrinsic_instr *
 
    writemask <<= component;
 
-   if (ctx->stage == MESA_SHADER_TESS_CTRL) {
-      nir_src *vertex_index_src = nir_get_io_arrayed_index_src(instr);
-      LLVMValueRef vertex_index = vertex_index_src ? get_src(ctx, *vertex_index_src) : NULL;
-      unsigned location = nir_intrinsic_io_semantics(instr).location;
-
-      ctx->abi->store_tcs_outputs(ctx->abi, vertex_index, indir_index, src,
-                                  writemask, component, location, base);
-      return;
-   }
-
-   /* No indirect indexing is allowed after this point. */
-   assert(!indir_index);
-
    for (unsigned chan = 0; chan < 8; chan++) {
       if (!(writemask & (1 << chan)))
          continue;
diff --git a/src/amd/llvm/ac_shader_abi.h b/src/amd/llvm/ac_shader_abi.h
index 4584d52d1203..ee9e17a88d09 100644
--- a/src/amd/llvm/ac_shader_abi.h
+++ b/src/amd/llvm/ac_shader_abi.h
@@ -69,12 +69,6 @@ struct ac_shader_abi {
                                       unsigned driver_location, unsigned component,
                                       unsigned num_components, bool load_inputs);
 
-   void (*store_tcs_outputs)(struct ac_shader_abi *abi,
-                             LLVMValueRef vertex_index, LLVMValueRef param_index,
-                             LLVMValueRef src, unsigned writemask,
-                             unsigned component, unsigned location, unsigned driver_location);
-
-
    LLVMValueRef (*load_ubo)(struct ac_shader_abi *abi, LLVMValueRef index);
 
    /**
diff --git a/src/gallium/drivers/radeonsi/si_shader.c b/src/gallium/drivers/radeonsi/si_shader.c
index b65cec6b978a..5e102df047d0 100644
--- a/src/gallium/drivers/radeonsi/si_shader.c
+++ b/src/gallium/drivers/radeonsi/si_shader.c
@@ -1491,13 +1491,20 @@ static bool si_nir_kill_outputs(nir_shader *nir, const union si_shader_key *key)
 
 static unsigned si_map_io_driver_location(unsigned semantic)
 {
+   if ((semantic >= VARYING_SLOT_PATCH0 && semantic < VARYING_SLOT_TESS_MAX) ||
+       semantic == VARYING_SLOT_TESS_LEVEL_INNER ||
+       semantic == VARYING_SLOT_TESS_LEVEL_OUTER)
+      return si_shader_io_get_unique_index_patch(semantic);
+
    return si_shader_io_get_unique_index(semantic, false);
 }
 
-static bool si_lower_io_to_mem(const union si_shader_key *key,
-                               nir_shader *nir,
+static bool si_lower_io_to_mem(struct si_shader *shader, nir_shader *nir,
                                uint64_t tcs_vgpr_only_inputs)
 {
+   struct si_shader_selector *sel = shader->selector;
+   const union si_shader_key *key = &shader->key;
+
    if (nir->info.stage == MESA_SHADER_VERTEX) {
       if (key->ge.as_ls) {
          NIR_PASS_V(nir, ac_nir_lower_ls_outputs_to_mem, si_map_io_driver_location,
@@ -1507,6 +1514,17 @@ static bool si_lower_io_to_mem(const union si_shader_key *key,
    } else if (nir->info.stage == MESA_SHADER_TESS_CTRL) {
       NIR_PASS_V(nir, ac_nir_lower_hs_inputs_to_mem, si_map_io_driver_location,
                  key->ge.opt.same_patch_vertices);
+      NIR_PASS_V(nir, ac_nir_lower_hs_outputs_to_mem, si_map_io_driver_location,
+                 sel->screen->info.gfx_level,
+                 false, /* does not matter as we disabled final tess factor write */
+                 ~0ULL, ~0ULL, /* no TES inputs filter */
+                 util_last_bit64(sel->info.outputs_written),
+                 util_last_bit64(sel->info.patch_outputs_written),
+                 shader->wave_size,
+                 /* ALL TCS inputs are passed by register. */
+                 key->ge.opt.same_patch_vertices &&
+                 !(sel->info.base.inputs_read & ~sel->info.tcs_vgpr_only_inputs),
+                 sel->info.tessfactors_are_def_in_all_invocs, false);
       return true;
    }
 
@@ -1633,7 +1651,7 @@ struct nir_shader *si_get_nir_shader(struct si_shader *shader, bool *free_nir,
     */
    progress2 |= ac_nir_lower_indirect_derefs(nir, sel->screen->info.gfx_level);
 
-   bool opt_offsets = si_lower_io_to_mem(key, nir, tcs_vgpr_only_inputs);
+   bool opt_offsets = si_lower_io_to_mem(shader, nir, tcs_vgpr_only_inputs);
 
    if (progress2 || opt_offsets)
       si_nir_opts(sel->screen, nir, false);
diff --git a/src/gallium/drivers/radeonsi/si_shader_internal.h b/src/gallium/drivers/radeonsi/si_shader_internal.h
index cbb4a5109126..6bda67d5b7be 100644
--- a/src/gallium/drivers/radeonsi/si_shader_internal.h
+++ b/src/gallium/drivers/radeonsi/si_shader_internal.h
@@ -144,7 +144,6 @@ struct si_shader_context {
    LLVMValueRef gsvs_ring[4];
    LLVMValueRef tess_offchip_ring;
 
-   LLVMValueRef invoc0_tess_factors[6]; /* outer[4], inner[2] */
    LLVMValueRef gs_next_vertex[4];
    LLVMValueRef gs_curprim_verts[4];
    LLVMValueRef gs_generated_prims[4];
diff --git a/src/gallium/drivers/radeonsi/si_shader_llvm.c b/src/gallium/drivers/radeonsi/si_shader_llvm.c
index 8f3263ab4b07..a1de3d85a350 100644
--- a/src/gallium/drivers/radeonsi/si_shader_llvm.c
+++ b/src/gallium/drivers/radeonsi/si_shader_llvm.c
@@ -834,11 +834,6 @@ bool si_llvm_translate_nir(struct si_shader_context *ctx, struct si_shader *shad
    case MESA_SHADER_TESS_CTRL:
       si_llvm_init_tcs_callbacks(ctx);
       si_llvm_preload_tess_rings(ctx);
-
-      if (sel->info.tessfactors_are_def_in_all_invocs) {
-         for (unsigned i = 0; i < 6; i++)
-            ctx->invoc0_tess_factors[i] = ac_build_alloca_undef(&ctx->ac, ctx->ac.i32, "");
-      }
       break;
 
    case MESA_SHADER_TESS_EVAL:
diff --git a/src/gallium/drivers/radeonsi/si_shader_llvm_tess.c b/src/gallium/drivers/radeonsi/si_shader_llvm_tess.c
index 70ab6e310a7a..4d75f291ccb1 100644
--- a/src/gallium/drivers/radeonsi/si_shader_llvm_tess.c
+++ b/src/gallium/drivers/radeonsi/si_shader_llvm_tess.c
@@ -383,42 +383,18 @@ static LLVMValueRef si_nir_load_tcs_varyings(struct ac_shader_abi *abi, LLVMType
 {
    struct si_shader_context *ctx = si_shader_context_from_abi(abi);
    struct si_shader_info *info = &ctx->shader->selector->info;
-   LLVMValueRef value[4];
-
-   if (load_input) {
-      assert(ctx->shader->key.ge.opt.same_patch_vertices && !param_index);
-
-      ubyte semantic = info->input[driver_location].semantic;
-      /* Load the TCS input from a VGPR. */
-      unsigned func_param = ctx->args.tcs_rel_ids.arg_index + 1 +
-         si_shader_io_get_unique_index(semantic, false) * 4;
 
-      for (unsigned i = component; i < component + num_components; i++) {
-         value[i] = LLVMGetParam(ctx->main_fn, func_param + i);
-         value[i] = LLVMBuildBitCast(ctx->ac.builder, value[i], type, "");
-      }
-   } else {
-      ubyte semantic = info->output_semantic[driver_location];
-
-      bool is_patch = vertex_index == NULL;
-      assert((semantic >= VARYING_SLOT_PATCH0 ||
-              semantic == VARYING_SLOT_TESS_LEVEL_INNER ||
-              semantic == VARYING_SLOT_TESS_LEVEL_OUTER) == is_patch);
-
-      LLVMValueRef dw_addr, stride;
-      if (is_patch) {
-         stride = NULL;
-         dw_addr = get_tcs_out_current_patch_data_offset(ctx);
-      } else {
-         stride = get_tcs_out_vertex_dw_stride(ctx);
-         dw_addr = get_tcs_out_current_patch_offset(ctx);
-      }
+   assert(ctx->shader->key.ge.opt.same_patch_vertices && !param_index);
 
-      dw_addr = get_dw_address_from_generic_indices(ctx, stride, dw_addr, vertex_index,
-                                                    param_index, semantic);
+   ubyte semantic = info->input[driver_location].semantic;
+   /* Load the TCS input from a VGPR. */
+   unsigned func_param = ctx->args.tcs_rel_ids.arg_index + 1 +
+      si_shader_io_get_unique_index(semantic, false) * 4;
 
-      for (unsigned i = component; i < component + num_components; i++)
-         value[i] = lshs_lds_load(ctx, type, i, dw_addr);
+   LLVMValueRef value[4];
+   for (unsigned i = component; i < component + num_components; i++) {
+      value[i] = LLVMGetParam(ctx->main_fn, func_param + i);
+      value[i] = LLVMBuildBitCast(ctx->ac.builder, value[i], type, "");
    }
 
    return ac_build_varying_gather_values(&ctx->ac, value, num_components, component);
@@ -455,96 +431,6 @@ static LLVMValueRef si_nir_load_input_tes(struct ac_shader_abi *abi, LLVMTypeRef
    return ac_build_varying_gather_values(&ctx->ac, value, num_components, component);
 }
 
-static void si_nir_store_output_tcs(struct ac_shader_abi *abi,
-                                    LLVMValueRef vertex_index, LLVMValueRef param_index,
-                                    LLVMValueRef src, unsigned writemask,
-                                    unsigned component, unsigned location, unsigned driver_location)
-{
-   struct si_shader_context *ctx = si_shader_context_from_abi(abi);
-   struct si_shader_info *info = &ctx->shader->selector->info;
-   LLVMValueRef dw_addr, stride;
-   LLVMValueRef buffer, base, addr;
-   LLVMValueRef values[8];
-   bool is_tess_factor = false, is_tess_inner = false;
-
-   ubyte semantic = info->output_semantic[driver_location];
-
-   const bool is_const = !param_index;
-   const bool is_patch = vertex_index == NULL;
-
-   /* Invalid SPIR-V can cause this. */
-   if ((semantic >= VARYING_SLOT_PATCH0 || semantic == VARYING_SLOT_TESS_LEVEL_INNER ||
-        semantic == VARYING_SLOT_TESS_LEVEL_OUTER) != is_patch)
-      return;
-
-   if (!is_patch) {
-      stride = get_tcs_out_vertex_dw_stride(ctx);
-      dw_addr = get_tcs_out_current_patch_offset(ctx);
-      dw_addr = get_dw_address_from_generic_indices(ctx, stride, dw_addr, vertex_index, param_index,
-                                                    semantic);
-   } else {
-      dw_addr = get_tcs_out_current_patch_data_offset(ctx);
-      dw_addr = get_dw_address_from_generic_indices(ctx, NULL, dw_addr, vertex_index, param_index,
-                                                    semantic);
-
-      if (is_const) {
-         int semantic = info->output_semantic[driver_location];
-
-         /* Always write tess factors into LDS for the TCS epilog. */
-         if (semantic == VARYING_SLOT_TESS_LEVEL_INNER ||
-             semantic == VARYING_SLOT_TESS_LEVEL_OUTER) {
-            is_tess_factor = true;
-            is_tess_inner = semantic == VARYING_SLOT_TESS_LEVEL_INNER;
-         }
-      }
-   }
-
-   buffer = ctx->tess_offchip_ring;
-
-   base = ac_get_arg(&ctx->ac, ctx->args.tess_offchip_offset);
-
-   addr =
-      get_tcs_tes_buffer_address_from_generic_indices(ctx, vertex_index, param_index, semantic);
-
-   for (unsigned chan = component; chan < 4; chan++) {
-      if (!(writemask & (1 << chan)))
-         continue;
-      LLVMValueRef value = ac_llvm_extract_elem(&ctx->ac, src, chan - component);
-
-      /* Skip LDS stores if there is no LDS read of this output. */
-      if (info->output_readmask[driver_location] & (1 << chan) ||
-          /* The epilog reads LDS if invocation 0 doesn't define tess factors. */
-          (is_tess_factor &&
-           !ctx->shader->selector->info.tessfactors_are_def_in_all_invocs))
-         lshs_lds_store(ctx, chan, dw_addr, value);
-
-      value = ac_to_integer(&ctx->ac, value);
-      values[chan] = value;
-
-      if (writemask != 0xF && !is_tess_factor) {
-         LLVMValueRef voffset = LLVMBuildAdd(ctx->ac.builder, addr,
-                                             LLVMConstInt(ctx->ac.i32, 4 * chan, 0), "");
-         ac_build_buffer_store_dword(&ctx->ac, buffer, value, NULL, voffset, base, ac_glc);
-      }
-
-      /* Write tess factors into VGPRs for the epilog. */
-      if (is_tess_factor && ctx->shader->selector->info.tessfactors_are_def_in_all_invocs) {
-         if (!is_tess_inner) {
-            LLVMBuildStore(ctx->ac.builder, value, /* outer */
-                           ctx->invoc0_tess_factors[chan]);
-         } else if (chan < 2) {
-            LLVMBuildStore(ctx->ac.builder, value, /* inner */
-                           ctx->invoc0_tess_factors[4 + chan]);
-         }
-      }
-   }
-
-   if (writemask == 0xF && !is_tess_factor) {
-      LLVMValueRef value = ac_build_gather_values(&ctx->ac, values, 4);
-      ac_build_buffer_store_dword(&ctx->ac, buffer, value, NULL, addr, base, ac_glc);
-   }
-}
-
 static void si_write_tess_factors(struct si_shader_context *ctx, union si_shader_part_key *key,
                                   LLVMValueRef rel_patch_id, LLVMValueRef invocation_id,
                                   LLVMValueRef tcs_out_current_patch_data_offset,
@@ -769,10 +655,25 @@ void si_llvm_tcs_build_end(struct si_shader_context *ctx)
    ret = LLVMBuildInsertValue(builder, ret, rel_patch_id, vgpr++, "");
    ret = LLVMBuildInsertValue(builder, ret, invocation_id, vgpr++, "");
 
-   if (ctx->shader->selector->info.tessfactors_are_def_in_all_invocs) {
+   struct si_shader_info *info = &ctx->shader->selector->info;
+   if (info->tessfactors_are_def_in_all_invocs) {
       vgpr++; /* skip the tess factor LDS offset */
+
+      /* get tess factor driver location */
+      int outer_loc = -1;
+      int inner_loc = -1;
+      for (int i = 0; i < info->num_outputs; i++) {
+         unsigned semantic = info->output_semantic[i];
+         if (semantic == VARYING_SLOT_TESS_LEVEL_OUTER)
+            outer_loc = i;
+         else if (semantic == VARYING_SLOT_TESS_LEVEL_INNER)
+            inner_loc = i;
+      }
+
       for (unsigned i = 0; i < 6; i++) {
-         LLVMValueRef value = LLVMBuildLoad(builder, ctx->invoc0_tess_factors[i], "");
+         int loc = i < 4 ? outer_loc : inner_loc;
+         LLVMValueRef value = loc < 0 ? LLVMGetUndef(ctx->ac.f32) :
+            LLVMBuildLoad(builder, ctx->abi.outputs[loc * 4 + i % 4], "");
          value = ac_to_float(&ctx->ac, value);
          ret = LLVMBuildInsertValue(builder, ret, value, vgpr++, "");
       }
@@ -920,7 +821,6 @@ void si_llvm_build_tcs_epilog(struct si_shader_context *ctx, union si_shader_par
 void si_llvm_init_tcs_callbacks(struct si_shader_context *ctx)
 {
    ctx->abi.load_tess_varyings = si_nir_load_tcs_varyings;
-   ctx->abi.store_tcs_outputs = si_nir_store_output_tcs;
 }
 
 void si_llvm_init_tes_callbacks(struct si_shader_context *ctx, bool ngg_cull_shader)
-- 
GitLab


From b69f4f15ac84b881a9bd96bf1d6b08513416392b Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Sat, 28 May 2022 18:09:56 +0800
Subject: [PATCH 18/30] radeonsi: enable PIPE_CAP_GLSL_TESS_LEVELS_AS_INPUTS
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

This can remove special handling of tessfactors which also benifit
the nir lower pass which does not handle these as system value.

Acked-by: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
Reviewed-by: Timur Kristóf <timur.kristof@gmail.com>
Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/amd/llvm/ac_nir_to_llvm.c                 |  2 --
 src/gallium/drivers/radeonsi/si_get.c         |  1 +
 src/gallium/drivers/radeonsi/si_shader_info.c | 15 +++++----------
 src/gallium/drivers/radeonsi/si_shader_llvm.c |  7 -------
 4 files changed, 6 insertions(+), 19 deletions(-)

diff --git a/src/amd/llvm/ac_nir_to_llvm.c b/src/amd/llvm/ac_nir_to_llvm.c
index c104c2165a9d..d6551f4d3e63 100644
--- a/src/amd/llvm/ac_nir_to_llvm.c
+++ b/src/amd/llvm/ac_nir_to_llvm.c
@@ -3611,8 +3611,6 @@ static void visit_intrinsic(struct ac_nir_context *ctx, nir_intrinsic_instr *ins
    case nir_intrinsic_load_base_vertex:
    case nir_intrinsic_load_first_vertex:
    case nir_intrinsic_load_workgroup_size:
-   case nir_intrinsic_load_tess_level_outer:
-   case nir_intrinsic_load_tess_level_inner:
    case nir_intrinsic_load_tess_level_outer_default:
    case nir_intrinsic_load_tess_level_inner_default:
    case nir_intrinsic_load_tess_rel_patch_id_amd:
diff --git a/src/gallium/drivers/radeonsi/si_get.c b/src/gallium/drivers/radeonsi/si_get.c
index 44a3be0a590b..fcd4fd7b364d 100644
--- a/src/gallium/drivers/radeonsi/si_get.c
+++ b/src/gallium/drivers/radeonsi/si_get.c
@@ -165,6 +165,7 @@ static int si_get_param(struct pipe_screen *pscreen, enum pipe_cap param)
    case PIPE_CAP_IMAGE_STORE_FORMATTED:
    case PIPE_CAP_ALLOW_DRAW_OUT_OF_ORDER:
    case PIPE_CAP_QUERY_SO_OVERFLOW:
+   case PIPE_CAP_GLSL_TESS_LEVELS_AS_INPUTS:
       return 1;
 
    case PIPE_CAP_TEXTURE_TRANSFER_MODES:
diff --git a/src/gallium/drivers/radeonsi/si_shader_info.c b/src/gallium/drivers/radeonsi/si_shader_info.c
index ff4b74e30dee..f4d94f07ddd0 100644
--- a/src/gallium/drivers/radeonsi/si_shader_info.c
+++ b/src/gallium/drivers/radeonsi/si_shader_info.c
@@ -440,8 +440,6 @@ static void scan_instruction(const struct nir_shader *nir, struct si_shader_info
             break;
 
          case nir_intrinsic_load_barycentric_at_sample: /* This loads sample positions. */
-         case nir_intrinsic_load_tess_level_outer: /* TES input read from memory */
-         case nir_intrinsic_load_tess_level_inner: /* TES input read from memory */
             info->uses_vmem_load_other = true;
             break;
 
@@ -625,6 +623,11 @@ void si_nir_scan_shader(struct si_screen *sscreen, const struct nir_shader *nir,
       info->tessfactors_are_def_in_all_invocs = are_tessfactors_def_in_all_invocs(nir);
    }
 
+   /* tess factors are loaded as input instead of system value */
+   info->reads_tess_factors = nir->info.patch_inputs_read &
+      (BITFIELD64_BIT(VARYING_SLOT_TESS_LEVEL_INNER) |
+       BITFIELD64_BIT(VARYING_SLOT_TESS_LEVEL_OUTER));
+
    info->uses_frontface = BITSET_TEST(nir->info.system_values_read, SYSTEM_VALUE_FRONT_FACE);
    info->uses_instanceid = BITSET_TEST(nir->info.system_values_read, SYSTEM_VALUE_INSTANCE_ID);
    info->uses_base_vertex = BITSET_TEST(nir->info.system_values_read, SYSTEM_VALUE_BASE_VERTEX);
@@ -639,8 +642,6 @@ void si_nir_scan_shader(struct si_screen *sscreen, const struct nir_shader *nir,
    info->uses_primid = BITSET_TEST(nir->info.system_values_read, SYSTEM_VALUE_PRIMITIVE_ID) ||
                        nir->info.inputs_read & VARYING_BIT_PRIMITIVE_ID;
    info->reads_samplemask = BITSET_TEST(nir->info.system_values_read, SYSTEM_VALUE_SAMPLE_MASK_IN);
-   info->reads_tess_factors = BITSET_TEST(nir->info.system_values_read, SYSTEM_VALUE_TESS_LEVEL_INNER) ||
-                              BITSET_TEST(nir->info.system_values_read, SYSTEM_VALUE_TESS_LEVEL_OUTER);
    info->uses_linear_sample = BITSET_TEST(nir->info.system_values_read, SYSTEM_VALUE_BARYCENTRIC_LINEAR_SAMPLE);
    info->uses_linear_centroid = BITSET_TEST(nir->info.system_values_read, SYSTEM_VALUE_BARYCENTRIC_LINEAR_CENTROID);
    info->uses_linear_center = BITSET_TEST(nir->info.system_values_read, SYSTEM_VALUE_BARYCENTRIC_LINEAR_PIXEL);
@@ -686,12 +687,6 @@ void si_nir_scan_shader(struct si_screen *sscreen, const struct nir_shader *nir,
       info->output_usagemask[info->num_outputs] = 0x1;
    }
 
-   if (nir->info.stage == MESA_SHADER_TESS_EVAL) {
-      /* This is a hack to simplify loading tess levels in TES. */
-      info->input[info->num_inputs].semantic = VARYING_SLOT_TESS_LEVEL_OUTER;
-      info->input[info->num_inputs + 1].semantic = VARYING_SLOT_TESS_LEVEL_INNER;
-   }
-
    if (nir->info.stage == MESA_SHADER_FRAGMENT) {
       info->allow_flat_shading = !(info->uses_persp_center || info->uses_persp_centroid ||
                                    info->uses_persp_sample || info->uses_linear_center ||
diff --git a/src/gallium/drivers/radeonsi/si_shader_llvm.c b/src/gallium/drivers/radeonsi/si_shader_llvm.c
index a1de3d85a350..b52cfad69995 100644
--- a/src/gallium/drivers/radeonsi/si_shader_llvm.c
+++ b/src/gallium/drivers/radeonsi/si_shader_llvm.c
@@ -718,7 +718,6 @@ void si_build_wrapper_function(struct si_shader_context *ctx, LLVMValueRef *part
 static LLVMValueRef si_llvm_load_intrinsic(struct ac_shader_abi *abi, nir_intrinsic_op op)
 {
    struct si_shader_context *ctx = si_shader_context_from_abi(abi);
-   const struct si_shader_info *info = &ctx->shader->selector->info;
 
    switch (op) {
    case nir_intrinsic_load_first_vertex:
@@ -746,12 +745,6 @@ static LLVMValueRef si_llvm_load_intrinsic(struct ac_shader_abi *abi, nir_intrin
       return ac_build_gather_values(&ctx->ac, chan, 3);
    }
 
-   case nir_intrinsic_load_tess_level_outer:
-      return abi->load_tess_varyings(abi, ctx->ac.f32, NULL, NULL, info->num_inputs, 0, 4, true);
-
-   case nir_intrinsic_load_tess_level_inner:
-      return abi->load_tess_varyings(abi, ctx->ac.f32, NULL, NULL, info->num_inputs + 1, 0, 4, true);
-
    case nir_intrinsic_load_tess_level_outer_default:
    case nir_intrinsic_load_tess_level_inner_default: {
       LLVMValueRef slot = LLVMConstInt(ctx->ac.i32, SI_HS_CONST_DEFAULT_TESS_LEVELS, 0);
-- 
GitLab


From bdb17b2951b6873a447b0291905067a99c2d3135 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Sat, 28 May 2022 22:20:08 +0800
Subject: [PATCH 19/30] radeonsi: set uses_vmem_load_other for
 nir_intrinsic_load_buffer_amd
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Before lower TES load input to load buffer, mark this flag for this
intrinsic, otherwise we get corruption with GFX10 after the lowering.

Acked-by: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
Reviewed-by: Timur Kristóf <timur.kristof@gmail.com>
Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/gallium/drivers/radeonsi/si_shader_info.c | 13 ++++++-------
 1 file changed, 6 insertions(+), 7 deletions(-)

diff --git a/src/gallium/drivers/radeonsi/si_shader_info.c b/src/gallium/drivers/radeonsi/si_shader_info.c
index f4d94f07ddd0..68dc0f8205db 100644
--- a/src/gallium/drivers/radeonsi/si_shader_info.c
+++ b/src/gallium/drivers/radeonsi/si_shader_info.c
@@ -435,13 +435,6 @@ static void scan_instruction(const struct nir_shader *nir, struct si_shader_info
             if (!nir_src_is_const(intr->src[1]))
                info->uses_vmem_load_other = true;
             break;
-         case nir_intrinsic_load_constant:
-            info->uses_vmem_load_other = true;
-            break;
-
-         case nir_intrinsic_load_barycentric_at_sample: /* This loads sample positions. */
-            info->uses_vmem_load_other = true;
-            break;
 
          case nir_intrinsic_load_input:
          case nir_intrinsic_load_input_vertex:
@@ -451,6 +444,12 @@ static void scan_instruction(const struct nir_shader *nir, struct si_shader_info
                info->uses_vmem_load_other = true;
             break;
 
+         case nir_intrinsic_load_constant:
+         case nir_intrinsic_load_barycentric_at_sample: /* This loads sample positions. */
+         case nir_intrinsic_load_buffer_amd:
+            info->uses_vmem_load_other = true;
+            break;
+
          default:
             if (is_image ||
                 is_bindless_image ||
-- 
GitLab


From 129f90efd806ee2baf4d36747221818866ccfcc7 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Sat, 28 May 2022 22:23:40 +0800
Subject: [PATCH 20/30] radeonsi: replace llvm tes input load with nir lowering

Acked-by: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/amd/llvm/ac_nir_to_llvm.c                 |   3 +-
 src/gallium/drivers/radeonsi/si_shader.c      |   3 +
 .../drivers/radeonsi/si_shader_internal.h     |   1 -
 src/gallium/drivers/radeonsi/si_shader_llvm.c |   1 -
 .../drivers/radeonsi/si_shader_llvm_tess.c    | 155 ------------------
 5 files changed, 4 insertions(+), 159 deletions(-)

diff --git a/src/amd/llvm/ac_nir_to_llvm.c b/src/amd/llvm/ac_nir_to_llvm.c
index d6551f4d3e63..955b77c46e1c 100644
--- a/src/amd/llvm/ac_nir_to_llvm.c
+++ b/src/amd/llvm/ac_nir_to_llvm.c
@@ -3458,8 +3458,7 @@ static LLVMValueRef visit_load(struct ac_nir_context *ctx, nir_intrinsic_instr *
    else
       indir_index = get_src(ctx, offset);
 
-   if (ctx->stage == MESA_SHADER_TESS_CTRL ||
-       (ctx->stage == MESA_SHADER_TESS_EVAL && !is_output)) {
+   if (ctx->stage == MESA_SHADER_TESS_CTRL) {
       LLVMValueRef result = ctx->abi->load_tess_varyings(ctx->abi, component_type,
                                                          vertex_index, indir_index,
                                                          base, component,
diff --git a/src/gallium/drivers/radeonsi/si_shader.c b/src/gallium/drivers/radeonsi/si_shader.c
index 5e102df047d0..fc3ecf4d18c8 100644
--- a/src/gallium/drivers/radeonsi/si_shader.c
+++ b/src/gallium/drivers/radeonsi/si_shader.c
@@ -1526,6 +1526,9 @@ static bool si_lower_io_to_mem(struct si_shader *shader, nir_shader *nir,
                  !(sel->info.base.inputs_read & ~sel->info.tcs_vgpr_only_inputs),
                  sel->info.tessfactors_are_def_in_all_invocs, false);
       return true;
+   } else if (nir->info.stage == MESA_SHADER_TESS_EVAL) {
+      NIR_PASS_V(nir, ac_nir_lower_tes_inputs_to_mem, si_map_io_driver_location);
+      return true;
    }
 
    return false;
diff --git a/src/gallium/drivers/radeonsi/si_shader_internal.h b/src/gallium/drivers/radeonsi/si_shader_internal.h
index 6bda67d5b7be..f4f4ed89fd95 100644
--- a/src/gallium/drivers/radeonsi/si_shader_internal.h
+++ b/src/gallium/drivers/radeonsi/si_shader_internal.h
@@ -249,7 +249,6 @@ void si_llvm_ls_build_end(struct si_shader_context *ctx);
 void si_llvm_build_tcs_epilog(struct si_shader_context *ctx, union si_shader_part_key *key);
 void si_llvm_tcs_build_end(struct si_shader_context *ctx);
 void si_llvm_init_tcs_callbacks(struct si_shader_context *ctx);
-void si_llvm_init_tes_callbacks(struct si_shader_context *ctx, bool ngg_cull_shader);
 
 /* si_shader_llvm_ps.c */
 LLVMValueRef si_get_sample_id(struct si_shader_context *ctx);
diff --git a/src/gallium/drivers/radeonsi/si_shader_llvm.c b/src/gallium/drivers/radeonsi/si_shader_llvm.c
index b52cfad69995..09b663a192ee 100644
--- a/src/gallium/drivers/radeonsi/si_shader_llvm.c
+++ b/src/gallium/drivers/radeonsi/si_shader_llvm.c
@@ -830,7 +830,6 @@ bool si_llvm_translate_nir(struct si_shader_context *ctx, struct si_shader *shad
       break;
 
    case MESA_SHADER_TESS_EVAL:
-      si_llvm_init_tes_callbacks(ctx, ngg_cull_shader);
       si_llvm_preload_tess_rings(ctx);
       break;
 
diff --git a/src/gallium/drivers/radeonsi/si_shader_llvm_tess.c b/src/gallium/drivers/radeonsi/si_shader_llvm_tess.c
index 4d75f291ccb1..196e83adcaf8 100644
--- a/src/gallium/drivers/radeonsi/si_shader_llvm_tess.c
+++ b/src/gallium/drivers/radeonsi/si_shader_llvm_tess.c
@@ -62,11 +62,6 @@ LLVMValueRef si_get_rel_patch_id(struct si_shader_context *ctx)
  * All three shaders VS(LS), TCS, TES share the same LDS space.
  */
 
-static LLVMValueRef get_tcs_in_patch_stride(struct si_shader_context *ctx)
-{
-   return GET_FIELD(ctx, VS_STATE_LS_OUT_PATCH_SIZE);
-}
-
 static unsigned get_tcs_out_vertex_dw_stride_constant(struct si_shader_context *ctx)
 {
    assert(ctx->stage == MESA_SHADER_TESS_CTRL);
@@ -74,13 +69,6 @@ static unsigned get_tcs_out_vertex_dw_stride_constant(struct si_shader_context *
    return util_last_bit64(ctx->shader->selector->info.outputs_written) * 4;
 }
 
-static LLVMValueRef get_tcs_out_vertex_dw_stride(struct si_shader_context *ctx)
-{
-   unsigned stride = get_tcs_out_vertex_dw_stride_constant(ctx);
-
-   return LLVMConstInt(ctx->ac.i32, stride, 0);
-}
-
 static LLVMValueRef get_tcs_out_patch_stride(struct si_shader_context *ctx)
 {
    const struct si_shader_info *info = &ctx->shader->selector->info;
@@ -91,35 +79,12 @@ static LLVMValueRef get_tcs_out_patch_stride(struct si_shader_context *ctx)
    return LLVMConstInt(ctx->ac.i32, patch_dw_stride, 0);
 }
 
-static LLVMValueRef get_tcs_out_patch0_offset(struct si_shader_context *ctx)
-{
-   return LLVMBuildMul(ctx->ac.builder, si_unpack_param(ctx, ctx->tcs_out_lds_offsets, 0, 16),
-                       LLVMConstInt(ctx->ac.i32, 4, 0), "");
-}
-
 static LLVMValueRef get_tcs_out_patch0_patch_data_offset(struct si_shader_context *ctx)
 {
    return LLVMBuildMul(ctx->ac.builder, si_unpack_param(ctx, ctx->tcs_out_lds_offsets, 16, 16),
                        LLVMConstInt(ctx->ac.i32, 4, 0), "");
 }
 
-static LLVMValueRef get_tcs_in_current_patch_offset(struct si_shader_context *ctx)
-{
-   LLVMValueRef patch_stride = get_tcs_in_patch_stride(ctx);
-   LLVMValueRef rel_patch_id = si_get_rel_patch_id(ctx);
-
-   return LLVMBuildMul(ctx->ac.builder, patch_stride, rel_patch_id, "");
-}
-
-static LLVMValueRef get_tcs_out_current_patch_offset(struct si_shader_context *ctx)
-{
-   LLVMValueRef patch0_offset = get_tcs_out_patch0_offset(ctx);
-   LLVMValueRef patch_stride = get_tcs_out_patch_stride(ctx);
-   LLVMValueRef rel_patch_id = si_get_rel_patch_id(ctx);
-
-   return ac_build_imad(&ctx->ac, patch_stride, rel_patch_id, patch0_offset);
-}
-
 static LLVMValueRef get_tcs_out_current_patch_data_offset(struct si_shader_context *ctx)
 {
    LLVMValueRef patch0_patch_data_offset = get_tcs_out_patch0_patch_data_offset(ctx);
@@ -165,29 +130,6 @@ LLVMValueRef si_get_tcs_in_vertex_dw_stride(struct si_shader_context *ctx)
    }
 }
 
-static LLVMValueRef
-get_dw_address_from_generic_indices(struct si_shader_context *ctx, LLVMValueRef vertex_dw_stride,
-                                    LLVMValueRef base_addr, LLVMValueRef vertex_index,
-                                    LLVMValueRef param_index, ubyte name)
-{
-   if (vertex_dw_stride) {
-      base_addr = ac_build_imad(&ctx->ac, vertex_index, vertex_dw_stride, base_addr);
-   }
-
-   if (param_index) {
-      base_addr = ac_build_imad(&ctx->ac, param_index, LLVMConstInt(ctx->ac.i32, 4, 0), base_addr);
-   }
-
-   int param = name >= VARYING_SLOT_PATCH0 ||
-               name == VARYING_SLOT_TESS_LEVEL_INNER ||
-               name == VARYING_SLOT_TESS_LEVEL_OUTER
-                  ? si_shader_io_get_unique_index_patch(name)
-                  : si_shader_io_get_unique_index(name, false);
-
-   /* Add the base address of the element. */
-   return LLVMBuildAdd(ctx->ac.builder, base_addr, LLVMConstInt(ctx->ac.i32, param * 4, 0), "");
-}
-
 /* The offchip buffer layout for TCS->TES is
  *
  * - attribute 0 of patch 0 vertex 0
@@ -238,51 +180,6 @@ static LLVMValueRef get_tcs_tes_buffer_address(struct si_shader_context *ctx,
    return base_addr;
 }
 
-static LLVMValueRef get_tcs_tes_buffer_address_from_generic_indices(struct si_shader_context *ctx,
-                                                                    LLVMValueRef vertex_index,
-                                                                    LLVMValueRef param_index,
-                                                                    ubyte name)
-{
-   unsigned param_index_base;
-
-   param_index_base = name >= VARYING_SLOT_PATCH0 ||
-                      name == VARYING_SLOT_TESS_LEVEL_INNER ||
-                      name == VARYING_SLOT_TESS_LEVEL_OUTER
-                         ? si_shader_io_get_unique_index_patch(name)
-                         : si_shader_io_get_unique_index(name, false);
-
-   if (param_index) {
-      param_index = LLVMBuildAdd(ctx->ac.builder, param_index,
-                                 LLVMConstInt(ctx->ac.i32, param_index_base, 0), "");
-   } else {
-      param_index = LLVMConstInt(ctx->ac.i32, param_index_base, 0);
-   }
-
-   return get_tcs_tes_buffer_address(ctx, si_get_rel_patch_id(ctx), vertex_index, param_index);
-}
-
-static LLVMValueRef buffer_load(struct si_shader_context *ctx, LLVMTypeRef type, unsigned swizzle,
-                                LLVMValueRef buffer, LLVMValueRef offset, LLVMValueRef base,
-                                bool can_speculate)
-{
-   LLVMValueRef value;
-   LLVMTypeRef vec_type = LLVMVectorType(type, 4);
-
-   if (swizzle == ~0) {
-      value = ac_build_buffer_load(&ctx->ac, buffer, 4, NULL, base, offset, type, ac_glc,
-                                   can_speculate, false);
-
-      return LLVMBuildBitCast(ctx->ac.builder, value, vec_type, "");
-   }
-
-   value = ac_build_buffer_load(&ctx->ac, buffer, 4, NULL, base, offset, type, ac_glc,
-                                can_speculate, false);
-
-   value = LLVMBuildBitCast(ctx->ac.builder, value, vec_type, "");
-   return LLVMBuildExtractElement(ctx->ac.builder, value, LLVMConstInt(ctx->ac.i32, swizzle, 0),
-                                  "");
-}
-
 /**
  * Load from LSHS LDS storage.
  *
@@ -309,22 +206,6 @@ static LLVMValueRef lshs_lds_load(struct si_shader_context *ctx, LLVMTypeRef typ
    return LLVMBuildBitCast(ctx->ac.builder, value, type, "");
 }
 
-/**
- * Store to LSHS LDS storage.
- *
- * \param swizzle	offset (typically 0..3)
- * \param dw_addr	address in dwords
- * \param value		value to store
- */
-static void lshs_lds_store(struct si_shader_context *ctx, unsigned dw_offset_imm,
-                           LLVMValueRef dw_addr, LLVMValueRef value)
-{
-   dw_addr =
-      LLVMBuildAdd(ctx->ac.builder, dw_addr, LLVMConstInt(ctx->ac.i32, dw_offset_imm, 0), "");
-
-   ac_lds_store(&ctx->ac, dw_addr, value);
-}
-
 enum si_tess_ring
 {
    TCS_FACTOR_RING,
@@ -400,37 +281,6 @@ static LLVMValueRef si_nir_load_tcs_varyings(struct ac_shader_abi *abi, LLVMType
    return ac_build_varying_gather_values(&ctx->ac, value, num_components, component);
 }
 
-static LLVMValueRef si_nir_load_input_tes(struct ac_shader_abi *abi, LLVMTypeRef type,
-                                          LLVMValueRef vertex_index, LLVMValueRef param_index,
-                                          unsigned driver_location, unsigned component,
-                                          unsigned num_components, bool load_input)
-{
-   struct si_shader_context *ctx = si_shader_context_from_abi(abi);
-   struct si_shader_info *info = &ctx->shader->selector->info;
-   LLVMValueRef base, addr;
-
-   ubyte semantic = info->input[driver_location].semantic;
-
-   assert((semantic >= VARYING_SLOT_PATCH0 ||
-           semantic == VARYING_SLOT_TESS_LEVEL_INNER ||
-           semantic == VARYING_SLOT_TESS_LEVEL_OUTER) == (vertex_index == NULL));
-
-   base = ac_get_arg(&ctx->ac, ctx->args.tess_offchip_offset);
-
-   addr =
-      get_tcs_tes_buffer_address_from_generic_indices(ctx, vertex_index, param_index, semantic);
-
-   /* TODO: This will generate rather ordinary llvm code, although it
-    * should be easy for the optimizer to fix up. In future we might want
-    * to refactor buffer_load().
-    */
-   LLVMValueRef value[4];
-   for (unsigned i = component; i < component + num_components; i++)
-      value[i] = buffer_load(ctx, type, i, ctx->tess_offchip_ring, base, addr, true);
-
-   return ac_build_varying_gather_values(&ctx->ac, value, num_components, component);
-}
-
 static void si_write_tess_factors(struct si_shader_context *ctx, union si_shader_part_key *key,
                                   LLVMValueRef rel_patch_id, LLVMValueRef invocation_id,
                                   LLVMValueRef tcs_out_current_patch_data_offset,
@@ -822,8 +672,3 @@ void si_llvm_init_tcs_callbacks(struct si_shader_context *ctx)
 {
    ctx->abi.load_tess_varyings = si_nir_load_tcs_varyings;
 }
-
-void si_llvm_init_tes_callbacks(struct si_shader_context *ctx, bool ngg_cull_shader)
-{
-   ctx->abi.load_tess_varyings = si_nir_load_input_tes;
-}
-- 
GitLab


From 01f5f3a8abfbe285e06883c8bf0356eeabf30073 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Mon, 30 May 2022 14:28:32 +0800
Subject: [PATCH 21/30] ac/llvm: fix code format alignment in
 visit_load_local_invocation_index
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Used tab instead of space.

Reviewed-by: Timur Kristóf <timur.kristof@gmail.com>
Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/amd/llvm/ac_nir_to_llvm.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/src/amd/llvm/ac_nir_to_llvm.c b/src/amd/llvm/ac_nir_to_llvm.c
index 955b77c46e1c..456f4a812dbe 100644
--- a/src/amd/llvm/ac_nir_to_llvm.c
+++ b/src/amd/llvm/ac_nir_to_llvm.c
@@ -3031,8 +3031,8 @@ static LLVMValueRef visit_load_local_invocation_index(struct ac_nir_context *ctx
       /* Thread ID in threadgroup in merged ESGS. */
       LLVMValueRef wave_id = ac_unpack_param(&ctx->ac, ac_get_arg(&ctx->ac, ctx->args->merged_wave_info), 24, 4);
       LLVMValueRef wave_size = LLVMConstInt(ctx->ac.i32, ctx->ac.wave_size, false);
-	   LLVMValueRef threads_before = LLVMBuildMul(ctx->ac.builder, wave_id, wave_size, "");
-	   return LLVMBuildAdd(ctx->ac.builder, threads_before, ac_get_thread_id(&ctx->ac), "");
+      LLVMValueRef threads_before = LLVMBuildMul(ctx->ac.builder, wave_id, wave_size, "");
+      return LLVMBuildAdd(ctx->ac.builder, threads_before, ac_get_thread_id(&ctx->ac), "");
    }
 
    LLVMValueRef result;
-- 
GitLab


From 8645f8abffeff6f048717c632d72501ae1e8b53f Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Mon, 30 May 2022 14:41:08 +0800
Subject: [PATCH 22/30] radeonsi: implement two esgs ring nir intrinsic
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

nir_intrinsic_load_ring_esgs_amd
nir_intrinsic_load_ring_es2gs_offset_amd

Will be used by esgs lowering.

Reviewed-by: Timur Kristóf <timur.kristof@gmail.com>
Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/amd/llvm/ac_nir_to_llvm.c                 | 1 +
 src/gallium/drivers/radeonsi/si_shader_llvm.c | 6 ++++++
 2 files changed, 7 insertions(+)

diff --git a/src/amd/llvm/ac_nir_to_llvm.c b/src/amd/llvm/ac_nir_to_llvm.c
index 456f4a812dbe..251195249d9d 100644
--- a/src/amd/llvm/ac_nir_to_llvm.c
+++ b/src/amd/llvm/ac_nir_to_llvm.c
@@ -3619,6 +3619,7 @@ static void visit_intrinsic(struct ac_nir_context *ctx, nir_intrinsic_instr *ins
    case nir_intrinsic_load_ring_tess_offchip_amd:
    case nir_intrinsic_load_ring_tess_offchip_offset_amd:
    case nir_intrinsic_load_ring_esgs_amd:
+   case nir_intrinsic_load_ring_es2gs_offset_amd:
    case nir_intrinsic_load_lshs_vertex_stride_amd:
    case nir_intrinsic_load_tcs_num_patches_amd:
    case nir_intrinsic_load_hs_out_patch_data_offset_amd:
diff --git a/src/gallium/drivers/radeonsi/si_shader_llvm.c b/src/gallium/drivers/radeonsi/si_shader_llvm.c
index 09b663a192ee..12585b18ff24 100644
--- a/src/gallium/drivers/radeonsi/si_shader_llvm.c
+++ b/src/gallium/drivers/radeonsi/si_shader_llvm.c
@@ -790,6 +790,12 @@ static LLVMValueRef si_llvm_load_intrinsic(struct ac_shader_abi *abi, nir_intrin
    case nir_intrinsic_load_tess_rel_patch_id_amd:
       return si_get_rel_patch_id(ctx);
 
+   case nir_intrinsic_load_ring_esgs_amd:
+      return ctx->esgs_ring;
+
+   case nir_intrinsic_load_ring_es2gs_offset_amd:
+      return ac_get_arg(&ctx->ac, ctx->args.es2gs_offset);
+
    default:
       return NULL;
    }
-- 
GitLab


From 9076963e0a989b69459827f8137add023593c2af Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Mon, 30 May 2022 14:52:57 +0800
Subject: [PATCH 23/30] ac/nir: skip gl_ViewportIndex and gl_Layer write in ES
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Reviewed-by: Timur Kristóf <timur.kristof@gmail.com>
Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/amd/common/ac_nir_lower_esgs_io_to_mem.c | 32 ++++++++++++++++++++
 1 file changed, 32 insertions(+)

diff --git a/src/amd/common/ac_nir_lower_esgs_io_to_mem.c b/src/amd/common/ac_nir_lower_esgs_io_to_mem.c
index 9cd7f4d6f9b0..70aad36106f1 100644
--- a/src/amd/common/ac_nir_lower_esgs_io_to_mem.c
+++ b/src/amd/common/ac_nir_lower_esgs_io_to_mem.c
@@ -124,6 +124,38 @@ lower_es_output_store(nir_builder *b,
    if (intrin->intrinsic != nir_intrinsic_store_output)
       return false;
 
+   /* The ARB_shader_viewport_layer_array spec contains the
+    * following issue:
+    *
+    *    2) What happens if gl_ViewportIndex or gl_Layer is
+    *    written in the vertex shader and a geometry shader is
+    *    present?
+    *
+    *    RESOLVED: The value written by the last vertex processing
+    *    stage is used. If the last vertex processing stage
+    *    (vertex, tessellation evaluation or geometry) does not
+    *    statically assign to gl_ViewportIndex or gl_Layer, index
+    *    or layer zero is assumed.
+    *
+    * Vulkan spec 15.7 Built-In Variables:
+    *
+    *   The last active pre-rasterization shader stage (in pipeline order)
+    *   controls the Layer that is used. Outputs in previous shader stages
+    *   are not used, even if the last stage fails to write the Layer.
+    *
+    *   The last active pre-rasterization shader stage (in pipeline order)
+    *   controls the ViewportIndex that is used. Outputs in previous shader
+    *   stages are not used, even if the last stage fails to write the
+    *   ViewportIndex.
+    *
+    * So writes to those outputs in ES are simply ignored.
+    */
+   unsigned semantic = nir_intrinsic_io_semantics(intrin).location;
+   if (semantic == VARYING_SLOT_LAYER || semantic == VARYING_SLOT_VIEWPORT) {
+      nir_instr_remove(instr);
+      return true;
+   }
+
    lower_esgs_io_state *st = (lower_esgs_io_state *) state;
    unsigned write_mask = nir_intrinsic_write_mask(intrin);
 
-- 
GitLab


From 870361872e07f528d565a2a4aa1eb85664a76688 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Tue, 31 May 2022 10:35:28 +0800
Subject: [PATCH 24/30] radeonsi: set lds for gs/es to handle nir shared memory
 load/store

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/gallium/drivers/radeonsi/si_shader_llvm_gs.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/src/gallium/drivers/radeonsi/si_shader_llvm_gs.c b/src/gallium/drivers/radeonsi/si_shader_llvm_gs.c
index 9c1e9999737f..66f1686378a5 100644
--- a/src/gallium/drivers/radeonsi/si_shader_llvm_gs.c
+++ b/src/gallium/drivers/radeonsi/si_shader_llvm_gs.c
@@ -395,6 +395,7 @@ void si_preload_esgs_ring(struct si_shader_context *ctx)
       if (USE_LDS_SYMBOLS) {
          /* Declare the ESGS ring as an explicit LDS symbol. */
          si_llvm_declare_esgs_ring(ctx);
+         ctx->ac.lds = ctx->esgs_ring;
       } else {
          ac_declare_lds_as_pointer(&ctx->ac);
          ctx->esgs_ring = ctx->ac.lds;
-- 
GitLab


From b9b21e1f7b8f31846704f974e468688d575e3aa3 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Mon, 30 May 2022 20:06:03 +0800
Subject: [PATCH 25/30] ac/nir: remove unused param num_reserved_es_outputs
 from gs input lower
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Reviewed-by: Timur Kristóf <timur.kristof@gmail.com>
Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/amd/common/ac_nir.h                      | 3 +--
 src/amd/common/ac_nir_lower_esgs_io_to_mem.c | 4 +---
 src/amd/vulkan/radv_shader.c                 | 3 +--
 3 files changed, 3 insertions(+), 7 deletions(-)

diff --git a/src/amd/common/ac_nir.h b/src/amd/common/ac_nir.h
index 437c2ca13528..0c34bad5e1b6 100644
--- a/src/amd/common/ac_nir.h
+++ b/src/amd/common/ac_nir.h
@@ -107,8 +107,7 @@ ac_nir_lower_es_outputs_to_mem(nir_shader *shader,
 void
 ac_nir_lower_gs_inputs_to_mem(nir_shader *shader,
                               ac_nir_map_io_driver_location map,
-                              enum amd_gfx_level gfx_level,
-                              unsigned num_reserved_es_outputs);
+                              enum amd_gfx_level gfx_level);
 
 bool
 ac_nir_lower_indirect_derefs(nir_shader *shader,
diff --git a/src/amd/common/ac_nir_lower_esgs_io_to_mem.c b/src/amd/common/ac_nir_lower_esgs_io_to_mem.c
index 70aad36106f1..2f79e5a6d6dc 100644
--- a/src/amd/common/ac_nir_lower_esgs_io_to_mem.c
+++ b/src/amd/common/ac_nir_lower_esgs_io_to_mem.c
@@ -284,12 +284,10 @@ ac_nir_lower_es_outputs_to_mem(nir_shader *shader,
 void
 ac_nir_lower_gs_inputs_to_mem(nir_shader *shader,
                               ac_nir_map_io_driver_location map,
-                              enum amd_gfx_level gfx_level,
-                              unsigned num_reserved_es_outputs)
+                              enum amd_gfx_level gfx_level)
 {
    lower_esgs_io_state state = {
       .gfx_level = gfx_level,
-      .num_reserved_es_outputs = num_reserved_es_outputs,
       .map_io = map,
    };
 
diff --git a/src/amd/vulkan/radv_shader.c b/src/amd/vulkan/radv_shader.c
index 6690fdf04918..4ce417bcbcfa 100644
--- a/src/amd/vulkan/radv_shader.c
+++ b/src/amd/vulkan/radv_shader.c
@@ -1091,8 +1091,7 @@ radv_lower_io_to_mem(struct radv_device *device, struct radv_pipeline_stage *sta
       return true;
    } else if (nir->info.stage == MESA_SHADER_GEOMETRY) {
       NIR_PASS_V(nir, ac_nir_lower_gs_inputs_to_mem, NULL,
-                 device->physical_device->rad_info.gfx_level,
-                 info->gs.num_linked_inputs);
+                 device->physical_device->rad_info.gfx_level);
       return true;
    } else if (nir->info.stage == MESA_SHADER_TASK) {
       ac_nir_apply_first_task_to_task_shader(nir);
-- 
GitLab


From 8ee59d9c7331ba98bd4ca03484d4bfb633488e46 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Tue, 31 May 2022 14:18:17 +0800
Subject: [PATCH 26/30] ac/nir: change es output lower param to esgs_itemsize
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

radeonsi may add extra dword to the stride, so let's pass it
directly.

Reviewed-by: Timur Kristóf <timur.kristof@gmail.com>
Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/amd/common/ac_nir.h                      |  2 +-
 src/amd/common/ac_nir_lower_esgs_io_to_mem.c | 13 +++++--------
 src/amd/vulkan/radv_shader.c                 |  6 ++++--
 3 files changed, 10 insertions(+), 11 deletions(-)

diff --git a/src/amd/common/ac_nir.h b/src/amd/common/ac_nir.h
index 0c34bad5e1b6..6844c2d87aec 100644
--- a/src/amd/common/ac_nir.h
+++ b/src/amd/common/ac_nir.h
@@ -102,7 +102,7 @@ void
 ac_nir_lower_es_outputs_to_mem(nir_shader *shader,
                                ac_nir_map_io_driver_location map,
                                enum amd_gfx_level gfx_level,
-                               unsigned num_reserved_es_outputs);
+                               unsigned esgs_itemsize);
 
 void
 ac_nir_lower_gs_inputs_to_mem(nir_shader *shader,
diff --git a/src/amd/common/ac_nir_lower_esgs_io_to_mem.c b/src/amd/common/ac_nir_lower_esgs_io_to_mem.c
index 2f79e5a6d6dc..611ac445810d 100644
--- a/src/amd/common/ac_nir_lower_esgs_io_to_mem.c
+++ b/src/amd/common/ac_nir_lower_esgs_io_to_mem.c
@@ -47,10 +47,8 @@ typedef struct {
    /* I/O semantic -> real location used by lowering. */
    ac_nir_map_io_driver_location map_io;
 
-   /* Number of ES outputs for which memory should be reserved.
-    * When compacted, this should be the number of linked ES outputs.
-    */
-   unsigned num_reserved_es_outputs;
+   /* Stride of an ES invocation outputs in esgs ring, in bytes. */
+   unsigned esgs_itemsize;
 } lower_esgs_io_state;
 
 static nir_ssa_def *
@@ -171,9 +169,8 @@ lower_es_output_store(nir_builder *b,
                               write_mask, true, true);
    } else {
       /* GFX9+: ES is merged into GS, data is passed through LDS. */
-      unsigned esgs_itemsize = st->num_reserved_es_outputs * 16u;
       nir_ssa_def *vertex_idx = nir_build_load_local_invocation_index(b);
-      nir_ssa_def *off = nir_iadd(b, nir_imul_imm(b, vertex_idx, esgs_itemsize), io_off);
+      nir_ssa_def *off = nir_iadd(b, nir_imul_imm(b, vertex_idx, st->esgs_itemsize), io_off);
       nir_build_store_shared(b, intrin->src[0].ssa, off, .write_mask = write_mask,
                              .align_mul = 16u, .align_offset = (nir_intrinsic_component(intrin) * 4u) % 16u);
    }
@@ -267,11 +264,11 @@ void
 ac_nir_lower_es_outputs_to_mem(nir_shader *shader,
                                ac_nir_map_io_driver_location map,
                                enum amd_gfx_level gfx_level,
-                               unsigned num_reserved_es_outputs)
+                               unsigned esgs_itemsize)
 {
    lower_esgs_io_state state = {
       .gfx_level = gfx_level,
-      .num_reserved_es_outputs = num_reserved_es_outputs,
+      .esgs_itemsize = esgs_itemsize,
       .map_io = map,
    };
 
diff --git a/src/amd/vulkan/radv_shader.c b/src/amd/vulkan/radv_shader.c
index 4ce417bcbcfa..94cf51148e49 100644
--- a/src/amd/vulkan/radv_shader.c
+++ b/src/amd/vulkan/radv_shader.c
@@ -1067,7 +1067,8 @@ radv_lower_io_to_mem(struct radv_device *device, struct radv_pipeline_stage *sta
          return true;
       } else if (info->vs.as_es) {
          NIR_PASS_V(nir, ac_nir_lower_es_outputs_to_mem, NULL,
-                    device->physical_device->rad_info.gfx_level, info->vs.num_linked_outputs);
+                    device->physical_device->rad_info.gfx_level,
+                    info->vs.num_linked_outputs * 16u);
          return true;
       }
    } else if (nir->info.stage == MESA_SHADER_TESS_CTRL) {
@@ -1085,7 +1086,8 @@ radv_lower_io_to_mem(struct radv_device *device, struct radv_pipeline_stage *sta
 
       if (info->tes.as_es) {
          NIR_PASS_V(nir, ac_nir_lower_es_outputs_to_mem, NULL,
-                    device->physical_device->rad_info.gfx_level, info->tes.num_linked_outputs);
+                    device->physical_device->rad_info.gfx_level,
+                    info->tes.num_linked_outputs * 16u);
       }
 
       return true;
-- 
GitLab


From 9f87f4cb62f361324b9e83ef728eff2ce42466e7 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Mon, 30 May 2022 15:03:40 +0800
Subject: [PATCH 27/30] radeonsi: replace llvm es output with nir lowering

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/gallium/drivers/radeonsi/si_shader.c      | 10 ++++
 .../drivers/radeonsi/si_shader_llvm_gs.c      | 51 -------------------
 2 files changed, 10 insertions(+), 51 deletions(-)

diff --git a/src/gallium/drivers/radeonsi/si_shader.c b/src/gallium/drivers/radeonsi/si_shader.c
index fc3ecf4d18c8..a439923fcff2 100644
--- a/src/gallium/drivers/radeonsi/si_shader.c
+++ b/src/gallium/drivers/radeonsi/si_shader.c
@@ -1510,6 +1510,10 @@ static bool si_lower_io_to_mem(struct si_shader *shader, nir_shader *nir,
          NIR_PASS_V(nir, ac_nir_lower_ls_outputs_to_mem, si_map_io_driver_location,
                     key->ge.opt.same_patch_vertices, tcs_vgpr_only_inputs);
          return true;
+      } else if (key->ge.as_es) {
+         NIR_PASS_V(nir, ac_nir_lower_es_outputs_to_mem, si_map_io_driver_location,
+                    sel->screen->info.gfx_level, sel->info.esgs_itemsize);
+         return true;
       }
    } else if (nir->info.stage == MESA_SHADER_TESS_CTRL) {
       NIR_PASS_V(nir, ac_nir_lower_hs_inputs_to_mem, si_map_io_driver_location,
@@ -1528,6 +1532,12 @@ static bool si_lower_io_to_mem(struct si_shader *shader, nir_shader *nir,
       return true;
    } else if (nir->info.stage == MESA_SHADER_TESS_EVAL) {
       NIR_PASS_V(nir, ac_nir_lower_tes_inputs_to_mem, si_map_io_driver_location);
+
+      if (key->ge.as_es) {
+         NIR_PASS_V(nir, ac_nir_lower_es_outputs_to_mem, si_map_io_driver_location,
+                    sel->screen->info.gfx_level, sel->info.esgs_itemsize);
+      }
+
       return true;
    }
 
diff --git a/src/gallium/drivers/radeonsi/si_shader_llvm_gs.c b/src/gallium/drivers/radeonsi/si_shader_llvm_gs.c
index 66f1686378a5..54c9b629296f 100644
--- a/src/gallium/drivers/radeonsi/si_shader_llvm_gs.c
+++ b/src/gallium/drivers/radeonsi/si_shader_llvm_gs.c
@@ -137,57 +137,6 @@ static void si_set_es_return_value_for_gs(struct si_shader_context *ctx)
 
 void si_llvm_es_build_end(struct si_shader_context *ctx)
 {
-   struct si_shader *es = ctx->shader;
-   struct si_shader_info *info = &es->selector->info;
-   LLVMValueRef *addrs = ctx->abi.outputs;
-   LLVMValueRef lds_base = NULL;
-   unsigned chan;
-   int i;
-
-   if (ctx->screen->info.gfx_level >= GFX9 && info->num_outputs) {
-      unsigned itemsize_dw = es->selector->info.esgs_itemsize / 4;
-      LLVMValueRef vertex_idx = ac_get_thread_id(&ctx->ac);
-      LLVMValueRef wave_idx = si_unpack_param(ctx, ctx->args.merged_wave_info, 24, 4);
-      vertex_idx =
-         LLVMBuildOr(ctx->ac.builder, vertex_idx,
-                     LLVMBuildMul(ctx->ac.builder, wave_idx,
-                                  LLVMConstInt(ctx->ac.i32, ctx->ac.wave_size, false), ""),
-                     "");
-      lds_base =
-         LLVMBuildMul(ctx->ac.builder, vertex_idx, LLVMConstInt(ctx->ac.i32, itemsize_dw, 0), "");
-   }
-
-   for (i = 0; i < info->num_outputs; i++) {
-      int param;
-
-      if (info->output_semantic[i] == VARYING_SLOT_VIEWPORT ||
-          info->output_semantic[i] == VARYING_SLOT_LAYER)
-         continue;
-
-      param = si_shader_io_get_unique_index(info->output_semantic[i], false);
-
-      for (chan = 0; chan < 4; chan++) {
-         if (!(info->output_usagemask[i] & (1 << chan)))
-            continue;
-
-         LLVMValueRef out_val = LLVMBuildLoad(ctx->ac.builder, addrs[4 * i + chan], "");
-         out_val = ac_to_integer(&ctx->ac, out_val);
-
-         /* GFX9 has the ESGS ring in LDS. */
-         if (ctx->screen->info.gfx_level >= GFX9) {
-            LLVMValueRef idx = LLVMConstInt(ctx->ac.i32, param * 4 + chan, false);
-            idx = LLVMBuildAdd(ctx->ac.builder, lds_base, idx, "");
-            ac_build_indexed_store(&ctx->ac, ctx->esgs_ring, idx, out_val);
-            continue;
-         }
-
-         ac_build_buffer_store_dword(&ctx->ac, ctx->esgs_ring, out_val, NULL,
-                                     LLVMConstInt(ctx->ac.i32, (4 * param + chan) * 4, 0),
-                                     ac_get_arg(&ctx->ac, ctx->args.es2gs_offset),
-                                     ac_glc | ac_slc | ac_swizzled);
-      }
-   }
-
    if (ctx->screen->info.gfx_level >= GFX9)
       si_set_es_return_value_for_gs(ctx);
 }
-- 
GitLab


From 190d1f7b065c91951575d78b9841c6593d081f10 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Mon, 30 May 2022 19:46:15 +0800
Subject: [PATCH 28/30] ac/nir: add triangle_strip_adjacency_fix to gs input
 lower
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

From radeonsi.

Acked-by: Timur Kristóf <timur.kristof@gmail.com>
Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/amd/common/ac_nir.h                      |  3 +-
 src/amd/common/ac_nir_lower_esgs_io_to_mem.c | 54 ++++++++++++++++----
 src/amd/vulkan/radv_shader.c                 |  2 +-
 3 files changed, 46 insertions(+), 13 deletions(-)

diff --git a/src/amd/common/ac_nir.h b/src/amd/common/ac_nir.h
index 6844c2d87aec..5573a52bb21a 100644
--- a/src/amd/common/ac_nir.h
+++ b/src/amd/common/ac_nir.h
@@ -107,7 +107,8 @@ ac_nir_lower_es_outputs_to_mem(nir_shader *shader,
 void
 ac_nir_lower_gs_inputs_to_mem(nir_shader *shader,
                               ac_nir_map_io_driver_location map,
-                              enum amd_gfx_level gfx_level);
+                              enum amd_gfx_level gfx_level,
+                              bool triangle_strip_adjacency_fix);
 
 bool
 ac_nir_lower_indirect_derefs(nir_shader *shader,
diff --git a/src/amd/common/ac_nir_lower_esgs_io_to_mem.c b/src/amd/common/ac_nir_lower_esgs_io_to_mem.c
index 611ac445810d..54a1583111f0 100644
--- a/src/amd/common/ac_nir_lower_esgs_io_to_mem.c
+++ b/src/amd/common/ac_nir_lower_esgs_io_to_mem.c
@@ -49,6 +49,9 @@ typedef struct {
 
    /* Stride of an ES invocation outputs in esgs ring, in bytes. */
    unsigned esgs_itemsize;
+
+   /* Enable fix for triangle strip adjacency in geometry shader. */
+   bool gs_triangle_strip_adjacency_fix;
 } lower_esgs_io_state;
 
 static nir_ssa_def *
@@ -180,16 +183,42 @@ lower_es_output_store(nir_builder *b,
 }
 
 static nir_ssa_def *
-gs_per_vertex_input_vertex_offset_gfx6(nir_builder *b, nir_src *vertex_src)
+gs_get_vertex_offset(nir_builder *b, lower_esgs_io_state *st, unsigned vertex_index)
+{
+   nir_ssa_def *origin = nir_build_load_gs_vertex_offset_amd(b, .base = vertex_index);
+   if (!st->gs_triangle_strip_adjacency_fix)
+      return origin;
+
+   unsigned fixed_index;
+   if (st->gfx_level < GFX9) {
+      /* Rotate vertex index by 2. */
+      fixed_index = (vertex_index + 4) % 6;
+   } else {
+      /* This issue has been fixed for GFX10+ */
+      assert(st->gfx_level == GFX9);
+      /* 6 vertex offset are packed to 3 vgprs for GFX9+ */
+      fixed_index = (vertex_index + 2) % 3;
+   }
+   nir_ssa_def *fixed = nir_build_load_gs_vertex_offset_amd(b, .base = fixed_index);
+
+   nir_ssa_def *prim_id = nir_load_primitive_id(b);
+   /* odd primitive id use fixed offset */
+   nir_ssa_def *cond = nir_i2b(b, nir_iand_imm(b, prim_id, 1));
+   return nir_bcsel(b, cond, fixed, origin);
+}
+
+static nir_ssa_def *
+gs_per_vertex_input_vertex_offset_gfx6(nir_builder *b, lower_esgs_io_state *st,
+                                       nir_src *vertex_src)
 {
    if (nir_src_is_const(*vertex_src))
-      return nir_build_load_gs_vertex_offset_amd(b, .base = nir_src_as_uint(*vertex_src));
+      return gs_get_vertex_offset(b, st, nir_src_as_uint(*vertex_src));
 
-   nir_ssa_def *vertex_offset = nir_build_load_gs_vertex_offset_amd(b, .base = 0);
+   nir_ssa_def *vertex_offset = gs_get_vertex_offset(b, st, 0);
 
    for (unsigned i = 1; i < b->shader->info.gs.vertices_in; ++i) {
       nir_ssa_def *cond = nir_ieq_imm(b, vertex_src->ssa, i);
-      nir_ssa_def *elem = nir_build_load_gs_vertex_offset_amd(b, .base = i);
+      nir_ssa_def *elem = gs_get_vertex_offset(b, st, i);
       vertex_offset = nir_bcsel(b, cond, elem, vertex_offset);
    }
 
@@ -197,19 +226,20 @@ gs_per_vertex_input_vertex_offset_gfx6(nir_builder *b, nir_src *vertex_src)
 }
 
 static nir_ssa_def *
-gs_per_vertex_input_vertex_offset_gfx9(nir_builder *b, nir_src *vertex_src)
+gs_per_vertex_input_vertex_offset_gfx9(nir_builder *b, lower_esgs_io_state *st,
+                                       nir_src *vertex_src)
 {
    if (nir_src_is_const(*vertex_src)) {
       unsigned vertex = nir_src_as_uint(*vertex_src);
-      return nir_ubfe(b, nir_build_load_gs_vertex_offset_amd(b, .base = vertex / 2u),
+      return nir_ubfe(b, gs_get_vertex_offset(b, st, vertex / 2u),
                       nir_imm_int(b, (vertex & 1u) * 16u), nir_imm_int(b, 16u));
    }
 
-   nir_ssa_def *vertex_offset = nir_build_load_gs_vertex_offset_amd(b, .base = 0);
+   nir_ssa_def *vertex_offset = gs_get_vertex_offset(b, st, 0);
 
    for (unsigned i = 1; i < b->shader->info.gs.vertices_in; i++) {
       nir_ssa_def *cond = nir_ieq_imm(b, vertex_src->ssa, i);
-      nir_ssa_def *elem = nir_build_load_gs_vertex_offset_amd(b, .base = i / 2u * 2u);
+      nir_ssa_def *elem = gs_get_vertex_offset(b, st, i / 2u * 2u);
       if (i % 2u)
          elem = nir_ishr_imm(b, elem, 16u);
 
@@ -226,8 +256,8 @@ gs_per_vertex_input_offset(nir_builder *b,
 {
    nir_src *vertex_src = nir_get_io_arrayed_index_src(instr);
    nir_ssa_def *vertex_offset = st->gfx_level >= GFX9
-                                ? gs_per_vertex_input_vertex_offset_gfx9(b, vertex_src)
-                                : gs_per_vertex_input_vertex_offset_gfx6(b, vertex_src);
+      ? gs_per_vertex_input_vertex_offset_gfx9(b, st, vertex_src)
+      : gs_per_vertex_input_vertex_offset_gfx6(b, st, vertex_src);
 
    unsigned base_stride = st->gfx_level >= GFX9 ? 1 : 64 /* Wave size on GFX6-8 */;
    nir_ssa_def *io_off = ac_nir_calc_io_offset(b, instr, nir_imm_int(b, base_stride * 4u), base_stride, st->map_io);
@@ -281,11 +311,13 @@ ac_nir_lower_es_outputs_to_mem(nir_shader *shader,
 void
 ac_nir_lower_gs_inputs_to_mem(nir_shader *shader,
                               ac_nir_map_io_driver_location map,
-                              enum amd_gfx_level gfx_level)
+                              enum amd_gfx_level gfx_level,
+                              bool triangle_strip_adjacency_fix)
 {
    lower_esgs_io_state state = {
       .gfx_level = gfx_level,
       .map_io = map,
+      .gs_triangle_strip_adjacency_fix = triangle_strip_adjacency_fix,
    };
 
    nir_shader_lower_instructions(shader,
diff --git a/src/amd/vulkan/radv_shader.c b/src/amd/vulkan/radv_shader.c
index 94cf51148e49..e45ae590cbab 100644
--- a/src/amd/vulkan/radv_shader.c
+++ b/src/amd/vulkan/radv_shader.c
@@ -1093,7 +1093,7 @@ radv_lower_io_to_mem(struct radv_device *device, struct radv_pipeline_stage *sta
       return true;
    } else if (nir->info.stage == MESA_SHADER_GEOMETRY) {
       NIR_PASS_V(nir, ac_nir_lower_gs_inputs_to_mem, NULL,
-                 device->physical_device->rad_info.gfx_level);
+                 device->physical_device->rad_info.gfx_level, false);
       return true;
    } else if (nir->info.stage == MESA_SHADER_TASK) {
       ac_nir_apply_first_task_to_task_shader(nir);
-- 
GitLab


From 8e8ca16cae8bd7b997ca3c1fc09c30ff667c96fe Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Mon, 30 May 2022 19:49:55 +0800
Subject: [PATCH 29/30] ac/llvm: get back
 nir_intrinsic_load_gs_vertex_offset_amd
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Will be used by radeonsi.

Reviewed-by: Timur Kristóf <timur.kristof@gmail.com>
Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/amd/llvm/ac_nir_to_llvm.c | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/src/amd/llvm/ac_nir_to_llvm.c b/src/amd/llvm/ac_nir_to_llvm.c
index 251195249d9d..2b68a3ab455e 100644
--- a/src/amd/llvm/ac_nir_to_llvm.c
+++ b/src/amd/llvm/ac_nir_to_llvm.c
@@ -4033,6 +4033,9 @@ static void visit_intrinsic(struct ac_nir_context *ctx, nir_intrinsic_instr *ins
       result = ac_build_gather_values(&ctx->ac, coord, 3);
       break;
    }
+   case nir_intrinsic_load_gs_vertex_offset_amd:
+      result = ac_get_arg(&ctx->ac, ctx->args->gs_vtx_offset[nir_intrinsic_base(instr)]);
+      break;
    case nir_intrinsic_vote_all: {
       result = ac_build_vote_all(&ctx->ac, get_src(ctx, instr->src[0]));
       break;
-- 
GitLab


From 233ea352aacd6b45b8db79737bcbad9972c184ca Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Mon, 30 May 2022 20:09:49 +0800
Subject: [PATCH 30/30] radeonsi: replace llvm gs input handle with nir
 lowering

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/amd/llvm/ac_nir_to_llvm.c                 |  7 ---
 src/gallium/drivers/radeonsi/si_shader.c      |  4 ++
 .../drivers/radeonsi/si_shader_internal.h     |  3 --
 src/gallium/drivers/radeonsi/si_shader_llvm.c | 27 ----------
 .../drivers/radeonsi/si_shader_llvm_gs.c      | 54 -------------------
 5 files changed, 4 insertions(+), 91 deletions(-)

diff --git a/src/amd/llvm/ac_nir_to_llvm.c b/src/amd/llvm/ac_nir_to_llvm.c
index 2b68a3ab455e..a3b5d9e4f883 100644
--- a/src/amd/llvm/ac_nir_to_llvm.c
+++ b/src/amd/llvm/ac_nir_to_llvm.c
@@ -3473,13 +3473,6 @@ static LLVMValueRef visit_load(struct ac_nir_context *ctx, nir_intrinsic_instr *
    /* No indirect indexing is allowed after this point. */
    assert(!indir_index);
 
-   if (ctx->stage == MESA_SHADER_GEOMETRY) {
-      assert(nir_src_is_const(*vertex_index_src));
-
-      return ctx->abi->load_inputs(ctx->abi, base, component, count,
-                                   nir_src_as_uint(*vertex_index_src), component_type);
-   }
-
    if (ctx->stage == MESA_SHADER_FRAGMENT && is_output &&
        nir_intrinsic_io_semantics(instr).fb_fetch_output)
       return ctx->abi->emit_fbfetch(ctx->abi);
diff --git a/src/gallium/drivers/radeonsi/si_shader.c b/src/gallium/drivers/radeonsi/si_shader.c
index a439923fcff2..720d09cac922 100644
--- a/src/gallium/drivers/radeonsi/si_shader.c
+++ b/src/gallium/drivers/radeonsi/si_shader.c
@@ -1539,6 +1539,10 @@ static bool si_lower_io_to_mem(struct si_shader *shader, nir_shader *nir,
       }
 
       return true;
+   } else if (nir->info.stage == MESA_SHADER_GEOMETRY) {
+      NIR_PASS_V(nir, ac_nir_lower_gs_inputs_to_mem, si_map_io_driver_location,
+                 sel->screen->info.gfx_level, key->ge.mono.u.gs_tri_strip_adj_fix);
+      return true;
    }
 
    return false;
diff --git a/src/gallium/drivers/radeonsi/si_shader_internal.h b/src/gallium/drivers/radeonsi/si_shader_internal.h
index f4f4ed89fd95..348a20d06ccc 100644
--- a/src/gallium/drivers/radeonsi/si_shader_internal.h
+++ b/src/gallium/drivers/radeonsi/si_shader_internal.h
@@ -136,9 +136,6 @@ struct si_shader_context {
 
    struct ac_llvm_compiler *compiler;
 
-   /* GS vertex offsets unpacked with the gfx6-9 tristrip_adj bug workaround. */
-   LLVMValueRef gs_vtx_offset[6];
-
    /* Preloaded descriptors. */
    LLVMValueRef esgs_ring;
    LLVMValueRef gsvs_ring[4];
diff --git a/src/gallium/drivers/radeonsi/si_shader_llvm.c b/src/gallium/drivers/radeonsi/si_shader_llvm.c
index 12585b18ff24..a02e1ace0e94 100644
--- a/src/gallium/drivers/radeonsi/si_shader_llvm.c
+++ b/src/gallium/drivers/radeonsi/si_shader_llvm.c
@@ -1046,33 +1046,6 @@ bool si_llvm_translate_nir(struct si_shader_context *ctx, struct si_shader *shad
       }
    }
 
-   if (nir->info.stage == MESA_SHADER_GEOMETRY) {
-      /* Unpack GS vertex offsets. */
-      for (unsigned i = 0; i < 6; i++) {
-         if (ctx->screen->info.gfx_level >= GFX9) {
-            ctx->gs_vtx_offset[i] = si_unpack_param(ctx, ctx->args.gs_vtx_offset[i / 2], (i & 1) * 16, 16);
-         } else {
-            ctx->gs_vtx_offset[i] = ac_get_arg(&ctx->ac, ctx->args.gs_vtx_offset[i]);
-         }
-      }
-
-      /* Apply the hw bug workaround for triangle strips with adjacency. */
-      if (ctx->screen->info.gfx_level <= GFX9 &&
-          ctx->shader->key.ge.mono.u.gs_tri_strip_adj_fix) {
-         LLVMValueRef prim_id = ac_get_arg(&ctx->ac, ctx->args.gs_prim_id);
-         /* Remap GS vertex offsets for every other primitive. */
-         LLVMValueRef rotate = LLVMBuildTrunc(ctx->ac.builder, prim_id, ctx->ac.i1, "");
-         LLVMValueRef fixed[6];
-
-         for (unsigned i = 0; i < 6; i++) {
-            fixed[i] = LLVMBuildSelect(ctx->ac.builder, rotate,
-                                       ctx->gs_vtx_offset[(i + 4) % 6],
-                                       ctx->gs_vtx_offset[i], "");
-         }
-         memcpy(ctx->gs_vtx_offset, fixed, sizeof(fixed));
-      }
-   }
-
    ctx->abi.clamp_shadow_reference = true;
    ctx->abi.robust_buffer_access = true;
    ctx->abi.convert_undef_to_zero = true;
diff --git a/src/gallium/drivers/radeonsi/si_shader_llvm_gs.c b/src/gallium/drivers/radeonsi/si_shader_llvm_gs.c
index 54c9b629296f..47a82dd1c537 100644
--- a/src/gallium/drivers/radeonsi/si_shader_llvm_gs.c
+++ b/src/gallium/drivers/radeonsi/si_shader_llvm_gs.c
@@ -43,59 +43,6 @@ LLVMValueRef si_is_gs_thread(struct si_shader_context *ctx)
                         si_unpack_param(ctx, ctx->args.merged_wave_info, 8, 8), "");
 }
 
-static LLVMValueRef si_llvm_load_input_gs(struct ac_shader_abi *abi, unsigned input_index,
-                                          unsigned vtx_offset_param, LLVMTypeRef type,
-                                          unsigned swizzle)
-{
-   struct si_shader_context *ctx = si_shader_context_from_abi(abi);
-   struct si_shader *shader = ctx->shader;
-   LLVMValueRef vtx_offset, soffset;
-   struct si_shader_info *info = &shader->selector->info;
-   unsigned param;
-   LLVMValueRef value;
-
-   param = si_shader_io_get_unique_index(info->input[input_index].semantic, false);
-
-   /* GFX9 has the ESGS ring in LDS. */
-   if (ctx->screen->info.gfx_level >= GFX9) {
-      unsigned offset = param * 4 + swizzle;
-
-      vtx_offset = LLVMBuildAdd(ctx->ac.builder, ctx->gs_vtx_offset[vtx_offset_param],
-                                LLVMConstInt(ctx->ac.i32, offset, false), "");
-
-      LLVMValueRef ptr = ac_build_gep0(&ctx->ac, ctx->esgs_ring, vtx_offset);
-      LLVMValueRef value = LLVMBuildLoad(ctx->ac.builder, ptr, "");
-      return LLVMBuildBitCast(ctx->ac.builder, value, type, "");
-   }
-
-   /* GFX6: input load from the ESGS ring in memory. */
-   /* Get the vertex offset parameter on GFX6. */
-   vtx_offset = LLVMBuildMul(ctx->ac.builder, ctx->gs_vtx_offset[vtx_offset_param],
-                             LLVMConstInt(ctx->ac.i32, 4, 0), "");
-
-   soffset = LLVMConstInt(ctx->ac.i32, (param * 4 + swizzle) * 256, 0);
-
-   value = ac_build_buffer_load(&ctx->ac, ctx->esgs_ring, 1, ctx->ac.i32_0, vtx_offset, soffset,
-                                ctx->ac.f32, ac_glc, true, false);
-   return LLVMBuildBitCast(ctx->ac.builder, value, type, "");
-}
-
-static LLVMValueRef si_nir_load_input_gs(struct ac_shader_abi *abi,
-                                         unsigned driver_location, unsigned component,
-                                         unsigned num_components, unsigned vertex_index,
-                                         LLVMTypeRef type)
-{
-   struct si_shader_context *ctx = si_shader_context_from_abi(abi);
-
-   LLVMValueRef value[4];
-   for (unsigned i = component; i < component + num_components; i++) {
-      value[i] = si_llvm_load_input_gs(&ctx->abi, driver_location,
-                                       vertex_index, type, i);
-   }
-
-   return ac_build_varying_gather_values(&ctx->ac, value, num_components, component);
-}
-
 /* Pass GS inputs from ES to GS on GFX9. */
 static void si_set_es_return_value_for_gs(struct si_shader_context *ctx)
 {
@@ -591,7 +538,6 @@ struct si_shader *si_generate_gs_copy_shader(struct si_screen *sscreen,
 
 void si_llvm_init_gs_callbacks(struct si_shader_context *ctx)
 {
-   ctx->abi.load_inputs = si_nir_load_input_gs;
    ctx->abi.emit_vertex = si_llvm_emit_vertex;
    ctx->abi.emit_primitive = si_llvm_emit_primitive;
 }
-- 
GitLab

