From 9a2fbec56117adb873cafbd778b58621e30fa862 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Wed, 11 May 2022 15:11:27 +0800
Subject: [PATCH 01/39] ac/llvm: get back
 nir_intrinsic_load_tess_rel_patch_id_amd
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

radeonsi will use it. This can be removed again after radeonsi support
radv_nir_lower_abi like lower pass.

Reviewed-by: Timur Kristóf <timur.kristof@gmail.com>
Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/amd/llvm/ac_nir_to_llvm.c | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/src/amd/llvm/ac_nir_to_llvm.c b/src/amd/llvm/ac_nir_to_llvm.c
index 3b740cf94319..3263ff3630ca 100644
--- a/src/amd/llvm/ac_nir_to_llvm.c
+++ b/src/amd/llvm/ac_nir_to_llvm.c
@@ -4036,6 +4036,10 @@ static void visit_intrinsic(struct ac_nir_context *ctx, nir_intrinsic_instr *ins
       result = ac_build_gather_values(&ctx->ac, coord, 3);
       break;
    }
+   case nir_intrinsic_load_tess_rel_patch_id_amd:
+      assert(ctx->stage == MESA_SHADER_TESS_CTRL);
+      result = ac_unpack_param(&ctx->ac, ac_get_arg(&ctx->ac, ctx->args->tcs_rel_ids), 0, 8);
+      break;
    case nir_intrinsic_vote_all: {
       result = ac_build_vote_all(&ctx->ac, get_src(ctx, instr->src[0]));
       break;
-- 
GitLab


From ed4b6d3088a124d8d0358f531e5d88af38af3fad Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Sat, 7 May 2022 17:34:54 +0800
Subject: [PATCH 02/39] nir: add nir_intrinsic_load_lshs_vertex_stride_amd
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

For loading LS-HS vertex stride by shader argument in radeonsi.

Reviewed-by: Timur Kristóf <timur.kristof@gmail.com>
Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/compiler/nir/nir_divergence_analysis.c | 1 +
 src/compiler/nir/nir_intrinsics.py         | 3 +++
 2 files changed, 4 insertions(+)

diff --git a/src/compiler/nir/nir_divergence_analysis.c b/src/compiler/nir/nir_divergence_analysis.c
index 11888723d567..60fb38c56b22 100644
--- a/src/compiler/nir/nir_divergence_analysis.c
+++ b/src/compiler/nir/nir_divergence_analysis.c
@@ -174,6 +174,7 @@ visit_intrinsic(nir_shader *shader, nir_intrinsic_instr *instr)
    case nir_intrinsic_load_btd_local_arg_addr_intel:
    case nir_intrinsic_load_mesh_inline_data_intel:
    case nir_intrinsic_load_ray_num_dss_rt_stacks_intel:
+   case nir_intrinsic_load_lshs_vertex_stride_amd:
       is_divergent = false;
       break;
 
diff --git a/src/compiler/nir/nir_intrinsics.py b/src/compiler/nir/nir_intrinsics.py
index ed9b3d0948ca..02d49a279657 100644
--- a/src/compiler/nir/nir_intrinsics.py
+++ b/src/compiler/nir/nir_intrinsics.py
@@ -1391,6 +1391,9 @@ intrinsic("load_shared2_amd", [1], dest_comp=2, indices=[OFFSET0, OFFSET1, ST64]
 # src[] = { value, offset }.
 intrinsic("store_shared2_amd", [2, 1], indices=[OFFSET0, OFFSET1, ST64])
 
+# Vertex stride in LS-HS buffer
+system_value("lshs_vertex_stride_amd", 1)
+
 # V3D-specific instrinc for tile buffer color reads.
 #
 # The hardware requires that we read the samples and components of a pixel
-- 
GitLab


From 023efb76de0bc132bd15c4fa5785b5518cf9ad10 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Sat, 7 May 2022 17:38:04 +0800
Subject: [PATCH 03/39] ac/nir: use nir_intrinsic_load_lshs_vertex_stride_amd
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

For radeonsi which pass this value by argument.

Reviewed-by: Timur Kristóf <timur.kristof@gmail.com>
Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/amd/common/ac_nir.h                      |  7 ++---
 src/amd/common/ac_nir_lower_tess_io_to_mem.c | 28 +++++++-------------
 src/amd/vulkan/radv_nir_lower_abi.c          | 10 ++++++-
 src/amd/vulkan/radv_shader.c                 |  9 +++----
 4 files changed, 24 insertions(+), 30 deletions(-)

diff --git a/src/amd/common/ac_nir.h b/src/amd/common/ac_nir.h
index 61f9fc18af23..07613668f1af 100644
--- a/src/amd/common/ac_nir.h
+++ b/src/amd/common/ac_nir.h
@@ -62,13 +62,11 @@ bool ac_nir_optimize_outputs(nir_shader *nir, bool sprite_tex_disallowed,
 void
 ac_nir_lower_ls_outputs_to_mem(nir_shader *ls,
                                bool tcs_in_out_eq,
-                               uint64_t tcs_temp_only_inputs,
-                               unsigned num_reserved_ls_outputs);
+                               uint64_t tcs_temp_only_inputs);
 
 void
 ac_nir_lower_hs_inputs_to_mem(nir_shader *shader,
-                              bool tcs_in_out_eq,
-                              unsigned num_reserved_tcs_inputs);
+                              bool tcs_in_out_eq);
 
 void
 ac_nir_lower_hs_outputs_to_mem(nir_shader *shader,
@@ -76,7 +74,6 @@ ac_nir_lower_hs_outputs_to_mem(nir_shader *shader,
                                bool tes_reads_tessfactors,
                                uint64_t tes_inputs_read,
                                uint64_t tes_patch_inputs_read,
-                               unsigned num_reserved_tcs_inputs,
                                unsigned num_reserved_tcs_outputs,
                                unsigned num_reserved_tcs_patch_outputs,
                                bool emit_tess_factor_write);
diff --git a/src/amd/common/ac_nir_lower_tess_io_to_mem.c b/src/amd/common/ac_nir_lower_tess_io_to_mem.c
index 2fe6b2cd957b..0fe115f0493e 100644
--- a/src/amd/common/ac_nir_lower_tess_io_to_mem.c
+++ b/src/amd/common/ac_nir_lower_tess_io_to_mem.c
@@ -140,10 +140,6 @@ typedef struct {
    /* Whether TES reads the tess factors. */
    bool tes_reads_tessfactors;
 
-   /* Number of inputs for which memory should be reserved.
-    * When compacted, this should be the number of linked inputs.
-    */
-   unsigned tcs_num_reserved_inputs;
    unsigned tcs_num_reserved_outputs;
    unsigned tcs_num_reserved_patch_outputs;
 
@@ -220,7 +216,7 @@ lower_ls_output_store(nir_builder *b,
    b->cursor = nir_before_instr(instr);
 
    nir_ssa_def *vertex_idx = nir_load_local_invocation_index(b);
-   nir_ssa_def *base_off_var = nir_imul_imm(b, vertex_idx, st->tcs_num_reserved_inputs * 16u);
+   nir_ssa_def *base_off_var = nir_imul(b, vertex_idx, nir_load_lshs_vertex_stride_amd(b));
 
    nir_ssa_def *io_off = nir_build_calc_io_offset(b, intrin, nir_imm_int(b, 16u), 4u);
    unsigned write_mask = nir_intrinsic_write_mask(intrin);
@@ -272,15 +268,15 @@ hs_per_vertex_input_lds_offset(nir_builder *b,
                                lower_tess_io_state *st,
                                nir_intrinsic_instr *instr)
 {
-   unsigned tcs_in_vertex_stride = st->tcs_num_reserved_inputs * 16u;
    nir_ssa_def *tcs_in_vtxcnt = nir_load_patch_vertices_in(b);
    nir_ssa_def *rel_patch_id = nir_load_tess_rel_patch_id_amd(b);
+   nir_ssa_def *vertex_index = nir_get_io_arrayed_index_src(instr)->ssa;
 
-   nir_ssa_def *tcs_in_patch_stride = nir_imul_imm(b, tcs_in_vtxcnt, tcs_in_vertex_stride);
-   nir_ssa_def *tcs_in_current_patch_offset = nir_imul(b, rel_patch_id, tcs_in_patch_stride);
+   nir_ssa_def *stride = nir_load_lshs_vertex_stride_amd(b);
+   nir_ssa_def *tcs_in_patch_stride = nir_imul(b, tcs_in_vtxcnt, stride);
+   nir_ssa_def *vertex_index_off = nir_imul(b, vertex_index, stride);
 
-   nir_ssa_def *vertex_index = nir_get_io_arrayed_index_src(instr)->ssa;
-   nir_ssa_def *vertex_index_off = nir_imul_imm(b, vertex_index, tcs_in_vertex_stride);
+   nir_ssa_def *tcs_in_current_patch_offset = nir_imul(b, rel_patch_id, tcs_in_patch_stride);
 
    nir_ssa_def *io_offset = nir_build_calc_io_offset(b, instr, nir_imm_int(b, 16u), 4u);
 
@@ -302,7 +298,7 @@ hs_output_lds_offset(nir_builder *b,
 
    nir_ssa_def *tcs_in_vtxcnt = nir_load_patch_vertices_in(b);
    nir_ssa_def *tcs_num_patches = nir_load_tcs_num_patches_amd(b);
-   nir_ssa_def *input_patch_size = nir_imul_imm(b, tcs_in_vtxcnt, st->tcs_num_reserved_inputs * 16u);
+   nir_ssa_def *input_patch_size = nir_imul(b, tcs_in_vtxcnt, nir_load_lshs_vertex_stride_amd(b));
    nir_ssa_def *output_patch0_offset = nir_imul(b, input_patch_size, tcs_num_patches);
 
    nir_ssa_def *off = intrin
@@ -634,13 +630,11 @@ filter_any_input_access(const nir_instr *instr,
 void
 ac_nir_lower_ls_outputs_to_mem(nir_shader *shader,
                                bool tcs_in_out_eq,
-                               uint64_t tcs_temp_only_inputs,
-                               unsigned num_reserved_ls_outputs)
+                               uint64_t tcs_temp_only_inputs)
 {
    assert(shader->info.stage == MESA_SHADER_VERTEX);
 
    lower_tess_io_state state = {
-      .tcs_num_reserved_inputs = num_reserved_ls_outputs,
       .tcs_in_out_eq = tcs_in_out_eq,
       .tcs_temp_only_inputs = tcs_in_out_eq ? tcs_temp_only_inputs : 0,
    };
@@ -653,14 +647,12 @@ ac_nir_lower_ls_outputs_to_mem(nir_shader *shader,
 
 void
 ac_nir_lower_hs_inputs_to_mem(nir_shader *shader,
-                              bool tcs_in_out_eq,
-                              unsigned num_reserved_tcs_inputs)
+                              bool tcs_in_out_eq)
 {
    assert(shader->info.stage == MESA_SHADER_TESS_CTRL);
 
    lower_tess_io_state state = {
       .tcs_in_out_eq = tcs_in_out_eq,
-      .tcs_num_reserved_inputs = num_reserved_tcs_inputs,
    };
 
    nir_shader_lower_instructions(shader,
@@ -675,7 +667,6 @@ ac_nir_lower_hs_outputs_to_mem(nir_shader *shader,
                                bool tes_reads_tessfactors,
                                uint64_t tes_inputs_read,
                                uint64_t tes_patch_inputs_read,
-                               unsigned num_reserved_tcs_inputs,
                                unsigned num_reserved_tcs_outputs,
                                unsigned num_reserved_tcs_patch_outputs,
                                bool emit_tess_factor_write)
@@ -687,7 +678,6 @@ ac_nir_lower_hs_outputs_to_mem(nir_shader *shader,
       .tes_reads_tessfactors = tes_reads_tessfactors,
       .tes_inputs_read = tes_inputs_read,
       .tes_patch_inputs_read = tes_patch_inputs_read,
-      .tcs_num_reserved_inputs = num_reserved_tcs_inputs,
       .tcs_num_reserved_outputs = num_reserved_tcs_outputs,
       .tcs_num_reserved_patch_outputs = num_reserved_tcs_patch_outputs,
       .tcs_out_patch_fits_subgroup = 32 % shader->info.tess.tcs_vertices_out == 0,
diff --git a/src/amd/vulkan/radv_nir_lower_abi.c b/src/amd/vulkan/radv_nir_lower_abi.c
index f89f4f6065ca..0570a0f1d889 100644
--- a/src/amd/vulkan/radv_nir_lower_abi.c
+++ b/src/amd/vulkan/radv_nir_lower_abi.c
@@ -182,6 +182,13 @@ lower_abi_instr(nir_builder *b, nir_instr *instr, void *state)
    case nir_intrinsic_load_task_ib_stride:
       return ac_nir_load_arg(b, &s->args->ac, s->args->task_ib_stride);
 
+   case nir_intrinsic_load_lshs_vertex_stride_amd: {
+      unsigned io_num = stage == MESA_SHADER_VERTEX ?
+         s->info->vs.num_linked_outputs :
+         s->info->tcs.num_linked_inputs;
+      return nir_imm_int(b, io_num * 16);
+   }
+
    default:
       unreachable("invalid NIR RADV ABI intrinsic.");
    }
@@ -225,7 +232,8 @@ filter_abi_instr(const nir_instr *instr,
           intrin->intrinsic == nir_intrinsic_load_ring_task_payload_amd ||
           intrin->intrinsic == nir_intrinsic_load_task_ring_entry_amd ||
           intrin->intrinsic == nir_intrinsic_load_task_ib_addr ||
-          intrin->intrinsic == nir_intrinsic_load_task_ib_stride;
+          intrin->intrinsic == nir_intrinsic_load_task_ib_stride ||
+          intrin->intrinsic == nir_intrinsic_load_lshs_vertex_stride_amd;
 }
 
 void
diff --git a/src/amd/vulkan/radv_shader.c b/src/amd/vulkan/radv_shader.c
index 3125e250da2d..57b4276c8461 100644
--- a/src/amd/vulkan/radv_shader.c
+++ b/src/amd/vulkan/radv_shader.c
@@ -1070,7 +1070,7 @@ radv_lower_io_to_mem(struct radv_device *device, struct radv_pipeline_stage *sta
    if (nir->info.stage == MESA_SHADER_VERTEX) {
       if (info->vs.as_ls) {
          NIR_PASS_V(nir, ac_nir_lower_ls_outputs_to_mem, info->vs.tcs_in_out_eq,
-                    info->vs.tcs_temp_only_input_mask, info->vs.num_linked_outputs);
+                    info->vs.tcs_temp_only_input_mask);
          return true;
       } else if (info->vs.as_es) {
          NIR_PASS_V(nir, ac_nir_lower_es_outputs_to_mem,
@@ -1078,12 +1078,11 @@ radv_lower_io_to_mem(struct radv_device *device, struct radv_pipeline_stage *sta
          return true;
       }
    } else if (nir->info.stage == MESA_SHADER_TESS_CTRL) {
-      NIR_PASS_V(nir, ac_nir_lower_hs_inputs_to_mem, info->vs.tcs_in_out_eq,
-                 info->tcs.num_linked_inputs);
+      NIR_PASS_V(nir, ac_nir_lower_hs_inputs_to_mem, info->vs.tcs_in_out_eq);
       NIR_PASS_V(nir, ac_nir_lower_hs_outputs_to_mem, device->physical_device->rad_info.gfx_level,
                  info->tcs.tes_reads_tess_factors, info->tcs.tes_inputs_read,
-                 info->tcs.tes_patch_inputs_read, info->tcs.num_linked_inputs,
-                 info->tcs.num_linked_outputs, info->tcs.num_linked_patch_outputs, true);
+                 info->tcs.tes_patch_inputs_read, info->tcs.num_linked_outputs,
+                 info->tcs.num_linked_patch_outputs, true);
 
       return true;
    } else if (nir->info.stage == MESA_SHADER_TESS_EVAL) {
-- 
GitLab


From 2e89600b9b19af86ea7e664a0900c9c59ab41a7a Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Sat, 7 May 2022 17:54:02 +0800
Subject: [PATCH 04/39] radeonsi: implement load_lshs_vertex_stride abi
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Reviewed-by: Timur Kristóf <timur.kristof@gmail.com>
Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/amd/llvm/ac_nir_to_llvm.c                      | 1 +
 src/gallium/drivers/radeonsi/si_shader_internal.h  | 1 +
 src/gallium/drivers/radeonsi/si_shader_llvm.c      | 4 ++++
 src/gallium/drivers/radeonsi/si_shader_llvm_tess.c | 8 ++++----
 4 files changed, 10 insertions(+), 4 deletions(-)

diff --git a/src/amd/llvm/ac_nir_to_llvm.c b/src/amd/llvm/ac_nir_to_llvm.c
index 3263ff3630ca..e3412cbce8c2 100644
--- a/src/amd/llvm/ac_nir_to_llvm.c
+++ b/src/amd/llvm/ac_nir_to_llvm.c
@@ -3626,6 +3626,7 @@ static void visit_intrinsic(struct ac_nir_context *ctx, nir_intrinsic_instr *ins
    case nir_intrinsic_load_ring_tess_factors_amd:
    case nir_intrinsic_load_ring_tess_offchip_amd:
    case nir_intrinsic_load_ring_esgs_amd:
+   case nir_intrinsic_load_lshs_vertex_stride_amd:
       result = ctx->abi->intrinsic_load(ctx->abi, instr->intrinsic);
       break;
    case nir_intrinsic_load_vertex_id:
diff --git a/src/gallium/drivers/radeonsi/si_shader_internal.h b/src/gallium/drivers/radeonsi/si_shader_internal.h
index 12ba6c332858..d34025c529fc 100644
--- a/src/gallium/drivers/radeonsi/si_shader_internal.h
+++ b/src/gallium/drivers/radeonsi/si_shader_internal.h
@@ -244,6 +244,7 @@ void si_llvm_gs_build_end(struct si_shader_context *ctx);
 void si_llvm_init_gs_callbacks(struct si_shader_context *ctx);
 
 /* si_shader_llvm_tess.c */
+LLVMValueRef si_get_tcs_in_vertex_dw_stride(struct si_shader_context *ctx);
 LLVMValueRef si_get_num_tcs_out_vertices(struct si_shader_context *ctx);
 void si_llvm_preload_tes_rings(struct si_shader_context *ctx);
 void si_llvm_ls_build_end(struct si_shader_context *ctx);
diff --git a/src/gallium/drivers/radeonsi/si_shader_llvm.c b/src/gallium/drivers/radeonsi/si_shader_llvm.c
index 9f94403d33b2..cb379d44d702 100644
--- a/src/gallium/drivers/radeonsi/si_shader_llvm.c
+++ b/src/gallium/drivers/radeonsi/si_shader_llvm.c
@@ -772,6 +772,10 @@ static LLVMValueRef si_llvm_load_intrinsic(struct ac_shader_abi *abi, nir_intrin
    case nir_intrinsic_load_sample_mask_in:
       return ac_to_integer(&ctx->ac, ac_get_arg(&ctx->ac, ctx->args.sample_coverage));
 
+   case nir_intrinsic_load_lshs_vertex_stride_amd:
+      return LLVMBuildShl(ctx->ac.builder, si_get_tcs_in_vertex_dw_stride(ctx),
+                          LLVMConstInt(ctx->ac.i32, 2, 0), "");
+
    default:
       return NULL;
    }
diff --git a/src/gallium/drivers/radeonsi/si_shader_llvm_tess.c b/src/gallium/drivers/radeonsi/si_shader_llvm_tess.c
index df228eed990e..72c355378bb9 100644
--- a/src/gallium/drivers/radeonsi/si_shader_llvm_tess.c
+++ b/src/gallium/drivers/radeonsi/si_shader_llvm_tess.c
@@ -149,7 +149,7 @@ LLVMValueRef si_get_num_tcs_out_vertices(struct si_shader_context *ctx)
                        si_unpack_param(ctx, ctx->tcs_offchip_layout, 6, 5), ctx->ac.i32_1, "");
 }
 
-static LLVMValueRef get_tcs_in_vertex_dw_stride(struct si_shader_context *ctx)
+LLVMValueRef si_get_tcs_in_vertex_dw_stride(struct si_shader_context *ctx)
 {
    unsigned stride;
 
@@ -419,7 +419,7 @@ static LLVMValueRef si_nir_load_tcs_varyings(struct ac_shader_abi *abi, LLVMType
            semantic == VARYING_SLOT_TESS_LEVEL_OUTER) == is_patch);
 
    if (load_input) {
-      stride = get_tcs_in_vertex_dw_stride(ctx);
+      stride = si_get_tcs_in_vertex_dw_stride(ctx);
       dw_addr = get_tcs_in_current_patch_offset(ctx);
    } else {
       if (is_patch) {
@@ -577,7 +577,7 @@ static void si_copy_tcs_inputs(struct si_shader_context *ctx)
    buffer = get_tess_ring_descriptor(ctx, TESS_OFFCHIP_RING_TCS);
    buffer_offset = ac_get_arg(&ctx->ac, ctx->args.tess_offchip_offset);
 
-   lds_vertex_stride = get_tcs_in_vertex_dw_stride(ctx);
+   lds_vertex_stride = si_get_tcs_in_vertex_dw_stride(ctx);
    lds_base = get_tcs_in_current_patch_offset(ctx);
    lds_base = ac_build_imad(&ctx->ac, invocation_id, lds_vertex_stride, lds_base);
 
@@ -886,7 +886,7 @@ void si_llvm_ls_build_end(struct si_shader_context *ctx)
    } else {
       vertex_id = ac_get_arg(&ctx->ac, ctx->args.vs_rel_patch_id);
    }
-   LLVMValueRef vertex_dw_stride = get_tcs_in_vertex_dw_stride(ctx);
+   LLVMValueRef vertex_dw_stride = si_get_tcs_in_vertex_dw_stride(ctx);
    LLVMValueRef base_dw_addr = LLVMBuildMul(ctx->ac.builder, vertex_id, vertex_dw_stride, "");
    LLVMValueRef *addrs = ctx->abi.outputs;
    unsigned ret_offset = 8 + GFX9_TCS_NUM_USER_SGPR + 2;
-- 
GitLab


From 011b20a1401c975bec8eb83e5062eb4c41c31e80 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Sun, 8 May 2022 22:10:58 +0800
Subject: [PATCH 05/39] radeonsi: add tcs_vgpr_only_inputs parameter to
 si_get_nir_shader

Will be used latter.

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/gallium/drivers/radeonsi/si_shader.c          | 5 +++--
 src/gallium/drivers/radeonsi/si_shader_internal.h | 3 ++-
 src/gallium/drivers/radeonsi/si_shader_llvm.c     | 5 +++--
 src/gallium/drivers/radeonsi/si_state.c           | 3 ++-
 4 files changed, 10 insertions(+), 6 deletions(-)

diff --git a/src/gallium/drivers/radeonsi/si_shader.c b/src/gallium/drivers/radeonsi/si_shader.c
index cde217ffd25d..0ec4f8c42f8b 100644
--- a/src/gallium/drivers/radeonsi/si_shader.c
+++ b/src/gallium/drivers/radeonsi/si_shader.c
@@ -1492,7 +1492,8 @@ static bool si_nir_kill_outputs(nir_shader *nir, const union si_shader_key *key)
 
 struct nir_shader *si_get_nir_shader(struct si_shader_selector *sel,
                                      const union si_shader_key *key,
-                                     bool *free_nir)
+                                     bool *free_nir,
+                                     uint64_t tcs_vgpr_only_inputs)
 {
    nir_shader *nir;
    *free_nir = false;
@@ -1683,7 +1684,7 @@ bool si_compile_shader(struct si_screen *sscreen, struct ac_llvm_compiler *compi
 {
    struct si_shader_selector *sel = shader->selector;
    bool free_nir;
-   struct nir_shader *nir = si_get_nir_shader(sel, &shader->key, &free_nir);
+   struct nir_shader *nir = si_get_nir_shader(sel, &shader->key, &free_nir, 0);
 
    /* Assign param export indices. */
    if ((sel->stage == MESA_SHADER_VERTEX ||
diff --git a/src/gallium/drivers/radeonsi/si_shader_internal.h b/src/gallium/drivers/radeonsi/si_shader_internal.h
index d34025c529fc..907dc04b796a 100644
--- a/src/gallium/drivers/radeonsi/si_shader_internal.h
+++ b/src/gallium/drivers/radeonsi/si_shader_internal.h
@@ -176,7 +176,8 @@ void si_get_vs_prolog_key(const struct si_shader_info *info, unsigned num_input_
                           struct si_shader *shader_out, union si_shader_part_key *key);
 struct nir_shader *si_get_nir_shader(struct si_shader_selector *sel,
                                      const union si_shader_key *key,
-                                     bool *free_nir);
+                                     bool *free_nir,
+                                     uint64_t tcs_vgpr_only_inputs);
 void si_get_tcs_epilog_key(struct si_shader *shader, union si_shader_part_key *key);
 bool si_need_ps_prolog(const union si_shader_part_key *key);
 void si_get_ps_prolog_key(struct si_shader *shader, union si_shader_part_key *key,
diff --git a/src/gallium/drivers/radeonsi/si_shader_llvm.c b/src/gallium/drivers/radeonsi/si_shader_llvm.c
index cb379d44d702..2a15e71086e2 100644
--- a/src/gallium/drivers/radeonsi/si_shader_llvm.c
+++ b/src/gallium/drivers/radeonsi/si_shader_llvm.c
@@ -1253,7 +1253,8 @@ bool si_llvm_compile_shader(struct si_screen *sscreen, struct ac_llvm_compiler *
          shader_ls.key.ge.opt.inline_uniforms = false; /* only TCS can inline uniforms */
          shader_ls.is_monolithic = true;
 
-         nir = si_get_nir_shader(ls, &shader_ls.key, &free_nir);
+         nir = si_get_nir_shader(ls, &shader_ls.key, &free_nir,
+                                 sel->info.tcs_vgpr_only_inputs);
          si_update_shader_binary_info(shader, nir);
 
          if (!si_llvm_translate_nir(&ctx, &shader_ls, nir, free_nir, false)) {
@@ -1313,7 +1314,7 @@ bool si_llvm_compile_shader(struct si_screen *sscreen, struct ac_llvm_compiler *
          shader_es.key.ge.opt.kill_outputs = 0;
          shader_es.is_monolithic = true;
 
-         nir = si_get_nir_shader(es, &shader_es.key, &free_nir);
+         nir = si_get_nir_shader(es, &shader_es.key, &free_nir, 0);
          si_update_shader_binary_info(shader, nir);
 
          if (!si_llvm_translate_nir(&ctx, &shader_es, nir, free_nir, false)) {
diff --git a/src/gallium/drivers/radeonsi/si_state.c b/src/gallium/drivers/radeonsi/si_state.c
index 0b6f4226829b..48dea26cb9ed 100644
--- a/src/gallium/drivers/radeonsi/si_state.c
+++ b/src/gallium/drivers/radeonsi/si_state.c
@@ -663,7 +663,8 @@ static bool si_check_blend_dst_sampler_noop(struct si_context *sctx)
 
       bool free_nir;
       if (unlikely(sel->info.writes_1_if_tex_is_1 == 0xff)) {
-         struct nir_shader *nir = si_get_nir_shader(sel, &sctx->shader.ps.key, &free_nir);
+         struct nir_shader *nir =
+            si_get_nir_shader(sel, &sctx->shader.ps.key, &free_nir, 0);
 
          /* Determine if this fragment shader always writes vec4(1) if a specific texture
           * is all 1s.
-- 
GitLab


From 1d1e7f7cb60bccaa420621f4d3ad6b6294bebc7c Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Mon, 9 May 2022 21:42:47 +0800
Subject: [PATCH 06/39] ac/nir: skip gl_Layer/gl_ViewportIndex write for LS
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

This is from radeonsi.

Reviewed-by: Timur Kristóf <timur.kristof@gmail.com>
Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/amd/common/ac_nir_lower_tess_io_to_mem.c | 21 ++++++++++++++++++++
 1 file changed, 21 insertions(+)

diff --git a/src/amd/common/ac_nir_lower_tess_io_to_mem.c b/src/amd/common/ac_nir_lower_tess_io_to_mem.c
index 0fe115f0493e..8483f4609ee5 100644
--- a/src/amd/common/ac_nir_lower_tess_io_to_mem.c
+++ b/src/amd/common/ac_nir_lower_tess_io_to_mem.c
@@ -207,6 +207,27 @@ lower_ls_output_store(nir_builder *b,
    if (intrin->intrinsic != nir_intrinsic_store_output)
       return false;
 
+   /* The ARB_shader_viewport_layer_array spec contains the
+    * following issue:
+    *
+    *    2) What happens if gl_ViewportIndex or gl_Layer is
+    *    written in the vertex shader and a geometry shader is
+    *    present?
+    *
+    *    RESOLVED: The value written by the last vertex processing
+    *    stage is used. If the last vertex processing stage
+    *    (vertex, tessellation evaluation or geometry) does not
+    *    statically assign to gl_ViewportIndex or gl_Layer, index
+    *    or layer zero is assumed.
+    *
+    * So writes to those outputs in VS-as-LS are simply ignored.
+    */
+   unsigned semantic = nir_intrinsic_io_semantics(intrin).location;
+   if (semantic == VARYING_SLOT_LAYER || semantic == VARYING_SLOT_VIEWPORT) {
+      nir_instr_remove(instr);
+      return true;
+   }
+
    lower_tess_io_state *st = (lower_tess_io_state *) state;
 
    /* If this is a temp-only TCS input, we don't need to use shared memory at all. */
-- 
GitLab


From c41e316a2114e37ca66d0a75136a05ae5a191ac4 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Timur=20Krist=C3=B3f?= <timur.kristof@gmail.com>
Date: Thu, 12 May 2022 15:48:24 +0200
Subject: [PATCH 07/39] ac/nir: Add remappability to tess and ESGS I/O lowering
 passes.
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Signed-off-by: Timur Kristóf <timur.kristof@gmail.com>
---
 src/amd/common/ac_nir.c                      | 31 ++++++++++++++++++++
 src/amd/common/ac_nir.h                      | 16 ++++++++++
 src/amd/common/ac_nir_lower_esgs_io_to_mem.c | 11 +++++--
 src/amd/common/ac_nir_lower_tess_io_to_mem.c | 21 +++++++++----
 src/amd/vulkan/radv_shader.c                 | 16 +++++-----
 src/compiler/nir/nir_builder.h               | 26 ----------------
 6 files changed, 81 insertions(+), 40 deletions(-)

diff --git a/src/amd/common/ac_nir.c b/src/amd/common/ac_nir.c
index 6c8db43c5164..49134cf33df6 100644
--- a/src/amd/common/ac_nir.c
+++ b/src/amd/common/ac_nir.c
@@ -35,6 +35,37 @@ ac_nir_load_arg(nir_builder *b, const struct ac_shader_args *ac_args, struct ac_
       return nir_load_vector_arg_amd(b, num_components, .base = arg.arg_index);
 }
 
+/**
+ * This function takes an I/O intrinsic like load/store_input,
+ * and emits a sequence that calculates the full offset of that instruction,
+ * including a stride to the base and component offsets.
+ */
+nir_ssa_def *
+ac_nir_calc_io_offset(nir_builder *b,
+                      nir_intrinsic_instr *intrin,
+                      nir_ssa_def *base_stride,
+                      unsigned component_stride,
+                      ac_nir_map_io_driver_location map_io)
+{
+   unsigned base = nir_intrinsic_base(intrin);
+   unsigned semantic = nir_intrinsic_io_semantics(intrin).location;
+   unsigned mapped_driver_location = map_io ? map_io(semantic) : base;
+
+   /* base is the driver_location, which is in slots (1 slot = 4x4 bytes) */
+   nir_ssa_def *base_op = nir_imul_imm(b, base_stride, mapped_driver_location);
+
+   /* offset should be interpreted in relation to the base,
+    * so the instruction effectively reads/writes another input/output
+    * when it has an offset
+    */
+   nir_ssa_def *offset_op = nir_imul(b, base_stride, nir_ssa_for_src(b, *nir_get_io_offset_src(intrin), 1));
+
+   /* component is in bytes */
+   unsigned const_op = nir_intrinsic_component(intrin) * component_stride;
+
+   return nir_iadd_imm_nuw(b, nir_iadd_nuw(b, base_op, offset_op), const_op);
+}
+
 bool
 ac_nir_lower_indirect_derefs(nir_shader *shader,
                              enum amd_gfx_level gfx_level)
diff --git a/src/amd/common/ac_nir.h b/src/amd/common/ac_nir.h
index 07613668f1af..8920e9855179 100644
--- a/src/amd/common/ac_nir.h
+++ b/src/amd/common/ac_nir.h
@@ -48,6 +48,9 @@ enum
    AC_EXP_PARAM_UNDEFINED = 255, /* deprecated, use AC_EXP_PARAM_DEFAULT_VAL_0000 instead */
 };
 
+/* Maps I/O semantics to the actual location used by the lowering pass. */
+typedef unsigned (*ac_nir_map_io_driver_location)(unsigned semantic);
+
 /* Forward declaration of nir_builder so we don't have to include nir_builder.h here */
 struct nir_builder;
 typedef struct nir_builder nir_builder;
@@ -55,21 +58,31 @@ typedef struct nir_builder nir_builder;
 nir_ssa_def *
 ac_nir_load_arg(nir_builder *b, const struct ac_shader_args *ac_args, struct ac_arg arg);
 
+nir_ssa_def *
+ac_nir_calc_io_offset(nir_builder *b,
+                      nir_intrinsic_instr *intrin,
+                      nir_ssa_def *base_stride,
+                      unsigned component_stride,
+                      ac_nir_map_io_driver_location map_io);
+
 bool ac_nir_optimize_outputs(nir_shader *nir, bool sprite_tex_disallowed,
                              int8_t slot_remap[NUM_TOTAL_VARYING_SLOTS],
                              uint8_t param_export_index[NUM_TOTAL_VARYING_SLOTS]);
 
 void
 ac_nir_lower_ls_outputs_to_mem(nir_shader *ls,
+                               ac_nir_map_io_driver_location map,
                                bool tcs_in_out_eq,
                                uint64_t tcs_temp_only_inputs);
 
 void
 ac_nir_lower_hs_inputs_to_mem(nir_shader *shader,
+                              ac_nir_map_io_driver_location map,
                               bool tcs_in_out_eq);
 
 void
 ac_nir_lower_hs_outputs_to_mem(nir_shader *shader,
+                               ac_nir_map_io_driver_location map,
                                enum amd_gfx_level gfx_level,
                                bool tes_reads_tessfactors,
                                uint64_t tes_inputs_read,
@@ -80,16 +93,19 @@ ac_nir_lower_hs_outputs_to_mem(nir_shader *shader,
 
 void
 ac_nir_lower_tes_inputs_to_mem(nir_shader *shader,
+                               ac_nir_map_io_driver_location map,
                                unsigned num_reserved_tcs_outputs,
                                unsigned num_reserved_tcs_patch_outputs);
 
 void
 ac_nir_lower_es_outputs_to_mem(nir_shader *shader,
+                               ac_nir_map_io_driver_location map,
                                enum amd_gfx_level gfx_level,
                                unsigned num_reserved_es_outputs);
 
 void
 ac_nir_lower_gs_inputs_to_mem(nir_shader *shader,
+                              ac_nir_map_io_driver_location map,
                               enum amd_gfx_level gfx_level,
                               unsigned num_reserved_es_outputs);
 
diff --git a/src/amd/common/ac_nir_lower_esgs_io_to_mem.c b/src/amd/common/ac_nir_lower_esgs_io_to_mem.c
index 1d5f9e9032b8..9cd7f4d6f9b0 100644
--- a/src/amd/common/ac_nir_lower_esgs_io_to_mem.c
+++ b/src/amd/common/ac_nir_lower_esgs_io_to_mem.c
@@ -44,6 +44,9 @@ typedef struct {
    /* Which hardware generation we're dealing with */
    enum amd_gfx_level gfx_level;
 
+   /* I/O semantic -> real location used by lowering. */
+   ac_nir_map_io_driver_location map_io;
+
    /* Number of ES outputs for which memory should be reserved.
     * When compacted, this should be the number of linked ES outputs.
     */
@@ -125,7 +128,7 @@ lower_es_output_store(nir_builder *b,
    unsigned write_mask = nir_intrinsic_write_mask(intrin);
 
    b->cursor = nir_before_instr(instr);
-   nir_ssa_def *io_off = nir_build_calc_io_offset(b, intrin, nir_imm_int(b, 16u), 4u);
+   nir_ssa_def *io_off = ac_nir_calc_io_offset(b, intrin, nir_imm_int(b, 16u), 4u, st->map_io);
 
    if (st->gfx_level <= GFX8) {
       /* GFX6-8: ES is a separate HW stage, data is passed from ES to GS in VRAM. */
@@ -198,7 +201,7 @@ gs_per_vertex_input_offset(nir_builder *b,
                                 : gs_per_vertex_input_vertex_offset_gfx6(b, vertex_src);
 
    unsigned base_stride = st->gfx_level >= GFX9 ? 1 : 64 /* Wave size on GFX6-8 */;
-   nir_ssa_def *io_off = nir_build_calc_io_offset(b, instr, nir_imm_int(b, base_stride * 4u), base_stride);
+   nir_ssa_def *io_off = ac_nir_calc_io_offset(b, instr, nir_imm_int(b, base_stride * 4u), base_stride, st->map_io);
    nir_ssa_def *off = nir_iadd(b, io_off, vertex_offset);
    return nir_imul_imm(b, off, 4u);
 }
@@ -230,12 +233,14 @@ filter_load_per_vertex_input(const nir_instr *instr, UNUSED const void *state)
 
 void
 ac_nir_lower_es_outputs_to_mem(nir_shader *shader,
+                               ac_nir_map_io_driver_location map,
                                enum amd_gfx_level gfx_level,
                                unsigned num_reserved_es_outputs)
 {
    lower_esgs_io_state state = {
       .gfx_level = gfx_level,
       .num_reserved_es_outputs = num_reserved_es_outputs,
+      .map_io = map,
    };
 
    nir_shader_instructions_pass(shader,
@@ -246,12 +251,14 @@ ac_nir_lower_es_outputs_to_mem(nir_shader *shader,
 
 void
 ac_nir_lower_gs_inputs_to_mem(nir_shader *shader,
+                              ac_nir_map_io_driver_location map,
                               enum amd_gfx_level gfx_level,
                               unsigned num_reserved_es_outputs)
 {
    lower_esgs_io_state state = {
       .gfx_level = gfx_level,
       .num_reserved_es_outputs = num_reserved_es_outputs,
+      .map_io = map,
    };
 
    nir_shader_lower_instructions(shader,
diff --git a/src/amd/common/ac_nir_lower_tess_io_to_mem.c b/src/amd/common/ac_nir_lower_tess_io_to_mem.c
index 8483f4609ee5..bb886f4c38c0 100644
--- a/src/amd/common/ac_nir_lower_tess_io_to_mem.c
+++ b/src/amd/common/ac_nir_lower_tess_io_to_mem.c
@@ -123,6 +123,9 @@ typedef struct {
    /* Which hardware generation we're dealing with */
    enum amd_gfx_level gfx_level;
 
+   /* I/O semantic -> real location used by lowering. */
+   ac_nir_map_io_driver_location map_io;
+
    /* True if merged VS+TCS (on GFX9+) has the same number
     * of input and output patch size.
     */
@@ -239,7 +242,7 @@ lower_ls_output_store(nir_builder *b,
    nir_ssa_def *vertex_idx = nir_load_local_invocation_index(b);
    nir_ssa_def *base_off_var = nir_imul(b, vertex_idx, nir_load_lshs_vertex_stride_amd(b));
 
-   nir_ssa_def *io_off = nir_build_calc_io_offset(b, intrin, nir_imm_int(b, 16u), 4u);
+   nir_ssa_def *io_off = ac_nir_calc_io_offset(b, intrin, nir_imm_int(b, 16u), 4u, st->map_io);
    unsigned write_mask = nir_intrinsic_write_mask(intrin);
 
    nir_ssa_def *off = nir_iadd_nuw(b, base_off_var, io_off);
@@ -299,7 +302,7 @@ hs_per_vertex_input_lds_offset(nir_builder *b,
 
    nir_ssa_def *tcs_in_current_patch_offset = nir_imul(b, rel_patch_id, tcs_in_patch_stride);
 
-   nir_ssa_def *io_offset = nir_build_calc_io_offset(b, instr, nir_imm_int(b, 16u), 4u);
+   nir_ssa_def *io_offset = ac_nir_calc_io_offset(b, instr, nir_imm_int(b, 16u), 4u, st->map_io);
 
    return nir_iadd_nuw(b, nir_iadd_nuw(b, tcs_in_current_patch_offset, vertex_index_off), io_offset);
 }
@@ -323,7 +326,7 @@ hs_output_lds_offset(nir_builder *b,
    nir_ssa_def *output_patch0_offset = nir_imul(b, input_patch_size, tcs_num_patches);
 
    nir_ssa_def *off = intrin
-                    ? nir_build_calc_io_offset(b, intrin, nir_imm_int(b, 16u), 4u)
+                    ? ac_nir_calc_io_offset(b, intrin, nir_imm_int(b, 16u), 4u, st->map_io)
                     : nir_imm_int(b, 0);
 
    nir_ssa_def *rel_patch_id = nir_load_tess_rel_patch_id_amd(b);
@@ -353,7 +356,7 @@ hs_per_vertex_output_vmem_offset(nir_builder *b,
 
    nir_ssa_def *tcs_num_patches = nir_load_tcs_num_patches_amd(b);
    nir_ssa_def *attr_stride = nir_imul(b, tcs_num_patches, nir_imul_imm(b, out_vertices_per_patch, 16u));
-   nir_ssa_def *io_offset = nir_build_calc_io_offset(b, intrin, attr_stride, 4u);
+   nir_ssa_def *io_offset = ac_nir_calc_io_offset(b, intrin, attr_stride, 4u, st->map_io);
 
    nir_ssa_def *rel_patch_id = nir_load_tess_rel_patch_id_amd(b);
    nir_ssa_def *patch_offset = nir_imul(b, rel_patch_id, nir_imul_imm(b, out_vertices_per_patch, 16u));
@@ -379,7 +382,7 @@ hs_per_patch_output_vmem_offset(nir_builder *b,
    nir_ssa_def *per_patch_data_offset = nir_imul(b, tcs_num_patches, per_vertex_output_patch_size);
 
    nir_ssa_def * off = intrin
-                    ? nir_build_calc_io_offset(b, intrin, nir_imul_imm(b, tcs_num_patches, 16u), 4u)
+                    ? ac_nir_calc_io_offset(b, intrin, nir_imul_imm(b, tcs_num_patches, 16u), 4u, st->map_io)
                     : nir_imm_int(b, 0);
 
    if (const_base_offset)
@@ -650,6 +653,7 @@ filter_any_input_access(const nir_instr *instr,
 
 void
 ac_nir_lower_ls_outputs_to_mem(nir_shader *shader,
+                               ac_nir_map_io_driver_location map,
                                bool tcs_in_out_eq,
                                uint64_t tcs_temp_only_inputs)
 {
@@ -658,6 +662,7 @@ ac_nir_lower_ls_outputs_to_mem(nir_shader *shader,
    lower_tess_io_state state = {
       .tcs_in_out_eq = tcs_in_out_eq,
       .tcs_temp_only_inputs = tcs_in_out_eq ? tcs_temp_only_inputs : 0,
+      .map_io = map,
    };
 
    nir_shader_instructions_pass(shader,
@@ -668,12 +673,14 @@ ac_nir_lower_ls_outputs_to_mem(nir_shader *shader,
 
 void
 ac_nir_lower_hs_inputs_to_mem(nir_shader *shader,
+                              ac_nir_map_io_driver_location map,
                               bool tcs_in_out_eq)
 {
    assert(shader->info.stage == MESA_SHADER_TESS_CTRL);
 
    lower_tess_io_state state = {
       .tcs_in_out_eq = tcs_in_out_eq,
+      .map_io = map,
    };
 
    nir_shader_lower_instructions(shader,
@@ -684,6 +691,7 @@ ac_nir_lower_hs_inputs_to_mem(nir_shader *shader,
 
 void
 ac_nir_lower_hs_outputs_to_mem(nir_shader *shader,
+                               ac_nir_map_io_driver_location map,
                                enum amd_gfx_level gfx_level,
                                bool tes_reads_tessfactors,
                                uint64_t tes_inputs_read,
@@ -702,6 +710,7 @@ ac_nir_lower_hs_outputs_to_mem(nir_shader *shader,
       .tcs_num_reserved_outputs = num_reserved_tcs_outputs,
       .tcs_num_reserved_patch_outputs = num_reserved_tcs_patch_outputs,
       .tcs_out_patch_fits_subgroup = 32 % shader->info.tess.tcs_vertices_out == 0,
+      .map_io = map,
    };
 
    nir_shader_lower_instructions(shader,
@@ -715,6 +724,7 @@ ac_nir_lower_hs_outputs_to_mem(nir_shader *shader,
 
 void
 ac_nir_lower_tes_inputs_to_mem(nir_shader *shader,
+                               ac_nir_map_io_driver_location map,
                                unsigned num_reserved_tcs_outputs,
                                unsigned num_reserved_tcs_patch_outputs)
 {
@@ -723,6 +733,7 @@ ac_nir_lower_tes_inputs_to_mem(nir_shader *shader,
    lower_tess_io_state state = {
       .tcs_num_reserved_outputs = num_reserved_tcs_outputs,
       .tcs_num_reserved_patch_outputs = num_reserved_tcs_patch_outputs,
+      .map_io = map,
    };
 
    nir_shader_lower_instructions(shader,
diff --git a/src/amd/vulkan/radv_shader.c b/src/amd/vulkan/radv_shader.c
index 57b4276c8461..ce7eca94b4dc 100644
--- a/src/amd/vulkan/radv_shader.c
+++ b/src/amd/vulkan/radv_shader.c
@@ -1069,34 +1069,36 @@ radv_lower_io_to_mem(struct radv_device *device, struct radv_pipeline_stage *sta
 
    if (nir->info.stage == MESA_SHADER_VERTEX) {
       if (info->vs.as_ls) {
-         NIR_PASS_V(nir, ac_nir_lower_ls_outputs_to_mem, info->vs.tcs_in_out_eq,
+         NIR_PASS_V(nir, ac_nir_lower_ls_outputs_to_mem, NULL, info->vs.tcs_in_out_eq,
                     info->vs.tcs_temp_only_input_mask);
          return true;
       } else if (info->vs.as_es) {
-         NIR_PASS_V(nir, ac_nir_lower_es_outputs_to_mem,
+         NIR_PASS_V(nir, ac_nir_lower_es_outputs_to_mem, NULL,
                     device->physical_device->rad_info.gfx_level, info->vs.num_linked_outputs);
          return true;
       }
    } else if (nir->info.stage == MESA_SHADER_TESS_CTRL) {
-      NIR_PASS_V(nir, ac_nir_lower_hs_inputs_to_mem, info->vs.tcs_in_out_eq);
-      NIR_PASS_V(nir, ac_nir_lower_hs_outputs_to_mem, device->physical_device->rad_info.gfx_level,
+      NIR_PASS_V(nir, ac_nir_lower_hs_inputs_to_mem, NULL, info->vs.tcs_in_out_eq);
+      NIR_PASS_V(nir, ac_nir_lower_hs_outputs_to_mem, NULL,
+                 device->physical_device->rad_info.gfx_level,
                  info->tcs.tes_reads_tess_factors, info->tcs.tes_inputs_read,
                  info->tcs.tes_patch_inputs_read, info->tcs.num_linked_outputs,
                  info->tcs.num_linked_patch_outputs, true);
 
       return true;
    } else if (nir->info.stage == MESA_SHADER_TESS_EVAL) {
-      NIR_PASS_V(nir, ac_nir_lower_tes_inputs_to_mem, info->tes.num_linked_inputs,
+      NIR_PASS_V(nir, ac_nir_lower_tes_inputs_to_mem, NULL, info->tes.num_linked_inputs,
                  info->tes.num_linked_patch_inputs);
 
       if (info->tes.as_es) {
-         NIR_PASS_V(nir, ac_nir_lower_es_outputs_to_mem,
+         NIR_PASS_V(nir, ac_nir_lower_es_outputs_to_mem, NULL,
                     device->physical_device->rad_info.gfx_level, info->tes.num_linked_outputs);
       }
 
       return true;
    } else if (nir->info.stage == MESA_SHADER_GEOMETRY) {
-      NIR_PASS_V(nir, ac_nir_lower_gs_inputs_to_mem, device->physical_device->rad_info.gfx_level,
+      NIR_PASS_V(nir, ac_nir_lower_gs_inputs_to_mem, NULL,
+                 device->physical_device->rad_info.gfx_level,
                  info->gs.num_linked_inputs);
       return true;
    } else if (nir->info.stage == MESA_SHADER_TASK) {
diff --git a/src/compiler/nir/nir_builder.h b/src/compiler/nir/nir_builder.h
index 928d7797f3f0..0f73655a8bca 100644
--- a/src/compiler/nir/nir_builder.h
+++ b/src/compiler/nir/nir_builder.h
@@ -1509,32 +1509,6 @@ nir_load_param(nir_builder *build, uint32_t param_idx)
    return nir_build_load_param(build, param->num_components, param->bit_size, param_idx);
 }
 
-/**
- * This function takes an I/O intrinsic like load/store_input,
- * and emits a sequence that calculates the full offset of that instruction,
- * including a stride to the base and component offsets.
- */
-static inline nir_ssa_def *
-nir_build_calc_io_offset(nir_builder *b,
-                         nir_intrinsic_instr *intrin,
-                         nir_ssa_def *base_stride,
-                         unsigned component_stride)
-{
-   /* base is the driver_location, which is in slots (1 slot = 4x4 bytes) */
-   nir_ssa_def *base_op = nir_imul_imm(b, base_stride, nir_intrinsic_base(intrin));
-
-   /* offset should be interpreted in relation to the base,
-    * so the instruction effectively reads/writes another input/output
-    * when it has an offset
-    */
-   nir_ssa_def *offset_op = nir_imul(b, base_stride, nir_ssa_for_src(b, *nir_get_io_offset_src(intrin), 1));
-
-   /* component is in bytes */
-   unsigned const_op = nir_intrinsic_component(intrin) * component_stride;
-
-   return nir_iadd_imm_nuw(b, nir_iadd_nuw(b, base_op, offset_op), const_op);
-}
-
 /* calculate a `(1 << value) - 1` in ssa without overflows */
 static inline nir_ssa_def *
 nir_mask(nir_builder *b, nir_ssa_def *bits, unsigned dst_bit_size)
-- 
GitLab


From ca3c99b6a9b2665bddef9b8f1f4743baf1367fa5 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Mon, 9 May 2022 21:28:26 +0800
Subject: [PATCH 08/39] radeonsi: replace llvm ls/hs interface lds ops with nir
 lowered ones

Use ac nir lower pass to generate these lds load/store ops explicitly.

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/amd/llvm/ac_nir_to_llvm.c                 |   9 +-
 src/amd/llvm/ac_shader_abi.h                  |   3 +-
 src/gallium/drivers/radeonsi/si_shader.c      |  41 ++++++-
 .../drivers/radeonsi/si_shader_internal.h     |   1 -
 src/gallium/drivers/radeonsi/si_shader_llvm.c |   7 +-
 .../drivers/radeonsi/si_shader_llvm_tess.c    | 105 +++++-------------
 6 files changed, 70 insertions(+), 96 deletions(-)

diff --git a/src/amd/llvm/ac_nir_to_llvm.c b/src/amd/llvm/ac_nir_to_llvm.c
index e3412cbce8c2..f45b71b19417 100644
--- a/src/amd/llvm/ac_nir_to_llvm.c
+++ b/src/amd/llvm/ac_nir_to_llvm.c
@@ -3459,17 +3459,10 @@ static LLVMValueRef visit_load(struct ac_nir_context *ctx, nir_intrinsic_instr *
 
    if (ctx->stage == MESA_SHADER_TESS_CTRL ||
        (ctx->stage == MESA_SHADER_TESS_EVAL && !is_output)) {
-      bool vertex_index_is_invoc_id =
-         vertex_index_src &&
-         vertex_index_src->ssa->parent_instr->type == nir_instr_type_intrinsic &&
-         nir_instr_as_intrinsic(vertex_index_src->ssa->parent_instr)->intrinsic ==
-         nir_intrinsic_load_invocation_id;
-
       LLVMValueRef result = ctx->abi->load_tess_varyings(ctx->abi, component_type,
                                                          vertex_index, indir_index,
                                                          base, component,
-                                                         count, !is_output,
-                                                         vertex_index_is_invoc_id);
+                                                         count, !is_output);
       if (instr->dest.ssa.bit_size == 16) {
          result = ac_to_integer(&ctx->ac, result);
          result = LLVMBuildTrunc(ctx->ac.builder, result, dest_type, "");
diff --git a/src/amd/llvm/ac_shader_abi.h b/src/amd/llvm/ac_shader_abi.h
index 2d2697b2e718..4584d52d1203 100644
--- a/src/amd/llvm/ac_shader_abi.h
+++ b/src/amd/llvm/ac_shader_abi.h
@@ -67,8 +67,7 @@ struct ac_shader_abi {
    LLVMValueRef (*load_tess_varyings)(struct ac_shader_abi *abi, LLVMTypeRef type,
                                       LLVMValueRef vertex_index, LLVMValueRef param_index,
                                       unsigned driver_location, unsigned component,
-                                      unsigned num_components,
-                                      bool load_inputs, bool vertex_index_is_invoc_id);
+                                      unsigned num_components, bool load_inputs);
 
    void (*store_tcs_outputs)(struct ac_shader_abi *abi,
                              LLVMValueRef vertex_index, LLVMValueRef param_index,
diff --git a/src/gallium/drivers/radeonsi/si_shader.c b/src/gallium/drivers/radeonsi/si_shader.c
index 0ec4f8c42f8b..575f6c4b169d 100644
--- a/src/gallium/drivers/radeonsi/si_shader.c
+++ b/src/gallium/drivers/radeonsi/si_shader.c
@@ -1490,6 +1490,30 @@ static bool si_nir_kill_outputs(nir_shader *nir, const union si_shader_key *key)
    return progress;
 }
 
+static unsigned si_map_io_driver_location(unsigned semantic)
+{
+   return si_shader_io_get_unique_index(semantic, false);
+}
+
+static bool si_lower_io_to_mem(const union si_shader_key *key,
+                               nir_shader *nir,
+                               uint64_t tcs_vgpr_only_inputs)
+{
+   if (nir->info.stage == MESA_SHADER_VERTEX) {
+      if (key->ge.as_ls) {
+         NIR_PASS_V(nir, ac_nir_lower_ls_outputs_to_mem, si_map_io_driver_location,
+                    key->ge.opt.same_patch_vertices, tcs_vgpr_only_inputs);
+         return true;
+      }
+   } else if (nir->info.stage == MESA_SHADER_TESS_CTRL) {
+      NIR_PASS_V(nir, ac_nir_lower_hs_inputs_to_mem, si_map_io_driver_location,
+                 key->ge.opt.same_patch_vertices);
+      return true;
+   }
+
+   return false;
+}
+
 struct nir_shader *si_get_nir_shader(struct si_shader_selector *sel,
                                      const union si_shader_key *key,
                                      bool *free_nir,
@@ -1603,10 +1627,23 @@ struct nir_shader *si_get_nir_shader(struct si_shader_selector *sel,
     * this should be done after that.
     */
    progress2 |= ac_nir_lower_indirect_derefs(nir, sel->screen->info.gfx_level);
-   if (progress2)
+
+   bool opt_offsets = false;
+   opt_offsets |= si_lower_io_to_mem(key, nir, tcs_vgpr_only_inputs);
+
+   if (progress2 || opt_offsets)
       si_nir_opts(sel->screen, nir, false);
 
-   if (progress || progress2)
+   if (opt_offsets) {
+      static const nir_opt_offsets_options offset_options = {
+         .uniform_max = 0,
+         .buffer_max = ~0,
+         .shared_max = ~0,
+      };
+      NIR_PASS_V(nir, nir_opt_offsets, &offset_options);
+   }
+
+   if (progress || progress2 || opt_offsets)
       si_nir_late_opts(nir);
 
    NIR_PASS_V(nir, nir_divergence_analysis);
diff --git a/src/gallium/drivers/radeonsi/si_shader_internal.h b/src/gallium/drivers/radeonsi/si_shader_internal.h
index 907dc04b796a..ee04b3708d7f 100644
--- a/src/gallium/drivers/radeonsi/si_shader_internal.h
+++ b/src/gallium/drivers/radeonsi/si_shader_internal.h
@@ -39,7 +39,6 @@ struct si_shader_output_values {
 struct si_shader_context {
    struct ac_llvm_context ac;
    struct si_shader *shader;
-   struct si_shader_selector *next_shader_sel;
    struct si_screen *screen;
    struct pipe_stream_output_info so;
 
diff --git a/src/gallium/drivers/radeonsi/si_shader_llvm.c b/src/gallium/drivers/radeonsi/si_shader_llvm.c
index 2a15e71086e2..a5b1389f24c1 100644
--- a/src/gallium/drivers/radeonsi/si_shader_llvm.c
+++ b/src/gallium/drivers/radeonsi/si_shader_llvm.c
@@ -743,10 +743,10 @@ static LLVMValueRef si_llvm_load_intrinsic(struct ac_shader_abi *abi, nir_intrin
    }
 
    case nir_intrinsic_load_tess_level_outer:
-      return abi->load_tess_varyings(abi, ctx->ac.f32, NULL, NULL, info->num_inputs, 0, 4, true, false);
+      return abi->load_tess_varyings(abi, ctx->ac.f32, NULL, NULL, info->num_inputs, 0, 4, true);
 
    case nir_intrinsic_load_tess_level_inner:
-      return abi->load_tess_varyings(abi, ctx->ac.f32, NULL, NULL, info->num_inputs + 1, 0, 4, true, false);
+      return abi->load_tess_varyings(abi, ctx->ac.f32, NULL, NULL, info->num_inputs + 1, 0, 4, true);
 
    case nir_intrinsic_load_tess_level_outer_default:
    case nir_intrinsic_load_tess_level_inner_default: {
@@ -1241,9 +1241,6 @@ bool si_llvm_compile_shader(struct si_screen *sscreen, struct ac_llvm_compiler *
          si_llvm_build_tcs_epilog(&ctx, &tcs_epilog_key);
          parts[3] = ctx.main_fn;
 
-         /* VS as LS main part */
-         ctx.next_shader_sel = ctx.shader->selector;
-
          struct si_shader shader_ls = {};
          shader_ls.selector = ls;
          shader_ls.key.ge.part.vs.prolog = shader->key.ge.part.tcs.ls_prolog;
diff --git a/src/gallium/drivers/radeonsi/si_shader_llvm_tess.c b/src/gallium/drivers/radeonsi/si_shader_llvm_tess.c
index 72c355378bb9..24e1858e3a25 100644
--- a/src/gallium/drivers/radeonsi/si_shader_llvm_tess.c
+++ b/src/gallium/drivers/radeonsi/si_shader_llvm_tess.c
@@ -384,44 +384,33 @@ void si_llvm_preload_tes_rings(struct si_shader_context *ctx)
 static LLVMValueRef si_nir_load_tcs_varyings(struct ac_shader_abi *abi, LLVMTypeRef type,
                                              LLVMValueRef vertex_index, LLVMValueRef param_index,
                                              unsigned driver_location, unsigned component,
-                                             unsigned num_components, bool load_input,
-                                             bool vertex_index_is_invoc_id)
+                                             unsigned num_components, bool load_input)
 {
    struct si_shader_context *ctx = si_shader_context_from_abi(abi);
    struct si_shader_info *info = &ctx->shader->selector->info;
-   LLVMValueRef dw_addr, stride;
-   ubyte semantic;
+   LLVMValueRef value[4];
 
    if (load_input) {
-      semantic = info->input[driver_location].semantic;
-   } else {
-      semantic = info->output_semantic[driver_location];
-   }
+      assert(ctx->shader->key.ge.opt.same_patch_vertices && !param_index);
 
-   /* Load the TCS input from a VGPR if possible. */
-   if (ctx->shader->key.ge.opt.same_patch_vertices &&
-       load_input && vertex_index_is_invoc_id && !param_index) {
+      ubyte semantic = info->input[driver_location].semantic;
+      /* Load the TCS input from a VGPR. */
       unsigned func_param = ctx->args.tcs_rel_ids.arg_index + 1 +
-                            si_shader_io_get_unique_index(semantic, false) * 4;
-      LLVMValueRef value[4];
+         si_shader_io_get_unique_index(semantic, false) * 4;
 
       for (unsigned i = component; i < component + num_components; i++) {
          value[i] = LLVMGetParam(ctx->main_fn, func_param + i);
          value[i] = LLVMBuildBitCast(ctx->ac.builder, value[i], type, "");
       }
+   } else {
+      ubyte semantic = info->output_semantic[driver_location];
 
-      return ac_build_varying_gather_values(&ctx->ac, value, num_components, component);
-   }
-
-   bool is_patch = vertex_index == NULL;
-   assert((semantic >= VARYING_SLOT_PATCH0 ||
-           semantic == VARYING_SLOT_TESS_LEVEL_INNER ||
-           semantic == VARYING_SLOT_TESS_LEVEL_OUTER) == is_patch);
+      bool is_patch = vertex_index == NULL;
+      assert((semantic >= VARYING_SLOT_PATCH0 ||
+              semantic == VARYING_SLOT_TESS_LEVEL_INNER ||
+              semantic == VARYING_SLOT_TESS_LEVEL_OUTER) == is_patch);
 
-   if (load_input) {
-      stride = si_get_tcs_in_vertex_dw_stride(ctx);
-      dw_addr = get_tcs_in_current_patch_offset(ctx);
-   } else {
+      LLVMValueRef dw_addr, stride;
       if (is_patch) {
          stride = NULL;
          dw_addr = get_tcs_out_current_patch_data_offset(ctx);
@@ -429,14 +418,13 @@ static LLVMValueRef si_nir_load_tcs_varyings(struct ac_shader_abi *abi, LLVMType
          stride = get_tcs_out_vertex_dw_stride(ctx);
          dw_addr = get_tcs_out_current_patch_offset(ctx);
       }
-   }
 
-   dw_addr = get_dw_address_from_generic_indices(ctx, stride, dw_addr, vertex_index, param_index,
-                                                 semantic);
+      dw_addr = get_dw_address_from_generic_indices(ctx, stride, dw_addr, vertex_index,
+                                                    param_index, semantic);
 
-   LLVMValueRef value[4];
-   for (unsigned i = component; i < component + num_components; i++)
-      value[i] = lshs_lds_load(ctx, type, i, dw_addr);
+      for (unsigned i = component; i < component + num_components; i++)
+         value[i] = lshs_lds_load(ctx, type, i, dw_addr);
+   }
 
    return ac_build_varying_gather_values(&ctx->ac, value, num_components, component);
 }
@@ -444,8 +432,7 @@ static LLVMValueRef si_nir_load_tcs_varyings(struct ac_shader_abi *abi, LLVMType
 static LLVMValueRef si_nir_load_input_tes(struct ac_shader_abi *abi, LLVMTypeRef type,
                                           LLVMValueRef vertex_index, LLVMValueRef param_index,
                                           unsigned driver_location, unsigned component,
-                                          unsigned num_components,
-                                          bool load_input, bool vertex_index_is_invoc_id)
+                                          unsigned num_components, bool load_input)
 {
    struct si_shader_context *ctx = si_shader_context_from_abi(abi);
    struct si_shader_info *info = &ctx->shader->selector->info;
@@ -877,58 +864,20 @@ void si_llvm_ls_build_end(struct si_shader_context *ctx)
 {
    struct si_shader *shader = ctx->shader;
    struct si_shader_info *info = &shader->selector->info;
-   unsigned i, chan;
-   LLVMValueRef vertex_id;
-   if (ctx->screen->info.gfx_level >= GFX11) {
-      vertex_id = ac_build_imad(&ctx->ac, si_unpack_param(ctx, ctx->args.tcs_wave_id, 0, 5),
-                                LLVMConstInt(ctx->ac.i32, ctx->ac.wave_size, 0),
-                                ac_get_thread_id(&ctx->ac));
-   } else {
-      vertex_id = ac_get_arg(&ctx->ac, ctx->args.vs_rel_patch_id);
-   }
-   LLVMValueRef vertex_dw_stride = si_get_tcs_in_vertex_dw_stride(ctx);
-   LLVMValueRef base_dw_addr = LLVMBuildMul(ctx->ac.builder, vertex_id, vertex_dw_stride, "");
    LLVMValueRef *addrs = ctx->abi.outputs;
    unsigned ret_offset = 8 + GFX9_TCS_NUM_USER_SGPR + 2;
 
-   /* Write outputs to LDS. The next shader (TCS aka HS) will read
-    * its inputs from it. */
-   for (i = 0; i < info->num_outputs; i++) {
-      unsigned semantic = info->output_semantic[i];
-
-      /* The ARB_shader_viewport_layer_array spec contains the
-       * following issue:
-       *
-       *    2) What happens if gl_ViewportIndex or gl_Layer is
-       *    written in the vertex shader and a geometry shader is
-       *    present?
-       *
-       *    RESOLVED: The value written by the last vertex processing
-       *    stage is used. If the last vertex processing stage
-       *    (vertex, tessellation evaluation or geometry) does not
-       *    statically assign to gl_ViewportIndex or gl_Layer, index
-       *    or layer zero is assumed.
-       *
-       * So writes to those outputs in VS-as-LS are simply ignored.
-       */
-      if (semantic == VARYING_SLOT_LAYER || semantic == VARYING_SLOT_VIEWPORT)
-         continue;
-
-      int param = si_shader_io_get_unique_index(semantic, false);
-      LLVMValueRef dw_addr =
-         LLVMBuildAdd(ctx->ac.builder, base_dw_addr, LLVMConstInt(ctx->ac.i32, param * 4, 0), "");
-
-      for (chan = 0; chan < 4; chan++) {
-         if (!(info->output_usagemask[i] & (1 << chan)))
-            continue;
+   if (shader->key.ge.opt.same_patch_vertices) {
+      for (unsigned i = 0; i < info->num_outputs; i++) {
+         unsigned semantic = info->output_semantic[i];
+         int param = si_shader_io_get_unique_index(semantic, false);
 
-         LLVMValueRef value = LLVMBuildLoad(ctx->ac.builder, addrs[4 * i + chan], "");
+         for (unsigned chan = 0; chan < 4; chan++) {
+            if (!(info->output_usagemask[i] & (1 << chan)))
+               continue;
 
-         if (!shader->key.ge.opt.same_patch_vertices ||
-             !(ctx->next_shader_sel->info.tcs_vgpr_only_inputs & (1ull << semantic)))
-            lshs_lds_store(ctx, chan, dw_addr, value);
+            LLVMValueRef value = LLVMBuildLoad(ctx->ac.builder, addrs[4 * i + chan], "");
 
-         if (shader->key.ge.opt.same_patch_vertices) {
             ctx->return_value = LLVMBuildInsertValue(ctx->ac.builder, ctx->return_value,
                                                      value, ret_offset + param * 4 + chan, "");
          }
-- 
GitLab


From a893593cfde94c71a7223e093a671583582c3023 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Fri, 27 May 2022 17:24:41 +0800
Subject: [PATCH 09/39] radeonsi: deserialize nir binary in
 si_check_blend_dst_sampler_noop

We can do this parse with original nir instead of shader key pass
applied nir in si_get_nir_shader.

This can free si_get_nir_shader to just use si_shader as parameter.

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/gallium/drivers/radeonsi/si_nir_optim.c | 25 +++++++++------------
 src/gallium/drivers/radeonsi/si_shader.c    | 18 +++++++++------
 src/gallium/drivers/radeonsi/si_shader.h    |  1 +
 src/gallium/drivers/radeonsi/si_state.c     | 17 +++++---------
 4 files changed, 28 insertions(+), 33 deletions(-)

diff --git a/src/gallium/drivers/radeonsi/si_nir_optim.c b/src/gallium/drivers/radeonsi/si_nir_optim.c
index 0374c870c5a4..993bb04fb206 100644
--- a/src/gallium/drivers/radeonsi/si_nir_optim.c
+++ b/src/gallium/drivers/radeonsi/si_nir_optim.c
@@ -175,19 +175,16 @@ si_nir_is_output_const_if_tex_is_const(nir_shader *shader, float *in, float *out
        util_bitcount64(shader->info.outputs_written) != 1)
       return false;
 
-   /* Clone the shader */
-   nir_shader *sh = nir_shader_clone(ralloc_parent(shader), shader);
-
    struct replace_param p;
    memcpy(p.value, in, 4 * sizeof(float));
    p.texunit = texunit;
 
    /* Test if the single store_output only depends on constants and a single texture op */
-   if (nir_shader_instructions_pass(sh, store_instr_depends_on_tex, nir_metadata_all, &p)) {
+   if (nir_shader_instructions_pass(shader, store_instr_depends_on_tex, nir_metadata_all, &p)) {
       assert(*p.texunit != -1);
 
       /* Replace nir_tex_instr using texunit by vec4(v) */
-      nir_shader_instructions_pass(sh, replace_tex_by_imm,
+      nir_shader_instructions_pass(shader, replace_tex_by_imm,
                                    nir_metadata_block_index |
                                    nir_metadata_dominance, &p);
 
@@ -195,20 +192,18 @@ si_nir_is_output_const_if_tex_is_const(nir_shader *shader, float *in, float *out
       bool progress;
       do {
          progress = false;
-         NIR_PASS(progress, sh, nir_copy_prop);
-         NIR_PASS(progress, sh, nir_opt_remove_phis);
-         NIR_PASS(progress, sh, nir_opt_dce);
-         NIR_PASS(progress, sh, nir_opt_dead_cf);
-         NIR_PASS(progress, sh, nir_opt_algebraic);
-         NIR_PASS(progress, sh, nir_opt_constant_folding);
+         NIR_PASS(progress, shader, nir_copy_prop);
+         NIR_PASS(progress, shader, nir_opt_remove_phis);
+         NIR_PASS(progress, shader, nir_opt_dce);
+         NIR_PASS(progress, shader, nir_opt_dead_cf);
+         NIR_PASS(progress, shader, nir_opt_algebraic);
+         NIR_PASS(progress, shader, nir_opt_constant_folding);
       } while (progress);
 
       /* Is the output a constant value? */
-      if (get_output_as_const_value(sh, out)) {
-         ralloc_free(sh);
+      if (get_output_as_const_value(shader, out))
          return true;
-      }
    }
-   ralloc_free(sh);
+
    return false;
 }
diff --git a/src/gallium/drivers/radeonsi/si_shader.c b/src/gallium/drivers/radeonsi/si_shader.c
index 575f6c4b169d..f849b945eb09 100644
--- a/src/gallium/drivers/radeonsi/si_shader.c
+++ b/src/gallium/drivers/radeonsi/si_shader.c
@@ -1514,6 +1514,17 @@ static bool si_lower_io_to_mem(const union si_shader_key *key,
    return false;
 }
 
+struct nir_shader *si_deserialize_shader(struct si_shader_selector *sel)
+{
+   struct pipe_screen *screen = &sel->screen->b;
+   const void *options = screen->get_compiler_options(screen, PIPE_SHADER_IR_NIR,
+                                                      pipe_shader_type_from_mesa(sel->stage));
+
+   struct blob_reader blob_reader;
+   blob_reader_init(&blob_reader, sel->nir_binary, sel->nir_size);
+   return nir_deserialize(NULL, options, &blob_reader);
+}
+
 struct nir_shader *si_get_nir_shader(struct si_shader_selector *sel,
                                      const union si_shader_key *key,
                                      bool *free_nir,
@@ -1525,14 +1536,7 @@ struct nir_shader *si_get_nir_shader(struct si_shader_selector *sel,
    if (sel->nir) {
       nir = sel->nir;
    } else if (sel->nir_binary) {
-      struct pipe_screen *screen = &sel->screen->b;
-      const void *options = screen->get_compiler_options(screen, PIPE_SHADER_IR_NIR,
-                                                         pipe_shader_type_from_mesa(sel->stage));
-
-      struct blob_reader blob_reader;
-      blob_reader_init(&blob_reader, sel->nir_binary, sel->nir_size);
       *free_nir = true;
-      nir = nir_deserialize(NULL, options, &blob_reader);
    } else {
       return NULL;
    }
diff --git a/src/gallium/drivers/radeonsi/si_shader.h b/src/gallium/drivers/radeonsi/si_shader.h
index d45d2e27fee3..bff4f20be30b 100644
--- a/src/gallium/drivers/radeonsi/si_shader.h
+++ b/src/gallium/drivers/radeonsi/si_shader.h
@@ -952,6 +952,7 @@ void si_shader_dump_stats_for_shader_db(struct si_screen *screen, struct si_shad
 void si_multiwave_lds_size_workaround(struct si_screen *sscreen, unsigned *lds_size);
 const char *si_get_shader_name(const struct si_shader *shader);
 void si_shader_binary_clean(struct si_shader_binary *binary);
+struct nir_shader *si_deserialize_shader(struct si_shader_selector *sel);
 
 /* si_shader_info.c */
 void si_nir_scan_shader(struct si_screen *sscreen,  const struct nir_shader *nir,
diff --git a/src/gallium/drivers/radeonsi/si_state.c b/src/gallium/drivers/radeonsi/si_state.c
index 48dea26cb9ed..f494238d8320 100644
--- a/src/gallium/drivers/radeonsi/si_state.c
+++ b/src/gallium/drivers/radeonsi/si_state.c
@@ -656,15 +656,12 @@ static bool si_check_blend_dst_sampler_noop(struct si_context *sctx)
    if (sctx->framebuffer.state.nr_cbufs == 1) {
       struct si_shader_selector *sel = sctx->shader.ps.cso;
 
-      /* Wait for the shader to be ready. */
-      util_queue_fence_wait(&sel->ready);
-
-      assert(!sel->nir);
-
-      bool free_nir;
       if (unlikely(sel->info.writes_1_if_tex_is_1 == 0xff)) {
-         struct nir_shader *nir =
-            si_get_nir_shader(sel, &sctx->shader.ps.key, &free_nir, 0);
+          /* Wait for the shader to be ready. */
+         util_queue_fence_wait(&sel->ready);
+         assert(sel->nir_binary);
+
+         struct nir_shader *nir = si_deserialize_shader(sel);
 
          /* Determine if this fragment shader always writes vec4(1) if a specific texture
           * is all 1s.
@@ -679,9 +676,7 @@ static bool si_check_blend_dst_sampler_noop(struct si_context *sctx)
             sel->info.writes_1_if_tex_is_1 = 0;
          }
 
-         assert(free_nir);
-         if (free_nir)
-            ralloc_free(nir);
+         ralloc_free(nir);
       }
 
       if (sel->info.writes_1_if_tex_is_1 &&
-- 
GitLab


From 625fbb62e94150c363612e42189cf6e64771b2bc Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Fri, 27 May 2022 17:32:45 +0800
Subject: [PATCH 10/39] radeonsi: use si_shader as parameter in
 si_get_nir_shader

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/gallium/drivers/radeonsi/si_shader.c          | 10 ++++++----
 src/gallium/drivers/radeonsi/si_shader_internal.h |  4 +---
 src/gallium/drivers/radeonsi/si_shader_llvm.c     |  5 ++---
 3 files changed, 9 insertions(+), 10 deletions(-)

diff --git a/src/gallium/drivers/radeonsi/si_shader.c b/src/gallium/drivers/radeonsi/si_shader.c
index f849b945eb09..5a57ab4a1408 100644
--- a/src/gallium/drivers/radeonsi/si_shader.c
+++ b/src/gallium/drivers/radeonsi/si_shader.c
@@ -1525,17 +1525,19 @@ struct nir_shader *si_deserialize_shader(struct si_shader_selector *sel)
    return nir_deserialize(NULL, options, &blob_reader);
 }
 
-struct nir_shader *si_get_nir_shader(struct si_shader_selector *sel,
-                                     const union si_shader_key *key,
-                                     bool *free_nir,
+struct nir_shader *si_get_nir_shader(struct si_shader *shader, bool *free_nir,
                                      uint64_t tcs_vgpr_only_inputs)
 {
+   struct si_shader_selector *sel = shader->selector;
+   const union si_shader_key *key = &shader->key;
+
    nir_shader *nir;
    *free_nir = false;
 
    if (sel->nir) {
       nir = sel->nir;
    } else if (sel->nir_binary) {
+      nir = si_deserialize_shader(sel);
       *free_nir = true;
    } else {
       return NULL;
@@ -1725,7 +1727,7 @@ bool si_compile_shader(struct si_screen *sscreen, struct ac_llvm_compiler *compi
 {
    struct si_shader_selector *sel = shader->selector;
    bool free_nir;
-   struct nir_shader *nir = si_get_nir_shader(sel, &shader->key, &free_nir, 0);
+   struct nir_shader *nir = si_get_nir_shader(shader, &free_nir, 0);
 
    /* Assign param export indices. */
    if ((sel->stage == MESA_SHADER_VERTEX ||
diff --git a/src/gallium/drivers/radeonsi/si_shader_internal.h b/src/gallium/drivers/radeonsi/si_shader_internal.h
index ee04b3708d7f..3860095e4ba3 100644
--- a/src/gallium/drivers/radeonsi/si_shader_internal.h
+++ b/src/gallium/drivers/radeonsi/si_shader_internal.h
@@ -173,9 +173,7 @@ bool si_vs_needs_prolog(const struct si_shader_selector *sel,
 void si_get_vs_prolog_key(const struct si_shader_info *info, unsigned num_input_sgprs,
                           bool ngg_cull_shader, const struct si_vs_prolog_bits *prolog_key,
                           struct si_shader *shader_out, union si_shader_part_key *key);
-struct nir_shader *si_get_nir_shader(struct si_shader_selector *sel,
-                                     const union si_shader_key *key,
-                                     bool *free_nir,
+struct nir_shader *si_get_nir_shader(struct si_shader *shader, bool *free_nir,
                                      uint64_t tcs_vgpr_only_inputs);
 void si_get_tcs_epilog_key(struct si_shader *shader, union si_shader_part_key *key);
 bool si_need_ps_prolog(const union si_shader_part_key *key);
diff --git a/src/gallium/drivers/radeonsi/si_shader_llvm.c b/src/gallium/drivers/radeonsi/si_shader_llvm.c
index a5b1389f24c1..c47327095c37 100644
--- a/src/gallium/drivers/radeonsi/si_shader_llvm.c
+++ b/src/gallium/drivers/radeonsi/si_shader_llvm.c
@@ -1250,8 +1250,7 @@ bool si_llvm_compile_shader(struct si_screen *sscreen, struct ac_llvm_compiler *
          shader_ls.key.ge.opt.inline_uniforms = false; /* only TCS can inline uniforms */
          shader_ls.is_monolithic = true;
 
-         nir = si_get_nir_shader(ls, &shader_ls.key, &free_nir,
-                                 sel->info.tcs_vgpr_only_inputs);
+         nir = si_get_nir_shader(&shader_ls, &free_nir, sel->info.tcs_vgpr_only_inputs);
          si_update_shader_binary_info(shader, nir);
 
          if (!si_llvm_translate_nir(&ctx, &shader_ls, nir, free_nir, false)) {
@@ -1311,7 +1310,7 @@ bool si_llvm_compile_shader(struct si_screen *sscreen, struct ac_llvm_compiler *
          shader_es.key.ge.opt.kill_outputs = 0;
          shader_es.is_monolithic = true;
 
-         nir = si_get_nir_shader(es, &shader_es.key, &free_nir, 0);
+         nir = si_get_nir_shader(&shader_es, &free_nir, 0);
          si_update_shader_binary_info(shader, nir);
 
          if (!si_llvm_translate_nir(&ctx, &shader_es, nir, free_nir, false)) {
-- 
GitLab

From 710aec9acd5b84af853b6921cba95b33d06eba86 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Wed, 18 May 2022 16:57:17 +0800
Subject: [PATCH 12/39] radeonsi: support multi stage shader state creation in
 nir shaderlib

For creating tcs passthrough shader.

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 .../drivers/radeonsi/si_shaderlib_nir.c       | 44 ++++++++++++++-----
 1 file changed, 32 insertions(+), 12 deletions(-)

diff --git a/src/gallium/drivers/radeonsi/si_shaderlib_nir.c b/src/gallium/drivers/radeonsi/si_shaderlib_nir.c
index 86b93b63cf04..9b9d0fd07585 100644
--- a/src/gallium/drivers/radeonsi/si_shaderlib_nir.c
+++ b/src/gallium/drivers/radeonsi/si_shaderlib_nir.c
@@ -26,15 +26,35 @@
 #include "ac_surface.h"
 #include "si_pipe.h"
 
-static void *create_nir_cs(struct si_context *sctx, nir_builder *b)
+static void *create_shader_state(struct si_context *sctx, nir_shader *nir)
 {
-   nir_shader_gather_info(b->shader, nir_shader_get_entrypoint(b->shader));
-
-   struct pipe_compute_state state = {0};
-   state.ir_type = PIPE_SHADER_IR_NIR;
-   state.prog = b->shader;
-   sctx->b.screen->finalize_nir(sctx->b.screen, (void*)state.prog);
-   return sctx->b.create_compute_state(&sctx->b, &state);
+   nir_shader_gather_info(nir, nir_shader_get_entrypoint(nir));
+
+   sctx->b.screen->finalize_nir(sctx->b.screen, (void*)nir);
+
+   struct pipe_shader_state state = {0};
+   state.type = PIPE_SHADER_IR_NIR;
+   state.ir.nir = nir;
+
+   switch (nir->info.stage) {
+   case MESA_SHADER_VERTEX:
+      return sctx->b.create_vs_state(&sctx->b, &state);
+   case MESA_SHADER_TESS_CTRL:
+      return sctx->b.create_tcs_state(&sctx->b, &state);
+   case MESA_SHADER_TESS_EVAL:
+      return sctx->b.create_tes_state(&sctx->b, &state);
+   case MESA_SHADER_FRAGMENT:
+      return sctx->b.create_fs_state(&sctx->b, &state);
+   case MESA_SHADER_COMPUTE: {
+      struct pipe_compute_state cs_state = {0};
+      cs_state.ir_type = PIPE_SHADER_IR_NIR;
+      cs_state.prog = nir;
+      return sctx->b.create_compute_state(&sctx->b, &cs_state);
+   }
+   default:
+      unreachable("invalid shader stage");
+      return NULL;
+   }
 }
 
 static nir_ssa_def *get_global_ids(nir_builder *b, unsigned num_components)
@@ -115,7 +135,7 @@ void *si_create_copy_image_cs(struct si_context *sctx, bool src_is_1d_array, boo
 
    nir_image_deref_store(&b, deref_ssa(&b, img_dst), coord_dst, undef32, data, zero);
 
-   return create_nir_cs(sctx, &b);
+   return create_shader_state(sctx, b.shader);
 }
 
 void *si_create_dcc_retile_cs(struct si_context *sctx, struct radeon_surf *surf)
@@ -163,7 +183,7 @@ void *si_create_dcc_retile_cs(struct si_context *sctx, struct radeon_surf *surf)
                                  zero, zero, zero); /* z, sample, pipe_xor */
    nir_store_ssbo(&b, value, zero, dst_offset, .write_mask=0x1, .align_mul=1);
 
-   return create_nir_cs(sctx, &b);
+   return create_shader_state(sctx, b.shader);
 }
 
 void *gfx9_create_clear_dcc_msaa_cs(struct si_context *sctx, struct si_texture *tex)
@@ -209,7 +229,7 @@ void *gfx9_create_clear_dcc_msaa_cs(struct si_context *sctx, struct si_texture *
     */
    nir_store_ssbo(&b, clear_value, zero, offset, .write_mask=0x1, .align_mul=2);
 
-   return create_nir_cs(sctx, &b);
+   return create_shader_state(sctx, b.shader);
 }
 
 /* Create a compute shader implementing clear_buffer or copy_buffer. */
@@ -247,6 +267,6 @@ void *si_create_clear_buffer_rmw_cs(struct si_context *sctx)
       .access = SI_COMPUTE_DST_CACHE_POLICY != L2_LRU ? ACCESS_STREAM_CACHE_POLICY : 0,
       .align_mul = 4);
 
-   return create_nir_cs(sctx, &b);
+   return create_shader_state(sctx, b.shader);
 }
 
-- 
GitLab


From 899de047d3ba2af4963164a4ab09e94e90539f96 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Wed, 18 May 2022 17:12:58 +0800
Subject: [PATCH 13/39] radeonsi: add si_create_passthrough_tcs

For replacing si_create_fixed_func_tcs.

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/gallium/drivers/radeonsi/si_pipe.h        |  1 +
 .../drivers/radeonsi/si_shaderlib_nir.c       | 79 +++++++++++++++++++
 2 files changed, 80 insertions(+)

diff --git a/src/gallium/drivers/radeonsi/si_pipe.h b/src/gallium/drivers/radeonsi/si_pipe.h
index 4192ddc3b852..ea6c176377d3 100644
--- a/src/gallium/drivers/radeonsi/si_pipe.h
+++ b/src/gallium/drivers/radeonsi/si_pipe.h
@@ -1549,6 +1549,7 @@ void si_resume_queries(struct si_context *sctx);
 void *si_create_copy_image_cs(struct si_context *sctx, bool src_is_1d_array, bool dst_is_1d_array);
 void *si_create_dcc_retile_cs(struct si_context *sctx, struct radeon_surf *surf);
 void *gfx9_create_clear_dcc_msaa_cs(struct si_context *sctx, struct si_texture *tex);
+void *si_create_passthrough_tcs(struct si_context *sctx);
 
 /* si_shaderlib_tgsi.c */
 void *si_get_blitter_vs(struct si_context *sctx, enum blitter_attrib_type type,
diff --git a/src/gallium/drivers/radeonsi/si_shaderlib_nir.c b/src/gallium/drivers/radeonsi/si_shaderlib_nir.c
index 9b9d0fd07585..fbbeea84a195 100644
--- a/src/gallium/drivers/radeonsi/si_shaderlib_nir.c
+++ b/src/gallium/drivers/radeonsi/si_shaderlib_nir.c
@@ -270,3 +270,82 @@ void *si_create_clear_buffer_rmw_cs(struct si_context *sctx)
    return create_shader_state(sctx, b.shader);
 }
 
+/* This is used when TCS is NULL in the VS->TCS->TES chain. In this case,
+ * VS passes its outputs to TES directly, so the fixed-function shader only
+ * has to write TESSOUTER and TESSINNER.
+ */
+void *si_create_passthrough_tcs(struct si_context *sctx)
+{
+   const nir_shader_compiler_options *options =
+      sctx->b.screen->get_compiler_options(sctx->b.screen, PIPE_SHADER_IR_NIR,
+                                           PIPE_SHADER_TESS_CTRL);
+
+   nir_builder b = nir_builder_init_simple_shader(MESA_SHADER_TESS_CTRL, options,
+                                                  "tcs passthrough");
+
+   unsigned num_inputs = 0;
+   unsigned num_outputs = 0;
+
+   nir_variable *in_inner =
+      nir_variable_create(b.shader, nir_var_system_value, glsl_vec_type(2),
+                          "tess inner default");
+   in_inner->data.location = SYSTEM_VALUE_TESS_LEVEL_INNER_DEFAULT;
+
+   nir_variable *out_inner =
+      nir_variable_create(b.shader, nir_var_shader_out, glsl_vec_type(2),
+                          "tess inner");
+   out_inner->data.location = VARYING_SLOT_TESS_LEVEL_INNER;
+   out_inner->data.driver_location = num_outputs++;
+
+   nir_ssa_def *inner = nir_load_var(&b, in_inner);
+   nir_store_var(&b, out_inner, inner, 0x3);
+
+   nir_variable *in_outer =
+      nir_variable_create(b.shader, nir_var_system_value, glsl_vec4_type(),
+                          "tess outer default");
+   in_outer->data.location = SYSTEM_VALUE_TESS_LEVEL_OUTER_DEFAULT;
+
+   nir_variable *out_outer =
+      nir_variable_create(b.shader, nir_var_shader_out, glsl_vec4_type(),
+                          "tess outer");
+   out_outer->data.location = VARYING_SLOT_TESS_LEVEL_OUTER;
+   out_outer->data.driver_location = num_outputs++;
+
+   nir_ssa_def *outer = nir_load_var(&b, in_outer);
+   nir_store_var(&b, out_outer, outer, 0xf);
+
+   nir_ssa_def *id = nir_load_invocation_id(&b);
+   struct si_shader_info *info = &sctx->shader.vs.cso->info;
+   for (unsigned i = 0; i < info->num_outputs; i++) {
+      const struct glsl_type *type;
+      unsigned semantic = info->output_semantic[i];
+      if (semantic < VARYING_SLOT_VAR31 && semantic != VARYING_SLOT_EDGE)
+         type = glsl_array_type(glsl_vec4_type(), 0, 0);
+      else if (semantic >= VARYING_SLOT_VAR0_16BIT)
+         type = glsl_array_type(glsl_vector_type(GLSL_TYPE_FLOAT16, 4), 0, 0);
+      else
+         continue;
+
+      char name[10];
+      snprintf(name, sizeof(name), "in_%u", i);
+      nir_variable *in = nir_variable_create(b.shader, nir_var_shader_in, type, name);
+      in->data.location = semantic;
+      in->data.driver_location = num_inputs++;
+
+      snprintf(name, sizeof(name), "out_%u", i);
+      nir_variable *out = nir_variable_create(b.shader, nir_var_shader_out, type, name);
+      out->data.location = semantic;
+      out->data.driver_location = num_outputs++;
+
+      /* no need to use copy_var to save a lower pass */
+      nir_ssa_def *value = nir_load_array_var(&b, in, id);
+      nir_store_array_var(&b, out, id, value, 0xf);
+   }
+
+   b.shader->num_inputs = num_inputs;
+   b.shader->num_outputs = num_outputs;
+
+   b.shader->info.tess.tcs_vertices_out = sctx->patch_vertices;
+
+   return create_shader_state(sctx, b.shader);
+}
-- 
GitLab


From 44cbac48103028c3bd3c41b07f9422f60e644378 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Fri, 20 May 2022 17:27:27 +0800
Subject: [PATCH 14/39] radeonsi: replace llvm based fixed tcs with nir

Create nir passthrough shader with explicit input/output and vertex
output count so that it can be handled by compiler same as user tcs.

The drawback is we create more si_shader_selector with different
input/output and vertex output count which was handled by compiler
backend before.

As fixed function tcs can be handled like user tcs, we don't need
the dedicated fixed_func_tcs_shader state either.

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/gallium/drivers/radeonsi/si_debug.c       |  10 +-
 src/gallium/drivers/radeonsi/si_pipe.c        |   9 +-
 src/gallium/drivers/radeonsi/si_pipe.h        |   5 +-
 src/gallium/drivers/radeonsi/si_shader.c      |   8 +-
 src/gallium/drivers/radeonsi/si_shader.h      |   1 -
 src/gallium/drivers/radeonsi/si_shader_llvm.c |   5 +-
 .../drivers/radeonsi/si_shader_llvm_tess.c    |  45 +----
 .../drivers/radeonsi/si_shaderlib_tgsi.c      |  27 ---
 .../drivers/radeonsi/si_state_draw.cpp        | 158 +++++++++++-------
 .../drivers/radeonsi/si_state_shaders.cpp     |  21 +--
 10 files changed, 117 insertions(+), 172 deletions(-)

diff --git a/src/gallium/drivers/radeonsi/si_debug.c b/src/gallium/drivers/radeonsi/si_debug.c
index 85f5667f2a76..d1deb09cca63 100644
--- a/src/gallium/drivers/radeonsi/si_debug.c
+++ b/src/gallium/drivers/radeonsi/si_debug.c
@@ -1036,19 +1036,13 @@ static void si_dump_debug_state(struct pipe_context *ctx, FILE *f, unsigned flag
 
 void si_log_draw_state(struct si_context *sctx, struct u_log_context *log)
 {
-   struct si_shader_ctx_state *tcs_shader;
-
    if (!log)
       return;
 
-   tcs_shader = &sctx->shader.tcs;
-   if (sctx->shader.tes.cso && !sctx->shader.tcs.cso)
-      tcs_shader = &sctx->fixed_func_tcs_shader;
-
    si_dump_framebuffer(sctx, log);
 
    si_dump_gfx_shader(sctx, &sctx->shader.vs, log);
-   si_dump_gfx_shader(sctx, tcs_shader, log);
+   si_dump_gfx_shader(sctx, &sctx->shader.tcs, log);
    si_dump_gfx_shader(sctx, &sctx->shader.tes, log);
    si_dump_gfx_shader(sctx, &sctx->shader.gs, log);
    si_dump_gfx_shader(sctx, &sctx->shader.ps, log);
@@ -1057,7 +1051,7 @@ void si_log_draw_state(struct si_context *sctx, struct u_log_context *log)
                            4, sctx->descriptors[SI_DESCS_INTERNAL].num_active_slots, si_identity,
                            log);
    si_dump_gfx_descriptors(sctx, &sctx->shader.vs, log);
-   si_dump_gfx_descriptors(sctx, tcs_shader, log);
+   si_dump_gfx_descriptors(sctx, &sctx->shader.tcs, log);
    si_dump_gfx_descriptors(sctx, &sctx->shader.tes, log);
    si_dump_gfx_descriptors(sctx, &sctx->shader.gs, log);
    si_dump_gfx_descriptors(sctx, &sctx->shader.ps, log);
diff --git a/src/gallium/drivers/radeonsi/si_pipe.c b/src/gallium/drivers/radeonsi/si_pipe.c
index 161f1a733202..c2de0c3e8980 100644
--- a/src/gallium/drivers/radeonsi/si_pipe.c
+++ b/src/gallium/drivers/radeonsi/si_pipe.c
@@ -228,8 +228,13 @@ static void si_destroy_context(struct pipe_context *context)
    for (i = 0; i < ARRAY_SIZE(sctx->vgt_shader_config); i++)
       si_pm4_free_state(sctx, sctx->vgt_shader_config[i], SI_STATE_IDX(vgt_shader_config));
 
-   if (sctx->fixed_func_tcs_shader.cso)
-      sctx->b.delete_tcs_state(&sctx->b, sctx->fixed_func_tcs_shader.cso);
+   if (sctx->fixed_func_tcs_shader_cache) {
+      hash_table_foreach(sctx->fixed_func_tcs_shader_cache, entry) {
+         sctx->b.delete_tcs_state(&sctx->b, entry->data);
+      }
+      _mesa_hash_table_destroy(sctx->fixed_func_tcs_shader_cache, NULL);
+   }
+
    if (sctx->custom_dsa_flush)
       sctx->b.delete_depth_stencil_alpha_state(&sctx->b, sctx->custom_dsa_flush);
    if (sctx->custom_blend_resolve)
diff --git a/src/gallium/drivers/radeonsi/si_pipe.h b/src/gallium/drivers/radeonsi/si_pipe.h
index ea6c176377d3..491be879e6a7 100644
--- a/src/gallium/drivers/radeonsi/si_pipe.h
+++ b/src/gallium/drivers/radeonsi/si_pipe.h
@@ -994,7 +994,7 @@ struct si_context {
    struct si_screen *screen;
    struct util_debug_callback debug;
    struct ac_llvm_compiler compiler; /* only non-threaded compilation */
-   struct si_shader_ctx_state fixed_func_tcs_shader;
+   struct hash_table *fixed_func_tcs_shader_cache;
    /* Offset 0: EOP flush number; Offset 4: GDS prim restart counter */
    struct si_resource *wait_mem_scratch;
    struct si_resource *wait_mem_scratch_tmz;
@@ -1075,6 +1075,8 @@ struct si_context {
       struct si_shader_ctx_state shaders[SI_NUM_GRAPHICS_SHADERS];
    };
    struct si_cs_shader_state cs_shader_state;
+   /* if current tcs set by user */
+   bool is_user_tcs;
 
    /* shader information */
    uint64_t ps_inputs_read_or_disabled;
@@ -1554,7 +1556,6 @@ void *si_create_passthrough_tcs(struct si_context *sctx);
 /* si_shaderlib_tgsi.c */
 void *si_get_blitter_vs(struct si_context *sctx, enum blitter_attrib_type type,
                         unsigned num_layers);
-void *si_create_fixed_func_tcs(struct si_context *sctx);
 void *si_create_dma_compute_shader(struct pipe_context *ctx, unsigned num_dwords_per_thread,
                                    bool dst_stream_cache_policy, bool is_copy);
 void *si_create_clear_buffer_rmw_cs(struct si_context *sctx);
diff --git a/src/gallium/drivers/radeonsi/si_shader.c b/src/gallium/drivers/radeonsi/si_shader.c
index 5a57ab4a1408..5d5b4a18f9b4 100644
--- a/src/gallium/drivers/radeonsi/si_shader.c
+++ b/src/gallium/drivers/radeonsi/si_shader.c
@@ -1238,8 +1238,6 @@ static void si_dump_shader_key(const struct si_shader *shader, FILE *f)
          si_dump_shader_key_vs(key, &key->ge.part.tcs.ls_prolog, "part.tcs.ls_prolog", f);
       }
       fprintf(f, "  part.tcs.epilog.prim_mode = %u\n", key->ge.part.tcs.epilog.prim_mode);
-      fprintf(f, "  mono.u.ff_tcs_inputs_to_copy = 0x%" PRIx64 "\n",
-              key->ge.mono.u.ff_tcs_inputs_to_copy);
       fprintf(f, "  opt.prefer_mono = %u\n", key->ge.opt.prefer_mono);
       fprintf(f, "  opt.same_patch_vertices = %u\n", key->ge.opt.same_patch_vertices);
       break;
@@ -2018,12 +2016,8 @@ void si_get_tcs_epilog_key(struct si_shader *shader, union si_shader_part_key *k
    key->tcs_epilog.wave32 = shader->wave_size == 32;
    key->tcs_epilog.states = shader->key.ge.part.tcs.epilog;
 
-   /* If output patches are wholly in one wave, we don't need a barrier.
-    * The fixed-func TCS doesn't set tcs_vertices_out, but it won't use a barrier
-    * anyway because tess levels are always defined in all invocations there.
-    */
+   /* If output patches are wholly in one wave, we don't need a barrier. */
    key->tcs_epilog.noop_s_barrier =
-      shader->selector->info.base.tess.tcs_vertices_out &&
       shader->wave_size % shader->selector->info.base.tess.tcs_vertices_out == 0;
 }
 
diff --git a/src/gallium/drivers/radeonsi/si_shader.h b/src/gallium/drivers/radeonsi/si_shader.h
index bff4f20be30b..2235f30c8b43 100644
--- a/src/gallium/drivers/radeonsi/si_shader.h
+++ b/src/gallium/drivers/radeonsi/si_shader.h
@@ -661,7 +661,6 @@ struct si_shader_key_ge {
       union si_vs_fix_fetch vs_fix_fetch[SI_MAX_ATTRIBS];
 
       union {
-         uint64_t ff_tcs_inputs_to_copy; /* fixed-func TCS only */
          /* When PS needs PrimID and GS is disabled. */
          unsigned vs_export_prim_id : 1;    /* VS and TES only */
          unsigned gs_tri_strip_adj_fix : 1; /* GS only */
diff --git a/src/gallium/drivers/radeonsi/si_shader_llvm.c b/src/gallium/drivers/radeonsi/si_shader_llvm.c
index c47327095c37..aeb6d02a4e77 100644
--- a/src/gallium/drivers/radeonsi/si_shader_llvm.c
+++ b/src/gallium/drivers/radeonsi/si_shader_llvm.c
@@ -1019,12 +1019,9 @@ bool si_llvm_translate_nir(struct si_shader_context *ctx, struct si_shader *shad
             /* If both input and output patches are wholly in one wave, we don't need a barrier.
              * That's true when both VS and TCS have the same number of patch vertices and
              * the wave size is a multiple of the number of patch vertices.
-             *
-             * The fixed-func TCS doesn't set tcs_vertices_out.
              */
             if (!shader->key.ge.opt.same_patch_vertices ||
-                (sel->info.base.tess.tcs_vertices_out &&
-                 ctx->ac.wave_size % sel->info.base.tess.tcs_vertices_out != 0))
+                ctx->ac.wave_size % sel->info.base.tess.tcs_vertices_out != 0)
                ac_build_s_barrier(&ctx->ac, ctx->stage);
          }
       } else if (ctx->stage == MESA_SHADER_GEOMETRY && !shader->key.ge.as_ngg) {
diff --git a/src/gallium/drivers/radeonsi/si_shader_llvm_tess.c b/src/gallium/drivers/radeonsi/si_shader_llvm_tess.c
index 24e1858e3a25..feace3b8db4e 100644
--- a/src/gallium/drivers/radeonsi/si_shader_llvm_tess.c
+++ b/src/gallium/drivers/radeonsi/si_shader_llvm_tess.c
@@ -71,9 +71,6 @@ static unsigned get_tcs_out_vertex_dw_stride_constant(struct si_shader_context *
 {
    assert(ctx->stage == MESA_SHADER_TESS_CTRL);
 
-   if (ctx->shader->key.ge.mono.u.ff_tcs_inputs_to_copy)
-      return util_last_bit64(ctx->shader->key.ge.mono.u.ff_tcs_inputs_to_copy) * 4;
-
    return util_last_bit64(ctx->shader->selector->info.outputs_written) * 4;
 }
 
@@ -86,9 +83,6 @@ static LLVMValueRef get_tcs_out_vertex_dw_stride(struct si_shader_context *ctx)
 
 static LLVMValueRef get_tcs_out_patch_stride(struct si_shader_context *ctx)
 {
-   if (ctx->shader->key.ge.mono.u.ff_tcs_inputs_to_copy)
-      return si_unpack_param(ctx, ctx->tcs_out_lds_layout, 0, 13);
-
    const struct si_shader_info *info = &ctx->shader->selector->info;
    unsigned tcs_out_vertices = info->base.tess.tcs_vertices_out;
    unsigned vertex_dw_stride = get_tcs_out_vertex_dw_stride_constant(ctx);
@@ -141,7 +135,7 @@ LLVMValueRef si_get_num_tcs_out_vertices(struct si_shader_context *ctx)
       ctx->shader->selector ? ctx->shader->selector->info.base.tess.tcs_vertices_out
                             : 0;
 
-   /* If !tcs_out_vertices, it's either the fixed-func TCS or the TCS epilog. */
+   /* If !tcs_out_vertices, it's the TCS epilog. */
    if (ctx->stage == MESA_SHADER_TESS_CTRL && tcs_out_vertices)
       return LLVMConstInt(ctx->ac.i32, tcs_out_vertices, 0);
 
@@ -550,41 +544,6 @@ static void si_nir_store_output_tcs(struct ac_shader_abi *abi,
    }
 }
 
-/**
- * Forward all outputs from the vertex shader to the TES. This is only used
- * for the fixed function TCS.
- */
-static void si_copy_tcs_inputs(struct si_shader_context *ctx)
-{
-   LLVMValueRef invocation_id, buffer, buffer_offset;
-   LLVMValueRef lds_vertex_stride, lds_base;
-   uint64_t inputs;
-
-   invocation_id = si_unpack_param(ctx, ctx->args.tcs_rel_ids, 8, 5);
-   buffer = get_tess_ring_descriptor(ctx, TESS_OFFCHIP_RING_TCS);
-   buffer_offset = ac_get_arg(&ctx->ac, ctx->args.tess_offchip_offset);
-
-   lds_vertex_stride = si_get_tcs_in_vertex_dw_stride(ctx);
-   lds_base = get_tcs_in_current_patch_offset(ctx);
-   lds_base = ac_build_imad(&ctx->ac, invocation_id, lds_vertex_stride, lds_base);
-
-   inputs = ctx->shader->key.ge.mono.u.ff_tcs_inputs_to_copy;
-   while (inputs) {
-      unsigned i = u_bit_scan64(&inputs);
-
-      LLVMValueRef lds_ptr =
-         LLVMBuildAdd(ctx->ac.builder, lds_base, LLVMConstInt(ctx->ac.i32, 4 * i, 0), "");
-
-      LLVMValueRef buffer_addr = get_tcs_tes_buffer_address(
-         ctx, get_rel_patch_id(ctx), invocation_id, LLVMConstInt(ctx->ac.i32, i, 0));
-
-      LLVMValueRef value = lshs_lds_load(ctx, ctx->ac.i32, ~0, lds_ptr);
-
-      ac_build_buffer_store_dword(&ctx->ac, buffer, value, NULL, buffer_addr, buffer_offset,
-                                  ac_glc);
-   }
-}
-
 static void si_write_tess_factors(struct si_shader_context *ctx, union si_shader_part_key *key,
                                   LLVMValueRef rel_patch_id, LLVMValueRef invocation_id,
                                   LLVMValueRef tcs_out_current_patch_data_offset,
@@ -751,8 +710,6 @@ void si_llvm_tcs_build_end(struct si_shader_context *ctx)
    LLVMBuilderRef builder = ctx->ac.builder;
    LLVMValueRef rel_patch_id, invocation_id, tf_lds_offset;
 
-   si_copy_tcs_inputs(ctx);
-
    rel_patch_id = get_rel_patch_id(ctx);
    invocation_id = si_unpack_param(ctx, ctx->args.tcs_rel_ids, 8, 5);
    tf_lds_offset = get_tcs_out_current_patch_data_offset(ctx);
diff --git a/src/gallium/drivers/radeonsi/si_shaderlib_tgsi.c b/src/gallium/drivers/radeonsi/si_shaderlib_tgsi.c
index 045ea934cf49..0cc53483213e 100644
--- a/src/gallium/drivers/radeonsi/si_shaderlib_tgsi.c
+++ b/src/gallium/drivers/radeonsi/si_shaderlib_tgsi.c
@@ -81,33 +81,6 @@ void *si_get_blitter_vs(struct si_context *sctx, enum blitter_attrib_type type,
    return *vs;
 }
 
-/**
- * This is used when TCS is NULL in the VS->TCS->TES chain. In this case,
- * VS passes its outputs to TES directly, so the fixed-function shader only
- * has to write TESSOUTER and TESSINNER.
- */
-void *si_create_fixed_func_tcs(struct si_context *sctx)
-{
-   struct ureg_src outer, inner;
-   struct ureg_dst tessouter, tessinner;
-   struct ureg_program *ureg = ureg_create(PIPE_SHADER_TESS_CTRL);
-
-   if (!ureg)
-      return NULL;
-
-   outer = ureg_DECL_system_value(ureg, TGSI_SEMANTIC_TESS_DEFAULT_OUTER_LEVEL, 0);
-   inner = ureg_DECL_system_value(ureg, TGSI_SEMANTIC_TESS_DEFAULT_INNER_LEVEL, 0);
-
-   tessouter = ureg_DECL_output(ureg, TGSI_SEMANTIC_TESSOUTER, 0);
-   tessinner = ureg_DECL_output(ureg, TGSI_SEMANTIC_TESSINNER, 0);
-
-   ureg_MOV(ureg, tessouter, outer);
-   ureg_MOV(ureg, tessinner, inner);
-   ureg_END(ureg);
-
-   return ureg_create_shader_and_destroy(ureg, &sctx->b);
-}
-
 /* Create a compute shader implementing clear_buffer or copy_buffer. */
 void *si_create_dma_compute_shader(struct pipe_context *ctx, unsigned num_dwords_per_thread,
                                    bool dst_stream_cache_policy, bool is_copy)
diff --git a/src/gallium/drivers/radeonsi/si_state_draw.cpp b/src/gallium/drivers/radeonsi/si_state_draw.cpp
index 9103cacc1f43..bb4ba3c291cf 100644
--- a/src/gallium/drivers/radeonsi/si_state_draw.cpp
+++ b/src/gallium/drivers/radeonsi/si_state_draw.cpp
@@ -107,6 +107,53 @@ static void si_emit_spi_map(struct si_context *sctx)
    radeon_end_update_context_roll(sctx);
 }
 
+struct si_fixed_func_tcs_shader_key {
+   uint64_t outputs_written;
+   uint8_t vertices_out;
+};
+
+static uint32_t si_fixed_func_tcs_shader_key_hash(const void *key)
+{
+   return _mesa_hash_data(key, sizeof(struct si_fixed_func_tcs_shader_key));
+}
+
+static bool si_fixed_func_tcs_shader_key_equals(const void *a, const void *b)
+{
+   return memcmp(a, b, sizeof(struct si_fixed_func_tcs_shader_key)) == 0;
+}
+
+static bool si_set_tcs_to_fixed_func_shader(struct si_context *sctx)
+{
+   if (!sctx->fixed_func_tcs_shader_cache) {
+      sctx->fixed_func_tcs_shader_cache = _mesa_hash_table_create(
+         NULL, si_fixed_func_tcs_shader_key_hash,
+         si_fixed_func_tcs_shader_key_equals);
+   }
+
+   struct si_fixed_func_tcs_shader_key key;
+   key.outputs_written = sctx->shader.vs.cso->info.outputs_written;
+   key.vertices_out = sctx->patch_vertices;
+
+   struct hash_entry *entry = _mesa_hash_table_search(
+      sctx->fixed_func_tcs_shader_cache, &key);
+
+   struct si_shader_selector *tcs;
+   if (entry)
+      tcs = (struct si_shader_selector *)entry->data;
+   else {
+      tcs = (struct si_shader_selector *)si_create_passthrough_tcs(sctx);
+      if (!tcs)
+         return false;
+      _mesa_hash_table_insert(sctx->fixed_func_tcs_shader_cache, &key, (void *)tcs);
+   }
+
+   sctx->shader.tcs.cso = tcs;
+   sctx->shader.tcs.key.ge.part.tcs.epilog.invoc0_tess_factors_are_def =
+      tcs->info.tessfactors_are_def_in_all_invocs;
+
+   return true;
+}
+
 template <amd_gfx_level GFX_VERSION, si_has_tess HAS_TESS, si_has_gs HAS_GS, si_has_ngg NGG>
 static bool si_update_shaders(struct si_context *sctx)
 {
@@ -126,28 +173,16 @@ static bool si_update_shaders(struct si_context *sctx)
             return false;
       }
 
-      if (sctx->shader.tcs.cso) {
-         r = si_shader_select(ctx, &sctx->shader.tcs);
-         if (r)
-            return false;
-         si_pm4_bind_state(sctx, hs, sctx->shader.tcs.current);
-      } else {
-         if (!sctx->fixed_func_tcs_shader.cso) {
-            sctx->fixed_func_tcs_shader.cso =
-               (struct si_shader_selector*)si_create_fixed_func_tcs(sctx);
-            if (!sctx->fixed_func_tcs_shader.cso)
-               return false;
-
-            sctx->fixed_func_tcs_shader.key.ge.part.tcs.epilog.invoc0_tess_factors_are_def =
-               sctx->fixed_func_tcs_shader.cso->info.tessfactors_are_def_in_all_invocs;
-         }
-
-         r = si_shader_select(ctx, &sctx->fixed_func_tcs_shader);
-         if (r)
+      if (!sctx->is_user_tcs) {
+         if (!si_set_tcs_to_fixed_func_shader(sctx))
             return false;
-         si_pm4_bind_state(sctx, hs, sctx->fixed_func_tcs_shader.current);
       }
 
+      r = si_shader_select(ctx, &sctx->shader.tcs);
+      if (r)
+         return false;
+      si_pm4_bind_state(sctx, hs, sctx->shader.tcs.current);
+
       if (!HAS_GS || GFX_VERSION <= GFX8) {
          r = si_shader_select(ctx, &sctx->shader.tes);
          if (r)
@@ -164,6 +199,10 @@ static bool si_update_shaders(struct si_context *sctx)
          }
       }
    } else {
+      /* Reset TCS to clear fixed function shader. */
+      sctx->shader.tcs.cso = NULL;
+      sctx->shader.tcs.current = NULL;
+
       if (GFX_VERSION <= GFX8) {
          si_pm4_bind_state(sctx, ls, NULL);
          sctx->prefetch_L2_mask &= ~SI_PREFETCH_LS;
@@ -618,10 +657,7 @@ static void si_emit_derived_tess_state(struct si_context *sctx, unsigned *num_pa
 {
    struct si_shader *ls_current;
    struct si_shader_selector *ls;
-   /* The TES pointer will only be used for sctx->last_tcs.
-    * It would be wrong to think that TCS = TES. */
-   struct si_shader_selector *tcs =
-      sctx->shader.tcs.cso ? sctx->shader.tcs.cso : sctx->shader.tes.cso;
+   struct si_shader_selector *tcs = sctx->shader.tcs.cso;
    unsigned tess_uses_primid = sctx->ia_multi_vgt_param_key.u.tess_uses_prim_id;
    bool has_primid_instancing_bug = sctx->gfx_level == GFX6 && sctx->screen->info.max_se == 1;
    unsigned tes_sh_base = sctx->shader_pointers.sh_base[PIPE_SHADER_TESS_EVAL];
@@ -629,11 +665,7 @@ static void si_emit_derived_tess_state(struct si_context *sctx, unsigned *num_pa
 
    /* Since GFX9 has merged LS-HS in the TCS state, set LS = TCS. */
    if (sctx->gfx_level >= GFX9) {
-      if (sctx->shader.tcs.cso)
-         ls_current = sctx->shader.tcs.current;
-      else
-         ls_current = sctx->fixed_func_tcs_shader.current;
-
+      ls_current = sctx->shader.tcs.current;
       ls = ls_current->key.ge.part.tcs.ls;
    } else {
       ls_current = sctx->shader.vs.current;
@@ -655,19 +687,9 @@ static void si_emit_derived_tess_state(struct si_context *sctx, unsigned *num_pa
 
    /* This calculates how shader inputs and outputs among VS, TCS, and TES
     * are laid out in LDS. */
-   unsigned num_tcs_inputs = util_last_bit64(ls->info.outputs_written);
-   unsigned num_tcs_output_cp, num_tcs_outputs, num_tcs_patch_outputs;
-
-   if (sctx->shader.tcs.cso) {
-      num_tcs_outputs = util_last_bit64(tcs->info.outputs_written);
-      num_tcs_output_cp = tcs->info.base.tess.tcs_vertices_out;
-      num_tcs_patch_outputs = util_last_bit64(tcs->info.patch_outputs_written);
-   } else {
-      /* No TCS. Route varyings from LS to TES. */
-      num_tcs_outputs = num_tcs_inputs;
-      num_tcs_output_cp = num_tcs_input_cp;
-      num_tcs_patch_outputs = 2; /* TESSINNER + TESSOUTER */
-   }
+   unsigned num_tcs_outputs = util_last_bit64(tcs->info.outputs_written);
+   unsigned num_tcs_output_cp = tcs->info.base.tess.tcs_vertices_out;
+   unsigned num_tcs_patch_outputs = util_last_bit64(tcs->info.patch_outputs_written);
 
    unsigned input_vertex_size = ls->info.lshs_vertex_stride;
    unsigned output_vertex_size = num_tcs_outputs * 16;
@@ -2218,34 +2240,44 @@ static void si_draw(struct pipe_context *ctx,
    si_need_gfx_cs_space(sctx, num_draws);
 
    if (HAS_TESS) {
-      struct si_shader_selector *tcs = sctx->shader.tcs.cso;
+      if (sctx->is_user_tcs) {
+         struct si_shader_selector *tcs = sctx->shader.tcs.cso;
 
-      /* The rarely occuring tcs == NULL case is not optimized. */
-      bool same_patch_vertices =
-         GFX_VERSION >= GFX9 &&
-         tcs && sctx->patch_vertices == tcs->info.base.tess.tcs_vertices_out;
+         bool same_patch_vertices =
+            GFX_VERSION >= GFX9 &&
+            sctx->patch_vertices == tcs->info.base.tess.tcs_vertices_out;
 
-      if (sctx->shader.tcs.key.ge.opt.same_patch_vertices != same_patch_vertices) {
-         sctx->shader.tcs.key.ge.opt.same_patch_vertices = same_patch_vertices;
-         sctx->do_update_shaders = true;
-      }
+         if (sctx->shader.tcs.key.ge.opt.same_patch_vertices != same_patch_vertices) {
+            sctx->shader.tcs.key.ge.opt.same_patch_vertices = same_patch_vertices;
+            sctx->do_update_shaders = true;
+         }
 
-      if (GFX_VERSION == GFX9 && sctx->screen->info.has_ls_vgpr_init_bug) {
-         /* Determine whether the LS VGPR fix should be applied.
-          *
-          * It is only required when num input CPs > num output CPs,
-          * which cannot happen with the fixed function TCS. We should
-          * also update this bit when switching from TCS to fixed
-          * function TCS.
+         if (GFX_VERSION == GFX9 && sctx->screen->info.has_ls_vgpr_init_bug) {
+            /* Determine whether the LS VGPR fix should be applied.
+             *
+             * It is only required when num input CPs > num output CPs,
+             * which cannot happen with the fixed function TCS.
+             */
+            bool ls_vgpr_fix =
+               sctx->patch_vertices > tcs->info.base.tess.tcs_vertices_out;
+
+            if (ls_vgpr_fix != sctx->shader.tcs.key.ge.part.tcs.ls_prolog.ls_vgpr_fix) {
+               sctx->shader.tcs.key.ge.part.tcs.ls_prolog.ls_vgpr_fix = ls_vgpr_fix;
+               sctx->do_update_shaders = true;
+            }
+         }
+      } else {
+         /* These fields are static for fixed function TCS. So no need to set
+          * do_update_shaders between fixed-TCS draws. As fixed-TCS to user-TCS
+          * or opposite, do_update_shaders should already be set by bind state.
           */
-         bool ls_vgpr_fix =
-            tcs && sctx->patch_vertices > tcs->info.base.tess.tcs_vertices_out;
+         sctx->shader.tcs.key.ge.opt.same_patch_vertices = GFX_VERSION >= GFX9;
+         sctx->shader.tcs.key.ge.part.tcs.ls_prolog.ls_vgpr_fix = false;
 
-         if (ls_vgpr_fix != sctx->shader.tcs.key.ge.part.tcs.ls_prolog.ls_vgpr_fix) {
-            sctx->shader.tcs.key.ge.part.tcs.ls_prolog.ls_vgpr_fix = ls_vgpr_fix;
-            sctx->fixed_func_tcs_shader.key.ge.part.tcs.ls_prolog.ls_vgpr_fix = ls_vgpr_fix;
+         /* User may only change patch vertices, needs to update fixed func TCS. */
+         if (sctx->shader.tcs.cso &&
+             sctx->shader.tcs.cso->info.base.tess.tcs_vertices_out != sctx->patch_vertices)
             sctx->do_update_shaders = true;
-         }
       }
    }
 
diff --git a/src/gallium/drivers/radeonsi/si_state_shaders.cpp b/src/gallium/drivers/radeonsi/si_state_shaders.cpp
index 85c0bca4740a..e4f487d62abd 100644
--- a/src/gallium/drivers/radeonsi/si_state_shaders.cpp
+++ b/src/gallium/drivers/radeonsi/si_state_shaders.cpp
@@ -3304,7 +3304,6 @@ static void si_bind_vs_shader(struct pipe_context *ctx, void *state)
    sctx->shader.vs.current = (sel && sel->variants_count) ? sel->variants[0] : NULL;
    sctx->num_vs_blit_sgprs = sel ? sel->info.base.vs.blit_sgprs_amd : 0;
    sctx->vs_uses_draw_id = sel ? sel->info.uses_drawid : false;
-   sctx->fixed_func_tcs_shader.key.ge.mono.u.ff_tcs_inputs_to_copy = sel ? sel->info.outputs_written : 0;
 
    if (si_update_ngg(sctx))
       si_shader_change_notify(sctx);
@@ -3417,6 +3416,11 @@ static void si_bind_tcs_shader(struct pipe_context *ctx, void *state)
    struct si_shader_selector *sel = (struct si_shader_selector*)state;
    bool enable_changed = !!sctx->shader.tcs.cso != !!sel;
 
+   /* Note it could happen that user shader sel is same as fixed function shader,
+    * so we should update this field even sctx->shader.tcs.cso == sel.
+    */
+   sctx->is_user_tcs = !!sel;
+
    if (sctx->shader.tcs.cso == sel)
       return;
 
@@ -3449,11 +3453,9 @@ static void si_bind_tes_shader(struct pipe_context *ctx, void *state)
    si_update_tess_uses_prim_id(sctx);
 
    sctx->shader.tcs.key.ge.part.tcs.epilog.prim_mode =
-   sctx->fixed_func_tcs_shader.key.ge.part.tcs.epilog.prim_mode =
       sel ? sel->info.base.tess._primitive_mode : 0;
 
    sctx->shader.tcs.key.ge.part.tcs.epilog.tes_reads_tess_factors =
-   sctx->fixed_func_tcs_shader.key.ge.part.tcs.epilog.tes_reads_tess_factors =
       sel ? sel->info.reads_tess_factors : 0;
 
    si_update_common_shader_state(sctx, sel, PIPE_SHADER_TESS_EVAL);
@@ -3923,17 +3925,8 @@ static int si_update_scratch_buffer(struct si_context *sctx, struct si_shader *s
    return 1;
 }
 
-static struct si_shader *si_get_tcs_current(struct si_context *sctx)
-{
-   if (!sctx->shader.tes.cso)
-      return NULL; /* tessellation disabled */
-
-   return sctx->shader.tcs.cso ? sctx->shader.tcs.current : sctx->fixed_func_tcs_shader.current;
-}
-
 static bool si_update_scratch_relocs(struct si_context *sctx)
 {
-   struct si_shader *tcs = si_get_tcs_current(sctx);
    int r;
 
    /* Update the shaders, so that they are using the latest scratch.
@@ -3953,11 +3946,11 @@ static bool si_update_scratch_relocs(struct si_context *sctx)
    if (r == 1)
       si_pm4_bind_state(sctx, gs, sctx->shader.gs.current);
 
-   r = si_update_scratch_buffer(sctx, tcs);
+   r = si_update_scratch_buffer(sctx, sctx->shader.tcs.current);
    if (r < 0)
       return false;
    if (r == 1)
-      si_pm4_bind_state(sctx, hs, tcs);
+      si_pm4_bind_state(sctx, hs, sctx->shader.tcs.current);
 
    /* VS can be bound as LS, ES, or VS. */
    r = si_update_scratch_buffer(sctx, sctx->shader.vs.current);
-- 
GitLab


From 9da5485198c8e18fb71a071b784edbd3f9b3e68c Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Mon, 23 May 2022 14:42:06 +0800
Subject: [PATCH 15/39] radeonsi: implement
 nir_intrinsic_load_tcs_num_patches_amd
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Used by ac_nir_lower_tess_io_to_mem.c.

Reviewed-by: Timur Kristóf <timur.kristof@gmail.com>
Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/amd/llvm/ac_nir_to_llvm.c                 | 1 +
 src/gallium/drivers/radeonsi/si_shader_llvm.c | 5 +++++
 2 files changed, 6 insertions(+)

diff --git a/src/amd/llvm/ac_nir_to_llvm.c b/src/amd/llvm/ac_nir_to_llvm.c
index f45b71b19417..ecfc71b07285 100644
--- a/src/amd/llvm/ac_nir_to_llvm.c
+++ b/src/amd/llvm/ac_nir_to_llvm.c
@@ -3620,6 +3620,7 @@ static void visit_intrinsic(struct ac_nir_context *ctx, nir_intrinsic_instr *ins
    case nir_intrinsic_load_ring_tess_offchip_amd:
    case nir_intrinsic_load_ring_esgs_amd:
    case nir_intrinsic_load_lshs_vertex_stride_amd:
+   case nir_intrinsic_load_tcs_num_patches_amd:
       result = ctx->abi->intrinsic_load(ctx->abi, instr->intrinsic);
       break;
    case nir_intrinsic_load_vertex_id:
diff --git a/src/gallium/drivers/radeonsi/si_shader_llvm.c b/src/gallium/drivers/radeonsi/si_shader_llvm.c
index aeb6d02a4e77..e76f06eca879 100644
--- a/src/gallium/drivers/radeonsi/si_shader_llvm.c
+++ b/src/gallium/drivers/radeonsi/si_shader_llvm.c
@@ -776,6 +776,11 @@ static LLVMValueRef si_llvm_load_intrinsic(struct ac_shader_abi *abi, nir_intrin
       return LLVMBuildShl(ctx->ac.builder, si_get_tcs_in_vertex_dw_stride(ctx),
                           LLVMConstInt(ctx->ac.i32, 2, 0), "");
 
+   case nir_intrinsic_load_tcs_num_patches_amd:
+      return LLVMBuildAdd(ctx->ac.builder,
+                          si_unpack_param(ctx, ctx->tcs_offchip_layout, 0, 6),
+                          ctx->ac.i32_1, "");
+
    default:
       return NULL;
    }
-- 
GitLab


From 636508d47c995defc7d39769b44e67cd79495d2e Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Mon, 23 May 2022 16:25:15 +0800
Subject: [PATCH 16/39] amd: remove unused parameter in tes input lower
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Reviewed-by: Timur Kristóf <timur.kristof@gmail.com>
Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/amd/common/ac_nir.h                      | 3 +--
 src/amd/common/ac_nir_lower_tess_io_to_mem.c | 4 +---
 src/amd/vulkan/radv_shader.c                 | 3 +--
 3 files changed, 3 insertions(+), 7 deletions(-)

diff --git a/src/amd/common/ac_nir.h b/src/amd/common/ac_nir.h
index 8920e9855179..8e0659a44abb 100644
--- a/src/amd/common/ac_nir.h
+++ b/src/amd/common/ac_nir.h
@@ -94,8 +94,7 @@ ac_nir_lower_hs_outputs_to_mem(nir_shader *shader,
 void
 ac_nir_lower_tes_inputs_to_mem(nir_shader *shader,
                                ac_nir_map_io_driver_location map,
-                               unsigned num_reserved_tcs_outputs,
-                               unsigned num_reserved_tcs_patch_outputs);
+                               unsigned num_reserved_tcs_outputs);
 
 void
 ac_nir_lower_es_outputs_to_mem(nir_shader *shader,
diff --git a/src/amd/common/ac_nir_lower_tess_io_to_mem.c b/src/amd/common/ac_nir_lower_tess_io_to_mem.c
index bb886f4c38c0..6d72f83faa0b 100644
--- a/src/amd/common/ac_nir_lower_tess_io_to_mem.c
+++ b/src/amd/common/ac_nir_lower_tess_io_to_mem.c
@@ -725,14 +725,12 @@ ac_nir_lower_hs_outputs_to_mem(nir_shader *shader,
 void
 ac_nir_lower_tes_inputs_to_mem(nir_shader *shader,
                                ac_nir_map_io_driver_location map,
-                               unsigned num_reserved_tcs_outputs,
-                               unsigned num_reserved_tcs_patch_outputs)
+                               unsigned num_reserved_tcs_outputs)
 {
    assert(shader->info.stage == MESA_SHADER_TESS_EVAL);
 
    lower_tess_io_state state = {
       .tcs_num_reserved_outputs = num_reserved_tcs_outputs,
-      .tcs_num_reserved_patch_outputs = num_reserved_tcs_patch_outputs,
       .map_io = map,
    };
 
diff --git a/src/amd/vulkan/radv_shader.c b/src/amd/vulkan/radv_shader.c
index ce7eca94b4dc..98664a7858d9 100644
--- a/src/amd/vulkan/radv_shader.c
+++ b/src/amd/vulkan/radv_shader.c
@@ -1087,8 +1087,7 @@ radv_lower_io_to_mem(struct radv_device *device, struct radv_pipeline_stage *sta
 
       return true;
    } else if (nir->info.stage == MESA_SHADER_TESS_EVAL) {
-      NIR_PASS_V(nir, ac_nir_lower_tes_inputs_to_mem, NULL, info->tes.num_linked_inputs,
-                 info->tes.num_linked_patch_inputs);
+      NIR_PASS_V(nir, ac_nir_lower_tes_inputs_to_mem, NULL, info->tes.num_linked_inputs);
 
       if (info->tes.as_es) {
          NIR_PASS_V(nir, ac_nir_lower_es_outputs_to_mem, NULL,
-- 
GitLab


From 35d04b2d069e785b36cdab0aab53b1ec71295b7d Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Mon, 23 May 2022 17:23:57 +0800
Subject: [PATCH 17/39] amd: add
 nir_intrinsic_load_hs_out_patch_data_offset_amd
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Also add radv and radeonsi implementation. Will be used in tess lowering.

Reviewed-by: Timur Kristóf <timur.kristof@gmail.com>
Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/amd/llvm/ac_nir_to_llvm.c                 |  1 +
 src/amd/vulkan/radv_nir_lower_abi.c           | 12 +++++++++++-
 src/compiler/nir/nir_divergence_analysis.c    |  1 +
 src/compiler/nir/nir_intrinsics.py            |  3 +++
 src/gallium/drivers/radeonsi/si_shader_llvm.c |  3 +++
 5 files changed, 19 insertions(+), 1 deletion(-)

diff --git a/src/amd/llvm/ac_nir_to_llvm.c b/src/amd/llvm/ac_nir_to_llvm.c
index ecfc71b07285..dde31808ba8e 100644
--- a/src/amd/llvm/ac_nir_to_llvm.c
+++ b/src/amd/llvm/ac_nir_to_llvm.c
@@ -3621,6 +3621,7 @@ static void visit_intrinsic(struct ac_nir_context *ctx, nir_intrinsic_instr *ins
    case nir_intrinsic_load_ring_esgs_amd:
    case nir_intrinsic_load_lshs_vertex_stride_amd:
    case nir_intrinsic_load_tcs_num_patches_amd:
+   case nir_intrinsic_load_hs_out_patch_data_offset_amd:
       result = ctx->abi->intrinsic_load(ctx->abi, instr->intrinsic);
       break;
    case nir_intrinsic_load_vertex_id:
diff --git a/src/amd/vulkan/radv_nir_lower_abi.c b/src/amd/vulkan/radv_nir_lower_abi.c
index 0570a0f1d889..a7d6cfd57a59 100644
--- a/src/amd/vulkan/radv_nir_lower_abi.c
+++ b/src/amd/vulkan/radv_nir_lower_abi.c
@@ -189,6 +189,15 @@ lower_abi_instr(nir_builder *b, nir_instr *instr, void *state)
       return nir_imm_int(b, io_num * 16);
    }
 
+   case nir_intrinsic_load_hs_out_patch_data_offset_amd: {
+      unsigned num_patchs = s->info->num_tess_patches;
+      unsigned out_vertices_per_patch = b->shader->info.tess.tcs_vertices_out;
+      unsigned num_tcs_outputs = stage == MESA_SHADER_TESS_CTRL ?
+         s->info->tcs.num_linked_outputs : s->info->tes.num_linked_inputs;
+      int per_vertex_output_patch_size = out_vertices_per_patch * num_tcs_outputs * 16u;
+      return nir_imm_int(b, num_patchs * per_vertex_output_patch_size);
+   }
+
    default:
       unreachable("invalid NIR RADV ABI intrinsic.");
    }
@@ -233,7 +242,8 @@ filter_abi_instr(const nir_instr *instr,
           intrin->intrinsic == nir_intrinsic_load_task_ring_entry_amd ||
           intrin->intrinsic == nir_intrinsic_load_task_ib_addr ||
           intrin->intrinsic == nir_intrinsic_load_task_ib_stride ||
-          intrin->intrinsic == nir_intrinsic_load_lshs_vertex_stride_amd;
+          intrin->intrinsic == nir_intrinsic_load_lshs_vertex_stride_amd ||
+          intrin->intrinsic == nir_intrinsic_load_hs_out_patch_data_offset_amd;
 }
 
 void
diff --git a/src/compiler/nir/nir_divergence_analysis.c b/src/compiler/nir/nir_divergence_analysis.c
index 60fb38c56b22..94b6e9482f28 100644
--- a/src/compiler/nir/nir_divergence_analysis.c
+++ b/src/compiler/nir/nir_divergence_analysis.c
@@ -175,6 +175,7 @@ visit_intrinsic(nir_shader *shader, nir_intrinsic_instr *instr)
    case nir_intrinsic_load_mesh_inline_data_intel:
    case nir_intrinsic_load_ray_num_dss_rt_stacks_intel:
    case nir_intrinsic_load_lshs_vertex_stride_amd:
+   case nir_intrinsic_load_hs_out_patch_data_offset_amd:
       is_divergent = false;
       break;
 
diff --git a/src/compiler/nir/nir_intrinsics.py b/src/compiler/nir/nir_intrinsics.py
index 02d49a279657..40d0f8bdc2a4 100644
--- a/src/compiler/nir/nir_intrinsics.py
+++ b/src/compiler/nir/nir_intrinsics.py
@@ -1394,6 +1394,9 @@ intrinsic("store_shared2_amd", [2, 1], indices=[OFFSET0, OFFSET1, ST64])
 # Vertex stride in LS-HS buffer
 system_value("lshs_vertex_stride_amd", 1)
 
+# Per patch data offset in HS VRAM output buffer
+system_value("hs_out_patch_data_offset_amd", 1)
+
 # V3D-specific instrinc for tile buffer color reads.
 #
 # The hardware requires that we read the samples and components of a pixel
diff --git a/src/gallium/drivers/radeonsi/si_shader_llvm.c b/src/gallium/drivers/radeonsi/si_shader_llvm.c
index e76f06eca879..1e67292c2482 100644
--- a/src/gallium/drivers/radeonsi/si_shader_llvm.c
+++ b/src/gallium/drivers/radeonsi/si_shader_llvm.c
@@ -781,6 +781,9 @@ static LLVMValueRef si_llvm_load_intrinsic(struct ac_shader_abi *abi, nir_intrin
                           si_unpack_param(ctx, ctx->tcs_offchip_layout, 0, 6),
                           ctx->ac.i32_1, "");
 
+   case nir_intrinsic_load_hs_out_patch_data_offset_amd:
+      return si_unpack_param(ctx, ctx->tcs_offchip_layout, 11, 21);
+
    default:
       return NULL;
    }
-- 
GitLab


From be6dcc04a8b0b910896bb321ecef9f9c843c983e Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Mon, 23 May 2022 17:26:00 +0800
Subject: [PATCH 18/39] amd: use
 nir_intrinsic_load_hs_out_patch_data_offset_amd in tess lower
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

radeonsi load this from SGPR arg, can't use static value because TCS output
and TES input may not match (TCS output is not a key for TES) and
determined in runtime.

Reviewed-by: Timur Kristóf <timur.kristof@gmail.com>
Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/amd/common/ac_nir.h                      |  3 +--
 src/amd/common/ac_nir_lower_tess_io_to_mem.c | 13 +++----------
 src/amd/vulkan/radv_shader.c                 |  2 +-
 3 files changed, 5 insertions(+), 13 deletions(-)

diff --git a/src/amd/common/ac_nir.h b/src/amd/common/ac_nir.h
index 8e0659a44abb..639ef7a67fb1 100644
--- a/src/amd/common/ac_nir.h
+++ b/src/amd/common/ac_nir.h
@@ -93,8 +93,7 @@ ac_nir_lower_hs_outputs_to_mem(nir_shader *shader,
 
 void
 ac_nir_lower_tes_inputs_to_mem(nir_shader *shader,
-                               ac_nir_map_io_driver_location map,
-                               unsigned num_reserved_tcs_outputs);
+                               ac_nir_map_io_driver_location map);
 
 void
 ac_nir_lower_es_outputs_to_mem(nir_shader *shader,
diff --git a/src/amd/common/ac_nir_lower_tess_io_to_mem.c b/src/amd/common/ac_nir_lower_tess_io_to_mem.c
index 6d72f83faa0b..f3c3fc2ec1f0 100644
--- a/src/amd/common/ac_nir_lower_tess_io_to_mem.c
+++ b/src/amd/common/ac_nir_lower_tess_io_to_mem.c
@@ -107,7 +107,7 @@
  * attr 1 of patch 0 vertex 2
  * ...
  * ...
- * per-patch attr 0 of patch 0
+ * per-patch attr 0 of patch 0  <─── hs_out_patch_data_offset_amd
  * per-patch attr 0 of patch 1
  * per-patch attr 0 of patch 2  <─── hs_per_patch_output_vmem_offset (attribute slot = 0, rel_patch_id = 2)
  * ...
@@ -373,13 +373,8 @@ hs_per_patch_output_vmem_offset(nir_builder *b,
                                 nir_intrinsic_instr *intrin,
                                 unsigned const_base_offset)
 {
-   nir_ssa_def *out_vertices_per_patch = b->shader->info.stage == MESA_SHADER_TESS_CTRL
-                                         ? nir_imm_int(b, b->shader->info.tess.tcs_vertices_out)
-                                         : nir_load_patch_vertices_in(b);
-
    nir_ssa_def *tcs_num_patches = nir_load_tcs_num_patches_amd(b);
-   nir_ssa_def *per_vertex_output_patch_size = nir_imul_imm(b, out_vertices_per_patch, st->tcs_num_reserved_outputs * 16u);
-   nir_ssa_def *per_patch_data_offset = nir_imul(b, tcs_num_patches, per_vertex_output_patch_size);
+   nir_ssa_def *per_patch_data_offset = nir_load_hs_out_patch_data_offset_amd(b);
 
    nir_ssa_def * off = intrin
                     ? ac_nir_calc_io_offset(b, intrin, nir_imul_imm(b, tcs_num_patches, 16u), 4u, st->map_io)
@@ -724,13 +719,11 @@ ac_nir_lower_hs_outputs_to_mem(nir_shader *shader,
 
 void
 ac_nir_lower_tes_inputs_to_mem(nir_shader *shader,
-                               ac_nir_map_io_driver_location map,
-                               unsigned num_reserved_tcs_outputs)
+                               ac_nir_map_io_driver_location map)
 {
    assert(shader->info.stage == MESA_SHADER_TESS_EVAL);
 
    lower_tess_io_state state = {
-      .tcs_num_reserved_outputs = num_reserved_tcs_outputs,
       .map_io = map,
    };
 
diff --git a/src/amd/vulkan/radv_shader.c b/src/amd/vulkan/radv_shader.c
index 98664a7858d9..9042d9091bf6 100644
--- a/src/amd/vulkan/radv_shader.c
+++ b/src/amd/vulkan/radv_shader.c
@@ -1087,7 +1087,7 @@ radv_lower_io_to_mem(struct radv_device *device, struct radv_pipeline_stage *sta
 
       return true;
    } else if (nir->info.stage == MESA_SHADER_TESS_EVAL) {
-      NIR_PASS_V(nir, ac_nir_lower_tes_inputs_to_mem, NULL, info->tes.num_linked_inputs);
+      NIR_PASS_V(nir, ac_nir_lower_tes_inputs_to_mem, NULL);
 
       if (info->tes.as_es) {
          NIR_PASS_V(nir, ac_nir_lower_es_outputs_to_mem, NULL,
-- 
GitLab


From 33c0fe8bf2e69ee0652efe6afeffad40d6350841 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Mon, 23 May 2022 20:27:55 +0800
Subject: [PATCH 19/39] amd: add pass_tessfactors_by_reg param to hs output
 lower
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

radeonsi won't emit tess factor in the lower pass, need to keep
the output for llvm backend to pass it as parameter. This is used
by radeonsi for an optimization to save LDS write.

Reviewed-by: Timur Kristóf <timur.kristof@gmail.com>
Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/amd/common/ac_nir.h                      |  1 +
 src/amd/common/ac_nir_lower_tess_io_to_mem.c | 22 ++++++++++++++++----
 src/amd/vulkan/radv_shader.c                 |  2 +-
 3 files changed, 20 insertions(+), 5 deletions(-)

diff --git a/src/amd/common/ac_nir.h b/src/amd/common/ac_nir.h
index 639ef7a67fb1..2510b659c2ed 100644
--- a/src/amd/common/ac_nir.h
+++ b/src/amd/common/ac_nir.h
@@ -89,6 +89,7 @@ ac_nir_lower_hs_outputs_to_mem(nir_shader *shader,
                                uint64_t tes_patch_inputs_read,
                                unsigned num_reserved_tcs_outputs,
                                unsigned num_reserved_tcs_patch_outputs,
+                               bool pass_tessfactors_by_reg,
                                bool emit_tess_factor_write);
 
 void
diff --git a/src/amd/common/ac_nir_lower_tess_io_to_mem.c b/src/amd/common/ac_nir_lower_tess_io_to_mem.c
index f3c3fc2ec1f0..0da9cdefb9c6 100644
--- a/src/amd/common/ac_nir_lower_tess_io_to_mem.c
+++ b/src/amd/common/ac_nir_lower_tess_io_to_mem.c
@@ -154,6 +154,11 @@ typedef struct {
     * subgroup that reads them.
     */
    bool tcs_out_patch_fits_subgroup;
+
+   /* Set if all invocations will write to all tess factors, so tess factors
+    * can be passed by register.
+    */
+   bool tcs_pass_tessfactors_by_reg;
 } lower_tess_io_state;
 
 static bool
@@ -402,7 +407,7 @@ lower_hs_per_vertex_input_load(nir_builder *b,
                           .align_mul = 16u, .align_offset = (nir_intrinsic_component(intrin) * 4u) % 16u);
 }
 
-static void
+static nir_ssa_def *
 lower_hs_output_store(nir_builder *b,
                       nir_intrinsic_instr *intrin,
                       lower_tess_io_state *st)
@@ -416,7 +421,8 @@ lower_hs_output_store(nir_builder *b,
    bool is_tess_factor = semantics.location == VARYING_SLOT_TESS_LEVEL_INNER ||
                          semantics.location == VARYING_SLOT_TESS_LEVEL_OUTER;
    bool write_to_vmem = !is_tess_factor && tcs_output_needs_vmem(intrin, st);
-   bool write_to_lds = is_tess_factor || tcs_output_needs_lds(intrin, b->shader);
+   bool write_to_lds = (is_tess_factor && !st->tcs_pass_tessfactors_by_reg) ||
+      tcs_output_needs_lds(intrin, b->shader);
 
    if (write_to_vmem) {
       nir_ssa_def *vmem_off = intrin->intrinsic == nir_intrinsic_store_per_vertex_output
@@ -439,6 +445,13 @@ lower_hs_output_store(nir_builder *b,
       nir_store_shared(b, store_val, lds_off, .write_mask = write_mask,
                        .align_mul = 16u, .align_offset = (nir_intrinsic_component(intrin) * 4u) % 16u);
    }
+
+   /* Keep tess factor nir_store_output instruction if it's going to be passed
+    * by reg instead of LDS, because it's used by radeonsi llvm backend to generate
+    * llvm variable which is read by the final llvm tess factor write epilog.
+    */
+   return is_tess_factor && st->tcs_pass_tessfactors_by_reg ?
+      NIR_LOWER_INSTR_PROGRESS : NIR_LOWER_INSTR_PROGRESS_REPLACE;
 }
 
 static nir_ssa_def *
@@ -481,8 +494,7 @@ lower_hs_output_access(nir_builder *b,
 
    if (intrin->intrinsic == nir_intrinsic_store_output ||
        intrin->intrinsic == nir_intrinsic_store_per_vertex_output) {
-      lower_hs_output_store(b, intrin, st);
-      return NIR_LOWER_INSTR_PROGRESS_REPLACE;
+      return lower_hs_output_store(b, intrin, st);
    } else if (intrin->intrinsic == nir_intrinsic_load_output ||
               intrin->intrinsic == nir_intrinsic_load_per_vertex_output) {
       return lower_hs_output_load(b, intrin, st);
@@ -693,6 +705,7 @@ ac_nir_lower_hs_outputs_to_mem(nir_shader *shader,
                                uint64_t tes_patch_inputs_read,
                                unsigned num_reserved_tcs_outputs,
                                unsigned num_reserved_tcs_patch_outputs,
+                               bool pass_tessfactors_by_reg,
                                bool emit_tess_factor_write)
 {
    assert(shader->info.stage == MESA_SHADER_TESS_CTRL);
@@ -705,6 +718,7 @@ ac_nir_lower_hs_outputs_to_mem(nir_shader *shader,
       .tcs_num_reserved_outputs = num_reserved_tcs_outputs,
       .tcs_num_reserved_patch_outputs = num_reserved_tcs_patch_outputs,
       .tcs_out_patch_fits_subgroup = 32 % shader->info.tess.tcs_vertices_out == 0,
+      .tcs_pass_tessfactors_by_reg = pass_tessfactors_by_reg,
       .map_io = map,
    };
 
diff --git a/src/amd/vulkan/radv_shader.c b/src/amd/vulkan/radv_shader.c
index 9042d9091bf6..7011941444f5 100644
--- a/src/amd/vulkan/radv_shader.c
+++ b/src/amd/vulkan/radv_shader.c
@@ -1083,7 +1083,7 @@ radv_lower_io_to_mem(struct radv_device *device, struct radv_pipeline_stage *sta
                  device->physical_device->rad_info.gfx_level,
                  info->tcs.tes_reads_tess_factors, info->tcs.tes_inputs_read,
                  info->tcs.tes_patch_inputs_read, info->tcs.num_linked_outputs,
-                 info->tcs.num_linked_patch_outputs, true);
+                 info->tcs.num_linked_patch_outputs, false, true);
 
       return true;
    } else if (nir->info.stage == MESA_SHADER_TESS_EVAL) {
-- 
GitLab


From 5ff940863910c42b889b1a64e190eb6b7d65f926 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Fri, 27 May 2022 17:39:18 +0800
Subject: [PATCH 20/39] amd: add wave_size parameter to
 ac_nir_lower_hs_outputs_to_mem
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Used by radeonsi and radv to reflect true wave size used, not minimal size.

Reviewed-by: Timur Kristóf <timur.kristof@gmail.com>
Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/amd/common/ac_nir.h                      | 1 +
 src/amd/common/ac_nir_lower_tess_io_to_mem.c | 3 ++-
 src/amd/vulkan/radv_shader.c                 | 2 +-
 3 files changed, 4 insertions(+), 2 deletions(-)

diff --git a/src/amd/common/ac_nir.h b/src/amd/common/ac_nir.h
index 2510b659c2ed..eb00d09d53e2 100644
--- a/src/amd/common/ac_nir.h
+++ b/src/amd/common/ac_nir.h
@@ -89,6 +89,7 @@ ac_nir_lower_hs_outputs_to_mem(nir_shader *shader,
                                uint64_t tes_patch_inputs_read,
                                unsigned num_reserved_tcs_outputs,
                                unsigned num_reserved_tcs_patch_outputs,
+                               unsigned wave_size,
                                bool pass_tessfactors_by_reg,
                                bool emit_tess_factor_write);
 
diff --git a/src/amd/common/ac_nir_lower_tess_io_to_mem.c b/src/amd/common/ac_nir_lower_tess_io_to_mem.c
index 0da9cdefb9c6..d2ce7c114798 100644
--- a/src/amd/common/ac_nir_lower_tess_io_to_mem.c
+++ b/src/amd/common/ac_nir_lower_tess_io_to_mem.c
@@ -705,6 +705,7 @@ ac_nir_lower_hs_outputs_to_mem(nir_shader *shader,
                                uint64_t tes_patch_inputs_read,
                                unsigned num_reserved_tcs_outputs,
                                unsigned num_reserved_tcs_patch_outputs,
+                               unsigned wave_size,
                                bool pass_tessfactors_by_reg,
                                bool emit_tess_factor_write)
 {
@@ -717,7 +718,7 @@ ac_nir_lower_hs_outputs_to_mem(nir_shader *shader,
       .tes_patch_inputs_read = tes_patch_inputs_read,
       .tcs_num_reserved_outputs = num_reserved_tcs_outputs,
       .tcs_num_reserved_patch_outputs = num_reserved_tcs_patch_outputs,
-      .tcs_out_patch_fits_subgroup = 32 % shader->info.tess.tcs_vertices_out == 0,
+      .tcs_out_patch_fits_subgroup = wave_size % shader->info.tess.tcs_vertices_out == 0,
       .tcs_pass_tessfactors_by_reg = pass_tessfactors_by_reg,
       .map_io = map,
    };
diff --git a/src/amd/vulkan/radv_shader.c b/src/amd/vulkan/radv_shader.c
index 7011941444f5..927eea9e25ed 100644
--- a/src/amd/vulkan/radv_shader.c
+++ b/src/amd/vulkan/radv_shader.c
@@ -1083,7 +1083,7 @@ radv_lower_io_to_mem(struct radv_device *device, struct radv_pipeline_stage *sta
                  device->physical_device->rad_info.gfx_level,
                  info->tcs.tes_reads_tess_factors, info->tcs.tes_inputs_read,
                  info->tcs.tes_patch_inputs_read, info->tcs.num_linked_outputs,
-                 info->tcs.num_linked_patch_outputs, false, true);
+                 info->tcs.num_linked_patch_outputs, info->wave_size, false, true);
 
       return true;
    } else if (nir->info.stage == MESA_SHADER_TESS_EVAL) {
-- 
GitLab


From 23e90526ddaa037cfd196273cf8151ce7857b039 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Tue, 24 May 2022 14:40:05 +0800
Subject: [PATCH 21/39] radeonsi: preload tess offchip ring for tcs

Sigend-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/gallium/drivers/radeonsi/si_shader_internal.h  | 2 +-
 src/gallium/drivers/radeonsi/si_shader_llvm.c      | 3 ++-
 src/gallium/drivers/radeonsi/si_shader_llvm_tess.c | 7 ++++---
 3 files changed, 7 insertions(+), 5 deletions(-)

diff --git a/src/gallium/drivers/radeonsi/si_shader_internal.h b/src/gallium/drivers/radeonsi/si_shader_internal.h
index 3860095e4ba3..8f41bd43c873 100644
--- a/src/gallium/drivers/radeonsi/si_shader_internal.h
+++ b/src/gallium/drivers/radeonsi/si_shader_internal.h
@@ -244,7 +244,7 @@ void si_llvm_init_gs_callbacks(struct si_shader_context *ctx);
 /* si_shader_llvm_tess.c */
 LLVMValueRef si_get_tcs_in_vertex_dw_stride(struct si_shader_context *ctx);
 LLVMValueRef si_get_num_tcs_out_vertices(struct si_shader_context *ctx);
-void si_llvm_preload_tes_rings(struct si_shader_context *ctx);
+void si_llvm_preload_tess_rings(struct si_shader_context *ctx);
 void si_llvm_ls_build_end(struct si_shader_context *ctx);
 void si_llvm_build_tcs_epilog(struct si_shader_context *ctx, union si_shader_part_key *key);
 void si_llvm_tcs_build_end(struct si_shader_context *ctx);
diff --git a/src/gallium/drivers/radeonsi/si_shader_llvm.c b/src/gallium/drivers/radeonsi/si_shader_llvm.c
index 1e67292c2482..61b2d81a5865 100644
--- a/src/gallium/drivers/radeonsi/si_shader_llvm.c
+++ b/src/gallium/drivers/radeonsi/si_shader_llvm.c
@@ -820,6 +820,7 @@ bool si_llvm_translate_nir(struct si_shader_context *ctx, struct si_shader *shad
 
    case MESA_SHADER_TESS_CTRL:
       si_llvm_init_tcs_callbacks(ctx);
+      si_llvm_preload_tess_rings(ctx);
 
       if (sel->info.tessfactors_are_def_in_all_invocs) {
          for (unsigned i = 0; i < 6; i++)
@@ -829,7 +830,7 @@ bool si_llvm_translate_nir(struct si_shader_context *ctx, struct si_shader *shad
 
    case MESA_SHADER_TESS_EVAL:
       si_llvm_init_tes_callbacks(ctx, ngg_cull_shader);
-      si_llvm_preload_tes_rings(ctx);
+      si_llvm_preload_tess_rings(ctx);
       break;
 
    case MESA_SHADER_GEOMETRY:
diff --git a/src/gallium/drivers/radeonsi/si_shader_llvm_tess.c b/src/gallium/drivers/radeonsi/si_shader_llvm_tess.c
index feace3b8db4e..31fe0dfb5e92 100644
--- a/src/gallium/drivers/radeonsi/si_shader_llvm_tess.c
+++ b/src/gallium/drivers/radeonsi/si_shader_llvm_tess.c
@@ -370,9 +370,10 @@ static LLVMValueRef get_tess_ring_descriptor(struct si_shader_context *ctx, enum
    return ac_build_gather_values(&ctx->ac, desc, 4);
 }
 
-void si_llvm_preload_tes_rings(struct si_shader_context *ctx)
+void si_llvm_preload_tess_rings(struct si_shader_context *ctx)
 {
-   ctx->tess_offchip_ring = get_tess_ring_descriptor(ctx, TESS_OFFCHIP_RING_TES);
+   ctx->tess_offchip_ring = get_tess_ring_descriptor(
+      ctx, ctx->stage == MESA_SHADER_TESS_CTRL ? TESS_OFFCHIP_RING_TCS : TESS_OFFCHIP_RING_TES);
 }
 
 static LLVMValueRef si_nir_load_tcs_varyings(struct ac_shader_abi *abi, LLVMTypeRef type,
@@ -498,7 +499,7 @@ static void si_nir_store_output_tcs(struct ac_shader_abi *abi,
       }
    }
 
-   buffer = get_tess_ring_descriptor(ctx, TESS_OFFCHIP_RING_TCS);
+   buffer = ctx->tess_offchip_ring;
 
    base = ac_get_arg(&ctx->ac, ctx->args.tess_offchip_offset);
 
-- 
GitLab


From f46941170af7b95fea8feded63e91307f0f6173d Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Tue, 24 May 2022 14:43:36 +0800
Subject: [PATCH 22/39] radeonsi: implement
 nir_intrinsic_load_ring_tess_offchip(_offset)_amd
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Used by tess lower latter.

Reviewed-by: Timur Kristóf <timur.kristof@gmail.com>
Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/amd/llvm/ac_nir_to_llvm.c                 | 1 +
 src/gallium/drivers/radeonsi/si_shader_llvm.c | 6 ++++++
 2 files changed, 7 insertions(+)

diff --git a/src/amd/llvm/ac_nir_to_llvm.c b/src/amd/llvm/ac_nir_to_llvm.c
index dde31808ba8e..3e8361bdd5c9 100644
--- a/src/amd/llvm/ac_nir_to_llvm.c
+++ b/src/amd/llvm/ac_nir_to_llvm.c
@@ -3618,6 +3618,7 @@ static void visit_intrinsic(struct ac_nir_context *ctx, nir_intrinsic_instr *ins
    case nir_intrinsic_load_sample_mask_in:
    case nir_intrinsic_load_ring_tess_factors_amd:
    case nir_intrinsic_load_ring_tess_offchip_amd:
+   case nir_intrinsic_load_ring_tess_offchip_offset_amd:
    case nir_intrinsic_load_ring_esgs_amd:
    case nir_intrinsic_load_lshs_vertex_stride_amd:
    case nir_intrinsic_load_tcs_num_patches_amd:
diff --git a/src/gallium/drivers/radeonsi/si_shader_llvm.c b/src/gallium/drivers/radeonsi/si_shader_llvm.c
index 61b2d81a5865..5da46df3fc87 100644
--- a/src/gallium/drivers/radeonsi/si_shader_llvm.c
+++ b/src/gallium/drivers/radeonsi/si_shader_llvm.c
@@ -784,6 +784,12 @@ static LLVMValueRef si_llvm_load_intrinsic(struct ac_shader_abi *abi, nir_intrin
    case nir_intrinsic_load_hs_out_patch_data_offset_amd:
       return si_unpack_param(ctx, ctx->tcs_offchip_layout, 11, 21);
 
+   case nir_intrinsic_load_ring_tess_offchip_amd:
+      return ctx->tess_offchip_ring;
+
+   case nir_intrinsic_load_ring_tess_offchip_offset_amd:
+      return ac_get_arg(&ctx->ac, ctx->args.tess_offchip_offset);
+
    default:
       return NULL;
    }
-- 
GitLab


From 9aa743c1ebcc418ede46b521d18a8b53c386e311 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Tue, 24 May 2022 15:09:00 +0800
Subject: [PATCH 23/39] radeonsi: implement
 nir_intrinsic_load_tess_rel_patch_id_amd for both tcs and tes

radv will lower this intrinsic before gets to llvm, so we just need to
implement it in radeonsi.

The tes version will be used in tess lower too.

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/amd/llvm/ac_nir_to_llvm.c                      |  5 +----
 src/gallium/drivers/radeonsi/si_shader_internal.h  |  1 +
 src/gallium/drivers/radeonsi/si_shader_llvm.c      |  3 +++
 src/gallium/drivers/radeonsi/si_shader_llvm_tess.c | 12 ++++++------
 4 files changed, 11 insertions(+), 10 deletions(-)

diff --git a/src/amd/llvm/ac_nir_to_llvm.c b/src/amd/llvm/ac_nir_to_llvm.c
index 3e8361bdd5c9..7dd533eb9ceb 100644
--- a/src/amd/llvm/ac_nir_to_llvm.c
+++ b/src/amd/llvm/ac_nir_to_llvm.c
@@ -3614,6 +3614,7 @@ static void visit_intrinsic(struct ac_nir_context *ctx, nir_intrinsic_instr *ins
    case nir_intrinsic_load_tess_level_inner:
    case nir_intrinsic_load_tess_level_outer_default:
    case nir_intrinsic_load_tess_level_inner_default:
+   case nir_intrinsic_load_tess_rel_patch_id_amd:
    case nir_intrinsic_load_patch_vertices_in:
    case nir_intrinsic_load_sample_mask_in:
    case nir_intrinsic_load_ring_tess_factors_amd:
@@ -4033,10 +4034,6 @@ static void visit_intrinsic(struct ac_nir_context *ctx, nir_intrinsic_instr *ins
       result = ac_build_gather_values(&ctx->ac, coord, 3);
       break;
    }
-   case nir_intrinsic_load_tess_rel_patch_id_amd:
-      assert(ctx->stage == MESA_SHADER_TESS_CTRL);
-      result = ac_unpack_param(&ctx->ac, ac_get_arg(&ctx->ac, ctx->args->tcs_rel_ids), 0, 8);
-      break;
    case nir_intrinsic_vote_all: {
       result = ac_build_vote_all(&ctx->ac, get_src(ctx, instr->src[0]));
       break;
diff --git a/src/gallium/drivers/radeonsi/si_shader_internal.h b/src/gallium/drivers/radeonsi/si_shader_internal.h
index 8f41bd43c873..cbb4a5109126 100644
--- a/src/gallium/drivers/radeonsi/si_shader_internal.h
+++ b/src/gallium/drivers/radeonsi/si_shader_internal.h
@@ -242,6 +242,7 @@ void si_llvm_gs_build_end(struct si_shader_context *ctx);
 void si_llvm_init_gs_callbacks(struct si_shader_context *ctx);
 
 /* si_shader_llvm_tess.c */
+LLVMValueRef si_get_rel_patch_id(struct si_shader_context *ctx);
 LLVMValueRef si_get_tcs_in_vertex_dw_stride(struct si_shader_context *ctx);
 LLVMValueRef si_get_num_tcs_out_vertices(struct si_shader_context *ctx);
 void si_llvm_preload_tess_rings(struct si_shader_context *ctx);
diff --git a/src/gallium/drivers/radeonsi/si_shader_llvm.c b/src/gallium/drivers/radeonsi/si_shader_llvm.c
index 5da46df3fc87..a63288e78628 100644
--- a/src/gallium/drivers/radeonsi/si_shader_llvm.c
+++ b/src/gallium/drivers/radeonsi/si_shader_llvm.c
@@ -790,6 +790,9 @@ static LLVMValueRef si_llvm_load_intrinsic(struct ac_shader_abi *abi, nir_intrin
    case nir_intrinsic_load_ring_tess_offchip_offset_amd:
       return ac_get_arg(&ctx->ac, ctx->args.tess_offchip_offset);
 
+   case nir_intrinsic_load_tess_rel_patch_id_amd:
+      return si_get_rel_patch_id(ctx);
+
    default:
       return NULL;
    }
diff --git a/src/gallium/drivers/radeonsi/si_shader_llvm_tess.c b/src/gallium/drivers/radeonsi/si_shader_llvm_tess.c
index 31fe0dfb5e92..8d6cf9a7ae6e 100644
--- a/src/gallium/drivers/radeonsi/si_shader_llvm_tess.c
+++ b/src/gallium/drivers/radeonsi/si_shader_llvm_tess.c
@@ -26,7 +26,7 @@
 #include "si_shader_internal.h"
 #include "sid.h"
 
-static LLVMValueRef get_rel_patch_id(struct si_shader_context *ctx)
+LLVMValueRef si_get_rel_patch_id(struct si_shader_context *ctx)
 {
    switch (ctx->stage) {
    case MESA_SHADER_TESS_CTRL:
@@ -106,7 +106,7 @@ static LLVMValueRef get_tcs_out_patch0_patch_data_offset(struct si_shader_contex
 static LLVMValueRef get_tcs_in_current_patch_offset(struct si_shader_context *ctx)
 {
    LLVMValueRef patch_stride = get_tcs_in_patch_stride(ctx);
-   LLVMValueRef rel_patch_id = get_rel_patch_id(ctx);
+   LLVMValueRef rel_patch_id = si_get_rel_patch_id(ctx);
 
    return LLVMBuildMul(ctx->ac.builder, patch_stride, rel_patch_id, "");
 }
@@ -115,7 +115,7 @@ static LLVMValueRef get_tcs_out_current_patch_offset(struct si_shader_context *c
 {
    LLVMValueRef patch0_offset = get_tcs_out_patch0_offset(ctx);
    LLVMValueRef patch_stride = get_tcs_out_patch_stride(ctx);
-   LLVMValueRef rel_patch_id = get_rel_patch_id(ctx);
+   LLVMValueRef rel_patch_id = si_get_rel_patch_id(ctx);
 
    return ac_build_imad(&ctx->ac, patch_stride, rel_patch_id, patch0_offset);
 }
@@ -124,7 +124,7 @@ static LLVMValueRef get_tcs_out_current_patch_data_offset(struct si_shader_conte
 {
    LLVMValueRef patch0_patch_data_offset = get_tcs_out_patch0_patch_data_offset(ctx);
    LLVMValueRef patch_stride = get_tcs_out_patch_stride(ctx);
-   LLVMValueRef rel_patch_id = get_rel_patch_id(ctx);
+   LLVMValueRef rel_patch_id = si_get_rel_patch_id(ctx);
 
    return ac_build_imad(&ctx->ac, patch_stride, rel_patch_id, patch0_patch_data_offset);
 }
@@ -258,7 +258,7 @@ static LLVMValueRef get_tcs_tes_buffer_address_from_generic_indices(struct si_sh
       param_index = LLVMConstInt(ctx->ac.i32, param_index_base, 0);
    }
 
-   return get_tcs_tes_buffer_address(ctx, get_rel_patch_id(ctx), vertex_index, param_index);
+   return get_tcs_tes_buffer_address(ctx, si_get_rel_patch_id(ctx), vertex_index, param_index);
 }
 
 static LLVMValueRef buffer_load(struct si_shader_context *ctx, LLVMTypeRef type, unsigned swizzle,
@@ -711,7 +711,7 @@ void si_llvm_tcs_build_end(struct si_shader_context *ctx)
    LLVMBuilderRef builder = ctx->ac.builder;
    LLVMValueRef rel_patch_id, invocation_id, tf_lds_offset;
 
-   rel_patch_id = get_rel_patch_id(ctx);
+   rel_patch_id = si_get_rel_patch_id(ctx);
    invocation_id = si_unpack_param(ctx, ctx->args.tcs_rel_ids, 8, 5);
    tf_lds_offset = get_tcs_out_current_patch_data_offset(ctx);
 
-- 
GitLab


From 7802f0372bd4e5e52e18790ca0a2474e5dfe95bf Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Wed, 25 May 2022 19:35:15 +0800
Subject: [PATCH 24/39] amd/llvm: handle write mask for
 nir_intrinsic_store_buffer_amd

tess lowering may generate buffer store with partial write mask.

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/amd/llvm/ac_nir_to_llvm.c | 17 +++++++++++++----
 1 file changed, 13 insertions(+), 4 deletions(-)

diff --git a/src/amd/llvm/ac_nir_to_llvm.c b/src/amd/llvm/ac_nir_to_llvm.c
index 7dd533eb9ceb..d70c88d79feb 100644
--- a/src/amd/llvm/ac_nir_to_llvm.c
+++ b/src/amd/llvm/ac_nir_to_llvm.c
@@ -4224,10 +4224,19 @@ static void visit_intrinsic(struct ac_nir_context *ctx, nir_intrinsic_instr *ins
       if (slc)
          cache_policy |= ac_slc;
 
-      LLVMValueRef voffset = LLVMBuildAdd(ctx->ac.builder, addr_voffset,
-                                          LLVMConstInt(ctx->ac.i32, const_offset, 0), "");
-      ac_build_buffer_store_dword(&ctx->ac, descriptor, store_data, NULL, voffset, addr_soffset,
-                                  cache_policy);
+      unsigned writemask = nir_intrinsic_write_mask(instr);
+      while (writemask) {
+         int start, count;
+         u_bit_scan_consecutive_range(&writemask, &start, &count);
+
+         LLVMValueRef voffset = LLVMBuildAdd(
+            ctx->ac.builder, addr_voffset,
+            LLVMConstInt(ctx->ac.i32, const_offset + start * 4, 0), "");
+
+         LLVMValueRef data = extract_vector_range(&ctx->ac, store_data, start, count);
+         ac_build_buffer_store_dword(&ctx->ac, descriptor, data, NULL, voffset, addr_soffset,
+                                     cache_policy);
+      }
       break;
    }
    case nir_intrinsic_has_input_vertex_amd: {
-- 
GitLab


From 05c12d4e113fd7c1b33b29209099aa25f9218a36 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Wed, 1 Jun 2022 17:13:00 +0800
Subject: [PATCH 25/39] amd: add no_input_lds_space param to hs output lower

This is used by radeonsi to save some lds space when all LS output
is passed by register.

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/amd/common/ac_nir.h                      |  1 +
 src/amd/common/ac_nir_lower_tess_io_to_mem.c | 26 +++++++++++++++-----
 src/amd/vulkan/radv_shader.c                 |  3 ++-
 3 files changed, 23 insertions(+), 7 deletions(-)

diff --git a/src/amd/common/ac_nir.h b/src/amd/common/ac_nir.h
index eb00d09d53e2..a6c6b2564969 100644
--- a/src/amd/common/ac_nir.h
+++ b/src/amd/common/ac_nir.h
@@ -90,6 +90,7 @@ ac_nir_lower_hs_outputs_to_mem(nir_shader *shader,
                                unsigned num_reserved_tcs_outputs,
                                unsigned num_reserved_tcs_patch_outputs,
                                unsigned wave_size,
+                               bool no_input_lds_space,
                                bool pass_tessfactors_by_reg,
                                bool emit_tess_factor_write);
 
diff --git a/src/amd/common/ac_nir_lower_tess_io_to_mem.c b/src/amd/common/ac_nir_lower_tess_io_to_mem.c
index d2ce7c114798..be85834ac6ad 100644
--- a/src/amd/common/ac_nir_lower_tess_io_to_mem.c
+++ b/src/amd/common/ac_nir_lower_tess_io_to_mem.c
@@ -159,6 +159,12 @@ typedef struct {
     * can be passed by register.
     */
    bool tcs_pass_tessfactors_by_reg;
+
+   /* Stop TCS count the input LDS space when load/store output to LDS. This is set when
+    * LS/HS is merged and all LS ouput is passed by register instead of LDS, so we don't
+    * need to reserve LDS space for them when TCS output load/store.
+    */
+   bool tcs_no_input_lds_space;
 } lower_tess_io_state;
 
 static bool
@@ -325,18 +331,24 @@ hs_output_lds_offset(nir_builder *b,
    unsigned pervertex_output_patch_size = b->shader->info.tess.tcs_vertices_out * output_vertex_size;
    unsigned output_patch_stride = pervertex_output_patch_size + st->tcs_num_reserved_patch_outputs * 16u;
 
-   nir_ssa_def *tcs_in_vtxcnt = nir_load_patch_vertices_in(b);
-   nir_ssa_def *tcs_num_patches = nir_load_tcs_num_patches_amd(b);
-   nir_ssa_def *input_patch_size = nir_imul(b, tcs_in_vtxcnt, nir_load_lshs_vertex_stride_amd(b));
-   nir_ssa_def *output_patch0_offset = nir_imul(b, input_patch_size, tcs_num_patches);
-
    nir_ssa_def *off = intrin
                     ? ac_nir_calc_io_offset(b, intrin, nir_imm_int(b, 16u), 4u, st->map_io)
                     : nir_imm_int(b, 0);
 
    nir_ssa_def *rel_patch_id = nir_load_tess_rel_patch_id_amd(b);
    nir_ssa_def *patch_offset = nir_imul_imm(b, rel_patch_id, output_patch_stride);
-   nir_ssa_def *output_patch_offset = nir_iadd_nuw(b, patch_offset, output_patch0_offset);
+
+   nir_ssa_def *output_patch_offset;
+   if (st->tcs_no_input_lds_space)
+      output_patch_offset = patch_offset;
+   else {
+      nir_ssa_def *tcs_in_vtxcnt = nir_load_patch_vertices_in(b);
+      nir_ssa_def *tcs_num_patches = nir_load_tcs_num_patches_amd(b);
+      nir_ssa_def *input_patch_size =
+         nir_imul(b, tcs_in_vtxcnt, nir_load_lshs_vertex_stride_amd(b));
+      nir_ssa_def *output_patch0_offset = nir_imul(b, input_patch_size, tcs_num_patches);
+      output_patch_offset = nir_iadd_nuw(b, patch_offset, output_patch0_offset);
+   }
 
    if (per_vertex) {
       nir_ssa_def *vertex_index = nir_ssa_for_src(b, *nir_get_io_arrayed_index_src(intrin), 1);
@@ -706,6 +718,7 @@ ac_nir_lower_hs_outputs_to_mem(nir_shader *shader,
                                unsigned num_reserved_tcs_outputs,
                                unsigned num_reserved_tcs_patch_outputs,
                                unsigned wave_size,
+                               bool no_input_lds_space,
                                bool pass_tessfactors_by_reg,
                                bool emit_tess_factor_write)
 {
@@ -720,6 +733,7 @@ ac_nir_lower_hs_outputs_to_mem(nir_shader *shader,
       .tcs_num_reserved_patch_outputs = num_reserved_tcs_patch_outputs,
       .tcs_out_patch_fits_subgroup = wave_size % shader->info.tess.tcs_vertices_out == 0,
       .tcs_pass_tessfactors_by_reg = pass_tessfactors_by_reg,
+      .tcs_no_input_lds_space = no_input_lds_space,
       .map_io = map,
    };
 
diff --git a/src/amd/vulkan/radv_shader.c b/src/amd/vulkan/radv_shader.c
index 927eea9e25ed..8af854c087ef 100644
--- a/src/amd/vulkan/radv_shader.c
+++ b/src/amd/vulkan/radv_shader.c
@@ -1083,7 +1083,8 @@ radv_lower_io_to_mem(struct radv_device *device, struct radv_pipeline_stage *sta
                  device->physical_device->rad_info.gfx_level,
                  info->tcs.tes_reads_tess_factors, info->tcs.tes_inputs_read,
                  info->tcs.tes_patch_inputs_read, info->tcs.num_linked_outputs,
-                 info->tcs.num_linked_patch_outputs, info->wave_size, false, true);
+                 info->tcs.num_linked_patch_outputs, info->wave_size,
+                 false, false, true);
 
       return true;
    } else if (nir->info.stage == MESA_SHADER_TESS_EVAL) {
-- 
GitLab


From 1f2c555c0e2d7e6e786b84d873e7162e5d0531ee Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Sat, 28 May 2022 17:52:35 +0800
Subject: [PATCH 26/39] radeonsi: replace llvm tcs output with nir lower pass

Remove the store_tcs_outputs abi, we can use common output abi
to handle the tessfactor pass as vgpr.

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/amd/llvm/ac_nir_to_llvm.c                 |  13 +-
 src/amd/llvm/ac_shader_abi.h                  |   6 -
 src/gallium/drivers/radeonsi/si_shader.c      |  24 ++-
 .../drivers/radeonsi/si_shader_internal.h     |   1 -
 src/gallium/drivers/radeonsi/si_shader_llvm.c |   5 -
 .../drivers/radeonsi/si_shader_llvm_tess.c    | 155 ++++--------------
 6 files changed, 52 insertions(+), 152 deletions(-)

diff --git a/src/amd/llvm/ac_nir_to_llvm.c b/src/amd/llvm/ac_nir_to_llvm.c
index d70c88d79feb..9e190348fbb0 100644
--- a/src/amd/llvm/ac_nir_to_llvm.c
+++ b/src/amd/llvm/ac_nir_to_llvm.c
@@ -2371,18 +2371,9 @@ static void visit_store_output(struct ac_nir_context *ctx, nir_intrinsic_instr *
 
    writemask <<= component;
 
-   if (ctx->stage == MESA_SHADER_TESS_CTRL) {
-      nir_src *vertex_index_src = nir_get_io_arrayed_index_src(instr);
-      LLVMValueRef vertex_index = vertex_index_src ? get_src(ctx, *vertex_index_src) : NULL;
-      unsigned location = nir_intrinsic_io_semantics(instr).location;
-
-      ctx->abi->store_tcs_outputs(ctx->abi, vertex_index, indir_index, src,
-                                  writemask, component, location, base);
-      return;
-   }
-
    /* No indirect indexing is allowed after this point. */
-   assert(!indir_index);
+   if (indir_index)
+      return;
 
    for (unsigned chan = 0; chan < 8; chan++) {
       if (!(writemask & (1 << chan)))
diff --git a/src/amd/llvm/ac_shader_abi.h b/src/amd/llvm/ac_shader_abi.h
index 4584d52d1203..ee9e17a88d09 100644
--- a/src/amd/llvm/ac_shader_abi.h
+++ b/src/amd/llvm/ac_shader_abi.h
@@ -69,12 +69,6 @@ struct ac_shader_abi {
                                       unsigned driver_location, unsigned component,
                                       unsigned num_components, bool load_inputs);
 
-   void (*store_tcs_outputs)(struct ac_shader_abi *abi,
-                             LLVMValueRef vertex_index, LLVMValueRef param_index,
-                             LLVMValueRef src, unsigned writemask,
-                             unsigned component, unsigned location, unsigned driver_location);
-
-
    LLVMValueRef (*load_ubo)(struct ac_shader_abi *abi, LLVMValueRef index);
 
    /**
diff --git a/src/gallium/drivers/radeonsi/si_shader.c b/src/gallium/drivers/radeonsi/si_shader.c
index 5d5b4a18f9b4..62fbb0ed99a0 100644
--- a/src/gallium/drivers/radeonsi/si_shader.c
+++ b/src/gallium/drivers/radeonsi/si_shader.c
@@ -1490,13 +1490,20 @@ static bool si_nir_kill_outputs(nir_shader *nir, const union si_shader_key *key)
 
 static unsigned si_map_io_driver_location(unsigned semantic)
 {
+   if (semantic >= VARYING_SLOT_PATCH0 ||
+       semantic == VARYING_SLOT_TESS_LEVEL_INNER ||
+       semantic == VARYING_SLOT_TESS_LEVEL_OUTER)
+      return si_shader_io_get_unique_index_patch(semantic);
+
    return si_shader_io_get_unique_index(semantic, false);
 }
 
-static bool si_lower_io_to_mem(const union si_shader_key *key,
-                               nir_shader *nir,
+static bool si_lower_io_to_mem(struct si_shader *shader, nir_shader *nir,
                                uint64_t tcs_vgpr_only_inputs)
 {
+   struct si_shader_selector *sel = shader->selector;
+   const union si_shader_key *key = &shader->key;
+
    if (nir->info.stage == MESA_SHADER_VERTEX) {
       if (key->ge.as_ls) {
          NIR_PASS_V(nir, ac_nir_lower_ls_outputs_to_mem, si_map_io_driver_location,
@@ -1506,6 +1513,17 @@ static bool si_lower_io_to_mem(const union si_shader_key *key,
    } else if (nir->info.stage == MESA_SHADER_TESS_CTRL) {
       NIR_PASS_V(nir, ac_nir_lower_hs_inputs_to_mem, si_map_io_driver_location,
                  key->ge.opt.same_patch_vertices);
+      NIR_PASS_V(nir, ac_nir_lower_hs_outputs_to_mem, si_map_io_driver_location,
+                 sel->screen->info.gfx_level,
+                 key->ge.part.tcs.epilog.tes_reads_tess_factors,
+                 ~0ULL, ~0ULL, /* no TES inputs filter */
+                 util_last_bit64(sel->info.outputs_written),
+                 util_last_bit64(sel->info.patch_outputs_written),
+                 shader->wave_size,
+                 /* ALL TCS inputs are passed by register. */
+                 key->ge.opt.same_patch_vertices &&
+                 !(sel->info.base.inputs_read & ~sel->info.tcs_vgpr_only_inputs),
+                 sel->info.tessfactors_are_def_in_all_invocs, false);
       return true;
    }
 
@@ -1633,7 +1651,7 @@ struct nir_shader *si_get_nir_shader(struct si_shader *shader, bool *free_nir,
    progress2 |= ac_nir_lower_indirect_derefs(nir, sel->screen->info.gfx_level);
 
    bool opt_offsets = false;
-   opt_offsets |= si_lower_io_to_mem(key, nir, tcs_vgpr_only_inputs);
+   opt_offsets |= si_lower_io_to_mem(shader, nir, tcs_vgpr_only_inputs);
 
    if (progress2 || opt_offsets)
       si_nir_opts(sel->screen, nir, false);
diff --git a/src/gallium/drivers/radeonsi/si_shader_internal.h b/src/gallium/drivers/radeonsi/si_shader_internal.h
index cbb4a5109126..6bda67d5b7be 100644
--- a/src/gallium/drivers/radeonsi/si_shader_internal.h
+++ b/src/gallium/drivers/radeonsi/si_shader_internal.h
@@ -144,7 +144,6 @@ struct si_shader_context {
    LLVMValueRef gsvs_ring[4];
    LLVMValueRef tess_offchip_ring;
 
-   LLVMValueRef invoc0_tess_factors[6]; /* outer[4], inner[2] */
    LLVMValueRef gs_next_vertex[4];
    LLVMValueRef gs_curprim_verts[4];
    LLVMValueRef gs_generated_prims[4];
diff --git a/src/gallium/drivers/radeonsi/si_shader_llvm.c b/src/gallium/drivers/radeonsi/si_shader_llvm.c
index a63288e78628..5656349808a4 100644
--- a/src/gallium/drivers/radeonsi/si_shader_llvm.c
+++ b/src/gallium/drivers/radeonsi/si_shader_llvm.c
@@ -830,11 +830,6 @@ bool si_llvm_translate_nir(struct si_shader_context *ctx, struct si_shader *shad
    case MESA_SHADER_TESS_CTRL:
       si_llvm_init_tcs_callbacks(ctx);
       si_llvm_preload_tess_rings(ctx);
-
-      if (sel->info.tessfactors_are_def_in_all_invocs) {
-         for (unsigned i = 0; i < 6; i++)
-            ctx->invoc0_tess_factors[i] = ac_build_alloca_undef(&ctx->ac, ctx->ac.i32, "");
-      }
       break;
 
    case MESA_SHADER_TESS_EVAL:
diff --git a/src/gallium/drivers/radeonsi/si_shader_llvm_tess.c b/src/gallium/drivers/radeonsi/si_shader_llvm_tess.c
index 8d6cf9a7ae6e..acb547f70d4d 100644
--- a/src/gallium/drivers/radeonsi/si_shader_llvm_tess.c
+++ b/src/gallium/drivers/radeonsi/si_shader_llvm_tess.c
@@ -383,42 +383,18 @@ static LLVMValueRef si_nir_load_tcs_varyings(struct ac_shader_abi *abi, LLVMType
 {
    struct si_shader_context *ctx = si_shader_context_from_abi(abi);
    struct si_shader_info *info = &ctx->shader->selector->info;
-   LLVMValueRef value[4];
-
-   if (load_input) {
-      assert(ctx->shader->key.ge.opt.same_patch_vertices && !param_index);
-
-      ubyte semantic = info->input[driver_location].semantic;
-      /* Load the TCS input from a VGPR. */
-      unsigned func_param = ctx->args.tcs_rel_ids.arg_index + 1 +
-         si_shader_io_get_unique_index(semantic, false) * 4;
 
-      for (unsigned i = component; i < component + num_components; i++) {
-         value[i] = LLVMGetParam(ctx->main_fn, func_param + i);
-         value[i] = LLVMBuildBitCast(ctx->ac.builder, value[i], type, "");
-      }
-   } else {
-      ubyte semantic = info->output_semantic[driver_location];
-
-      bool is_patch = vertex_index == NULL;
-      assert((semantic >= VARYING_SLOT_PATCH0 ||
-              semantic == VARYING_SLOT_TESS_LEVEL_INNER ||
-              semantic == VARYING_SLOT_TESS_LEVEL_OUTER) == is_patch);
-
-      LLVMValueRef dw_addr, stride;
-      if (is_patch) {
-         stride = NULL;
-         dw_addr = get_tcs_out_current_patch_data_offset(ctx);
-      } else {
-         stride = get_tcs_out_vertex_dw_stride(ctx);
-         dw_addr = get_tcs_out_current_patch_offset(ctx);
-      }
+   assert(ctx->shader->key.ge.opt.same_patch_vertices && !param_index);
 
-      dw_addr = get_dw_address_from_generic_indices(ctx, stride, dw_addr, vertex_index,
-                                                    param_index, semantic);
+   ubyte semantic = info->input[driver_location].semantic;
+   /* Load the TCS input from a VGPR. */
+   unsigned func_param = ctx->args.tcs_rel_ids.arg_index + 1 +
+      si_shader_io_get_unique_index(semantic, false) * 4;
 
-      for (unsigned i = component; i < component + num_components; i++)
-         value[i] = lshs_lds_load(ctx, type, i, dw_addr);
+   LLVMValueRef value[4];
+   for (unsigned i = component; i < component + num_components; i++) {
+      value[i] = LLVMGetParam(ctx->main_fn, func_param + i);
+      value[i] = LLVMBuildBitCast(ctx->ac.builder, value[i], type, "");
    }
 
    return ac_build_varying_gather_values(&ctx->ac, value, num_components, component);
@@ -455,96 +431,6 @@ static LLVMValueRef si_nir_load_input_tes(struct ac_shader_abi *abi, LLVMTypeRef
    return ac_build_varying_gather_values(&ctx->ac, value, num_components, component);
 }
 
-static void si_nir_store_output_tcs(struct ac_shader_abi *abi,
-                                    LLVMValueRef vertex_index, LLVMValueRef param_index,
-                                    LLVMValueRef src, unsigned writemask,
-                                    unsigned component, unsigned location, unsigned driver_location)
-{
-   struct si_shader_context *ctx = si_shader_context_from_abi(abi);
-   struct si_shader_info *info = &ctx->shader->selector->info;
-   LLVMValueRef dw_addr, stride;
-   LLVMValueRef buffer, base, addr;
-   LLVMValueRef values[8];
-   bool is_tess_factor = false, is_tess_inner = false;
-
-   ubyte semantic = info->output_semantic[driver_location];
-
-   const bool is_const = !param_index;
-   const bool is_patch = vertex_index == NULL;
-
-   /* Invalid SPIR-V can cause this. */
-   if ((semantic >= VARYING_SLOT_PATCH0 || semantic == VARYING_SLOT_TESS_LEVEL_INNER ||
-        semantic == VARYING_SLOT_TESS_LEVEL_OUTER) != is_patch)
-      return;
-
-   if (!is_patch) {
-      stride = get_tcs_out_vertex_dw_stride(ctx);
-      dw_addr = get_tcs_out_current_patch_offset(ctx);
-      dw_addr = get_dw_address_from_generic_indices(ctx, stride, dw_addr, vertex_index, param_index,
-                                                    semantic);
-   } else {
-      dw_addr = get_tcs_out_current_patch_data_offset(ctx);
-      dw_addr = get_dw_address_from_generic_indices(ctx, NULL, dw_addr, vertex_index, param_index,
-                                                    semantic);
-
-      if (is_const) {
-         int semantic = info->output_semantic[driver_location];
-
-         /* Always write tess factors into LDS for the TCS epilog. */
-         if (semantic == VARYING_SLOT_TESS_LEVEL_INNER ||
-             semantic == VARYING_SLOT_TESS_LEVEL_OUTER) {
-            is_tess_factor = true;
-            is_tess_inner = semantic == VARYING_SLOT_TESS_LEVEL_INNER;
-         }
-      }
-   }
-
-   buffer = ctx->tess_offchip_ring;
-
-   base = ac_get_arg(&ctx->ac, ctx->args.tess_offchip_offset);
-
-   addr =
-      get_tcs_tes_buffer_address_from_generic_indices(ctx, vertex_index, param_index, semantic);
-
-   for (unsigned chan = component; chan < 4; chan++) {
-      if (!(writemask & (1 << chan)))
-         continue;
-      LLVMValueRef value = ac_llvm_extract_elem(&ctx->ac, src, chan - component);
-
-      /* Skip LDS stores if there is no LDS read of this output. */
-      if (info->output_readmask[driver_location] & (1 << chan) ||
-          /* The epilog reads LDS if invocation 0 doesn't define tess factors. */
-          (is_tess_factor &&
-           !ctx->shader->selector->info.tessfactors_are_def_in_all_invocs))
-         lshs_lds_store(ctx, chan, dw_addr, value);
-
-      value = ac_to_integer(&ctx->ac, value);
-      values[chan] = value;
-
-      if (writemask != 0xF && !is_tess_factor) {
-         LLVMValueRef voffset = LLVMBuildAdd(ctx->ac.builder, addr,
-                                             LLVMConstInt(ctx->ac.i32, 4 * chan, 0), "");
-         ac_build_buffer_store_dword(&ctx->ac, buffer, value, NULL, voffset, base, ac_glc);
-      }
-
-      /* Write tess factors into VGPRs for the epilog. */
-      if (is_tess_factor && ctx->shader->selector->info.tessfactors_are_def_in_all_invocs) {
-         if (!is_tess_inner) {
-            LLVMBuildStore(ctx->ac.builder, value, /* outer */
-                           ctx->invoc0_tess_factors[chan]);
-         } else if (chan < 2) {
-            LLVMBuildStore(ctx->ac.builder, value, /* inner */
-                           ctx->invoc0_tess_factors[4 + chan]);
-         }
-      }
-   }
-
-   if (writemask == 0xF && !is_tess_factor) {
-      LLVMValueRef value = ac_build_gather_values(&ctx->ac, values, 4);
-      ac_build_buffer_store_dword(&ctx->ac, buffer, value, NULL, addr, base, ac_glc);
-   }
-}
-
 static void si_write_tess_factors(struct si_shader_context *ctx, union si_shader_part_key *key,
                                   LLVMValueRef rel_patch_id, LLVMValueRef invocation_id,
                                   LLVMValueRef tcs_out_current_patch_data_offset,
@@ -769,10 +655,28 @@ void si_llvm_tcs_build_end(struct si_shader_context *ctx)
    ret = LLVMBuildInsertValue(builder, ret, rel_patch_id, vgpr++, "");
    ret = LLVMBuildInsertValue(builder, ret, invocation_id, vgpr++, "");
 
-   if (ctx->shader->selector->info.tessfactors_are_def_in_all_invocs) {
+   struct si_shader_info *info = &ctx->shader->selector->info;
+   if (info->tessfactors_are_def_in_all_invocs) {
       vgpr++; /* skip the tess factor LDS offset */
+
+      /* get tess factor driver location */
+      int outer_loc = -1;
+      int inner_loc = -1;
+      for (int i = 0; i < info->num_outputs; i++) {
+         unsigned semantic = info->output_semantic[i];
+         if (semantic == VARYING_SLOT_TESS_LEVEL_OUTER)
+            outer_loc = i;
+         else if (semantic == VARYING_SLOT_TESS_LEVEL_INNER)
+            inner_loc = i;
+      }
+
       for (unsigned i = 0; i < 6; i++) {
-         LLVMValueRef value = LLVMBuildLoad(builder, ctx->invoc0_tess_factors[i], "");
+         int loc = i < 4 ? outer_loc : inner_loc;
+         LLVMValueRef value = loc < 0 ?
+            ac_build_alloca_undef(&ctx->ac, ctx->ac.f32, "") :
+            ctx->abi.outputs[loc * 4 + i % 4];
+
+         value = LLVMBuildLoad(builder, value, "");
          value = ac_to_float(&ctx->ac, value);
          ret = LLVMBuildInsertValue(builder, ret, value, vgpr++, "");
       }
@@ -920,7 +824,6 @@ void si_llvm_build_tcs_epilog(struct si_shader_context *ctx, union si_shader_par
 void si_llvm_init_tcs_callbacks(struct si_shader_context *ctx)
 {
    ctx->abi.load_tess_varyings = si_nir_load_tcs_varyings;
-   ctx->abi.store_tcs_outputs = si_nir_store_output_tcs;
 }
 
 void si_llvm_init_tes_callbacks(struct si_shader_context *ctx, bool ngg_cull_shader)
-- 
GitLab


From 908af5f32fdde9148e3f86b816830befd14db02f Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Sat, 28 May 2022 18:09:56 +0800
Subject: [PATCH 27/39] radeonsi: enable PIPE_CAP_GLSL_TESS_LEVELS_AS_INPUTS
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

This can remove special handling of tessfactors which also benifit
the nir lower pass which does not handle these as system value.

Reviewed-by: Timur Kristóf <timur.kristof@gmail.com>
Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/amd/llvm/ac_nir_to_llvm.c                 |  2 --
 src/gallium/drivers/radeonsi/si_get.c         |  1 +
 src/gallium/drivers/radeonsi/si_shader_info.c | 15 +++++----------
 src/gallium/drivers/radeonsi/si_shader_llvm.c |  7 -------
 4 files changed, 6 insertions(+), 19 deletions(-)

diff --git a/src/amd/llvm/ac_nir_to_llvm.c b/src/amd/llvm/ac_nir_to_llvm.c
index 9e190348fbb0..631feb6fa2fd 100644
--- a/src/amd/llvm/ac_nir_to_llvm.c
+++ b/src/amd/llvm/ac_nir_to_llvm.c
@@ -3601,8 +3601,6 @@ static void visit_intrinsic(struct ac_nir_context *ctx, nir_intrinsic_instr *ins
    case nir_intrinsic_load_base_vertex:
    case nir_intrinsic_load_first_vertex:
    case nir_intrinsic_load_workgroup_size:
-   case nir_intrinsic_load_tess_level_outer:
-   case nir_intrinsic_load_tess_level_inner:
    case nir_intrinsic_load_tess_level_outer_default:
    case nir_intrinsic_load_tess_level_inner_default:
    case nir_intrinsic_load_tess_rel_patch_id_amd:
diff --git a/src/gallium/drivers/radeonsi/si_get.c b/src/gallium/drivers/radeonsi/si_get.c
index 84d6e67bdbf5..439410d8ecf2 100644
--- a/src/gallium/drivers/radeonsi/si_get.c
+++ b/src/gallium/drivers/radeonsi/si_get.c
@@ -165,6 +165,7 @@ static int si_get_param(struct pipe_screen *pscreen, enum pipe_cap param)
    case PIPE_CAP_IMAGE_ATOMIC_INC_WRAP:
    case PIPE_CAP_IMAGE_STORE_FORMATTED:
    case PIPE_CAP_ALLOW_DRAW_OUT_OF_ORDER:
+   case PIPE_CAP_GLSL_TESS_LEVELS_AS_INPUTS:
       return 1;
 
    case PIPE_CAP_TEXTURE_TRANSFER_MODES:
diff --git a/src/gallium/drivers/radeonsi/si_shader_info.c b/src/gallium/drivers/radeonsi/si_shader_info.c
index 497b090a1751..84a21eec35f4 100644
--- a/src/gallium/drivers/radeonsi/si_shader_info.c
+++ b/src/gallium/drivers/radeonsi/si_shader_info.c
@@ -440,8 +440,6 @@ static void scan_instruction(const struct nir_shader *nir, struct si_shader_info
             break;
 
          case nir_intrinsic_load_barycentric_at_sample: /* This loads sample positions. */
-         case nir_intrinsic_load_tess_level_outer: /* TES input read from memory */
-         case nir_intrinsic_load_tess_level_inner: /* TES input read from memory */
             info->uses_vmem_load_other = true;
             break;
 
@@ -625,6 +623,11 @@ void si_nir_scan_shader(struct si_screen *sscreen, const struct nir_shader *nir,
       info->tessfactors_are_def_in_all_invocs = are_tessfactors_def_in_all_invocs(nir);
    }
 
+   /* tess factors are loaded as input instead of system value */
+   info->reads_tess_factors = nir->info.patch_inputs_read &
+      (BITFIELD64_BIT(VARYING_SLOT_TESS_LEVEL_INNER) |
+       BITFIELD64_BIT(VARYING_SLOT_TESS_LEVEL_OUTER));
+
    info->uses_frontface = BITSET_TEST(nir->info.system_values_read, SYSTEM_VALUE_FRONT_FACE);
    info->uses_instanceid = BITSET_TEST(nir->info.system_values_read, SYSTEM_VALUE_INSTANCE_ID);
    info->uses_base_vertex = BITSET_TEST(nir->info.system_values_read, SYSTEM_VALUE_BASE_VERTEX);
@@ -639,8 +642,6 @@ void si_nir_scan_shader(struct si_screen *sscreen, const struct nir_shader *nir,
    info->uses_primid = BITSET_TEST(nir->info.system_values_read, SYSTEM_VALUE_PRIMITIVE_ID) ||
                        nir->info.inputs_read & VARYING_BIT_PRIMITIVE_ID;
    info->reads_samplemask = BITSET_TEST(nir->info.system_values_read, SYSTEM_VALUE_SAMPLE_MASK_IN);
-   info->reads_tess_factors = BITSET_TEST(nir->info.system_values_read, SYSTEM_VALUE_TESS_LEVEL_INNER) ||
-                              BITSET_TEST(nir->info.system_values_read, SYSTEM_VALUE_TESS_LEVEL_OUTER);
    info->uses_linear_sample = BITSET_TEST(nir->info.system_values_read, SYSTEM_VALUE_BARYCENTRIC_LINEAR_SAMPLE);
    info->uses_linear_centroid = BITSET_TEST(nir->info.system_values_read, SYSTEM_VALUE_BARYCENTRIC_LINEAR_CENTROID);
    info->uses_linear_center = BITSET_TEST(nir->info.system_values_read, SYSTEM_VALUE_BARYCENTRIC_LINEAR_PIXEL);
@@ -686,12 +687,6 @@ void si_nir_scan_shader(struct si_screen *sscreen, const struct nir_shader *nir,
       info->output_usagemask[info->num_outputs] = 0x1;
    }
 
-   if (nir->info.stage == MESA_SHADER_TESS_EVAL) {
-      /* This is a hack to simplify loading tess levels in TES. */
-      info->input[info->num_inputs].semantic = VARYING_SLOT_TESS_LEVEL_OUTER;
-      info->input[info->num_inputs + 1].semantic = VARYING_SLOT_TESS_LEVEL_INNER;
-   }
-
    if (nir->info.stage == MESA_SHADER_FRAGMENT) {
       info->allow_flat_shading = !(info->uses_persp_center || info->uses_persp_centroid ||
                                    info->uses_persp_sample || info->uses_linear_center ||
diff --git a/src/gallium/drivers/radeonsi/si_shader_llvm.c b/src/gallium/drivers/radeonsi/si_shader_llvm.c
index 5656349808a4..0e1cbbb77ab3 100644
--- a/src/gallium/drivers/radeonsi/si_shader_llvm.c
+++ b/src/gallium/drivers/radeonsi/si_shader_llvm.c
@@ -714,7 +714,6 @@ void si_build_wrapper_function(struct si_shader_context *ctx, LLVMValueRef *part
 static LLVMValueRef si_llvm_load_intrinsic(struct ac_shader_abi *abi, nir_intrinsic_op op)
 {
    struct si_shader_context *ctx = si_shader_context_from_abi(abi);
-   const struct si_shader_info *info = &ctx->shader->selector->info;
 
    switch (op) {
    case nir_intrinsic_load_first_vertex:
@@ -742,12 +741,6 @@ static LLVMValueRef si_llvm_load_intrinsic(struct ac_shader_abi *abi, nir_intrin
       return ac_build_gather_values(&ctx->ac, chan, 3);
    }
 
-   case nir_intrinsic_load_tess_level_outer:
-      return abi->load_tess_varyings(abi, ctx->ac.f32, NULL, NULL, info->num_inputs, 0, 4, true);
-
-   case nir_intrinsic_load_tess_level_inner:
-      return abi->load_tess_varyings(abi, ctx->ac.f32, NULL, NULL, info->num_inputs + 1, 0, 4, true);
-
    case nir_intrinsic_load_tess_level_outer_default:
    case nir_intrinsic_load_tess_level_inner_default: {
       LLVMValueRef slot = LLVMConstInt(ctx->ac.i32, SI_HS_CONST_DEFAULT_TESS_LEVELS, 0);
-- 
GitLab


From 04c1f5b243184d1d79e78554f4bac1222689e418 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Sat, 28 May 2022 22:20:08 +0800
Subject: [PATCH 28/39] radeonsi: set uses_vmem_load_other for
 nir_intrinsic_load_buffer_amd
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Before lower TES load input to load buffer, mark this flag for this
intrinsic, otherwise we get corruption with GFX10 after the lowering.

Reviewed-by: Timur Kristóf <timur.kristof@gmail.com>
Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/gallium/drivers/radeonsi/si_shader_info.c | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/src/gallium/drivers/radeonsi/si_shader_info.c b/src/gallium/drivers/radeonsi/si_shader_info.c
index 84a21eec35f4..3fc3f3b9dabc 100644
--- a/src/gallium/drivers/radeonsi/si_shader_info.c
+++ b/src/gallium/drivers/radeonsi/si_shader_info.c
@@ -451,6 +451,10 @@ static void scan_instruction(const struct nir_shader *nir, struct si_shader_info
                info->uses_vmem_load_other = true;
             break;
 
+         case nir_intrinsic_load_buffer_amd:
+            info->uses_vmem_load_other = true;
+            break;
+
          default:
             if (is_image ||
                 is_bindless_image ||
-- 
GitLab


From 67c8c12a325fe3da051634f6b62623cd7ef78242 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Sat, 28 May 2022 22:23:40 +0800
Subject: [PATCH 29/39] radeonsi: replace llvm tes input load with nir lowering

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/amd/llvm/ac_nir_to_llvm.c                 |   3 +-
 src/gallium/drivers/radeonsi/si_shader.c      |   3 +
 .../drivers/radeonsi/si_shader_internal.h     |   1 -
 src/gallium/drivers/radeonsi/si_shader_llvm.c |   1 -
 .../drivers/radeonsi/si_shader_llvm_tess.c    | 155 ------------------
 5 files changed, 4 insertions(+), 159 deletions(-)

diff --git a/src/amd/llvm/ac_nir_to_llvm.c b/src/amd/llvm/ac_nir_to_llvm.c
index 631feb6fa2fd..1844b5fc1d36 100644
--- a/src/amd/llvm/ac_nir_to_llvm.c
+++ b/src/amd/llvm/ac_nir_to_llvm.c
@@ -3448,8 +3448,7 @@ static LLVMValueRef visit_load(struct ac_nir_context *ctx, nir_intrinsic_instr *
    else
       indir_index = get_src(ctx, offset);
 
-   if (ctx->stage == MESA_SHADER_TESS_CTRL ||
-       (ctx->stage == MESA_SHADER_TESS_EVAL && !is_output)) {
+   if (ctx->stage == MESA_SHADER_TESS_CTRL) {
       LLVMValueRef result = ctx->abi->load_tess_varyings(ctx->abi, component_type,
                                                          vertex_index, indir_index,
                                                          base, component,
diff --git a/src/gallium/drivers/radeonsi/si_shader.c b/src/gallium/drivers/radeonsi/si_shader.c
index 62fbb0ed99a0..a0d53671bc74 100644
--- a/src/gallium/drivers/radeonsi/si_shader.c
+++ b/src/gallium/drivers/radeonsi/si_shader.c
@@ -1525,6 +1525,9 @@ static bool si_lower_io_to_mem(struct si_shader *shader, nir_shader *nir,
                  !(sel->info.base.inputs_read & ~sel->info.tcs_vgpr_only_inputs),
                  sel->info.tessfactors_are_def_in_all_invocs, false);
       return true;
+   } else if (nir->info.stage == MESA_SHADER_TESS_EVAL) {
+      NIR_PASS_V(nir, ac_nir_lower_tes_inputs_to_mem, si_map_io_driver_location);
+      return true;
    }
 
    return false;
diff --git a/src/gallium/drivers/radeonsi/si_shader_internal.h b/src/gallium/drivers/radeonsi/si_shader_internal.h
index 6bda67d5b7be..f4f4ed89fd95 100644
--- a/src/gallium/drivers/radeonsi/si_shader_internal.h
+++ b/src/gallium/drivers/radeonsi/si_shader_internal.h
@@ -249,7 +249,6 @@ void si_llvm_ls_build_end(struct si_shader_context *ctx);
 void si_llvm_build_tcs_epilog(struct si_shader_context *ctx, union si_shader_part_key *key);
 void si_llvm_tcs_build_end(struct si_shader_context *ctx);
 void si_llvm_init_tcs_callbacks(struct si_shader_context *ctx);
-void si_llvm_init_tes_callbacks(struct si_shader_context *ctx, bool ngg_cull_shader);
 
 /* si_shader_llvm_ps.c */
 LLVMValueRef si_get_sample_id(struct si_shader_context *ctx);
diff --git a/src/gallium/drivers/radeonsi/si_shader_llvm.c b/src/gallium/drivers/radeonsi/si_shader_llvm.c
index 0e1cbbb77ab3..c6cbd4ba198b 100644
--- a/src/gallium/drivers/radeonsi/si_shader_llvm.c
+++ b/src/gallium/drivers/radeonsi/si_shader_llvm.c
@@ -826,7 +826,6 @@ bool si_llvm_translate_nir(struct si_shader_context *ctx, struct si_shader *shad
       break;
 
    case MESA_SHADER_TESS_EVAL:
-      si_llvm_init_tes_callbacks(ctx, ngg_cull_shader);
       si_llvm_preload_tess_rings(ctx);
       break;
 
diff --git a/src/gallium/drivers/radeonsi/si_shader_llvm_tess.c b/src/gallium/drivers/radeonsi/si_shader_llvm_tess.c
index acb547f70d4d..ea9df8d56ef2 100644
--- a/src/gallium/drivers/radeonsi/si_shader_llvm_tess.c
+++ b/src/gallium/drivers/radeonsi/si_shader_llvm_tess.c
@@ -62,11 +62,6 @@ LLVMValueRef si_get_rel_patch_id(struct si_shader_context *ctx)
  * All three shaders VS(LS), TCS, TES share the same LDS space.
  */
 
-static LLVMValueRef get_tcs_in_patch_stride(struct si_shader_context *ctx)
-{
-   return si_unpack_param(ctx, ctx->vs_state_bits, 11, 13);
-}
-
 static unsigned get_tcs_out_vertex_dw_stride_constant(struct si_shader_context *ctx)
 {
    assert(ctx->stage == MESA_SHADER_TESS_CTRL);
@@ -74,13 +69,6 @@ static unsigned get_tcs_out_vertex_dw_stride_constant(struct si_shader_context *
    return util_last_bit64(ctx->shader->selector->info.outputs_written) * 4;
 }
 
-static LLVMValueRef get_tcs_out_vertex_dw_stride(struct si_shader_context *ctx)
-{
-   unsigned stride = get_tcs_out_vertex_dw_stride_constant(ctx);
-
-   return LLVMConstInt(ctx->ac.i32, stride, 0);
-}
-
 static LLVMValueRef get_tcs_out_patch_stride(struct si_shader_context *ctx)
 {
    const struct si_shader_info *info = &ctx->shader->selector->info;
@@ -91,35 +79,12 @@ static LLVMValueRef get_tcs_out_patch_stride(struct si_shader_context *ctx)
    return LLVMConstInt(ctx->ac.i32, patch_dw_stride, 0);
 }
 
-static LLVMValueRef get_tcs_out_patch0_offset(struct si_shader_context *ctx)
-{
-   return LLVMBuildMul(ctx->ac.builder, si_unpack_param(ctx, ctx->tcs_out_lds_offsets, 0, 16),
-                       LLVMConstInt(ctx->ac.i32, 4, 0), "");
-}
-
 static LLVMValueRef get_tcs_out_patch0_patch_data_offset(struct si_shader_context *ctx)
 {
    return LLVMBuildMul(ctx->ac.builder, si_unpack_param(ctx, ctx->tcs_out_lds_offsets, 16, 16),
                        LLVMConstInt(ctx->ac.i32, 4, 0), "");
 }
 
-static LLVMValueRef get_tcs_in_current_patch_offset(struct si_shader_context *ctx)
-{
-   LLVMValueRef patch_stride = get_tcs_in_patch_stride(ctx);
-   LLVMValueRef rel_patch_id = si_get_rel_patch_id(ctx);
-
-   return LLVMBuildMul(ctx->ac.builder, patch_stride, rel_patch_id, "");
-}
-
-static LLVMValueRef get_tcs_out_current_patch_offset(struct si_shader_context *ctx)
-{
-   LLVMValueRef patch0_offset = get_tcs_out_patch0_offset(ctx);
-   LLVMValueRef patch_stride = get_tcs_out_patch_stride(ctx);
-   LLVMValueRef rel_patch_id = si_get_rel_patch_id(ctx);
-
-   return ac_build_imad(&ctx->ac, patch_stride, rel_patch_id, patch0_offset);
-}
-
 static LLVMValueRef get_tcs_out_current_patch_data_offset(struct si_shader_context *ctx)
 {
    LLVMValueRef patch0_patch_data_offset = get_tcs_out_patch0_patch_data_offset(ctx);
@@ -165,29 +130,6 @@ LLVMValueRef si_get_tcs_in_vertex_dw_stride(struct si_shader_context *ctx)
    }
 }
 
-static LLVMValueRef
-get_dw_address_from_generic_indices(struct si_shader_context *ctx, LLVMValueRef vertex_dw_stride,
-                                    LLVMValueRef base_addr, LLVMValueRef vertex_index,
-                                    LLVMValueRef param_index, ubyte name)
-{
-   if (vertex_dw_stride) {
-      base_addr = ac_build_imad(&ctx->ac, vertex_index, vertex_dw_stride, base_addr);
-   }
-
-   if (param_index) {
-      base_addr = ac_build_imad(&ctx->ac, param_index, LLVMConstInt(ctx->ac.i32, 4, 0), base_addr);
-   }
-
-   int param = name >= VARYING_SLOT_PATCH0 ||
-               name == VARYING_SLOT_TESS_LEVEL_INNER ||
-               name == VARYING_SLOT_TESS_LEVEL_OUTER
-                  ? si_shader_io_get_unique_index_patch(name)
-                  : si_shader_io_get_unique_index(name, false);
-
-   /* Add the base address of the element. */
-   return LLVMBuildAdd(ctx->ac.builder, base_addr, LLVMConstInt(ctx->ac.i32, param * 4, 0), "");
-}
-
 /* The offchip buffer layout for TCS->TES is
  *
  * - attribute 0 of patch 0 vertex 0
@@ -238,51 +180,6 @@ static LLVMValueRef get_tcs_tes_buffer_address(struct si_shader_context *ctx,
    return base_addr;
 }
 
-static LLVMValueRef get_tcs_tes_buffer_address_from_generic_indices(struct si_shader_context *ctx,
-                                                                    LLVMValueRef vertex_index,
-                                                                    LLVMValueRef param_index,
-                                                                    ubyte name)
-{
-   unsigned param_index_base;
-
-   param_index_base = name >= VARYING_SLOT_PATCH0 ||
-                      name == VARYING_SLOT_TESS_LEVEL_INNER ||
-                      name == VARYING_SLOT_TESS_LEVEL_OUTER
-                         ? si_shader_io_get_unique_index_patch(name)
-                         : si_shader_io_get_unique_index(name, false);
-
-   if (param_index) {
-      param_index = LLVMBuildAdd(ctx->ac.builder, param_index,
-                                 LLVMConstInt(ctx->ac.i32, param_index_base, 0), "");
-   } else {
-      param_index = LLVMConstInt(ctx->ac.i32, param_index_base, 0);
-   }
-
-   return get_tcs_tes_buffer_address(ctx, si_get_rel_patch_id(ctx), vertex_index, param_index);
-}
-
-static LLVMValueRef buffer_load(struct si_shader_context *ctx, LLVMTypeRef type, unsigned swizzle,
-                                LLVMValueRef buffer, LLVMValueRef offset, LLVMValueRef base,
-                                bool can_speculate)
-{
-   LLVMValueRef value;
-   LLVMTypeRef vec_type = LLVMVectorType(type, 4);
-
-   if (swizzle == ~0) {
-      value = ac_build_buffer_load(&ctx->ac, buffer, 4, NULL, base, offset, type, ac_glc,
-                                   can_speculate, false);
-
-      return LLVMBuildBitCast(ctx->ac.builder, value, vec_type, "");
-   }
-
-   value = ac_build_buffer_load(&ctx->ac, buffer, 4, NULL, base, offset, type, ac_glc,
-                                can_speculate, false);
-
-   value = LLVMBuildBitCast(ctx->ac.builder, value, vec_type, "");
-   return LLVMBuildExtractElement(ctx->ac.builder, value, LLVMConstInt(ctx->ac.i32, swizzle, 0),
-                                  "");
-}
-
 /**
  * Load from LSHS LDS storage.
  *
@@ -309,22 +206,6 @@ static LLVMValueRef lshs_lds_load(struct si_shader_context *ctx, LLVMTypeRef typ
    return LLVMBuildBitCast(ctx->ac.builder, value, type, "");
 }
 
-/**
- * Store to LSHS LDS storage.
- *
- * \param swizzle	offset (typically 0..3)
- * \param dw_addr	address in dwords
- * \param value		value to store
- */
-static void lshs_lds_store(struct si_shader_context *ctx, unsigned dw_offset_imm,
-                           LLVMValueRef dw_addr, LLVMValueRef value)
-{
-   dw_addr =
-      LLVMBuildAdd(ctx->ac.builder, dw_addr, LLVMConstInt(ctx->ac.i32, dw_offset_imm, 0), "");
-
-   ac_lds_store(&ctx->ac, dw_addr, value);
-}
-
 enum si_tess_ring
 {
    TCS_FACTOR_RING,
@@ -400,37 +281,6 @@ static LLVMValueRef si_nir_load_tcs_varyings(struct ac_shader_abi *abi, LLVMType
    return ac_build_varying_gather_values(&ctx->ac, value, num_components, component);
 }
 
-static LLVMValueRef si_nir_load_input_tes(struct ac_shader_abi *abi, LLVMTypeRef type,
-                                          LLVMValueRef vertex_index, LLVMValueRef param_index,
-                                          unsigned driver_location, unsigned component,
-                                          unsigned num_components, bool load_input)
-{
-   struct si_shader_context *ctx = si_shader_context_from_abi(abi);
-   struct si_shader_info *info = &ctx->shader->selector->info;
-   LLVMValueRef base, addr;
-
-   ubyte semantic = info->input[driver_location].semantic;
-
-   assert((semantic >= VARYING_SLOT_PATCH0 ||
-           semantic == VARYING_SLOT_TESS_LEVEL_INNER ||
-           semantic == VARYING_SLOT_TESS_LEVEL_OUTER) == (vertex_index == NULL));
-
-   base = ac_get_arg(&ctx->ac, ctx->args.tess_offchip_offset);
-
-   addr =
-      get_tcs_tes_buffer_address_from_generic_indices(ctx, vertex_index, param_index, semantic);
-
-   /* TODO: This will generate rather ordinary llvm code, although it
-    * should be easy for the optimizer to fix up. In future we might want
-    * to refactor buffer_load().
-    */
-   LLVMValueRef value[4];
-   for (unsigned i = component; i < component + num_components; i++)
-      value[i] = buffer_load(ctx, type, i, ctx->tess_offchip_ring, base, addr, true);
-
-   return ac_build_varying_gather_values(&ctx->ac, value, num_components, component);
-}
-
 static void si_write_tess_factors(struct si_shader_context *ctx, union si_shader_part_key *key,
                                   LLVMValueRef rel_patch_id, LLVMValueRef invocation_id,
                                   LLVMValueRef tcs_out_current_patch_data_offset,
@@ -825,8 +675,3 @@ void si_llvm_init_tcs_callbacks(struct si_shader_context *ctx)
 {
    ctx->abi.load_tess_varyings = si_nir_load_tcs_varyings;
 }
-
-void si_llvm_init_tes_callbacks(struct si_shader_context *ctx, bool ngg_cull_shader)
-{
-   ctx->abi.load_tess_varyings = si_nir_load_input_tes;
-}
-- 
GitLab


From 68d3a9b1d989d56a50588fb3474b9e35a93c19cf Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Mon, 30 May 2022 14:28:32 +0800
Subject: [PATCH 30/39] amd/llvm: fix code format alignment in
 visit_load_local_invocation_index

Used tab instead of space.

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/amd/llvm/ac_nir_to_llvm.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/src/amd/llvm/ac_nir_to_llvm.c b/src/amd/llvm/ac_nir_to_llvm.c
index 1844b5fc1d36..5b7655cca7ca 100644
--- a/src/amd/llvm/ac_nir_to_llvm.c
+++ b/src/amd/llvm/ac_nir_to_llvm.c
@@ -3021,8 +3021,8 @@ static LLVMValueRef visit_load_local_invocation_index(struct ac_nir_context *ctx
       /* Thread ID in threadgroup in merged ESGS. */
       LLVMValueRef wave_id = ac_unpack_param(&ctx->ac, ac_get_arg(&ctx->ac, ctx->args->merged_wave_info), 24, 4);
       LLVMValueRef wave_size = LLVMConstInt(ctx->ac.i32, ctx->ac.wave_size, false);
-	   LLVMValueRef threads_before = LLVMBuildMul(ctx->ac.builder, wave_id, wave_size, "");
-	   return LLVMBuildAdd(ctx->ac.builder, threads_before, ac_get_thread_id(&ctx->ac), "");
+      LLVMValueRef threads_before = LLVMBuildMul(ctx->ac.builder, wave_id, wave_size, "");
+      return LLVMBuildAdd(ctx->ac.builder, threads_before, ac_get_thread_id(&ctx->ac), "");
    }
 
    LLVMValueRef result;
-- 
GitLab


From a4c0e7a0805a8ad4096e6a4c54602147c3f262b3 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Mon, 30 May 2022 14:41:08 +0800
Subject: [PATCH 31/39] radeonsi: implement two esgs ring nir intrinsic

nir_intrinsic_load_ring_esgs_amd
nir_intrinsic_load_ring_es2gs_offset_amd

Will be used by esgs lowering.

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/amd/llvm/ac_nir_to_llvm.c                 | 1 +
 src/gallium/drivers/radeonsi/si_shader_llvm.c | 6 ++++++
 2 files changed, 7 insertions(+)

diff --git a/src/amd/llvm/ac_nir_to_llvm.c b/src/amd/llvm/ac_nir_to_llvm.c
index 5b7655cca7ca..80927865350e 100644
--- a/src/amd/llvm/ac_nir_to_llvm.c
+++ b/src/amd/llvm/ac_nir_to_llvm.c
@@ -3609,6 +3609,7 @@ static void visit_intrinsic(struct ac_nir_context *ctx, nir_intrinsic_instr *ins
    case nir_intrinsic_load_ring_tess_offchip_amd:
    case nir_intrinsic_load_ring_tess_offchip_offset_amd:
    case nir_intrinsic_load_ring_esgs_amd:
+   case nir_intrinsic_load_ring_es2gs_offset_amd:
    case nir_intrinsic_load_lshs_vertex_stride_amd:
    case nir_intrinsic_load_tcs_num_patches_amd:
    case nir_intrinsic_load_hs_out_patch_data_offset_amd:
diff --git a/src/gallium/drivers/radeonsi/si_shader_llvm.c b/src/gallium/drivers/radeonsi/si_shader_llvm.c
index c6cbd4ba198b..f36391d44035 100644
--- a/src/gallium/drivers/radeonsi/si_shader_llvm.c
+++ b/src/gallium/drivers/radeonsi/si_shader_llvm.c
@@ -786,6 +786,12 @@ static LLVMValueRef si_llvm_load_intrinsic(struct ac_shader_abi *abi, nir_intrin
    case nir_intrinsic_load_tess_rel_patch_id_amd:
       return si_get_rel_patch_id(ctx);
 
+   case nir_intrinsic_load_ring_esgs_amd:
+      return ctx->esgs_ring;
+
+   case nir_intrinsic_load_ring_es2gs_offset_amd:
+      return ac_get_arg(&ctx->ac, ctx->args.es2gs_offset);
+
    default:
       return NULL;
    }
-- 
GitLab


From eb1d31eac4342b43b98d7325233ac1a696600902 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Mon, 30 May 2022 14:52:57 +0800
Subject: [PATCH 32/39] ac/nir: skip gl_ViewportIndex and gl_Layer write in ES

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/amd/common/ac_nir_lower_esgs_io_to_mem.c | 32 ++++++++++++++++++++
 1 file changed, 32 insertions(+)

diff --git a/src/amd/common/ac_nir_lower_esgs_io_to_mem.c b/src/amd/common/ac_nir_lower_esgs_io_to_mem.c
index 9cd7f4d6f9b0..70aad36106f1 100644
--- a/src/amd/common/ac_nir_lower_esgs_io_to_mem.c
+++ b/src/amd/common/ac_nir_lower_esgs_io_to_mem.c
@@ -124,6 +124,38 @@ lower_es_output_store(nir_builder *b,
    if (intrin->intrinsic != nir_intrinsic_store_output)
       return false;
 
+   /* The ARB_shader_viewport_layer_array spec contains the
+    * following issue:
+    *
+    *    2) What happens if gl_ViewportIndex or gl_Layer is
+    *    written in the vertex shader and a geometry shader is
+    *    present?
+    *
+    *    RESOLVED: The value written by the last vertex processing
+    *    stage is used. If the last vertex processing stage
+    *    (vertex, tessellation evaluation or geometry) does not
+    *    statically assign to gl_ViewportIndex or gl_Layer, index
+    *    or layer zero is assumed.
+    *
+    * Vulkan spec 15.7 Built-In Variables:
+    *
+    *   The last active pre-rasterization shader stage (in pipeline order)
+    *   controls the Layer that is used. Outputs in previous shader stages
+    *   are not used, even if the last stage fails to write the Layer.
+    *
+    *   The last active pre-rasterization shader stage (in pipeline order)
+    *   controls the ViewportIndex that is used. Outputs in previous shader
+    *   stages are not used, even if the last stage fails to write the
+    *   ViewportIndex.
+    *
+    * So writes to those outputs in ES are simply ignored.
+    */
+   unsigned semantic = nir_intrinsic_io_semantics(intrin).location;
+   if (semantic == VARYING_SLOT_LAYER || semantic == VARYING_SLOT_VIEWPORT) {
+      nir_instr_remove(instr);
+      return true;
+   }
+
    lower_esgs_io_state *st = (lower_esgs_io_state *) state;
    unsigned write_mask = nir_intrinsic_write_mask(intrin);
 
-- 
GitLab


From 37baeb9ded497bb08bcea1b685e740d36e566ed9 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Tue, 31 May 2022 10:35:28 +0800
Subject: [PATCH 33/39] radeonsi: set lds for gs/es to handle nir shared memory
 load/store

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/gallium/drivers/radeonsi/si_shader_llvm_gs.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/src/gallium/drivers/radeonsi/si_shader_llvm_gs.c b/src/gallium/drivers/radeonsi/si_shader_llvm_gs.c
index be2e57480ea9..9c3188ce4de7 100644
--- a/src/gallium/drivers/radeonsi/si_shader_llvm_gs.c
+++ b/src/gallium/drivers/radeonsi/si_shader_llvm_gs.c
@@ -397,6 +397,7 @@ void si_preload_esgs_ring(struct si_shader_context *ctx)
       if (USE_LDS_SYMBOLS) {
          /* Declare the ESGS ring as an explicit LDS symbol. */
          si_llvm_declare_esgs_ring(ctx);
+         ctx->ac.lds = ctx->esgs_ring;
       } else {
          ac_declare_lds_as_pointer(&ctx->ac);
          ctx->esgs_ring = ctx->ac.lds;
-- 
GitLab


From 47b6632629dde353106eab3127868fe729b577af Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Mon, 30 May 2022 20:06:03 +0800
Subject: [PATCH 34/39] amd: remove unused param num_reserved_es_outputs from
 gs input lower

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/amd/common/ac_nir.h                      | 3 +--
 src/amd/common/ac_nir_lower_esgs_io_to_mem.c | 4 +---
 src/amd/vulkan/radv_shader.c                 | 3 +--
 3 files changed, 3 insertions(+), 7 deletions(-)

diff --git a/src/amd/common/ac_nir.h b/src/amd/common/ac_nir.h
index a6c6b2564969..5b6fbbb4fb81 100644
--- a/src/amd/common/ac_nir.h
+++ b/src/amd/common/ac_nir.h
@@ -107,8 +107,7 @@ ac_nir_lower_es_outputs_to_mem(nir_shader *shader,
 void
 ac_nir_lower_gs_inputs_to_mem(nir_shader *shader,
                               ac_nir_map_io_driver_location map,
-                              enum amd_gfx_level gfx_level,
-                              unsigned num_reserved_es_outputs);
+                              enum amd_gfx_level gfx_level);
 
 bool
 ac_nir_lower_indirect_derefs(nir_shader *shader,
diff --git a/src/amd/common/ac_nir_lower_esgs_io_to_mem.c b/src/amd/common/ac_nir_lower_esgs_io_to_mem.c
index 70aad36106f1..2f79e5a6d6dc 100644
--- a/src/amd/common/ac_nir_lower_esgs_io_to_mem.c
+++ b/src/amd/common/ac_nir_lower_esgs_io_to_mem.c
@@ -284,12 +284,10 @@ ac_nir_lower_es_outputs_to_mem(nir_shader *shader,
 void
 ac_nir_lower_gs_inputs_to_mem(nir_shader *shader,
                               ac_nir_map_io_driver_location map,
-                              enum amd_gfx_level gfx_level,
-                              unsigned num_reserved_es_outputs)
+                              enum amd_gfx_level gfx_level)
 {
    lower_esgs_io_state state = {
       .gfx_level = gfx_level,
-      .num_reserved_es_outputs = num_reserved_es_outputs,
       .map_io = map,
    };
 
diff --git a/src/amd/vulkan/radv_shader.c b/src/amd/vulkan/radv_shader.c
index 8af854c087ef..12be13321c98 100644
--- a/src/amd/vulkan/radv_shader.c
+++ b/src/amd/vulkan/radv_shader.c
@@ -1098,8 +1098,7 @@ radv_lower_io_to_mem(struct radv_device *device, struct radv_pipeline_stage *sta
       return true;
    } else if (nir->info.stage == MESA_SHADER_GEOMETRY) {
       NIR_PASS_V(nir, ac_nir_lower_gs_inputs_to_mem, NULL,
-                 device->physical_device->rad_info.gfx_level,
-                 info->gs.num_linked_inputs);
+                 device->physical_device->rad_info.gfx_level);
       return true;
    } else if (nir->info.stage == MESA_SHADER_TASK) {
       ac_nir_apply_first_task_to_task_shader(nir);
-- 
GitLab


From f231f3759d41f8892fe1290890d66b8b68da0047 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Tue, 31 May 2022 14:18:17 +0800
Subject: [PATCH 35/39] amd: change es output lower param to esgs_itemsize

radeonsi may add extra dword to the stride, so let's pass it
directly.

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/amd/common/ac_nir.h                      |  2 +-
 src/amd/common/ac_nir_lower_esgs_io_to_mem.c | 13 +++++--------
 src/amd/vulkan/radv_shader.c                 |  6 ++++--
 3 files changed, 10 insertions(+), 11 deletions(-)

diff --git a/src/amd/common/ac_nir.h b/src/amd/common/ac_nir.h
index 5b6fbbb4fb81..c0fbd47499c3 100644
--- a/src/amd/common/ac_nir.h
+++ b/src/amd/common/ac_nir.h
@@ -102,7 +102,7 @@ void
 ac_nir_lower_es_outputs_to_mem(nir_shader *shader,
                                ac_nir_map_io_driver_location map,
                                enum amd_gfx_level gfx_level,
-                               unsigned num_reserved_es_outputs);
+                               unsigned esgs_itemsize);
 
 void
 ac_nir_lower_gs_inputs_to_mem(nir_shader *shader,
diff --git a/src/amd/common/ac_nir_lower_esgs_io_to_mem.c b/src/amd/common/ac_nir_lower_esgs_io_to_mem.c
index 2f79e5a6d6dc..611ac445810d 100644
--- a/src/amd/common/ac_nir_lower_esgs_io_to_mem.c
+++ b/src/amd/common/ac_nir_lower_esgs_io_to_mem.c
@@ -47,10 +47,8 @@ typedef struct {
    /* I/O semantic -> real location used by lowering. */
    ac_nir_map_io_driver_location map_io;
 
-   /* Number of ES outputs for which memory should be reserved.
-    * When compacted, this should be the number of linked ES outputs.
-    */
-   unsigned num_reserved_es_outputs;
+   /* Stride of an ES invocation outputs in esgs ring, in bytes. */
+   unsigned esgs_itemsize;
 } lower_esgs_io_state;
 
 static nir_ssa_def *
@@ -171,9 +169,8 @@ lower_es_output_store(nir_builder *b,
                               write_mask, true, true);
    } else {
       /* GFX9+: ES is merged into GS, data is passed through LDS. */
-      unsigned esgs_itemsize = st->num_reserved_es_outputs * 16u;
       nir_ssa_def *vertex_idx = nir_build_load_local_invocation_index(b);
-      nir_ssa_def *off = nir_iadd(b, nir_imul_imm(b, vertex_idx, esgs_itemsize), io_off);
+      nir_ssa_def *off = nir_iadd(b, nir_imul_imm(b, vertex_idx, st->esgs_itemsize), io_off);
       nir_build_store_shared(b, intrin->src[0].ssa, off, .write_mask = write_mask,
                              .align_mul = 16u, .align_offset = (nir_intrinsic_component(intrin) * 4u) % 16u);
    }
@@ -267,11 +264,11 @@ void
 ac_nir_lower_es_outputs_to_mem(nir_shader *shader,
                                ac_nir_map_io_driver_location map,
                                enum amd_gfx_level gfx_level,
-                               unsigned num_reserved_es_outputs)
+                               unsigned esgs_itemsize)
 {
    lower_esgs_io_state state = {
       .gfx_level = gfx_level,
-      .num_reserved_es_outputs = num_reserved_es_outputs,
+      .esgs_itemsize = esgs_itemsize,
       .map_io = map,
    };
 
diff --git a/src/amd/vulkan/radv_shader.c b/src/amd/vulkan/radv_shader.c
index 12be13321c98..12183cea2335 100644
--- a/src/amd/vulkan/radv_shader.c
+++ b/src/amd/vulkan/radv_shader.c
@@ -1074,7 +1074,8 @@ radv_lower_io_to_mem(struct radv_device *device, struct radv_pipeline_stage *sta
          return true;
       } else if (info->vs.as_es) {
          NIR_PASS_V(nir, ac_nir_lower_es_outputs_to_mem, NULL,
-                    device->physical_device->rad_info.gfx_level, info->vs.num_linked_outputs);
+                    device->physical_device->rad_info.gfx_level,
+                    info->vs.num_linked_outputs * 16u);
          return true;
       }
    } else if (nir->info.stage == MESA_SHADER_TESS_CTRL) {
@@ -1092,7 +1093,8 @@ radv_lower_io_to_mem(struct radv_device *device, struct radv_pipeline_stage *sta
 
       if (info->tes.as_es) {
          NIR_PASS_V(nir, ac_nir_lower_es_outputs_to_mem, NULL,
-                    device->physical_device->rad_info.gfx_level, info->tes.num_linked_outputs);
+                    device->physical_device->rad_info.gfx_level,
+                    info->tes.num_linked_outputs * 16u);
       }
 
       return true;
-- 
GitLab


From 1a917b7bd2a1c3ff3ae00779a93e69e61cab5d6c Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Mon, 30 May 2022 15:03:40 +0800
Subject: [PATCH 36/39] radeonsi: replace llvm es output with nir lowering

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/gallium/drivers/radeonsi/si_shader.c      | 10 ++++
 .../drivers/radeonsi/si_shader_llvm_gs.c      | 51 -------------------
 2 files changed, 10 insertions(+), 51 deletions(-)

diff --git a/src/gallium/drivers/radeonsi/si_shader.c b/src/gallium/drivers/radeonsi/si_shader.c
index a0d53671bc74..022107755b52 100644
--- a/src/gallium/drivers/radeonsi/si_shader.c
+++ b/src/gallium/drivers/radeonsi/si_shader.c
@@ -1509,6 +1509,10 @@ static bool si_lower_io_to_mem(struct si_shader *shader, nir_shader *nir,
          NIR_PASS_V(nir, ac_nir_lower_ls_outputs_to_mem, si_map_io_driver_location,
                     key->ge.opt.same_patch_vertices, tcs_vgpr_only_inputs);
          return true;
+      } else if (key->ge.as_es) {
+         NIR_PASS_V(nir, ac_nir_lower_es_outputs_to_mem, si_map_io_driver_location,
+                    sel->screen->info.gfx_level, sel->info.esgs_itemsize);
+         return true;
       }
    } else if (nir->info.stage == MESA_SHADER_TESS_CTRL) {
       NIR_PASS_V(nir, ac_nir_lower_hs_inputs_to_mem, si_map_io_driver_location,
@@ -1527,6 +1531,12 @@ static bool si_lower_io_to_mem(struct si_shader *shader, nir_shader *nir,
       return true;
    } else if (nir->info.stage == MESA_SHADER_TESS_EVAL) {
       NIR_PASS_V(nir, ac_nir_lower_tes_inputs_to_mem, si_map_io_driver_location);
+
+      if (key->ge.as_es) {
+         NIR_PASS_V(nir, ac_nir_lower_es_outputs_to_mem, si_map_io_driver_location,
+                    sel->screen->info.gfx_level, sel->info.esgs_itemsize);
+      }
+
       return true;
    }
 
diff --git a/src/gallium/drivers/radeonsi/si_shader_llvm_gs.c b/src/gallium/drivers/radeonsi/si_shader_llvm_gs.c
index 9c3188ce4de7..7157126fda43 100644
--- a/src/gallium/drivers/radeonsi/si_shader_llvm_gs.c
+++ b/src/gallium/drivers/radeonsi/si_shader_llvm_gs.c
@@ -137,57 +137,6 @@ static void si_set_es_return_value_for_gs(struct si_shader_context *ctx)
 
 void si_llvm_es_build_end(struct si_shader_context *ctx)
 {
-   struct si_shader *es = ctx->shader;
-   struct si_shader_info *info = &es->selector->info;
-   LLVMValueRef *addrs = ctx->abi.outputs;
-   LLVMValueRef lds_base = NULL;
-   unsigned chan;
-   int i;
-
-   if (ctx->screen->info.gfx_level >= GFX9 && info->num_outputs) {
-      unsigned itemsize_dw = es->selector->info.esgs_itemsize / 4;
-      LLVMValueRef vertex_idx = ac_get_thread_id(&ctx->ac);
-      LLVMValueRef wave_idx = si_unpack_param(ctx, ctx->args.merged_wave_info, 24, 4);
-      vertex_idx =
-         LLVMBuildOr(ctx->ac.builder, vertex_idx,
-                     LLVMBuildMul(ctx->ac.builder, wave_idx,
-                                  LLVMConstInt(ctx->ac.i32, ctx->ac.wave_size, false), ""),
-                     "");
-      lds_base =
-         LLVMBuildMul(ctx->ac.builder, vertex_idx, LLVMConstInt(ctx->ac.i32, itemsize_dw, 0), "");
-   }
-
-   for (i = 0; i < info->num_outputs; i++) {
-      int param;
-
-      if (info->output_semantic[i] == VARYING_SLOT_VIEWPORT ||
-          info->output_semantic[i] == VARYING_SLOT_LAYER)
-         continue;
-
-      param = si_shader_io_get_unique_index(info->output_semantic[i], false);
-
-      for (chan = 0; chan < 4; chan++) {
-         if (!(info->output_usagemask[i] & (1 << chan)))
-            continue;
-
-         LLVMValueRef out_val = LLVMBuildLoad(ctx->ac.builder, addrs[4 * i + chan], "");
-         out_val = ac_to_integer(&ctx->ac, out_val);
-
-         /* GFX9 has the ESGS ring in LDS. */
-         if (ctx->screen->info.gfx_level >= GFX9) {
-            LLVMValueRef idx = LLVMConstInt(ctx->ac.i32, param * 4 + chan, false);
-            idx = LLVMBuildAdd(ctx->ac.builder, lds_base, idx, "");
-            ac_build_indexed_store(&ctx->ac, ctx->esgs_ring, idx, out_val);
-            continue;
-         }
-
-         ac_build_buffer_store_dword(&ctx->ac, ctx->esgs_ring, out_val, NULL,
-                                     LLVMConstInt(ctx->ac.i32, (4 * param + chan) * 4, 0),
-                                     ac_get_arg(&ctx->ac, ctx->args.es2gs_offset),
-                                     ac_glc | ac_slc | ac_swizzled);
-      }
-   }
-
    if (ctx->screen->info.gfx_level >= GFX9)
       si_set_es_return_value_for_gs(ctx);
 }
-- 
GitLab


From 0fc6dc52ce9c89c9c3493b1bda784c5f3147e593 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Mon, 30 May 2022 19:46:15 +0800
Subject: [PATCH 37/39] amd: add triangle_strip_adjacency_fix to gs input lower

From radeonsi.

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/amd/common/ac_nir.h                      |  3 +-
 src/amd/common/ac_nir_lower_esgs_io_to_mem.c | 54 ++++++++++++++++----
 src/amd/vulkan/radv_shader.c                 |  2 +-
 3 files changed, 46 insertions(+), 13 deletions(-)

diff --git a/src/amd/common/ac_nir.h b/src/amd/common/ac_nir.h
index c0fbd47499c3..64ff8d0e82e8 100644
--- a/src/amd/common/ac_nir.h
+++ b/src/amd/common/ac_nir.h
@@ -107,7 +107,8 @@ ac_nir_lower_es_outputs_to_mem(nir_shader *shader,
 void
 ac_nir_lower_gs_inputs_to_mem(nir_shader *shader,
                               ac_nir_map_io_driver_location map,
-                              enum amd_gfx_level gfx_level);
+                              enum amd_gfx_level gfx_level,
+                              bool triangle_strip_adjacency_fix);
 
 bool
 ac_nir_lower_indirect_derefs(nir_shader *shader,
diff --git a/src/amd/common/ac_nir_lower_esgs_io_to_mem.c b/src/amd/common/ac_nir_lower_esgs_io_to_mem.c
index 611ac445810d..54a1583111f0 100644
--- a/src/amd/common/ac_nir_lower_esgs_io_to_mem.c
+++ b/src/amd/common/ac_nir_lower_esgs_io_to_mem.c
@@ -49,6 +49,9 @@ typedef struct {
 
    /* Stride of an ES invocation outputs in esgs ring, in bytes. */
    unsigned esgs_itemsize;
+
+   /* Enable fix for triangle strip adjacency in geometry shader. */
+   bool gs_triangle_strip_adjacency_fix;
 } lower_esgs_io_state;
 
 static nir_ssa_def *
@@ -180,16 +183,42 @@ lower_es_output_store(nir_builder *b,
 }
 
 static nir_ssa_def *
-gs_per_vertex_input_vertex_offset_gfx6(nir_builder *b, nir_src *vertex_src)
+gs_get_vertex_offset(nir_builder *b, lower_esgs_io_state *st, unsigned vertex_index)
+{
+   nir_ssa_def *origin = nir_build_load_gs_vertex_offset_amd(b, .base = vertex_index);
+   if (!st->gs_triangle_strip_adjacency_fix)
+      return origin;
+
+   unsigned fixed_index;
+   if (st->gfx_level < GFX9) {
+      /* Rotate vertex index by 2. */
+      fixed_index = (vertex_index + 4) % 6;
+   } else {
+      /* This issue has been fixed for GFX10+ */
+      assert(st->gfx_level == GFX9);
+      /* 6 vertex offset are packed to 3 vgprs for GFX9+ */
+      fixed_index = (vertex_index + 2) % 3;
+   }
+   nir_ssa_def *fixed = nir_build_load_gs_vertex_offset_amd(b, .base = fixed_index);
+
+   nir_ssa_def *prim_id = nir_load_primitive_id(b);
+   /* odd primitive id use fixed offset */
+   nir_ssa_def *cond = nir_i2b(b, nir_iand_imm(b, prim_id, 1));
+   return nir_bcsel(b, cond, fixed, origin);
+}
+
+static nir_ssa_def *
+gs_per_vertex_input_vertex_offset_gfx6(nir_builder *b, lower_esgs_io_state *st,
+                                       nir_src *vertex_src)
 {
    if (nir_src_is_const(*vertex_src))
-      return nir_build_load_gs_vertex_offset_amd(b, .base = nir_src_as_uint(*vertex_src));
+      return gs_get_vertex_offset(b, st, nir_src_as_uint(*vertex_src));
 
-   nir_ssa_def *vertex_offset = nir_build_load_gs_vertex_offset_amd(b, .base = 0);
+   nir_ssa_def *vertex_offset = gs_get_vertex_offset(b, st, 0);
 
    for (unsigned i = 1; i < b->shader->info.gs.vertices_in; ++i) {
       nir_ssa_def *cond = nir_ieq_imm(b, vertex_src->ssa, i);
-      nir_ssa_def *elem = nir_build_load_gs_vertex_offset_amd(b, .base = i);
+      nir_ssa_def *elem = gs_get_vertex_offset(b, st, i);
       vertex_offset = nir_bcsel(b, cond, elem, vertex_offset);
    }
 
@@ -197,19 +226,20 @@ gs_per_vertex_input_vertex_offset_gfx6(nir_builder *b, nir_src *vertex_src)
 }
 
 static nir_ssa_def *
-gs_per_vertex_input_vertex_offset_gfx9(nir_builder *b, nir_src *vertex_src)
+gs_per_vertex_input_vertex_offset_gfx9(nir_builder *b, lower_esgs_io_state *st,
+                                       nir_src *vertex_src)
 {
    if (nir_src_is_const(*vertex_src)) {
       unsigned vertex = nir_src_as_uint(*vertex_src);
-      return nir_ubfe(b, nir_build_load_gs_vertex_offset_amd(b, .base = vertex / 2u),
+      return nir_ubfe(b, gs_get_vertex_offset(b, st, vertex / 2u),
                       nir_imm_int(b, (vertex & 1u) * 16u), nir_imm_int(b, 16u));
    }
 
-   nir_ssa_def *vertex_offset = nir_build_load_gs_vertex_offset_amd(b, .base = 0);
+   nir_ssa_def *vertex_offset = gs_get_vertex_offset(b, st, 0);
 
    for (unsigned i = 1; i < b->shader->info.gs.vertices_in; i++) {
       nir_ssa_def *cond = nir_ieq_imm(b, vertex_src->ssa, i);
-      nir_ssa_def *elem = nir_build_load_gs_vertex_offset_amd(b, .base = i / 2u * 2u);
+      nir_ssa_def *elem = gs_get_vertex_offset(b, st, i / 2u * 2u);
       if (i % 2u)
          elem = nir_ishr_imm(b, elem, 16u);
 
@@ -226,8 +256,8 @@ gs_per_vertex_input_offset(nir_builder *b,
 {
    nir_src *vertex_src = nir_get_io_arrayed_index_src(instr);
    nir_ssa_def *vertex_offset = st->gfx_level >= GFX9
-                                ? gs_per_vertex_input_vertex_offset_gfx9(b, vertex_src)
-                                : gs_per_vertex_input_vertex_offset_gfx6(b, vertex_src);
+      ? gs_per_vertex_input_vertex_offset_gfx9(b, st, vertex_src)
+      : gs_per_vertex_input_vertex_offset_gfx6(b, st, vertex_src);
 
    unsigned base_stride = st->gfx_level >= GFX9 ? 1 : 64 /* Wave size on GFX6-8 */;
    nir_ssa_def *io_off = ac_nir_calc_io_offset(b, instr, nir_imm_int(b, base_stride * 4u), base_stride, st->map_io);
@@ -281,11 +311,13 @@ ac_nir_lower_es_outputs_to_mem(nir_shader *shader,
 void
 ac_nir_lower_gs_inputs_to_mem(nir_shader *shader,
                               ac_nir_map_io_driver_location map,
-                              enum amd_gfx_level gfx_level)
+                              enum amd_gfx_level gfx_level,
+                              bool triangle_strip_adjacency_fix)
 {
    lower_esgs_io_state state = {
       .gfx_level = gfx_level,
       .map_io = map,
+      .gs_triangle_strip_adjacency_fix = triangle_strip_adjacency_fix,
    };
 
    nir_shader_lower_instructions(shader,
diff --git a/src/amd/vulkan/radv_shader.c b/src/amd/vulkan/radv_shader.c
index 12183cea2335..cd95e5eb85ab 100644
--- a/src/amd/vulkan/radv_shader.c
+++ b/src/amd/vulkan/radv_shader.c
@@ -1100,7 +1100,7 @@ radv_lower_io_to_mem(struct radv_device *device, struct radv_pipeline_stage *sta
       return true;
    } else if (nir->info.stage == MESA_SHADER_GEOMETRY) {
       NIR_PASS_V(nir, ac_nir_lower_gs_inputs_to_mem, NULL,
-                 device->physical_device->rad_info.gfx_level);
+                 device->physical_device->rad_info.gfx_level, false);
       return true;
    } else if (nir->info.stage == MESA_SHADER_TASK) {
       ac_nir_apply_first_task_to_task_shader(nir);
-- 
GitLab


From a514d476ca6f943cee31426a24b1a8e81bebaad0 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Mon, 30 May 2022 19:49:55 +0800
Subject: [PATCH 38/39] amd/llvm: get back
 nir_intrinsic_load_gs_vertex_offset_amd

Will be used by radeonsi.

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/amd/llvm/ac_nir_to_llvm.c | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/src/amd/llvm/ac_nir_to_llvm.c b/src/amd/llvm/ac_nir_to_llvm.c
index 80927865350e..3e7e6b80fef3 100644
--- a/src/amd/llvm/ac_nir_to_llvm.c
+++ b/src/amd/llvm/ac_nir_to_llvm.c
@@ -4023,6 +4023,9 @@ static void visit_intrinsic(struct ac_nir_context *ctx, nir_intrinsic_instr *ins
       result = ac_build_gather_values(&ctx->ac, coord, 3);
       break;
    }
+   case nir_intrinsic_load_gs_vertex_offset_amd:
+      result = ac_get_arg(&ctx->ac, ctx->args->gs_vtx_offset[nir_intrinsic_base(instr)]);
+      break;
    case nir_intrinsic_vote_all: {
       result = ac_build_vote_all(&ctx->ac, get_src(ctx, instr->src[0]));
       break;
-- 
GitLab


From 19a99f3a5cfc177fa1af34d22e378bf17f69e8ae Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Mon, 30 May 2022 20:09:49 +0800
Subject: [PATCH 39/39] radeonsi: replace llvm gs input handle with nir
 lowering

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 src/amd/llvm/ac_nir_to_llvm.c                 |  7 ---
 src/gallium/drivers/radeonsi/si_shader.c      |  4 ++
 .../drivers/radeonsi/si_shader_internal.h     |  3 --
 src/gallium/drivers/radeonsi/si_shader_llvm.c | 27 ----------
 .../drivers/radeonsi/si_shader_llvm_gs.c      | 54 -------------------
 5 files changed, 4 insertions(+), 91 deletions(-)

diff --git a/src/amd/llvm/ac_nir_to_llvm.c b/src/amd/llvm/ac_nir_to_llvm.c
index 3e7e6b80fef3..1187120d3024 100644
--- a/src/amd/llvm/ac_nir_to_llvm.c
+++ b/src/amd/llvm/ac_nir_to_llvm.c
@@ -3463,13 +3463,6 @@ static LLVMValueRef visit_load(struct ac_nir_context *ctx, nir_intrinsic_instr *
    /* No indirect indexing is allowed after this point. */
    assert(!indir_index);
 
-   if (ctx->stage == MESA_SHADER_GEOMETRY) {
-      assert(nir_src_is_const(*vertex_index_src));
-
-      return ctx->abi->load_inputs(ctx->abi, base, component, count,
-                                   nir_src_as_uint(*vertex_index_src), component_type);
-   }
-
    if (ctx->stage == MESA_SHADER_FRAGMENT && is_output &&
        nir_intrinsic_io_semantics(instr).fb_fetch_output)
       return ctx->abi->emit_fbfetch(ctx->abi);
diff --git a/src/gallium/drivers/radeonsi/si_shader.c b/src/gallium/drivers/radeonsi/si_shader.c
index 022107755b52..5e45664eb8b4 100644
--- a/src/gallium/drivers/radeonsi/si_shader.c
+++ b/src/gallium/drivers/radeonsi/si_shader.c
@@ -1538,6 +1538,10 @@ static bool si_lower_io_to_mem(struct si_shader *shader, nir_shader *nir,
       }
 
       return true;
+   } else if (nir->info.stage == MESA_SHADER_GEOMETRY) {
+      NIR_PASS_V(nir, ac_nir_lower_gs_inputs_to_mem, si_map_io_driver_location,
+                 sel->screen->info.gfx_level, key->ge.mono.u.gs_tri_strip_adj_fix);
+      return true;
    }
 
    return false;
diff --git a/src/gallium/drivers/radeonsi/si_shader_internal.h b/src/gallium/drivers/radeonsi/si_shader_internal.h
index f4f4ed89fd95..348a20d06ccc 100644
--- a/src/gallium/drivers/radeonsi/si_shader_internal.h
+++ b/src/gallium/drivers/radeonsi/si_shader_internal.h
@@ -136,9 +136,6 @@ struct si_shader_context {
 
    struct ac_llvm_compiler *compiler;
 
-   /* GS vertex offsets unpacked with the gfx6-9 tristrip_adj bug workaround. */
-   LLVMValueRef gs_vtx_offset[6];
-
    /* Preloaded descriptors. */
    LLVMValueRef esgs_ring;
    LLVMValueRef gsvs_ring[4];
diff --git a/src/gallium/drivers/radeonsi/si_shader_llvm.c b/src/gallium/drivers/radeonsi/si_shader_llvm.c
index f36391d44035..78e6f72117a7 100644
--- a/src/gallium/drivers/radeonsi/si_shader_llvm.c
+++ b/src/gallium/drivers/radeonsi/si_shader_llvm.c
@@ -1042,33 +1042,6 @@ bool si_llvm_translate_nir(struct si_shader_context *ctx, struct si_shader *shad
       }
    }
 
-   if (nir->info.stage == MESA_SHADER_GEOMETRY) {
-      /* Unpack GS vertex offsets. */
-      for (unsigned i = 0; i < 6; i++) {
-         if (ctx->screen->info.gfx_level >= GFX9) {
-            ctx->gs_vtx_offset[i] = si_unpack_param(ctx, ctx->args.gs_vtx_offset[i / 2], (i & 1) * 16, 16);
-         } else {
-            ctx->gs_vtx_offset[i] = ac_get_arg(&ctx->ac, ctx->args.gs_vtx_offset[i]);
-         }
-      }
-
-      /* Apply the hw bug workaround for triangle strips with adjacency. */
-      if (ctx->screen->info.gfx_level <= GFX9 &&
-          ctx->shader->key.ge.mono.u.gs_tri_strip_adj_fix) {
-         LLVMValueRef prim_id = ac_get_arg(&ctx->ac, ctx->args.gs_prim_id);
-         /* Remap GS vertex offsets for every other primitive. */
-         LLVMValueRef rotate = LLVMBuildTrunc(ctx->ac.builder, prim_id, ctx->ac.i1, "");
-         LLVMValueRef fixed[6];
-
-         for (unsigned i = 0; i < 6; i++) {
-            fixed[i] = LLVMBuildSelect(ctx->ac.builder, rotate,
-                                       ctx->gs_vtx_offset[(i + 4) % 6],
-                                       ctx->gs_vtx_offset[i], "");
-         }
-         memcpy(ctx->gs_vtx_offset, fixed, sizeof(fixed));
-      }
-   }
-
    ctx->abi.clamp_shadow_reference = true;
    ctx->abi.robust_buffer_access = true;
    ctx->abi.convert_undef_to_zero = true;
diff --git a/src/gallium/drivers/radeonsi/si_shader_llvm_gs.c b/src/gallium/drivers/radeonsi/si_shader_llvm_gs.c
index 7157126fda43..d566348f3eea 100644
--- a/src/gallium/drivers/radeonsi/si_shader_llvm_gs.c
+++ b/src/gallium/drivers/radeonsi/si_shader_llvm_gs.c
@@ -43,59 +43,6 @@ LLVMValueRef si_is_gs_thread(struct si_shader_context *ctx)
                         si_unpack_param(ctx, ctx->args.merged_wave_info, 8, 8), "");
 }
 
-static LLVMValueRef si_llvm_load_input_gs(struct ac_shader_abi *abi, unsigned input_index,
-                                          unsigned vtx_offset_param, LLVMTypeRef type,
-                                          unsigned swizzle)
-{
-   struct si_shader_context *ctx = si_shader_context_from_abi(abi);
-   struct si_shader *shader = ctx->shader;
-   LLVMValueRef vtx_offset, soffset;
-   struct si_shader_info *info = &shader->selector->info;
-   unsigned param;
-   LLVMValueRef value;
-
-   param = si_shader_io_get_unique_index(info->input[input_index].semantic, false);
-
-   /* GFX9 has the ESGS ring in LDS. */
-   if (ctx->screen->info.gfx_level >= GFX9) {
-      unsigned offset = param * 4 + swizzle;
-
-      vtx_offset = LLVMBuildAdd(ctx->ac.builder, ctx->gs_vtx_offset[vtx_offset_param],
-                                LLVMConstInt(ctx->ac.i32, offset, false), "");
-
-      LLVMValueRef ptr = ac_build_gep0(&ctx->ac, ctx->esgs_ring, vtx_offset);
-      LLVMValueRef value = LLVMBuildLoad(ctx->ac.builder, ptr, "");
-      return LLVMBuildBitCast(ctx->ac.builder, value, type, "");
-   }
-
-   /* GFX6: input load from the ESGS ring in memory. */
-   /* Get the vertex offset parameter on GFX6. */
-   vtx_offset = LLVMBuildMul(ctx->ac.builder, ctx->gs_vtx_offset[vtx_offset_param],
-                             LLVMConstInt(ctx->ac.i32, 4, 0), "");
-
-   soffset = LLVMConstInt(ctx->ac.i32, (param * 4 + swizzle) * 256, 0);
-
-   value = ac_build_buffer_load(&ctx->ac, ctx->esgs_ring, 1, ctx->ac.i32_0, vtx_offset, soffset,
-                                ctx->ac.f32, ac_glc, true, false);
-   return LLVMBuildBitCast(ctx->ac.builder, value, type, "");
-}
-
-static LLVMValueRef si_nir_load_input_gs(struct ac_shader_abi *abi,
-                                         unsigned driver_location, unsigned component,
-                                         unsigned num_components, unsigned vertex_index,
-                                         LLVMTypeRef type)
-{
-   struct si_shader_context *ctx = si_shader_context_from_abi(abi);
-
-   LLVMValueRef value[4];
-   for (unsigned i = component; i < component + num_components; i++) {
-      value[i] = si_llvm_load_input_gs(&ctx->abi, driver_location,
-                                       vertex_index, type, i);
-   }
-
-   return ac_build_varying_gather_values(&ctx->ac, value, num_components, component);
-}
-
 /* Pass GS inputs from ES to GS on GFX9. */
 static void si_set_es_return_value_for_gs(struct si_shader_context *ctx)
 {
@@ -593,7 +540,6 @@ struct si_shader *si_generate_gs_copy_shader(struct si_screen *sscreen,
 
 void si_llvm_init_gs_callbacks(struct si_shader_context *ctx)
 {
-   ctx->abi.load_inputs = si_nir_load_input_gs;
    ctx->abi.emit_vertex = si_llvm_emit_vertex;
    ctx->abi.emit_primitive = si_llvm_emit_primitive;
 }
-- 
GitLab

