From d481ff2db22ae52c91c3699f4b2f72c1eb064772 Mon Sep 17 00:00:00 2001
From: Georg Lehmann <dadschoorse@gmail.com>
Date: Wed, 28 Sep 2022 13:45:25 +0200
Subject: [PATCH 1/6] aco/optimizer: Cleanup ctx.uses handling for patterns
 which use follow_operand(..., true).

No Foz-DB changes.

Signed-off-by: Georg Lehmann <dadschoorse@gmail.com>
---
 src/amd/compiler/aco_optimizer.cpp | 68 ++++++++++++++++--------------
 1 file changed, 36 insertions(+), 32 deletions(-)

diff --git a/src/amd/compiler/aco_optimizer.cpp b/src/amd/compiler/aco_optimizer.cpp
index 945da8879bab..9c5d9ec53a86 100644
--- a/src/amd/compiler/aco_optimizer.cpp
+++ b/src/amd/compiler/aco_optimizer.cpp
@@ -2064,9 +2064,9 @@ original_temp_id(opt_ctx& ctx, Temp tmp)
 }
 
 void
-decrease_uses(opt_ctx& ctx, Instruction* instr)
+decrease_op_uses_if_dead(opt_ctx& ctx, Instruction* instr)
 {
-   if (!--ctx.uses[instr->definitions[0].tempId()]) {
+   if (is_dead(ctx.uses, instr)) {
       for (const Operand& op : instr->operands) {
          if (op.isTemp())
             ctx.uses[op.tempId()]--;
@@ -2074,6 +2074,21 @@ decrease_uses(opt_ctx& ctx, Instruction* instr)
    }
 }
 
+void
+decrease_uses(opt_ctx& ctx, Instruction* instr)
+{
+   ctx.uses[instr->definitions[0].tempId()]--;
+   decrease_op_uses_if_dead(ctx, instr);
+}
+
+Operand
+copy_operand(opt_ctx& ctx, Operand op)
+{
+   if (op.isTemp())
+      ctx.uses[op.tempId()]++;
+   return op;
+}
+
 Instruction*
 follow_operand(opt_ctx& ctx, Operand op, bool ignore_uses = false)
 {
@@ -2154,11 +2169,6 @@ combine_ordering_test(opt_ctx& ctx, aco_ptr<Instruction>& instr)
    if (num_sgprs > (ctx.program->gfx_level >= GFX10 ? 2 : 1))
       return false;
 
-   ctx.uses[op[0].id()]++;
-   ctx.uses[op[1].id()]++;
-   decrease_uses(ctx, op_instr[0]);
-   decrease_uses(ctx, op_instr[1]);
-
    aco_opcode new_op = aco_opcode::num_opcodes;
    switch (bitsize) {
    case 16: new_op = is_or ? aco_opcode::v_cmp_u_f16 : aco_opcode::v_cmp_o_f16; break;
@@ -2178,10 +2188,13 @@ combine_ordering_test(opt_ctx& ctx, aco_ptr<Instruction>& instr)
    } else {
       new_instr = create_instruction<VOPC_instruction>(new_op, Format::VOPC, 2, 1);
    }
-   new_instr->operands[0] = Operand(op[0]);
-   new_instr->operands[1] = Operand(op[1]);
+   new_instr->operands[0] = copy_operand(ctx, Operand(op[0]));
+   new_instr->operands[1] = copy_operand(ctx, Operand(op[1]));
    new_instr->definitions[0] = instr->definitions[0];
 
+   decrease_uses(ctx, op_instr[0]);
+   decrease_uses(ctx, op_instr[1]);
+
    ctx.info[instr->definitions[0].tempId()].label = 0;
    ctx.info[instr->definitions[0].tempId()].set_vopc(new_instr);
 
@@ -2232,11 +2245,6 @@ combine_comparison_ordering(opt_ctx& ctx, aco_ptr<Instruction>& instr)
    if (prop_cmp1 != prop_nan0 && prop_cmp1 != prop_nan1)
       return false;
 
-   ctx.uses[cmp->operands[0].tempId()]++;
-   ctx.uses[cmp->operands[1].tempId()]++;
-   decrease_uses(ctx, nan_test);
-   decrease_uses(ctx, cmp);
-
    aco_opcode new_op = is_or ? get_unordered(cmp->opcode) : get_ordered(cmp->opcode);
    Instruction* new_instr;
    if (cmp->isVOP3()) {
@@ -2252,10 +2260,13 @@ combine_comparison_ordering(opt_ctx& ctx, aco_ptr<Instruction>& instr)
    } else {
       new_instr = create_instruction<VOPC_instruction>(new_op, Format::VOPC, 2, 1);
    }
-   new_instr->operands[0] = cmp->operands[0];
-   new_instr->operands[1] = cmp->operands[1];
+   new_instr->operands[0] = copy_operand(ctx, cmp->operands[0]);
+   new_instr->operands[1] = copy_operand(ctx, cmp->operands[1]);
    new_instr->definitions[0] = instr->definitions[0];
 
+   decrease_uses(ctx, nan_test);
+   decrease_uses(ctx, cmp);
+
    ctx.info[instr->definitions[0].tempId()].label = 0;
    ctx.info[instr->definitions[0].tempId()].set_vopc(new_instr);
 
@@ -2355,13 +2366,6 @@ combine_constant_comparison_ordering(opt_ctx& ctx, aco_ptr<Instruction>& instr)
    if (is_constant_nan(constant_value, bit_size))
       return false;
 
-   if (cmp->operands[0].isTemp())
-      ctx.uses[cmp->operands[0].tempId()]++;
-   if (cmp->operands[1].isTemp())
-      ctx.uses[cmp->operands[1].tempId()]++;
-   decrease_uses(ctx, nan_test);
-   decrease_uses(ctx, cmp);
-
    aco_opcode new_op = is_or ? get_unordered(cmp->opcode) : get_ordered(cmp->opcode);
    Instruction* new_instr;
    if (cmp->isVOP3()) {
@@ -2377,10 +2381,13 @@ combine_constant_comparison_ordering(opt_ctx& ctx, aco_ptr<Instruction>& instr)
    } else {
       new_instr = create_instruction<VOPC_instruction>(new_op, Format::VOPC, 2, 1);
    }
-   new_instr->operands[0] = cmp->operands[0];
-   new_instr->operands[1] = cmp->operands[1];
+   new_instr->operands[0] = copy_operand(ctx, cmp->operands[0]);
+   new_instr->operands[1] = copy_operand(ctx, cmp->operands[1]);
    new_instr->definitions[0] = instr->definitions[0];
 
+   decrease_uses(ctx, nan_test);
+   decrease_uses(ctx, cmp);
+
    ctx.info[instr->definitions[0].tempId()].label = 0;
    ctx.info[instr->definitions[0].tempId()].set_vopc(new_instr);
 
@@ -2740,9 +2747,9 @@ combine_salu_lshl_add(opt_ctx& ctx, aco_ptr<Instruction>& instr)
           instr->operands[!i].constantValue() != op2_instr->operands[0].constantValue())
          continue;
 
-      ctx.uses[instr->operands[i].tempId()]--;
       instr->operands[1] = instr->operands[!i];
-      instr->operands[0] = op2_instr->operands[0];
+      instr->operands[0] = copy_operand(ctx, op2_instr->operands[0]);
+      decrease_uses(ctx, op2_instr);
       ctx.info[instr->definitions[0].tempId()].label = 0;
 
       instr->opcode = std::array<aco_opcode, 4>{
@@ -3293,15 +3300,12 @@ combine_and_subbrev(opt_ctx& ctx, aco_ptr<Instruction>& instr)
             return false;
          }
 
-         ctx.uses[instr->operands[i].tempId()]--;
-         if (ctx.uses[instr->operands[i].tempId()])
-            ctx.uses[op_instr->operands[2].tempId()]++;
-
          new_instr->operands[0] = Operand::zero();
          new_instr->operands[1] = instr->operands[!i];
-         new_instr->operands[2] = Operand(op_instr->operands[2]);
+         new_instr->operands[2] = copy_operand(ctx, op_instr->operands[2]);
          new_instr->definitions[0] = instr->definitions[0];
          instr = std::move(new_instr);
+         decrease_uses(ctx, op_instr);
          ctx.info[instr->definitions[0].tempId()].label = 0;
          return true;
       }
-- 
GitLab


From b2f364544db821c8f73701e29cd6e6572e766225 Mon Sep 17 00:00:00 2001
From: Georg Lehmann <dadschoorse@gmail.com>
Date: Wed, 28 Sep 2022 14:37:19 +0200
Subject: [PATCH 2/6] aco: Ignore instructions with exec operands in
 follow_operand.

No Foz-DB changes.

Signed-off-by: Georg Lehmann <dadschoorse@gmail.com>
---
 src/amd/compiler/aco_optimizer.cpp | 11 +++++++----
 1 file changed, 7 insertions(+), 4 deletions(-)

diff --git a/src/amd/compiler/aco_optimizer.cpp b/src/amd/compiler/aco_optimizer.cpp
index 9c5d9ec53a86..f4382a554d6e 100644
--- a/src/amd/compiler/aco_optimizer.cpp
+++ b/src/amd/compiler/aco_optimizer.cpp
@@ -2105,6 +2105,11 @@ follow_operand(opt_ctx& ctx, Operand op, bool ignore_uses = false)
          return nullptr;
    }
 
+   for (Operand& operand : instr->operands) {
+      if (fixed_to_exec(operand))
+         return nullptr;
+   }
+
    return instr;
 }
 
@@ -2437,8 +2442,6 @@ match_op3_for_vop3(opt_ctx& ctx, aco_opcode op1, aco_opcode op2, Instruction* op
    Instruction* op2_instr = follow_operand(ctx, op1_instr->operands[swap]);
    if (!op2_instr || op2_instr->opcode != op2)
       return false;
-   if (fixed_to_exec(op2_instr->operands[0]) || fixed_to_exec(op2_instr->operands[1]))
-      return false;
 
    VOP3_instruction* op1_vop3 = op1_instr->isVOP3() ? &op1_instr->vop3() : NULL;
    VOP3_instruction* op2_vop3 = op2_instr->isVOP3() ? &op2_instr->vop3() : NULL;
@@ -2699,7 +2702,7 @@ combine_salu_n2(opt_ctx& ctx, aco_ptr<Instruction>& instr)
       if (!op2_instr || (op2_instr->opcode != aco_opcode::s_not_b32 &&
                          op2_instr->opcode != aco_opcode::s_not_b64))
          continue;
-      if (ctx.uses[op2_instr->definitions[1].tempId()] || fixed_to_exec(op2_instr->operands[0]))
+      if (ctx.uses[op2_instr->definitions[1].tempId()])
          continue;
 
       if (instr->operands[!i].isLiteral() && op2_instr->operands[0].isLiteral() &&
@@ -2736,7 +2739,7 @@ combine_salu_lshl_add(opt_ctx& ctx, aco_ptr<Instruction>& instr)
       if (!op2_instr || op2_instr->opcode != aco_opcode::s_lshl_b32 ||
           ctx.uses[op2_instr->definitions[1].tempId()])
          continue;
-      if (!op2_instr->operands[1].isConstant() || fixed_to_exec(op2_instr->operands[0]))
+      if (!op2_instr->operands[1].isConstant())
          continue;
 
       uint32_t shift = op2_instr->operands[1].constantValue();
-- 
GitLab


From 50b91cd9d3c718c1a50538c0d4ff6c21c3e67d1d Mon Sep 17 00:00:00 2001
From: Georg Lehmann <dadschoorse@gmail.com>
Date: Fri, 23 Sep 2022 19:00:36 +0200
Subject: [PATCH 3/6] aco: Combine s_abs and s_sub/s_add to s_absdiff.

Foz-DB Navi21:
Totals from 3 (0.00% of 134913) affected shaders:
CodeSize: 9156 -> 9152 (-0.04%); split: -0.09%, +0.04%
Instrs: 1571 -> 1569 (-0.13%)

Signed-off-by: Georg Lehmann <dadschoorse@gmail.com>
---
 src/amd/compiler/aco_optimizer.cpp | 65 ++++++++++++++++++++++++++++++
 1 file changed, 65 insertions(+)

diff --git a/src/amd/compiler/aco_optimizer.cpp b/src/amd/compiler/aco_optimizer.cpp
index f4382a554d6e..9cfc150c2c01 100644
--- a/src/amd/compiler/aco_optimizer.cpp
+++ b/src/amd/compiler/aco_optimizer.cpp
@@ -2764,6 +2764,67 @@ combine_salu_lshl_add(opt_ctx& ctx, aco_ptr<Instruction>& instr)
    return false;
 }
 
+/* s_abs_i32(s_sub_[iu]32(a, b)) -> s_absdiff_i32(a, b) */
+bool
+combine_sabs_sub(opt_ctx& ctx, aco_ptr<Instruction>& instr)
+{
+   Instruction* op_instr = follow_operand(ctx, instr->operands[0], true);
+   if (!op_instr ||
+       (op_instr->opcode != aco_opcode::s_sub_i32 && op_instr->opcode != aco_opcode::s_sub_u32))
+      return false;
+
+   Definition def0 = instr->definitions[0], def1 = instr->definitions[1];
+   instr.reset(create_instruction<SOP2_instruction>(aco_opcode::s_absdiff_i32, Format::SOP2, 2, 2));
+   instr->definitions[0] = def0;
+   instr->definitions[1] = def1;
+   for (unsigned i = 0; i < 2; i++)
+      instr->operands[i] = copy_operand(ctx, op_instr->operands[i]);
+   decrease_uses(ctx, op_instr);
+   return true;
+}
+
+bool
+operand_is_constant(opt_ctx& ctx, Operand op, uint32_t* value)
+{
+   if (op.isConstant()) {
+      *value = op.constantValue();
+      return true;
+   } else if (op.isTemp() && ctx.info[op.tempId()].is_literal(32)) {
+      *value = ctx.info[op.tempId()].val;
+      return true;
+   }
+   return false;
+}
+
+/* s_abs_i32(s_add_[iu]32(a, #b)) -> s_absdiff_i32(a, -b) */
+bool
+combine_sabs_add(opt_ctx& ctx, aco_ptr<Instruction>& instr)
+{
+   Instruction* op_instr = follow_operand(ctx, instr->operands[0], true);
+   if (!op_instr ||
+       (op_instr->opcode != aco_opcode::s_add_i32 && op_instr->opcode != aco_opcode::s_add_u32))
+      return false;
+
+   for (unsigned i = 0; i < 2; i++) {
+      uint32_t constant;
+      if (op_instr->operands[!i].isLiteral() ||
+          !operand_is_constant(ctx, op_instr->operands[i], &constant))
+         continue;
+
+      Definition def0 = instr->definitions[0], def1 = instr->definitions[1];
+      instr.reset(
+         create_instruction<SOP2_instruction>(aco_opcode::s_absdiff_i32, Format::SOP2, 2, 2));
+      instr->definitions[0] = def0;
+      instr->definitions[1] = def1;
+      instr->operands[0] = copy_operand(ctx, op_instr->operands[!i]);
+      instr->operands[1] = Operand::c32(-constant);
+      decrease_uses(ctx, op_instr);
+      return true;
+   }
+
+   return false;
+}
+
 bool
 combine_add_sub_b2i(opt_ctx& ctx, aco_ptr<Instruction>& instr, aco_opcode new_op, uint8_t ops)
 {
@@ -4177,6 +4238,10 @@ combine_instruction(opt_ctx& ctx, aco_ptr<Instruction>& instr)
       } else if (combine_constant_comparison_ordering(ctx, instr)) {
       } else if (combine_salu_n2(ctx, instr)) {
       }
+   } else if (instr->opcode == aco_opcode::s_abs_i32) {
+      if (combine_sabs_sub(ctx, instr)) {
+      } else if (combine_sabs_add(ctx, instr)) {
+      }
    } else if (instr->opcode == aco_opcode::v_and_b32) {
       combine_and_subbrev(ctx, instr);
    } else if (instr->opcode == aco_opcode::v_fma_f32 || instr->opcode == aco_opcode::v_fma_f16) {
-- 
GitLab


From 0bd6b69e1801f86d5afd22dc38a9970b6d5f5e6f Mon Sep 17 00:00:00 2001
From: Georg Lehmann <dadschoorse@gmail.com>
Date: Sat, 24 Sep 2022 17:18:22 +0200
Subject: [PATCH 4/6] aco: Combine (1 << a) - 1 to s_bfm_b32(a, 0).

Foz-DB Navi21:
Totals from 303 (0.22% of 134913) affected shaders:
SpillVGPRs: 2246 -> 2238 (-0.36%); split: -0.85%, +0.49%
CodeSize: 1841480 -> 1839084 (-0.13%); split: -0.19%, +0.06%
Scratch: 219136 -> 221184 (+0.93%)
Instrs: 325324 -> 324945 (-0.12%); split: -0.16%, +0.04%
Latency: 6043264 -> 5963795 (-1.32%); split: -1.63%, +0.31%
InvThroughput: 2779301 -> 2739583 (-1.43%); split: -1.77%, +0.34%
VClause: 7818 -> 7837 (+0.24%); split: -0.22%, +0.46%
SClause: 8680 -> 8643 (-0.43%)
Copies: 61553 -> 61285 (-0.44%); split: -0.68%, +0.24%
Branches: 9935 -> 9931 (-0.04%); split: -0.05%, +0.01%

Signed-off-by: Georg Lehmann <dadschoorse@gmail.com>
---
 src/amd/compiler/aco_optimizer.cpp | 35 +++++++++++++++++++++++++++---
 1 file changed, 32 insertions(+), 3 deletions(-)

diff --git a/src/amd/compiler/aco_optimizer.cpp b/src/amd/compiler/aco_optimizer.cpp
index 9cfc150c2c01..d4f2bec3b3b9 100644
--- a/src/amd/compiler/aco_optimizer.cpp
+++ b/src/amd/compiler/aco_optimizer.cpp
@@ -2825,6 +2825,34 @@ combine_sabs_add(opt_ctx& ctx, aco_ptr<Instruction>& instr)
    return false;
 }
 
+/* s_add_[iu]_32(s_lshl_b32(1, a), -1) -> s_bfm_b32(a, 0) */
+bool
+combine_s_add_lhsl_to_bfm(opt_ctx& ctx, aco_ptr<Instruction>& instr)
+{
+   if (ctx.uses[instr->definitions[1].tempId()])
+      return false;
+
+   for (unsigned shift_idx = 0; shift_idx < 2; shift_idx++) {
+      if (!instr->operands[!shift_idx].constantEquals(-1))
+         continue;
+
+      Instruction* op_instr = follow_operand(ctx, instr->operands[shift_idx], true);
+      if (!op_instr || op_instr->opcode != aco_opcode::s_lshl_b32 ||
+          !op_instr->operands[0].constantEquals(1))
+         continue;
+
+      ctx.info[instr->definitions[0].tempId()].label = 0;
+      instr->opcode = aco_opcode::s_bfm_b32;
+      instr->definitions.pop_back();
+      instr->operands[0] = copy_operand(ctx, op_instr->operands[1]);
+      instr->operands[1] = Operand::zero();
+      decrease_uses(ctx, op_instr);
+      return true;
+   }
+
+   return false;
+}
+
 bool
 combine_add_sub_b2i(opt_ctx& ctx, aco_ptr<Instruction>& instr, aco_opcode new_op, uint8_t ops)
 {
@@ -4225,9 +4253,10 @@ combine_instruction(opt_ctx& ctx, aco_ptr<Instruction>& instr)
    } else if (instr->opcode == aco_opcode::v_lshlrev_b32 && ctx.program->gfx_level >= GFX9) {
       combine_three_valu_op(ctx, instr, aco_opcode::v_add_u32, aco_opcode::v_add_lshl_u32, "120",
                             2);
-   } else if ((instr->opcode == aco_opcode::s_add_u32 || instr->opcode == aco_opcode::s_add_i32) &&
-              ctx.program->gfx_level >= GFX9) {
-      combine_salu_lshl_add(ctx, instr);
+   } else if (instr->opcode == aco_opcode::s_add_u32 || instr->opcode == aco_opcode::s_add_i32) {
+      if (ctx.program->gfx_level >= GFX9 && combine_salu_lshl_add(ctx, instr)) {
+      } else if (combine_s_add_lhsl_to_bfm(ctx, instr)) {
+      }
    } else if (instr->opcode == aco_opcode::s_not_b32 || instr->opcode == aco_opcode::s_not_b64) {
       if (!combine_salu_not_bitwise(ctx, instr))
          combine_inverse_comparison(ctx, instr);
-- 
GitLab


From e15ca89402a4b509d64192cf2f23e3df74975c38 Mon Sep 17 00:00:00 2001
From: Georg Lehmann <dadschoorse@gmail.com>
Date: Sat, 24 Sep 2022 17:31:45 +0200
Subject: [PATCH 5/6] aco: Combine s_bfm_b32(a, 0) << b to s_bfm_b32(a, b).

No Foz-DB changes.

Signed-off-by: Georg Lehmann <dadschoorse@gmail.com>
---
 src/amd/compiler/aco_optimizer.cpp | 23 +++++++++++++++++++++++
 1 file changed, 23 insertions(+)

diff --git a/src/amd/compiler/aco_optimizer.cpp b/src/amd/compiler/aco_optimizer.cpp
index d4f2bec3b3b9..b8657fded7fb 100644
--- a/src/amd/compiler/aco_optimizer.cpp
+++ b/src/amd/compiler/aco_optimizer.cpp
@@ -2847,12 +2847,33 @@ combine_s_add_lhsl_to_bfm(opt_ctx& ctx, aco_ptr<Instruction>& instr)
       instr->operands[0] = copy_operand(ctx, op_instr->operands[1]);
       instr->operands[1] = Operand::zero();
       decrease_uses(ctx, op_instr);
+      ctx.info[instr->definitions[0].tempId()].set_usedef(instr.get());
       return true;
    }
 
    return false;
 }
 
+/* s_lshl_b32(s_bfm_b32(a, 0), b) -> s_bfm_b32(a, b) */
+bool
+combine_s_lshl_bfm0(opt_ctx& ctx, aco_ptr<Instruction>& instr)
+{
+   if (ctx.uses[instr->definitions[1].tempId()])
+      return false;
+
+   Instruction* op_instr = follow_operand(ctx, instr->operands[0], true);
+   if (!op_instr || op_instr->opcode != aco_opcode::s_bfm_b32 ||
+       !op_instr->operands[1].constantEquals(0) ||
+       (op_instr->operands[0].isLiteral() && instr->operands[1].isLiteral()))
+      return false;
+
+   instr->opcode = aco_opcode::s_bfm_b32;
+   instr->definitions.pop_back();
+   instr->operands[0] = copy_operand(ctx, op_instr->operands[0]);
+   decrease_uses(ctx, op_instr);
+   return true;
+}
+
 bool
 combine_add_sub_b2i(opt_ctx& ctx, aco_ptr<Instruction>& instr, aco_opcode new_op, uint8_t ops)
 {
@@ -4271,6 +4292,8 @@ combine_instruction(opt_ctx& ctx, aco_ptr<Instruction>& instr)
       if (combine_sabs_sub(ctx, instr)) {
       } else if (combine_sabs_add(ctx, instr)) {
       }
+   } else if (instr->opcode == aco_opcode::s_lshl_b32) {
+      combine_s_lshl_bfm0(ctx, instr);
    } else if (instr->opcode == aco_opcode::v_and_b32) {
       combine_and_subbrev(ctx, instr);
    } else if (instr->opcode == aco_opcode::v_fma_f32 || instr->opcode == aco_opcode::v_fma_f16) {
-- 
GitLab


From 7dae3a40b1e93643f566f30371bf7610e95d5d1c Mon Sep 17 00:00:00 2001
From: Georg Lehmann <dadschoorse@gmail.com>
Date: Sat, 24 Sep 2022 18:49:10 +0200
Subject: [PATCH 6/6] aco: Combine bit test to s_bitcmp.

Foz-DB Navi21:
Totals from 6396 (4.74% of 134913) affected shaders:
VGPRs: 483280 -> 483152 (-0.03%); split: -0.03%, +0.01%
SpillSGPRs: 8119 -> 7941 (-2.19%)
CodeSize: 63377916 -> 63268592 (-0.17%); split: -0.20%, +0.03%
MaxWaves: 86778 -> 86810 (+0.04%)
Instrs: 11745630 -> 11725866 (-0.17%); split: -0.20%, +0.03%
Latency: 162400152 -> 162282235 (-0.07%); split: -0.08%, +0.01%
InvThroughput: 29179429 -> 29133173 (-0.16%); split: -0.16%, +0.00%
VClause: 208032 -> 208100 (+0.03%); split: -0.01%, +0.05%
SClause: 431390 -> 430849 (-0.13%); split: -0.24%, +0.11%
Copies: 896222 -> 893285 (-0.33%); split: -0.62%, +0.30%
Branches: 349815 -> 348779 (-0.30%); split: -0.90%, +0.60%
PreSGPRs: 618908 -> 613773 (-0.83%); split: -0.83%, +0.00%
PreVGPRs: 482901 -> 482893 (-0.00%)

Signed-off-by: Georg Lehmann <dadschoorse@gmail.com>
---
 src/amd/compiler/aco_optimizer.cpp | 69 ++++++++++++++++++++++++++++++
 1 file changed, 69 insertions(+)

diff --git a/src/amd/compiler/aco_optimizer.cpp b/src/amd/compiler/aco_optimizer.cpp
index b8657fded7fb..e2402787c5e2 100644
--- a/src/amd/compiler/aco_optimizer.cpp
+++ b/src/amd/compiler/aco_optimizer.cpp
@@ -2874,6 +2874,68 @@ combine_s_lshl_bfm0(opt_ctx& ctx, aco_ptr<Instruction>& instr)
    return true;
 }
 
+/* s_cmp_{lg,eq}(s_and(a, s_lshl(1, b)), 0) -> s_bitcmp[10](a, b)*/
+bool
+combine_s_bitcmp(opt_ctx& ctx, aco_ptr<Instruction>& instr)
+{
+   bool lg = false;
+   bool b64 = false;
+   switch (instr->opcode) {
+   case aco_opcode::s_cmp_lg_i32:
+   case aco_opcode::s_cmp_lg_u32: lg = true; break;
+   case aco_opcode::s_cmp_eq_i32:
+   case aco_opcode::s_cmp_eq_u32: break;
+   case aco_opcode::s_cmp_lg_u64: lg = true; FALLTHROUGH;
+   case aco_opcode::s_cmp_eq_u64: b64 = true; break;
+   default: return false;
+   }
+
+   aco_opcode s_and = b64 ? aco_opcode::s_and_b64 : aco_opcode::s_and_b32;
+   aco_opcode s_lshl = b64 ? aco_opcode::s_lshl_b64 : aco_opcode::s_lshl_b32;
+
+   for (unsigned cmp_idx = 0; cmp_idx < 2; cmp_idx++) {
+      Instruction* and_instr = follow_operand(ctx, instr->operands[cmp_idx], false);
+      if (!and_instr || and_instr->opcode != s_and)
+         continue;
+
+      for (unsigned and_idx = 0; and_idx < 2; and_idx++) {
+         Instruction* lshl_instr = follow_operand(ctx, and_instr->operands[and_idx], true);
+         if (!lshl_instr || lshl_instr->opcode != s_lshl ||
+             !lshl_instr->operands[0].constantEquals(1) ||
+             (lshl_instr->operands[1].isLiteral() && and_instr->operands[!and_idx].isLiteral()))
+            continue;
+
+         bool test1 = false;
+         if (instr->operands[!cmp_idx].constantEquals(0)) {
+            test1 = lg;
+         } else if (instr->operands[!cmp_idx].isTemp() &&
+                    instr->operands[!cmp_idx].tempId() == lshl_instr->definitions[0].tempId()) {
+            test1 = !lg;
+            ctx.uses[lshl_instr->definitions[0].tempId()]--;
+         } else {
+            continue;
+         }
+
+         if (test1 && b64)
+            instr->opcode = aco_opcode::s_bitcmp1_b64;
+         else if (!test1 && b64)
+            instr->opcode = aco_opcode::s_bitcmp0_b64;
+         else if (test1 && !b64)
+            instr->opcode = aco_opcode::s_bitcmp1_b32;
+         else
+            instr->opcode = aco_opcode::s_bitcmp0_b32;
+
+         instr->operands[0] = copy_operand(ctx, and_instr->operands[!and_idx]);
+         instr->operands[1] = copy_operand(ctx, lshl_instr->operands[1]);
+         decrease_uses(ctx, and_instr);
+         decrease_op_uses_if_dead(ctx, lshl_instr);
+         return true;
+      }
+   }
+
+   return false;
+}
+
 bool
 combine_add_sub_b2i(opt_ctx& ctx, aco_ptr<Instruction>& instr, aco_opcode new_op, uint8_t ops)
 {
@@ -4294,6 +4356,13 @@ combine_instruction(opt_ctx& ctx, aco_ptr<Instruction>& instr)
       }
    } else if (instr->opcode == aco_opcode::s_lshl_b32) {
       combine_s_lshl_bfm0(ctx, instr);
+   } else if (instr->opcode == aco_opcode::s_cmp_lg_i32 ||
+              instr->opcode == aco_opcode::s_cmp_lg_u32 ||
+              instr->opcode == aco_opcode::s_cmp_lg_u64 ||
+              instr->opcode == aco_opcode::s_cmp_eq_i32 ||
+              instr->opcode == aco_opcode::s_cmp_eq_u32 ||
+              instr->opcode == aco_opcode::s_cmp_eq_u64) {
+      combine_s_bitcmp(ctx, instr);
    } else if (instr->opcode == aco_opcode::v_and_b32) {
       combine_and_subbrev(ctx, instr);
    } else if (instr->opcode == aco_opcode::v_fma_f32 || instr->opcode == aco_opcode::v_fma_f16) {
-- 
GitLab

