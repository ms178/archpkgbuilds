From 0c6784a81d983f8a9c64b6f9cbf39d5dbd154629 Mon Sep 17 00:00:00 2001
From: Georg Lehmann <dadschoorse@gmail.com>
Date: Wed, 28 Sep 2022 13:45:25 +0200
Subject: [PATCH 1/5] aco/optimizer: Cleanup ctx.uses handling for patterns
 which use follow_operand(..., true).

No Foz-DB changes.

Signed-off-by: Georg Lehmann <dadschoorse@gmail.com>
---
 src/amd/compiler/aco_optimizer.cpp | 68 ++++++++++++++++--------------
 1 file changed, 36 insertions(+), 32 deletions(-)

diff --git a/src/amd/compiler/aco_optimizer.cpp b/src/amd/compiler/aco_optimizer.cpp
index 96d5eddf77e9..fb88c86f47d1 100644
--- a/src/amd/compiler/aco_optimizer.cpp
+++ b/src/amd/compiler/aco_optimizer.cpp
@@ -2064,9 +2064,9 @@ original_temp_id(opt_ctx& ctx, Temp tmp)
 }
 
 void
-decrease_uses(opt_ctx& ctx, Instruction* instr)
+decrease_op_uses_if_dead(opt_ctx& ctx, Instruction* instr)
 {
-   if (!--ctx.uses[instr->definitions[0].tempId()]) {
+   if (is_dead(ctx.uses, instr)) {
       for (const Operand& op : instr->operands) {
          if (op.isTemp())
             ctx.uses[op.tempId()]--;
@@ -2074,6 +2074,21 @@ decrease_uses(opt_ctx& ctx, Instruction* instr)
    }
 }
 
+void
+decrease_uses(opt_ctx& ctx, Instruction* instr)
+{
+   ctx.uses[instr->definitions[0].tempId()]--;
+   decrease_op_uses_if_dead(ctx, instr);
+}
+
+Operand
+copy_operand(opt_ctx& ctx, Operand op)
+{
+   if (op.isTemp())
+      ctx.uses[op.tempId()]++;
+   return op;
+}
+
 Instruction*
 follow_operand(opt_ctx& ctx, Operand op, bool ignore_uses = false)
 {
@@ -2154,11 +2169,6 @@ combine_ordering_test(opt_ctx& ctx, aco_ptr<Instruction>& instr)
    if (num_sgprs > (ctx.program->gfx_level >= GFX10 ? 2 : 1))
       return false;
 
-   ctx.uses[op[0].id()]++;
-   ctx.uses[op[1].id()]++;
-   decrease_uses(ctx, op_instr[0]);
-   decrease_uses(ctx, op_instr[1]);
-
    aco_opcode new_op = aco_opcode::num_opcodes;
    switch (bitsize) {
    case 16: new_op = is_or ? aco_opcode::v_cmp_u_f16 : aco_opcode::v_cmp_o_f16; break;
@@ -2178,10 +2188,13 @@ combine_ordering_test(opt_ctx& ctx, aco_ptr<Instruction>& instr)
    } else {
       new_instr = create_instruction<VOPC_instruction>(new_op, Format::VOPC, 2, 1);
    }
-   new_instr->operands[0] = Operand(op[0]);
-   new_instr->operands[1] = Operand(op[1]);
+   new_instr->operands[0] = copy_operand(ctx, Operand(op[0]));
+   new_instr->operands[1] = copy_operand(ctx, Operand(op[1]));
    new_instr->definitions[0] = instr->definitions[0];
 
+   decrease_uses(ctx, op_instr[0]);
+   decrease_uses(ctx, op_instr[1]);
+
    ctx.info[instr->definitions[0].tempId()].label = 0;
    ctx.info[instr->definitions[0].tempId()].set_vopc(new_instr);
 
@@ -2232,11 +2245,6 @@ combine_comparison_ordering(opt_ctx& ctx, aco_ptr<Instruction>& instr)
    if (prop_cmp1 != prop_nan0 && prop_cmp1 != prop_nan1)
       return false;
 
-   ctx.uses[cmp->operands[0].tempId()]++;
-   ctx.uses[cmp->operands[1].tempId()]++;
-   decrease_uses(ctx, nan_test);
-   decrease_uses(ctx, cmp);
-
    aco_opcode new_op = is_or ? get_unordered(cmp->opcode) : get_ordered(cmp->opcode);
    Instruction* new_instr;
    if (cmp->isVOP3()) {
@@ -2252,10 +2260,13 @@ combine_comparison_ordering(opt_ctx& ctx, aco_ptr<Instruction>& instr)
    } else {
       new_instr = create_instruction<VOPC_instruction>(new_op, Format::VOPC, 2, 1);
    }
-   new_instr->operands[0] = cmp->operands[0];
-   new_instr->operands[1] = cmp->operands[1];
+   new_instr->operands[0] = copy_operand(ctx, cmp->operands[0]);
+   new_instr->operands[1] = copy_operand(ctx, cmp->operands[1]);
    new_instr->definitions[0] = instr->definitions[0];
 
+   decrease_uses(ctx, nan_test);
+   decrease_uses(ctx, cmp);
+
    ctx.info[instr->definitions[0].tempId()].label = 0;
    ctx.info[instr->definitions[0].tempId()].set_vopc(new_instr);
 
@@ -2355,13 +2366,6 @@ combine_constant_comparison_ordering(opt_ctx& ctx, aco_ptr<Instruction>& instr)
    if (is_constant_nan(constant_value, bit_size))
       return false;
 
-   if (cmp->operands[0].isTemp())
-      ctx.uses[cmp->operands[0].tempId()]++;
-   if (cmp->operands[1].isTemp())
-      ctx.uses[cmp->operands[1].tempId()]++;
-   decrease_uses(ctx, nan_test);
-   decrease_uses(ctx, cmp);
-
    aco_opcode new_op = is_or ? get_unordered(cmp->opcode) : get_ordered(cmp->opcode);
    Instruction* new_instr;
    if (cmp->isVOP3()) {
@@ -2377,10 +2381,13 @@ combine_constant_comparison_ordering(opt_ctx& ctx, aco_ptr<Instruction>& instr)
    } else {
       new_instr = create_instruction<VOPC_instruction>(new_op, Format::VOPC, 2, 1);
    }
-   new_instr->operands[0] = cmp->operands[0];
-   new_instr->operands[1] = cmp->operands[1];
+   new_instr->operands[0] = copy_operand(ctx, cmp->operands[0]);
+   new_instr->operands[1] = copy_operand(ctx, cmp->operands[1]);
    new_instr->definitions[0] = instr->definitions[0];
 
+   decrease_uses(ctx, nan_test);
+   decrease_uses(ctx, cmp);
+
    ctx.info[instr->definitions[0].tempId()].label = 0;
    ctx.info[instr->definitions[0].tempId()].set_vopc(new_instr);
 
@@ -2740,9 +2747,9 @@ combine_salu_lshl_add(opt_ctx& ctx, aco_ptr<Instruction>& instr)
           instr->operands[!i].constantValue() != op2_instr->operands[0].constantValue())
          continue;
 
-      ctx.uses[instr->operands[i].tempId()]--;
       instr->operands[1] = instr->operands[!i];
-      instr->operands[0] = op2_instr->operands[0];
+      instr->operands[0] = copy_operand(ctx, op2_instr->operands[0]);
+      decrease_uses(ctx, op2_instr);
       ctx.info[instr->definitions[0].tempId()].label = 0;
 
       instr->opcode = std::array<aco_opcode, 4>{
@@ -3293,15 +3300,12 @@ combine_and_subbrev(opt_ctx& ctx, aco_ptr<Instruction>& instr)
             return false;
          }
 
-         ctx.uses[instr->operands[i].tempId()]--;
-         if (ctx.uses[instr->operands[i].tempId()])
-            ctx.uses[op_instr->operands[2].tempId()]++;
-
          new_instr->operands[0] = Operand::zero();
          new_instr->operands[1] = instr->operands[!i];
-         new_instr->operands[2] = Operand(op_instr->operands[2]);
+         new_instr->operands[2] = copy_operand(ctx, op_instr->operands[2]);
          new_instr->definitions[0] = instr->definitions[0];
          instr = std::move(new_instr);
+         decrease_uses(ctx, op_instr);
          ctx.info[instr->definitions[0].tempId()].label = 0;
          return true;
       }
-- 
GitLab


From 72ff53744ba90de6a9151b4811162894455968af Mon Sep 17 00:00:00 2001
From: Georg Lehmann <dadschoorse@gmail.com>
Date: Wed, 28 Sep 2022 14:37:19 +0200
Subject: [PATCH 2/5] aco: Ignore instructions with exec operands in
 follow_operand.

No Foz-DB changes.

Signed-off-by: Georg Lehmann <dadschoorse@gmail.com>
---
 src/amd/compiler/aco_optimizer.cpp | 11 +++++++----
 1 file changed, 7 insertions(+), 4 deletions(-)

diff --git a/src/amd/compiler/aco_optimizer.cpp b/src/amd/compiler/aco_optimizer.cpp
index fb88c86f47d1..bd073eb30139 100644
--- a/src/amd/compiler/aco_optimizer.cpp
+++ b/src/amd/compiler/aco_optimizer.cpp
@@ -2105,6 +2105,11 @@ follow_operand(opt_ctx& ctx, Operand op, bool ignore_uses = false)
          return nullptr;
    }
 
+   for (Operand& operand : instr->operands) {
+      if (fixed_to_exec(operand))
+         return nullptr;
+   }
+
    return instr;
 }
 
@@ -2437,8 +2442,6 @@ match_op3_for_vop3(opt_ctx& ctx, aco_opcode op1, aco_opcode op2, Instruction* op
    Instruction* op2_instr = follow_operand(ctx, op1_instr->operands[swap]);
    if (!op2_instr || op2_instr->opcode != op2)
       return false;
-   if (fixed_to_exec(op2_instr->operands[0]) || fixed_to_exec(op2_instr->operands[1]))
-      return false;
 
    VOP3_instruction* op1_vop3 = op1_instr->isVOP3() ? &op1_instr->vop3() : NULL;
    VOP3_instruction* op2_vop3 = op2_instr->isVOP3() ? &op2_instr->vop3() : NULL;
@@ -2699,7 +2702,7 @@ combine_salu_n2(opt_ctx& ctx, aco_ptr<Instruction>& instr)
       if (!op2_instr || (op2_instr->opcode != aco_opcode::s_not_b32 &&
                          op2_instr->opcode != aco_opcode::s_not_b64))
          continue;
-      if (ctx.uses[op2_instr->definitions[1].tempId()] || fixed_to_exec(op2_instr->operands[0]))
+      if (ctx.uses[op2_instr->definitions[1].tempId()])
          continue;
 
       if (instr->operands[!i].isLiteral() && op2_instr->operands[0].isLiteral() &&
@@ -2736,7 +2739,7 @@ combine_salu_lshl_add(opt_ctx& ctx, aco_ptr<Instruction>& instr)
       if (!op2_instr || op2_instr->opcode != aco_opcode::s_lshl_b32 ||
           ctx.uses[op2_instr->definitions[1].tempId()])
          continue;
-      if (!op2_instr->operands[1].isConstant() || fixed_to_exec(op2_instr->operands[0]))
+      if (!op2_instr->operands[1].isConstant())
          continue;
 
       uint32_t shift = op2_instr->operands[1].constantValue();
-- 
GitLab


From 0e572e1fdfc0384fa1161df33fd8e9265e6b7988 Mon Sep 17 00:00:00 2001
From: Georg Lehmann <dadschoorse@gmail.com>
Date: Fri, 23 Sep 2022 19:00:36 +0200
Subject: [PATCH 3/5] aco: Combine s_abs and s_sub/s_add to s_absdiff.

Totals from 2 (0.00% of 134913) affected shaders:
CodeSize: 1344 -> 1336 (-0.60%)
Instrs: 277 -> 275 (-0.72%)

Signed-off-by: Georg Lehmann <dadschoorse@gmail.com>
---
 src/amd/compiler/aco_optimizer.cpp | 49 ++++++++++++++++++++++++++++++
 1 file changed, 49 insertions(+)

diff --git a/src/amd/compiler/aco_optimizer.cpp b/src/amd/compiler/aco_optimizer.cpp
index bd073eb30139..ed817d6c1fee 100644
--- a/src/amd/compiler/aco_optimizer.cpp
+++ b/src/amd/compiler/aco_optimizer.cpp
@@ -2764,6 +2764,51 @@ combine_salu_lshl_add(opt_ctx& ctx, aco_ptr<Instruction>& instr)
    return false;
 }
 
+/* s_abs_i32(s_sub_[iu]32(a, b)) -> s_absdiff_i32(a, b) */
+bool
+combine_sabs_sub(opt_ctx& ctx, aco_ptr<Instruction>& instr)
+{
+   Instruction* op_instr = follow_operand(ctx, instr->operands[0], false);
+   if (!op_instr ||
+       (op_instr->opcode != aco_opcode::s_sub_i32 && op_instr->opcode != aco_opcode::s_sub_u32))
+      return false;
+
+   op_instr->opcode = aco_opcode::s_absdiff_i32;
+   std::swap(instr->definitions[0], op_instr->definitions[0]);
+   std::swap(instr->definitions[1], op_instr->definitions[1]);
+   ctx.uses[instr->operands[0].tempId()]--;
+
+   return true;
+}
+
+/* s_abs_i32(s_add_[iu]32(a, #b)) -> s_absdiff_i32(a, -b) */
+bool
+combine_sabs_add(opt_ctx& ctx, aco_ptr<Instruction>& instr)
+{
+   Instruction* op_instr = follow_operand(ctx, instr->operands[0], false);
+   if (!op_instr ||
+       (op_instr->opcode != aco_opcode::s_add_i32 && op_instr->opcode != aco_opcode::s_add_u32))
+      return false;
+
+   for (unsigned i = 0; i < 2; i++) {
+      uint64_t constant;
+      if (op_instr->operands[!i].isLiteral() ||
+          !is_operand_constant(ctx, op_instr->operands[i], 32, &constant))
+         continue;
+
+      op_instr->opcode = aco_opcode::s_absdiff_i32;
+      std::swap(instr->definitions[0], op_instr->definitions[0]);
+      std::swap(instr->definitions[1], op_instr->definitions[1]);
+      ctx.uses[instr->operands[0].tempId()]--;
+      if (op_instr->operands[i].isTemp())
+         ctx.uses[op_instr->operands[i].tempId()]--;
+      op_instr->operands[i] = Operand::c32(-int32_t(constant));
+      return true;
+   }
+
+   return false;
+}
+
 bool
 combine_add_sub_b2i(opt_ctx& ctx, aco_ptr<Instruction>& instr, aco_opcode new_op, uint8_t ops)
 {
@@ -4177,6 +4222,10 @@ combine_instruction(opt_ctx& ctx, aco_ptr<Instruction>& instr)
       } else if (combine_constant_comparison_ordering(ctx, instr)) {
       } else if (combine_salu_n2(ctx, instr)) {
       }
+   } else if (instr->opcode == aco_opcode::s_abs_i32) {
+      if (combine_sabs_sub(ctx, instr)) {
+      } else if (combine_sabs_add(ctx, instr)) {
+      }
    } else if (instr->opcode == aco_opcode::v_and_b32) {
       combine_and_subbrev(ctx, instr);
    } else if (instr->opcode == aco_opcode::v_fma_f32 || instr->opcode == aco_opcode::v_fma_f16) {
-- 
GitLab


From 4c8cfa71da4397a1ead4d87a7ebbb4d86e3bc0bc Mon Sep 17 00:00:00 2001
From: Georg Lehmann <dadschoorse@gmail.com>
Date: Sat, 24 Sep 2022 18:49:10 +0200
Subject: [PATCH 4/5] aco: Combine bit test to s_bitcmp.

Foz-DB Navi21:
Totals from 6396 (4.74% of 134913) affected shaders:
VGPRs: 483280 -> 483152 (-0.03%); split: -0.03%, +0.01%
SpillSGPRs: 8119 -> 7941 (-2.19%)
CodeSize: 63377880 -> 63268556 (-0.17%); split: -0.20%, +0.03%
MaxWaves: 86778 -> 86810 (+0.04%)
Instrs: 11745621 -> 11725857 (-0.17%); split: -0.20%, +0.03%
Latency: 162400148 -> 162282230 (-0.07%); split: -0.08%, +0.01%
InvThroughput: 29179429 -> 29133173 (-0.16%); split: -0.16%, +0.00%
VClause: 208032 -> 208100 (+0.03%); split: -0.01%, +0.05%
SClause: 431390 -> 430849 (-0.13%); split: -0.24%, +0.11%
Copies: 896222 -> 893285 (-0.33%); split: -0.62%, +0.30%
Branches: 349806 -> 348770 (-0.30%); split: -0.90%, +0.60%
PreSGPRs: 618908 -> 613773 (-0.83%); split: -0.83%, +0.00%
PreVGPRs: 482901 -> 482893 (-0.00%)

Signed-off-by: Georg Lehmann <dadschoorse@gmail.com>
---
 src/amd/compiler/aco_optimizer.cpp | 69 ++++++++++++++++++++++++++++++
 1 file changed, 69 insertions(+)

diff --git a/src/amd/compiler/aco_optimizer.cpp b/src/amd/compiler/aco_optimizer.cpp
index ed817d6c1fee..ccbc3f95c1ae 100644
--- a/src/amd/compiler/aco_optimizer.cpp
+++ b/src/amd/compiler/aco_optimizer.cpp
@@ -2809,6 +2809,68 @@ combine_sabs_add(opt_ctx& ctx, aco_ptr<Instruction>& instr)
    return false;
 }
 
+/* s_cmp_{lg,eq}(s_and(a, s_lshl(1, b)), 0) -> s_bitcmp[10](a, b)*/
+bool
+combine_s_bitcmp(opt_ctx& ctx, aco_ptr<Instruction>& instr)
+{
+   bool lg = false;
+   bool b64 = false;
+   switch (instr->opcode) {
+   case aco_opcode::s_cmp_lg_i32:
+   case aco_opcode::s_cmp_lg_u32: lg = true; break;
+   case aco_opcode::s_cmp_eq_i32:
+   case aco_opcode::s_cmp_eq_u32: break;
+   case aco_opcode::s_cmp_lg_u64: lg = true; FALLTHROUGH;
+   case aco_opcode::s_cmp_eq_u64: b64 = true; break;
+   default: return false;
+   }
+
+   aco_opcode s_and = b64 ? aco_opcode::s_and_b64 : aco_opcode::s_and_b32;
+   aco_opcode s_lshl = b64 ? aco_opcode::s_lshl_b64 : aco_opcode::s_lshl_b32;
+
+   for (unsigned cmp_idx = 0; cmp_idx < 2; cmp_idx++) {
+      Instruction* and_instr = follow_operand(ctx, instr->operands[cmp_idx], false);
+      if (!and_instr || and_instr->opcode != s_and)
+         continue;
+
+      for (unsigned and_idx = 0; and_idx < 2; and_idx++) {
+         Instruction* lshl_instr = follow_operand(ctx, and_instr->operands[and_idx], true);
+         if (!lshl_instr || lshl_instr->opcode != s_lshl ||
+             !lshl_instr->operands[0].constantEquals(1) ||
+             (lshl_instr->operands[1].isLiteral() && and_instr->operands[!and_idx].isLiteral()))
+            continue;
+
+         bool test1 = false;
+         if (instr->operands[!cmp_idx].constantEquals(0)) {
+            test1 = lg;
+         } else if (instr->operands[!cmp_idx].isTemp() &&
+                    instr->operands[!cmp_idx].tempId() == lshl_instr->definitions[0].tempId()) {
+            test1 = !lg;
+            ctx.uses[lshl_instr->definitions[0].tempId()]--;
+         } else {
+            continue;
+         }
+
+         if (test1 && b64)
+            instr->opcode = aco_opcode::s_bitcmp1_b64;
+         else if (!test1 && b64)
+            instr->opcode = aco_opcode::s_bitcmp0_b64;
+         else if (test1 && !b64)
+            instr->opcode = aco_opcode::s_bitcmp1_b32;
+         else
+            instr->opcode = aco_opcode::s_bitcmp0_b32;
+
+         instr->operands[0] = copy_operand(ctx, and_instr->operands[!and_idx]);
+         instr->operands[1] = copy_operand(ctx, lshl_instr->operands[1]);
+         decrease_uses(ctx, and_instr);
+         decrease_op_uses_if_dead(ctx, lshl_instr);
+         return true;
+      }
+   }
+
+   return false;
+}
+
 bool
 combine_add_sub_b2i(opt_ctx& ctx, aco_ptr<Instruction>& instr, aco_opcode new_op, uint8_t ops)
 {
@@ -4226,6 +4288,13 @@ combine_instruction(opt_ctx& ctx, aco_ptr<Instruction>& instr)
       if (combine_sabs_sub(ctx, instr)) {
       } else if (combine_sabs_add(ctx, instr)) {
       }
+   } else if (instr->opcode == aco_opcode::s_cmp_lg_i32 ||
+              instr->opcode == aco_opcode::s_cmp_lg_u32 ||
+              instr->opcode == aco_opcode::s_cmp_lg_u64 ||
+              instr->opcode == aco_opcode::s_cmp_eq_i32 ||
+              instr->opcode == aco_opcode::s_cmp_eq_u32 ||
+              instr->opcode == aco_opcode::s_cmp_eq_u64) {
+      combine_s_bitcmp(ctx, instr);
    } else if (instr->opcode == aco_opcode::v_and_b32) {
       combine_and_subbrev(ctx, instr);
    } else if (instr->opcode == aco_opcode::v_fma_f32 || instr->opcode == aco_opcode::v_fma_f16) {
-- 
GitLab


From c681bafab66be5e567496e4620f21ac86bfd1edc Mon Sep 17 00:00:00 2001
From: Georg Lehmann <dadschoorse@gmail.com>
Date: Tue, 18 Oct 2022 15:48:21 +0200
Subject: [PATCH 5/5] aco: Combine constant bit test to s_bitcmp.

Foz-DB Navi21:
Totals from 73988 (54.84% of 134913) affected shaders:
VGPRs: 2959768 -> 2959752 (-0.00%)
SpillSGPRs: 10250 -> 10697 (+4.36%); split: -0.64%, +5.00%
SpillVGPRs: 2326 -> 2291 (-1.50%); split: -2.24%, +0.73%
CodeSize: 261339476 -> 261045912 (-0.11%); split: -0.12%, +0.00%
Scratch: 239616 -> 238592 (-0.43%)
Instrs: 49214044 -> 49188242 (-0.05%); split: -0.06%, +0.00%
Latency: 413214139 -> 413296229 (+0.02%); split: -0.03%, +0.05%
InvThroughput: 71741622 -> 71786300 (+0.06%); split: -0.07%, +0.13%
VClause: 856838 -> 856973 (+0.02%); split: -0.01%, +0.02%
SClause: 1504502 -> 1504567 (+0.00%); split: -0.01%, +0.02%
Copies: 4058433 -> 4060424 (+0.05%); split: -0.03%, +0.08%
Branches: 1502953 -> 1502945 (-0.00%); split: -0.00%, +0.00%
PreSGPRs: 3081927 -> 3081531 (-0.01%); split: -0.02%, +0.01%
PreVGPRs: 2513990 -> 2513992 (+0.00%)

The vast majority of instruction count regressions are caused by parallel-rdp.

Signed-off-by: Georg Lehmann <dadschoorse@gmail.com>
---
 src/amd/compiler/aco_optimizer.cpp | 25 +++++++++++++++++++++++++
 1 file changed, 25 insertions(+)

diff --git a/src/amd/compiler/aco_optimizer.cpp b/src/amd/compiler/aco_optimizer.cpp
index ccbc3f95c1ae..a66d90cb3733 100644
--- a/src/amd/compiler/aco_optimizer.cpp
+++ b/src/amd/compiler/aco_optimizer.cpp
@@ -2866,6 +2866,31 @@ combine_s_bitcmp(opt_ctx& ctx, aco_ptr<Instruction>& instr)
          decrease_op_uses_if_dead(ctx, lshl_instr);
          return true;
       }
+
+      if (instr->operands[!cmp_idx].constantEquals(0)) {
+         for (unsigned and_idx = 0; and_idx < 2; and_idx++) {
+            uint64_t constant;
+            if (!is_operand_constant(ctx, and_instr->operands[and_idx], b64 ? 64 : 32, &constant) ||
+                !util_is_power_of_two_or_zero64(constant) || constant == 0)
+               continue;
+
+            if (lg && b64)
+               instr->opcode = aco_opcode::s_bitcmp1_b64;
+            else if (!lg && b64)
+               instr->opcode = aco_opcode::s_bitcmp0_b64;
+            else if (lg && !b64)
+               instr->opcode = aco_opcode::s_bitcmp1_b32;
+            else
+               instr->opcode = aco_opcode::s_bitcmp0_b32;
+
+            instr->operands[0] = copy_operand(ctx, and_instr->operands[!and_idx]);
+            instr->operands[1] = Operand::c32(ffsll(constant) - 1);
+            decrease_uses(ctx, and_instr);
+            if (and_instr->operands[and_idx].isTemp())
+               ctx.uses[and_instr->operands[and_idx].tempId()]--;
+            return true;
+         }
+      }
    }
 
    return false;
-- 
GitLab

