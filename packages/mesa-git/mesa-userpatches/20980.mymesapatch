From 1eee488be33515aafbee7a9580d04cacf1e896ab Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Timur=20Krist=C3=B3f?= <timur.kristof@gmail.com>
Date: Mon, 30 Jan 2023 02:45:05 +0100
Subject: [PATCH 1/5] radv: Don't change LDS_SIZE for NGG culling shaders.
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

There was no measurable perf benefit from this optimization,
and it made the code messy and difficult to refactor.

Signed-off-by: Timur Kristóf <timur.kristof@gmail.com>
Reviewed-by: Bas Nieuwenhuizen <bas@basnieuwenhuizen.nl>
---
 src/amd/vulkan/radv_cmd_buffer.c  | 34 -------------------------------
 src/amd/vulkan/radv_shader.h      |  1 -
 src/amd/vulkan/radv_shader_info.c | 13 ------------
 3 files changed, 48 deletions(-)

diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index eecebadd9fd3..c5b138694281 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -1860,19 +1860,6 @@ radv_emit_graphics_pipeline(struct radv_cmd_buffer *cmd_buffer)
 
    radeon_emit_array(cmd_buffer->cs, pipeline->base.cs.buf, pipeline->base.cs.cdw);
 
-   if (pipeline->has_ngg_culling &&
-       pipeline->last_vgt_api_stage != MESA_SHADER_GEOMETRY &&
-       !cmd_buffer->state.last_nggc_settings) {
-      /* The already emitted RSRC2 contains the LDS required for NGG culling.
-       * Culling is currently disabled, so re-emit RSRC2 to reduce LDS usage.
-       * API GS always needs LDS, so this isn't useful there.
-       */
-      struct radv_shader *v = pipeline->base.shaders[pipeline->last_vgt_api_stage];
-      radeon_set_sh_reg(cmd_buffer->cs, R_00B22C_SPI_SHADER_PGM_RSRC2_GS,
-                        (v->config.rsrc2 & C_00B22C_LDS_SIZE) |
-                        S_00B22C_LDS_SIZE(v->info.num_lds_blocks_when_not_culling));
-   }
-
    if (!cmd_buffer->state.emitted_graphics_pipeline ||
        cmd_buffer->state.emitted_graphics_pipeline->base.ctx_cs.cdw != pipeline->base.ctx_cs.cdw ||
        cmd_buffer->state.emitted_graphics_pipeline->base.ctx_cs_hash != pipeline->base.ctx_cs_hash ||
@@ -8540,27 +8527,6 @@ radv_emit_ngg_culling_state(struct radv_cmd_buffer *cmd_buffer, const struct rad
       radeon_set_sh_reg(cmd_buffer->cs, base_reg + nggc_sgpr_idx * 4, nggc_settings);
    }
 
-   /* These only need to be emitted when culling is turned on or off,
-    * but not when it stays on and just some settings change.
-    */
-   if (!!cmd_buffer->state.last_nggc_settings != !!nggc_settings) {
-      uint32_t rsrc2 = v->config.rsrc2;
-
-      if (!nggc_settings) {
-         /* Allocate less LDS when culling is disabled. (But GS always needs it.) */
-         if (stage != MESA_SHADER_GEOMETRY)
-            rsrc2 = (rsrc2 & C_00B22C_LDS_SIZE) | S_00B22C_LDS_SIZE(v->info.num_lds_blocks_when_not_culling);
-      }
-
-      /* When the pipeline is dirty and not yet emitted, don't write it here
-       * because radv_emit_graphics_pipeline will overwrite this register.
-       */
-      if (!(cmd_buffer->state.dirty & RADV_CMD_DIRTY_PIPELINE) ||
-          cmd_buffer->state.emitted_graphics_pipeline == pipeline) {
-         radeon_set_sh_reg(cmd_buffer->cs, R_00B22C_SPI_SHADER_PGM_RSRC2_GS, rsrc2);
-      }
-   }
-
    cmd_buffer->state.last_nggc_settings = nggc_settings;
    cmd_buffer->state.last_nggc_settings_sgpr_idx = nggc_sgpr_idx;
 }
diff --git a/src/amd/vulkan/radv_shader.h b/src/amd/vulkan/radv_shader.h
index 3069b69159f7..baef6822623a 100644
--- a/src/amd/vulkan/radv_shader.h
+++ b/src/amd/vulkan/radv_shader.h
@@ -253,7 +253,6 @@ struct radv_shader_info {
    bool has_ngg_early_prim_export;
    bool has_ngg_prim_query;
    bool has_ngg_xfb_query;
-   uint32_t num_lds_blocks_when_not_culling;
    uint32_t num_tess_patches;
    uint32_t esgs_itemsize; /* Only for VS or TES as ES */
    struct radv_vs_output_info outinfo;
diff --git a/src/amd/vulkan/radv_shader_info.c b/src/amd/vulkan/radv_shader_info.c
index c04711673e03..43d311fa0623 100644
--- a/src/amd/vulkan/radv_shader_info.c
+++ b/src/amd/vulkan/radv_shader_info.c
@@ -1271,19 +1271,6 @@ radv_determine_ngg_settings(struct radv_device *device, struct radv_pipeline_sta
    nir_function_impl *impl = nir_shader_get_entrypoint(es_stage->nir);
    es_stage->info.has_ngg_early_prim_export = exec_list_is_singular(&impl->body);
 
-   /* Invocations that process an input vertex */
-   const struct gfx10_ngg_info *ngg_info = &es_stage->info.ngg_info;
-   unsigned max_vtx_in = MIN2(256, ngg_info->hw_max_esverts);
-
-   unsigned lds_bytes_if_culling_off = 0;
-   /* We need LDS space when VS needs to export the primitive ID. */
-   if (es_stage->stage == MESA_SHADER_VERTEX && es_stage->info.outinfo.export_prim_id)
-      lds_bytes_if_culling_off = max_vtx_in * 4u;
-
-   es_stage->info.num_lds_blocks_when_not_culling =
-      DIV_ROUND_UP(lds_bytes_if_culling_off,
-                   device->physical_device->rad_info.lds_encode_granularity);
-
    /* NGG passthrough mode should be disabled when culling and when the vertex shader
     * exports the primitive ID.
     */
-- 
GitLab


From 692c243438bb23454053f8bb89b5aef98d92b030 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Timur=20Krist=C3=B3f?= <timur.kristof@gmail.com>
Date: Mon, 30 Jan 2023 02:53:07 +0100
Subject: [PATCH 2/5] radv: Move checking primitive topology to
 radv_get_ngg_culling_settings.
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Signed-off-by: Timur Kristóf <timur.kristof@gmail.com>
Reviewed-by: Bas Nieuwenhuizen <bas@basnieuwenhuizen.nl>
---
 src/amd/vulkan/radv_cmd_buffer.c | 21 ++++++++++-----------
 1 file changed, 10 insertions(+), 11 deletions(-)

diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index c5b138694281..ca0d89bfe419 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -8357,8 +8357,6 @@ radv_skip_ngg_culling(struct radv_cmd_buffer *cmd_buffer,
                       const struct radv_graphics_pipeline *pipeline,
                       const struct radv_draw_info *draw_info)
 {
-   const struct radv_dynamic_state *d = &cmd_buffer->state.dynamic;
-
    /* If we have to draw only a few vertices, we get better latency if
     * we disable NGG culling.
     *
@@ -8371,14 +8369,6 @@ radv_skip_ngg_culling(struct radv_cmd_buffer *cmd_buffer,
    if (!draw_info->indirect && draw_info->count < 128)
       return true;
 
-   /* With graphics pipeline library, NGG culling is enabled unconditionally because we don't know
-    * the primitive topology at compile time, but we should still disable it dynamically for points
-    * or lines.
-    */
-   unsigned num_vertices_per_prim = si_conv_prim_to_gs_out(d->vk.ia.primitive_topology) + 1;
-   if (num_vertices_per_prim != 3)
-      return true;
-
    return false;
 }
 
@@ -8394,6 +8384,14 @@ radv_get_ngg_culling_settings(struct radv_cmd_buffer *cmd_buffer, bool vp_y_inve
    if (d->vk.rs.conservative_mode == VK_CONSERVATIVE_RASTERIZATION_MODE_OVERESTIMATE_EXT)
       return radv_nggc_none;
 
+   /* With graphics pipeline library, NGG culling is unconditionally compiled into shaders
+    * because we don't know the primitive topology at compile time, so we should
+    * disable it dynamically for points or lines.
+    */
+   const unsigned num_vertices_per_prim = si_conv_prim_to_gs_out(d->vk.ia.primitive_topology) + 1;
+   if (num_vertices_per_prim != 3)
+      return radv_nggc_none;
+
    /* Cull every triangle when rasterizer discard is enabled. */
    if (d->vk.rs.rasterizer_discard_enable)
       return radv_nggc_front_face | radv_nggc_back_face;
@@ -8458,7 +8456,8 @@ radv_emit_ngg_culling_state(struct radv_cmd_buffer *cmd_buffer, const struct rad
       (RADV_CMD_DIRTY_PIPELINE |
        RADV_CMD_DIRTY_DYNAMIC_CULL_MODE | RADV_CMD_DIRTY_DYNAMIC_FRONT_FACE |
        RADV_CMD_DIRTY_DYNAMIC_RASTERIZER_DISCARD_ENABLE | RADV_CMD_DIRTY_DYNAMIC_VIEWPORT |
-       RADV_CMD_DIRTY_DYNAMIC_CONSERVATIVE_RAST_MODE | RADV_CMD_DIRTY_DYNAMIC_RASTERIZATION_SAMPLES);
+       RADV_CMD_DIRTY_DYNAMIC_CONSERVATIVE_RAST_MODE | RADV_CMD_DIRTY_DYNAMIC_RASTERIZATION_SAMPLES |
+       RADV_CMD_DIRTY_DYNAMIC_PRIMITIVE_TOPOLOGY);
 
    /* Check small draw status:
     * For small draw calls, we disable culling by setting the SGPR to 0.
-- 
GitLab


From 82be3d9bc14512bdfc9cdc1d6ed32270bd615bd8 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Timur=20Krist=C3=B3f?= <timur.kristof@gmail.com>
Date: Mon, 30 Jan 2023 04:48:00 +0100
Subject: [PATCH 3/5] radv: Use shader code to skip NGG culling in small
 workgroups.
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Extend RADV lowering of the load_cull_any_enabled_amd intrinsic to
take into account the number of primitives in the current workgroup.

Workgroups that have less than 16 triangles are considered "small"
and will disable shader culling. Note that LLPC does the same,
but it checks the number of vertices not primitives.

The primary intention of this change is to eliminate the need to
check the draw size in radv_cmd_buffer, but this is actually
beneficial to larger draw calls too, specifically this may improve
the performance of the last workgroup of larger draws too.

Signed-off-by: Timur Kristóf <timur.kristof@gmail.com>
Reviewed-by: Bas Nieuwenhuizen <bas@basnieuwenhuizen.nl>
---
 src/amd/vulkan/radv_nir_lower_abi.c | 21 ++++++++++++++++++---
 1 file changed, 18 insertions(+), 3 deletions(-)

diff --git a/src/amd/vulkan/radv_nir_lower_abi.c b/src/amd/vulkan/radv_nir_lower_abi.c
index 6ee8bd4ea130..f458e7c01469 100644
--- a/src/amd/vulkan/radv_nir_lower_abi.c
+++ b/src/amd/vulkan/radv_nir_lower_abi.c
@@ -266,10 +266,25 @@ lower_abi_instr(nir_builder *b, nir_instr *instr, void *state)
    case nir_intrinsic_load_merged_wave_info_amd:
       replacement = ac_nir_load_arg(b, &s->args->ac, s->args->ac.merged_wave_info);
       break;
-   case nir_intrinsic_load_cull_any_enabled_amd:
-      replacement = nggc_bool_setting(
-         b, radv_nggc_front_face | radv_nggc_back_face | radv_nggc_small_primitives, s);
+   case nir_intrinsic_load_cull_any_enabled_amd: {
+      nir_ssa_def *gs_tg_info = ac_nir_load_arg(b, &s->args->ac, s->args->ac.gs_tg_info);
+
+      /* Consider a workgroup small if it contains less than 16 triangles.
+       *
+       * The gs_tg_info[30:22] is the number of primitives, which we know is non-zero,
+       * so the below is equivalent to: "ult(ubfe(gs_tg_info, 22, 9), 16)", but
+       * ACO can optimize out the comparison to zero (see try_optimize_scc_nocompare).
+       */
+      nir_ssa_def *small_workgroup =
+         nir_ieq_imm(b, nir_iand_imm(b, gs_tg_info, BITFIELD_RANGE(22 + 4, 9 - 4)), 0);
+
+      nir_ssa_def *mask = nir_bcsel(
+         b, small_workgroup, nir_imm_int(b, radv_nggc_none),
+         nir_imm_int(b, radv_nggc_front_face | radv_nggc_back_face | radv_nggc_small_primitives));
+      nir_ssa_def *settings = ac_nir_load_arg(b, &s->args->ac, s->args->ngg_culling_settings);
+      replacement = nir_ine_imm(b, nir_iand(b, settings, mask), 0);
       break;
+   }
    case nir_intrinsic_load_cull_front_face_enabled_amd:
       replacement = nggc_bool_setting(b, radv_nggc_front_face, s);
       break;
-- 
GitLab


From f342181c4eeb13d2d127bc7f3da80e6d518bcdd5 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Timur=20Krist=C3=B3f?= <timur.kristof@gmail.com>
Date: Mon, 30 Jan 2023 04:02:23 +0100
Subject: [PATCH 4/5] radv: Remove NGG culling skip from command buffer.
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

This code used to runtime-disable NGG culling for small draw calls.
However, this had too much CPU overhead, let's remove it.
It will be solved by the shaders instead.

Signed-off-by: Timur Kristóf <timur.kristof@gmail.com>
Reviewed-by: Bas Nieuwenhuizen <bas@basnieuwenhuizen.nl>
---
 src/amd/vulkan/radv_cmd_buffer.c | 31 ++-----------------------------
 src/amd/vulkan/radv_private.h    |  1 -
 2 files changed, 2 insertions(+), 30 deletions(-)

diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index ca0d89bfe419..d13b7a9e332d 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -7159,7 +7159,6 @@ radv_CmdExecuteCommands(VkCommandBuffer commandBuffer, uint32_t commandBufferCou
 
       primary->state.last_nggc_settings = secondary->state.last_nggc_settings;
       primary->state.last_nggc_settings_sgpr_idx = secondary->state.last_nggc_settings_sgpr_idx;
-      primary->state.last_nggc_skip = secondary->state.last_nggc_skip;
 
       primary->state.last_vrs_rates = secondary->state.last_vrs_rates;
       primary->state.last_vrs_rates_sgpr_idx = secondary->state.last_vrs_rates_sgpr_idx;
@@ -8352,26 +8351,6 @@ radv_need_late_scissor_emission(struct radv_cmd_buffer *cmd_buffer,
    return false;
 }
 
-ALWAYS_INLINE static bool
-radv_skip_ngg_culling(struct radv_cmd_buffer *cmd_buffer,
-                      const struct radv_graphics_pipeline *pipeline,
-                      const struct radv_draw_info *draw_info)
-{
-   /* If we have to draw only a few vertices, we get better latency if
-    * we disable NGG culling.
-    *
-    * When tessellation is used, what matters is the number of tessellated
-    * vertices, so let's always assume it's not a small draw.
-    */
-   if (pipeline->last_vgt_api_stage != MESA_SHADER_VERTEX)
-      return false;
-
-   if (!draw_info->indirect && draw_info->count < 128)
-      return true;
-
-   return false;
-}
-
 ALWAYS_INLINE static uint32_t
 radv_get_ngg_culling_settings(struct radv_cmd_buffer *cmd_buffer, bool vp_y_inverted)
 {
@@ -8459,17 +8438,11 @@ radv_emit_ngg_culling_state(struct radv_cmd_buffer *cmd_buffer, const struct rad
        RADV_CMD_DIRTY_DYNAMIC_CONSERVATIVE_RAST_MODE | RADV_CMD_DIRTY_DYNAMIC_RASTERIZATION_SAMPLES |
        RADV_CMD_DIRTY_DYNAMIC_PRIMITIVE_TOPOLOGY);
 
-   /* Check small draw status:
-    * For small draw calls, we disable culling by setting the SGPR to 0.
-    */
-   const bool skip = radv_skip_ngg_culling(cmd_buffer, pipeline, draw_info);
-
    /* See if anything changed. */
-   if (!dirty && skip == cmd_buffer->state.last_nggc_skip)
+   if (!dirty)
       return;
 
    /* Remember small draw state. */
-   cmd_buffer->state.last_nggc_skip = skip;
    const struct radv_shader *v = pipeline->base.shaders[stage];
    assert(v->info.has_ngg_culling == nggc_supported);
 
@@ -8485,7 +8458,7 @@ radv_emit_ngg_culling_state(struct radv_cmd_buffer *cmd_buffer, const struct rad
    bool vp_y_inverted = (-vp_scale[1] + vp_translate[1]) > (vp_scale[1] + vp_translate[1]);
 
    /* Get current culling settings. */
-   uint32_t nggc_settings = nggc_supported && !skip
+   uint32_t nggc_settings = nggc_supported
                             ? radv_get_ngg_culling_settings(cmd_buffer, vp_y_inverted)
                             : radv_nggc_none;
 
diff --git a/src/amd/vulkan/radv_private.h b/src/amd/vulkan/radv_private.h
index 5f4026a06ffb..6b1b3aa959eb 100644
--- a/src/amd/vulkan/radv_private.h
+++ b/src/amd/vulkan/radv_private.h
@@ -1557,7 +1557,6 @@ struct radv_cmd_state {
    /* NGG culling state. */
    uint32_t last_nggc_settings;
    int8_t last_nggc_settings_sgpr_idx;
-   bool last_nggc_skip;
 
    /* Mesh shading state. */
    bool mesh_shading;
-- 
GitLab


From d0ea7412bfedb48c5b096f55f28a2a04bf3e1682 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Timur=20Krist=C3=B3f?= <timur.kristof@gmail.com>
Date: Mon, 30 Jan 2023 04:18:57 +0100
Subject: [PATCH 5/5] radv: Refactor radv_emit_ngg_culling_state so it's based
 on dirty flags.
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

This significantly lowers the CPU overhead of this function.

Signed-off-by: Timur Kristóf <timur.kristof@gmail.com>
Reviewed-by: Bas Nieuwenhuizen <bas@basnieuwenhuizen.nl>
---
 src/amd/vulkan/radv_cmd_buffer.c | 82 +++++++-------------------------
 src/amd/vulkan/radv_private.h    |  3 +-
 2 files changed, 18 insertions(+), 67 deletions(-)

diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index d13b7a9e332d..8990e953bee3 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -5584,8 +5584,6 @@ radv_BeginCommandBuffer(VkCommandBuffer commandBuffer, const VkCommandBufferBegi
    cmd_buffer->state.last_sx_ps_downconvert = -1;
    cmd_buffer->state.last_sx_blend_opt_epsilon = -1;
    cmd_buffer->state.last_sx_blend_opt_control = -1;
-   cmd_buffer->state.last_nggc_settings = -1;
-   cmd_buffer->state.last_nggc_settings_sgpr_idx = -1;
    cmd_buffer->state.mesh_shading = false;
    cmd_buffer->state.last_vrs_rates = -1;
    cmd_buffer->state.last_vrs_rates_sgpr_idx = -1;
@@ -6177,6 +6175,7 @@ radv_CmdBindPipeline(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipeline
       }
 
       cmd_buffer->state.mesh_shading = mesh_shading;
+      cmd_buffer->state.has_nggc = graphics_pipeline->has_ngg_culling;
       cmd_buffer->state.dirty |= RADV_CMD_DIRTY_PIPELINE | RADV_CMD_DIRTY_DYNAMIC_VERTEX_INPUT;
       cmd_buffer->push_constant_stages |= graphics_pipeline->active_stages;
 
@@ -7157,9 +7156,6 @@ radv_CmdExecuteCommands(VkCommandBuffer commandBuffer, uint32_t commandBufferCou
          primary->state.last_index_type = secondary->state.last_index_type;
       }
 
-      primary->state.last_nggc_settings = secondary->state.last_nggc_settings;
-      primary->state.last_nggc_settings_sgpr_idx = secondary->state.last_nggc_settings_sgpr_idx;
-
       primary->state.last_vrs_rates = secondary->state.last_vrs_rates;
       primary->state.last_vrs_rates_sgpr_idx = secondary->state.last_vrs_rates_sgpr_idx;
 
@@ -8412,44 +8408,11 @@ radv_get_ngg_culling_settings(struct radv_cmd_buffer *cmd_buffer, bool vp_y_inve
 }
 
 static void
-radv_emit_ngg_culling_state(struct radv_cmd_buffer *cmd_buffer, const struct radv_draw_info *draw_info)
+radv_emit_ngg_culling_state(struct radv_cmd_buffer *cmd_buffer)
 {
-   struct radv_graphics_pipeline *pipeline = cmd_buffer->state.graphics_pipeline;
+   const struct radv_graphics_pipeline *pipeline = cmd_buffer->state.graphics_pipeline;
    const unsigned stage = pipeline->last_vgt_api_stage;
-   const bool nggc_supported = pipeline->has_ngg_culling;
-
-   if (!nggc_supported && !cmd_buffer->state.last_nggc_settings) {
-      /* Current shader doesn't support culling and culling was already disabled:
-       * No further steps needed, just remember the SGPR's location is not set.
-       */
-      cmd_buffer->state.last_nggc_settings_sgpr_idx = -1;
-      return;
-   }
-
-   /* Check dirty flags:
-    * - Dirty pipeline: SGPR index may have changed (we have to re-emit if changed).
-    * - Dirty dynamic flags: culling settings may have changed.
-    */
-   const bool dirty =
-      cmd_buffer->state.dirty &
-      (RADV_CMD_DIRTY_PIPELINE |
-       RADV_CMD_DIRTY_DYNAMIC_CULL_MODE | RADV_CMD_DIRTY_DYNAMIC_FRONT_FACE |
-       RADV_CMD_DIRTY_DYNAMIC_RASTERIZER_DISCARD_ENABLE | RADV_CMD_DIRTY_DYNAMIC_VIEWPORT |
-       RADV_CMD_DIRTY_DYNAMIC_CONSERVATIVE_RAST_MODE | RADV_CMD_DIRTY_DYNAMIC_RASTERIZATION_SAMPLES |
-       RADV_CMD_DIRTY_DYNAMIC_PRIMITIVE_TOPOLOGY);
-
-   /* See if anything changed. */
-   if (!dirty)
-      return;
-
-   /* Remember small draw state. */
-   const struct radv_shader *v = pipeline->base.shaders[stage];
-   assert(v->info.has_ngg_culling == nggc_supported);
-
-   /* Find the user SGPR. */
    const uint32_t base_reg = pipeline->base.user_data_0[stage];
-   const int8_t nggc_sgpr_idx = pipeline->last_vgt_api_stage_locs[AC_UD_NGG_CULLING_SETTINGS].sgpr_idx;
-   assert(!nggc_supported || nggc_sgpr_idx != -1);
 
    /* Get viewport transform. */
    float vp_scale[2], vp_translate[2];
@@ -8458,16 +8421,10 @@ radv_emit_ngg_culling_state(struct radv_cmd_buffer *cmd_buffer, const struct rad
    bool vp_y_inverted = (-vp_scale[1] + vp_translate[1]) > (vp_scale[1] + vp_translate[1]);
 
    /* Get current culling settings. */
-   uint32_t nggc_settings = nggc_supported
-                            ? radv_get_ngg_culling_settings(cmd_buffer, vp_y_inverted)
-                            : radv_nggc_none;
+   uint32_t nggc_settings = radv_get_ngg_culling_settings(cmd_buffer, vp_y_inverted);
 
-   bool emit_viewport = nggc_settings &&
-                        (cmd_buffer->state.dirty & RADV_CMD_DIRTY_DYNAMIC_VIEWPORT ||
-                         cmd_buffer->state.last_nggc_settings_sgpr_idx != nggc_sgpr_idx ||
-                         !cmd_buffer->state.last_nggc_settings);
-
-   if (emit_viewport) {
+   if (cmd_buffer->state.dirty &
+       (RADV_CMD_DIRTY_PIPELINE | RADV_CMD_DIRTY_DYNAMIC_VIEWPORT | RADV_CMD_DIRTY_DYNAMIC_RASTERIZATION_SAMPLES)) {
       /* Correction for inverted Y */
       if (vp_y_inverted) {
          vp_scale[1] = -vp_scale[1];
@@ -8487,20 +8444,11 @@ radv_emit_ngg_culling_state(struct radv_cmd_buffer *cmd_buffer, const struct rad
       radeon_emit_array(cmd_buffer->cs, vp_reg_values, 4);
    }
 
-   bool emit_settings = nggc_supported &&
-                        (cmd_buffer->state.last_nggc_settings != nggc_settings ||
-                         cmd_buffer->state.last_nggc_settings_sgpr_idx != nggc_sgpr_idx);
-
-   /* This needs to be emitted when culling is turned on
-    * and when it's already on but some settings change.
-    */
-   if (emit_settings) {
-      assert(nggc_sgpr_idx >= 0);
-      radeon_set_sh_reg(cmd_buffer->cs, base_reg + nggc_sgpr_idx * 4, nggc_settings);
-   }
+   const int8_t nggc_sgpr_idx =
+      pipeline->last_vgt_api_stage_locs[AC_UD_NGG_CULLING_SETTINGS].sgpr_idx;
+   assert(nggc_sgpr_idx != -1);
 
-   cmd_buffer->state.last_nggc_settings = nggc_settings;
-   cmd_buffer->state.last_nggc_settings_sgpr_idx = nggc_sgpr_idx;
+   radeon_set_sh_reg(cmd_buffer->cs, base_reg + nggc_sgpr_idx * 4, nggc_settings);
 }
 
 static void
@@ -8545,9 +8493,13 @@ radv_emit_all_graphics_states(struct radv_cmd_buffer *cmd_buffer, const struct r
       radv_flush_ngg_query_state(cmd_buffer);
    }
 
-   if (cmd_buffer->device->physical_device->use_ngg_culling &&
-       cmd_buffer->state.graphics_pipeline->is_ngg)
-      radv_emit_ngg_culling_state(cmd_buffer, info);
+   if ((cmd_buffer->state.dirty &
+        (RADV_CMD_DIRTY_PIPELINE | RADV_CMD_DIRTY_DYNAMIC_CULL_MODE |
+         RADV_CMD_DIRTY_DYNAMIC_FRONT_FACE | RADV_CMD_DIRTY_DYNAMIC_RASTERIZER_DISCARD_ENABLE |
+         RADV_CMD_DIRTY_DYNAMIC_VIEWPORT | RADV_CMD_DIRTY_DYNAMIC_CONSERVATIVE_RAST_MODE |
+         RADV_CMD_DIRTY_DYNAMIC_RASTERIZATION_SAMPLES | RADV_CMD_DIRTY_DYNAMIC_PRIMITIVE_TOPOLOGY)) &&
+       cmd_buffer->state.has_nggc)
+      radv_emit_ngg_culling_state(cmd_buffer);
 
    if ((cmd_buffer->state.dirty & (RADV_CMD_DIRTY_DYNAMIC_COLOR_WRITE_MASK |
                                    RADV_CMD_DIRTY_DYNAMIC_RASTERIZATION_SAMPLES |
diff --git a/src/amd/vulkan/radv_private.h b/src/amd/vulkan/radv_private.h
index 6b1b3aa959eb..f951a2aa7e0c 100644
--- a/src/amd/vulkan/radv_private.h
+++ b/src/amd/vulkan/radv_private.h
@@ -1555,8 +1555,7 @@ struct radv_cmd_state {
    enum rgp_flush_bits sqtt_flush_bits;
 
    /* NGG culling state. */
-   uint32_t last_nggc_settings;
-   int8_t last_nggc_settings_sgpr_idx;
+   bool has_nggc;
 
    /* Mesh shading state. */
    bool mesh_shading;
-- 
GitLab

