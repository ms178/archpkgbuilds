From 58eff69d4ed31e7ddc3b7e1e5b4e15a0e793eb3d Mon Sep 17 00:00:00 2001
From: Alyssa Rosenzweig <alyssa@rosenzweig.io>
Date: Mon, 8 Jan 2024 12:01:49 -0400
Subject: [PATCH] vtn: fuse OpenCL mad if we can can

clpeak "float" case from 1112 -> 1978 GFLOPS on rusticl on m1.

Signed-off-by: Alyssa Rosenzweig <alyssa@rosenzweig.io>
---
 src/compiler/spirv/vtn_opencl.c | 23 +++++++++++++++++++++--
 1 file changed, 21 insertions(+), 2 deletions(-)

diff --git a/src/compiler/spirv/vtn_opencl.c b/src/compiler/spirv/vtn_opencl.c
index e3e4e61802ce5..1601cb49f7639 100644
--- a/src/compiler/spirv/vtn_opencl.c
+++ b/src/compiler/spirv/vtn_opencl.c
@@ -508,8 +508,27 @@ handle_special(struct vtn_builder *b, uint32_t opcode,
       return nir_cross3(nb, srcs[0], srcs[1]);
    case OpenCLstd_Fdim:
       return nir_fdim(nb, srcs[0], srcs[1]);
-   case OpenCLstd_Mad:
-      return nir_fmad(nb, srcs[0], srcs[1], srcs[2]);
+   case OpenCLstd_Mad: {
+      /* The spec says
+       *
+       *    mad approximates a * b + c. Whether or how the product of a * b is
+       *    rounded and how supernormal or subnormal intermediate products are
+       *    handled is not defined. mad is intended to be used where speed is
+       *    preferred over accuracy.
+       *
+       * So lower to fmul+fadd if we have to, but fuse to an ffma if the backend
+       * supports that. This can be significantly faster.
+       */
+      bool lower =
+         ((nb->shader->options->lower_ffma16 && srcs[0]->bit_size == 16) ||
+          (nb->shader->options->lower_ffma32 && srcs[0]->bit_size == 32) ||
+          (nb->shader->options->lower_ffma64 && srcs[0]->bit_size == 64));
+
+      if (lower)
+         return nir_fmad(nb, srcs[0], srcs[1], srcs[2]);
+      else
+         return nir_ffma(nb, srcs[0], srcs[1], srcs[2]);
+   }
    case OpenCLstd_Maxmag:
       return nir_maxmag(nb, srcs[0], srcs[1]);
    case OpenCLstd_Minmag:
-- 
GitLab

