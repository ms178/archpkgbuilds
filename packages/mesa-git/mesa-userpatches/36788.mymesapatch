From d44744c0c5a60de5abf1a5f07d4646a1fdfd8ea4 Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Thu, 14 Aug 2025 11:22:48 -0400
Subject: [PATCH 1/8] radv: move streamout flush check outside the function

this is not inlined and is seldom called, so avoid the overhead of calling
---
 src/amd/vulkan/radv_cmd_buffer.c | 78 ++++++++++++++++----------------
 1 file changed, 38 insertions(+), 40 deletions(-)

diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index 839a3efc74e51..d3f8c57265e74 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -5830,53 +5830,50 @@ radv_flush_streamout_descriptors(struct radv_cmd_buffer *cmd_buffer)
 {
    struct radv_device *device = radv_cmd_buffer_device(cmd_buffer);
    const struct radv_physical_device *pdev = radv_device_physical(device);
+   struct radv_streamout_binding *sb = cmd_buffer->streamout_bindings;
+   struct radv_streamout_state *so = &cmd_buffer->state.streamout;
+   unsigned so_offset;
+   uint64_t desc_va;
+   void *so_ptr;
 
-   if (cmd_buffer->state.dirty & RADV_CMD_DIRTY_STREAMOUT_BUFFER) {
-      struct radv_streamout_binding *sb = cmd_buffer->streamout_bindings;
-      struct radv_streamout_state *so = &cmd_buffer->state.streamout;
-      unsigned so_offset;
-      uint64_t desc_va;
-      void *so_ptr;
-
-      /* Allocate some descriptor state for streamout buffers. */
-      if (!radv_cmd_buffer_upload_alloc(cmd_buffer, MAX_SO_BUFFERS * 16, &so_offset, &so_ptr))
-         return;
-
-      for (uint32_t i = 0; i < MAX_SO_BUFFERS; i++) {
-         uint32_t *desc = &((uint32_t *)so_ptr)[i * 4];
-         uint32_t size = 0;
-         uint64_t va = 0;
-
-         if (so->enabled_mask & (1 << i)) {
-            va = sb[i].va;
+   /* Allocate some descriptor state for streamout buffers. */
+   if (!radv_cmd_buffer_upload_alloc(cmd_buffer, MAX_SO_BUFFERS * 16, &so_offset, &so_ptr))
+      return;
 
-            /* Set the descriptor.
-             *
-             * On GFX8, the format must be non-INVALID, otherwise
-             * the buffer will be considered not bound and store
-             * instructions will be no-ops.
-             */
-            size = 0xffffffff;
+   for (uint32_t i = 0; i < MAX_SO_BUFFERS; i++) {
+      uint32_t *desc = &((uint32_t *)so_ptr)[i * 4];
+      uint32_t size = 0;
+      uint64_t va = 0;
 
-            if (pdev->use_ngg_streamout) {
-               /* With NGG streamout, the buffer size is used to determine the max emit per buffer
-                * and also acts as a disable bit when it's 0.
-                */
-               size = radv_is_streamout_enabled(cmd_buffer) ? sb[i].size : 0;
-            }
+      if (so->enabled_mask & (1 << i)) {
+         va = sb[i].va;
+
+         /* Set the descriptor.
+            *
+            * On GFX8, the format must be non-INVALID, otherwise
+            * the buffer will be considered not bound and store
+            * instructions will be no-ops.
+            */
+         size = 0xffffffff;
+
+         if (pdev->use_ngg_streamout) {
+            /* With NGG streamout, the buffer size is used to determine the max emit per buffer
+               * and also acts as a disable bit when it's 0.
+               */
+            size = radv_is_streamout_enabled(cmd_buffer) ? sb[i].size : 0;
          }
-
-         ac_build_raw_buffer_descriptor(pdev->info.gfx_level, va, size, desc);
       }
 
-      desc_va = radv_buffer_get_va(cmd_buffer->upload.upload_bo);
-      desc_va += so_offset;
+      ac_build_raw_buffer_descriptor(pdev->info.gfx_level, va, size, desc);
+   }
+
+   desc_va = radv_buffer_get_va(cmd_buffer->upload.upload_bo);
+   desc_va += so_offset;
 
-      radv_emit_streamout_buffers(cmd_buffer, desc_va);
+   radv_emit_streamout_buffers(cmd_buffer, desc_va);
 
-      if (pdev->info.gfx_level >= GFX12)
-         radv_emit_streamout_state(cmd_buffer);
-   }
+   if (pdev->info.gfx_level >= GFX12)
+      radv_emit_streamout_state(cmd_buffer);
 
    cmd_buffer->state.dirty &= ~RADV_CMD_DIRTY_STREAMOUT_BUFFER;
 }
@@ -5940,7 +5937,8 @@ radv_upload_graphics_shader_descriptors(struct radv_cmd_buffer *cmd_buffer)
    if (cmd_buffer->state.dirty & RADV_CMD_DIRTY_VERTEX_BUFFER)
       radv_flush_vertex_descriptors(cmd_buffer);
 
-   radv_flush_streamout_descriptors(cmd_buffer);
+   if (cmd_buffer->state.dirty & RADV_CMD_DIRTY_STREAMOUT_BUFFER)
+      radv_flush_streamout_descriptors(cmd_buffer);
 
    VkShaderStageFlags stages = VK_SHADER_STAGE_ALL_GRAPHICS;
    radv_flush_descriptors(cmd_buffer, stages, VK_PIPELINE_BIND_POINT_GRAPHICS);
-- 
GitLab


From 2a0d4de3801671f61ff21ee3861d080e12b406a0 Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Thu, 14 Aug 2025 11:23:43 -0400
Subject: [PATCH 2/8] radv: add RADV_CMD_DIRTY_VRS

vrs doesn't need to be flushed on every draw
---
 src/amd/vulkan/radv_cmd_buffer.c | 8 +++++++-
 src/amd/vulkan/radv_cmd_buffer.h | 3 ++-
 2 files changed, 9 insertions(+), 2 deletions(-)

diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index d3f8c57265e74..963660690cbbb 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -5886,6 +5886,7 @@ radv_flush_force_vrs_state(struct radv_cmd_buffer *cmd_buffer)
    const struct radv_shader *last_vgt_shader = cmd_buffer->state.last_vgt_shader;
    uint32_t force_vrs_rates_offset;
 
+   cmd_buffer->state.dirty &= ~RADV_CMD_DIRTY_VRS;
    if (!last_vgt_shader->info.force_vrs_per_vertex) {
       /* Un-set the SGPR index so we know to re-emit it later. */
       cmd_buffer->state.last_force_vrs_rates_offset = -1;
@@ -5947,7 +5948,8 @@ radv_upload_graphics_shader_descriptors(struct radv_cmd_buffer *cmd_buffer)
    if (pc_stages)
       radv_flush_constants(cmd_buffer, pc_stages, VK_PIPELINE_BIND_POINT_GRAPHICS);
 
-   radv_flush_force_vrs_state(cmd_buffer);
+   if (cmd_buffer->state.dirty & RADV_CMD_DIRTY_VRS)
+      radv_flush_force_vrs_state(cmd_buffer);
 }
 
 struct radv_prim_vertex_count {
@@ -7764,6 +7766,8 @@ radv_CmdBindPipeline(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipeline
 
       radv_bind_gs_copy_shader(cmd_buffer, graphics_pipeline->base.gs_copy_shader);
 
+      if (cmd_buffer->state.last_vgt_shader != graphics_pipeline->base.shaders[graphics_pipeline->last_vgt_api_stage])
+         cmd_buffer->state.dirty |= RADV_CMD_DIRTY_VRS;
       cmd_buffer->state.last_vgt_shader = graphics_pipeline->base.shaders[graphics_pipeline->last_vgt_api_stage];
 
       cmd_buffer->state.graphics_pipeline = graphics_pipeline;
@@ -11486,6 +11490,8 @@ radv_bind_graphics_shaders(struct radv_cmd_buffer *cmd_buffer)
       cmd_buffer->state.flush_bits |= RADV_CMD_FLAG_VGT_FLUSH;
    }
 
+   if (cmd_buffer->state.last_vgt_shader != cmd_buffer->state.shaders[last_vgt_api_stage])
+      cmd_buffer->state.dirty |= RADV_CMD_DIRTY_VRS;
    cmd_buffer->state.last_vgt_shader = cmd_buffer->state.shaders[last_vgt_api_stage];
 
    cmd_buffer->state.has_nggc = cmd_buffer->state.last_vgt_shader->info.has_ngg_culling;
diff --git a/src/amd/vulkan/radv_cmd_buffer.h b/src/amd/vulkan/radv_cmd_buffer.h
index 50a48e1e7383a..72474d30fe334 100644
--- a/src/amd/vulkan/radv_cmd_buffer.h
+++ b/src/amd/vulkan/radv_cmd_buffer.h
@@ -105,7 +105,8 @@ enum radv_cmd_dirty_bits {
    RADV_CMD_DIRTY_CLIP_RECTS_STATE = 1ull << 19,
    RADV_CMD_DIRTY_TESS_STATE = 1ull << 20,
    RADV_CMD_DIRTY_CB_RENDER_STATE = 1ull << 21,
-   RADV_CMD_DIRTY_ALL = (1ull << 22) - 1,
+   RADV_CMD_DIRTY_VRS = 1ull << 22,
+   RADV_CMD_DIRTY_ALL = (1ull << 23) - 1,
 
    RADV_CMD_DIRTY_SHADER_QUERY = RADV_CMD_DIRTY_NGG_STATE | RADV_CMD_DIRTY_TASK_STATE,
 };
-- 
GitLab


From 947e7fc8bd5c181a61fafd596d5bb886ae8cb8e0 Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Thu, 14 Aug 2025 11:24:12 -0400
Subject: [PATCH 3/8] radv: ALWAYS_INLINE
 radv_upload_graphics_shader_descriptors and relateds

this mostly makes it go away
---
 src/amd/vulkan/radv_cmd_buffer.c | 2 +-
 src/amd/vulkan/radv_cmd_buffer.h | 6 +++---
 2 files changed, 4 insertions(+), 4 deletions(-)

diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index 963660690cbbb..0fe34b17c1758 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -5932,7 +5932,7 @@ radv_flush_force_vrs_state(struct radv_cmd_buffer *cmd_buffer)
    cmd_buffer->state.last_force_vrs_rates_offset = force_vrs_rates_offset;
 }
 
-static void
+ALWAYS_INLINE static void
 radv_upload_graphics_shader_descriptors(struct radv_cmd_buffer *cmd_buffer)
 {
    if (cmd_buffer->state.dirty & RADV_CMD_DIRTY_VERTEX_BUFFER)
diff --git a/src/amd/vulkan/radv_cmd_buffer.h b/src/amd/vulkan/radv_cmd_buffer.h
index 72474d30fe334..3189e9e75a093 100644
--- a/src/amd/vulkan/radv_cmd_buffer.h
+++ b/src/amd/vulkan/radv_cmd_buffer.h
@@ -694,19 +694,19 @@ radv_is_streamout_enabled(struct radv_cmd_buffer *cmd_buffer)
    return (so->streamout_enabled || cmd_buffer->state.active_prims_gen_queries) && !cmd_buffer->state.suspend_streamout;
 }
 
-static inline unsigned
+ALWAYS_INLINE static unsigned
 vk_to_bind_point(VkPipelineBindPoint bind_point)
 {
    return bind_point == VK_PIPELINE_BIND_POINT_RAY_TRACING_KHR ? 2 : bind_point;
 }
 
-static inline struct radv_descriptor_state *
+ALWAYS_INLINE static struct radv_descriptor_state *
 radv_get_descriptors_state(struct radv_cmd_buffer *cmd_buffer, VkPipelineBindPoint bind_point)
 {
    return &cmd_buffer->descriptors[vk_to_bind_point(bind_point)];
 }
 
-static inline const struct radv_push_constant_state *
+ALWAYS_INLINE static const struct radv_push_constant_state *
 radv_get_push_constants_state(const struct radv_cmd_buffer *cmd_buffer, VkPipelineBindPoint bind_point)
 {
    return &cmd_buffer->push_constant_state[vk_to_bind_point(bind_point)];
-- 
GitLab


From 67e57efc894a4254b8e157118d5395364ce08607 Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Thu, 14 Aug 2025 11:42:56 -0400
Subject: [PATCH 4/8] radv: rename rast_prim -> shader_rast_prim

---
 src/amd/vulkan/radv_cmd_buffer.c | 8 ++++----
 src/amd/vulkan/radv_cmd_buffer.h | 2 +-
 2 files changed, 5 insertions(+), 5 deletions(-)

diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index 0fe34b17c1758..eee615895d050 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -1020,7 +1020,7 @@ radv_get_rasterization_prim(const struct radv_cmd_buffer *cmd_buffer)
        (VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT | VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT |
         VK_SHADER_STAGE_GEOMETRY_BIT | VK_SHADER_STAGE_MESH_BIT_EXT)) {
       /* Ignore dynamic primitive topology for TES/GS/MS stages. */
-      return cmd_buffer->state.rast_prim;
+      return cmd_buffer->state.shader_rast_prim;
    }
 
    return radv_conv_prim_to_gs_out(d->vk.ia.primitive_topology, last_vgt_shader->info.is_ngg);
@@ -7829,7 +7829,7 @@ radv_CmdBindPipeline(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipeline
 
       cmd_buffer->state.db_render_control = graphics_pipeline->db_render_control;
 
-      cmd_buffer->state.rast_prim = graphics_pipeline->rast_prim;
+      cmd_buffer->state.shader_rast_prim = graphics_pipeline->rast_prim;
 
       cmd_buffer->state.ia_multi_vgt_param = graphics_pipeline->ia_multi_vgt_param;
 
@@ -11520,7 +11520,7 @@ radv_bind_graphics_shaders(struct radv_cmd_buffer *cmd_buffer)
    if (cmd_buffer->state.active_stages &
        (VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT | VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT |
         VK_SHADER_STAGE_GEOMETRY_BIT | VK_SHADER_STAGE_MESH_BIT_EXT)) {
-      cmd_buffer->state.rast_prim = radv_get_vgt_gs_out(cmd_buffer->state.shaders, 0, false);
+      cmd_buffer->state.shader_rast_prim = radv_get_vgt_gs_out(cmd_buffer->state.shaders, 0, false);
    }
 
    const struct radv_shader *vs = radv_get_shader(cmd_buffer->state.shaders, MESA_SHADER_VERTEX);
@@ -14418,7 +14418,7 @@ radv_reset_pipeline_state(struct radv_cmd_buffer *cmd_buffer, VkPipelineBindPoin
          cmd_buffer->state.emitted_vs_prolog = NULL;
          cmd_buffer->state.ms.sample_shading_enable = false;
          cmd_buffer->state.ms.min_sample_shading = 1.0f;
-         cmd_buffer->state.rast_prim = 0;
+         cmd_buffer->state.shader_rast_prim = 0;
          cmd_buffer->state.uses_out_of_order_rast = false;
          cmd_buffer->state.uses_vrs_attachment = false;
       }
diff --git a/src/amd/vulkan/radv_cmd_buffer.h b/src/amd/vulkan/radv_cmd_buffer.h
index 3189e9e75a093..cf6331e45374a 100644
--- a/src/amd/vulkan/radv_cmd_buffer.h
+++ b/src/amd/vulkan/radv_cmd_buffer.h
@@ -512,7 +512,7 @@ struct radv_cmd_state {
 
    unsigned last_cb_target_mask;
 
-   unsigned rast_prim;
+   unsigned shader_rast_prim;
 
    uint32_t vtx_base_sgpr;
    uint8_t vtx_emit_num;
-- 
GitLab


From 7b979feea0d52d0540fee721df9f6d2326999fad Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Thu, 14 Aug 2025 11:47:02 -0400
Subject: [PATCH 5/8] radv: store 'rast_prim' to cmdbuf state

---
 src/amd/vulkan/meta/radv_meta.c  |  3 +++
 src/amd/vulkan/radv_cmd_buffer.c | 29 +++++++++++++++++++++--------
 src/amd/vulkan/radv_cmd_buffer.h |  4 ++++
 3 files changed, 28 insertions(+), 8 deletions(-)

diff --git a/src/amd/vulkan/meta/radv_meta.c b/src/amd/vulkan/meta/radv_meta.c
index 0349dba7eb9e4..de89f1bd6dc88 100644
--- a/src/amd/vulkan/meta/radv_meta.c
+++ b/src/amd/vulkan/meta/radv_meta.c
@@ -195,6 +195,9 @@ radv_meta_restore(const struct radv_meta_saved_state *state, struct radv_cmd_buf
       radv_CmdBindShadersEXT(radv_cmd_buffer_to_handle(cmd_buffer), stage_count, stages, shaders);
    }
 
+   if (state->flags & RADV_META_SAVE_GRAPHICS_PIPELINE)
+      radv_set_rast_sample_state(radv_cmd_buffer_to_handle(cmd_buffer));
+
    if (state->flags & RADV_META_SAVE_DESCRIPTORS) {
       if (state->old_descriptor_set0_valid)
          radv_set_descriptor_set(cmd_buffer, bind_point, state->old_descriptor_set0, 0);
diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index eee615895d050..0bc21a6e69deb 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -1010,20 +1010,29 @@ radv_emit_descriptors_per_stage(const struct radv_device *device, struct radv_cm
    }
 }
 
-static unsigned
-radv_get_rasterization_prim(const struct radv_cmd_buffer *cmd_buffer)
+ALWAYS_INLINE static void
+radv_set_rasterization_prim(struct radv_cmd_buffer *cmd_buffer)
 {
    const struct radv_shader *last_vgt_shader = cmd_buffer->state.last_vgt_shader;
    const struct radv_dynamic_state *d = &cmd_buffer->state.dynamic;
 
+   if (!last_vgt_shader)
+      return;
+
    if (cmd_buffer->state.active_stages &
        (VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT | VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT |
         VK_SHADER_STAGE_GEOMETRY_BIT | VK_SHADER_STAGE_MESH_BIT_EXT)) {
       /* Ignore dynamic primitive topology for TES/GS/MS stages. */
-      return cmd_buffer->state.shader_rast_prim;
+      cmd_buffer->state.rast_prim = cmd_buffer->state.shader_rast_prim;
+   } else if (d->vk.ia.primitive_topology) {
+      cmd_buffer->state.rast_prim = radv_conv_prim_to_gs_out(d->vk.ia.primitive_topology, last_vgt_shader->info.is_ngg);
    }
+}
 
-   return radv_conv_prim_to_gs_out(d->vk.ia.primitive_topology, last_vgt_shader->info.is_ngg);
+ALWAYS_INLINE void
+radv_set_rast_sample_state(struct radv_cmd_buffer *cmd_buffer)
+{
+   radv_set_rasterization_prim(cmd_buffer);
 }
 
 static ALWAYS_INLINE VkLineRasterizationModeEXT
@@ -1031,7 +1040,7 @@ radv_get_line_mode(const struct radv_cmd_buffer *cmd_buffer)
 {
    const struct radv_dynamic_state *d = &cmd_buffer->state.dynamic;
 
-   const unsigned rast_prim = radv_get_rasterization_prim(cmd_buffer);
+   const unsigned rast_prim = cmd_buffer->state.rast_prim;
 
    const bool draw_lines = (radv_rast_prim_is_line(rast_prim) && !radv_polygon_mode_is_point(d->vk.rs.polygon_mode)) ||
                            (radv_polygon_mode_is_line(d->vk.rs.polygon_mode) && !radv_rast_prim_is_point(rast_prim));
@@ -3415,7 +3424,7 @@ radv_emit_primitive_topology(struct radv_cmd_buffer *cmd_buffer)
 {
    struct radv_device *device = radv_cmd_buffer_device(cmd_buffer);
    const struct radv_physical_device *pdev = radv_device_physical(device);
-   const uint32_t vgt_gs_out_prim_type = radv_get_rasterization_prim(cmd_buffer);
+   const uint32_t vgt_gs_out_prim_type = cmd_buffer->state.rast_prim;
    const struct radv_dynamic_state *d = &cmd_buffer->state.dynamic;
    struct radv_cmd_stream *cs = cmd_buffer->cs;
 
@@ -4750,7 +4759,7 @@ radv_emit_guardband_state(struct radv_cmd_buffer *cmd_buffer)
    struct radv_device *device = radv_cmd_buffer_device(cmd_buffer);
    const struct radv_physical_device *pdev = radv_device_physical(device);
    const struct radv_dynamic_state *d = &cmd_buffer->state.dynamic;
-   unsigned rast_prim = radv_get_rasterization_prim(cmd_buffer);
+   unsigned rast_prim = cmd_buffer->state.rast_prim;
    const bool draw_points = radv_rast_prim_is_point(rast_prim) || radv_polygon_mode_is_point(d->vk.rs.polygon_mode);
    const bool draw_lines = radv_rast_prim_is_line(rast_prim) || radv_polygon_mode_is_line(d->vk.rs.polygon_mode);
    struct radv_cmd_stream *cs = cmd_buffer->cs;
@@ -7830,6 +7839,7 @@ radv_CmdBindPipeline(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipeline
       cmd_buffer->state.db_render_control = graphics_pipeline->db_render_control;
 
       cmd_buffer->state.shader_rast_prim = graphics_pipeline->rast_prim;
+      radv_set_rast_sample_state(cmd_buffer);
 
       cmd_buffer->state.ia_multi_vgt_param = graphics_pipeline->ia_multi_vgt_param;
 
@@ -8052,6 +8062,7 @@ radv_CmdSetPrimitiveTopology(VkCommandBuffer commandBuffer, VkPrimitiveTopology
       state->dirty |= RADV_DYNAMIC_RASTERIZATION_SAMPLES;
 
    state->dynamic.vk.ia.primitive_topology = primitive_topology;
+   radv_set_rast_sample_state(cmd_buffer);
 
    state->dirty_dynamic |= RADV_DYNAMIC_PRIMITIVE_TOPOLOGY;
 }
@@ -10390,7 +10401,7 @@ radv_emit_fs_state(struct radv_cmd_buffer *cmd_buffer)
    const unsigned rasterization_samples = radv_get_rasterization_samples(cmd_buffer);
    const unsigned ps_iter_samples = radv_get_ps_iter_samples(cmd_buffer);
    const uint16_t ps_iter_mask = ac_get_ps_iter_mask(ps_iter_samples);
-   const unsigned rast_prim = radv_get_rasterization_prim(cmd_buffer);
+   const unsigned rast_prim = cmd_buffer->state.rast_prim;
    const unsigned ps_state = SET_SGPR_FIELD(PS_STATE_NUM_SAMPLES, rasterization_samples) |
                              SET_SGPR_FIELD(PS_STATE_PS_ITER_MASK, ps_iter_mask) |
                              SET_SGPR_FIELD(PS_STATE_LINE_RAST_MODE, radv_get_line_mode(cmd_buffer)) |
@@ -11522,6 +11533,7 @@ radv_bind_graphics_shaders(struct radv_cmd_buffer *cmd_buffer)
         VK_SHADER_STAGE_GEOMETRY_BIT | VK_SHADER_STAGE_MESH_BIT_EXT)) {
       cmd_buffer->state.shader_rast_prim = radv_get_vgt_gs_out(cmd_buffer->state.shaders, 0, false);
    }
+   radv_set_rast_sample_state(cmd_buffer);
 
    const struct radv_shader *vs = radv_get_shader(cmd_buffer->state.shaders, MESA_SHADER_VERTEX);
    if (vs) {
@@ -14419,6 +14431,7 @@ radv_reset_pipeline_state(struct radv_cmd_buffer *cmd_buffer, VkPipelineBindPoin
          cmd_buffer->state.ms.sample_shading_enable = false;
          cmd_buffer->state.ms.min_sample_shading = 1.0f;
          cmd_buffer->state.shader_rast_prim = 0;
+         cmd_buffer->state.rast_prim = 0;
          cmd_buffer->state.uses_out_of_order_rast = false;
          cmd_buffer->state.uses_vrs_attachment = false;
       }
diff --git a/src/amd/vulkan/radv_cmd_buffer.h b/src/amd/vulkan/radv_cmd_buffer.h
index cf6331e45374a..a852bfde06d96 100644
--- a/src/amd/vulkan/radv_cmd_buffer.h
+++ b/src/amd/vulkan/radv_cmd_buffer.h
@@ -512,6 +512,7 @@ struct radv_cmd_state {
 
    unsigned last_cb_target_mask;
 
+   unsigned rast_prim;
    unsigned shader_rast_prim;
 
    uint32_t vtx_base_sgpr;
@@ -726,6 +727,9 @@ radv_get_num_pipeline_stat_queries(struct radv_cmd_buffer *cmd_buffer)
           cmd_buffer->state.active_prims_xfb_queries;
 }
 
+void
+radv_set_rast_sample_state(struct radv_cmd_buffer *cmd_buffer);
+
 bool radv_cmd_buffer_uses_mec(struct radv_cmd_buffer *cmd_buffer);
 
 void radv_cmd_buffer_reset_rendering(struct radv_cmd_buffer *cmd_buffer);
-- 
GitLab


From d4e5d78821a848b8f13f4c1a249b371046b5b9ed Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Thu, 14 Aug 2025 13:53:51 -0400
Subject: [PATCH 6/8] radv: calculate 'draw_lines' at the places where it may
 change

---
 src/amd/vulkan/meta/radv_meta.c  |  2 +-
 src/amd/vulkan/radv_cmd_buffer.c | 28 ++++++++++++++++++++--------
 src/amd/vulkan/radv_cmd_buffer.h |  1 +
 3 files changed, 22 insertions(+), 9 deletions(-)

diff --git a/src/amd/vulkan/meta/radv_meta.c b/src/amd/vulkan/meta/radv_meta.c
index de89f1bd6dc88..29b8e302bebff 100644
--- a/src/amd/vulkan/meta/radv_meta.c
+++ b/src/amd/vulkan/meta/radv_meta.c
@@ -196,7 +196,7 @@ radv_meta_restore(const struct radv_meta_saved_state *state, struct radv_cmd_buf
    }
 
    if (state->flags & RADV_META_SAVE_GRAPHICS_PIPELINE)
-      radv_set_rast_sample_state(radv_cmd_buffer_to_handle(cmd_buffer));
+      radv_set_rast_sample_state(cmd_buffer);
 
    if (state->flags & RADV_META_SAVE_DESCRIPTORS) {
       if (state->old_descriptor_set0_valid)
diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index 0bc21a6e69deb..a5c48358c9161 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -1010,6 +1010,16 @@ radv_emit_descriptors_per_stage(const struct radv_device *device, struct radv_cm
    }
 }
 
+ALWAYS_INLINE static void
+radv_set_draw_lines(struct radv_cmd_buffer *cmd_buffer)
+{
+   const struct radv_dynamic_state *d = &cmd_buffer->state.dynamic;
+   const unsigned rast_prim = cmd_buffer->state.rast_prim;
+
+   cmd_buffer->state.draw_lines = (radv_rast_prim_is_line(rast_prim) && !radv_polygon_mode_is_point(d->vk.rs.polygon_mode)) ||
+                                  (radv_polygon_mode_is_line(d->vk.rs.polygon_mode) && !radv_rast_prim_is_point(rast_prim));
+}
+
 ALWAYS_INLINE static void
 radv_set_rasterization_prim(struct radv_cmd_buffer *cmd_buffer)
 {
@@ -1040,14 +1050,7 @@ radv_get_line_mode(const struct radv_cmd_buffer *cmd_buffer)
 {
    const struct radv_dynamic_state *d = &cmd_buffer->state.dynamic;
 
-   const unsigned rast_prim = cmd_buffer->state.rast_prim;
-
-   const bool draw_lines = (radv_rast_prim_is_line(rast_prim) && !radv_polygon_mode_is_point(d->vk.rs.polygon_mode)) ||
-                           (radv_polygon_mode_is_line(d->vk.rs.polygon_mode) && !radv_rast_prim_is_point(rast_prim));
-   if (draw_lines)
-      return d->vk.rs.line.mode;
-
-   return VK_LINE_RASTERIZATION_MODE_DEFAULT;
+   return cmd_buffer->state.draw_lines ? d->vk.rs.line.mode : VK_LINE_RASTERIZATION_MODE_DEFAULT;
 }
 
 static ALWAYS_INLINE unsigned
@@ -1077,6 +1080,13 @@ radv_get_rasterization_samples(struct radv_cmd_buffer *cmd_buffer)
    return MAX2(1, d->vk.ms.rasterization_samples);
 }
 
+ALWAYS_INLINE void
+radv_set_rast_sample_state(struct radv_cmd_buffer *cmd_buffer)
+{
+   radv_set_rasterization_prim(cmd_buffer);
+   radv_set_draw_lines(cmd_buffer);
+}
+
 static ALWAYS_INLINE unsigned
 radv_get_ps_iter_samples(struct radv_cmd_buffer *cmd_buffer)
 {
@@ -8370,6 +8380,7 @@ radv_CmdSetPolygonModeEXT(VkCommandBuffer commandBuffer, VkPolygonMode polygonMo
       state->dirty |= RADV_CMD_DIRTY_GUARDBAND;
 
    state->dynamic.vk.rs.polygon_mode = polygon_mode;
+   radv_set_draw_lines(cmd_buffer);
 
    state->dirty_dynamic |= RADV_DYNAMIC_POLYGON_MODE;
 }
@@ -14434,6 +14445,7 @@ radv_reset_pipeline_state(struct radv_cmd_buffer *cmd_buffer, VkPipelineBindPoin
          cmd_buffer->state.rast_prim = 0;
          cmd_buffer->state.uses_out_of_order_rast = false;
          cmd_buffer->state.uses_vrs_attachment = false;
+         cmd_buffer->state.draw_lines = false;
       }
       if (cmd_buffer->state.emitted_graphics_pipeline) {
          radv_bind_custom_blend_mode(cmd_buffer, 0);
diff --git a/src/amd/vulkan/radv_cmd_buffer.h b/src/amd/vulkan/radv_cmd_buffer.h
index a852bfde06d96..68e4ae720829a 100644
--- a/src/amd/vulkan/radv_cmd_buffer.h
+++ b/src/amd/vulkan/radv_cmd_buffer.h
@@ -517,6 +517,7 @@ struct radv_cmd_state {
 
    uint32_t vtx_base_sgpr;
    uint8_t vtx_emit_num;
+   bool draw_lines;
    bool uses_drawid;
    bool uses_baseinstance;
    bool can_use_simple_vertex_input;
-- 
GitLab


From d40168ea6356f7a9a7702de86381f54c33da08bc Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Thu, 14 Aug 2025 14:02:38 -0400
Subject: [PATCH 7/8] radv: calculate 'total_samples' at any point where it may
 change

---
 src/amd/vulkan/radv_cmd_buffer.c | 43 ++++++++++++++------------------
 src/amd/vulkan/radv_cmd_buffer.h |  1 +
 2 files changed, 20 insertions(+), 24 deletions(-)

diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index a5c48358c9161..91d667d38b2bf 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -1039,12 +1039,6 @@ radv_set_rasterization_prim(struct radv_cmd_buffer *cmd_buffer)
    }
 }
 
-ALWAYS_INLINE void
-radv_set_rast_sample_state(struct radv_cmd_buffer *cmd_buffer)
-{
-   radv_set_rasterization_prim(cmd_buffer);
-}
-
 static ALWAYS_INLINE VkLineRasterizationModeEXT
 radv_get_line_mode(const struct radv_cmd_buffer *cmd_buffer)
 {
@@ -1053,8 +1047,8 @@ radv_get_line_mode(const struct radv_cmd_buffer *cmd_buffer)
    return cmd_buffer->state.draw_lines ? d->vk.rs.line.mode : VK_LINE_RASTERIZATION_MODE_DEFAULT;
 }
 
-static ALWAYS_INLINE unsigned
-radv_get_rasterization_samples(struct radv_cmd_buffer *cmd_buffer)
+ALWAYS_INLINE static void
+radv_set_total_samples(struct radv_cmd_buffer *cmd_buffer)
 {
    const struct radv_dynamic_state *d = &cmd_buffer->state.dynamic;
 
@@ -1070,14 +1064,12 @@ radv_get_rasterization_samples(struct radv_cmd_buffer *cmd_buffer)
        * number of rasterization samples, and cover all samples in those pixels (unless masked out
        * or killed)."
        */
-      return 1;
-   }
-
-   if (line_mode == VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH) {
-      return RADV_NUM_SMOOTH_AA_SAMPLES;
+      cmd_buffer->state.total_samples = 1;
+   } else if (line_mode == VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH) {
+      cmd_buffer->state.total_samples =  RADV_NUM_SMOOTH_AA_SAMPLES;
+   } else {
+      cmd_buffer->state.total_samples = MAX2(1, d->vk.ms.rasterization_samples);
    }
-
-   return MAX2(1, d->vk.ms.rasterization_samples);
 }
 
 ALWAYS_INLINE void
@@ -1094,7 +1086,7 @@ radv_get_ps_iter_samples(struct radv_cmd_buffer *cmd_buffer)
    unsigned ps_iter_samples = 1;
 
    if (cmd_buffer->state.ms.sample_shading_enable) {
-      unsigned rasterization_samples = radv_get_rasterization_samples(cmd_buffer);
+      unsigned rasterization_samples = cmd_buffer->state.total_samples;
       unsigned color_samples = MAX2(render->color_samples, rasterization_samples);
 
       ps_iter_samples = ceilf(cmd_buffer->state.ms.min_sample_shading * color_samples);
@@ -1328,7 +1320,7 @@ radv_gfx10_compute_bin_size(struct radv_cmd_buffer *cmd_buffer)
    const unsigned color_tag_part = (color_tag_count * rb_count / pipe_count) * color_tag_size * pipe_count;
    const unsigned fmask_tag_part = (fmask_tag_count * rb_count / pipe_count) * fmask_tag_size * pipe_count;
 
-   const unsigned total_samples = radv_get_rasterization_samples(cmd_buffer);
+   const unsigned total_samples = cmd_buffer->state.total_samples;
    const unsigned samples_log = util_logbase2_ceil(total_samples);
 
    unsigned color_bytes_per_pixel = 0;
@@ -1612,7 +1604,7 @@ radv_gfx9_compute_bin_size(struct radv_cmd_buffer *cmd_buffer)
    unsigned log_num_rb_per_se = util_logbase2_ceil(pdev->info.max_render_backends / pdev->info.max_se);
    unsigned log_num_se = util_logbase2_ceil(pdev->info.max_se);
 
-   unsigned total_samples = radv_get_rasterization_samples(cmd_buffer);
+   unsigned total_samples = cmd_buffer->state.total_samples;
    unsigned ps_iter_samples = radv_get_ps_iter_samples(cmd_buffer);
    unsigned effective_samples = total_samples;
    unsigned color_bytes_per_pixel = 0;
@@ -3629,7 +3621,7 @@ radv_emit_rasterization_samples(struct radv_cmd_buffer *cmd_buffer)
 {
    struct radv_device *device = radv_cmd_buffer_device(cmd_buffer);
    const struct radv_physical_device *pdev = radv_device_physical(device);
-   unsigned rasterization_samples = radv_get_rasterization_samples(cmd_buffer);
+   unsigned rasterization_samples = cmd_buffer->state.total_samples;
    unsigned ps_iter_samples = radv_get_ps_iter_samples(cmd_buffer);
    const struct radv_dynamic_state *d = &cmd_buffer->state.dynamic;
    unsigned spi_baryc_cntl = S_0286E0_FRONT_FACE_ALL_BITS(0);
@@ -4910,7 +4902,7 @@ radv_flush_occlusion_query_state(struct radv_cmd_buffer *cmd_buffer)
       }
 
       if (gfx_level < GFX12) {
-         const uint32_t rasterization_samples = radv_get_rasterization_samples(cmd_buffer);
+         const uint32_t rasterization_samples = cmd_buffer->state.total_samples;
          const uint32_t sample_rate = util_logbase2(rasterization_samples);
 
          db_count_control |= S_028004_SAMPLE_RATE(sample_rate);
@@ -8381,6 +8373,7 @@ radv_CmdSetPolygonModeEXT(VkCommandBuffer commandBuffer, VkPolygonMode polygonMo
 
    state->dynamic.vk.rs.polygon_mode = polygon_mode;
    radv_set_draw_lines(cmd_buffer);
+   radv_set_total_samples(cmd_buffer);
 
    state->dirty_dynamic |= RADV_DYNAMIC_POLYGON_MODE;
 }
@@ -8556,6 +8549,7 @@ radv_CmdSetRasterizationSamplesEXT(VkCommandBuffer commandBuffer, VkSampleCountF
    struct radv_cmd_state *state = &cmd_buffer->state;
 
    state->dynamic.vk.ms.rasterization_samples = rasterizationSamples;
+   radv_set_total_samples(cmd_buffer);
 
    state->dirty_dynamic |= RADV_DYNAMIC_RASTERIZATION_SAMPLES;
 }
@@ -10343,7 +10337,7 @@ radv_get_ngg_culling_settings(struct radv_cmd_buffer *cmd_buffer, bool vp_y_inve
        * num_samples is also always a power of two, so the small prim precision can only be
        * a power of two between 2^-2 and 2^-6, therefore it's enough to remember the exponent.
        */
-      unsigned rasterization_samples = radv_get_rasterization_samples(cmd_buffer);
+      unsigned rasterization_samples = cmd_buffer->state.total_samples;
       unsigned subpixel_bits = 256;
       int32_t small_prim_precision_log2 = util_logbase2(rasterization_samples) - util_logbase2(subpixel_bits);
       nggc_settings |= ((uint32_t)small_prim_precision_log2 << 24u);
@@ -10409,7 +10403,7 @@ radv_emit_fs_state(struct radv_cmd_buffer *cmd_buffer)
    if (!ps_state_offset)
       return;
 
-   const unsigned rasterization_samples = radv_get_rasterization_samples(cmd_buffer);
+   const unsigned rasterization_samples = cmd_buffer->state.total_samples;
    const unsigned ps_iter_samples = radv_get_ps_iter_samples(cmd_buffer);
    const uint16_t ps_iter_mask = ac_get_ps_iter_mask(ps_iter_samples);
    const unsigned rast_prim = cmd_buffer->state.rast_prim;
@@ -10650,7 +10644,7 @@ radv_emit_db_shader_control(struct radv_cmd_buffer *cmd_buffer)
    const struct radv_dynamic_state *d = &cmd_buffer->state.dynamic;
    const bool uses_ds_feedback_loop =
       !!(d->feedback_loop_aspects & (VK_IMAGE_ASPECT_DEPTH_BIT | VK_IMAGE_ASPECT_STENCIL_BIT));
-   const unsigned rasterization_samples = radv_get_rasterization_samples(cmd_buffer);
+   const unsigned rasterization_samples = cmd_buffer->state.total_samples;
    uint32_t db_dfsm_control = S_028060_PUNCHOUT_MODE(V_028060_FORCE_OFF);
    uint32_t db_shader_control;
 
@@ -11092,7 +11086,7 @@ radv_emit_msaa_state(struct radv_cmd_buffer *cmd_buffer)
    const struct radv_physical_device *pdev = radv_device_physical(device);
    const struct radv_instance *instance = radv_physical_device_instance(pdev);
    const struct radv_shader *ps = cmd_buffer->state.shaders[MESA_SHADER_FRAGMENT];
-   const unsigned rasterization_samples = radv_get_rasterization_samples(cmd_buffer);
+   const unsigned rasterization_samples = cmd_buffer->state.total_samples;
    const struct radv_rendering_state *render = &cmd_buffer->state.render;
    const struct radv_dynamic_state *d = &cmd_buffer->state.dynamic;
    const uint32_t sample_mask = d->vk.ms.sample_mask | ((uint32_t)d->vk.ms.sample_mask << 16);
@@ -14443,6 +14437,7 @@ radv_reset_pipeline_state(struct radv_cmd_buffer *cmd_buffer, VkPipelineBindPoin
          cmd_buffer->state.ms.min_sample_shading = 1.0f;
          cmd_buffer->state.shader_rast_prim = 0;
          cmd_buffer->state.rast_prim = 0;
+         cmd_buffer->state.total_samples = 0;
          cmd_buffer->state.uses_out_of_order_rast = false;
          cmd_buffer->state.uses_vrs_attachment = false;
          cmd_buffer->state.draw_lines = false;
diff --git a/src/amd/vulkan/radv_cmd_buffer.h b/src/amd/vulkan/radv_cmd_buffer.h
index 68e4ae720829a..8b0e153073973 100644
--- a/src/amd/vulkan/radv_cmd_buffer.h
+++ b/src/amd/vulkan/radv_cmd_buffer.h
@@ -517,6 +517,7 @@ struct radv_cmd_state {
 
    uint32_t vtx_base_sgpr;
    uint8_t vtx_emit_num;
+   uint8_t total_samples;
    bool draw_lines;
    bool uses_drawid;
    bool uses_baseinstance;
-- 
GitLab


From 5c126bd6c7f0c2de51aed26f979393908051b516 Mon Sep 17 00:00:00 2001
From: Mike Blumenkrantz <michael.blumenkrantz@gmail.com>
Date: Thu, 14 Aug 2025 14:10:06 -0400
Subject: [PATCH 8/8] radv: add a TOTAL_SAMPLES dirty flag to eliminate
 unnecessary state emissions

this enables RADV_DYNAMIC_PRIMITIVE_TOPOLOGY without lots of recalc
---
 src/amd/vulkan/radv_cmd_buffer.c | 21 ++++++++++++---------
 src/amd/vulkan/radv_cmd_buffer.h |  3 ++-
 2 files changed, 14 insertions(+), 10 deletions(-)

diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index 91d667d38b2bf..fd948d5a10df8 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -1053,6 +1053,7 @@ radv_set_total_samples(struct radv_cmd_buffer *cmd_buffer)
    const struct radv_dynamic_state *d = &cmd_buffer->state.dynamic;
 
    VkLineRasterizationModeEXT line_mode = radv_get_line_mode(cmd_buffer);
+   uint8_t total_samples = cmd_buffer->state.total_samples;
 
    if (line_mode == VK_LINE_RASTERIZATION_MODE_BRESENHAM) {
       /* From the Vulkan spec 1.3.221:
@@ -1070,6 +1071,9 @@ radv_set_total_samples(struct radv_cmd_buffer *cmd_buffer)
    } else {
       cmd_buffer->state.total_samples = MAX2(1, d->vk.ms.rasterization_samples);
    }
+
+   if (total_samples != cmd_buffer->state.total_samples)
+      cmd_buffer->state.dirty |= RADV_CMD_DIRTY_TOTAL_SAMPLES;
 }
 
 ALWAYS_INLINE void
@@ -1077,6 +1081,7 @@ radv_set_rast_sample_state(struct radv_cmd_buffer *cmd_buffer)
 {
    radv_set_rasterization_prim(cmd_buffer);
    radv_set_draw_lines(cmd_buffer);
+   radv_set_total_samples(cmd_buffer);
 }
 
 static ALWAYS_INLINE unsigned
@@ -11366,8 +11371,7 @@ radv_emit_all_graphics_states(struct radv_cmd_buffer *cmd_buffer, const struct r
    if (cmd_buffer->state.dirty & RADV_CMD_DIRTY_RBPLUS)
       radv_emit_rbplus_state(cmd_buffer);
 
-   if ((cmd_buffer->state.dirty & RADV_CMD_DIRTY_OCCLUSION_QUERY) ||
-       (cmd_buffer->state.dirty_dynamic & (RADV_DYNAMIC_RASTERIZATION_SAMPLES | RADV_DYNAMIC_PRIMITIVE_TOPOLOGY)))
+   if (cmd_buffer->state.dirty & (RADV_CMD_DIRTY_OCCLUSION_QUERY | RADV_CMD_DIRTY_TOTAL_SAMPLES))
       radv_flush_occlusion_query_state(cmd_buffer);
 
    if (((cmd_buffer->state.dirty & (RADV_CMD_DIRTY_PIPELINE | RADV_CMD_DIRTY_GRAPHICS_SHADERS)) ||
@@ -11378,10 +11382,8 @@ radv_emit_all_graphics_states(struct radv_cmd_buffer *cmd_buffer, const struct r
        cmd_buffer->state.has_nggc)
       radv_emit_ngg_culling_state(cmd_buffer);
 
-   if ((cmd_buffer->state.dirty & RADV_CMD_DIRTY_FRAMEBUFFER) ||
-       (cmd_buffer->state.dirty_dynamic &
-        (RADV_DYNAMIC_COLOR_WRITE_MASK | RADV_DYNAMIC_RASTERIZATION_SAMPLES | RADV_DYNAMIC_LINE_RASTERIZATION_MODE |
-         RADV_DYNAMIC_PRIMITIVE_TOPOLOGY | RADV_DYNAMIC_POLYGON_MODE)))
+   if ((cmd_buffer->state.dirty & (RADV_CMD_DIRTY_FRAMEBUFFER | RADV_CMD_DIRTY_TOTAL_SAMPLES)) ||
+       (cmd_buffer->state.dirty_dynamic & RADV_DYNAMIC_COLOR_WRITE_MASK))
       radv_emit_binning_state(cmd_buffer);
 
    if (cmd_buffer->state.dirty & RADV_CMD_DIRTY_PIPELINE) {
@@ -11402,10 +11404,9 @@ radv_emit_all_graphics_states(struct radv_cmd_buffer *cmd_buffer, const struct r
    if (cmd_buffer->state.dirty & RADV_CMD_DIRTY_GUARDBAND)
       radv_emit_guardband_state(cmd_buffer);
 
-   if ((cmd_buffer->state.dirty & RADV_CMD_DIRTY_DB_SHADER_CONTROL) ||
+   if ((cmd_buffer->state.dirty & (RADV_CMD_DIRTY_DB_SHADER_CONTROL | RADV_CMD_DIRTY_TOTAL_SAMPLES)) ||
        (cmd_buffer->state.dirty_dynamic &
-        (RADV_DYNAMIC_COLOR_WRITE_MASK | RADV_DYNAMIC_COLOR_BLEND_ENABLE | RADV_DYNAMIC_RASTERIZATION_SAMPLES |
-         RADV_DYNAMIC_LINE_RASTERIZATION_MODE | RADV_DYNAMIC_PRIMITIVE_TOPOLOGY | RADV_DYNAMIC_POLYGON_MODE |
+        (RADV_DYNAMIC_COLOR_WRITE_MASK | RADV_DYNAMIC_COLOR_BLEND_ENABLE |
          RADV_DYNAMIC_ATTACHMENT_FEEDBACK_LOOP_ENABLE | RADV_DYNAMIC_ALPHA_TO_COVERAGE_ENABLE |
          RADV_DYNAMIC_ALPHA_TO_ONE_ENABLE)))
       radv_emit_db_shader_control(cmd_buffer);
@@ -11447,6 +11448,8 @@ radv_emit_all_graphics_states(struct radv_cmd_buffer *cmd_buffer, const struct r
       radv_emit_scissor(cmd_buffer);
       cmd_buffer->cs->context_roll_without_scissor_emitted = false;
    }
+
+   cmd_buffer->state.dirty &= ~RADV_CMD_DIRTY_TOTAL_SAMPLES;
 }
 
 static void
diff --git a/src/amd/vulkan/radv_cmd_buffer.h b/src/amd/vulkan/radv_cmd_buffer.h
index 8b0e153073973..3470e1fb6efbc 100644
--- a/src/amd/vulkan/radv_cmd_buffer.h
+++ b/src/amd/vulkan/radv_cmd_buffer.h
@@ -106,7 +106,8 @@ enum radv_cmd_dirty_bits {
    RADV_CMD_DIRTY_TESS_STATE = 1ull << 20,
    RADV_CMD_DIRTY_CB_RENDER_STATE = 1ull << 21,
    RADV_CMD_DIRTY_VRS = 1ull << 22,
-   RADV_CMD_DIRTY_ALL = (1ull << 23) - 1,
+   RADV_CMD_DIRTY_TOTAL_SAMPLES = 1ull << 23,
+   RADV_CMD_DIRTY_ALL = (1ull << 24) - 1,
 
    RADV_CMD_DIRTY_SHADER_QUERY = RADV_CMD_DIRTY_NGG_STATE | RADV_CMD_DIRTY_TASK_STATE,
 };
-- 
GitLab

