From 1bf61a9f0d8b307009f3cee5dcfaf1028144cd77 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Daniel=20Sch=C3=BCrmann?= <daniel@schuermann.dev>
Date: Tue, 20 Jun 2023 15:36:38 +0200
Subject: [PATCH 1/3] aco/assembler: align resume shaders with cache lines

---
 src/amd/compiler/aco_assembler.cpp | 12 ++++++++++++
 1 file changed, 12 insertions(+)

diff --git a/src/amd/compiler/aco_assembler.cpp b/src/amd/compiler/aco_assembler.cpp
index 300ebdfbab94..2a2a6cf02753 100644
--- a/src/amd/compiler/aco_assembler.cpp
+++ b/src/amd/compiler/aco_assembler.cpp
@@ -1216,6 +1216,17 @@ fix_constaddrs(asm_context& ctx, std::vector<uint32_t>& out)
    }
 }
 
+void
+align_block(asm_context& ctx, std::vector<uint32_t>& code, Block& block)
+{
+   /* align resume shaders with cache line */
+   if (block.kind & block_kind_resume) {
+      size_t cache_aligned = align(code.size(), 16);
+      code.resize(cache_aligned, 0xbf800000u); /* s_nop 0 */
+      block.offset = code.size();
+   }
+}
+
 unsigned
 emit_program(Program* program, std::vector<uint32_t>& code, std::vector<struct aco_symbol>* symbols)
 {
@@ -1227,6 +1238,7 @@ emit_program(Program* program, std::vector<uint32_t>& code, std::vector<struct a
 
    for (Block& block : program->blocks) {
       block.offset = code.size();
+      align_block(ctx, code, block);
       emit_block(ctx, code, block);
    }
 
-- 
GitLab


From 6eef793f86558c001079dc82464baf8b7569857f Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Daniel=20Sch=C3=BCrmann?= <daniel@schuermann.dev>
Date: Tue, 20 Jun 2023 19:03:35 +0200
Subject: [PATCH 2/3] aco/assembler: align loops if it reduces the number of
 cache lines

This is especially beneficial on GFX6-9.

Totals from 11229 (8.46% of 132726) affected shaders: GFX11
CodeSize: 109608640 -> 109840916 (+0.21%)
---
 src/amd/compiler/aco_assembler.cpp | 30 ++++++++++++++++++++++++++++++
 1 file changed, 30 insertions(+)

diff --git a/src/amd/compiler/aco_assembler.cpp b/src/amd/compiler/aco_assembler.cpp
index 2a2a6cf02753..f98ad480a40a 100644
--- a/src/amd/compiler/aco_assembler.cpp
+++ b/src/amd/compiler/aco_assembler.cpp
@@ -48,6 +48,7 @@ struct asm_context {
    std::map<unsigned, constaddr_info> constaddrs;
    std::map<unsigned, constaddr_info> resumeaddrs;
    std::vector<struct aco_symbol>* symbols;
+   Block* loop_header;
    const int16_t* opcode;
    // TODO: keep track of branch instructions referring blocks
    // and, when emitting the block, correct the offset in instr
@@ -1219,6 +1220,35 @@ fix_constaddrs(asm_context& ctx, std::vector<uint32_t>& out)
 void
 align_block(asm_context& ctx, std::vector<uint32_t>& code, Block& block)
 {
+   if (block.kind & block_kind_loop_exit && ctx.loop_header) {
+      Block* loop_header = ctx.loop_header;
+      ctx.loop_header = NULL;
+      std::vector<uint32_t> nops;
+
+      const unsigned loop_num_cl = DIV_ROUND_UP(block.offset - loop_header->offset, 16);
+      const unsigned loop_start_cl = loop_header->offset >> 4;
+      const unsigned loop_end_cl = (block.offset - 1) >> 4;
+
+      /* Align the loop if it fits into a single cache line or if we can
+       * reduce the number of cache lines with less than 8 NOPs.
+       */
+      const bool align_loop = loop_end_cl - loop_start_cl >= loop_num_cl &&
+                              (loop_num_cl == 1 || loop_header->offset % 16 > 8);
+
+      if (align_loop) {
+         nops.resize(16 - (loop_header->offset % 16), 0xbf800000u);
+         insert_code(ctx, code, loop_header->offset, nops.size(), nops.data());
+      }
+   }
+
+   if (block.kind & block_kind_loop_header) {
+      /* In case of nested loops, only handle the inner-most loops in order
+       * to not break the alignment of inner loops by handling outer loops.
+       * Also ignore loops without back-edge.
+       */
+      ctx.loop_header = block.linear_preds.size() > 1 ? &block : NULL;
+   }
+
    /* align resume shaders with cache line */
    if (block.kind & block_kind_resume) {
       size_t cache_aligned = align(code.size(), 16);
-- 
GitLab


From 51dd89038e9b1d3e19c26f9314ec486e7b8c0c66 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Daniel=20Sch=C3=BCrmann?= <daniel@schuermann.dev>
Date: Wed, 21 Jun 2023 14:08:06 +0200
Subject: [PATCH 3/3] aco/assembler: change prefetch mode during loops if
 beneficial

Totals from 8864 (6.68% of 132726) affected shaders: GFX11
CodeSize: 90776128 -> 90923760 (+0.16%)
---
 src/amd/compiler/aco_assembler.cpp | 22 ++++++++++++++++++++--
 1 file changed, 20 insertions(+), 2 deletions(-)

diff --git a/src/amd/compiler/aco_assembler.cpp b/src/amd/compiler/aco_assembler.cpp
index f98ad480a40a..9633f9d7a2a7 100644
--- a/src/amd/compiler/aco_assembler.cpp
+++ b/src/amd/compiler/aco_assembler.cpp
@@ -1226,16 +1226,34 @@ align_block(asm_context& ctx, std::vector<uint32_t>& code, Block& block)
       std::vector<uint32_t> nops;
 
       const unsigned loop_num_cl = DIV_ROUND_UP(block.offset - loop_header->offset, 16);
+
+      /* On GFX10+, change the prefetch mode if the loop fits into 2 or 3 cache lines. */
+      const bool change_prefetch =
+         ctx.program->gfx_level >= GFX10 && loop_num_cl > 1 && loop_num_cl <= 3;
+
+      if (change_prefetch) {
+         Builder bld(ctx.program);
+         int16_t prefetch_mode = loop_num_cl == 3 ? 0x1 : 0x2;
+         aco_ptr<Instruction> instr(bld.sopp(aco_opcode::s_inst_prefetch, -1, prefetch_mode));
+         emit_instruction(ctx, nops, instr.get());
+         insert_code(ctx, code, loop_header->offset, nops.size(), nops.data());
+
+         /* Change prefetch mode back to default (0x3). */
+         instr->sopp().imm = 0x3;
+         emit_instruction(ctx, code, instr.get());
+      }
+
       const unsigned loop_start_cl = loop_header->offset >> 4;
       const unsigned loop_end_cl = (block.offset - 1) >> 4;
 
-      /* Align the loop if it fits into a single cache line or if we can
+      /* Align the loop if it fits into the fetched cache lines or if we can
        * reduce the number of cache lines with less than 8 NOPs.
        */
       const bool align_loop = loop_end_cl - loop_start_cl >= loop_num_cl &&
-                              (loop_num_cl == 1 || loop_header->offset % 16 > 8);
+                              (loop_num_cl == 1 || change_prefetch || loop_header->offset % 16 > 8);
 
       if (align_loop) {
+         nops.clear();
          nops.resize(16 - (loop_header->offset % 16), 0xbf800000u);
          insert_code(ctx, code, loop_header->offset, nops.size(), nops.data());
       }
-- 
GitLab

