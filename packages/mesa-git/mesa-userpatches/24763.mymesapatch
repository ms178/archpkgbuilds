From e1a1289ada3a07d28f65542a41fdb10b5f80a711 Mon Sep 17 00:00:00 2001
From: Emma Anholt <emma@anholt.net>
Date: Thu, 17 Aug 2023 11:50:50 -0700
Subject: [PATCH 1/3] i915: Make I915_DEBUG=fs log shaders that fail to link
 due to CF.

---
 src/gallium/drivers/i915/i915_screen.c | 7 ++++++-
 1 file changed, 6 insertions(+), 1 deletion(-)

diff --git a/src/gallium/drivers/i915/i915_screen.c b/src/gallium/drivers/i915/i915_screen.c
index ac0e6adf6c8d..c56ad5372fdb 100644
--- a/src/gallium/drivers/i915/i915_screen.c
+++ b/src/gallium/drivers/i915/i915_screen.c
@@ -281,8 +281,13 @@ i915_finalize_nir(struct pipe_screen *pscreen, void *nir)
    nir_sweep(s);
 
    char *msg = i915_check_control_flow(s);
-   if (msg)
+   if (msg) {
+      if (I915_DBG_ON(DBG_FS)) {
+         mesa_logi("failing shader:");
+         nir_log_shaderi(s);
+      }
       return strdup(msg);
+   }
 
    if (s->info.stage == MESA_SHADER_FRAGMENT)
       return i915_test_fragment_shader_compile(pscreen, s);
-- 
GitLab


From 676cb804007ca26f31b72d49bd28f9103ed1878e Mon Sep 17 00:00:00 2001
From: Emma Anholt <emma@anholt.net>
Date: Tue, 3 Oct 2023 10:04:04 -0700
Subject: [PATCH 2/3] nir: Flatten ifs with discards in nir_opt_peephole_select
 for HW without CF.

i915g and r300-r400 don't have if statements, and discards are all
nir_intrinsic_discard_if.  We can flatten those discards here, saving a
separate GLSL pass to try to do so.

i915g:
GAINED: shaders/closed/xcom-enemy-unknown/413.shader_test FS

rv370:
GAINED: shaders/closed/xcom-enemy-unknown/12.shader_test FS
GAINED: shaders/closed/xcom-enemy-unknown/122.shader_test FS
GAINED: shaders/closed/xcom-enemy-unknown/132.shader_test FS
GAINED: shaders/closed/xcom-enemy-unknown/145.shader_test FS
GAINED: shaders/closed/xcom-enemy-unknown/146.shader_test FS
GAINED: shaders/closed/xcom-enemy-unknown/19.shader_test FS
GAINED: shaders/closed/xcom-enemy-unknown/413.shader_test FS
GAINED: shaders/closed/xcom-enemy-unknown/415.shader_test FS

Closes: #9918
---
 src/compiler/nir/nir_opt_peephole_select.c | 46 ++++++++++++++++++++--
 1 file changed, 43 insertions(+), 3 deletions(-)

diff --git a/src/compiler/nir/nir_opt_peephole_select.c b/src/compiler/nir/nir_opt_peephole_select.c
index f0b2c7f19254..506f597fc2d1 100644
--- a/src/compiler/nir/nir_opt_peephole_select.c
+++ b/src/compiler/nir/nir_opt_peephole_select.c
@@ -23,6 +23,7 @@
 
 #include "nir/nir_builder.h"
 #include "nir.h"
+#include "nir_builder.h"
 #include "nir_control_flow.h"
 #include "nir_search_helpers.h"
 
@@ -74,10 +75,21 @@ block_check_for_allowed_instrs(nir_block *block, unsigned *count,
          case nir_instr_type_tex:
             break;
 
-         case nir_instr_type_intrinsic:
-            if (!nir_intrinsic_can_reorder(nir_instr_as_intrinsic(instr)))
-               return false;
+         case nir_instr_type_intrinsic: {
+            nir_intrinsic_instr *intr = nir_instr_as_intrinsic(instr);
+            switch (intr->intrinsic) {
+            case nir_intrinsic_discard:
+            case nir_intrinsic_discard_if:
+              /* For non-CF hardware, we need to be able to move discards up
+               * and flatten, so let them pass.
+               */
+              continue;
+            default:
+               if (!nir_intrinsic_can_reorder(intr))
+                  return false;
+            }
             break;
+         }
 
          case nir_instr_type_call:
          case nir_instr_type_jump:
@@ -362,6 +374,32 @@ nir_opt_collapse_if(nir_if *if_stmt, nir_shader *shader, unsigned limit,
    return true;
 }
 
+/* If we're moving discards out of the if for non-CF hardware, we need to add
+ * the if's condition to it
+ */
+static void
+rewrite_discard_conds(nir_instr *instr, nir_def *if_cond, bool is_else)
+{
+   if (instr->type != nir_instr_type_intrinsic)
+      return;
+   nir_intrinsic_instr *intr = nir_instr_as_intrinsic(instr);
+
+   if (intr->intrinsic != nir_intrinsic_discard_if && intr->intrinsic != nir_intrinsic_discard)
+      return;
+
+   nir_builder b = nir_builder_at(nir_before_instr(instr));
+
+   if (is_else)
+      if_cond = nir_inot(&b, if_cond);
+
+   if (intr->intrinsic == nir_intrinsic_discard_if) {
+      nir_src_rewrite(&intr->src[0], nir_iand(&b, intr->src[0].ssa, if_cond));
+   } else {
+      nir_discard_if(&b, if_cond);
+      nir_instr_remove(instr);
+   }
+}
+
 static bool
 nir_opt_peephole_select_block(nir_block *block, nir_shader *shader,
                               unsigned limit, bool indirect_load_ok,
@@ -434,12 +472,14 @@ nir_opt_peephole_select_block(nir_block *block, nir_shader *shader,
       exec_node_remove(&instr->node);
       instr->block = prev_block;
       exec_list_push_tail(&prev_block->instr_list, &instr->node);
+      rewrite_discard_conds(instr, if_stmt->condition.ssa, false);
    }
 
    nir_foreach_instr_safe(instr, else_block) {
       exec_node_remove(&instr->node);
       instr->block = prev_block;
       exec_list_push_tail(&prev_block->instr_list, &instr->node);
+      rewrite_discard_conds(instr, if_stmt->condition.ssa, true);
    }
 
    nir_foreach_phi_safe(phi, block) {
-- 
GitLab


From 438652fa8138b92f29675f641869bb441fc8690b Mon Sep 17 00:00:00 2001
From: Emma Anholt <emma@anholt.net>
Date: Thu, 17 Aug 2023 11:23:35 -0700
Subject: [PATCH 3/3] glsl: Remove lower_discard().

Replaced by the new NIR pass.

i915g results:
total instructions in shared programs: 510678 -> 510714 (<.01%)
total temps in shared programs: 30429 -> 30426 (<.01%)

rv370 results:
total instructions in shared programs: 737649 -> 737656 (<.01%)
instructions in affected programs: 82 -> 89 (8.54%)
total temps in shared programs: 112093 -> 112094 (<.01%)
temps in affected programs: 6 -> 7 (16.67%)
---
 src/compiler/glsl/ir_optimization.h       |   1 -
 src/compiler/glsl/lower_discard.cpp       | 201 ----------------------
 src/compiler/glsl/meson.build             |   1 -
 src/compiler/glsl/test_optpass.cpp        |   2 -
 src/mesa/state_tracker/st_glsl_to_nir.cpp |   5 -
 5 files changed, 210 deletions(-)
 delete mode 100644 src/compiler/glsl/lower_discard.cpp

diff --git a/src/compiler/glsl/ir_optimization.h b/src/compiler/glsl/ir_optimization.h
index 0a394d4371f0..d10a4327f15b 100644
--- a/src/compiler/glsl/ir_optimization.h
+++ b/src/compiler/glsl/ir_optimization.h
@@ -57,7 +57,6 @@ bool do_mat_op_to_vec(exec_list *instructions);
 bool do_minmax_prune(exec_list *instructions);
 bool do_tree_grafting(exec_list *instructions);
 bool do_vec_index_to_cond_assign(exec_list *instructions);
-bool lower_discard(exec_list *instructions);
 void lower_discard_flow(exec_list *instructions);
 bool lower_instructions(exec_list *instructions,
                         bool have_dround,
diff --git a/src/compiler/glsl/lower_discard.cpp b/src/compiler/glsl/lower_discard.cpp
deleted file mode 100644
index 203d9e3b9603..000000000000
--- a/src/compiler/glsl/lower_discard.cpp
+++ /dev/null
@@ -1,201 +0,0 @@
-/*
- * Copyright Â© 2010 Intel Corporation
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice (including the next
- * paragraph) shall be included in all copies or substantial portions of the
- * Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- */
-
-/**
- * \file lower_discard.cpp
- *
- * This pass moves discards out of if-statements.
- *
- * Case 1: The "then" branch contains a conditional discard:
- * ---------------------------------------------------------
- *
- *    if (cond1) {
- *	 s1;
- *	 discard cond2;
- *	 s2;
- *    } else {
- *	 s3;
- *    }
- *
- * becomes:
- *
- *    temp = false;
- *    if (cond1) {
- *	 s1;
- *	 temp = cond2;
- *	 s2;
- *    } else {
- *	 s3;
- *    }
- *    discard temp;
- *
- * Case 2: The "else" branch contains a conditional discard:
- * ---------------------------------------------------------
- *
- *    if (cond1) {
- *	 s1;
- *    } else {
- *	 s2;
- *	 discard cond2;
- *	 s3;
- *    }
- *
- * becomes:
- *
- *    temp = false;
- *    if (cond1) {
- *	 s1;
- *    } else {
- *	 s2;
- *	 temp = cond2;
- *	 s3;
- *    }
- *    discard temp;
- *
- * Case 3: Both branches contain a conditional discard:
- * ----------------------------------------------------
- *
- *    if (cond1) {
- *	 s1;
- *	 discard cond2;
- *	 s2;
- *    } else {
- *	 s3;
- *	 discard cond3;
- *	 s4;
- *    }
- *
- * becomes:
- *
- *    temp = false;
- *    if (cond1) {
- *	 s1;
- *	 temp = cond2;
- *	 s2;
- *    } else {
- *	 s3;
- *	 temp = cond3;
- *	 s4;
- *    }
- *    discard temp;
- *
- * If there are multiple conditional discards, we need only deal with one of
- * them.  Repeatedly applying this pass will take care of the others.
- *
- * Unconditional discards are treated as having a condition of "true".
- */
-
-#include "compiler/glsl_types.h"
-#include "ir.h"
-
-namespace {
-
-class lower_discard_visitor : public ir_hierarchical_visitor {
-public:
-   lower_discard_visitor()
-   {
-      this->progress = false;
-   }
-
-   ir_visitor_status visit_leave(ir_if *);
-
-   bool progress;
-};
-
-} /* anonymous namespace */
-
-bool
-lower_discard(exec_list *instructions)
-{
-   lower_discard_visitor v;
-
-   visit_list_elements(&v, instructions);
-
-   return v.progress;
-}
-
-
-static ir_discard *
-find_discard(exec_list &instructions)
-{
-   foreach_in_list(ir_instruction, node, &instructions) {
-      ir_discard *ir = node->as_discard();
-      if (ir != NULL)
-	 return ir;
-   }
-   return NULL;
-}
-
-
-static void
-replace_discard(void *mem_ctx, ir_variable *var, ir_discard *ir)
-{
-   ir_rvalue *condition = ir->condition;
-
-   /* For unconditional discards, use "true" as the condition. */
-   if (condition == NULL)
-      condition = new(mem_ctx) ir_constant(true);
-
-   ir_assignment *assignment =
-      new(mem_ctx) ir_assignment(new(mem_ctx) ir_dereference_variable(var),
-                                 condition);
-
-   ir->replace_with(assignment);
-}
-
-
-ir_visitor_status
-lower_discard_visitor::visit_leave(ir_if *ir)
-{
-   ir_discard *then_discard = find_discard(ir->then_instructions);
-   ir_discard *else_discard = find_discard(ir->else_instructions);
-
-   if (then_discard == NULL && else_discard == NULL)
-      return visit_continue;
-
-   void *mem_ctx = ralloc_parent(ir);
-
-   ir_variable *temp = new(mem_ctx) ir_variable(glsl_type::bool_type,
-						"discard_cond_temp",
-						ir_var_temporary);
-   ir_assignment *temp_initializer =
-      new(mem_ctx) ir_assignment(new(mem_ctx) ir_dereference_variable(temp),
-                                 new(mem_ctx) ir_constant(false));
-
-   ir->insert_before(temp);
-   ir->insert_before(temp_initializer);
-
-   if (then_discard != NULL)
-      replace_discard(mem_ctx, temp, then_discard);
-
-   if (else_discard != NULL)
-      replace_discard(mem_ctx, temp, else_discard);
-
-   ir_discard *discard = then_discard != NULL ? then_discard : else_discard;
-   discard->condition = new(mem_ctx) ir_dereference_variable(temp);
-   ir->insert_after(discard);
-
-   this->progress = true;
-
-   return visit_continue;
-}
diff --git a/src/compiler/glsl/meson.build b/src/compiler/glsl/meson.build
index 07ee91366ef6..9cb51e323dd4 100644
--- a/src/compiler/glsl/meson.build
+++ b/src/compiler/glsl/meson.build
@@ -197,7 +197,6 @@ files_libglsl = files(
   'link_uniform_blocks.cpp',
   'list.h',
   'lower_builtins.cpp',
-  'lower_discard.cpp',
   'lower_discard_flow.cpp',
   'lower_distance.cpp',
   'lower_instructions.cpp',
diff --git a/src/compiler/glsl/test_optpass.cpp b/src/compiler/glsl/test_optpass.cpp
index e0a2e8a0565d..d875444587e4 100644
--- a/src/compiler/glsl/test_optpass.cpp
+++ b/src/compiler/glsl/test_optpass.cpp
@@ -89,8 +89,6 @@ do_optimization(struct exec_list *ir, const char *optimization,
       return do_tree_grafting(ir);
    } else if (strcmp(optimization, "do_vec_index_to_cond_assign") == 0) {
       return do_vec_index_to_cond_assign(ir);
-   } else if (strcmp(optimization, "lower_discard") == 0) {
-      return lower_discard(ir);
    } else if (sscanf(optimization, "lower_instructions ( %d ) ",
                      &int_0) == 1) {
       return lower_instructions(ir, false, false);
diff --git a/src/mesa/state_tracker/st_glsl_to_nir.cpp b/src/mesa/state_tracker/st_glsl_to_nir.cpp
index a83a0f747935..7c457fd98c41 100644
--- a/src/mesa/state_tracker/st_glsl_to_nir.cpp
+++ b/src/mesa/state_tracker/st_glsl_to_nir.cpp
@@ -510,8 +510,6 @@ st_link_glsl_to_nir(struct gl_context *ctx,
          struct gl_linked_shader *shader = shader_program->_LinkedShaders[i];
          exec_list *ir = shader->ir;
          gl_shader_stage stage = shader->Stage;
-         const struct gl_shader_compiler_options *options =
-               &ctx->Const.ShaderCompilerOptions[stage];
 
          enum pipe_shader_type ptarget = pipe_shader_type_from_mesa(stage);
          bool have_dround = pscreen->get_shader_param(pscreen, ptarget,
@@ -529,9 +527,6 @@ st_link_glsl_to_nir(struct gl_context *ctx,
                             ctx->Extensions.ARB_gpu_shader5);
 
          do_vec_index_to_cond_assign(ir);
-         if (options->MaxIfDepth == 0) {
-            lower_discard(ir);
-         }
 
          validate_ir_tree(ir);
       }
-- 
GitLab

