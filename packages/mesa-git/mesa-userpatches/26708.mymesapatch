From 0b069f2bd1ad0aabc7a81f345ae17acc5ca87376 Mon Sep 17 00:00:00 2001
From: Caio Oliveira <caio.oliveira@intel.com>
Date: Thu, 14 Dec 2023 22:14:03 -0800
Subject: [PATCH 1/9] intel/compiler: Use glsl_type C helpers

---
 src/intel/compiler/brw_mesh.cpp         |  6 +++---
 src/intel/compiler/brw_vec4.cpp         |  2 +-
 src/intel/compiler/brw_vec4_gs_nir.cpp  |  2 +-
 src/intel/compiler/brw_vec4_nir.cpp     |  4 ++--
 src/intel/compiler/brw_vec4_visitor.cpp | 12 ++++++------
 5 files changed, 13 insertions(+), 13 deletions(-)

diff --git a/src/intel/compiler/brw_mesh.cpp b/src/intel/compiler/brw_mesh.cpp
index 8d88d929d7f62..66a02b2275e60 100644
--- a/src/intel/compiler/brw_mesh.cpp
+++ b/src/intel/compiler/brw_mesh.cpp
@@ -1333,9 +1333,9 @@ brw_can_pack_primitive_indices(nir_shader *nir, struct index_packing_state *stat
       return true;
 
    ASSERTED const struct glsl_type *type = state->original_prim_indices->type;
-   assert(type->is_array());
-   assert(type->without_array()->is_vector());
-   assert(type->without_array()->vector_elements == state->vertices_per_primitive);
+   assert(glsl_type_is_array(type));
+   assert(glsl_type_is_vector(glsl_without_array(type)));
+   assert(glsl_without_array(type)->vector_elements == state->vertices_per_primitive);
 
    nir_foreach_function_impl(impl, nir) {
       nir_foreach_block(block, impl) {
diff --git a/src/intel/compiler/brw_vec4.cpp b/src/intel/compiler/brw_vec4.cpp
index 63ab52143f4bc..631050f31e33a 100644
--- a/src/intel/compiler/brw_vec4.cpp
+++ b/src/intel/compiler/brw_vec4.cpp
@@ -53,7 +53,7 @@ src_reg::src_reg(enum brw_reg_file file, int nr, const glsl_type *type)
 
    this->file = file;
    this->nr = nr;
-   if (type && (type->is_scalar() || type->is_vector() || type->is_matrix()))
+   if (type && (glsl_type_is_scalar(type) || glsl_type_is_vector(type) || glsl_type_is_matrix(type)))
       this->swizzle = brw_swizzle_for_size(type->vector_elements);
    else
       this->swizzle = BRW_SWIZZLE_XYZW;
diff --git a/src/intel/compiler/brw_vec4_gs_nir.cpp b/src/intel/compiler/brw_vec4_gs_nir.cpp
index 818688de4e52a..60b42da87b9aa 100644
--- a/src/intel/compiler/brw_vec4_gs_nir.cpp
+++ b/src/intel/compiler/brw_vec4_gs_nir.cpp
@@ -43,7 +43,7 @@ vec4_gs_visitor::nir_emit_intrinsic(nir_intrinsic_instr *instr)
       const unsigned input_array_stride = prog_data->urb_read_length * 2;
 
       /* Make up a type...we have no way of knowing... */
-      const glsl_type *const type = glsl_type::ivec(instr->num_components);
+      const glsl_type *const type = glsl_ivec_type(instr->num_components);
 
       src = src_reg(ATTR, input_array_stride * vertex +
                     nir_intrinsic_base(instr) + offset_reg,
diff --git a/src/intel/compiler/brw_vec4_nir.cpp b/src/intel/compiler/brw_vec4_nir.cpp
index e72646d361c0a..9121f8e10f26b 100644
--- a/src/intel/compiler/brw_vec4_nir.cpp
+++ b/src/intel/compiler/brw_vec4_nir.cpp
@@ -1908,13 +1908,13 @@ vec4_visitor::nir_emit_texture(nir_tex_instr *instr)
          case nir_texop_samples_identical:
             coordinate = get_nir_src(instr->src[i].src, BRW_REGISTER_TYPE_D,
                                      src_size);
-            coord_type = glsl_type::ivec(src_size);
+            coord_type = glsl_ivec_type(src_size);
             break;
 
          default:
             coordinate = get_nir_src(instr->src[i].src, BRW_REGISTER_TYPE_F,
                                      src_size);
-            coord_type = glsl_type::vec(src_size);
+            coord_type = glsl_vec_type(src_size);
             break;
          }
          break;
diff --git a/src/intel/compiler/brw_vec4_visitor.cpp b/src/intel/compiler/brw_vec4_visitor.cpp
index f96c189136588..ea89b8b620055 100644
--- a/src/intel/compiler/brw_vec4_visitor.cpp
+++ b/src/intel/compiler/brw_vec4_visitor.cpp
@@ -582,10 +582,10 @@ type_size_xvec4(const struct glsl_type *type, bool as_vec4, bool bindless)
    case GLSL_TYPE_INT8:
    case GLSL_TYPE_UINT64:
    case GLSL_TYPE_INT64:
-      if (type->is_matrix()) {
-         const glsl_type *col_type = type->column_type();
+      if (glsl_type_is_matrix(type)) {
+         const glsl_type *col_type = glsl_get_column_type(type);
          unsigned col_slots =
-            (as_vec4 && col_type->is_dual_slot()) ? 2 : 1;
+            (as_vec4 && glsl_type_is_dual_slot(col_type)) ? 2 : 1;
          return type->matrix_columns * col_slots;
       } else {
          /* Regardless of size of vector, it gets a vec4. This is bad
@@ -593,7 +593,7 @@ type_size_xvec4(const struct glsl_type *type, bool as_vec4, bool bindless)
           * mess.  Hopefully a later pass over the code can pack scalars
           * down if appropriate.
           */
-         return (as_vec4 && type->is_dual_slot()) ? 2 : 1;
+         return (as_vec4 && glsl_type_is_dual_slot(type)) ? 2 : 1;
       }
    case GLSL_TYPE_ARRAY:
       assert(type->length > 0);
@@ -677,7 +677,7 @@ src_reg::src_reg(class vec4_visitor *v, const struct glsl_type *type)
    this->file = VGRF;
    this->nr = v->alloc.allocate(type_size_vec4(type, false));
 
-   if (type->is_array() || type->is_struct()) {
+   if (glsl_type_is_array(type) || glsl_type_is_struct(type)) {
       this->swizzle = BRW_SWIZZLE_NOOP;
    } else {
       this->swizzle = brw_swizzle_for_size(type->vector_elements);
@@ -707,7 +707,7 @@ dst_reg::dst_reg(class vec4_visitor *v, const struct glsl_type *type)
    this->file = VGRF;
    this->nr = v->alloc.allocate(type_size_vec4(type, false));
 
-   if (type->is_array() || type->is_struct()) {
+   if (glsl_type_is_array(type) || glsl_type_is_struct(type)) {
       this->writemask = WRITEMASK_XYZW;
    } else {
       this->writemask = (1 << type->vector_elements) - 1;
-- 
GitLab


From 7dd3d58ada9b21aa665c7a4ac30de59c3d92785c Mon Sep 17 00:00:00 2001
From: Caio Oliveira <caio.oliveira@intel.com>
Date: Thu, 14 Dec 2023 22:31:27 -0800
Subject: [PATCH 2/9] r600/sfn: Use glsl_type C helpers

In one case, just used glsl_without_array instead of checking if its
an array to decide to use.  Using that helper with a non-array type
just returns the type.
---
 src/gallium/drivers/r600/sfn/sfn_nir.cpp      |  4 +-
 .../drivers/r600/sfn/sfn_nir_lower_64bit.cpp  | 38 +++++++++----------
 .../drivers/r600/sfn/sfn_nir_lower_tex.cpp    |  2 +-
 src/gallium/drivers/r600/sfn/sfn_shader.cpp   | 12 +++---
 4 files changed, 28 insertions(+), 28 deletions(-)

diff --git a/src/gallium/drivers/r600/sfn/sfn_nir.cpp b/src/gallium/drivers/r600/sfn/sfn_nir.cpp
index f490c63ff5e78..b973cdfa2212a 100644
--- a/src/gallium/drivers/r600/sfn/sfn_nir.cpp
+++ b/src/gallium/drivers/r600/sfn/sfn_nir.cpp
@@ -443,7 +443,7 @@ r600_nir_lower_atomics(nir_shader *shader)
    std::map<unsigned, nir_variable *> sorted_var;
 
    nir_foreach_variable_with_modes_safe(var, shader, nir_var_uniform) {
-      if (var->type->contains_atomic()) {
+      if (glsl_contains_atomic(var->type)) {
          sorted_var[(var->data.binding << 16) | var->data.offset] = var;
          exec_node_remove(&var->node);
       }
@@ -451,7 +451,7 @@ r600_nir_lower_atomics(nir_shader *shader)
 
    for (auto& [dummy, var] : sorted_var) {
       auto iindex = binding_offset.find(var->data.binding);
-      unsigned offset_update = var->type->atomic_size() / 4; /* ATOMIC_COUNTER_SIZE */
+      unsigned offset_update = glsl_atomic_size(var->type) / 4; /* ATOMIC_COUNTER_SIZE */
       if (iindex == binding_offset.end()) {
          var->data.index = 0;
          binding_offset[var->data.binding] = offset_update;
diff --git a/src/gallium/drivers/r600/sfn/sfn_nir_lower_64bit.cpp b/src/gallium/drivers/r600/sfn/sfn_nir_lower_64bit.cpp
index b11c98c500ac9..449cdf9f3ba1b 100644
--- a/src/gallium/drivers/r600/sfn/sfn_nir_lower_64bit.cpp
+++ b/src/gallium/drivers/r600/sfn/sfn_nir_lower_64bit.cpp
@@ -391,7 +391,7 @@ nir_def *
 LowerSplit64BitVar::split_load_deref_array(nir_intrinsic_instr *intr, nir_src& index)
 {
    auto old_var = nir_intrinsic_get_var(intr, 0);
-   unsigned old_components = old_var->type->without_array()->components();
+   unsigned old_components = glsl_get_components(glsl_without_array(old_var->type));
 
    assert(old_components > 2 && old_components <= 4);
 
@@ -416,7 +416,7 @@ LowerSplit64BitVar::split_store_deref_array(nir_intrinsic_instr *intr,
                                             nir_deref_instr *deref)
 {
    auto old_var = nir_intrinsic_get_var(intr, 0);
-   unsigned old_components = old_var->type->without_array()->components();
+   unsigned old_components = glsl_get_components(glsl_without_array(old_var->type));
 
    assert(old_components > 2 && old_components <= 4);
 
@@ -453,7 +453,7 @@ LowerSplit64BitVar::split_store_deref_var(nir_intrinsic_instr *intr,
                                           UNUSED nir_deref_instr *deref)
 {
    auto old_var = nir_intrinsic_get_var(intr, 0);
-   unsigned old_components = old_var->type->without_array()->components();
+   unsigned old_components = glsl_get_components(glsl_without_array(old_var->type));
 
    assert(old_components > 2 && old_components <= 4);
 
@@ -481,7 +481,7 @@ LowerSplit64BitVar::split_load_deref_var(nir_intrinsic_instr *intr)
 {
    auto old_var = nir_intrinsic_get_var(intr, 0);
    auto vars = get_var_pair(old_var);
-   unsigned old_components = old_var->type->components();
+   unsigned old_components = glsl_get_components(old_var->type);
 
    nir_deref_instr *deref1 = nir_build_deref_var(b, vars.first);
    auto *load1 = nir_load_deref(b, deref1);
@@ -499,18 +499,18 @@ LowerSplit64BitVar::get_var_pair(nir_variable *old_var)
 {
    auto split_vars = m_varmap.find(old_var->data.driver_location);
 
-   assert(old_var->type->without_array()->components() > 2);
+   assert(glsl_get_components(glsl_without_array(old_var->type)) > 2);
 
    if (split_vars == m_varmap.end()) {
       auto var1 = nir_variable_clone(old_var, b->shader);
       auto var2 = nir_variable_clone(old_var, b->shader);
 
       var1->type = glsl_dvec_type(2);
-      var2->type = glsl_dvec_type(old_var->type->without_array()->components() - 2);
+      var2->type = glsl_dvec_type(glsl_get_components(glsl_without_array(old_var->type)) - 2);
 
-      if (old_var->type->is_array()) {
-         var1->type = glsl_array_type(var1->type, old_var->type->array_size(), 0);
-         var2->type = glsl_array_type(var2->type, old_var->type->array_size(), 0);
+      if (glsl_type_is_array(old_var->type)) {
+         var1->type = glsl_array_type(var1->type, glsl_array_size(old_var->type), 0);
+         var2->type = glsl_array_type(var2->type, glsl_array_size(old_var->type), 0);
       }
 
       if (old_var->data.mode == nir_var_shader_in ||
@@ -838,9 +838,9 @@ Lower64BitToVec2::filter(const nir_instr *instr) const
          if (nir_src_bit_size(intr->src[1]) == 64)
             return true;
          auto var = nir_intrinsic_get_var(intr, 0);
-         if (var->type->without_array()->bit_size() == 64)
+         if (glsl_get_bit_size(glsl_without_array(var->type)) == 64)
             return true;
-         return (var->type->without_array()->components() != intr->num_components);
+         return (glsl_get_components(glsl_without_array(var->type)) != intr->num_components);
       }
       case nir_intrinsic_store_global:
          return nir_src_bit_size(intr->src[0]) == 64;
@@ -951,15 +951,15 @@ Lower64BitToVec2::load_deref_64_to_vec2(nir_intrinsic_instr *intr)
 {
    auto deref = nir_instr_as_deref(intr->src[0].ssa->parent_instr);
    auto var = nir_intrinsic_get_var(intr, 0);
-   unsigned components = var->type->without_array()->components();
-   if (var->type->without_array()->bit_size() == 64) {
+   unsigned components = glsl_get_components(glsl_without_array(var->type));
+   if (glsl_get_bit_size(glsl_without_array(var->type)) == 64) {
       components *= 2;
       if (deref->deref_type == nir_deref_type_var) {
          var->type = glsl_vec_type(components);
       } else if (deref->deref_type == nir_deref_type_array) {
 
          var->type =
-            glsl_array_type(glsl_vec_type(components), var->type->array_size(), 0);
+            glsl_array_type(glsl_vec_type(components), glsl_array_size(var->type), 0);
 
       } else {
          nir_print_shader(b->shader, stderr);
@@ -970,7 +970,7 @@ Lower64BitToVec2::load_deref_64_to_vec2(nir_intrinsic_instr *intr)
    if (deref->deref_type == nir_deref_type_array) {
       auto deref_array = nir_instr_as_deref(deref->parent.ssa->parent_instr);
       deref_array->type = var->type;
-      deref->type = deref_array->type->without_array();
+      deref->type = glsl_without_array(deref_array->type);
    }
 
    intr->num_components = components;
@@ -985,15 +985,15 @@ Lower64BitToVec2::store_64_to_vec2(nir_intrinsic_instr *intr)
    auto deref = nir_instr_as_deref(intr->src[0].ssa->parent_instr);
    auto var = nir_intrinsic_get_var(intr, 0);
 
-   unsigned components = var->type->without_array()->components();
+   unsigned components = glsl_get_components(glsl_without_array(var->type));
    unsigned wrmask = nir_intrinsic_write_mask(intr);
-   if (var->type->without_array()->bit_size() == 64) {
+   if (glsl_get_bit_size(glsl_without_array(var->type)) == 64) {
       components *= 2;
       if (deref->deref_type == nir_deref_type_var) {
          var->type = glsl_vec_type(components);
       } else if (deref->deref_type == nir_deref_type_array) {
          var->type =
-            glsl_array_type(glsl_vec_type(components), var->type->array_size(), 0);
+            glsl_array_type(glsl_vec_type(components), glsl_array_size(var->type), 0);
       } else {
          nir_print_shader(b->shader, stderr);
          assert(0 && "Only lowring of var and array derefs supported\n");
@@ -1003,7 +1003,7 @@ Lower64BitToVec2::store_64_to_vec2(nir_intrinsic_instr *intr)
    if (deref->deref_type == nir_deref_type_array) {
       auto deref_array = nir_instr_as_deref(deref->parent.ssa->parent_instr);
       deref_array->type = var->type;
-      deref->type = deref_array->type->without_array();
+      deref->type = glsl_without_array(deref_array->type);
    }
    intr->num_components = components;
    nir_intrinsic_set_write_mask(intr, wrmask == 1 ? 3 : 0xf);
diff --git a/src/gallium/drivers/r600/sfn/sfn_nir_lower_tex.cpp b/src/gallium/drivers/r600/sfn/sfn_nir_lower_tex.cpp
index 802f8009868be..7d15ea2ee76fb 100644
--- a/src/gallium/drivers/r600/sfn/sfn_nir_lower_tex.cpp
+++ b/src/gallium/drivers/r600/sfn/sfn_nir_lower_tex.cpp
@@ -126,7 +126,7 @@ r600_nir_lower_int_tg4(nir_shader *shader)
 
    nir_foreach_uniform_variable(var, shader)
    {
-      if (var->type->is_sampler()) {
+      if (glsl_type_is_sampler(var->type)) {
          if (glsl_base_type_is_integer(var->type->sampled_type)) {
             need_lowering = true;
          }
diff --git a/src/gallium/drivers/r600/sfn/sfn_shader.cpp b/src/gallium/drivers/r600/sfn/sfn_shader.cpp
index 7cd90e38d2d3d..7af0000f45bbd 100644
--- a/src/gallium/drivers/r600/sfn/sfn_shader.cpp
+++ b/src/gallium/drivers/r600/sfn/sfn_shader.cpp
@@ -581,11 +581,11 @@ Shader::scan_shader(const nir_function *func)
 bool
 Shader::scan_uniforms(nir_variable *uniform)
 {
-   if (uniform->type->contains_atomic()) {
-      int natomics = uniform->type->atomic_size() / 4; /* ATOMIC_COUNTER_SIZE */
+   if (glsl_contains_atomic(uniform->type)) {
+      int natomics = glsl_atomic_size(uniform->type) / 4; /* ATOMIC_COUNTER_SIZE */
       m_nhwatomic += natomics;
 
-      if (uniform->type->is_array())
+      if (glsl_type_is_array(uniform->type))
          m_indirect_files |= 1 << TGSI_FILE_HW_ATOMIC;
 
       m_flags.set(sh_uses_atomics);
@@ -610,10 +610,10 @@ Shader::scan_uniforms(nir_variable *uniform)
       m_atomics.push_back(atom);
    }
 
-   auto type = uniform->type->is_array() ? uniform->type->without_array() : uniform->type;
-   if (type->is_image() || uniform->data.mode == nir_var_mem_ssbo) {
+   auto type = glsl_without_array(uniform->type);
+   if (glsl_type_is_image(type) || uniform->data.mode == nir_var_mem_ssbo) {
       m_flags.set(sh_uses_images);
-      if (uniform->type->is_array() && !(uniform->data.mode == nir_var_mem_ssbo))
+      if (glsl_type_is_array(uniform->type) && !(uniform->data.mode == nir_var_mem_ssbo))
          m_indirect_files |= 1 << TGSI_FILE_IMAGE;
    }
 
-- 
GitLab


From ab963e9316caae1ad9b6f5999b1bc3dde3437000 Mon Sep 17 00:00:00 2001
From: Caio Oliveira <caio.oliveira@intel.com>
Date: Thu, 14 Dec 2023 22:15:28 -0800
Subject: [PATCH 3/9] nouveau: Use glsl_type C helpers

---
 src/nouveau/codegen/nv50_ir_from_nir.cpp | 20 ++++++++++----------
 1 file changed, 10 insertions(+), 10 deletions(-)

diff --git a/src/nouveau/codegen/nv50_ir_from_nir.cpp b/src/nouveau/codegen/nv50_ir_from_nir.cpp
index 9bdc45b9ccedc..7543b4446b769 100644
--- a/src/nouveau/codegen/nv50_ir_from_nir.cpp
+++ b/src/nouveau/codegen/nv50_ir_from_nir.cpp
@@ -889,13 +889,13 @@ static uint16_t
 calcSlots(const glsl_type *type, Program::Type stage, const shader_info &info,
           bool input, const nir_variable *var)
 {
-   if (!type->is_array())
-      return type->count_attribute_slots(false);
+   if (!glsl_type_is_array(type))
+      return glsl_count_attribute_slots(type, false);
 
    uint16_t slots;
    switch (stage) {
    case Program::TYPE_GEOMETRY:
-      slots = type->count_attribute_slots(false);
+      slots = glsl_count_attribute_slots(type, false);
       if (input)
          slots /= info.gs.vertices_in;
       break;
@@ -903,12 +903,12 @@ calcSlots(const glsl_type *type, Program::Type stage, const shader_info &info,
    case Program::TYPE_TESSELLATION_EVAL:
       // remove first dimension
       if (var->data.patch || (!input && stage == Program::TYPE_TESSELLATION_EVAL))
-         slots = type->count_attribute_slots(false);
+         slots = glsl_count_attribute_slots(type, false);
       else
-         slots = type->fields.array->count_attribute_slots(false);
+         slots = glsl_count_attribute_slots(type->fields.array, false);
       break;
    default:
-      slots = type->count_attribute_slots(false);
+      slots = glsl_count_attribute_slots(type, false);
       break;
    }
 
@@ -917,10 +917,10 @@ calcSlots(const glsl_type *type, Program::Type stage, const shader_info &info,
 
 static uint8_t
 getMaskForType(const glsl_type *type, uint8_t slot) {
-   uint16_t comp = type->without_array()->components();
+   uint16_t comp = glsl_get_components(glsl_without_array(type));
    comp = comp ? comp : 4;
 
-   if (glsl_base_type_is_64bit(type->without_array()->base_type)) {
+   if (glsl_base_type_is_64bit(glsl_without_array(type)->base_type)) {
       comp *= 2;
       if (comp > 4) {
          if (slot % 2)
@@ -1018,7 +1018,7 @@ bool Converter::assignSlots() {
             assert(glsl_type_is_scalar(type->fields.array));
             assert(slots == glsl_get_length(type));
          }
-         assert(!glsl_base_type_is_64bit(type->without_array()->base_type));
+         assert(!glsl_base_type_is_64bit(glsl_without_array(type)->base_type));
 
          uint32_t comps = BITFIELD_RANGE(var->data.location_frac, slots);
          assert(!(comps & ~0xff));
@@ -1122,7 +1122,7 @@ bool Converter::assignSlots() {
             assert(glsl_type_is_scalar(type->fields.array));
             assert(slots == glsl_get_length(type));
          }
-         assert(!glsl_base_type_is_64bit(type->without_array()->base_type));
+         assert(!glsl_base_type_is_64bit(glsl_without_array(type)->base_type));
 
          uint32_t comps = BITFIELD_RANGE(var->data.location_frac, slots);
          assert(!(comps & ~0xff));
-- 
GitLab


From 671b59254d0855db2ca1b6a007d4dacbaed05ed3 Mon Sep 17 00:00:00 2001
From: Caio Oliveira <caio.oliveira@intel.com>
Date: Thu, 14 Dec 2023 22:35:22 -0800
Subject: [PATCH 4/9] nir: Use glsl_type C helpers

---
 src/compiler/nir/tests/builder_tests.cpp |  8 +++---
 src/compiler/nir/tests/vars_tests.cpp    | 31 ++++++++++--------------
 2 files changed, 17 insertions(+), 22 deletions(-)

diff --git a/src/compiler/nir/tests/builder_tests.cpp b/src/compiler/nir/tests/builder_tests.cpp
index 576f430266f62..91dd9ae28ac02 100644
--- a/src/compiler/nir/tests/builder_tests.cpp
+++ b/src/compiler/nir/tests/builder_tests.cpp
@@ -30,10 +30,10 @@ private:
    const glsl_type *type_for_def(nir_def *def)
    {
       switch (def->bit_size) {
-      case 8:  return glsl_type::u8vec(def->num_components);
-      case 16: return glsl_type::u16vec(def->num_components);
-      case 32: return glsl_type::uvec(def->num_components);
-      case 64: return glsl_type::u64vec(def->num_components);
+      case 8:  return glsl_u8vec_type(def->num_components);
+      case 16: return glsl_u16vec_type(def->num_components);
+      case 32: return glsl_uvec_type(def->num_components);
+      case 64: return glsl_u64vec_type(def->num_components);
       default: unreachable("Invalid bit size");
       }
    }
diff --git a/src/compiler/nir/tests/vars_tests.cpp b/src/compiler/nir/tests/vars_tests.cpp
index 3ff1cc43bd7eb..e7235b20d691b 100644
--- a/src/compiler/nir/tests/vars_tests.cpp
+++ b/src/compiler/nir/tests/vars_tests.cpp
@@ -1302,9 +1302,8 @@ TEST_F(nir_copy_prop_vars_test, restrict_ssbo_bindings)
    field.type = glsl_int_type();
    field.name = "x";
    const glsl_type *ifc_type =
-      glsl_type::get_interface_instance(&field, 1,
-                                        GLSL_INTERFACE_PACKING_STD430,
-                                        false /* row_major */, "b");
+      glsl_interface_type(&field, 1, GLSL_INTERFACE_PACKING_STD430,
+                          false /* row_major */, "b");
    nir_variable *ssbo0 = create_var(nir_var_mem_ssbo, ifc_type, "ssbo0");
    nir_variable *ssbo1 = create_var(nir_var_mem_ssbo, ifc_type, "ssbo1");
    ssbo0->data.access = ssbo1->data.access = ACCESS_RESTRICT;
@@ -1347,9 +1346,8 @@ TEST_F(nir_copy_prop_vars_test, aliasing_ssbo_bindings)
    field.type = glsl_int_type();
    field.name = "x";
    const glsl_type *ifc_type =
-      glsl_type::get_interface_instance(&field, 1,
-                                        GLSL_INTERFACE_PACKING_STD430,
-                                        false /* row_major */, "b");
+      glsl_interface_type(&field, 1, GLSL_INTERFACE_PACKING_STD430,
+                          false /* row_major */, "b");
    nir_variable *ssbo0 = create_var(nir_var_mem_ssbo, ifc_type, "ssbo0");
    nir_variable *ssbo1 = create_var(nir_var_mem_ssbo, ifc_type, "ssbo1");
    nir_variable *out = create_var(nir_var_mem_ssbo, ifc_type, "out");
@@ -1386,10 +1384,9 @@ TEST_F(nir_copy_prop_vars_test, ssbo_array_binding_indirect)
    field.type = glsl_int_type();
    field.name = "x";
    const glsl_type *ifc_type =
-      glsl_type::get_interface_instance(&field, 1,
-                                        GLSL_INTERFACE_PACKING_STD430,
-                                        false /* row_major */, "b");
-   const glsl_type *arr_ifc_type = glsl_type::get_array_instance(ifc_type, 2);
+      glsl_interface_type(&field, 1, GLSL_INTERFACE_PACKING_STD430,
+                          false /* row_major */, "b");
+   const glsl_type *arr_ifc_type = glsl_array_type(ifc_type, 2, 0);
    nir_variable *ssbo_arr = create_var(nir_var_mem_ssbo, arr_ifc_type,
                                        "ssbo_arr");
    ssbo_arr->data.access = ACCESS_RESTRICT;
@@ -1430,10 +1427,9 @@ TEST_F(nir_copy_prop_vars_test, restrict_ssbo_array_binding)
    field.type = glsl_int_type();
    field.name = "x";
    const glsl_type *ifc_type =
-      glsl_type::get_interface_instance(&field, 1,
-                                        GLSL_INTERFACE_PACKING_STD430,
-                                        false /* row_major */, "b");
-   const glsl_type *arr_ifc_type = glsl_type::get_array_instance(ifc_type, 2);
+      glsl_interface_type(&field, 1, GLSL_INTERFACE_PACKING_STD430,
+                          false /* row_major */, "b");
+   const glsl_type *arr_ifc_type = glsl_array_type(ifc_type, 2, 0);
    nir_variable *ssbo_arr = create_var(nir_var_mem_ssbo, arr_ifc_type,
                                        "ssbo_arr");
    ssbo_arr->data.access = ACCESS_RESTRICT;
@@ -1478,10 +1474,9 @@ TEST_F(nir_copy_prop_vars_test, aliasing_ssbo_array_binding)
    field.type = glsl_int_type();
    field.name = "x";
    const glsl_type *ifc_type =
-      glsl_type::get_interface_instance(&field, 1,
-                                        GLSL_INTERFACE_PACKING_STD430,
-                                        false /* row_major */, "b");
-   const glsl_type *arr_ifc_type = glsl_type::get_array_instance(ifc_type, 2);
+      glsl_interface_type(&field, 1, GLSL_INTERFACE_PACKING_STD430,
+                          false /* row_major */, "b");
+   const glsl_type *arr_ifc_type = glsl_array_type(ifc_type, 2, 0);
    nir_variable *ssbo_arr = create_var(nir_var_mem_ssbo, arr_ifc_type,
                                        "ssbo_arr");
    nir_variable *out = create_var(nir_var_mem_ssbo, ifc_type, "out");
-- 
GitLab


From f71a50a60d3026e3a1d2b15b6b4bb5735e41b32d Mon Sep 17 00:00:00 2001
From: Caio Oliveira <caio.oliveira@intel.com>
Date: Thu, 14 Dec 2023 22:16:15 -0800
Subject: [PATCH 5/9] mesa: Use glsl_type C helpers

---
 src/mesa/main/shader_query.cpp            | 12 +++---
 src/mesa/main/uniform_query.cpp           | 50 +++++++++++------------
 src/mesa/state_tracker/st_glsl_to_nir.cpp |  6 +--
 3 files changed, 34 insertions(+), 34 deletions(-)

diff --git a/src/mesa/main/shader_query.cpp b/src/mesa/main/shader_query.cpp
index 88de7139825cf..92442682dd239 100644
--- a/src/mesa/main/shader_query.cpp
+++ b/src/mesa/main/shader_query.cpp
@@ -1122,7 +1122,7 @@ program_resource_location(struct gl_program_resource *res, unsigned array_index)
          return -1;
       }
       return var->location +
-	     (array_index * var->type->without_array()->matrix_columns);
+	     (array_index * glsl_without_array(var->type)->matrix_columns);
    }
    case GL_PROGRAM_OUTPUT:
       if (RESOURCE_VAR(res)->location == -1)
@@ -1144,7 +1144,7 @@ program_resource_location(struct gl_program_resource *res, unsigned array_index)
       *     "A valid name cannot be a structure, an array of structures, or any
       *     portion of a single vector or a matrix."
       */
-      if (RESOURCE_UNI(res)->type->without_array()->is_struct())
+      if (glsl_type_is_struct(glsl_without_array(RESOURCE_UNI(res)->type)))
          return -1;
 
       /* From the GL_ARB_uniform_buffer_object spec:
@@ -2013,10 +2013,10 @@ validate_io(struct gl_program *producer, struct gl_program *consumer)
       if (consumer_is_array_stage) {
          if (consumer_interface_type) {
             /* the interface is the array; the underlying types should match */
-            if (consumer_interface_type->is_array() && !consumer_var->patch)
+            if (glsl_type_is_array(consumer_interface_type) && !consumer_var->patch)
                consumer_interface_type = consumer_interface_type->fields.array;
          } else {
-            if (consumer_type->is_array() && !consumer_var->patch)
+            if (glsl_type_is_array(consumer_type) && !consumer_var->patch)
                consumer_type = consumer_type->fields.array;
          }
       }
@@ -2024,10 +2024,10 @@ validate_io(struct gl_program *producer, struct gl_program *consumer)
       if (producer_is_array_stage) {
          if (producer_interface_type) {
             /* the interface is the array; the underlying types should match */
-            if (producer_interface_type->is_array() && !producer_var->patch)
+            if (glsl_type_is_array(producer_interface_type) && !producer_var->patch)
                producer_interface_type = producer_interface_type->fields.array;
          } else {
-            if (producer_type->is_array() && !producer_var->patch)
+            if (glsl_type_is_array(producer_type) && !producer_var->patch)
                producer_type = producer_type->fields.array;
          }
       }
diff --git a/src/mesa/main/uniform_query.cpp b/src/mesa/main/uniform_query.cpp
index d1863697e7267..193833bdf2ab6 100644
--- a/src/mesa/main/uniform_query.cpp
+++ b/src/mesa/main/uniform_query.cpp
@@ -345,13 +345,13 @@ _mesa_get_uniform(struct gl_context *ctx, GLuint program, GLint location,
    }
 
    {
-      unsigned elements = uni->type->components();
+      unsigned elements = glsl_get_components(uni->type);
       unsigned components = uni->type->vector_elements;
 
       const int rmul = glsl_base_type_is_64bit(returnType) ? 2 : 1;
-      int dmul = (uni->type->is_64bit()) ? 2 : 1;
+      int dmul = (glsl_type_is_64bit(uni->type)) ? 2 : 1;
 
-      if ((uni->type->is_sampler() || uni->type->is_image()) &&
+      if ((glsl_type_is_sampler(uni->type) || glsl_type_is_image(uni->type)) &&
           !uni->is_bindless) {
          /* Non-bindless samplers/images are represented using unsigned integer
           * 32-bit, while bindless handles are 64-bit.
@@ -364,7 +364,7 @@ _mesa_get_uniform(struct gl_context *ctx, GLuint program, GLint location,
        */
       const union gl_constant_value *src;
       if (ctx->Const.PackedDriverUniformStorage &&
-          (uni->is_bindless || !uni->type->contains_opaque())) {
+          (uni->is_bindless || !glsl_contains_opaque(uni->type))) {
          unsigned dword_elements = elements;
 
          /* 16-bit uniforms are packed. */
@@ -398,7 +398,7 @@ _mesa_get_uniform(struct gl_context *ctx, GLuint program, GLint location,
        */
       if (returnType == uni->type->base_type ||
           ((returnType == GLSL_TYPE_INT || returnType == GLSL_TYPE_UINT) &&
-           (uni->type->is_sampler() || uni->type->is_image())) ||
+           (glsl_type_is_sampler(uni->type) || glsl_type_is_image(uni->type))) ||
           (returnType == GLSL_TYPE_UINT64 && uni->is_bindless)) {
          memcpy(paramsOut, src, bytes);
       } else {
@@ -836,7 +836,7 @@ _mesa_propagate_uniforms_to_driver_storage(struct gl_uniform_storage *uni,
 
    const unsigned components = uni->type->vector_elements;
    const unsigned vectors = uni->type->matrix_columns;
-   const int dmul = uni->type->is_64bit() ? 2 : 1;
+   const int dmul = glsl_type_is_64bit(uni->type) ? 2 : 1;
 
    /* Store the data in the driver's requested type in the driver's storage
     * areas.
@@ -1033,11 +1033,11 @@ associate_uniform_storage(struct gl_context *ctx,
             for (unsigned j = 0; j < array_elements; ++j) {
                unsigned unit = storage->opaque[shader_type].index + j;
 
-               if (storage->type->without_array()->is_sampler()) {
+               if (glsl_type_is_sampler(glsl_without_array(storage->type))) {
                   assert(unit >= 0 && unit < prog->sh.NumBindlessSamplers);
                   prog->sh.BindlessSamplers[unit].data =
                      &params->ParameterValues[pvo] + 4 * j;
-               } else if (storage->type->without_array()->is_image()) {
+               } else if (glsl_type_is_image(glsl_without_array(storage->type))) {
                   assert(unit >= 0 && unit < prog->sh.NumBindlessImages);
                   prog->sh.BindlessImages[unit].data =
                      &params->ParameterValues[pvo] + 4 * j;
@@ -1051,8 +1051,8 @@ associate_uniform_storage(struct gl_context *ctx,
           */
          unsigned array_elements = MAX2(1, storage->array_elements);
          if (ctx->Const.PackedDriverUniformStorage && !prog->info.use_legacy_math_rules &&
-             (storage->is_bindless || !storage->type->contains_opaque())) {
-            const int dmul = storage->type->is_64bit() ? 2 : 1;
+             (storage->is_bindless || !glsl_contains_opaque(storage->type))) {
+            const int dmul = glsl_type_is_64bit(storage->type) ? 2 : 1;
             const unsigned components =
                storage->type->vector_elements *
                storage->type->matrix_columns;
@@ -1149,7 +1149,7 @@ validate_uniform(GLint location, GLsizei count, const GLvoid *values,
    if (uni == NULL)
       return NULL;
 
-   if (uni->type->is_matrix()) {
+   if (glsl_type_is_matrix(uni->type)) {
       /* Can't set matrix uniforms (like mat4) with glUniform */
       _mesa_error(ctx, GL_INVALID_OPERATION,
                   "glUniform%u(uniform \"%s\"@%d is matrix)",
@@ -1219,7 +1219,7 @@ validate_uniform(GLint location, GLsizei count, const GLvoid *values,
     * Based on that, when an invalid sampler is specified, we generate a
     * GL_INVALID_VALUE error and ignore the command.
     */
-   if (uni->type->is_sampler()) {
+   if (glsl_type_is_sampler(uni->type)) {
       for (int i = 0; i < count; i++) {
          const unsigned texUnit = ((unsigned *) values)[i];
 
@@ -1237,7 +1237,7 @@ validate_uniform(GLint location, GLsizei count, const GLvoid *values,
       ctx->_Shader->Validated = ctx->_Shader->UserValidated = GL_FALSE;
    }
 
-   if (uni->type->is_image()) {
+   if (glsl_type_is_image(uni->type)) {
       for (int i = 0; i < count; i++) {
          const int unit = ((GLint *) values)[i];
 
@@ -1259,9 +1259,9 @@ _mesa_flush_vertices_for_uniforms(struct gl_context *ctx,
                                   const struct gl_uniform_storage *uni)
 {
    /* Opaque uniforms have no storage unless they are bindless */
-   if (!uni->is_bindless && uni->type->contains_opaque()) {
+   if (!uni->is_bindless && glsl_contains_opaque(uni->type)) {
       /* Samplers flush on demand and ignore redundant updates. */
-      if (!uni->type->is_sampler())
+      if (!glsl_type_is_sampler(uni->type))
          FLUSH_VERTICES(ctx, 0, 0);
       return;
    }
@@ -1290,10 +1290,10 @@ copy_uniforms_to_storage(gl_constant_value *storage,
 {
    const gl_constant_value *src = (const gl_constant_value*)values;
    bool copy_as_uint64 = uni->is_bindless &&
-                         (uni->type->is_sampler() || uni->type->is_image());
+                         (glsl_type_is_sampler(uni->type) || glsl_type_is_image(uni->type));
    bool copy_to_float16 = uni->type->base_type == GLSL_TYPE_FLOAT16;
 
-   if (!uni->type->is_boolean() && !copy_as_uint64 && !copy_to_float16) {
+   if (!glsl_type_is_boolean(uni->type) && !copy_as_uint64 && !copy_to_float16) {
       unsigned size = sizeof(storage[0]) * components * count * size_mul;
 
       if (!memcmp(storage, values, size))
@@ -1489,7 +1489,7 @@ _mesa_uniform(GLint location, GLsizei count, const GLvoid *values,
    bool ctx_flushed = false;
    gl_constant_value *storage;
    if (ctx->Const.PackedDriverUniformStorage &&
-       (uni->is_bindless || !uni->type->contains_opaque())) {
+       (uni->is_bindless || !glsl_contains_opaque(uni->type))) {
       for (unsigned s = 0; s < uni->num_driver_storage; s++) {
          unsigned dword_components = components;
 
@@ -1515,13 +1515,13 @@ _mesa_uniform(GLint location, GLsizei count, const GLvoid *values,
    /* Return early if possible. Bindless samplers need to be processed
     * because of the !sampler->bound codepath below.
     */
-   if (!ctx_flushed && !(uni->type->is_sampler() && uni->is_bindless))
+   if (!ctx_flushed && !(glsl_type_is_sampler(uni->type) && uni->is_bindless))
       return; /* no change in uniform values */
 
    /* If the uniform is a sampler, do the extra magic necessary to propagate
     * the changes through.
     */
-   if (uni->type->is_sampler()) {
+   if (glsl_type_is_sampler(uni->type)) {
       /* Note that samplers are the only uniforms that don't call
        * FLUSH_VERTICES above.
        */
@@ -1587,7 +1587,7 @@ _mesa_uniform(GLint location, GLsizei count, const GLvoid *values,
    /* If the uniform is an image, update the mapping from image
     * uniforms to image units present in the shader data structure.
     */
-   if (uni->type->is_image()) {
+   if (glsl_type_is_image(uni->type)) {
       for (int i = 0; i < MESA_SHADER_STAGES; i++) {
          struct gl_linked_shader *sh = shProg->_LinkedShaders[i];
 
@@ -1861,7 +1861,7 @@ _mesa_uniform_matrix(GLint location, GLsizei count,
       }
    }
 
-   if (!uni->type->is_matrix()) {
+   if (!glsl_type_is_matrix(uni->type)) {
       _mesa_error(ctx, GL_INVALID_OPERATION,
 		  "glUniformMatrix(non-matrix uniform)");
       return;
@@ -1870,7 +1870,7 @@ _mesa_uniform_matrix(GLint location, GLsizei count,
    assert(basicType == GLSL_TYPE_FLOAT || basicType == GLSL_TYPE_DOUBLE);
    const unsigned size_mul = basicType == GLSL_TYPE_DOUBLE ? 2 : 1;
 
-   assert(!uni->type->is_sampler());
+   assert(!glsl_type_is_sampler(uni->type));
    const unsigned vectors = uni->type->matrix_columns;
    const unsigned components = uni->type->vector_elements;
 
@@ -2109,7 +2109,7 @@ _mesa_uniform_handle(GLint location, GLsizei count, const GLvoid *values,
       _mesa_propagate_uniforms_to_driver_storage(uni, offset, count);
    }
 
-   if (uni->type->is_sampler()) {
+   if (glsl_type_is_sampler(uni->type)) {
       /* Mark this bindless sampler as not bound to a texture unit because
        * it refers to a texture handle.
        */
@@ -2132,7 +2132,7 @@ _mesa_uniform_handle(GLint location, GLsizei count, const GLvoid *values,
       }
    }
 
-   if (uni->type->is_image()) {
+   if (glsl_type_is_image(uni->type)) {
       /* Mark this bindless image as not bound to an image unit because it
        * refers to a texture handle.
        */
diff --git a/src/mesa/state_tracker/st_glsl_to_nir.cpp b/src/mesa/state_tracker/st_glsl_to_nir.cpp
index bba2e0a7f9ee9..736a999cbb46b 100644
--- a/src/mesa/state_tracker/st_glsl_to_nir.cpp
+++ b/src/mesa/state_tracker/st_glsl_to_nir.cpp
@@ -58,7 +58,7 @@
 static int
 type_size(const struct glsl_type *type)
 {
-   return type->count_attribute_slots(false);
+   return glsl_count_attribute_slots(type, false);
 }
 
 /* Depending on PIPE_CAP_TGSI_TEXCOORD (st->needs_texcoord_semantic) we
@@ -189,8 +189,8 @@ st_nir_assign_uniform_locations(struct gl_context *ctx,
       int loc;
 
       const struct glsl_type *type = glsl_without_array(uniform->type);
-      if (!uniform->data.bindless && (type->is_sampler() || type->is_image())) {
-         if (type->is_sampler()) {
+      if (!uniform->data.bindless && (glsl_type_is_sampler(type) || glsl_type_is_image(type))) {
+         if (glsl_type_is_sampler(type)) {
             loc = shaderidx;
             shaderidx += type_size(uniform->type);
          } else {
-- 
GitLab


From de98382e92cc5a3371487291809fde3bfda78494 Mon Sep 17 00:00:00 2001
From: Caio Oliveira <caio.oliveira@intel.com>
Date: Thu, 14 Dec 2023 22:20:27 -0800
Subject: [PATCH 6/9] compiler/types: Add a few more glsl_type C helpers

These will be used once the C++ ones are removed.
---
 src/compiler/glsl_types.c |  8 ++++
 src/compiler/glsl_types.h | 96 ++++++++++++++++++++++++++++++++++++++-
 2 files changed, 103 insertions(+), 1 deletion(-)

diff --git a/src/compiler/glsl_types.c b/src/compiler/glsl_types.c
index 90226e24e3511..633f6e7613b18 100644
--- a/src/compiler/glsl_types.c
+++ b/src/compiler/glsl_types.c
@@ -1722,6 +1722,14 @@ glsl_get_field_index(const struct glsl_type *t, const char *name)
    return -1;
 }
 
+const struct glsl_type *
+glsl_get_field_type(const struct glsl_type *t, const char *name)
+{
+   const int idx = glsl_get_field_index(t, name);
+   if (idx == -1)
+      return &glsl_type_builtin_error;
+   return glsl_get_struct_field(t, (unsigned)idx);
+}
 
 unsigned
 glsl_get_component_slots(const struct glsl_type *t)
diff --git a/src/compiler/glsl_types.h b/src/compiler/glsl_types.h
index 597a4b0e5531d..f59d268d583da 100644
--- a/src/compiler/glsl_types.h
+++ b/src/compiler/glsl_types.h
@@ -89,7 +89,7 @@ enum glsl_base_type {
    GLSL_TYPE_ERROR
 };
 
-/* Return the bit size of a type. Note that this differs from 
+/* Return the bit size of a type. Note that this differs from
  * glsl_get_bit_size in that it returns 32 bits for bools, whereas at
  * the NIR level we would want to return 1 bit for bools.
  */
@@ -704,6 +704,7 @@ static inline bool glsl_type_is_void(const struct glsl_type *t) { return t->base
 static inline bool glsl_type_is_subroutine(const struct glsl_type *t) { return t->base_type == GLSL_TYPE_SUBROUTINE; }
 static inline bool glsl_type_is_error(const struct glsl_type *t) { return t->base_type == GLSL_TYPE_ERROR; }
 static inline bool glsl_type_is_double(const struct glsl_type *t) { return t->base_type == GLSL_TYPE_DOUBLE; }
+static inline bool glsl_type_is_float(const struct glsl_type *t) { return t->base_type == GLSL_TYPE_FLOAT; }
 
 static inline bool
 glsl_type_is_numeric(const struct glsl_type *t)
@@ -750,6 +751,90 @@ glsl_type_is_64bit(const struct glsl_type *t)
    return glsl_base_type_is_64bit(t->base_type);
 }
 
+static inline bool
+glsl_type_is_integer_16(const struct glsl_type *t)
+{
+   return t->base_type == GLSL_TYPE_UINT16 || t->base_type == GLSL_TYPE_INT16;
+}
+
+static inline bool
+glsl_type_is_integer_32(const struct glsl_type *t)
+{
+   return t->base_type == GLSL_TYPE_UINT || t->base_type == GLSL_TYPE_INT;
+}
+
+static inline bool
+glsl_type_is_integer_64(const struct glsl_type *t)
+{
+   return t->base_type == GLSL_TYPE_UINT64 || t->base_type == GLSL_TYPE_INT64;
+}
+
+static inline bool
+glsl_type_is_integer_32_64(const struct glsl_type *t)
+{
+   return glsl_type_is_integer_32(t) || glsl_type_is_integer_64(t);
+}
+
+static inline bool
+glsl_type_is_integer_16_32(const struct glsl_type *t)
+{
+   return glsl_type_is_integer_16(t) || glsl_type_is_integer_32(t);
+}
+
+static inline bool
+glsl_type_is_integer_16_32_64(const struct glsl_type *t)
+{
+   return glsl_type_is_integer_16(t) || glsl_type_is_integer_32(t) || glsl_type_is_integer_64(t);
+}
+
+static inline bool
+glsl_type_is_float_16_32(const struct glsl_type *t)
+{
+   return t->base_type == GLSL_TYPE_FLOAT16 || glsl_type_is_float(t);
+}
+
+static inline bool
+glsl_type_is_float_16_32_64(const struct glsl_type *t)
+{
+   return t->base_type == GLSL_TYPE_FLOAT16 || glsl_type_is_float(t) || glsl_type_is_double(t);
+}
+
+static inline bool
+glsl_type_is_float_32_64(const struct glsl_type *t)
+{
+   return glsl_type_is_float(t) || glsl_type_is_double(t);
+}
+
+static inline bool
+glsl_type_is_int_16_32_64(const struct glsl_type *t)
+{
+   return t->base_type == GLSL_TYPE_INT16 ||
+          t->base_type == GLSL_TYPE_INT ||
+          t->base_type == GLSL_TYPE_INT64;
+}
+
+static inline bool
+glsl_type_is_uint_16_32_64(const struct glsl_type *t)
+{
+   return t->base_type == GLSL_TYPE_UINT16 ||
+          t->base_type == GLSL_TYPE_UINT ||
+          t->base_type == GLSL_TYPE_UINT64;
+}
+
+static inline bool
+glsl_type_is_int_16_32(const struct glsl_type *t)
+{
+   return t->base_type == GLSL_TYPE_INT ||
+          t->base_type == GLSL_TYPE_INT16;
+}
+
+static inline bool
+glsl_type_is_uint_16_32(const struct glsl_type *t)
+{
+   return t->base_type == GLSL_TYPE_UINT ||
+          t->base_type == GLSL_TYPE_UINT16;
+}
+
 static inline bool
 glsl_type_is_unsized_array(const struct glsl_type *t)
 {
@@ -990,6 +1075,15 @@ unsigned glsl_get_struct_location_offset(const struct glsl_type *t, unsigned len
  */
 int glsl_get_field_index(const struct glsl_type *t, const char *name);
 
+/**
+ * Get the type of a structure field
+ *
+ * \return
+ * Pointer to the type of the named field.  If the type is not a structure
+ * or the named field does not exist, \c &glsl_type_builtin_error is returned.
+ */
+const struct glsl_type *glsl_get_field_type(const struct glsl_type *t, const char *name);
+
 static inline int
 glsl_get_struct_field_offset(const struct glsl_type *t, unsigned index)
 {
-- 
GitLab


From c3620e9e7c07762948bc9063ef96cc75395082d5 Mon Sep 17 00:00:00 2001
From: Caio Oliveira <caio.oliveira@intel.com>
Date: Thu, 14 Dec 2023 22:21:26 -0800
Subject: [PATCH 7/9] glsl: Use glsl_type C helpers

---
 src/compiler/glsl/ast_array_index.cpp         |  54 +-
 src/compiler/glsl/ast_function.cpp            | 155 +++---
 src/compiler/glsl/ast_to_hir.cpp              | 484 +++++++++---------
 src/compiler/glsl/ast_type.cpp                |   4 +-
 src/compiler/glsl/builtin_functions.cpp       | 124 ++---
 src/compiler/glsl/builtin_types.cpp           |   2 +-
 src/compiler/glsl/builtin_variables.cpp       |  14 +-
 src/compiler/glsl/glsl_parser.yy              |   2 +-
 src/compiler/glsl/glsl_parser_extras.cpp      |  22 +-
 src/compiler/glsl/glsl_symbol_table.cpp       |   4 +-
 src/compiler/glsl/glsl_to_nir.cpp             |  62 +--
 src/compiler/glsl/hir_field_selection.cpp     |  10 +-
 src/compiler/glsl/ir.cpp                      | 212 ++++----
 src/compiler/glsl/ir.h                        |  10 +-
 src/compiler/glsl/ir_array_refcount.cpp       |  12 +-
 .../glsl/ir_builder_print_visitor.cpp         |   2 +-
 src/compiler/glsl/ir_constant_expression.cpp  | 110 ++--
 src/compiler/glsl/ir_equals.cpp               |   4 +-
 src/compiler/glsl/ir_expression_operation.py  |  18 +-
 src/compiler/glsl/ir_function.cpp             |   6 +-
 src/compiler/glsl/ir_print_visitor.cpp        |  10 +-
 src/compiler/glsl/ir_reader.cpp               |  14 +-
 src/compiler/glsl/ir_validate.cpp             | 318 ++++++------
 src/compiler/glsl/link_functions.cpp          |   6 +-
 src/compiler/glsl/link_interface_blocks.cpp   |  14 +-
 src/compiler/glsl/linker.cpp                  |  57 +--
 src/compiler/glsl/lower_instructions.cpp      |  52 +-
 src/compiler/glsl/lower_jumps.cpp             |  10 +-
 src/compiler/glsl/lower_mat_op_to_vec.cpp     |  22 +-
 src/compiler/glsl/lower_precision.cpp         |  85 +--
 src/compiler/glsl/lower_subroutine.cpp        |   2 +-
 src/compiler/glsl/lower_vector_derefs.cpp     |   4 +-
 src/compiler/glsl/opt_algebraic.cpp           |  30 +-
 src/compiler/glsl/opt_dead_code.cpp           |   2 +-
 src/compiler/glsl/opt_dead_code_local.cpp     |   6 +-
 src/compiler/glsl/opt_flip_matrices.cpp       |   4 +-
 src/compiler/glsl/opt_function_inlining.cpp   |   4 +-
 src/compiler/glsl/opt_minmax.cpp              |  10 +-
 src/compiler/glsl/opt_rebalance_tree.cpp      |  14 +-
 src/compiler/glsl/opt_tree_grafting.cpp       |   2 +-
 src/compiler/glsl/serialize.cpp               |   4 +-
 .../glsl/tests/array_refcount_test.cpp        |  22 +-
 .../glsl/tests/builtin_variable_test.cpp      |   2 +-
 src/compiler/glsl/tests/general_ir_test.cpp   |  29 +-
 .../glsl/tests/sampler_types_test.cpp         |   2 +-
 45 files changed, 1009 insertions(+), 1027 deletions(-)

diff --git a/src/compiler/glsl/ast_array_index.cpp b/src/compiler/glsl/ast_array_index.cpp
index 00d69d4012314..5d758672b0014 100644
--- a/src/compiler/glsl/ast_array_index.cpp
+++ b/src/compiler/glsl/ast_array_index.cpp
@@ -145,19 +145,19 @@ _mesa_ast_array_index_to_hir(void *mem_ctx,
                              ir_rvalue *array, ir_rvalue *idx,
                              YYLTYPE &loc, YYLTYPE &idx_loc)
 {
-   if (!array->type->is_error()
-       && !array->type->is_array()
-       && !array->type->is_matrix()
-       && !array->type->is_vector()) {
+   if (!glsl_type_is_error(array->type)
+       && !glsl_type_is_array(array->type)
+       && !glsl_type_is_matrix(array->type)
+       && !glsl_type_is_vector(array->type)) {
       _mesa_glsl_error(& idx_loc, state,
                        "cannot dereference non-array / non-matrix / "
                        "non-vector");
    }
 
-   if (!idx->type->is_error()) {
-      if (!idx->type->is_integer_32()) {
+   if (!glsl_type_is_error(idx->type)) {
+      if (!glsl_type_is_integer_32(idx->type)) {
          _mesa_glsl_error(& idx_loc, state, "array index must be integer type");
-      } else if (!idx->type->is_scalar()) {
+      } else if (!glsl_type_is_scalar(idx->type)) {
          _mesa_glsl_error(& idx_loc, state, "array index must be scalar");
       }
    }
@@ -168,7 +168,7 @@ _mesa_ast_array_index_to_hir(void *mem_ctx,
     * declared size.
     */
    ir_constant *const const_index = idx->constant_expression_value(mem_ctx);
-   if (const_index != NULL && idx->type->is_integer_32()) {
+   if (const_index != NULL && glsl_type_is_integer_32(idx->type)) {
       const int idx = const_index->value.i[0];
       const char *type_name = "error";
       unsigned bound = 0;
@@ -181,12 +181,12 @@ _mesa_ast_array_index_to_hir(void *mem_ctx,
        *    declared size. It is also illegal to index an array with a
        *    negative constant expression."
        */
-      if (array->type->is_matrix()) {
-         if (array->type->row_type()->vector_elements <= idx) {
+      if (glsl_type_is_matrix(array->type)) {
+         if (glsl_get_row_type(array->type)->vector_elements <= idx) {
             type_name = "matrix";
-            bound = array->type->row_type()->vector_elements;
+            bound = glsl_get_row_type(array->type)->vector_elements;
          }
-      } else if (array->type->is_vector()) {
+      } else if (glsl_type_is_vector(array->type)) {
          if (array->type->vector_elements <= idx) {
             type_name = "vector";
             bound = array->type->vector_elements;
@@ -196,10 +196,10 @@ _mesa_ast_array_index_to_hir(void *mem_ctx,
           * that we don't need to verify that the type is an array before
           * doing the bounds checking.
           */
-         if ((array->type->array_size() > 0)
-             && (array->type->array_size() <= idx)) {
+         if ((glsl_array_size(array->type) > 0)
+             && (glsl_array_size(array->type) <= idx)) {
             type_name = "array";
-            bound = array->type->array_size();
+            bound = glsl_array_size(array->type);
          }
       }
 
@@ -210,10 +210,10 @@ _mesa_ast_array_index_to_hir(void *mem_ctx,
          _mesa_glsl_error(& loc, state, "%s index must be >= 0", type_name);
       }
 
-      if (array->type->is_array())
+      if (glsl_type_is_array(array->type))
          update_max_array_access(array, idx, &loc, state);
-   } else if (const_index == NULL && array->type->is_array()) {
-      if (array->type->is_unsized_array()) {
+   } else if (const_index == NULL && glsl_type_is_array(array->type)) {
+      if (glsl_type_is_unsized_array(array->type)) {
          int implicit_size = get_implicit_array_size(state, array);
          if (implicit_size) {
             ir_variable *v = array->whole_variable_referenced();
@@ -239,7 +239,7 @@ _mesa_ast_array_index_to_hir(void *mem_ctx,
              */
             ir_variable *var = array->variable_referenced();
             const glsl_type *iface_type = var->get_interface_type();
-            int field_index = iface_type->field_index(var->name);
+            int field_index = glsl_get_field_index(iface_type, var->name);
             /* Field index can be < 0 for instance arrays */
             if (field_index >= 0 &&
                 field_index != (int) iface_type->length - 1) {
@@ -248,7 +248,7 @@ _mesa_ast_array_index_to_hir(void *mem_ctx,
                                 "SSBO.");
             }
          }
-      } else if (array->type->without_array()->is_interface()
+      } else if (glsl_type_is_interface(glsl_without_array(array->type))
                  && ((array->variable_referenced()->data.mode == ir_var_uniform
                       && !state->is_version(400, 320)
                       && !state->ARB_gpu_shader5_enable
@@ -277,7 +277,7 @@ _mesa_ast_array_index_to_hir(void *mem_ctx,
           */
          ir_variable *v = array->whole_variable_referenced();
          if (v != NULL)
-            v->data.max_array_access = array->type->array_size() - 1;
+            v->data.max_array_access = glsl_array_size(array->type) - 1;
       }
 
       /* From page 23 (29 of the PDF) of the GLSL 1.30 spec:
@@ -305,7 +305,7 @@ _mesa_ast_array_index_to_hir(void *mem_ctx,
        *    "Samplers aggregated into arrays within a shader (using square
        *    brackets []) can be indexed with arbitrary integer expressions."
        */
-      if (array->type->without_array()->is_sampler()) {
+      if (glsl_type_is_sampler(glsl_without_array(array->type))) {
          if (!state->is_version(400, 320) &&
              !state->ARB_gpu_shader5_enable &&
              !state->EXT_gpu_shader5_enable &&
@@ -339,7 +339,7 @@ _mesa_ast_array_index_to_hir(void *mem_ctx,
        * non-constant indexing of image arrays, but behavior is left undefined
        * in cases where the indexing expression is not dynamically uniform.
        */
-      if (state->es_shader && array->type->without_array()->is_image()) {
+      if (state->es_shader && glsl_type_is_image(glsl_without_array(array->type))) {
          _mesa_glsl_error(&loc, state,
                           "image arrays indexed with non-constant "
                           "expressions are forbidden in GLSL ES.");
@@ -349,11 +349,11 @@ _mesa_ast_array_index_to_hir(void *mem_ctx,
    /* After performing all of the error checking, generate the IR for the
     * expression.
     */
-   if (array->type->is_array()
-       || array->type->is_matrix()
-       || array->type->is_vector()) {
+   if (glsl_type_is_array(array->type)
+       || glsl_type_is_matrix(array->type)
+       || glsl_type_is_vector(array->type)) {
       return new(mem_ctx) ir_dereference_array(array, idx);
-   } else if (array->type->is_error()) {
+   } else if (glsl_type_is_error(array->type)) {
       return array;
    } else {
       ir_rvalue *result = new(mem_ctx) ir_dereference_array(array, idx);
diff --git a/src/compiler/glsl/ast_function.cpp b/src/compiler/glsl/ast_function.cpp
index 840188f0bf0dc..4354485852e58 100644
--- a/src/compiler/glsl/ast_function.cpp
+++ b/src/compiler/glsl/ast_function.cpp
@@ -353,7 +353,7 @@ verify_parameter_modes(_mesa_glsl_parse_state *state,
          }
       }
 
-      if (formal->type->is_image() &&
+      if (glsl_type_is_image(formal->type) &&
           actual->variable_referenced()) {
          if (!verify_image_parameter(&loc, state, formal,
                                      actual->variable_referenced()))
@@ -563,7 +563,7 @@ generate_call(exec_list *instructions, ir_function_signature *sig,
       ir_rvalue *actual = (ir_rvalue *) actual_node;
       ir_variable *formal = (ir_variable *) formal_node;
 
-      if (formal->type->is_numeric() || formal->type->is_boolean()) {
+      if (glsl_type_is_numeric(formal->type) || glsl_type_is_boolean(formal->type)) {
          switch (formal->data.mode) {
          case ir_var_const_in:
          case ir_var_function_in: {
@@ -643,7 +643,7 @@ generate_call(exec_list *instructions, ir_function_signature *sig,
    }
 
    ir_dereference_variable *deref = NULL;
-   if (!sig->return_type->is_void()) {
+   if (!glsl_type_is_void(sig->return_type)) {
       /* Create a new temporary to hold the return value. */
       char *const name = ir_variable::temporaries_allocate_names
          ? ralloc_asprintf(ctx, "%s_retval", sig->function_name())
@@ -742,7 +742,7 @@ match_subroutine_by_name(const char *name,
 
    for (int i = 0; i < state->num_subroutine_types; i++) {
       f = state->subroutine_types[i];
-      if (strcmp(f->name, glsl_get_type_name(var->type->without_array())))
+      if (strcmp(f->name, glsl_get_type_name(glsl_without_array(var->type))))
          continue;
       found = f;
       break;
@@ -874,7 +874,7 @@ convert_component(ir_rvalue *src, const glsl_type *desired_type)
    const unsigned b = src->type->base_type;
    ir_expression *result = NULL;
 
-   if (src->type->is_error())
+   if (glsl_type_is_error(src->type))
       return src;
 
    assert(a <= GLSL_TYPE_IMAGE);
@@ -1109,9 +1109,9 @@ implicitly_convert_component(ir_rvalue * &from, const glsl_base_type to,
 
    if (to != from->type->base_type) {
       const glsl_type *desired_type =
-         glsl_type::get_instance(to,
-                                 from->type->vector_elements,
-                                 from->type->matrix_columns);
+         glsl_simple_type(to,
+                          from->type->vector_elements,
+                          from->type->matrix_columns);
 
       if (_mesa_glsl_can_implicitly_convert(from->type, desired_type, state)) {
          /* Even though convert_component() implements the constructor
@@ -1144,7 +1144,7 @@ static ir_rvalue *
 dereference_component(ir_rvalue *src, unsigned component)
 {
    void *ctx = ralloc_parent(src);
-   assert(component < src->type->components());
+   assert(component < glsl_get_components(src->type));
 
    /* If the source is a constant, just create a new constant instead of a
     * dereference of the existing constant.
@@ -1153,23 +1153,23 @@ dereference_component(ir_rvalue *src, unsigned component)
    if (constant)
       return new(ctx) ir_constant(constant, component);
 
-   if (src->type->is_scalar()) {
+   if (glsl_type_is_scalar(src->type)) {
       return src;
-   } else if (src->type->is_vector()) {
+   } else if (glsl_type_is_vector(src->type)) {
       return new(ctx) ir_swizzle(src, component, 0, 0, 0, 1);
    } else {
-      assert(src->type->is_matrix());
+      assert(glsl_type_is_matrix(src->type));
 
       /* Dereference a row of the matrix, then call this function again to get
        * a specific element from that row.
        */
-      const int c = component / src->type->column_type()->vector_elements;
-      const int r = component % src->type->column_type()->vector_elements;
+      const int c = component / glsl_get_column_type(src->type)->vector_elements;
+      const int r = component % glsl_get_column_type(src->type)->vector_elements;
       ir_constant *const col_index = new(ctx) ir_constant(c);
       ir_dereference *const col = new(ctx) ir_dereference_array(src,
                                                                 col_index);
 
-      col->type = src->type->column_type();
+      col->type = glsl_get_column_type(src->type);
 
       return dereference_component(col, r);
    }
@@ -1206,12 +1206,12 @@ process_vec_mat_constructor(exec_list *instructions,
       process_parameters(instructions, &actual_parameters, parameters, state);
 
    if (parameter_count == 0
-       || (constructor_type->is_vector() &&
+       || (glsl_type_is_vector(constructor_type) &&
            constructor_type->vector_elements != parameter_count)
-       || (constructor_type->is_matrix() &&
+       || (glsl_type_is_matrix(constructor_type) &&
            constructor_type->matrix_columns != parameter_count)) {
       _mesa_glsl_error(loc, state, "%s constructor must have %u parameters",
-                       constructor_type->is_vector() ? "vector" : "matrix",
+                       glsl_type_is_vector(constructor_type) ? "vector" : "matrix",
                        constructor_type->vector_elements);
       return ir_rvalue::error_value(ctx);
    }
@@ -1229,18 +1229,18 @@ process_vec_mat_constructor(exec_list *instructions,
       all_parameters_are_constant &=
          implicitly_convert_component(ir, constructor_type->base_type, state);
 
-      if (constructor_type->is_matrix()) {
-         if (ir->type != constructor_type->column_type()) {
+      if (glsl_type_is_matrix(constructor_type)) {
+         if (ir->type != glsl_get_column_type(constructor_type)) {
             _mesa_glsl_error(loc, state, "type error in matrix constructor: "
                              "expected: %s, found %s",
-                             glsl_get_type_name(constructor_type->column_type()),
+                             glsl_get_type_name(glsl_get_column_type(constructor_type)),
                              glsl_get_type_name(ir->type));
             return ir_rvalue::error_value(ctx);
          }
-      } else if (ir->type != constructor_type->get_scalar_type()) {
+      } else if (ir->type != glsl_get_scalar_type(constructor_type)) {
          _mesa_glsl_error(loc, state, "type error in vector constructor: "
                           "expected: %s, found %s",
-                          glsl_get_type_name(constructor_type->get_scalar_type()),
+                          glsl_get_type_name(glsl_get_scalar_type(constructor_type)),
                           glsl_get_type_name(ir->type));
          return ir_rvalue::error_value(ctx);
       }
@@ -1258,13 +1258,13 @@ process_vec_mat_constructor(exec_list *instructions,
    foreach_in_list(ir_rvalue, rhs, &actual_parameters) {
       ir_instruction *assignment = NULL;
 
-      if (var->type->is_matrix()) {
+      if (glsl_type_is_matrix(var->type)) {
          ir_rvalue *lhs =
             new(ctx) ir_dereference_array(var, new(ctx) ir_constant(i));
          assignment = new(ctx) ir_assignment(lhs, rhs);
       } else {
          /* use writemask rather than index for vector */
-         assert(var->type->is_vector());
+         assert(glsl_type_is_vector(var->type));
          assert(i < 4);
          ir_dereference *lhs = new(ctx) ir_dereference_variable(var);
          assignment = new(ctx) ir_assignment(lhs, rhs, 1u << i);
@@ -1309,7 +1309,7 @@ process_array_constructor(exec_list *instructions,
    exec_list actual_parameters;
    const unsigned parameter_count =
       process_parameters(instructions, &actual_parameters, parameters, state);
-   bool is_unsized_array = constructor_type->is_unsized_array();
+   bool is_unsized_array = glsl_type_is_unsized_array(constructor_type);
 
    if ((parameter_count == 0) ||
        (!is_unsized_array && (constructor_type->length != parameter_count))) {
@@ -1325,8 +1325,8 @@ process_array_constructor(exec_list *instructions,
 
    if (is_unsized_array) {
       constructor_type =
-         glsl_type::get_array_instance(constructor_type->fields.array,
-                                       parameter_count);
+         glsl_array_type(constructor_type->fields.array,
+                         parameter_count, 0);
       assert(constructor_type != NULL);
       assert(constructor_type->length == parameter_count);
    }
@@ -1345,7 +1345,7 @@ process_array_constructor(exec_list *instructions,
       all_parameters_are_constant &=
          implicitly_convert_component(ir, element_type->base_type, state);
 
-      if (constructor_type->fields.array->is_unsized_array()) {
+      if (glsl_type_is_unsized_array(constructor_type->fields.array)) {
          /* As the inner parameters of the constructor are created without
           * knowledge of each other we need to check to make sure unsized
           * parameters of unsized constructors all end up with the same size.
@@ -1355,7 +1355,7 @@ process_array_constructor(exec_list *instructions,
           *                       vec4[](vec4(0.0), vec4(1.0), vec4(1.0)),
           *                       vec4[](vec4(0.0), vec4(1.0)));
           */
-         if (element_type->is_unsized_array()) {
+         if (glsl_type_is_unsized_array(element_type)) {
             /* This is the first parameter so just get the type */
             element_type = ir->type;
          } else if (element_type != ir->type) {
@@ -1376,10 +1376,9 @@ process_array_constructor(exec_list *instructions,
       }
    }
 
-   if (constructor_type->fields.array->is_unsized_array()) {
+   if (glsl_type_is_unsized_array(constructor_type->fields.array)) {
       constructor_type =
-         glsl_type::get_array_instance(element_type,
-                                       parameter_count);
+         glsl_array_type(element_type, parameter_count, 0);
       assert(constructor_type != NULL);
       assert(constructor_type->length == parameter_count);
    }
@@ -1415,7 +1414,7 @@ single_scalar_parameter(exec_list *parameters)
    const ir_rvalue *const p = (ir_rvalue *) parameters->get_head_raw();
    assert(((ir_rvalue *)p)->as_rvalue() != NULL);
 
-   return (p->type->is_scalar() && p->next->is_tail_sentinel());
+   return (glsl_type_is_scalar(p->type) && p->next->is_tail_sentinel());
 }
 
 
@@ -1454,7 +1453,7 @@ emit_inline_vector_constructor(const glsl_type *type,
     *    scalars.  The components of the constructor parameters are assigned
     *    to the vector in order until the vector is full.
     */
-   const unsigned lhs_components = type->components();
+   const unsigned lhs_components = glsl_get_components(type);
    if (single_scalar_parameter(parameters)) {
       ir_rvalue *first_param = (ir_rvalue *)parameters->get_head_raw();
       return new(ctx) ir_swizzle(first_param, 0, 0, 0, 0, lhs_components);
@@ -1467,7 +1466,7 @@ emit_inline_vector_constructor(const glsl_type *type,
       memset(&data, 0, sizeof(data));
 
       foreach_in_list(ir_rvalue, param, parameters) {
-         unsigned rhs_components = param->type->components();
+         unsigned rhs_components = glsl_get_components(param->type);
 
          /* Do not try to assign more components to the vector than it has! */
          if ((rhs_components + base_lhs_component) > lhs_components) {
@@ -1520,9 +1519,7 @@ emit_inline_vector_constructor(const glsl_type *type,
       if (constant_mask != 0) {
          ir_dereference *lhs = new(ctx) ir_dereference_variable(var);
          const glsl_type *rhs_type =
-            glsl_type::get_instance(var->type->base_type,
-                                    constant_components,
-                                    1);
+            glsl_simple_type(var->type->base_type, constant_components, 1);
          ir_rvalue *rhs = new(ctx) ir_constant(rhs_type, &data);
 
          ir_instruction *inst =
@@ -1532,7 +1529,7 @@ emit_inline_vector_constructor(const glsl_type *type,
 
       base_component = 0;
       foreach_in_list(ir_rvalue, param, parameters) {
-         unsigned rhs_components = param->type->components();
+         unsigned rhs_components = glsl_get_components(param->type);
 
          /* Do not try to assign more components to the vector than it has! */
          if ((rhs_components + base_component) > lhs_components) {
@@ -1595,8 +1592,8 @@ assign_to_matrix_column(ir_variable *var, unsigned column, unsigned row_base,
    ir_dereference *column_ref = new(mem_ctx) ir_dereference_array(var,
                                                                   col_idx);
 
-   assert(column_ref->type->components() >= (row_base + count));
-   assert(src->type->components() >= (src_base + count));
+   assert(glsl_get_components(column_ref->type) >= (row_base + count));
+   assert(glsl_get_components(src->type) >= (src_base + count));
 
    /* Generate a swizzle that extracts the number of components from the source
     * that are to be assigned to the column of the matrix.
@@ -1657,16 +1654,16 @@ emit_inline_matrix_constructor(const glsl_type *type,
        * components with zero.
        */
       glsl_base_type param_base_type = first_param->type->base_type;
-      assert(first_param->type->is_float() || first_param->type->is_double());
+      assert(glsl_type_is_float(first_param->type) || glsl_type_is_double(first_param->type));
       ir_variable *rhs_var =
-         new(ctx) ir_variable(glsl_type::get_instance(param_base_type, 4, 1),
+         new(ctx) ir_variable(glsl_simple_type(param_base_type, 4, 1),
                               "mat_ctor_vec",
                               ir_var_temporary);
       instructions->push_tail(rhs_var);
 
       ir_constant_data zero;
       for (unsigned i = 0; i < 4; i++)
-         if (first_param->type->is_float())
+         if (glsl_type_is_float(first_param->type))
             zero.f[i] = 0.0;
          else
             zero.d[i] = 0.0;
@@ -1722,7 +1719,7 @@ emit_inline_matrix_constructor(const glsl_type *type,
          inst = new(ctx) ir_assignment(col_ref, rhs);
          instructions->push_tail(inst);
       }
-   } else if (first_param->type->is_matrix()) {
+   } else if (glsl_type_is_matrix(first_param->type)) {
       /* From page 50 (56 of the PDF) of the GLSL 1.50 spec:
        *
        *     "If a matrix is constructed from a matrix, then each component
@@ -1750,11 +1747,11 @@ emit_inline_matrix_constructor(const glsl_type *type,
             (src_matrix->type->vector_elements < var->type->vector_elements)
             ? 0 : src_matrix->type->matrix_columns;
 
-         const glsl_type *const col_type = var->type->column_type();
+         const glsl_type *const col_type = glsl_get_column_type(var->type);
          for (/* empty */; col < var->type->matrix_columns; col++) {
             ir_constant_data ident;
 
-            if (!col_type->is_double()) {
+            if (!glsl_type_is_double(col_type)) {
                ident.f[0] = 0.0f;
                ident.f[1] = 0.0f;
                ident.f[2] = 0.0f;
@@ -1839,7 +1836,7 @@ emit_inline_matrix_constructor(const glsl_type *type,
       unsigned row_idx = 0;
 
       foreach_in_list(ir_rvalue, rhs, parameters) {
-         unsigned rhs_components = rhs->type->components();
+         unsigned rhs_components = glsl_get_components(rhs->type);
          unsigned rhs_base = 0;
 
          if (remaining_slots == 0)
@@ -2034,8 +2031,8 @@ ast_function_expression::handle_method(exec_list *instructions,
          goto fail;
       }
 
-      if (op->type->is_array()) {
-         if (op->type->is_unsized_array()) {
+      if (glsl_type_is_array(op->type)) {
+         if (glsl_type_is_unsized_array(op->type)) {
             if (!state->has_shader_storage_buffer_objects()) {
                _mesa_glsl_error(&loc, state,
                                 "length called on unsized array"
@@ -2054,9 +2051,9 @@ ast_function_expression::handle_method(exec_list *instructions,
                   ir_expression(ir_unop_implicitly_sized_array_length, op);
             }
          } else {
-            result = new(ctx) ir_constant(op->type->array_size());
+            result = new(ctx) ir_constant(glsl_array_size(op->type));
          }
-      } else if (op->type->is_vector()) {
+      } else if (glsl_type_is_vector(op->type)) {
          if (state->has_420pack()) {
             /* .length() returns int. */
             result = new(ctx) ir_constant((int) op->type->vector_elements);
@@ -2065,7 +2062,7 @@ ast_function_expression::handle_method(exec_list *instructions,
                              " available with ARB_shading_language_420pack");
             goto fail;
          }
-      } else if (op->type->is_matrix()) {
+      } else if (glsl_type_is_matrix(op->type)) {
          if (state->has_420pack()) {
             /* .length() returns int. */
             result = new(ctx) ir_constant((int) op->type->matrix_columns);
@@ -2090,8 +2087,8 @@ ast_function_expression::handle_method(exec_list *instructions,
 static inline bool is_valid_constructor(const glsl_type *type,
                                         struct _mesa_glsl_parse_state *state)
 {
-   return type->is_numeric() || type->is_boolean() ||
-          (state->has_bindless() && (type->is_sampler() || type->is_image()));
+   return glsl_type_is_numeric(type) || glsl_type_is_boolean(type) ||
+          (state->has_bindless() && (glsl_type_is_sampler(type) || glsl_type_is_image(type)));
 }
 
 ir_rvalue *
@@ -2137,22 +2134,22 @@ ast_function_expression::hir(exec_list *instructions,
        * "Images are represented using 64-bit integer handles, and may be
        *  converted to and from 64-bit integers using constructors."
        */
-      if (constructor_type->contains_atomic() ||
-          (!state->has_bindless() && constructor_type->contains_opaque())) {
+      if (glsl_contains_atomic(constructor_type) ||
+          (!state->has_bindless() && glsl_contains_opaque(constructor_type))) {
          _mesa_glsl_error(& loc, state, "cannot construct %s type `%s'",
                           state->has_bindless() ? "atomic" : "opaque",
                           glsl_get_type_name(constructor_type));
          return ir_rvalue::error_value(ctx);
       }
 
-      if (constructor_type->is_subroutine()) {
+      if (glsl_type_is_subroutine(constructor_type)) {
          _mesa_glsl_error(& loc, state,
                           "subroutine name cannot be a constructor `%s'",
                           glsl_get_type_name(constructor_type));
          return ir_rvalue::error_value(ctx);
       }
 
-      if (constructor_type->is_array()) {
+      if (glsl_type_is_array(constructor_type)) {
          if (!state->check_version(state->allow_glsl_120_subset_in_110 ? 110 : 120,
                                    300, &loc, "array constructors forbidden")) {
             return ir_rvalue::error_value(ctx);
@@ -2177,7 +2174,7 @@ ast_function_expression::hir(exec_list *instructions,
        * must have the exact number of arguments with matching types in the
        * correct order.
        */
-      if (constructor_type->is_struct()) {
+      if (glsl_type_is_struct(constructor_type)) {
          return process_record_constructor(instructions, constructor_type,
                                            &loc, &this->expressions,
                                            state);
@@ -2187,7 +2184,7 @@ ast_function_expression::hir(exec_list *instructions,
          return ir_rvalue::error_value(ctx);
 
       /* Total number of components of the type being constructed. */
-      const unsigned type_components = constructor_type->components();
+      const unsigned type_components = glsl_get_components(constructor_type);
 
       /* Number of components from parameters that have actually been
        * consumed.  This is used to perform several kinds of error checking.
@@ -2223,13 +2220,13 @@ ast_function_expression::hir(exec_list *instructions,
          /* Count the number of matrix and nonmatrix parameters.  This
           * is used below to enforce some of the constructor rules.
           */
-         if (result->type->is_matrix())
+         if (glsl_type_is_matrix(result->type))
             matrix_parameters++;
          else
             nonmatrix_parameters++;
 
          actual_parameters.push_tail(result);
-         components_used += result->type->components();
+         components_used += glsl_get_components(result->type);
       }
 
       /* From page 28 (page 34 of the PDF) of the GLSL 1.10 spec:
@@ -2238,7 +2235,7 @@ ast_function_expression::hir(exec_list *instructions,
        *    is reserved for future use."
        */
       if (matrix_parameters > 0
-          && constructor_type->is_matrix()
+          && glsl_type_is_matrix(constructor_type)
           && !state->check_version(120, 100, &loc,
                                    "cannot construct `%s' from a matrix",
                                    glsl_get_type_name(constructor_type))) {
@@ -2252,7 +2249,7 @@ ast_function_expression::hir(exec_list *instructions,
        */
       if ((matrix_parameters > 0)
           && ((matrix_parameters + nonmatrix_parameters) > 1)
-          && constructor_type->is_matrix()) {
+          && glsl_type_is_matrix(constructor_type)) {
          _mesa_glsl_error(& loc, state, "for matrix `%s' constructor, "
                           "matrix must be only parameter",
                           glsl_get_type_name(constructor_type));
@@ -2277,9 +2274,9 @@ ast_function_expression::hir(exec_list *instructions,
        * constructors. If the constructor type is not matrix, always break the
        * matrix up into a series of column vectors.
        */
-      if (!constructor_type->is_matrix()) {
+      if (!glsl_type_is_matrix(constructor_type)) {
          foreach_in_list_safe(ir_rvalue, matrix, &actual_parameters) {
-            if (!matrix->type->is_matrix())
+            if (!glsl_type_is_matrix(matrix->type))
                continue;
 
             /* Create a temporary containing the matrix. */
@@ -2322,7 +2319,7 @@ ast_function_expression::hir(exec_list *instructions,
           *  any image type(uvec2)       // Converts a pair of 32-bit unsigned integers to
           *                              //   an image type
           */
-         if (ir->type->is_sampler() || ir->type->is_image()) {
+         if (glsl_type_is_sampler(ir->type) || glsl_type_is_image(ir->type)) {
             /* Convert a sampler/image type to a pair of 32-bit unsigned
              * integers as defined by ARB_bindless_texture.
              */
@@ -2332,8 +2329,8 @@ ast_function_expression::hir(exec_list *instructions,
                                 "integers");
             }
             desired_type = &glsl_type_builtin_uvec2;
-         } else if (constructor_type->is_sampler() ||
-                    constructor_type->is_image()) {
+         } else if (glsl_type_is_sampler(constructor_type) ||
+                    glsl_type_is_image(constructor_type)) {
             /* Convert a pair of 32-bit unsigned integers to a sampler or image
              * type as defined by ARB_bindless_texture.
              */
@@ -2345,9 +2342,9 @@ ast_function_expression::hir(exec_list *instructions,
             desired_type = constructor_type;
          } else {
             desired_type =
-               glsl_type::get_instance(constructor_type->base_type,
-                                       ir->type->vector_elements,
-                                       ir->type->matrix_columns);
+               glsl_simple_type(constructor_type->base_type,
+                                ir->type->vector_elements,
+                                ir->type->matrix_columns);
          }
 
          ir_rvalue *result = convert_component(ir, desired_type);
@@ -2373,17 +2370,17 @@ ast_function_expression::hir(exec_list *instructions,
        */
       if (all_parameters_are_constant) {
          return new(ctx) ir_constant(constructor_type, &actual_parameters);
-      } else if (constructor_type->is_scalar()) {
+      } else if (glsl_type_is_scalar(constructor_type)) {
          return dereference_component((ir_rvalue *)
                                       actual_parameters.get_head_raw(),
                                       0);
-      } else if (constructor_type->is_vector()) {
+      } else if (glsl_type_is_vector(constructor_type)) {
          return emit_inline_vector_constructor(constructor_type,
                                                instructions,
                                                &actual_parameters,
                                                ctx);
       } else {
-         assert(constructor_type->is_matrix());
+         assert(glsl_type_is_matrix(constructor_type));
          return emit_inline_matrix_constructor(constructor_type,
                                                instructions,
                                                &actual_parameters,
@@ -2540,12 +2537,12 @@ ast_aggregate_initializer::hir(exec_list *instructions,
       return ir_rvalue::error_value(ctx);
    }
 
-   if (constructor_type->is_array()) {
+   if (glsl_type_is_array(constructor_type)) {
       return process_array_constructor(instructions, constructor_type, &loc,
                                        &this->expressions, state);
    }
 
-   if (constructor_type->is_struct()) {
+   if (glsl_type_is_struct(constructor_type)) {
       return process_record_constructor(instructions, constructor_type, &loc,
                                         &this->expressions, state);
    }
diff --git a/src/compiler/glsl/ast_to_hir.cpp b/src/compiler/glsl/ast_to_hir.cpp
index 1216a5efd2c75..8b5cdd5cb3557 100644
--- a/src/compiler/glsl/ast_to_hir.cpp
+++ b/src/compiler/glsl/ast_to_hir.cpp
@@ -324,15 +324,15 @@ apply_implicit_conversion(const glsl_type *to, ir_rvalue * &from,
     *    example, an array of int cannot be implicitly converted to an
     *    array of float.
     */
-   if (!to->is_numeric() || !from->type->is_numeric())
+   if (!glsl_type_is_numeric(to) || !glsl_type_is_numeric(from->type))
       return false;
 
    /* We don't actually want the specific type `to`, we want a type
     * with the same base type as `to`, but the same vector width as
     * `from`.
     */
-   to = glsl_type::get_instance(to->base_type, from->type->vector_elements,
-                                from->type->matrix_columns);
+   to = glsl_simple_type(to->base_type, from->type->vector_elements,
+                         from->type->matrix_columns);
 
    ir_expression_operation op = get_implicit_conversion_operation(to, from->type, state);
    if (op) {
@@ -358,7 +358,7 @@ arithmetic_result_type(ir_rvalue * &value_a, ir_rvalue * &value_b,
     *    multiply (*), and divide (/) operate on integer and
     *    floating-point scalars, vectors, and matrices."
     */
-   if (!type_a->is_numeric() || !type_b->is_numeric()) {
+   if (!glsl_type_is_numeric(type_a) || !glsl_type_is_numeric(type_b)) {
       _mesa_glsl_error(loc, state,
                        "operands to arithmetic operators must be numeric");
       return &glsl_type_builtin_error;
@@ -402,7 +402,7 @@ arithmetic_result_type(ir_rvalue * &value_a, ir_rvalue * &value_b,
     *    * The two operands are scalars. In this case the operation is
     *      applied, resulting in a scalar."
     */
-   if (type_a->is_scalar() && type_b->is_scalar())
+   if (glsl_type_is_scalar(type_a) && glsl_type_is_scalar(type_b))
       return type_a;
 
    /*   "* One operand is a scalar, and the other is a vector or matrix.
@@ -410,10 +410,10 @@ arithmetic_result_type(ir_rvalue * &value_a, ir_rvalue * &value_b,
     *      component of the vector or matrix, resulting in the same size
     *      vector or matrix."
     */
-   if (type_a->is_scalar()) {
-      if (!type_b->is_scalar())
+   if (glsl_type_is_scalar(type_a)) {
+      if (!glsl_type_is_scalar(type_b))
          return type_b;
-   } else if (type_b->is_scalar()) {
+   } else if (glsl_type_is_scalar(type_b)) {
       return type_a;
    }
 
@@ -421,14 +421,14 @@ arithmetic_result_type(ir_rvalue * &value_a, ir_rvalue * &value_b,
     * <scalar, vector>, <scalar, matrix>, and <matrix, scalar> have been
     * handled.
     */
-   assert(!type_a->is_scalar());
-   assert(!type_b->is_scalar());
+   assert(!glsl_type_is_scalar(type_a));
+   assert(!glsl_type_is_scalar(type_b));
 
    /*   "* The two operands are vectors of the same size. In this case, the
     *      operation is done component-wise resulting in the same size
     *      vector."
     */
-   if (type_a->is_vector() && type_b->is_vector()) {
+   if (glsl_type_is_vector(type_a) && glsl_type_is_vector(type_b)) {
       if (type_a == type_b) {
          return type_a;
       } else {
@@ -444,9 +444,9 @@ arithmetic_result_type(ir_rvalue * &value_a, ir_rvalue * &value_b,
     * be matrix.  Further, since there are no integer matrix types, the base
     * type of both operands must be float.
     */
-   assert(type_a->is_matrix() || type_b->is_matrix());
-   assert(type_a->is_float() || type_a->is_double());
-   assert(type_b->is_float() || type_b->is_double());
+   assert(glsl_type_is_matrix(type_a) || glsl_type_is_matrix(type_b));
+   assert(glsl_type_is_float(type_a) || glsl_type_is_double(type_a));
+   assert(glsl_type_is_float(type_b) || glsl_type_is_double(type_b));
 
    /*   "* The operator is add (+), subtract (-), or divide (/), and the
     *      operands are matrices with the same number of rows and the same
@@ -467,7 +467,7 @@ arithmetic_result_type(ir_rvalue * &value_a, ir_rvalue * &value_b,
       if (type_a == type_b)
          return type_a;
    } else {
-      const glsl_type *type = glsl_type::get_mul_type(type_a, type_b);
+      const glsl_type *type = glsl_get_mul_type(type_a, type_b);
 
       if (type == &glsl_type_builtin_error) {
          _mesa_glsl_error(loc, state,
@@ -497,7 +497,7 @@ unary_arithmetic_result_type(const struct glsl_type *type,
     *     component-wise on their operands. These result with the same type
     *     they operated on."
     */
-   if (!type->is_numeric()) {
+   if (!glsl_type_is_numeric(type)) {
       _mesa_glsl_error(loc, state,
                        "operands to arithmetic operators must be numeric");
       return &glsl_type_builtin_error;
@@ -533,12 +533,12 @@ bit_logic_result_type(ir_rvalue * &value_a, ir_rvalue * &value_b,
     *     (|). The operands must be of type signed or unsigned integers or
     *     integer vectors."
     */
-   if (!type_a->is_integer_32_64()) {
+   if (!glsl_type_is_integer_32_64(type_a)) {
       _mesa_glsl_error(loc, state, "LHS of `%s' must be an integer",
                         ast_expression::operator_string(op));
       return &glsl_type_builtin_error;
    }
-   if (!type_b->is_integer_32_64()) {
+   if (!glsl_type_is_integer_32_64(type_b)) {
       _mesa_glsl_error(loc, state, "RHS of `%s' must be an integer",
                        ast_expression::operator_string(op));
       return &glsl_type_builtin_error;
@@ -584,8 +584,8 @@ bit_logic_result_type(ir_rvalue * &value_a, ir_rvalue * &value_b,
    }
 
    /*     "The operands cannot be vectors of differing size." */
-   if (type_a->is_vector() &&
-       type_b->is_vector() &&
+   if (glsl_type_is_vector(type_a) &&
+       glsl_type_is_vector(type_b) &&
        type_a->vector_elements != type_b->vector_elements) {
       _mesa_glsl_error(loc, state, "operands of `%s' cannot be vectors of "
                        "different sizes", ast_expression::operator_string(op));
@@ -597,7 +597,7 @@ bit_logic_result_type(ir_rvalue * &value_a, ir_rvalue * &value_b,
     *     the vector. The fundamental types of the operands [...] will be the
     *     resulting fundamental type."
     */
-   if (type_a->is_scalar())
+   if (glsl_type_is_scalar(type_a))
        return type_b;
    else
        return type_a;
@@ -620,11 +620,11 @@ modulus_result_type(ir_rvalue * &value_a, ir_rvalue * &value_b,
     *    "The operator modulus (%) operates on signed or unsigned integers or
     *    integer vectors."
     */
-   if (!type_a->is_integer_32_64()) {
+   if (!glsl_type_is_integer_32_64(type_a)) {
       _mesa_glsl_error(loc, state, "LHS of operator %% must be an integer");
       return &glsl_type_builtin_error;
    }
-   if (!type_b->is_integer_32_64()) {
+   if (!glsl_type_is_integer_32_64(type_b)) {
       _mesa_glsl_error(loc, state, "RHS of operator %% must be an integer");
       return &glsl_type_builtin_error;
    }
@@ -656,8 +656,8 @@ modulus_result_type(ir_rvalue * &value_a, ir_rvalue * &value_b,
     *    wise to the vector, resulting in the same type as the vector. If both
     *    are vectors of the same size, the result is computed component-wise."
     */
-   if (type_a->is_vector()) {
-      if (!type_b->is_vector()
+   if (glsl_type_is_vector(type_a)) {
+      if (!glsl_type_is_vector(type_b)
           || (type_a->vector_elements == type_b->vector_elements))
       return type_a;
    } else
@@ -683,10 +683,10 @@ relational_result_type(ir_rvalue * &value_a, ir_rvalue * &value_b,
     *    than or equal (>=), and less than or equal (<=) operate only on
     *    scalar integer and scalar floating-point expressions."
     */
-   if (!type_a->is_numeric()
-       || !type_b->is_numeric()
-       || !type_a->is_scalar()
-       || !type_b->is_scalar()) {
+   if (!glsl_type_is_numeric(type_a)
+       || !glsl_type_is_numeric(type_b)
+       || !glsl_type_is_scalar(type_a)
+       || !glsl_type_is_scalar(type_b)) {
       _mesa_glsl_error(loc, state,
                        "operands to relational operators must be scalar and "
                        "numeric");
@@ -742,13 +742,13 @@ shift_result_type(const struct glsl_type *type_a,
     *     must be signed or unsigned integers or integer vectors. One operand
     *     can be signed while the other is unsigned."
     */
-   if (!type_a->is_integer_32_64()) {
+   if (!glsl_type_is_integer_32_64(type_a)) {
       _mesa_glsl_error(loc, state, "LHS of operator %s must be an integer or "
                        "integer vector", ast_expression::operator_string(op));
      return &glsl_type_builtin_error;
 
    }
-   if (!type_b->is_integer_32_64()) {
+   if (!glsl_type_is_integer_32_64(type_b)) {
       _mesa_glsl_error(loc, state, "RHS of operator %s must be an integer or "
                        "integer vector", ast_expression::operator_string(op));
      return &glsl_type_builtin_error;
@@ -757,7 +757,7 @@ shift_result_type(const struct glsl_type *type_a,
    /*     "If the first operand is a scalar, the second operand has to be
     *     a scalar as well."
     */
-   if (type_a->is_scalar() && !type_b->is_scalar()) {
+   if (glsl_type_is_scalar(type_a) && !glsl_type_is_scalar(type_b)) {
       _mesa_glsl_error(loc, state, "if the first operand of %s is scalar, the "
                        "second must be scalar as well",
                        ast_expression::operator_string(op));
@@ -767,8 +767,8 @@ shift_result_type(const struct glsl_type *type_a,
    /* If both operands are vectors, check that they have same number of
     * elements.
     */
-   if (type_a->is_vector() &&
-      type_b->is_vector() &&
+   if (glsl_type_is_vector(type_a) &&
+      glsl_type_is_vector(type_b) &&
       type_a->vector_elements != type_b->vector_elements) {
       _mesa_glsl_error(loc, state, "vector operands to operator %s must "
                        "have same number of elements",
@@ -834,7 +834,7 @@ validate_assignment(struct _mesa_glsl_parse_state *state,
    /* If there is already some error in the RHS, just return it.  Anything
     * else will lead to an avalanche of error message back to the user.
     */
-   if (rhs->type->is_error())
+   if (glsl_type_is_error(rhs->type))
       return rhs;
 
    /* In the Tessellation Control Shader:
@@ -842,7 +842,7 @@ validate_assignment(struct _mesa_glsl_parse_state *state,
     * if the expression indicating the vertex number is not the identifier
     * `gl_InvocationID`.
     */
-   if (state->stage == MESA_SHADER_TESS_CTRL && !lhs->type->is_error()) {
+   if (state->stage == MESA_SHADER_TESS_CTRL && !glsl_type_is_error(lhs->type)) {
       ir_variable *var = lhs->variable_referenced();
       if (var && var->data.mode == ir_var_shader_out && !var->data.patch) {
          ir_rvalue *index = find_innermost_array_index(lhs);
@@ -871,10 +871,10 @@ validate_assignment(struct _mesa_glsl_parse_state *state,
    const glsl_type *lhs_t = lhs->type;
    const glsl_type *rhs_t = rhs->type;
    bool unsized_array = false;
-   while(lhs_t->is_array()) {
+   while(glsl_type_is_array(lhs_t)) {
       if (rhs_t == lhs_t)
          break; /* the rest of the inner arrays match so break out early */
-      if (!rhs_t->is_array()) {
+      if (!glsl_type_is_array(rhs_t)) {
          unsized_array = false;
          break; /* number of dimensions mismatch */
       }
@@ -882,7 +882,7 @@ validate_assignment(struct _mesa_glsl_parse_state *state,
          lhs_t = lhs_t->fields.array;
          rhs_t = rhs_t->fields.array;
          continue;
-      } else if (lhs_t->is_unsized_array()) {
+      } else if (glsl_type_is_unsized_array(lhs_t)) {
          unsized_array = true;
       } else {
          unsized_array = false;
@@ -893,7 +893,7 @@ validate_assignment(struct _mesa_glsl_parse_state *state,
    }
    if (unsized_array) {
       if (is_initializer) {
-         if (rhs->type->get_scalar_type() == lhs->type->get_scalar_type())
+         if (glsl_get_scalar_type(rhs->type) == glsl_get_scalar_type(lhs->type))
             return rhs;
       } else {
          _mesa_glsl_error(&loc, state,
@@ -936,7 +936,7 @@ do_assignment(exec_list *instructions, struct _mesa_glsl_parse_state *state,
               YYLTYPE lhs_loc)
 {
    void *ctx = state;
-   bool error_emitted = (lhs->type->is_error() || rhs->type->is_error());
+   bool error_emitted = (glsl_type_is_error(lhs->type) || glsl_type_is_error(rhs->type));
 
    ir_variable *lhs_var = lhs->variable_referenced();
    if (lhs_var)
@@ -968,7 +968,7 @@ do_assignment(exec_list *instructions, struct _mesa_glsl_parse_state *state,
                              lhs_var->name);
             error_emitted = true;
          }
-      } else if (lhs->type->is_array() &&
+      } else if (glsl_type_is_array(lhs->type) &&
                  !state->check_version(state->allow_glsl_120_subset_in_110 ? 110 : 120,
                                        300, &lhs_loc,
                                        "whole array assignment forbidden")) {
@@ -997,7 +997,7 @@ do_assignment(exec_list *instructions, struct _mesa_glsl_parse_state *state,
        * dereference of a variable.  Any other case would require that the LHS
        * is either not an l-value or not a whole array.
        */
-      if (lhs->type->is_unsized_array()) {
+      if (glsl_type_is_unsized_array(lhs->type)) {
          ir_dereference *const d = lhs->as_dereference();
 
          assert(d != NULL);
@@ -1006,18 +1006,18 @@ do_assignment(exec_list *instructions, struct _mesa_glsl_parse_state *state,
 
          assert(var != NULL);
 
-         if (var->data.max_array_access >= rhs->type->array_size()) {
+         if (var->data.max_array_access >= glsl_array_size(rhs->type)) {
             /* FINISHME: This should actually log the location of the RHS. */
             _mesa_glsl_error(& lhs_loc, state, "array size must be > %u due to "
                              "previous access",
                              var->data.max_array_access);
          }
 
-         var->type = glsl_type::get_array_instance(lhs->type->fields.array,
-                                                   rhs->type->array_size());
+         var->type = glsl_array_type(lhs->type->fields.array,
+                                     glsl_array_size(rhs->type), 0);
          d->type = var->type;
       }
-      if (lhs->type->is_array()) {
+      if (glsl_type_is_array(lhs->type)) {
          mark_whole_array_access(rhs);
          mark_whole_array_access(lhs);
       }
@@ -1219,7 +1219,7 @@ get_scalar_boolean_operand(exec_list *instructions,
    void *ctx = state;
    ir_rvalue *val = expr->hir(instructions, state);
 
-   if (val->type->is_boolean() && val->type->is_scalar())
+   if (glsl_type_is_boolean(val->type) && glsl_type_is_scalar(val->type))
       return val;
 
    if (!*error_emitted) {
@@ -1436,7 +1436,7 @@ ast_expression::do_hir(exec_list *instructions,
 
       type = unary_arithmetic_result_type(op[0]->type, state, & loc);
 
-      error_emitted = type->is_error();
+      error_emitted = glsl_type_is_error(type);
 
       result = op[0];
       break;
@@ -1446,7 +1446,7 @@ ast_expression::do_hir(exec_list *instructions,
 
       type = unary_arithmetic_result_type(op[0]->type, state, & loc);
 
-      error_emitted = type->is_error();
+      error_emitted = glsl_type_is_error(type);
 
       result = new(ctx) ir_expression(operations[this->oper], type,
                                       op[0], NULL);
@@ -1462,7 +1462,7 @@ ast_expression::do_hir(exec_list *instructions,
       type = arithmetic_result_type(op[0], op[1],
                                     (this->oper == ast_mul),
                                     state, & loc);
-      error_emitted = type->is_error();
+      error_emitted = glsl_type_is_error(type);
 
       result = new(ctx) ir_expression(operations[this->oper], type,
                                       op[0], op[1]);
@@ -1478,7 +1478,7 @@ ast_expression::do_hir(exec_list *instructions,
 
       result = new(ctx) ir_expression(operations[this->oper], type,
                                       op[0], op[1]);
-      error_emitted = type->is_error();
+      error_emitted = glsl_type_is_error(type);
       break;
 
    case ast_lshift:
@@ -1493,7 +1493,7 @@ ast_expression::do_hir(exec_list *instructions,
                                 &loc);
        result = new(ctx) ir_expression(operations[this->oper], type,
                                        op[0], op[1]);
-       error_emitted = op[0]->type->is_error() || op[1]->type->is_error();
+       error_emitted = glsl_type_is_error(op[0]->type) || glsl_type_is_error(op[1]->type);
        break;
 
    case ast_less:
@@ -1508,8 +1508,8 @@ ast_expression::do_hir(exec_list *instructions,
       /* The relational operators must either generate an error or result
        * in a scalar boolean.  See page 57 of the GLSL 1.50 spec.
        */
-      assert(type->is_error()
-             || (type->is_boolean() && type->is_scalar()));
+      assert(glsl_type_is_error(type)
+             || (glsl_type_is_boolean(type) && glsl_type_is_scalar(type)));
 
       /* Like NIR, GLSL IR does not have opcodes for > or <=.  Instead, swap
        * the arguments and use < or >=.
@@ -1522,7 +1522,7 @@ ast_expression::do_hir(exec_list *instructions,
 
       result = new(ctx) ir_expression(operations[this->oper], type,
                                       op[0], op[1]);
-      error_emitted = type->is_error();
+      error_emitted = glsl_type_is_error(type);
       break;
 
    case ast_nequal:
@@ -1552,16 +1552,16 @@ ast_expression::do_hir(exec_list *instructions,
          _mesa_glsl_error(& loc, state, "operands of `%s' must have the same "
                           "type", (this->oper == ast_equal) ? "==" : "!=");
          error_emitted = true;
-      } else if ((op[0]->type->is_array() || op[1]->type->is_array()) &&
+      } else if ((glsl_type_is_array(op[0]->type) || glsl_type_is_array(op[1]->type)) &&
                  !state->check_version(120, 300, &loc,
                                        "array comparisons forbidden")) {
          error_emitted = true;
-      } else if ((op[0]->type->contains_subroutine() ||
-                  op[1]->type->contains_subroutine())) {
+      } else if ((glsl_contains_subroutine(op[0]->type) ||
+                  glsl_contains_subroutine(op[1]->type))) {
          _mesa_glsl_error(&loc, state, "subroutine comparisons forbidden");
          error_emitted = true;
-      } else if ((op[0]->type->contains_opaque() ||
-                  op[1]->type->contains_opaque())) {
+      } else if ((glsl_contains_opaque(op[0]->type) ||
+                  glsl_contains_opaque(op[1]->type))) {
          _mesa_glsl_error(&loc, state, "opaque type comparisons forbidden");
          error_emitted = true;
       }
@@ -1582,7 +1582,7 @@ ast_expression::do_hir(exec_list *instructions,
       type = bit_logic_result_type(op[0], op[1], this->oper, state, &loc);
       result = new(ctx) ir_expression(operations[this->oper], type,
                                       op[0], op[1]);
-      error_emitted = op[0]->type->is_error() || op[1]->type->is_error();
+      error_emitted = glsl_type_is_error(op[0]->type) || glsl_type_is_error(op[1]->type);
       break;
 
    case ast_bit_not:
@@ -1592,7 +1592,7 @@ ast_expression::do_hir(exec_list *instructions,
          error_emitted = true;
       }
 
-      if (!op[0]->type->is_integer_32_64()) {
+      if (!glsl_type_is_integer_32_64(op[0]->type)) {
          _mesa_glsl_error(&loc, state, "operand of `~' must be an integer");
          error_emitted = true;
       }
@@ -1889,7 +1889,7 @@ ast_expression::do_hir(exec_list *instructions,
        *    "The second and third expressions must be the same type, but can
        *    be of any type other than an array."
        */
-      if (type->is_array() &&
+      if (glsl_type_is_array(type) &&
           !state->check_version(120, 300, &loc,
                                 "second and third operands of ?: operator "
                                 "cannot be arrays")) {
@@ -1902,8 +1902,8 @@ ast_expression::do_hir(exec_list *instructions,
        *   parentheses, opaque variables are not allowed to be operands in
        *   expressions; such use results in a compile-time error."
        */
-      if (type->contains_opaque()) {
-         if (!(state->has_bindless() && (type->is_image() || type->is_sampler()))) {
+      if (glsl_contains_opaque(type)) {
+         if (!(state->has_bindless() && (glsl_type_is_image(type) || glsl_type_is_sampler(type)))) {
             _mesa_glsl_error(&loc, state, "variables of type %s cannot be "
                              "operands of the ?: operator", glsl_get_type_name(type));
             error_emitted = true;
@@ -1918,7 +1918,7 @@ ast_expression::do_hir(exec_list *instructions,
          result = cond_val->value.b[0] ? op[1] : op[2];
       } else {
          /* The copy to conditional_tmp reads the whole array. */
-         if (type->is_array()) {
+         if (glsl_type_is_array(type)) {
             mark_whole_array_access(op[1]);
             mark_whole_array_access(op[2]);
          }
@@ -1979,7 +1979,7 @@ ast_expression::do_hir(exec_list *instructions,
       op[0] = this->subexpressions[0]->hir(instructions, state);
       op[1] = constant_one_for_inc_dec(ctx, op[0]->type);
 
-      error_emitted = op[0]->type->is_error() || op[1]->type->is_error();
+      error_emitted = glsl_type_is_error(op[0]->type) || glsl_type_is_error(op[1]->type);
 
       if (error_emitted) {
          result = ir_rvalue::error_value(ctx);
@@ -2026,7 +2026,7 @@ ast_expression::do_hir(exec_list *instructions,
       result = _mesa_ast_array_index_to_hir(ctx, state, op[0], op[1],
                                             loc, index_loc);
 
-      if (result->type->is_error())
+      if (glsl_type_is_error(result->type))
          error_emitted = true;
 
       break;
@@ -2190,7 +2190,7 @@ ast_expression::do_hir(exec_list *instructions,
    type = NULL; /* use result->type, not type. */
    assert(error_emitted || (result != NULL || !needs_rvalue));
 
-   if (result && result->type->is_error() && !error_emitted)
+   if (result && glsl_type_is_error(result->type) && !error_emitted)
       _mesa_glsl_error(& loc, state, "type mismatch");
 
    return result;
@@ -2346,13 +2346,13 @@ process_array_size(exec_node *node,
       return 0;
    }
 
-   if (!ir->type->is_integer_32()) {
+   if (!glsl_type_is_integer_32(ir->type)) {
       _mesa_glsl_error(& loc, state,
                        "array size must be integer type");
       return 0;
    }
 
-   if (!ir->type->is_scalar()) {
+   if (!glsl_type_is_scalar(ir->type)) {
       _mesa_glsl_error(& loc, state,
                        "array size must be scalar type");
       return 0;
@@ -2393,7 +2393,7 @@ process_array_type(YYLTYPE *loc, const glsl_type *base,
    const glsl_type *array_type = base;
 
    if (array_specifier != NULL) {
-      if (base->is_array()) {
+      if (glsl_type_is_array(base)) {
 
          /* From page 19 (page 25) of the GLSL 1.20 spec:
           *
@@ -2407,7 +2407,7 @@ process_array_type(YYLTYPE *loc, const glsl_type *base,
       for (exec_node *node = array_specifier->array_dimensions.get_tail_raw();
            !node->is_head_sentinel(); node = node->prev) {
          unsigned array_size = process_array_size(node, state);
-         array_type = glsl_type::get_array_instance(array_type, array_size);
+         array_type = glsl_array_type(array_type, array_size, 0);
       }
    }
 
@@ -2444,10 +2444,10 @@ precision_qualifier_allowed(const glsl_type *type)
     * From this, we infer that GLSL 1.30 (and later) should allow precision
     * qualifiers on sampler types just like float and integer types.
     */
-   const glsl_type *const t = type->without_array();
+   const glsl_type *const t = glsl_without_array(type);
 
-   return (t->is_float() || t->is_integer_32() || t->contains_opaque()) &&
-          !t->is_struct();
+   return (glsl_type_is_float(t) || glsl_type_is_integer_32(t) || glsl_contains_opaque(t)) &&
+          !glsl_type_is_struct(t);
 }
 
 const glsl_type *
@@ -2506,13 +2506,13 @@ get_type_name_for_precision_qualifier(const glsl_type *type)
    case GLSL_TYPE_SAMPLER: {
       const unsigned type_idx =
          type->sampler_array + 2 * type->sampler_shadow;
-      const unsigned offset = type->is_sampler() ? 0 : 4;
+      const unsigned offset = glsl_type_is_sampler(type) ? 0 : 4;
       assert(type_idx < 4);
       switch (type->sampled_type) {
       case GLSL_TYPE_FLOAT:
          switch (type->sampler_dimensionality) {
          case GLSL_SAMPLER_DIM_1D: {
-            assert(type->is_sampler());
+            assert(glsl_type_is_sampler(type));
             static const char *const names[4] = {
               "sampler1D", "sampler1DArray",
               "sampler1DShadow", "sampler1DArrayShadow"
@@ -2543,14 +2543,14 @@ get_type_name_for_precision_qualifier(const glsl_type *type)
             return names[offset + type_idx];
          }
          case GLSL_SAMPLER_DIM_MS: {
-            assert(type->is_sampler());
+            assert(glsl_type_is_sampler(type));
             static const char *const names[4] = {
               "sampler2DMS", "sampler2DMSArray", NULL, NULL
             };
             return names[type_idx];
          }
          case GLSL_SAMPLER_DIM_RECT: {
-            assert(type->is_sampler());
+            assert(glsl_type_is_sampler(type));
             static const char *const names[4] = {
               "samplerRect", NULL, "samplerRectShadow", NULL
             };
@@ -2564,7 +2564,7 @@ get_type_name_for_precision_qualifier(const glsl_type *type)
             return names[offset + type_idx];
          }
          case GLSL_SAMPLER_DIM_EXTERNAL: {
-            assert(type->is_sampler());
+            assert(glsl_type_is_sampler(type));
             static const char *const names[4] = {
               "samplerExternalOES", NULL, NULL, NULL
             };
@@ -2577,7 +2577,7 @@ get_type_name_for_precision_qualifier(const glsl_type *type)
       case GLSL_TYPE_INT:
          switch (type->sampler_dimensionality) {
          case GLSL_SAMPLER_DIM_1D: {
-            assert(type->is_sampler());
+            assert(glsl_type_is_sampler(type));
             static const char *const names[4] = {
               "isampler1D", "isampler1DArray", NULL, NULL
             };
@@ -2605,14 +2605,14 @@ get_type_name_for_precision_qualifier(const glsl_type *type)
             return names[offset + type_idx];
          }
          case GLSL_SAMPLER_DIM_MS: {
-            assert(type->is_sampler());
+            assert(glsl_type_is_sampler(type));
             static const char *const names[4] = {
               "isampler2DMS", "isampler2DMSArray", NULL, NULL
             };
             return names[type_idx];
          }
          case GLSL_SAMPLER_DIM_RECT: {
-            assert(type->is_sampler());
+            assert(glsl_type_is_sampler(type));
             static const char *const names[4] = {
               "isamplerRect", NULL, "isamplerRectShadow", NULL
             };
@@ -2632,7 +2632,7 @@ get_type_name_for_precision_qualifier(const glsl_type *type)
       case GLSL_TYPE_UINT:
          switch (type->sampler_dimensionality) {
          case GLSL_SAMPLER_DIM_1D: {
-            assert(type->is_sampler());
+            assert(glsl_type_is_sampler(type));
             static const char *const names[4] = {
               "usampler1D", "usampler1DArray", NULL, NULL
             };
@@ -2660,14 +2660,14 @@ get_type_name_for_precision_qualifier(const glsl_type *type)
             return names[offset + type_idx];
          }
          case GLSL_SAMPLER_DIM_MS: {
-            assert(type->is_sampler());
+            assert(glsl_type_is_sampler(type));
             static const char *const names[4] = {
               "usampler2DMS", "usampler2DMSArray", NULL, NULL
             };
             return names[type_idx];
          }
          case GLSL_SAMPLER_DIM_RECT: {
-            assert(type->is_sampler());
+            assert(glsl_type_is_sampler(type));
             static const char *const names[4] = {
               "usamplerRect", NULL, "usamplerRectShadow", NULL
             };
@@ -2713,7 +2713,7 @@ select_gles_precision(unsigned qual_precision,
       precision = qual_precision;
    } else if (precision_qualifier_allowed(type)) {
       const char *type_name =
-         get_type_name_for_precision_qualifier(type->without_array());
+         get_type_name_for_precision_qualifier(glsl_without_array(type));
       assert(type_name != NULL);
 
       precision =
@@ -2732,7 +2732,7 @@ select_gles_precision(unsigned qual_precision,
     *    declare an atomic type with a different precision or to specify the
     *    default precision for an atomic type to be lowp or mediump."
     */
-   if (type->is_atomic_uint() && precision != ast_precision_high) {
+   if (glsl_type_is_atomic_uint(type) && precision != ast_precision_high) {
       _mesa_glsl_error(loc, state,
                        "atomic_uint can only have highp precision qualifier");
    }
@@ -2835,21 +2835,21 @@ validate_component_layout_for_type(struct _mesa_glsl_parse_state *state,
                                    YYLTYPE *loc, const glsl_type *type,
                                    unsigned qual_component)
 {
-   type = type->without_array();
-   unsigned components = type->component_slots();
+   type = glsl_without_array(type);
+   unsigned components = glsl_get_component_slots(type);
 
-   if (type->is_matrix() || type->is_struct()) {
+   if (glsl_type_is_matrix(type) || glsl_type_is_struct(type)) {
        _mesa_glsl_error(loc, state, "component layout qualifier "
                         "cannot be applied to a matrix, a structure, "
                         "a block, or an array containing any of these.");
-   } else if (components > 4 && type->is_64bit()) {
+   } else if (components > 4 && glsl_type_is_64bit(type)) {
       _mesa_glsl_error(loc, state, "component layout qualifier "
                        "cannot be applied to dvec%u.",
                         components / 2);
    } else if (qual_component != 0 && (qual_component + components - 1) > 3) {
       _mesa_glsl_error(loc, state, "component overflow (%u > 3)",
                        (qual_component + components - 1));
-   } else if (qual_component == 1 && type->is_64bit()) {
+   } else if (qual_component == 1 && glsl_type_is_64bit(type)) {
       /* We don't bother checking for 3 as it should be caught by the
        * overflow check above.
        */
@@ -2874,7 +2874,7 @@ validate_matrix_layout_for_type(struct _mesa_glsl_parse_state *state,
                        "uniform block layout qualifiers row_major and "
                        "column_major may not be applied to variables "
                        "outside of uniform blocks");
-   } else if (!type->without_array()->is_matrix()) {
+   } else if (!glsl_type_is_matrix(glsl_without_array(type))) {
       /* The OpenGL ES 3.0 conformance tests did not originally allow
        * matrix layout qualifiers on non-matrices.  However, the OpenGL
        * 4.4 and OpenGL ES 3.0 (revision TBD) specifications were
@@ -2919,9 +2919,9 @@ validate_xfb_offset_qualifier(YYLTYPE *loc,
                               struct _mesa_glsl_parse_state *state,
                               int xfb_offset, const glsl_type *type,
                               unsigned component_size) {
-  const glsl_type *t_without_array = type->without_array();
+  const glsl_type *t_without_array = glsl_without_array(type);
 
-   if (xfb_offset != -1 && type->is_unsized_array()) {
+   if (xfb_offset != -1 && glsl_type_is_unsized_array(type)) {
       _mesa_glsl_error(loc, state,
                        "xfb_offset can't be used with unsized arrays.");
       return false;
@@ -2930,7 +2930,7 @@ validate_xfb_offset_qualifier(YYLTYPE *loc,
    /* Make sure nested structs don't contain unsized arrays, and validate
     * any xfb_offsets on interface members.
     */
-   if (t_without_array->is_struct() || t_without_array->is_interface())
+   if (glsl_type_is_struct(t_without_array) || glsl_type_is_interface(t_without_array))
       for (unsigned int i = 0; i < t_without_array->length; i++) {
          const glsl_type *member_t = t_without_array->fields.structure[i].type;
 
@@ -2938,7 +2938,7 @@ validate_xfb_offset_qualifier(YYLTYPE *loc,
           * we apply the component size rules at the member level.
           */
          if (xfb_offset == -1)
-            component_size = member_t->contains_double() ? 8 : 4;
+            component_size = glsl_contains_double(member_t) ? 8 : 4;
 
          int xfb_offset = t_without_array->fields.structure[i].offset;
          validate_xfb_offset_qualifier(loc, state, xfb_offset, member_t,
@@ -3001,11 +3001,11 @@ apply_explicit_binding(struct _mesa_glsl_parse_state *state,
    }
 
    const struct gl_constants *consts = state->consts;
-   unsigned elements = type->is_array() ? type->arrays_of_arrays_size() : 1;
+   unsigned elements = glsl_type_is_array(type) ? glsl_get_aoa_size(type) : 1;
    unsigned max_index = qual_binding + elements - 1;
-   const glsl_type *base_type = type->without_array();
+   const glsl_type *base_type = glsl_without_array(type);
 
-   if (base_type->is_interface()) {
+   if (glsl_type_is_interface(base_type)) {
       /* UBOs.  From page 60 of the GLSL 4.20 specification:
        * "If the binding point for any uniform block instance is less than zero,
        *  or greater than or equal to the implementation-dependent maximum
@@ -3042,7 +3042,7 @@ apply_explicit_binding(struct _mesa_glsl_parse_state *state,
                           consts->MaxShaderStorageBufferBindings);
          return;
       }
-   } else if (base_type->is_sampler()) {
+   } else if (glsl_type_is_sampler(base_type)) {
       /* Samplers.  From page 63 of the GLSL 4.20 specification:
        * "If the binding is less than zero, or greater than or equal to the
        *  implementation-dependent maximum supported number of units, a
@@ -3059,7 +3059,7 @@ apply_explicit_binding(struct _mesa_glsl_parse_state *state,
 
          return;
       }
-   } else if (base_type->contains_atomic()) {
+   } else if (glsl_contains_atomic(base_type)) {
       assert(consts->MaxAtomicBufferBindings <= MAX_COMBINED_ATOMIC_BUFFERS);
       if (qual_binding >= consts->MaxAtomicBufferBindings) {
          _mesa_glsl_error(loc, state, "layout(binding = %d) exceeds the "
@@ -3071,7 +3071,7 @@ apply_explicit_binding(struct _mesa_glsl_parse_state *state,
       }
    } else if ((state->is_version(420, 310) ||
                state->ARB_shading_language_420pack_enable) &&
-              base_type->is_image()) {
+              glsl_type_is_image(base_type)) {
       assert(consts->MaxImageUnits <= MAX_IMAGE_UNITS);
       if (max_index >= consts->MaxImageUnits) {
          _mesa_glsl_error(loc, state, "Image binding %d exceeds the "
@@ -3136,7 +3136,7 @@ validate_fragment_flat_interpolation_input(struct _mesa_glsl_parse_state *state,
     * an integer. See Khronos bug #15671.
     */
    if ((state->is_version(130, 300) || state->EXT_gpu_shader4_enable)
-       && var_type->contains_integer()) {
+       && glsl_contains_integer(var_type)) {
       _mesa_glsl_error(loc, state, "if a fragment input is (or contains) "
                        "an integer, then it must be qualified with 'flat'");
    }
@@ -3159,7 +3159,7 @@ validate_fragment_flat_interpolation_input(struct _mesa_glsl_parse_state *state,
     * The 'double' type does not exist in GLSL ES so far.
     */
    if (state->has_double()
-       && var_type->contains_double()) {
+       && glsl_contains_double(var_type)) {
       _mesa_glsl_error(loc, state, "if a fragment input is (or contains) "
                        "a double, then it must be qualified with 'flat'");
    }
@@ -3178,7 +3178,7 @@ validate_fragment_flat_interpolation_input(struct _mesa_glsl_parse_state *state,
     *     interpolation qualifier "flat"."
     */
    if (state->has_bindless()
-       && (var_type->contains_sampler() || var_type->contains_image())) {
+       && (glsl_contains_sampler(var_type) || glsl_type_contains_image(var_type))) {
       _mesa_glsl_error(loc, state, "if a fragment input is (or contains) "
                        "a bindless sampler (or image), then it must be "
                        "qualified with 'flat'");
@@ -3321,7 +3321,7 @@ apply_explicit_location(const struct ast_type_qualifier *qual,
          return;
 
       const struct gl_constants *consts = state->consts;
-      unsigned max_loc = qual_location + var->type->uniform_locations() - 1;
+      unsigned max_loc = qual_location + glsl_type_uniform_locations(var->type) - 1;
 
       if (max_loc >= consts->MaxUserAssignableUniformLocations) {
          _mesa_glsl_error(loc, state, "location(s) consumed by uniform %s "
@@ -3531,7 +3531,7 @@ validate_memory_qualifier_for_type(struct _mesa_glsl_parse_state *state,
     *  variables, buffer variables, and shader storage blocks; it is an error
     *  to use such qualifiers in any other declarations.
     */
-   if (!type->is_image() && !qual->flags.q.buffer) {
+   if (!glsl_type_is_image(type) && !qual->flags.q.buffer) {
       if (qual->flags.q.read_only ||
           qual->flags.q.write_only ||
           qual->flags.q.coherent ||
@@ -3557,7 +3557,7 @@ validate_image_format_qualifier_for_type(struct _mesa_glsl_parse_state *state,
     * "Format layout qualifiers can be used on image variable declarations
     *  (those declared with a basic type  having image  in its keyword)."
     */
-   if (!type->is_image() && qual->flags.q.explicit_image_format) {
+   if (!glsl_type_is_image(type) && qual->flags.q.explicit_image_format) {
       _mesa_glsl_error(loc, state, "format layout qualifiers may only be "
                        "applied to images");
       return false;
@@ -3571,13 +3571,13 @@ apply_image_qualifier_to_variable(const struct ast_type_qualifier *qual,
                                   struct _mesa_glsl_parse_state *state,
                                   YYLTYPE *loc)
 {
-   const glsl_type *base_type = var->type->without_array();
+   const glsl_type *base_type = glsl_without_array(var->type);
 
    if (!validate_image_format_qualifier_for_type(state, loc, qual, base_type) ||
        !validate_memory_qualifier_for_type(state, loc, qual, base_type))
       return;
 
-   if (!base_type->is_image())
+   if (!glsl_type_is_image(base_type))
       return;
 
    if (!validate_storage_for_sampler_image_types(var, state, loc))
@@ -3681,10 +3681,10 @@ validate_array_dimensions(const glsl_type *t,
                           struct _mesa_glsl_parse_state *state,
                           YYLTYPE *loc) {
    const glsl_type *top = t;
-   if (t->is_array()) {
+   if (glsl_type_is_array(t)) {
       t = t->fields.array;
-      while (t->is_array()) {
-         if (t->is_unsized_array()) {
+      while (glsl_type_is_array(t)) {
+         if (glsl_type_is_unsized_array(t)) {
             _mesa_glsl_error(loc, state,
                              "only the outermost array dimension can "
                              "be unsized, but got %s",
@@ -3729,14 +3729,14 @@ apply_bindless_qualifier_to_variable(const struct ast_type_qualifier *qual,
     * types.
     */
    if ((qual->flags.q.bindless_sampler || qual->flags.q.bound_sampler) &&
-       !var->type->contains_sampler()) {
+       !glsl_contains_sampler(var->type)) {
       _mesa_glsl_error(loc, state, "bindless_sampler or bound_sampler can only "
                        "be applied to sampler types");
       return;
    }
 
    if ((qual->flags.q.bindless_image || qual->flags.q.bound_image) &&
-       !var->type->contains_image()) {
+       !glsl_type_contains_image(var->type)) {
       _mesa_glsl_error(loc, state, "bindless_image or bound_image can only be "
                        "applied to image types");
       return;
@@ -3746,7 +3746,7 @@ apply_bindless_qualifier_to_variable(const struct ast_type_qualifier *qual,
     * bound_sampler/bound_image) layout qualifiers can be set at global and at
     * local scope.
     */
-   if (var->type->contains_sampler() || var->type->contains_image()) {
+   if (glsl_contains_sampler(var->type) || glsl_type_contains_image(var->type)) {
       var->data.bindless = qual->flags.q.bindless_sampler ||
                            qual->flags.q.bindless_image ||
                            state->bindless_sampler_specified ||
@@ -3769,8 +3769,8 @@ apply_bindless_qualifier_to_variable(const struct ast_type_qualifier *qual,
     * So we treat these images as implicitly bindless just like the types
     * in the spec quote above.
     */
-   if (!var->data.bindless && var->type->is_struct() &&
-       var->type->contains_image()) {
+   if (!var->data.bindless && glsl_type_is_struct(var->type) &&
+       glsl_type_contains_image(var->type)) {
       var->data.bindless = true;
    }
 }
@@ -3888,7 +3888,7 @@ apply_layout_qualifier_to_variable(const struct ast_type_qualifier *qual,
 
    if (qual->flags.q.explicit_xfb_offset) {
       unsigned qual_xfb_offset;
-      unsigned component_size = var->type->contains_double() ? 8 : 4;
+      unsigned component_size = glsl_contains_double(var->type) ? 8 : 4;
 
       if (process_qualifier_constant(state, loc, "xfb_offset",
                                      qual->offset, &qual_xfb_offset) &&
@@ -3908,7 +3908,7 @@ apply_layout_qualifier_to_variable(const struct ast_type_qualifier *qual,
       }
    }
 
-   if (var->type->contains_atomic()) {
+   if (glsl_contains_atomic(var->type)) {
       if (var->data.mode == ir_var_uniform) {
          if (var->data.explicit_binding) {
             unsigned *offset =
@@ -3923,7 +3923,7 @@ apply_layout_qualifier_to_variable(const struct ast_type_qualifier *qual,
                                 "offset > max atomic counter buffer size");
 
             var->data.offset = *offset;
-            *offset += var->type->atomic_size();
+            *offset += glsl_atomic_size(var->type);
 
          } else {
             _mesa_glsl_error(loc, state,
@@ -3936,7 +3936,7 @@ apply_layout_qualifier_to_variable(const struct ast_type_qualifier *qual,
       }
    }
 
-   if (var->type->contains_sampler() &&
+   if (glsl_contains_sampler(var->type) &&
        !validate_storage_for_sampler_image_types(var, state, loc))
       return;
 
@@ -4282,7 +4282,7 @@ apply_type_qualifier_to_variable(const struct ast_type_qualifier *qual,
        *     integer vectors, sampler or image types, or arrays or structures
        *     of any these."
        */
-      switch (var->type->without_array()->base_type) {
+      switch (glsl_without_array(var->type)->base_type) {
       case GLSL_TYPE_FLOAT:
          /* Ok in all GLSL versions */
          break;
@@ -4437,9 +4437,9 @@ get_variable_being_redeclared(ir_variable **var_ptr, YYLTYPE loc,
     *  later re-declare the same name as an array of the same
     *  type and specify a size."
     */
-   if (earlier->type->is_unsized_array() && var->type->is_array()
+   if (glsl_type_is_unsized_array(earlier->type) && glsl_type_is_array(var->type)
        && (var->type->fields.array == earlier->type->fields.array)) {
-      const int size = var->type->array_size();
+      const int size = glsl_array_size(var->type);
       check_builtin_array_max_size(var->name, size, loc, state);
       if ((size > 0) && (size <= earlier->data.max_array_access)) {
          _mesa_glsl_error(& loc, state, "array size must be > %u due to "
@@ -4621,8 +4621,8 @@ process_initializer(ir_variable *var, ast_declaration *decl,
     *    "Images may be declared as shader inputs and outputs, as uniform
     *     variables, as temporary variables, and as function parameters."
     */
-   if (var->type->contains_atomic() ||
-       (!state->has_bindless() && var->type->contains_opaque())) {
+   if (glsl_contains_atomic(var->type) ||
+       (!state->has_bindless() && glsl_contains_opaque(var->type))) {
       _mesa_glsl_error(&initializer_loc, state,
                        "cannot initialize %s variable %s",
                        var->name, state->has_bindless() ? "atomic" : "opaque");
@@ -4736,7 +4736,7 @@ process_initializer(ir_variable *var, ast_declaration *decl,
                                 "constant expression",
                                 variable_mode,
                                 decl->identifier);
-               if (var->type->is_numeric()) {
+               if (glsl_type_is_numeric(var->type)) {
                   /* Reduce cascading errors. */
                   var->constant_value = type->qualifier.flags.q.constant
                      ? ir_constant::zero(state, var->type) : NULL;
@@ -4748,7 +4748,7 @@ process_initializer(ir_variable *var, ast_declaration *decl,
                ? constant_value : NULL;
          }
       } else {
-         if (var->type->is_numeric()) {
+         if (glsl_type_is_numeric(var->type)) {
             /* Reduce cascading errors. */
             rhs = var->constant_value = type->qualifier.flags.q.constant
                ? ir_constant::zero(state, var->type) : NULL;
@@ -4756,7 +4756,7 @@ process_initializer(ir_variable *var, ast_declaration *decl,
       }
    }
 
-   if (rhs && !rhs->type->is_error()) {
+   if (rhs && !glsl_type_is_error(rhs->type)) {
       bool temp = var->data.read_only;
       if (type->qualifier.flags.q.constant)
          var->data.read_only = false;
@@ -4816,7 +4816,7 @@ validate_layout_qualifier_vertex_count(struct _mesa_glsl_parse_state *state,
                                        unsigned *size,
                                        const char *var_category)
 {
-   if (var->type->is_unsized_array()) {
+   if (glsl_type_is_unsized_array(var->type)) {
       /* Section 4.3.8.1 (Input Layout Qualifiers) of the GLSL 1.50 spec says:
        *
        *   All geometry shader input unsized array declarations will be
@@ -4829,8 +4829,8 @@ validate_layout_qualifier_vertex_count(struct _mesa_glsl_parse_state *state,
        * Similarly for tessellation control shader outputs.
        */
       if (num_vertices != 0)
-         var->type = glsl_type::get_array_instance(var->type->fields.array,
-                                                   num_vertices);
+         var->type = glsl_array_type(var->type->fields.array,
+                                     num_vertices, 0);
    } else {
       /* Section 4.3.8.1 (Input Layout Qualifiers) of the GLSL 1.50 spec
        * includes the following examples of compile-time errors:
@@ -4887,7 +4887,7 @@ handle_tess_ctrl_shader_output_decl(struct _mesa_glsl_parse_state *state,
       }
    }
 
-   if (!var->type->is_array() && !var->data.patch) {
+   if (!glsl_type_is_array(var->type) && !var->data.patch) {
       _mesa_glsl_error(&loc, state,
                        "tessellation control shader outputs must be arrays");
 
@@ -4912,7 +4912,7 @@ static void
 handle_tess_shader_input_decl(struct _mesa_glsl_parse_state *state,
                               YYLTYPE loc, ir_variable *var)
 {
-   if (!var->type->is_array() && !var->data.patch) {
+   if (!glsl_type_is_array(var->type) && !var->data.patch) {
       _mesa_glsl_error(&loc, state,
                        "per-vertex tessellation shader inputs must be arrays");
       /* Avoid cascading failures. */
@@ -4931,9 +4931,9 @@ handle_tess_shader_input_decl(struct _mesa_glsl_parse_state *state,
     *
     * This text appears twice, once for TCS inputs, and again for TES inputs.
     */
-   if (var->type->is_unsized_array()) {
-      var->type = glsl_type::get_array_instance(var->type->fields.array,
-            state->Const.MaxPatchVertices);
+   if (glsl_type_is_unsized_array(var->type)) {
+      var->type = glsl_array_type(var->type->fields.array,
+            state->Const.MaxPatchVertices, 0);
    } else if (var->type->length != state->Const.MaxPatchVertices) {
       _mesa_glsl_error(&loc, state,
                        "per-vertex tessellation shader input arrays must be "
@@ -4961,7 +4961,7 @@ handle_geometry_shader_input_decl(struct _mesa_glsl_parse_state *state,
    /* Geometry shader input variables must be arrays.  Caller should have
     * reported an error for this.
     */
-   if (!var->type->is_array()) {
+   if (!glsl_type_is_array(var->type)) {
       assert(state->error);
 
       /* To avoid cascading failures, short circuit the checks below. */
@@ -5113,7 +5113,7 @@ ast_declarator_list::hir(exec_list *instructions,
     * This is done here, based on the layout qualifier and the type of the image var
     */
    if (this->type->qualifier.flags.q.explicit_image_format &&
-         this->type->specifier->type->is_image() &&
+         glsl_type_is_image(this->type->specifier->type) &&
          this->type->qualifier.image_base_type == GLSL_TYPE_VOID) {
       /*     "The ARB_shader_image_load_store says:
        *     If both extensions are enabled in the shading language, the "size*" layout
@@ -5196,7 +5196,7 @@ ast_declarator_list::hir(exec_list *instructions,
     *    shader storage blocks. It is a compile-time error to declare buffer
     *    variables at global scope (outside a block)."
     */
-   if (type->qualifier.flags.q.buffer && !decl_type->is_interface()) {
+   if (type->qualifier.flags.q.buffer && !glsl_type_is_interface(decl_type)) {
       _mesa_glsl_error(&loc, state,
                        "buffer variables cannot be declared outside "
                        "interface blocks");
@@ -5206,7 +5206,7 @@ ast_declarator_list::hir(exec_list *instructions,
     * offset for the next declaration within the same atomic counter
     * buffer.
     */
-   if (decl_type && decl_type->contains_atomic()) {
+   if (decl_type && glsl_contains_atomic(decl_type)) {
       if (type->qualifier.flags.q.explicit_binding &&
           type->qualifier.flags.q.explicit_offset) {
          unsigned qual_binding;
@@ -5263,7 +5263,7 @@ ast_declarator_list::hir(exec_list *instructions,
                           "invalid type `%s' in empty declaration",
                           type_name);
       } else {
-         if (decl_type->is_array()) {
+         if (glsl_type_is_array(decl_type)) {
             /* From Section 13.22 (Array Declarations) of the GLSL ES 3.2
              * spec:
              *
@@ -5271,7 +5271,7 @@ ast_declarator_list::hir(exec_list *instructions,
              *    disallowed as this would add complexity and there are no
              *    use-cases."
              */
-            if (state->es_shader && decl_type->is_unsized_array()) {
+            if (state->es_shader && glsl_type_is_unsized_array(decl_type)) {
                _mesa_glsl_error(&loc, state, "array size must be explicitly "
                                 "or implicitly defined");
             }
@@ -5285,7 +5285,7 @@ ast_declarator_list::hir(exec_list *instructions,
             validate_array_dimensions(decl_type, state, &loc);
          }
 
-         if (decl_type->is_atomic_uint()) {
+         if (glsl_type_is_atomic_uint(decl_type)) {
             /* Empty atomic counter declarations are allowed and useful
              * to set the default offset qualifier.
              */
@@ -5325,7 +5325,7 @@ ast_declarator_list::hir(exec_list *instructions,
        * FINISHME: declaration at a higher scope.
        */
 
-      if ((decl_type == NULL) || decl_type->is_void()) {
+      if ((decl_type == NULL) || glsl_type_is_void(decl_type)) {
          if (type_name != NULL) {
             _mesa_glsl_error(& loc, state,
                              "invalid type `%s' in declaration of `%s'",
@@ -5418,7 +5418,7 @@ ast_declarator_list::hir(exec_list *instructions,
                                          &loc);
 
       if ((state->zero_init & (1u << var->data.mode)) &&
-          (var->type->is_numeric() || var->type->is_boolean())) {
+          (glsl_type_is_numeric(var->type) || glsl_type_is_boolean(var->type))) {
          const ir_constant_data data = { { 0 } };
          var->data.has_initializer = true;
          var->data.is_implicit_initializer = true;
@@ -5500,7 +5500,7 @@ ast_declarator_list::hir(exec_list *instructions,
              *    floating-point vectors, matrices, signed and unsigned
              *    integers and integer vectors, sampler and image types."
              */
-            const glsl_type *check_type = var->type->without_array();
+            const glsl_type *check_type = glsl_without_array(var->type);
 
             bool error = false;
             switch (check_type->base_type) {
@@ -5529,9 +5529,9 @@ ast_declarator_list::hir(exec_list *instructions,
                _mesa_glsl_error(& loc, state,
                                 "vertex shader input / attribute cannot have "
                                 "type %s`%s'",
-                                var->type->is_array() ? "array of " : "",
+                                glsl_type_is_array(var->type) ? "array of " : "",
                                 glsl_get_type_name(check_type));
-            } else if (var->type->is_array() &&
+            } else if (glsl_type_is_array(var->type) &&
                 !state->check_version(150, 0, &loc,
                                       "vertex shader input / attribute "
                                       "cannot have array type")) {
@@ -5545,7 +5545,7 @@ ast_declarator_list::hir(exec_list *instructions,
              *     vertices, each input varying variable (or input block, see
              *     interface blocks below) needs to be declared as an array.
              */
-            if (!var->type->is_array()) {
+            if (!glsl_type_is_array(var->type)) {
                _mesa_glsl_error(&loc, state,
                                 "geometry shader inputs must be arrays");
             }
@@ -5565,30 +5565,30 @@ ast_declarator_list::hir(exec_list *instructions,
              *     * A structure containing a structure
              */
             if (state->es_shader) {
-               const glsl_type *check_type = var->type->without_array();
-               if (check_type->is_boolean() ||
-                   check_type->contains_opaque()) {
+               const glsl_type *check_type = glsl_without_array(var->type);
+               if (glsl_type_is_boolean(check_type) ||
+                   glsl_contains_opaque(check_type)) {
                   _mesa_glsl_error(&loc, state,
                                    "fragment shader input cannot have type %s",
                                    glsl_get_type_name(check_type));
                }
-               if (var->type->is_array() &&
-                   var->type->fields.array->is_array()) {
+               if (glsl_type_is_array(var->type) &&
+                   glsl_type_is_array(var->type->fields.array)) {
                   _mesa_glsl_error(&loc, state,
                                    "%s shader output "
                                    "cannot have an array of arrays",
                                    _mesa_shader_stage_to_string(state->stage));
                }
-               if (var->type->is_array() &&
-                   var->type->fields.array->is_struct()) {
+               if (glsl_type_is_array(var->type) &&
+                   glsl_type_is_struct(var->type->fields.array)) {
                   _mesa_glsl_error(&loc, state,
                                    "fragment shader input "
                                    "cannot have an array of structs");
                }
-               if (var->type->is_struct()) {
+               if (glsl_type_is_struct(var->type)) {
                   for (unsigned i = 0; i < var->type->length; i++) {
-                     if (var->type->fields.structure[i].type->is_array() ||
-                         var->type->fields.structure[i].type->is_struct())
+                     if (glsl_type_is_array(var->type->fields.structure[i].type) ||
+                         glsl_type_is_struct(var->type->fields.structure[i].type))
                         _mesa_glsl_error(&loc, state,
                                          "fragment shader input cannot have "
                                          "a struct that contains an "
@@ -5601,7 +5601,7 @@ ast_declarator_list::hir(exec_list *instructions,
             handle_tess_shader_input_decl(state, loc, var);
          }
       } else if (var->data.mode == ir_var_shader_out) {
-         const glsl_type *check_type = var->type->without_array();
+         const glsl_type *check_type = glsl_without_array(var->type);
 
          /* From section 4.3.6 (Output variables) of the GLSL 4.40 spec:
           *
@@ -5615,7 +5615,7 @@ ast_declarator_list::hir(exec_list *instructions,
           *     * A structure
           */
          if (state->stage == MESA_SHADER_FRAGMENT) {
-            if (check_type->is_struct() || check_type->is_matrix())
+            if (glsl_type_is_struct(check_type) || glsl_type_is_matrix(check_type))
                _mesa_glsl_error(&loc, state,
                                 "fragment shader output "
                                 "cannot have struct or matrix type");
@@ -5671,8 +5671,8 @@ ast_declarator_list::hir(exec_list *instructions,
           * the old rules.
           */
          if (state->es_shader) {
-            if (var->type->is_array() &&
-                var->type->fields.array->is_array()) {
+            if (glsl_type_is_array(var->type) &&
+                glsl_type_is_array(var->type->fields.array)) {
                _mesa_glsl_error(&loc, state,
                                 "%s shader output "
                                 "cannot have an array of arrays",
@@ -5682,20 +5682,20 @@ ast_declarator_list::hir(exec_list *instructions,
                const glsl_type *type = var->type;
 
                if (state->stage == MESA_SHADER_TESS_CTRL &&
-                   !var->data.patch && var->type->is_array()) {
+                   !var->data.patch && glsl_type_is_array(var->type)) {
                   type = var->type->fields.array;
                }
 
-               if (type->is_array() && type->fields.array->is_struct()) {
+               if (glsl_type_is_array(type) && glsl_type_is_struct(type->fields.array)) {
                   _mesa_glsl_error(&loc, state,
                                    "%s shader output cannot have "
                                    "an array of structs",
                                    _mesa_shader_stage_to_string(state->stage));
                }
-               if (type->is_struct()) {
+               if (glsl_type_is_struct(type)) {
                   for (unsigned i = 0; i < type->length; i++) {
-                     if (type->fields.structure[i].type->is_array() ||
-                         type->fields.structure[i].type->is_struct())
+                     if (glsl_type_is_array(type->fields.structure[i].type) ||
+                         glsl_type_is_struct(type->fields.structure[i].type))
                         _mesa_glsl_error(&loc, state,
                                          "%s shader output cannot have a "
                                          "struct that contains an "
@@ -5709,7 +5709,7 @@ ast_declarator_list::hir(exec_list *instructions,
          if (state->stage == MESA_SHADER_TESS_CTRL) {
             handle_tess_ctrl_shader_output_decl(state, loc, var);
          }
-      } else if (var->type->contains_subroutine()) {
+      } else if (glsl_contains_subroutine(var->type)) {
          /* declare subroutine uniforms as hidden */
          var->data.how_declared = ir_var_hidden;
       }
@@ -5770,8 +5770,8 @@ ast_declarator_list::hir(exec_list *instructions,
        *     variables, as temporary variables, and as function parameters."
        */
       if (!this->type->qualifier.flags.q.uniform &&
-          (var_type->contains_atomic() ||
-           (!state->has_bindless() && var_type->contains_opaque()))) {
+          (glsl_contains_atomic(var_type) ||
+           (!state->has_bindless() && glsl_contains_opaque(var_type)))) {
          _mesa_glsl_error(&loc, state,
                           "%s variables must be declared uniform",
                           state->has_bindless() ? "atomic" : "opaque");
@@ -5851,7 +5851,7 @@ ast_declarator_list::hir(exec_list *instructions,
             (var->data.mode == ir_var_shader_out &&
              state->stage == MESA_SHADER_TESS_CTRL);
 
-         if (t->is_unsized_array() && !implicitly_sized)
+         if (glsl_type_is_unsized_array(t) && !implicitly_sized)
             /* Section 10.17 of the GLSL ES 1.00 specification states that
              * unsized array declarations have been removed from the language.
              * Arrays that are sized using an initializer are still explicitly
@@ -5879,8 +5879,8 @@ ast_declarator_list::hir(exec_list *instructions,
        *    "It is a compile-time error to declare an unsized array of
        *     atomic_uint"
        */
-      if (var->type->is_unsized_array() &&
-          var->type->without_array()->base_type == GLSL_TYPE_ATOMIC_UINT) {
+      if (glsl_type_is_unsized_array(var->type) &&
+          glsl_without_array(var->type)->base_type == GLSL_TYPE_ATOMIC_UINT) {
          _mesa_glsl_error(& loc, state,
                           "Unsized array of atomic_uint is not allowed");
       }
@@ -5974,7 +5974,7 @@ ast_parameter_declarator::hir(exec_list *instructions,
     * for a function, which avoids tripping up checks for main taking
     * parameters and lookups of an unnamed symbol.
     */
-   if (type->is_void()) {
+   if (glsl_type_is_void(type)) {
       if (this->identifier != NULL)
          _mesa_glsl_error(& loc, state,
                           "named parameter cannot have type `void'");
@@ -5993,7 +5993,7 @@ ast_parameter_declarator::hir(exec_list *instructions,
     */
    type = process_array_type(&loc, type, this->array_specifier, state);
 
-   if (!type->is_error() && type->is_unsized_array()) {
+   if (!glsl_type_is_error(type) && glsl_type_is_unsized_array(type)) {
       _mesa_glsl_error(&loc, state, "arrays passed as parameters must have "
                        "a declared size");
       type = &glsl_type_builtin_error;
@@ -6010,7 +6010,7 @@ ast_parameter_declarator::hir(exec_list *instructions,
                                     true);
 
    if (((1u << var->data.mode) & state->zero_init) &&
-       (var->type->is_numeric() || var->type->is_boolean())) {
+       (glsl_type_is_numeric(var->type) || glsl_type_is_boolean(var->type))) {
          const ir_constant_data data = { { 0 } };
          var->data.has_initializer = true;
          var->data.is_implicit_initializer = true;
@@ -6034,8 +6034,8 @@ ast_parameter_declarator::hir(exec_list *instructions,
     *    "out" and "inout" function parameters."
     */
    if ((var->data.mode == ir_var_function_inout || var->data.mode == ir_var_function_out)
-       && (type->contains_atomic() ||
-           (!state->has_bindless() && type->contains_opaque()))) {
+       && (glsl_contains_atomic(type) ||
+           (!state->has_bindless() && glsl_contains_opaque(type)))) {
       _mesa_glsl_error(&loc, state, "out and inout parameters cannot "
                        "contain %s variables",
                        state->has_bindless() ? "atomic" : "opaque");
@@ -6057,7 +6057,7 @@ ast_parameter_declarator::hir(exec_list *instructions,
     * allowed.  This restriction is removed in GLSL 1.20, and in GLSL ES.
     */
    if ((var->data.mode == ir_var_function_inout || var->data.mode == ir_var_function_out)
-       && type->is_array()
+       && glsl_type_is_array(type)
        && !state->check_version(120, 100, &loc,
                                 "arrays cannot be out or inout parameters")) {
       type = &glsl_type_builtin_error;
@@ -6198,7 +6198,7 @@ ast_function::hir(exec_list *instructions,
     *     "Arrays are allowed as arguments and as the return type. In both
     *     cases, the array must be explicitly sized."
     */
-   if (return_type->is_unsized_array()) {
+   if (glsl_type_is_unsized_array(return_type)) {
       YYLTYPE loc = this->get_location();
       _mesa_glsl_error(& loc, state,
                        "function `%s' return type array must be explicitly "
@@ -6211,7 +6211,7 @@ ast_function::hir(exec_list *instructions,
     *      The return type can also be a structure if the structure does not
     *      contain an array."
     */
-   if (state->language_version == 100 && return_type->contains_array()) {
+   if (state->language_version == 100 && glsl_contains_array(return_type)) {
       YYLTYPE loc = this->get_location();
       _mesa_glsl_error(& loc, state,
                        "function `%s' return type contains an array", name);
@@ -6226,8 +6226,8 @@ ast_function::hir(exec_list *instructions,
     * "Replace Section 4.1.7 (Samplers), p. 25" and, "Replace Section 4.1.X,
     * (Images)", this should be allowed.
     */
-   if (return_type->contains_atomic() ||
-       (!state->has_bindless() && return_type->contains_opaque())) {
+   if (glsl_contains_atomic(return_type) ||
+       (!state->has_bindless() && glsl_contains_opaque(return_type))) {
       YYLTYPE loc = this->get_location();
       _mesa_glsl_error(&loc, state,
                        "function `%s' return type can't contain an %s type",
@@ -6235,7 +6235,7 @@ ast_function::hir(exec_list *instructions,
    }
 
    /**/
-   if (return_type->is_subroutine()) {
+   if (glsl_type_is_subroutine(return_type)) {
       YYLTYPE loc = this->get_location();
       _mesa_glsl_error(&loc, state,
                        "function `%s' return type can't be a subroutine type",
@@ -6359,7 +6359,7 @@ ast_function::hir(exec_list *instructions,
 
    /* Verify the return type of main() */
    if (strcmp(name, "main") == 0) {
-      if (! return_type->is_void()) {
+      if (! glsl_type_is_void(return_type)) {
          YYLTYPE loc = this->get_location();
 
          _mesa_glsl_error(& loc, state, "main() must return void");
@@ -6447,7 +6447,7 @@ ast_function::hir(exec_list *instructions,
    }
 
    if (this->return_type->qualifier.is_subroutine_decl()) {
-      if (!state->symbols->add_type(this->identifier, glsl_type::get_subroutine_instance(this->identifier))) {
+      if (!state->symbols->add_type(this->identifier, glsl_subroutine_type(this->identifier))) {
          _mesa_glsl_error(& loc, state, "type '%s' previously defined", this->identifier);
          return NULL;
       }
@@ -6511,7 +6511,7 @@ ast_function_definition::hir(exec_list *instructions,
    assert(state->current_function == signature);
    state->current_function = NULL;
 
-   if (!signature->return_type->is_void() && !state->found_return) {
+   if (!glsl_type_is_void(signature->return_type) && !state->found_return) {
       YYLTYPE loc = this->get_location();
       _mesa_glsl_error(& loc, state, "function `%s' has non-void return type "
                        "%s, but no return statement",
@@ -6727,7 +6727,7 @@ ast_selection_statement::hir(exec_list *instructions,
     * The checks are separated so that higher quality diagnostics can be
     * generated for cases where both rules are violated.
     */
-   if (!condition->type->is_boolean() || !condition->type->is_scalar()) {
+   if (!glsl_type_is_boolean(condition->type) || !glsl_type_is_scalar(condition->type)) {
       YYLTYPE loc = this->condition->get_location();
 
       _mesa_glsl_error(& loc, state, "if-statement condition must be scalar "
@@ -6811,8 +6811,8 @@ ast_switch_statement::hir(exec_list *instructions,
     *    "The type of init-expression in a switch statement must be a
     *     scalar integer."
     */
-   if (!test_val->type->is_scalar() ||
-       !test_val->type->is_integer_32()) {
+   if (!glsl_type_is_scalar(test_val->type) ||
+       !glsl_type_is_integer_32(test_val->type)) {
       YYLTYPE loc = this->test_expression->get_location();
 
       _mesa_glsl_error(& loc,
@@ -7133,7 +7133,7 @@ ast_case_label::hir(exec_list *instructions,
          bool integer_conversion_supported =
             _mesa_glsl_can_implicitly_convert(&glsl_type_builtin_int, &glsl_type_builtin_uint, state);
 
-         if ((!type_a->is_integer_32() || !type_b->is_integer_32()) ||
+         if ((!glsl_type_is_integer_32(type_a) || !glsl_type_is_integer_32(type_b)) ||
               !integer_conversion_supported) {
             _mesa_glsl_error(&loc, state, "type mismatch with switch "
                              "init-expression and case label (%s != %s)",
@@ -7194,7 +7194,7 @@ ast_iteration_statement::condition_to_hir(exec_list *instructions,
          condition->hir(instructions, state);
 
       if ((cond == NULL)
-          || !cond->type->is_boolean() || !cond->type->is_scalar()) {
+          || !glsl_type_is_boolean(cond->type) || !glsl_type_is_scalar(cond->type)) {
          YYLTYPE loc = condition->get_location();
 
          _mesa_glsl_error(& loc, state,
@@ -7524,14 +7524,14 @@ ast_process_struct_or_iface_block_members(exec_list *instructions,
           *
           *     * sampler types are not allowed
           */
-         if (decl_type->contains_atomic() ||
-             (!state->has_bindless() && decl_type->contains_opaque())) {
+         if (glsl_contains_atomic(decl_type) ||
+             (!state->has_bindless() && glsl_contains_opaque(decl_type))) {
             _mesa_glsl_error(&loc, state, "uniform/buffer in non-default "
                              "interface block contains %s variable",
                              state->has_bindless() ? "atomic" : "opaque");
          }
       } else {
-         if (decl_type->contains_atomic()) {
+         if (glsl_contains_atomic(decl_type)) {
             /* From section 4.1.7.3 of the GLSL 4.40 spec:
              *
              *    "Members of structures cannot be declared as atomic counter
@@ -7540,7 +7540,7 @@ ast_process_struct_or_iface_block_members(exec_list *instructions,
             _mesa_glsl_error(&loc, state, "atomic counter in structure");
          }
 
-         if (!state->has_bindless() && decl_type->contains_image()) {
+         if (!state->has_bindless() && glsl_type_contains_image(decl_type)) {
             /* FINISHME: Same problem as with atomic counters.
              * FINISHME: Request clarification from Khronos and add
              * FINISHME: spec quotation here.
@@ -7695,12 +7695,12 @@ ast_process_struct_or_iface_block_members(exec_list *instructions,
                fields[i].location = qual_location +
                   (fields[i].patch ? VARYING_SLOT_PATCH0 : VARYING_SLOT_VAR0);
                expl_location = fields[i].location +
-                  fields[i].type->count_attribute_slots(false);
+                  glsl_count_attribute_slots(fields[i].type, false);
             }
          } else {
             if (layout && layout->flags.q.explicit_location) {
                fields[i].location = expl_location;
-               expl_location += fields[i].type->count_attribute_slots(false);
+               expl_location += glsl_count_attribute_slots(fields[i].type, false);
             } else {
                fields[i].location = -1;
             }
@@ -7733,11 +7733,11 @@ ast_process_struct_or_iface_block_members(exec_list *instructions,
             }
 
             if(layout->flags.q.std140) {
-               base_alignment = field_type->std140_base_alignment(row_major);
-               size = field_type->std140_size(row_major);
+               base_alignment = glsl_get_std140_base_alignment(field_type, row_major);
+               size = glsl_get_std140_size(field_type, row_major);
             } else if (layout->flags.q.std430) {
-               base_alignment = field_type->std430_base_alignment(row_major);
-               size = field_type->std430_size(row_major);
+               base_alignment = glsl_get_std430_base_alignment(field_type, row_major);
+               size = glsl_get_std430_size(field_type, row_major);
             }
          }
 
@@ -7807,13 +7807,13 @@ ast_process_struct_or_iface_block_members(exec_list *instructions,
                                            qual->offset, &xfb_offset)) {
                fields[i].offset = xfb_offset;
                block_xfb_offset = fields[i].offset +
-                  4 * field_type->component_slots();
+                  4 * glsl_get_component_slots(field_type);
             }
          } else {
             if (layout && layout->flags.q.explicit_xfb_offset) {
-               unsigned base_alignment = field_type->is_64bit() ? 8 : 4;
+               unsigned base_alignment = glsl_type_is_64bit(field_type) ? 8 : 4;
                fields[i].offset = align(block_xfb_offset, base_alignment);
-               block_xfb_offset += 4 * field_type->component_slots();
+               block_xfb_offset += 4 * glsl_get_component_slots(field_type);
             }
          }
 
@@ -7824,8 +7824,8 @@ ast_process_struct_or_iface_block_members(exec_list *instructions,
           */
          if (is_interface && layout &&
              (layout->flags.q.uniform || layout->flags.q.buffer) &&
-             (field_type->without_array()->is_matrix()
-              || field_type->without_array()->is_struct())) {
+             (glsl_type_is_matrix(glsl_without_array(field_type))
+              || glsl_type_is_struct(glsl_without_array(field_type)))) {
             /* If no layout is specified for the field, inherit the layout
              * from the block.
              */
@@ -7847,7 +7847,7 @@ ast_process_struct_or_iface_block_members(exec_list *instructions,
           * the format qualifier is only accepted for images.
           */
          if (var_mode == ir_var_shader_storage ||
-             field_type->without_array()->is_image()) {
+             glsl_type_is_image(glsl_without_array(field_type))) {
             /* For readonly and writeonly qualifiers the field definition,
              * if set, overwrites the layout qualifier.
              */
@@ -7871,10 +7871,10 @@ ast_process_struct_or_iface_block_members(exec_list *instructions,
             fields[i].memory_restrict = qual->flags.q.restrict_flag ||
                                         (layout && layout->flags.q.restrict_flag);
 
-            if (field_type->without_array()->is_image()) {
+            if (glsl_type_is_image(glsl_without_array(field_type))) {
                if (qual->flags.q.explicit_image_format) {
                   if (qual->image_base_type !=
-                      field_type->without_array()->sampled_type) {
+                      glsl_without_array(field_type)->sampled_type) {
                      _mesa_glsl_error(&loc, state, "format qualifier doesn't "
                                       "match the base data type of the image");
                   }
@@ -7954,12 +7954,12 @@ ast_struct_specifier::hir(exec_list *instructions,
 
    validate_identifier(this->name, loc, state);
 
-   type = glsl_type::get_struct_instance(fields, decl_count, this->name);
+   type = glsl_struct_type(fields, decl_count, this->name, false /* packed */);
 
    if (!is_anonymous(type) && !state->symbols->add_type(name, type)) {
       const glsl_type *match = state->symbols->get_type(name);
       /* allow struct matching for desktop GL - older UE4 does this */
-      if (match != NULL && state->is_version(130, 0) && match->record_compare(type, true, false))
+      if (match != NULL && state->is_version(130, 0) && glsl_record_compare(match, type, true, false, true))
          _mesa_glsl_warning(& loc, state, "struct `%s' previously defined", name);
       else
          _mesa_glsl_error(& loc, state, "struct `%s' previously defined", name);
@@ -8017,7 +8017,7 @@ is_unsized_array_last_element(ir_variable *v)
    const glsl_type *interface_type = v->get_interface_type();
    int length = interface_type->length;
 
-   assert(v->type->is_unsized_array());
+   assert(glsl_type_is_unsized_array(v->type));
 
    /* Check if it is the last element of the interface */
    if (strcmp(interface_type->fields.structure[length-1].name, v->name) == 0)
@@ -8262,7 +8262,7 @@ ast_interface_block::hir(exec_list *instructions,
        *     scope for anything other than as a block name."
        */
       ir_variable *var = state->symbols->get_variable(this->block_name);
-      if (var && !var->type->is_interface()) {
+      if (var && !glsl_type_is_interface(var->type)) {
          _mesa_glsl_error(&loc, state, "Block name `%s' is "
                           "already used in the scope.",
                           this->block_name);
@@ -8343,7 +8343,7 @@ ast_interface_block::hir(exec_list *instructions,
 
       /* Copy locations from the old gl_PerVertex interface block. */
       for (unsigned i = 0; i < num_variables; i++) {
-         int j = earlier_per_vertex->field_index(fields[i].name);
+         int j = glsl_get_field_index(earlier_per_vertex, fields[i].name);
          if (j == -1) {
             _mesa_glsl_error(&loc, state,
                              "redeclaration of gl_PerVertex must be a subset "
@@ -8394,14 +8394,14 @@ ast_interface_block::hir(exec_list *instructions,
    }
 
    const glsl_type *block_type =
-      glsl_type::get_interface_instance(fields,
-                                        num_variables,
-                                        packing,
-                                        matrix_layout ==
-                                           GLSL_MATRIX_LAYOUT_ROW_MAJOR,
-                                        this->block_name);
-
-   unsigned component_size = block_type->contains_double() ? 8 : 4;
+      glsl_interface_type(fields,
+                          num_variables,
+                          packing,
+                          matrix_layout ==
+                          GLSL_MATRIX_LAYOUT_ROW_MAJOR,
+                          this->block_name);
+
+   unsigned component_size = glsl_contains_double(block_type) ? 8 : 4;
    int xfb_offset =
       layout.flags.q.explicit_xfb_offset ? (int) qual_xfb_offset : -1;
    validate_xfb_offset_qualifier(&loc, state, xfb_offset, block_type,
@@ -8462,8 +8462,8 @@ ast_interface_block::hir(exec_list *instructions,
           * of the interface that are arrays.
           */
          for (unsigned i = 0; i < num_variables; i++) {
-            if (fields[i].type->is_array()) {
-               const unsigned size = fields[i].type->array_size();
+            if (glsl_type_is_array(fields[i].type)) {
+               const unsigned size = glsl_array_size(fields[i].type);
                check_builtin_array_max_size(fields[i].name, size, loc, state);
             }
          }
@@ -8553,7 +8553,7 @@ ast_interface_block::hir(exec_list *instructions,
           * tessellation control shader output, and tessellation evaluation
           * shader input.
           */
-         if (block_array_type->is_unsized_array()) {
+         if (glsl_type_is_unsized_array(block_array_type)) {
             bool allow_inputs = state->stage == MESA_SHADER_GEOMETRY ||
                                 state->stage == MESA_SHADER_TESS_CTRL ||
                                 state->stage == MESA_SHADER_TESS_EVAL;
@@ -8584,8 +8584,8 @@ ast_interface_block::hir(exec_list *instructions,
           *
           *     * Arrays of arrays of blocks are not allowed
           */
-         if (state->es_shader && block_array_type->is_array() &&
-             block_array_type->fields.array->is_array()) {
+         if (state->es_shader && glsl_type_is_array(block_array_type) &&
+             glsl_type_is_array(block_array_type->fields.array)) {
             _mesa_glsl_error(&loc, state,
                              "arrays of arrays interface blocks are "
                              "not allowed");
@@ -8732,7 +8732,7 @@ ast_interface_block::hir(exec_list *instructions,
                                    var->get_interface_type(), &this->layout);
          }
 
-         if (var->type->is_unsized_array()) {
+         if (glsl_type_is_unsized_array(var->type)) {
             if (var->is_in_shader_storage_block() &&
                 is_unsized_array_last_element(var)) {
                var->data.from_ssbo_unsized_array = true;
@@ -8843,7 +8843,7 @@ ast_tcs_output_layout::hir(exec_list *instructions,
          continue;
 
       /* Note: Not all tessellation control shader output are arrays. */
-      if (!var->type->is_unsized_array() || var->data.patch)
+      if (!glsl_type_is_unsized_array(var->type) || var->data.patch)
          continue;
 
       if (var->data.max_array_access >= (int)num_vertices) {
@@ -8853,8 +8853,8 @@ ast_tcs_output_layout::hir(exec_list *instructions,
                           "%u of output `%s' already exists", num_vertices,
                           var->data.max_array_access, var->name);
       } else {
-         var->type = glsl_type::get_array_instance(var->type->fields.array,
-                                                   num_vertices);
+         var->type = glsl_array_type(var->type->fields.array,
+                                     num_vertices, 0);
       }
    }
 
@@ -8900,7 +8900,7 @@ ast_gs_input_layout::hir(exec_list *instructions,
        * array; skip it.
        */
 
-      if (var->type->is_unsized_array()) {
+      if (glsl_type_is_unsized_array(var->type)) {
          if (var->data.max_array_access >= (int)num_vertices) {
             _mesa_glsl_error(&loc, state,
                              "this geometry shader input layout implies %u"
@@ -8908,8 +8908,8 @@ ast_gs_input_layout::hir(exec_list *instructions,
                              " `%s' already exists", num_vertices,
                              var->data.max_array_access, var->name);
          } else {
-            var->type = glsl_type::get_array_instance(var->type->fields.array,
-                                                      num_vertices);
+            var->type = glsl_array_type(var->type->fields.array,
+                                        num_vertices, 0);
          }
       }
    }
diff --git a/src/compiler/glsl/ast_type.cpp b/src/compiler/glsl/ast_type.cpp
index 6abccc4d16480..4aa3d657d877a 100644
--- a/src/compiler/glsl/ast_type.cpp
+++ b/src/compiler/glsl/ast_type.cpp
@@ -944,7 +944,7 @@ ast_layout_expression::process_qualifier_constant(struct _mesa_glsl_parse_state
       ir_constant *const const_int =
          ir->constant_expression_value(ralloc_parent(ir));
 
-      if (const_int == NULL || !const_int->type->is_integer_32()) {
+      if (const_int == NULL || !glsl_type_is_integer_32(const_int->type)) {
          YYLTYPE loc = const_expression->get_location();
          _mesa_glsl_error(&loc, state, "%s must be an integral constant "
                           "expression", qual_indentifier);
@@ -1000,7 +1000,7 @@ process_qualifier_constant(struct _mesa_glsl_parse_state *state,
 
    ir_constant *const const_int =
       ir->constant_expression_value(ralloc_parent(ir));
-   if (const_int == NULL || !const_int->type->is_integer_32()) {
+   if (const_int == NULL || !glsl_type_is_integer_32(const_int->type)) {
       _mesa_glsl_error(loc, state, "%s must be an integral constant "
                        "expression", qual_indentifier);
       return false;
diff --git a/src/compiler/glsl/builtin_functions.cpp b/src/compiler/glsl/builtin_functions.cpp
index 8c20ba245337d..8a60856991f01 100644
--- a/src/compiler/glsl/builtin_functions.cpp
+++ b/src/compiler/glsl/builtin_functions.cpp
@@ -5719,7 +5719,7 @@ builtin_builder::imm(const glsl_type *type, const ir_constant_data &data)
    return new(mem_ctx) ir_constant(type, &data);
 }
 
-#define IMM_FP(type, val) (type->is_double()) ? imm(val) : imm((float)val)
+#define IMM_FP(type, val) (glsl_type_is_double(type)) ? imm(val) : imm((float)val)
 
 ir_dereference_variable *
 builtin_builder::var_ref(ir_variable *var)
@@ -5917,7 +5917,7 @@ builtin_builder::call(ir_function *f, ir_variable *ret, exec_list params)
       return NULL;
 
    ir_dereference_variable *deref =
-      (sig->return_type->is_void() ? NULL : var_ref(ret));
+      (glsl_type_is_void(sig->return_type) ? NULL : var_ref(ret));
 
    return new(mem_ctx) ir_call(sig, deref, &actual_params);
 }
@@ -6147,14 +6147,14 @@ builtin_builder::_step(builtin_available_predicate avail, const glsl_type *edge_
    ir_variable *t = body.make_temp(x_type, "t");
    if (x_type->vector_elements == 1) {
       /* Both are floats */
-      if (edge_type->is_double())
+      if (glsl_type_is_double(edge_type))
          body.emit(assign(t, f2d(b2f(gequal(x, edge)))));
       else
          body.emit(assign(t, b2f(gequal(x, edge))));
    } else if (edge_type->vector_elements == 1) {
       /* x is a vector but edge is a float */
       for (int i = 0; i < x_type->vector_elements; i++) {
-         if (edge_type->is_double())
+         if (glsl_type_is_double(edge_type))
             body.emit(assign(t, f2d(b2f(gequal(swizzle(x, i, 1), edge))), 1 << i));
          else
             body.emit(assign(t, b2f(gequal(swizzle(x, i, 1), edge)), 1 << i));
@@ -6162,7 +6162,7 @@ builtin_builder::_step(builtin_available_predicate avail, const glsl_type *edge_
    } else {
       /* Both are vectors */
       for (int i = 0; i < x_type->vector_elements; i++) {
-         if (edge_type->is_double())
+         if (glsl_type_is_double(edge_type))
             body.emit(assign(t, f2d(b2f(gequal(swizzle(x, i, 1), swizzle(edge, i, 1)))),
                              1 << i));
          else
@@ -6204,7 +6204,7 @@ ir_function_signature *
 builtin_builder::_isnan(builtin_available_predicate avail, const glsl_type *type)
 {
    ir_variable *x = in_var(type, "x");
-   MAKE_SIG(glsl_type::bvec(type->vector_elements), avail, 1, x);
+   MAKE_SIG(glsl_bvec_type(type->vector_elements), avail, 1, x);
 
    body.emit(ret(nequal(x, x)));
 
@@ -6215,7 +6215,7 @@ ir_function_signature *
 builtin_builder::_isinf(builtin_available_predicate avail, const glsl_type *type)
 {
    ir_variable *x = in_var(type, "x");
-   MAKE_SIG(glsl_type::bvec(type->vector_elements), avail, 1, x);
+   MAKE_SIG(glsl_bvec_type(type->vector_elements), avail, 1, x);
 
    ir_constant_data infinities;
    for (int i = 0; i < type->vector_elements; i++) {
@@ -6246,7 +6246,7 @@ ir_function_signature *
 builtin_builder::_floatBitsToInt(const glsl_type *type)
 {
    ir_variable *x = in_var(type, "x");
-   MAKE_SIG(glsl_type::ivec(type->vector_elements), shader_bit_encoding, 1, x);
+   MAKE_SIG(glsl_ivec_type(type->vector_elements), shader_bit_encoding, 1, x);
    body.emit(ret(bitcast_f2i(as_highp(body, x))));
    return sig;
 }
@@ -6255,7 +6255,7 @@ ir_function_signature *
 builtin_builder::_floatBitsToUint(const glsl_type *type)
 {
    ir_variable *x = in_var(type, "x");
-   MAKE_SIG(glsl_type::uvec(type->vector_elements), shader_bit_encoding, 1, x);
+   MAKE_SIG(glsl_uvec_type(type->vector_elements), shader_bit_encoding, 1, x);
    body.emit(ret(bitcast_f2u(as_highp(body, x))));
    return sig;
 }
@@ -6264,7 +6264,7 @@ ir_function_signature *
 builtin_builder::_intBitsToFloat(const glsl_type *type)
 {
    ir_variable *x = in_var(type, "x");
-   MAKE_SIG(glsl_type::vec(type->vector_elements), shader_bit_encoding, 1, x);
+   MAKE_SIG(glsl_vec_type(type->vector_elements), shader_bit_encoding, 1, x);
    body.emit(ret(bitcast_i2f(as_highp(body, x))));
    return sig;
 }
@@ -6273,7 +6273,7 @@ ir_function_signature *
 builtin_builder::_uintBitsToFloat(const glsl_type *type)
 {
    ir_variable *x = in_var(type, "x");
-   MAKE_SIG(glsl_type::vec(type->vector_elements), shader_bit_encoding, 1, x);
+   MAKE_SIG(glsl_vec_type(type->vector_elements), shader_bit_encoding, 1, x);
    body.emit(ret(bitcast_u2f(as_highp(body, x))));
    return sig;
 }
@@ -6282,7 +6282,7 @@ ir_function_signature *
 builtin_builder::_doubleBitsToInt64(builtin_available_predicate avail, const glsl_type *type)
 {
    ir_variable *x = in_var(type, "x");
-   MAKE_SIG(glsl_type::i64vec(type->vector_elements), avail, 1, x);
+   MAKE_SIG(glsl_i64vec_type(type->vector_elements), avail, 1, x);
    body.emit(ret(bitcast_d2i64(x)));
    return sig;
 }
@@ -6291,7 +6291,7 @@ ir_function_signature *
 builtin_builder::_doubleBitsToUint64(builtin_available_predicate avail, const glsl_type *type)
 {
    ir_variable *x = in_var(type, "x");
-   MAKE_SIG(glsl_type::u64vec(type->vector_elements), avail, 1, x);
+   MAKE_SIG(glsl_u64vec_type(type->vector_elements), avail, 1, x);
    body.emit(ret(bitcast_d2u64(x)));
    return sig;
 }
@@ -6300,7 +6300,7 @@ ir_function_signature *
 builtin_builder::_int64BitsToDouble(builtin_available_predicate avail, const glsl_type *type)
 {
    ir_variable *x = in_var(type, "x");
-   MAKE_SIG(glsl_type::dvec(type->vector_elements), avail, 1, x);
+   MAKE_SIG(glsl_dvec_type(type->vector_elements), avail, 1, x);
    body.emit(ret(bitcast_i642d(x)));
    return sig;
 }
@@ -6309,7 +6309,7 @@ ir_function_signature *
 builtin_builder::_uint64BitsToDouble(builtin_available_predicate avail, const glsl_type *type)
 {
    ir_variable *x = in_var(type, "x");
-   MAKE_SIG(glsl_type::dvec(type->vector_elements), avail, 1, x);
+   MAKE_SIG(glsl_dvec_type(type->vector_elements), avail, 1, x);
    body.emit(ret(bitcast_u642d(x)));
    return sig;
 }
@@ -6473,7 +6473,7 @@ ir_function_signature *
 builtin_builder::_length(builtin_available_predicate avail, const glsl_type *type)
 {
    ir_variable *x = in_var(type, "x");
-   MAKE_SIG(type->get_base_type(), avail, 1, x);
+   MAKE_SIG(glsl_get_base_glsl_type(type), avail, 1, x);
 
    body.emit(ret(sqrt(dot(x, x))));
 
@@ -6485,7 +6485,7 @@ builtin_builder::_distance(builtin_available_predicate avail, const glsl_type *t
 {
    ir_variable *p0 = in_var(type, "p0");
    ir_variable *p1 = in_var(type, "p1");
-   MAKE_SIG(type->get_base_type(), avail, 2, p0, p1);
+   MAKE_SIG(glsl_get_base_glsl_type(type), avail, 2, p0, p1);
 
    if (type->vector_elements == 1) {
       body.emit(ret(abs(sub(p0, p1))));
@@ -6505,7 +6505,7 @@ builtin_builder::_dot(builtin_available_predicate avail, const glsl_type *type)
       return binop(avail, ir_binop_mul, type, type, type);
 
    return binop(avail, ir_binop_dot,
-                type->get_base_type(), type, type);
+                glsl_get_base_glsl_type(type), type, type);
 }
 
 ir_function_signature *
@@ -6583,10 +6583,10 @@ builtin_builder::_refract(builtin_available_predicate avail, const glsl_type *ty
 {
    ir_variable *I = in_var(type, "I");
    ir_variable *N = in_var(type, "N");
-   ir_variable *eta = in_var(type->get_base_type(), "eta");
+   ir_variable *eta = in_var(glsl_get_base_glsl_type(type), "eta");
    MAKE_SIG(type, avail, 3, I, N, eta);
 
-   ir_variable *n_dot_i = body.make_temp(type->get_base_type(), "n_dot_i");
+   ir_variable *n_dot_i = body.make_temp(glsl_get_base_glsl_type(type), "n_dot_i");
    body.emit(assign(n_dot_i, dot(N, I)));
 
    /* From the GLSL 1.10 specification:
@@ -6596,7 +6596,7 @@ builtin_builder::_refract(builtin_available_predicate avail, const glsl_type *ty
     * else
     *    return eta * I - (eta * dot(N, I) + sqrt(k)) * N
     */
-   ir_variable *k = body.make_temp(type->get_base_type(), "k");
+   ir_variable *k = body.make_temp(glsl_get_base_glsl_type(type), "k");
    body.emit(assign(k, sub(IMM_FP(type, 1.0),
                            mul(eta, mul(eta, sub(IMM_FP(type, 1.0),
                                                  mul(n_dot_i, n_dot_i)))))));
@@ -6630,12 +6630,12 @@ builtin_builder::_outerProduct(builtin_available_predicate avail, const glsl_typ
    ir_variable *c;
    ir_variable *r;
 
-   if (type->is_double()) {
-      r = in_var(glsl_type::dvec(type->matrix_columns), "r");
-      c = in_var(glsl_type::dvec(type->vector_elements), "c");
+   if (glsl_type_is_double(type)) {
+      r = in_var(glsl_dvec_type(type->matrix_columns), "r");
+      c = in_var(glsl_dvec_type(type->vector_elements), "c");
    } else {
-      r = in_var(glsl_type::vec(type->matrix_columns), "r");
-      c = in_var(glsl_type::vec(type->vector_elements), "c");
+      r = in_var(glsl_vec_type(type->matrix_columns), "r");
+      c = in_var(glsl_vec_type(type->vector_elements), "c");
    }
    MAKE_SIG(type, avail, 2, c, r);
 
@@ -6652,9 +6652,9 @@ ir_function_signature *
 builtin_builder::_transpose(builtin_available_predicate avail, const glsl_type *orig_type)
 {
    const glsl_type *transpose_type =
-      glsl_type::get_instance(orig_type->base_type,
-                              orig_type->matrix_columns,
-                              orig_type->vector_elements);
+      glsl_simple_type(orig_type->base_type,
+                       orig_type->matrix_columns,
+                       orig_type->vector_elements);
 
    ir_variable *m = in_var(orig_type, "m");
    MAKE_SIG(transpose_type, avail, 1, m);
@@ -6676,7 +6676,7 @@ ir_function_signature *
 builtin_builder::_determinant_mat2(builtin_available_predicate avail, const glsl_type *type)
 {
    ir_variable *m = in_var(type, "m");
-   MAKE_SIG(type->get_base_type(), avail, 1, m);
+   MAKE_SIG(glsl_get_base_glsl_type(type), avail, 1, m);
 
    body.emit(ret(sub(mul(matrix_elt(m, 0, 0), matrix_elt(m, 1, 1)),
                      mul(matrix_elt(m, 1, 0), matrix_elt(m, 0, 1)))));
@@ -6688,7 +6688,7 @@ ir_function_signature *
 builtin_builder::_determinant_mat3(builtin_available_predicate avail, const glsl_type *type)
 {
    ir_variable *m = in_var(type, "m");
-   MAKE_SIG(type->get_base_type(), avail, 1, m);
+   MAKE_SIG(glsl_get_base_glsl_type(type), avail, 1, m);
 
    ir_expression *f1 =
       sub(mul(matrix_elt(m, 1, 1), matrix_elt(m, 2, 2)),
@@ -6713,7 +6713,7 @@ ir_function_signature *
 builtin_builder::_determinant_mat4(builtin_available_predicate avail, const glsl_type *type)
 {
    ir_variable *m = in_var(type, "m");
-   const glsl_type *btype = type->get_base_type();
+   const glsl_type *btype = glsl_get_base_glsl_type(type);
    MAKE_SIG(btype, avail, 1, m);
 
    ir_variable *SubFactor00 = body.make_temp(btype, "SubFactor00");
@@ -6808,7 +6808,7 @@ ir_function_signature *
 builtin_builder::_inverse_mat3(builtin_available_predicate avail, const glsl_type *type)
 {
    ir_variable *m = in_var(type, "m");
-   const glsl_type *btype = type->get_base_type();
+   const glsl_type *btype = glsl_get_base_glsl_type(type);
    MAKE_SIG(type, avail, 1, m);
 
    ir_variable *f11_22_21_12 = body.make_temp(btype, "f11_22_21_12");
@@ -6870,7 +6870,7 @@ ir_function_signature *
 builtin_builder::_inverse_mat4(builtin_available_predicate avail, const glsl_type *type)
 {
    ir_variable *m = in_var(type, "m");
-   const glsl_type *btype = type->get_base_type();
+   const glsl_type *btype = glsl_get_base_glsl_type(type);
    MAKE_SIG(type, avail, 1, m);
 
    ir_variable *SubFactor00 = body.make_temp(btype, "SubFactor00");
@@ -7015,7 +7015,7 @@ builtin_builder::_lessThan(builtin_available_predicate avail,
                            const glsl_type *type)
 {
    return binop(avail, ir_binop_less,
-                glsl_type::bvec(type->vector_elements), type, type);
+                glsl_bvec_type(type->vector_elements), type, type);
 }
 
 ir_function_signature *
@@ -7023,7 +7023,7 @@ builtin_builder::_lessThanEqual(builtin_available_predicate avail,
                                 const glsl_type *type)
 {
    return binop(avail, ir_binop_gequal,
-                glsl_type::bvec(type->vector_elements), type, type,
+                glsl_bvec_type(type->vector_elements), type, type,
                 true);
 }
 
@@ -7032,7 +7032,7 @@ builtin_builder::_greaterThan(builtin_available_predicate avail,
                               const glsl_type *type)
 {
    return binop(avail, ir_binop_less,
-                glsl_type::bvec(type->vector_elements), type, type,
+                glsl_bvec_type(type->vector_elements), type, type,
                 true);
 }
 
@@ -7041,7 +7041,7 @@ builtin_builder::_greaterThanEqual(builtin_available_predicate avail,
                                    const glsl_type *type)
 {
    return binop(avail, ir_binop_gequal,
-                glsl_type::bvec(type->vector_elements), type, type);
+                glsl_bvec_type(type->vector_elements), type, type);
 }
 
 ir_function_signature *
@@ -7049,7 +7049,7 @@ builtin_builder::_equal(builtin_available_predicate avail,
                         const glsl_type *type)
 {
    return binop(avail, ir_binop_equal,
-                glsl_type::bvec(type->vector_elements), type, type);
+                glsl_bvec_type(type->vector_elements), type, type);
 }
 
 ir_function_signature *
@@ -7057,7 +7057,7 @@ builtin_builder::_notEqual(builtin_available_predicate avail,
                            const glsl_type *type)
 {
    return binop(avail, ir_binop_nequal,
-                glsl_type::bvec(type->vector_elements), type, type);
+                glsl_bvec_type(type->vector_elements), type, type);
 }
 
 ir_function_signature *
@@ -7089,7 +7089,7 @@ UNOP(not, ir_unop_logic_not, always_available)
 static bool
 has_lod(const glsl_type *sampler_type)
 {
-   assert(sampler_type->is_sampler());
+   assert(glsl_type_is_sampler(sampler_type));
 
    switch (sampler_type->sampler_dimensionality) {
    case GLSL_SAMPLER_DIM_RECT:
@@ -7183,7 +7183,7 @@ builtin_builder::_texture(ir_texture_opcode opcode,
    ir_texture *tex = new(mem_ctx) ir_texture(opcode, flags & TEX_SPARSE);
    tex->set_sampler(var_ref(s), return_type);
 
-   const int coord_size = sampler_type->coordinate_components();
+   const int coord_size = glsl_get_sampler_coordinate_components(sampler_type);
 
    if (coord_size == coord_type->vector_elements) {
       tex->coordinate = var_ref(P);
@@ -7220,8 +7220,8 @@ builtin_builder::_texture(ir_texture_opcode opcode,
       tex->lod_info.lod = var_ref(lod);
    } else if (opcode == ir_txd) {
       int grad_size = coord_size - (sampler_type->sampler_array ? 1 : 0);
-      ir_variable *dPdx = in_var(glsl_type::vec(grad_size), "dPdx");
-      ir_variable *dPdy = in_var(glsl_type::vec(grad_size), "dPdy");
+      ir_variable *dPdx = in_var(glsl_vec_type(grad_size), "dPdx");
+      ir_variable *dPdy = in_var(glsl_vec_type(grad_size), "dPdy");
       sig->parameters.push_tail(dPdx);
       sig->parameters.push_tail(dPdy);
       tex->lod_info.grad.dPdx = var_ref(dPdx);
@@ -7231,7 +7231,7 @@ builtin_builder::_texture(ir_texture_opcode opcode,
    if (flags & (TEX_OFFSET | TEX_OFFSET_NONCONST)) {
       int offset_size = coord_size - (sampler_type->sampler_array ? 1 : 0);
       ir_variable *offset =
-         new(mem_ctx) ir_variable(glsl_type::ivec(offset_size), "offset",
+         new(mem_ctx) ir_variable(glsl_ivec_type(offset_size), "offset",
                                   (flags & TEX_OFFSET) ? ir_var_const_in : ir_var_function_in);
       sig->parameters.push_tail(offset);
       tex->offset = var_ref(offset);
@@ -7239,7 +7239,7 @@ builtin_builder::_texture(ir_texture_opcode opcode,
 
    if (flags & TEX_OFFSET_ARRAY) {
       ir_variable *offsets =
-         new(mem_ctx) ir_variable(glsl_type::get_array_instance(&glsl_type_builtin_ivec2, 4),
+         new(mem_ctx) ir_variable(glsl_array_type(&glsl_type_builtin_ivec2, 4, 0),
                                   "offsets", ir_var_const_in);
       sig->parameters.push_tail(offsets);
       tex->offset = var_ref(offsets);
@@ -7673,7 +7673,7 @@ ir_function_signature *
 builtin_builder::_bitCount(const glsl_type *type)
 {
    ir_variable *x = in_var(type, "x");
-   MAKE_SIG(glsl_type::ivec(type->vector_elements), gpu_shader5_or_es31_or_integer_functions, 1, x);
+   MAKE_SIG(glsl_ivec_type(type->vector_elements), gpu_shader5_or_es31_or_integer_functions, 1, x);
    sig->return_precision = GLSL_PRECISION_LOW;
    body.emit(ret(expr(ir_unop_bit_count, x)));
    return sig;
@@ -7683,7 +7683,7 @@ ir_function_signature *
 builtin_builder::_findLSB(const glsl_type *type)
 {
    ir_variable *x = in_highp_var(type, "x");
-   MAKE_SIG(glsl_type::ivec(type->vector_elements), gpu_shader5_or_es31_or_integer_functions, 1, x);
+   MAKE_SIG(glsl_ivec_type(type->vector_elements), gpu_shader5_or_es31_or_integer_functions, 1, x);
    sig->return_precision = GLSL_PRECISION_LOW;
    body.emit(ret(expr(ir_unop_find_lsb, x)));
    return sig;
@@ -7693,7 +7693,7 @@ ir_function_signature *
 builtin_builder::_findMSB(const glsl_type *type)
 {
    ir_variable *x = in_highp_var(type, "x");
-   MAKE_SIG(glsl_type::ivec(type->vector_elements), gpu_shader5_or_es31_or_integer_functions, 1, x);
+   MAKE_SIG(glsl_ivec_type(type->vector_elements), gpu_shader5_or_es31_or_integer_functions, 1, x);
    sig->return_precision = GLSL_PRECISION_LOW;
    body.emit(ret(expr(ir_unop_find_msb, x)));
    return sig;
@@ -7704,7 +7704,7 @@ builtin_builder::_countLeadingZeros(builtin_available_predicate avail,
                                     const glsl_type *type)
 {
    return unop(avail, ir_unop_clz,
-               glsl_type::uvec(type->vector_elements), type);
+               glsl_uvec_type(type->vector_elements), type);
 }
 
 ir_function_signature *
@@ -7712,7 +7712,7 @@ builtin_builder::_countTrailingZeros(builtin_available_predicate avail,
                                      const glsl_type *type)
 {
    ir_variable *a = in_var(type, "a");
-   MAKE_SIG(glsl_type::uvec(type->vector_elements), avail, 1, a);
+   MAKE_SIG(glsl_uvec_type(type->vector_elements), avail, 1, a);
 
    body.emit(ret(ir_builder::min2(
                     ir_builder::i2u(ir_builder::expr(ir_unop_find_lsb, a)),
@@ -7739,7 +7739,7 @@ builtin_builder::_ldexp(const glsl_type *x_type, const glsl_type *exp_type)
 {
    ir_variable *x = in_highp_var(x_type, "x");
    ir_variable *y = in_highp_var(exp_type, "y");
-   MAKE_SIG(x_type, x_type->is_double() ? fp64 : gpu_shader5_or_es31_or_integer_functions, 2, x, y);
+   MAKE_SIG(x_type, glsl_type_is_double(x_type) ? fp64 : gpu_shader5_or_es31_or_integer_functions, 2, x, y);
    sig->return_precision = GLSL_PRECISION_HIGH;
    body.emit(ret(expr(ir_binop_ldexp, x, y)));
    return sig;
@@ -7750,7 +7750,7 @@ builtin_builder::_frexp(const glsl_type *x_type, const glsl_type *exp_type)
 {
    ir_variable *x = in_highp_var(x_type, "x");
    ir_variable *exponent = out_var(exp_type, "exp");
-   MAKE_SIG(x_type, x_type->is_double() ? fp64 : gpu_shader5_or_es31_or_integer_functions,
+   MAKE_SIG(x_type, glsl_type_is_double(x_type) ? fp64 : gpu_shader5_or_es31_or_integer_functions,
             2, x, exponent);
    sig->return_precision = GLSL_PRECISION_HIGH;
 
@@ -7812,8 +7812,8 @@ builtin_builder::_absoluteDifference(builtin_available_predicate avail,
     * bits and number of vector elements as the type of the operands.
     */
    return binop(avail, ir_binop_abs_sub,
-                glsl_type::get_instance(glsl_unsigned_base_type_of(type->base_type),
-                                        type->vector_elements, 1),
+                glsl_simple_type(glsl_unsigned_base_type_of(type->base_type),
+                                 type->vector_elements, 1),
                 type, type);
 }
 
@@ -7842,11 +7842,11 @@ builtin_builder::_mulExtended(const glsl_type *type)
 
    if (type->base_type == GLSL_TYPE_INT) {
       unpack_op = ir_unop_unpack_int_2x32;
-      mul_type = glsl_type::get_instance(GLSL_TYPE_INT64, type->vector_elements, 1);
+      mul_type = glsl_simple_type(GLSL_TYPE_INT64, type->vector_elements, 1);
       unpack_type = &glsl_type_builtin_ivec2;
    } else {
       unpack_op = ir_unop_unpack_uint_2x32;
-      mul_type = glsl_type::get_instance(GLSL_TYPE_UINT64, type->vector_elements, 1);
+      mul_type = glsl_simple_type(GLSL_TYPE_UINT64, type->vector_elements, 1);
       unpack_type = &glsl_type_builtin_uvec2;
    }
 
@@ -8161,7 +8161,7 @@ builtin_builder::_image_prototype(const glsl_type *image_type,
                                   unsigned num_arguments,
                                   unsigned flags)
 {
-   const glsl_type *data_type = glsl_type::get_instance(
+   const glsl_type *data_type = glsl_simple_type(
       image_type->sampled_type,
       (flags & IMAGE_FUNCTION_HAS_VECTOR_DATA_TYPE ? 4 : 1),
       1);
@@ -8178,7 +8178,7 @@ builtin_builder::_image_prototype(const glsl_type *image_type,
             glsl_struct_field(&glsl_type_builtin_int, "code"),
             glsl_struct_field(data_type, "texel"),
          };
-         ret_type = glsl_type::get_struct_instance(fields, 2, "struct");
+         ret_type = glsl_struct_type(fields, 2, "struct", false /* packed */);
       }
    } else
       ret_type = data_type;
@@ -8186,7 +8186,7 @@ builtin_builder::_image_prototype(const glsl_type *image_type,
    /* Addressing arguments that are always present. */
    ir_variable *image = in_var(image_type, "image");
    ir_variable *coord = in_var(
-      glsl_type::ivec(image_type->coordinate_components()), "coord");
+      glsl_ivec_type(glsl_get_sampler_coordinate_components(image_type)), "coord");
 
    ir_function_signature *sig = new_sig(
       ret_type, get_image_available_predicate(image_type, flags),
@@ -8225,7 +8225,7 @@ builtin_builder::_image_size_prototype(const glsl_type *image_type,
                                        unsigned /* flags */)
 {
    const glsl_type *ret_type;
-   unsigned num_components = image_type->coordinate_components();
+   unsigned num_components = glsl_get_sampler_coordinate_components(image_type);
 
    /* From the ARB_shader_image_size extension:
     * "Cube images return the dimensions of one face."
@@ -8238,7 +8238,7 @@ builtin_builder::_image_size_prototype(const glsl_type *image_type,
    /* FIXME: Add the highp precision qualifier for GLES 3.10 when it is
     * supported by mesa.
     */
-   ret_type = glsl_type::get_instance(GLSL_TYPE_INT, num_components, 1);
+   ret_type = glsl_simple_type(GLSL_TYPE_INT, num_components, 1);
 
    ir_variable *image = in_var(image_type, "image");
    ir_function_signature *sig = new_sig(ret_type, shader_image_size, 1, image);
diff --git a/src/compiler/glsl/builtin_types.cpp b/src/compiler/glsl/builtin_types.cpp
index 4ea82781226b2..5e7698e70271c 100644
--- a/src/compiler/glsl/builtin_types.cpp
+++ b/src/compiler/glsl/builtin_types.cpp
@@ -259,7 +259,7 @@ _mesa_glsl_initialize_types(struct _mesa_glsl_parse_state *state)
     * copy of the struct types.
     */
    {
-      #define GET_STRUCT_TYPE(NAME) glsl_type::get_struct_instance(NAME##_fields, ARRAY_SIZE(NAME##_fields), #NAME)
+      #define GET_STRUCT_TYPE(NAME) glsl_struct_type(NAME##_fields, ARRAY_SIZE(NAME##_fields), #NAME, false /* packed */)
 
       if (state->is_version(110, 100)) {
          add_type(symbols, GET_STRUCT_TYPE(gl_DepthRangeParameters));
diff --git a/src/compiler/glsl/builtin_variables.cpp b/src/compiler/glsl/builtin_variables.cpp
index 100cc4c05b325..cbf0c9d34fbab 100644
--- a/src/compiler/glsl/builtin_variables.cpp
+++ b/src/compiler/glsl/builtin_variables.cpp
@@ -409,10 +409,10 @@ per_vertex_accumulator::add_field(int slot, const glsl_type *type,
 const glsl_type *
 per_vertex_accumulator::construct_interface_instance() const
 {
-   return glsl_type::get_interface_instance(this->fields, this->num_fields,
-                                            GLSL_INTERFACE_PACKING_STD140,
-                                            false,
-                                            "gl_PerVertex");
+   return glsl_interface_type(this->fields, this->num_fields,
+                              GLSL_INTERFACE_PACKING_STD140,
+                              false,
+                              "gl_PerVertex");
 }
 
 
@@ -435,7 +435,7 @@ public:
 private:
    const glsl_type *array(const glsl_type *base, unsigned elements)
    {
-      return glsl_type::get_array_instance(base, elements);
+      return glsl_array_type(base, elements, 0);
    }
 
    const glsl_type *type(const char *name)
@@ -669,7 +669,7 @@ builtin_variable_generator::add_uniform(const glsl_type *type,
       _mesa_glsl_get_builtin_uniform_desc(name);
    assert(statevar != NULL);
 
-   const unsigned array_count = type->is_array() ? type->length : 1;
+   const unsigned array_count = glsl_type_is_array(type) ? type->length : 1;
 
    ir_state_slot *slots =
       uni->allocate_state_slots(array_count * statevar->num_elements);
@@ -680,7 +680,7 @@ builtin_variable_generator::add_uniform(const glsl_type *type,
 	    &statevar->elements[j];
 
 	 memcpy(slots->tokens, element->tokens, sizeof(element->tokens));
-	 if (type->is_array())
+	 if (glsl_type_is_array(type))
             slots->tokens[1] = a;
 
 	 slots++;
diff --git a/src/compiler/glsl/glsl_parser.yy b/src/compiler/glsl/glsl_parser.yy
index 0a6bd6af0d6b5..8c0535f4a9d20 100644
--- a/src/compiler/glsl/glsl_parser.yy
+++ b/src/compiler/glsl/glsl_parser.yy
@@ -896,7 +896,7 @@ function_header:
 
       if ($1->qualifier.is_subroutine_decl()) {
          /* add type for IDENTIFIER search */
-         state->symbols->add_type($2, glsl_type::get_subroutine_instance($2));
+         state->symbols->add_type($2, glsl_subroutine_type($2));
       } else
          state->symbols->add_function(new(state) ir_function($2));
       state->symbols->push_scope();
diff --git a/src/compiler/glsl/glsl_parser_extras.cpp b/src/compiler/glsl/glsl_parser_extras.cpp
index 0f6d303dc7ba3..afb7f439e96d9 100644
--- a/src/compiler/glsl/glsl_parser_extras.cpp
+++ b/src/compiler/glsl/glsl_parser_extras.cpp
@@ -837,7 +837,7 @@ static const char *find_extension_alias(_mesa_glsl_parse_state *state, const cha
             break;
          }
       }
-      
+
       free(exts);
    }
    return ext_alias;
@@ -854,7 +854,7 @@ static const _mesa_glsl_extension *find_extension(_mesa_glsl_parse_state *state,
       ext_alias = find_extension_alias(state, name);
       name = ext_alias ? ext_alias : name;
    }
-   
+
    for (unsigned i = 0; i < ARRAY_SIZE(_mesa_glsl_supported_extensions); ++i) {
       if (strcmp(name, _mesa_glsl_supported_extensions[i].name) == 0) {
          free((void *)ext_alias);
@@ -979,7 +979,7 @@ _mesa_glsl_can_implicitly_convert(const glsl_type *from, const glsl_type *desire
       return false;
 
    /* int and uint can be converted to float. */
-   if (desired->is_float() && from->is_integer_32())
+   if (glsl_type_is_float(desired) && glsl_type_is_integer_32(from))
       return true;
 
    /* With GLSL 4.0, ARB_gpu_shader5, or MESA_shader_integer_functions, int
@@ -993,14 +993,14 @@ _mesa_glsl_can_implicitly_convert(const glsl_type *from, const glsl_type *desire
       return true;
 
    /* No implicit conversions from double. */
-   if ((!state || state->has_double()) && from->is_double())
+   if ((!state || state->has_double()) && glsl_type_is_double(from))
       return false;
 
    /* Conversions from different types to double. */
-   if ((!state || state->has_double()) && desired->is_double()) {
-      if (from->is_float())
+   if ((!state || state->has_double()) && glsl_type_is_double(desired)) {
+      if (glsl_type_is_float(from))
          return true;
-      if (from->is_integer_32())
+      if (glsl_type_is_integer_32(from))
          return true;
    }
 
@@ -1061,7 +1061,7 @@ _mesa_ast_set_aggregate_type(const glsl_type *type,
    ai->constructor_type = type;
 
    /* If the aggregate is an array, recursively set its elements' types. */
-   if (type->is_array()) {
+   if (glsl_type_is_array(type)) {
       /* Each array element has the type type->fields.array.
        *
        * E.g., if <type> if struct S[2] we want to set each element's type to
@@ -1078,7 +1078,7 @@ _mesa_ast_set_aggregate_type(const glsl_type *type,
       }
 
    /* If the aggregate is a struct, recursively set its fields' types. */
-   } else if (type->is_struct()) {
+   } else if (glsl_type_is_struct(type)) {
       exec_node *expr_node = ai->expressions.get_head_raw();
 
       /* Iterate through the struct's fields. */
@@ -1092,7 +1092,7 @@ _mesa_ast_set_aggregate_type(const glsl_type *type,
          }
       }
    /* If the aggregate is a matrix, set its columns' types. */
-   } else if (type->is_matrix()) {
+   } else if (glsl_type_is_matrix(type)) {
       for (exec_node *expr_node = ai->expressions.get_head_raw();
            !expr_node->is_tail_sentinel();
            expr_node = expr_node->next) {
@@ -1100,7 +1100,7 @@ _mesa_ast_set_aggregate_type(const glsl_type *type,
                                                link);
 
          if (expr->oper == ast_aggregate)
-            _mesa_ast_set_aggregate_type(type->column_type(), expr);
+            _mesa_ast_set_aggregate_type(glsl_get_column_type(type), expr);
       }
    }
 }
diff --git a/src/compiler/glsl/glsl_symbol_table.cpp b/src/compiler/glsl/glsl_symbol_table.cpp
index d92b3e7b38e0a..eebc244bb255d 100644
--- a/src/compiler/glsl/glsl_symbol_table.cpp
+++ b/src/compiler/glsl/glsl_symbol_table.cpp
@@ -85,7 +85,7 @@ public:
    symbol_table_entry(const glsl_type *t, enum ir_variable_mode mode) :
       v(0), f(0), t(0), ibu(0), iss(0), ibi(0), ibo(0), a(0)
    {
-      assert(t->is_interface());
+      assert(glsl_type_is_interface(t));
       add_interface(t, mode);
    }
    symbol_table_entry(const class ast_type_specifier *a):
@@ -175,7 +175,7 @@ bool glsl_symbol_table::add_type(const char *name, const glsl_type *t)
 bool glsl_symbol_table::add_interface(const char *name, const glsl_type *i,
                                       enum ir_variable_mode mode)
 {
-   assert(i->is_interface());
+   assert(glsl_type_is_interface(i));
    symbol_table_entry *entry = get_entry(name);
    if (entry == NULL) {
       symbol_table_entry *entry =
diff --git a/src/compiler/glsl/glsl_to_nir.cpp b/src/compiler/glsl/glsl_to_nir.cpp
index 8ea81fcb132dc..049c9b1c0ab67 100644
--- a/src/compiler/glsl/glsl_to_nir.cpp
+++ b/src/compiler/glsl/glsl_to_nir.cpp
@@ -199,14 +199,14 @@ public:
           * We have no way to handle this in NIR or the glsl to nir pass
           * currently so let the GLSL IR lowering handle it.
           */
-         if (param->type->contains_opaque()) {
+         if (glsl_contains_opaque(param->type)) {
             unsupported = true;
             return visit_stop;
          }
       }
 
       if (!glsl_type_is_vector_or_scalar(ir->return_type) &&
-          !ir->return_type->is_void()) {
+          !glsl_type_is_void(ir->return_type)) {
          unsupported = true;
          return visit_stop;
       }
@@ -485,7 +485,7 @@ void
 nir_visitor::adjust_sparse_variable(nir_deref_instr *var_deref, const glsl_type *type,
                                     nir_def *dest)
 {
-   const glsl_type *texel_type = type->field_type("texel");
+   const glsl_type *texel_type = glsl_get_field_type(type, "texel");
    assert(texel_type);
 
    assert(var_deref->deref_type == nir_deref_type_var);
@@ -495,8 +495,8 @@ nir_visitor::adjust_sparse_variable(nir_deref_instr *var_deref, const glsl_type
     * Because the nir_variable is created with struct type from ir_variable,
     * but sparse nir instructions output with vector dest.
     */
-   var->type = glsl_type::get_instance(texel_type->get_base_type()->base_type,
-                                       dest->num_components, 1);
+   var->type = glsl_simple_type(glsl_get_base_glsl_type(texel_type)->base_type,
+                                dest->num_components, 1);
 
    var_deref->type = var->type;
 
@@ -582,7 +582,7 @@ nir_visitor::visit(ir_variable *ir)
    case ir_var_uniform:
       if (ir->get_interface_type())
          var->data.mode = nir_var_mem_ubo;
-      else if (ir->type->contains_image() && !ir->data.bindless)
+      else if (glsl_type_contains_image(ir->type) && !ir->data.bindless)
          var->data.mode = nir_var_image;
       else
          var->data.mode = nir_var_uniform;
@@ -621,11 +621,11 @@ nir_visitor::visit(ir_variable *ir)
    /* For UBO and SSBO variables, we need explicit types */
    if (var->data.mode & (nir_var_mem_ubo | nir_var_mem_ssbo)) {
       const glsl_type *explicit_ifc_type =
-         ir->get_interface_type()->get_explicit_interface_type(supports_std430);
+         glsl_get_explicit_interface_type(ir->get_interface_type(), supports_std430);
 
       var->interface_type = explicit_ifc_type;
 
-      if (ir->type->without_array()->is_interface()) {
+      if (glsl_type_is_interface(glsl_without_array(ir->type))) {
          /* If the type contains the interface, wrap the explicit type in the
           * right number of arrays.
           */
@@ -690,7 +690,7 @@ nir_visitor::visit(ir_variable *ir)
    var->data.offset = ir->data.offset;
    var->data.access = (gl_access_qualifier)mem_access;
 
-   if (var->type->without_array()->is_image()) {
+   if (glsl_type_is_image(glsl_without_array(var->type))) {
       var->data.image.format = ir->data.image_format;
    } else if (var->data.mode == nir_var_shader_out) {
       var->data.xfb.buffer = ir->data.xfb_buffer;
@@ -765,7 +765,7 @@ nir_visitor::create_function(ir_function_signature *ir)
 
    foreach_in_list(ir_variable, param, &ir->parameters) {
       /* FINISHME: pass arrays, structs, etc by reference? */
-      assert(param->type->is_vector() || param->type->is_scalar());
+      assert(glsl_type_is_vector(param->type) || glsl_type_is_scalar(param->type));
 
       if (param->data.mode == ir_var_function_in) {
          func->params[np].num_components = param->type->vector_elements;
@@ -922,7 +922,7 @@ nir_visitor::visit(ir_return *ir)
 static void
 intrinsic_set_std430_align(nir_intrinsic_instr *intrin, const glsl_type *type)
 {
-   unsigned bit_size = type->is_boolean() ? 32 : glsl_get_bit_size(type);
+   unsigned bit_size = glsl_type_is_boolean(type) ? 32 : glsl_get_bit_size(type);
    unsigned pow2_components = util_next_power_of_two(type->vector_elements);
    nir_intrinsic_set_align(intrin, (bit_size / 8) * pow2_components, 0);
 }
@@ -943,7 +943,7 @@ deref_get_qualifier(nir_deref_instr *deref)
    for (nir_deref_instr **cur_ptr = &path.path[1]; *cur_ptr; cur_ptr++) {
       nir_deref_instr *cur = *cur_ptr;
 
-      if (parent_type->is_interface()) {
+      if (glsl_type_is_interface(parent_type)) {
          const struct glsl_struct_field *field =
             &parent_type->fields.structure[cur->strct.index];
          if (field->memory_read_only)
@@ -978,7 +978,7 @@ nir_visitor::visit(ir_call *ir)
       switch (ir->callee->intrinsic_id) {
       case ir_intrinsic_generic_atomic_add:
          op = nir_intrinsic_deref_atomic;
-         atomic_op = ir->return_deref->type->is_integer_32_64()
+         atomic_op = glsl_type_is_integer_32_64(ir->return_deref->type)
             ? nir_atomic_op_iadd : nir_atomic_op_fadd;
          break;
       case ir_intrinsic_generic_atomic_and:
@@ -1027,7 +1027,7 @@ nir_visitor::visit(ir_call *ir)
          break;
       case ir_intrinsic_generic_atomic_comp_swap:
          op = nir_intrinsic_deref_atomic_swap;
-         atomic_op = ir->return_deref->type->is_integer_32_64()
+         atomic_op = glsl_type_is_integer_32_64(ir->return_deref->type)
             ? nir_atomic_op_cmpxchg
             : nir_atomic_op_fcmpxchg;
          break;
@@ -1072,7 +1072,7 @@ nir_visitor::visit(ir_call *ir)
          break;
       case ir_intrinsic_image_atomic_add:
          op = nir_intrinsic_image_deref_atomic;
-         atomic_op = ir->return_deref->type->is_integer_32_64()
+         atomic_op = glsl_type_is_integer_32_64(ir->return_deref->type)
             ? nir_atomic_op_iadd
             : nir_atomic_op_fadd;
          break;
@@ -1222,7 +1222,7 @@ nir_visitor::visit(ir_call *ir)
 
          /* Atomic result */
          assert(ir->return_deref);
-         if (ir->return_deref->type->is_integer_64()) {
+         if (glsl_type_is_integer_64(ir->return_deref->type)) {
             nir_def_init(&instr->instr, &instr->def,
                          ir->return_deref->type->vector_elements, 64);
          } else {
@@ -1302,7 +1302,7 @@ nir_visitor::visit(ir_call *ir)
             unsigned num_components;
             if (op == nir_intrinsic_image_deref_sparse_load) {
                const glsl_type *dest_type =
-                  ir->return_deref->type->field_type("texel");
+                  glsl_get_field_type(ir->return_deref->type, "texel");
                /* One extra component to hold residency code. */
                num_components = dest_type->vector_elements + 1;
             } else
@@ -1343,7 +1343,7 @@ nir_visitor::visit(ir_call *ir)
          nir_def *srcs[4];
 
          for (int i = 0; i < 4; i++) {
-            if (i < type->coordinate_components())
+            if (i < glsl_get_sampler_coordinate_components(type))
                srcs[i] = nir_channel(&b, src_addr, i);
             else
                srcs[i] = nir_undef(&b, 1, 32);
@@ -1466,7 +1466,7 @@ nir_visitor::visit(ir_call *ir)
          assert(write_mask);
 
          nir_def *nir_val = evaluate_rvalue(val);
-         if (val->type->is_boolean())
+         if (glsl_type_is_boolean(val->type))
             nir_val = nir_b2i32(&b, nir_val);
 
          instr->src[0] = nir_src_for_ssa(nir_val);
@@ -1491,14 +1491,14 @@ nir_visitor::visit(ir_call *ir)
          intrinsic_set_std430_align(instr, type);
 
          /* Setup destination register */
-         unsigned bit_size = type->is_boolean() ? 32 : glsl_get_bit_size(type);
+         unsigned bit_size = glsl_type_is_boolean(type) ? 32 : glsl_get_bit_size(type);
          nir_def_init(&instr->instr, &instr->def, type->vector_elements,
                       bit_size);
 
          nir_builder_instr_insert(&b, &instr->instr);
 
          /* The value in shared memory is a 32-bit value */
-         if (type->is_boolean())
+         if (glsl_type_is_boolean(type))
             ret = nir_b2b1(&b, &instr->def);
          break;
       }
@@ -1520,7 +1520,7 @@ nir_visitor::visit(ir_call *ir)
 
          nir_def *nir_val = evaluate_rvalue(val);
          /* The value in shared memory is a 32-bit value */
-         if (val->type->is_boolean())
+         if (glsl_type_is_boolean(val->type))
             nir_val = nir_b2b32(&b, nir_val);
 
          instr->src[0] = nir_src_for_ssa(nir_val);
@@ -1697,7 +1697,7 @@ nir_visitor::visit(ir_assignment *ir)
    bool is_sparse = tex && tex->is_sparse;
 
    if (!is_sparse)
-      assert(ir->rhs->type->is_scalar() || ir->rhs->type->is_vector());
+      assert(glsl_type_is_scalar(ir->rhs->type) || glsl_type_is_vector(ir->rhs->type));
 
    ir->lhs->accept(this);
    nir_deref_instr *lhs_deref = this->deref;
@@ -2316,7 +2316,7 @@ nir_visitor::visit(ir_expression *ir)
       result = nir_bcsel(&b, srcs[0], srcs[1], srcs[2]);
       break;
    case ir_triop_bitfield_extract:
-      result = ir->type->is_int_16_32() ?
+      result = glsl_type_is_int_16_32(ir->type) ?
          nir_ibitfield_extract(&b, nir_i2i32(&b, srcs[0]), nir_i2i32(&b, srcs[1]), nir_i2i32(&b, srcs[2])) :
          nir_ubitfield_extract(&b, nir_u2u32(&b, srcs[0]), nir_i2i32(&b, srcs[1]), nir_i2i32(&b, srcs[2]));
 
@@ -2438,7 +2438,7 @@ nir_visitor::visit(ir_texture *ir)
    if (ir->shadow_comparator != NULL)
       num_srcs++;
    /* offsets are constants we store inside nir_tex_intrs.offsets */
-   if (ir->offset != NULL && !ir->offset->type->is_array())
+   if (ir->offset != NULL && !glsl_type_is_array(ir->offset->type))
       num_srcs++;
    if (ir->clamp != NULL)
       num_srcs++;
@@ -2455,7 +2455,7 @@ nir_visitor::visit(ir_texture *ir)
    instr->is_shadow = ir->sampler->type->sampler_shadow;
 
    const glsl_type *dest_type
-      = ir->is_sparse ? ir->type->field_type("texel") : ir->type;
+      = ir->is_sparse ? glsl_get_field_type(ir->type, "texel") : ir->type;
    assert(dest_type != &glsl_type_builtin_error);
    if (instr->is_shadow)
       instr->is_new_style_shadow = (dest_type->vector_elements == 1);
@@ -2499,8 +2499,8 @@ nir_visitor::visit(ir_texture *ir)
    }
 
    if (ir->offset != NULL) {
-      if (ir->offset->type->is_array()) {
-         for (int i = 0; i < ir->offset->type->array_size(); i++) {
+      if (glsl_type_is_array(ir->offset->type)) {
+         for (int i = 0; i < glsl_array_size(ir->offset->type); i++) {
             const ir_constant *c =
                ir->offset->as_constant()->get_array_element(i);
 
@@ -2510,7 +2510,7 @@ nir_visitor::visit(ir_texture *ir)
             }
          }
       } else {
-         assert(ir->offset->type->is_vector() || ir->offset->type->is_scalar());
+         assert(glsl_type_is_vector(ir->offset->type) || glsl_type_is_scalar(ir->offset->type));
 
          instr->src[src_number] = nir_tex_src_for_ssa(nir_tex_src_offset,
                                                       evaluate_rvalue(ir->offset));
@@ -2633,11 +2633,11 @@ nir_visitor::visit(ir_dereference_record *ir)
 
       nir_def *ssa;
       const glsl_type *type = ir->record->type;
-      if (field_index == type->field_index("code")) {
+      if (field_index == glsl_get_field_index(type, "code")) {
          /* last channel holds residency code */
          ssa = nir_channel(&b, load, load->num_components - 1);
       } else {
-         assert(field_index == type->field_index("texel"));
+         assert(field_index == glsl_get_field_index(type, "texel"));
 
          unsigned mask = BITFIELD_MASK(load->num_components - 1);
          ssa = nir_channels(&b, load, mask);
diff --git a/src/compiler/glsl/hir_field_selection.cpp b/src/compiler/glsl/hir_field_selection.cpp
index cb499d43b067b..5c64153a75b98 100644
--- a/src/compiler/glsl/hir_field_selection.cpp
+++ b/src/compiler/glsl/hir_field_selection.cpp
@@ -44,19 +44,19 @@ _mesa_ast_field_selection_to_hir(const ast_expression *expr,
     * being applied.
     */
    YYLTYPE loc = expr->get_location();
-   if (op->type->is_error()) {
+   if (glsl_type_is_error(op->type)) {
       /* silently propagate the error */
-   } else if (op->type->is_struct() || op->type->is_interface()) {
+   } else if (glsl_type_is_struct(op->type) || glsl_type_is_interface(op->type)) {
       result = new(ctx) ir_dereference_record(op,
 					      expr->primary_expression.identifier);
 
-      if (result->type->is_error()) {
+      if (glsl_type_is_error(result->type)) {
 	 _mesa_glsl_error(& loc, state, "cannot access field `%s' of "
 			  "structure",
 			  expr->primary_expression.identifier);
       }
-   } else if (op->type->is_vector() ||
-              (state->has_420pack() && op->type->is_scalar())) {
+   } else if (glsl_type_is_vector(op->type) ||
+              (state->has_420pack() && glsl_type_is_scalar(op->type))) {
       ir_swizzle *swiz = ir_swizzle::create(op,
 					    expr->primary_expression.identifier,
 					    op->type->vector_elements);
diff --git a/src/compiler/glsl/ir.cpp b/src/compiler/glsl/ir.cpp
index f378f0bd0314d..fa7a4321b01ec 100644
--- a/src/compiler/glsl/ir.cpp
+++ b/src/compiler/glsl/ir.cpp
@@ -133,10 +133,10 @@ ir_assignment::whole_variable_written()
    if (v == NULL)
       return NULL;
 
-   if (v->type->is_scalar())
+   if (glsl_type_is_scalar(v->type))
       return v;
 
-   if (v->type->is_vector()) {
+   if (glsl_type_is_vector(v->type)) {
       const unsigned mask = (1U << v->type->vector_elements) - 1;
 
       if (mask != this->write_mask)
@@ -157,7 +157,7 @@ ir_assignment::ir_assignment(ir_dereference *lhs, ir_rvalue *rhs,
    this->lhs = lhs;
    this->write_mask = write_mask;
 
-   if (lhs->type->is_scalar() || lhs->type->is_vector())
+   if (glsl_type_is_scalar(lhs->type) || glsl_type_is_vector(lhs->type))
       assert(util_bitcount(write_mask) == this->rhs->type->vector_elements);
 }
 
@@ -173,9 +173,9 @@ ir_assignment::ir_assignment(ir_rvalue *lhs, ir_rvalue *rhs)
     *
     *     (assign (...) (xyz) (var_ref lhs) (var_ref rhs))
     */
-   if (rhs->type->is_vector())
+   if (glsl_type_is_vector(rhs->type))
       this->write_mask = (1U << rhs->type->vector_elements) - 1;
-   else if (rhs->type->is_scalar())
+   else if (glsl_type_is_scalar(rhs->type))
       this->write_mask = 1;
    else
       this->write_mask = 0;
@@ -266,8 +266,7 @@ ir_expression::ir_expression(int op, ir_rvalue *op0)
    case ir_unop_subroutine_to_int:
    case ir_unop_i642i:
    case ir_unop_u642i:
-      this->type = glsl_type::get_instance(GLSL_TYPE_INT,
-					   op0->type->vector_elements, 1);
+      this->type = glsl_simple_type(GLSL_TYPE_INT, op0->type->vector_elements, 1);
       break;
 
    case ir_unop_b2f:
@@ -279,47 +278,39 @@ ir_expression::ir_expression(int op, ir_rvalue *op0)
    case ir_unop_bitcast_u2f:
    case ir_unop_i642f:
    case ir_unop_u642f:
-      this->type = glsl_type::get_instance(GLSL_TYPE_FLOAT,
-					   op0->type->vector_elements, 1);
+      this->type = glsl_simple_type(GLSL_TYPE_FLOAT, op0->type->vector_elements, 1);
       break;
 
    case ir_unop_f2f16:
    case ir_unop_f2fmp:
    case ir_unop_b2f16:
-      this->type = glsl_type::get_instance(GLSL_TYPE_FLOAT16,
-					   op0->type->vector_elements, 1);
+      this->type = glsl_simple_type(GLSL_TYPE_FLOAT16, op0->type->vector_elements, 1);
       break;
 
    case ir_unop_i2imp:
-      this->type = glsl_type::get_instance(GLSL_TYPE_INT16,
-					   op0->type->vector_elements, 1);
+      this->type = glsl_simple_type(GLSL_TYPE_INT16, op0->type->vector_elements, 1);
       break;
 
    case ir_unop_i2i:
       if (op0->type->base_type == GLSL_TYPE_INT) {
-         this->type = glsl_type::get_instance(GLSL_TYPE_INT16,
-                                              op0->type->vector_elements, 1);
+         this->type = glsl_simple_type(GLSL_TYPE_INT16, op0->type->vector_elements, 1);
       } else {
          assert(op0->type->base_type == GLSL_TYPE_INT16);
-         this->type = glsl_type::get_instance(GLSL_TYPE_INT,
-                                              op0->type->vector_elements, 1);
+         this->type = glsl_simple_type(GLSL_TYPE_INT, op0->type->vector_elements, 1);
       }
       break;
 
    case ir_unop_u2u:
       if (op0->type->base_type == GLSL_TYPE_UINT) {
-         this->type = glsl_type::get_instance(GLSL_TYPE_UINT16,
-                                              op0->type->vector_elements, 1);
+         this->type = glsl_simple_type(GLSL_TYPE_UINT16, op0->type->vector_elements, 1);
       } else {
          assert(op0->type->base_type == GLSL_TYPE_UINT16);
-         this->type = glsl_type::get_instance(GLSL_TYPE_UINT,
-                                              op0->type->vector_elements, 1);
+         this->type = glsl_simple_type(GLSL_TYPE_UINT, op0->type->vector_elements, 1);
       }
       break;
 
    case ir_unop_u2ump:
-      this->type = glsl_type::get_instance(GLSL_TYPE_UINT16,
-					   op0->type->vector_elements, 1);
+      this->type = glsl_simple_type(GLSL_TYPE_UINT16, op0->type->vector_elements, 1);
       break;
 
    case ir_unop_f2b:
@@ -327,8 +318,7 @@ ir_expression::ir_expression(int op, ir_rvalue *op0)
    case ir_unop_d2b:
    case ir_unop_f162b:
    case ir_unop_i642b:
-      this->type = glsl_type::get_instance(GLSL_TYPE_BOOL,
-					   op0->type->vector_elements, 1);
+      this->type = glsl_simple_type(GLSL_TYPE_BOOL, op0->type->vector_elements, 1);
       break;
 
    case ir_unop_f2d:
@@ -336,8 +326,7 @@ ir_expression::ir_expression(int op, ir_rvalue *op0)
    case ir_unop_u2d:
    case ir_unop_i642d:
    case ir_unop_u642d:
-      this->type = glsl_type::get_instance(GLSL_TYPE_DOUBLE,
-					   op0->type->vector_elements, 1);
+      this->type = glsl_simple_type(GLSL_TYPE_DOUBLE, op0->type->vector_elements, 1);
       break;
 
    case ir_unop_i2u:
@@ -346,8 +335,7 @@ ir_expression::ir_expression(int op, ir_rvalue *op0)
    case ir_unop_bitcast_f2u:
    case ir_unop_i642u:
    case ir_unop_u642u:
-      this->type = glsl_type::get_instance(GLSL_TYPE_UINT,
-					   op0->type->vector_elements, 1);
+      this->type = glsl_simple_type(GLSL_TYPE_UINT, op0->type->vector_elements, 1);
       break;
 
    case ir_unop_i2i64:
@@ -356,8 +344,7 @@ ir_expression::ir_expression(int op, ir_rvalue *op0)
    case ir_unop_f2i64:
    case ir_unop_d2i64:
    case ir_unop_u642i64:
-      this->type = glsl_type::get_instance(GLSL_TYPE_INT64,
-					   op0->type->vector_elements, 1);
+      this->type = glsl_simple_type(GLSL_TYPE_INT64, op0->type->vector_elements, 1);
       break;
 
    case ir_unop_i2u64:
@@ -365,8 +352,7 @@ ir_expression::ir_expression(int op, ir_rvalue *op0)
    case ir_unop_f2u64:
    case ir_unop_d2u64:
    case ir_unop_i642u64:
-      this->type = glsl_type::get_instance(GLSL_TYPE_UINT64,
-					   op0->type->vector_elements, 1);
+      this->type = glsl_simple_type(GLSL_TYPE_UINT64, op0->type->vector_elements, 1);
       break;
 
    case ir_unop_unpack_double_2x32:
@@ -423,8 +409,7 @@ ir_expression::ir_expression(int op, ir_rvalue *op0)
       this->type = op0->type;
       break;
    case ir_unop_frexp_exp:
-      this->type = glsl_type::get_instance(GLSL_TYPE_INT,
-					   op0->type->vector_elements, 1);
+      this->type = glsl_simple_type(GLSL_TYPE_INT, op0->type->vector_elements, 1);
       break;
 
    case ir_unop_get_buffer_size:
@@ -435,17 +420,14 @@ ir_expression::ir_expression(int op, ir_rvalue *op0)
 
    case ir_unop_bitcast_i642d:
    case ir_unop_bitcast_u642d:
-      this->type = glsl_type::get_instance(GLSL_TYPE_DOUBLE,
-                                           op0->type->vector_elements, 1);
+      this->type = glsl_simple_type(GLSL_TYPE_DOUBLE, op0->type->vector_elements, 1);
       break;
 
    case ir_unop_bitcast_d2i64:
-      this->type = glsl_type::get_instance(GLSL_TYPE_INT64,
-                                           op0->type->vector_elements, 1);
+      this->type = glsl_simple_type(GLSL_TYPE_INT64, op0->type->vector_elements, 1);
       break;
    case ir_unop_bitcast_d2u64:
-      this->type = glsl_type::get_instance(GLSL_TYPE_UINT64,
-                                           op0->type->vector_elements, 1);
+      this->type = glsl_simple_type(GLSL_TYPE_UINT64, op0->type->vector_elements, 1);
       break;
 
    default:
@@ -486,13 +468,13 @@ ir_expression::ir_expression(int op, ir_rvalue *op0, ir_rvalue *op1)
    case ir_binop_div:
    case ir_binop_mod:
    case ir_binop_atan2:
-      if (op0->type->is_scalar()) {
+      if (glsl_type_is_scalar(op0->type)) {
 	 this->type = op1->type;
-      } else if (op1->type->is_scalar()) {
+      } else if (glsl_type_is_scalar(op1->type)) {
 	 this->type = op0->type;
       } else {
          if (this->operation == ir_binop_mul) {
-            this->type = glsl_type::get_mul_type(op0->type, op1->type);
+            this->type = glsl_get_mul_type(op0->type, op1->type);
          } else {
             assert(op0->type == op1->type);
             this->type = op0->type;
@@ -506,11 +488,11 @@ ir_expression::ir_expression(int op, ir_rvalue *op0, ir_rvalue *op1)
    case ir_binop_bit_and:
    case ir_binop_bit_xor:
    case ir_binop_bit_or:
-       assert(!op0->type->is_matrix());
-       assert(!op1->type->is_matrix());
-      if (op0->type->is_scalar()) {
+       assert(!glsl_type_is_matrix(op0->type));
+       assert(!glsl_type_is_matrix(op1->type));
+      if (glsl_type_is_scalar(op0->type)) {
          this->type = op1->type;
-      } else if (op1->type->is_scalar()) {
+      } else if (glsl_type_is_scalar(op1->type)) {
          this->type = op0->type;
       } else {
           assert(op0->type->vector_elements == op1->type->vector_elements);
@@ -523,12 +505,11 @@ ir_expression::ir_expression(int op, ir_rvalue *op0, ir_rvalue *op1)
    case ir_binop_gequal:
    case ir_binop_less:
       assert(op0->type == op1->type);
-      this->type = glsl_type::get_instance(GLSL_TYPE_BOOL,
-					   op0->type->vector_elements, 1);
+      this->type = glsl_simple_type(GLSL_TYPE_BOOL, op0->type->vector_elements, 1);
       break;
 
    case ir_binop_dot:
-      this->type = op0->type->get_base_type();
+      this->type = glsl_get_base_glsl_type(op0->type);
       break;
 
    case ir_binop_imul_high:
@@ -577,12 +558,12 @@ ir_expression::ir_expression(int op, ir_rvalue *op0, ir_rvalue *op1)
          unreachable("Invalid base type.");
       }
 
-      this->type = glsl_type::get_instance(base, op0->type->vector_elements, 1);
+      this->type = glsl_simple_type(base, op0->type->vector_elements, 1);
       break;
    }
 
    case ir_binop_vector_extract:
-      this->type = op0->type->get_scalar_type();
+      this->type = glsl_get_scalar_type(op0->type);
       break;
 
    default:
@@ -718,7 +699,7 @@ ir_constant::ir_constant(float16_t f16, unsigned vector_elements)
 {
    this->const_elements = NULL;
    assert(vector_elements <= 4);
-   this->type = glsl_type::get_instance(GLSL_TYPE_FLOAT16, vector_elements, 1);
+   this->type = glsl_simple_type(GLSL_TYPE_FLOAT16, vector_elements, 1);
    for (unsigned i = 0; i < vector_elements; i++) {
       this->value.f16[i] = f16.bits;
    }
@@ -732,7 +713,7 @@ ir_constant::ir_constant(float f, unsigned vector_elements)
 {
    this->const_elements = NULL;
    assert(vector_elements <= 4);
-   this->type = glsl_type::get_instance(GLSL_TYPE_FLOAT, vector_elements, 1);
+   this->type = glsl_simple_type(GLSL_TYPE_FLOAT, vector_elements, 1);
    for (unsigned i = 0; i < vector_elements; i++) {
       this->value.f[i] = f;
    }
@@ -746,7 +727,7 @@ ir_constant::ir_constant(double d, unsigned vector_elements)
 {
    this->const_elements = NULL;
    assert(vector_elements <= 4);
-   this->type = glsl_type::get_instance(GLSL_TYPE_DOUBLE, vector_elements, 1);
+   this->type = glsl_simple_type(GLSL_TYPE_DOUBLE, vector_elements, 1);
    for (unsigned i = 0; i < vector_elements; i++) {
       this->value.d[i] = d;
    }
@@ -760,7 +741,7 @@ ir_constant::ir_constant(int16_t i16, unsigned vector_elements)
 {
    this->const_elements = NULL;
    assert(vector_elements <= 4);
-   this->type = glsl_type::get_instance(GLSL_TYPE_INT16, vector_elements, 1);
+   this->type = glsl_simple_type(GLSL_TYPE_INT16, vector_elements, 1);
    for (unsigned i = 0; i < vector_elements; i++) {
       this->value.i16[i] = i16;
    }
@@ -774,7 +755,7 @@ ir_constant::ir_constant(uint16_t u16, unsigned vector_elements)
 {
    this->const_elements = NULL;
    assert(vector_elements <= 4);
-   this->type = glsl_type::get_instance(GLSL_TYPE_UINT16, vector_elements, 1);
+   this->type = glsl_simple_type(GLSL_TYPE_UINT16, vector_elements, 1);
    for (unsigned i = 0; i < vector_elements; i++) {
       this->value.u16[i] = u16;
    }
@@ -788,7 +769,7 @@ ir_constant::ir_constant(unsigned int u, unsigned vector_elements)
 {
    this->const_elements = NULL;
    assert(vector_elements <= 4);
-   this->type = glsl_type::get_instance(GLSL_TYPE_UINT, vector_elements, 1);
+   this->type = glsl_simple_type(GLSL_TYPE_UINT, vector_elements, 1);
    for (unsigned i = 0; i < vector_elements; i++) {
       this->value.u[i] = u;
    }
@@ -802,7 +783,7 @@ ir_constant::ir_constant(int integer, unsigned vector_elements)
 {
    this->const_elements = NULL;
    assert(vector_elements <= 4);
-   this->type = glsl_type::get_instance(GLSL_TYPE_INT, vector_elements, 1);
+   this->type = glsl_simple_type(GLSL_TYPE_INT, vector_elements, 1);
    for (unsigned i = 0; i < vector_elements; i++) {
       this->value.i[i] = integer;
    }
@@ -816,7 +797,7 @@ ir_constant::ir_constant(uint64_t u64, unsigned vector_elements)
 {
    this->const_elements = NULL;
    assert(vector_elements <= 4);
-   this->type = glsl_type::get_instance(GLSL_TYPE_UINT64, vector_elements, 1);
+   this->type = glsl_simple_type(GLSL_TYPE_UINT64, vector_elements, 1);
    for (unsigned i = 0; i < vector_elements; i++) {
       this->value.u64[i] = u64;
    }
@@ -830,7 +811,7 @@ ir_constant::ir_constant(int64_t int64, unsigned vector_elements)
 {
    this->const_elements = NULL;
    assert(vector_elements <= 4);
-   this->type = glsl_type::get_instance(GLSL_TYPE_INT64, vector_elements, 1);
+   this->type = glsl_simple_type(GLSL_TYPE_INT64, vector_elements, 1);
    for (unsigned i = 0; i < vector_elements; i++) {
       this->value.i64[i] = int64;
    }
@@ -844,7 +825,7 @@ ir_constant::ir_constant(bool b, unsigned vector_elements)
 {
    this->const_elements = NULL;
    assert(vector_elements <= 4);
-   this->type = glsl_type::get_instance(GLSL_TYPE_BOOL, vector_elements, 1);
+   this->type = glsl_simple_type(GLSL_TYPE_BOOL, vector_elements, 1);
    for (unsigned i = 0; i < vector_elements; i++) {
       this->value.b[i] = b;
    }
@@ -857,7 +838,7 @@ ir_constant::ir_constant(const ir_constant *c, unsigned i)
    : ir_rvalue(ir_type_constant)
 {
    this->const_elements = NULL;
-   this->type = c->type->get_base_type();
+   this->type = glsl_get_base_glsl_type(c->type);
 
    /* Section 5.11 (Out-of-Bounds Accesses) of the GLSL 4.60 spec says:
     *
@@ -892,15 +873,15 @@ ir_constant::ir_constant(const struct glsl_type *type, exec_list *value_list)
    this->const_elements = NULL;
    this->type = type;
 
-   assert(type->is_scalar() || type->is_vector() || type->is_matrix()
-	  || type->is_struct() || type->is_array());
+   assert(glsl_type_is_scalar(type) || glsl_type_is_vector(type) || glsl_type_is_matrix(type)
+	  || glsl_type_is_struct(type) || glsl_type_is_array(type));
 
    /* If the constant is a record, the types of each of the entries in
     * value_list must be a 1-for-1 match with the structure components.  Each
     * entry must also be a constant.  Just move the nodes from the value_list
     * to the list in the ir_constant.
     */
-   if (type->is_array() || type->is_struct()) {
+   if (glsl_type_is_array(type) || glsl_type_is_struct(type)) {
       this->const_elements = ralloc_array(this, ir_constant *, type->length);
       unsigned i = 0;
       foreach_in_list(ir_constant, value, value_list) {
@@ -922,8 +903,8 @@ ir_constant::ir_constant(const struct glsl_type *type, exec_list *value_list)
     * the components.  For matrices, the scalar fills the components of the
     * diagonal while the rest is filled with 0.
     */
-   if (value->type->is_scalar() && value->next->is_tail_sentinel()) {
-      if (type->is_matrix()) {
+   if (glsl_type_is_scalar(value->type) && value->next->is_tail_sentinel()) {
+      if (glsl_type_is_matrix(type)) {
 	 /* Matrix - fill diagonal (rest is already set to 0) */
          for (unsigned i = 0; i < type->matrix_columns; i++) {
             switch (type->base_type) {
@@ -948,33 +929,33 @@ ir_constant::ir_constant(const struct glsl_type *type, exec_list *value_list)
 	 switch (type->base_type) {
          case GLSL_TYPE_UINT16:
 	 case GLSL_TYPE_INT16:
-	    for (unsigned i = 0; i < type->components(); i++)
+	    for (unsigned i = 0; i < glsl_get_components(type); i++)
 	       this->value.u16[i] = value->value.u16[0];
 	    break;
 	 case GLSL_TYPE_UINT:
 	 case GLSL_TYPE_INT:
-	    for (unsigned i = 0; i < type->components(); i++)
+	    for (unsigned i = 0; i < glsl_get_components(type); i++)
 	       this->value.u[i] = value->value.u[0];
 	    break;
 	 case GLSL_TYPE_FLOAT:
-	    for (unsigned i = 0; i < type->components(); i++)
+	    for (unsigned i = 0; i < glsl_get_components(type); i++)
 	       this->value.f[i] = value->value.f[0];
 	    break;
 	 case GLSL_TYPE_FLOAT16:
-	    for (unsigned i = 0; i < type->components(); i++)
+	    for (unsigned i = 0; i < glsl_get_components(type); i++)
 	       this->value.f16[i] = value->value.f16[0];
 	    break;
 	 case GLSL_TYPE_DOUBLE:
-	    for (unsigned i = 0; i < type->components(); i++)
+	    for (unsigned i = 0; i < glsl_get_components(type); i++)
 	       this->value.d[i] = value->value.d[0];
 	    break;
 	 case GLSL_TYPE_UINT64:
 	 case GLSL_TYPE_INT64:
-	    for (unsigned i = 0; i < type->components(); i++)
+	    for (unsigned i = 0; i < glsl_get_components(type); i++)
 	       this->value.u64[i] = value->value.u64[0];
 	    break;
 	 case GLSL_TYPE_BOOL:
-	    for (unsigned i = 0; i < type->components(); i++)
+	    for (unsigned i = 0; i < glsl_get_components(type); i++)
 	       this->value.b[i] = value->value.b[0];
 	    break;
 	 case GLSL_TYPE_SAMPLER:
@@ -989,7 +970,7 @@ ir_constant::ir_constant(const struct glsl_type *type, exec_list *value_list)
       return;
    }
 
-   if (type->is_matrix() && value->type->is_matrix()) {
+   if (glsl_type_is_matrix(type) && glsl_type_is_matrix(value->type)) {
       assert(value->next->is_tail_sentinel());
 
       /* From section 5.4.2 of the GLSL 1.20 spec:
@@ -1022,7 +1003,7 @@ ir_constant::ir_constant(const struct glsl_type *type, exec_list *value_list)
       assert(value->as_constant() != NULL);
       assert(!value->is_tail_sentinel());
 
-      for (unsigned j = 0; j < value->type->components(); j++) {
+      for (unsigned j = 0; j < glsl_get_components(value->type); j++) {
 	 switch (type->base_type) {
          case GLSL_TYPE_UINT16:
 	    this->value.u16[i] = value->get_uint16_component(j);
@@ -1061,11 +1042,11 @@ ir_constant::ir_constant(const struct glsl_type *type, exec_list *value_list)
 	 }
 
 	 i++;
-	 if (i >= type->components())
+	 if (i >= glsl_get_components(type))
 	    break;
       }
 
-      if (i >= type->components())
+      if (i >= glsl_get_components(type))
 	 break; /* avoid downcasting a list sentinel */
       value = (ir_constant *) value->next;
    }
@@ -1074,21 +1055,21 @@ ir_constant::ir_constant(const struct glsl_type *type, exec_list *value_list)
 ir_constant *
 ir_constant::zero(void *mem_ctx, const glsl_type *type)
 {
-   assert(type->is_scalar() || type->is_vector() || type->is_matrix()
-	  || type->is_struct() || type->is_array());
+   assert(glsl_type_is_scalar(type) || glsl_type_is_vector(type) || glsl_type_is_matrix(type)
+	  || glsl_type_is_struct(type) || glsl_type_is_array(type));
 
    ir_constant *c = new(mem_ctx) ir_constant;
    c->type = type;
    memset(&c->value, 0, sizeof(c->value));
 
-   if (type->is_array()) {
+   if (glsl_type_is_array(type)) {
       c->const_elements = ralloc_array(c, ir_constant *, type->length);
 
       for (unsigned i = 0; i < type->length; i++)
 	 c->const_elements[i] = ir_constant::zero(c, type->fields.array);
    }
 
-   if (type->is_struct()) {
+   if (glsl_type_is_struct(type)) {
       c->const_elements = ralloc_array(c, ir_constant *, type->length);
 
       for (unsigned i = 0; i < type->length; i++) {
@@ -1337,7 +1318,7 @@ ir_constant::get_uint64_component(unsigned i) const
 ir_constant *
 ir_constant::get_array_element(unsigned i) const
 {
-   assert(this->type->is_array());
+   assert(glsl_type_is_array(this->type));
 
    /* From page 35 (page 41 of the PDF) of the GLSL 1.20 spec:
     *
@@ -1360,7 +1341,7 @@ ir_constant::get_array_element(unsigned i) const
 ir_constant *
 ir_constant::get_record_field(int idx)
 {
-   assert(this->type->is_struct());
+   assert(glsl_type_is_struct(this->type));
    assert(idx >= 0 && (unsigned) idx < this->type->length);
 
    return const_elements[idx];
@@ -1382,8 +1363,8 @@ ir_constant::copy_offset(ir_constant *src, int offset)
    case GLSL_TYPE_UINT64:
    case GLSL_TYPE_INT64:
    case GLSL_TYPE_BOOL: {
-      unsigned int size = src->type->components();
-      assert (size <= this->type->components() - offset);
+      unsigned int size = glsl_get_components(src->type);
+      assert (size <= glsl_get_components(this->type) - offset);
       for (unsigned int i=0; i<size; i++) {
 	 switch (this->type->base_type) {
          case GLSL_TYPE_UINT16:
@@ -1443,9 +1424,9 @@ ir_constant::copy_offset(ir_constant *src, int offset)
 void
 ir_constant::copy_masked_offset(ir_constant *src, int offset, unsigned int mask)
 {
-   assert (!type->is_array() && !type->is_struct());
+   assert (!glsl_type_is_array(type) && !glsl_type_is_struct(type));
 
-   if (!type->is_vector() && !type->is_matrix()) {
+   if (!glsl_type_is_vector(type) && !glsl_type_is_matrix(type)) {
       offset = 0;
       mask = 1;
    }
@@ -1500,7 +1481,7 @@ ir_constant::has_value(const ir_constant *c) const
    if (this->type != c->type)
       return false;
 
-   if (this->type->is_array() || this->type->is_struct()) {
+   if (glsl_type_is_array(this->type) || glsl_type_is_struct(this->type)) {
       for (unsigned i = 0; i < this->type->length; i++) {
 	 if (!this->const_elements[i]->has_value(c->const_elements[i]))
 	    return false;
@@ -1508,7 +1489,7 @@ ir_constant::has_value(const ir_constant *c) const
       return true;
    }
 
-   for (unsigned i = 0; i < this->type->components(); i++) {
+   for (unsigned i = 0; i < glsl_get_components(this->type); i++) {
       switch (this->type->base_type) {
       case GLSL_TYPE_UINT16:
 	 if (this->value.u16[i] != c->value.u16[i])
@@ -1566,11 +1547,11 @@ ir_constant::has_value(const ir_constant *c) const
 bool
 ir_constant::is_value(float f, int i) const
 {
-   if (!this->type->is_scalar() && !this->type->is_vector())
+   if (!glsl_type_is_scalar(this->type) && !glsl_type_is_vector(this->type))
       return false;
 
    /* Only accept boolean values for 0/1. */
-   if (int(bool(i)) != i && this->type->is_boolean())
+   if (int(bool(i)) != i && glsl_type_is_boolean(this->type))
       return false;
 
    for (unsigned c = 0; c < this->type->vector_elements; c++) {
@@ -1651,7 +1632,7 @@ ir_constant::is_negative_one() const
 bool
 ir_constant::is_uint16_constant() const
 {
-   if (!type->is_integer_32())
+   if (!glsl_type_is_integer_32(type))
       return false;
 
    return value.u[0] < (1 << 16);
@@ -1702,12 +1683,12 @@ ir_dereference_array::set_array(ir_rvalue *value)
 
    const glsl_type *const vt = this->array->type;
 
-   if (vt->is_array()) {
+   if (glsl_type_is_array(vt)) {
       type = vt->fields.array;
-   } else if (vt->is_matrix()) {
-      type = vt->column_type();
-   } else if (vt->is_vector()) {
-      type = vt->get_base_type();
+   } else if (glsl_type_is_matrix(vt)) {
+      type = glsl_get_column_type(vt);
+   } else if (glsl_type_is_vector(vt)) {
+      type = glsl_get_base_glsl_type(vt);
    }
 }
 
@@ -1719,8 +1700,8 @@ ir_dereference_record::ir_dereference_record(ir_rvalue *value,
    assert(value != NULL);
 
    this->record = value;
-   this->type = this->record->type->field_type(field);
-   this->field_idx = this->record->type->field_index(field);
+   this->type = glsl_get_field_type(this->record->type, field);
+   this->field_idx = glsl_get_field_index(this->record->type, field);
 }
 
 
@@ -1731,8 +1712,8 @@ ir_dereference_record::ir_dereference_record(ir_variable *var,
    void *ctx = ralloc_parent(var);
 
    this->record = new(ctx) ir_dereference_variable(var);
-   this->type = this->record->type->field_type(field);
-   this->field_idx = this->record->type->field_index(field);
+   this->type = glsl_get_field_type(this->record->type, field);
+   this->field_idx = glsl_get_field_index(this->record->type, field);
 }
 
 bool
@@ -1756,7 +1737,7 @@ ir_dereference::is_lvalue(const struct _mesa_glsl_parse_state *state) const
     *  "out" and "inout" function parameters."
     */
    if ((!state || state->has_bindless()) &&
-       (this->type->contains_sampler() || this->type->contains_image()))
+       (glsl_contains_sampler(this->type) || glsl_type_contains_image(this->type)))
       return true;
 
    /* From section 4.1.7 of the GLSL 4.40 spec:
@@ -1765,7 +1746,7 @@ ir_dereference::is_lvalue(const struct _mesa_glsl_parse_state *state) const
     *    be used as out or inout function parameters, nor can they be
     *    assigned into."
     */
-   if (this->type->contains_opaque())
+   if (glsl_contains_opaque(this->type))
       return false;
 
    return true;
@@ -1805,7 +1786,7 @@ ir_texture::set_sampler(ir_dereference *sampler, const glsl_type *type)
          glsl_struct_field(&glsl_type_builtin_int, "code"),
          glsl_struct_field(type, "texel"),
       };
-      this->type = glsl_type::get_struct_instance(fields, 2, "struct");
+      this->type = glsl_struct_type(fields, 2, "struct", false /* packed */);
    } else
       this->type = type;
 
@@ -1814,10 +1795,10 @@ ir_texture::set_sampler(ir_dereference *sampler, const glsl_type *type)
       assert(type->base_type == GLSL_TYPE_INT);
    } else if (this->op == ir_lod) {
       assert(type->vector_elements == 2);
-      assert(type->is_float());
+      assert(glsl_type_is_float(type));
    } else if (this->op == ir_samples_identical) {
       assert(type == &glsl_type_builtin_bool);
-      assert(sampler->type->is_sampler());
+      assert(glsl_type_is_sampler(sampler->type));
       assert(sampler->type->sampler_dimensionality == GLSL_SAMPLER_DIM_MS);
    } else {
       assert(sampler->type->sampled_type == (int) type->base_type);
@@ -1868,7 +1849,7 @@ ir_swizzle::init_mask(const unsigned *comp, unsigned count)
     * (i.e., float, int, unsigned, or bool) of the vector being swizzled,
     * generate the type of the resulting value.
     */
-   type = glsl_type::get_instance(val->type->base_type, mask.num_components, 1);
+   type = glsl_simple_type(val->type->base_type, mask.num_components, 1);
 }
 
 ir_swizzle::ir_swizzle(ir_rvalue *val, unsigned x, unsigned y, unsigned z,
@@ -1889,8 +1870,7 @@ ir_swizzle::ir_swizzle(ir_rvalue *val, const unsigned *comp,
 ir_swizzle::ir_swizzle(ir_rvalue *val, ir_swizzle_mask mask)
    : ir_rvalue(ir_type_swizzle), val(val), mask(mask)
 {
-   this->type = glsl_type::get_instance(val->type->base_type,
-					mask.num_components, 1);
+   this->type = glsl_simple_type(val->type->base_type, mask.num_components, 1);
 }
 
 #define X 1
@@ -2077,10 +2057,10 @@ ir_variable::ir_variable(const struct glsl_type *type, const char *name,
    this->interface_type = NULL;
 
    if (type != NULL) {
-      if (type->is_interface())
+      if (glsl_type_is_interface(type))
          this->init_interface_type(type);
-      else if (type->without_array()->is_interface())
-         this->init_interface_type(type->without_array());
+      else if (glsl_type_is_interface(glsl_without_array(type)))
+         this->init_interface_type(glsl_without_array(type));
    }
 }
 
@@ -2257,7 +2237,7 @@ steal_memory(ir_instruction *ir, void *new_ctx)
     * visitor, so steal their values by hand.
     */
    if (constant != NULL &&
-       (constant->type->is_array() || constant->type->is_struct())) {
+       (glsl_type_is_array(constant->type) || glsl_type_is_struct(constant->type))) {
       for (unsigned int i = 0; i < constant->type->length; i++) {
          steal_memory(constant->const_elements[i], ir);
       }
diff --git a/src/compiler/glsl/ir.h b/src/compiler/glsl/ir.h
index e1a5ccae538e9..68a3ab6454476 100644
--- a/src/compiler/glsl/ir.h
+++ b/src/compiler/glsl/ir.h
@@ -453,7 +453,7 @@ public:
     */
    inline bool is_interface_instance() const
    {
-      return this->type->without_array() == this->interface_type;
+      return glsl_without_array(this->type) == this->interface_type;
    }
 
    /**
@@ -461,7 +461,7 @@ public:
     */
    inline bool contains_bindless() const
    {
-      if (!this->type->contains_sampler() && !this->type->contains_image())
+      if (!glsl_contains_sampler(this->type) && !glsl_type_contains_image(this->type))
          return false;
 
       return this->data.bindless || this->data.mode != ir_var_uniform;
@@ -531,7 +531,7 @@ public:
 
    enum glsl_interface_packing get_interface_type_packing() const
    {
-     return this->interface_type->get_interface_packing();
+     return glsl_get_ifc_packing(this->interface_type);
    }
    /**
     * Get the max_ifc_array_access pointer
@@ -585,8 +585,8 @@ public:
    inline bool is_interpolation_flat() const
    {
       return this->data.interpolation == INTERP_MODE_FLAT ||
-             this->type->contains_integer() ||
-             this->type->contains_double();
+             glsl_contains_integer(this->type) ||
+             glsl_contains_double(this->type);
    }
 
    inline bool is_name_ralloced() const
diff --git a/src/compiler/glsl/ir_array_refcount.cpp b/src/compiler/glsl/ir_array_refcount.cpp
index 0c18c7e0ecf14..ba8fce6067a95 100644
--- a/src/compiler/glsl/ir_array_refcount.cpp
+++ b/src/compiler/glsl/ir_array_refcount.cpp
@@ -56,14 +56,14 @@ ir_array_refcount_visitor::~ir_array_refcount_visitor()
 ir_array_refcount_entry::ir_array_refcount_entry(ir_variable *var)
    : var(var), is_referenced(false)
 {
-   num_bits = MAX2(1, var->type->arrays_of_arrays_size());
+   num_bits = MAX2(1, glsl_get_aoa_size(var->type));
    bits = new BITSET_WORD[BITSET_WORDS(num_bits)];
    memset(bits, 0, BITSET_WORDS(num_bits) * sizeof(bits[0]));
 
    /* Count the "depth" of the arrays-of-arrays. */
    array_depth = 0;
    for (const glsl_type *type = var->type;
-        type->is_array();
+        glsl_type_is_array(type);
         type = type->fields.array) {
       array_depth++;
    }
@@ -116,7 +116,7 @@ ir_array_refcount_visitor::visit_enter(ir_dereference_array *ir)
    /* It could also be a vector or a matrix.  Individual elements of vectors
     * are natrices are not tracked, so bail.
     */
-   if (!ir->array->type->is_array())
+   if (!glsl_type_is_array(ir->array->type))
       return visit_continue;
 
    /* If this array dereference is a child of an array dereference that was
@@ -139,13 +139,13 @@ ir_array_refcount_visitor::visit_enter(ir_dereference_array *ir)
       ir_dereference_array *const deref = rv->as_dereference_array();
 
       assert(deref != NULL);
-      assert(deref->array->type->is_array());
+      assert(glsl_type_is_array(deref->array->type));
 
       ir_rvalue *const array = deref->array;
       const ir_constant *const idx = deref->array_index->as_constant();
       array_deref_range *const dr = get_array_deref();
 
-      dr->size = array->type->array_size();
+      dr->size = glsl_array_size(array->type);
 
       if (idx != NULL) {
          dr->index = idx->get_int_component(0);
@@ -153,7 +153,7 @@ ir_array_refcount_visitor::visit_enter(ir_dereference_array *ir)
          /* An unsized array can occur at the end of an SSBO.  We can't track
           * accesses to such an array, so bail.
           */
-         if (array->type->array_size() == 0)
+         if (glsl_array_size(array->type) == 0)
             return visit_continue;
 
          dr->index = dr->size;
diff --git a/src/compiler/glsl/ir_builder_print_visitor.cpp b/src/compiler/glsl/ir_builder_print_visitor.cpp
index 0d2996c0bd66a..7707dfb78d3df 100644
--- a/src/compiler/glsl/ir_builder_print_visitor.cpp
+++ b/src/compiler/glsl/ir_builder_print_visitor.cpp
@@ -313,7 +313,7 @@ ir_builder_print_visitor::visit_leave(ir_function_signature *ir)
 void
 ir_builder_print_visitor::print_without_declaration(const ir_constant *ir)
 {
-  if (ir->type->is_scalar()) {
+  if (glsl_type_is_scalar(ir->type)) {
       switch (ir->type->base_type) {
       case GLSL_TYPE_UINT:
          print_without_indent("body.constant(%uu)", ir->value.u[0]);
diff --git a/src/compiler/glsl/ir_constant_expression.cpp b/src/compiler/glsl/ir_constant_expression.cpp
index 618dda6ec5a40..25dfe7322b6f5 100644
--- a/src/compiler/glsl/ir_constant_expression.cpp
+++ b/src/compiler/glsl/ir_constant_expression.cpp
@@ -44,10 +44,10 @@
 static float
 dot_f(ir_constant *op0, ir_constant *op1)
 {
-   assert(op0->type->is_float() && op1->type->is_float());
+   assert(glsl_type_is_float(op0->type) && glsl_type_is_float(op1->type));
 
    float result = 0;
-   for (unsigned c = 0; c < op0->type->components(); c++)
+   for (unsigned c = 0; c < glsl_get_components(op0->type); c++)
       result += op0->value.f[c] * op1->value.f[c];
 
    return result;
@@ -56,10 +56,10 @@ dot_f(ir_constant *op0, ir_constant *op1)
 static double
 dot_d(ir_constant *op0, ir_constant *op1)
 {
-   assert(op0->type->is_double() && op1->type->is_double());
+   assert(glsl_type_is_double(op0->type) && glsl_type_is_double(op1->type));
 
    double result = 0;
-   for (unsigned c = 0; c < op0->type->components(); c++)
+   for (unsigned c = 0; c < glsl_get_components(op0->type); c++)
       result += op0->value.d[c] * op1->value.d[c];
 
    return result;
@@ -492,8 +492,8 @@ constant_referenced(const ir_dereference *deref,
       ir_constant *const index_c =
          da->array_index->constant_expression_value(variable_context);
 
-      if (!index_c || !index_c->type->is_scalar() ||
-          !index_c->type->is_integer_32())
+      if (!index_c || !glsl_type_is_scalar(index_c->type) ||
+          !glsl_type_is_integer_32(index_c->type))
          break;
 
       const int index = index_c->type->base_type == GLSL_TYPE_INT ?
@@ -511,13 +511,13 @@ constant_referenced(const ir_dereference *deref,
          break;
 
       const glsl_type *const vt = da->array->type;
-      if (vt->is_array()) {
+      if (glsl_type_is_array(vt)) {
          store = substore->get_array_element(index);
          offset = 0;
-      } else if (vt->is_matrix()) {
+      } else if (glsl_type_is_matrix(vt)) {
          store = substore;
          offset = index * vt->vector_elements;
-      } else if (vt->is_vector()) {
+      } else if (glsl_type_is_vector(vt)) {
          store = substore;
          offset = suboffset + index;
       }
@@ -569,7 +569,7 @@ constant_referenced(const ir_dereference *deref,
 ir_constant *
 ir_rvalue::constant_expression_value(void *, struct hash_table *)
 {
-   assert(this->type->is_error());
+   assert(glsl_type_is_error(this->type));
    return NULL;
 }
 
@@ -691,7 +691,7 @@ ir_expression::constant_expression_value(void *mem_ctx,
 {
    assert(mem_ctx);
 
-   if (this->type->is_error())
+   if (glsl_type_is_error(this->type))
       return NULL;
 
    const glsl_type *return_type = this->type;
@@ -712,11 +712,12 @@ ir_expression::constant_expression_value(void *mem_ctx,
       switch (op[operand]->type->base_type) {
       case GLSL_TYPE_FLOAT16: {
          const struct glsl_type *float_type =
-               glsl_type::get_instance(GLSL_TYPE_FLOAT,
-                                       op[operand]->type->vector_elements,
-                                       op[operand]->type->matrix_columns,
-                                       op[operand]->type->explicit_stride,
-                                       op[operand]->type->interface_row_major);
+               glsl_simple_explicit_type(GLSL_TYPE_FLOAT,
+                                         op[operand]->type->vector_elements,
+                                         op[operand]->type->matrix_columns,
+                                         op[operand]->type->explicit_stride,
+                                         op[operand]->type->interface_row_major,
+                                         0 /* explicit_alignment */);
 
          ir_constant_data f;
          for (unsigned i = 0; i < ARRAY_SIZE(f.f); i++)
@@ -727,11 +728,12 @@ ir_expression::constant_expression_value(void *mem_ctx,
       }
       case GLSL_TYPE_INT16: {
          const struct glsl_type *int_type =
-            glsl_type::get_instance(GLSL_TYPE_INT,
-                                    op[operand]->type->vector_elements,
-                                    op[operand]->type->matrix_columns,
-                                    op[operand]->type->explicit_stride,
-                                    op[operand]->type->interface_row_major);
+            glsl_simple_explicit_type(GLSL_TYPE_INT,
+                                      op[operand]->type->vector_elements,
+                                      op[operand]->type->matrix_columns,
+                                      op[operand]->type->explicit_stride,
+                                      op[operand]->type->interface_row_major,
+                                      0 /* explicit_alignment */);
 
          ir_constant_data d;
          for (unsigned i = 0; i < ARRAY_SIZE(d.i); i++)
@@ -742,11 +744,12 @@ ir_expression::constant_expression_value(void *mem_ctx,
       }
       case GLSL_TYPE_UINT16: {
          const struct glsl_type *uint_type =
-            glsl_type::get_instance(GLSL_TYPE_UINT,
-                                    op[operand]->type->vector_elements,
-                                    op[operand]->type->matrix_columns,
-                                    op[operand]->type->explicit_stride,
-                                    op[operand]->type->interface_row_major);
+            glsl_simple_explicit_type(GLSL_TYPE_UINT,
+                                      op[operand]->type->vector_elements,
+                                      op[operand]->type->matrix_columns,
+                                      op[operand]->type->explicit_stride,
+                                      op[operand]->type->interface_row_major,
+                                      0 /* explicit_alignment */);
 
          ir_constant_data d;
          for (unsigned i = 0; i < ARRAY_SIZE(d.u); i++)
@@ -763,25 +766,28 @@ ir_expression::constant_expression_value(void *mem_ctx,
 
    switch (return_type->base_type) {
    case GLSL_TYPE_FLOAT16:
-      return_type = glsl_type::get_instance(GLSL_TYPE_FLOAT,
-                                            return_type->vector_elements,
-                                            return_type->matrix_columns,
-                                            return_type->explicit_stride,
-                                            return_type->interface_row_major);
+      return_type = glsl_simple_explicit_type(GLSL_TYPE_FLOAT,
+                                              return_type->vector_elements,
+                                              return_type->matrix_columns,
+                                              return_type->explicit_stride,
+                                              return_type->interface_row_major,
+                                              0 /* explicit_alignment */);
       break;
    case GLSL_TYPE_INT16:
-      return_type = glsl_type::get_instance(GLSL_TYPE_INT,
-                                            return_type->vector_elements,
-                                            return_type->matrix_columns,
-                                            return_type->explicit_stride,
-                                            return_type->interface_row_major);
+      return_type = glsl_simple_explicit_type(GLSL_TYPE_INT,
+                                              return_type->vector_elements,
+                                              return_type->matrix_columns,
+                                              return_type->explicit_stride,
+                                              return_type->interface_row_major,
+                                              0 /* explicit_alignment */);
       break;
    case GLSL_TYPE_UINT16:
-      return_type = glsl_type::get_instance(GLSL_TYPE_UINT,
-                                            return_type->vector_elements,
-                                            return_type->matrix_columns,
-                                            return_type->explicit_stride,
-                                            return_type->interface_row_major);
+      return_type = glsl_simple_explicit_type(GLSL_TYPE_UINT,
+                                              return_type->vector_elements,
+                                              return_type->matrix_columns,
+                                              return_type->explicit_stride,
+                                              return_type->interface_row_major,
+                                              0 /* explicit_alignment */);
       break;
    default:
       /* nothing to do */
@@ -805,8 +811,8 @@ ir_expression::constant_expression_value(void *mem_ctx,
          break;
       }
 
-   bool op0_scalar = op[0]->type->is_scalar();
-   bool op1_scalar = op[1] != NULL && op[1]->type->is_scalar();
+   bool op0_scalar = glsl_type_is_scalar(op[0]->type);
+   bool op1_scalar = op[1] != NULL && glsl_type_is_scalar(op[1]->type);
 
    /* When iterating over a vector or matrix's components, we want to increase
     * the loop counter.  However, for scalars, we want to stay at 0.
@@ -815,14 +821,14 @@ ir_expression::constant_expression_value(void *mem_ctx,
    unsigned c1_inc = op1_scalar ? 0 : 1;
    unsigned components;
    if (op1_scalar || !op[1]) {
-      components = op[0]->type->components();
+      components = glsl_get_components(op[0]->type);
    } else {
-      components = op[1]->type->components();
+      components = glsl_get_components(op[1]->type);
    }
 
    /* Handle array operations here, rather than below. */
-   if (op[0]->type->is_array()) {
-      assert(op[1] != NULL && op[1]->type->is_array());
+   if (glsl_type_is_array(op[0]->type)) {
+      assert(op[1] != NULL && glsl_type_is_array(op[1]->type));
       switch (this->operation) {
       case ir_binop_all_equal:
          return new(mem_ctx) ir_constant(op[0]->has_value(op[1]));
@@ -948,12 +954,12 @@ ir_dereference_array::constant_expression_value(void *mem_ctx,
    ir_constant *idx = this->array_index->constant_expression_value(mem_ctx, variable_context);
 
    if ((array != NULL) && (idx != NULL)) {
-      if (array->type->is_matrix()) {
+      if (glsl_type_is_matrix(array->type)) {
          /* Array access of a matrix results in a vector.
           */
          const unsigned column = idx->value.u[0];
 
-         const glsl_type *const column_type = array->type->column_type();
+         const glsl_type *const column_type = glsl_get_column_type(array->type);
 
          /* Section 5.11 (Out-of-Bounds Accesses) of the GLSL 4.60 spec says:
           *
@@ -999,11 +1005,11 @@ ir_dereference_array::constant_expression_value(void *mem_ctx,
          }
 
          return new(mem_ctx) ir_constant(column_type, &data);
-      } else if (array->type->is_vector()) {
+      } else if (glsl_type_is_vector(array->type)) {
          const unsigned component = idx->value.u[0];
 
          return new(mem_ctx) ir_constant(array, component);
-      } else if (array->type->is_array()) {
+      } else if (glsl_type_is_array(array->type)) {
          const unsigned index = idx->value.u[0];
          return array->get_array_element(index)->clone(mem_ctx, NULL);
       }
@@ -1129,7 +1135,7 @@ bool ir_function_signature::constant_expression_evaluate_expression_list(void *m
          ir_constant *cond =
             iif->condition->constant_expression_value(mem_ctx,
                                                       variable_context);
-         if (!cond || !cond->type->is_boolean())
+         if (!cond || !glsl_type_is_boolean(cond->type))
             return false;
 
          exec_list &branch = cond->get_bool_component(0) ? iif->then_instructions : iif->else_instructions;
diff --git a/src/compiler/glsl/ir_equals.cpp b/src/compiler/glsl/ir_equals.cpp
index e26c7d8223338..4e8d07828a81c 100644
--- a/src/compiler/glsl/ir_equals.cpp
+++ b/src/compiler/glsl/ir_equals.cpp
@@ -57,8 +57,8 @@ ir_constant::equals(const ir_instruction *ir, enum ir_node_type) const
    if (type != other->type)
       return false;
 
-   for (unsigned i = 0; i < type->components(); i++) {
-      if (type->is_double()) {
+   for (unsigned i = 0; i < glsl_get_components(type); i++) {
+      if (glsl_type_is_double(type)) {
          if (value.d[i] != other->value.d[i])
             return false;
       } else {
diff --git a/src/compiler/glsl/ir_expression_operation.py b/src/compiler/glsl/ir_expression_operation.py
index 0b8cc0a10731e..1d9a9aec1de50 100644
--- a/src/compiler/glsl/ir_expression_operation.py
+++ b/src/compiler/glsl/ir_expression_operation.py
@@ -99,7 +99,7 @@ real_types = (float_type, double_type)
 # This is used by most operations.
 constant_template_common = mako.template.Template("""\
    case ${op.get_enum_name()}:
-      for (unsigned c = 0; c < op[0]->type->components(); c++) {
+      for (unsigned c = 0; c < glsl_get_components(op[0]->type); c++) {
          switch (op[0]->type->base_type) {
     % for dst_type, src_types in op.signatures():
          case ${src_types[0].glsl_type}:
@@ -173,7 +173,7 @@ constant_template_vector_scalar_mixed = mako.template.Template("""\
 constant_template_mul = mako.template.Template("""\
    case ${op.get_enum_name()}:
       /* Check for equal types, or unequal types involving scalars */
-      if ((op[0]->type == op[1]->type && !op[0]->type->is_matrix())
+      if ((op[0]->type == op[1]->type && !glsl_type_is_matrix(op[0]->type))
           || op0_scalar || op1_scalar) {
          for (unsigned c = 0, c0 = 0, c1 = 0;
               c < components;
@@ -190,7 +190,7 @@ constant_template_mul = mako.template.Template("""\
             }
          }
       } else {
-         assert(op[0]->type->is_matrix() || op[1]->type->is_matrix());
+         assert(glsl_type_is_matrix(op[0]->type) || glsl_type_is_matrix(op[1]->type));
 
          /* Multiply an N-by-M matrix with an M-by-P matrix.  Since either
           * matrix can be a GLSL vector, either N or P can be 1.
@@ -201,14 +201,14 @@ constant_template_mul = mako.template.Template("""\
           * For mat*vec, the vector is treated as a column vector.  Since
           * matrix_columns is 1 for vectors, this just works.
           */
-         const unsigned n = op[0]->type->is_vector()
+         const unsigned n = glsl_type_is_vector(op[0]->type)
             ? 1 : op[0]->type->vector_elements;
          const unsigned m = op[1]->type->vector_elements;
          const unsigned p = op[1]->type->matrix_columns;
          for (unsigned j = 0; j < p; j++) {
             for (unsigned i = 0; i < n; i++) {
                for (unsigned k = 0; k < m; k++) {
-                  if (op[0]->type->is_double())
+                  if (glsl_type_is_double(op[0]->type))
                      data.d[i+n*j] += op[0]->value.d[i+n*k]*op[1]->value.d[k+m*j];
                   else
                      data.f[i+n*j] += op[0]->value.f[i+n*k]*op[1]->value.f[k+m*j];
@@ -304,11 +304,11 @@ constant_template_vector = mako.template.Template("""\
 # This template is for ir_triop_lrp.
 constant_template_lrp = mako.template.Template("""\
    case ${op.get_enum_name()}: {
-      assert(op[0]->type->is_float() || op[0]->type->is_double());
-      assert(op[1]->type->is_float() || op[1]->type->is_double());
-      assert(op[2]->type->is_float() || op[2]->type->is_double());
+      assert(glsl_type_is_float(op[0]->type) || glsl_type_is_double(op[0]->type));
+      assert(glsl_type_is_float(op[1]->type) || glsl_type_is_double(op[1]->type));
+      assert(glsl_type_is_float(op[2]->type) || glsl_type_is_double(op[2]->type));
 
-      unsigned c2_inc = op[2]->type->is_scalar() ? 0 : 1;
+      unsigned c2_inc = glsl_type_is_scalar(op[2]->type) ? 0 : 1;
       for (unsigned c = 0, c2 = 0; c < components; c2 += c2_inc, c++) {
          switch (return_type->base_type) {
     % for dst_type, src_types in op.signatures():
diff --git a/src/compiler/glsl/ir_function.cpp b/src/compiler/glsl/ir_function.cpp
index 70ec0e7c8e715..82987522d6616 100644
--- a/src/compiler/glsl/ir_function.cpp
+++ b/src/compiler/glsl/ir_function.cpp
@@ -150,13 +150,13 @@ get_parameter_match_type(const ir_variable *param,
    if (from_type == to_type)
       return PARAMETER_EXACT_MATCH;
 
-   if (to_type->is_double()) {
-      if (from_type->is_float())
+   if (glsl_type_is_double(to_type)) {
+      if (glsl_type_is_float(from_type))
          return PARAMETER_FLOAT_TO_DOUBLE;
       return PARAMETER_INT_TO_DOUBLE;
    }
 
-   if (to_type->is_float())
+   if (glsl_type_is_float(to_type))
       return PARAMETER_INT_TO_FLOAT;
 
    /* int -> uint and any other oddball conversions */
diff --git a/src/compiler/glsl/ir_print_visitor.cpp b/src/compiler/glsl/ir_print_visitor.cpp
index 5852340eea586..f86ce80677673 100644
--- a/src/compiler/glsl/ir_print_visitor.cpp
+++ b/src/compiler/glsl/ir_print_visitor.cpp
@@ -49,11 +49,11 @@ ir_instruction::fprint(FILE *f) const
 static void
 glsl_print_type(FILE *f, const glsl_type *t)
 {
-   if (t->is_array()) {
+   if (glsl_type_is_array(t)) {
       fprintf(f, "(array ");
       glsl_print_type(f, t->fields.array);
       fprintf(f, " %u)", t->length);
-   } else if (t->is_struct() && !is_gl_identifier(glsl_get_type_name(t))) {
+   } else if (glsl_type_is_struct(t) && !is_gl_identifier(glsl_get_type_name(t))) {
       fprintf(f, "%s@%p", glsl_get_type_name(t), (void *) t);
    } else {
       fprintf(f, "%s", glsl_get_type_name(t));
@@ -500,17 +500,17 @@ void ir_print_visitor::visit(ir_constant *ir)
    glsl_print_type(f, ir->type);
    fprintf(f, " (");
 
-   if (ir->type->is_array()) {
+   if (glsl_type_is_array(ir->type)) {
       for (unsigned i = 0; i < ir->type->length; i++)
 	 ir->get_array_element(i)->accept(this);
-   } else if (ir->type->is_struct()) {
+   } else if (glsl_type_is_struct(ir->type)) {
       for (unsigned i = 0; i < ir->type->length; i++) {
 	 fprintf(f, "(%s ", ir->type->fields.structure[i].name);
          ir->get_record_field(i)->accept(this);
 	 fprintf(f, ")");
       }
    } else {
-      for (unsigned i = 0; i < ir->type->components(); i++) {
+      for (unsigned i = 0; i < glsl_get_components(ir->type); i++) {
 	 if (i != 0)
 	    fprintf(f, " ");
 	 switch (ir->type->base_type) {
diff --git a/src/compiler/glsl/ir_reader.cpp b/src/compiler/glsl/ir_reader.cpp
index 46b1d56f10f32..e697ee30cb3a0 100644
--- a/src/compiler/glsl/ir_reader.cpp
+++ b/src/compiler/glsl/ir_reader.cpp
@@ -145,7 +145,7 @@ ir_reader::read_type(s_expression *expr)
 	 return NULL;
       }
 
-      return glsl_type::get_array_instance(base_type, s_size->value());
+      return glsl_array_type(base_type, s_size->value(), 0);
    }
 
    s_symbol *type_sym = SX_AS_SYMBOL(expr);
@@ -638,7 +638,7 @@ ir_reader::read_assignment(s_expression *expr)
       return NULL;
    }
 
-   if (mask == 0 && (lhs->type->is_vector() || lhs->type->is_scalar())) {
+   if (mask == 0 && (glsl_type_is_vector(lhs->type) || glsl_type_is_scalar(lhs->type))) {
       ir_read_error(expr, "non-zero write mask required.");
       return NULL;
    }
@@ -806,7 +806,7 @@ ir_reader::read_constant(s_expression *expr)
       return NULL;
    }
 
-   if (type->is_array()) {
+   if (glsl_type_is_array(type)) {
       unsigned elements_supplied = 0;
       exec_list elements;
       foreach_in_list(s_expression, elt, &values->subexpressions) {
@@ -835,7 +835,7 @@ ir_reader::read_constant(s_expression *expr)
 	 return NULL;
       }
 
-      if (type->is_float()) {
+      if (glsl_type_is_float(type)) {
 	 s_number *value = SX_AS_NUMBER(expr);
 	 if (value == NULL) {
 	    ir_read_error(values, "expected numbers");
@@ -869,9 +869,9 @@ ir_reader::read_constant(s_expression *expr)
       }
       ++k;
    }
-   if (k != type->components()) {
+   if (k != glsl_get_components(type)) {
       ir_read_error(values, "expected %u constant values, found %u",
-		    type->components(), k);
+		    glsl_get_components(type), k);
       return NULL;
    }
 
@@ -1031,7 +1031,7 @@ ir_reader::read_texture(s_expression *expr)
    }
 
    if (is_sparse) {
-      const glsl_type *texel = type->field_type("texel");
+      const glsl_type *texel = glsl_get_field_type(type, "texel");
       if (texel == &glsl_type_builtin_error) {
          ir_read_error(NULL, "invalid type for sparse texture");
          return NULL;
diff --git a/src/compiler/glsl/ir_validate.cpp b/src/compiler/glsl/ir_validate.cpp
index a7c374d861cda..e71f60c32ca97 100644
--- a/src/compiler/glsl/ir_validate.cpp
+++ b/src/compiler/glsl/ir_validate.cpp
@@ -102,7 +102,7 @@ ir_validate::visit(ir_dereference_variable *ir)
    /* Compare types without arrays, because one side can be sized and
     * the other unsized.
     */
-   if (ir->var->type->without_array() != ir->type->without_array()) {
+   if (glsl_without_array(ir->var->type) != glsl_without_array(ir->type)) {
       printf("ir_dereference_variable type is not equal to variable type: ");
       ir->print();
       printf("\n");
@@ -124,8 +124,8 @@ ir_validate::visit(ir_dereference_variable *ir)
 ir_visitor_status
 ir_validate::visit_enter(class ir_dereference_array *ir)
 {
-   if (!ir->array->type->is_array() && !ir->array->type->is_matrix() &&
-      !ir->array->type->is_vector()) {
+   if (!glsl_type_is_array(ir->array->type) && !glsl_type_is_matrix(ir->array->type) &&
+      !glsl_type_is_vector(ir->array->type)) {
       printf("ir_dereference_array @ %p does not specify an array, a vector "
              "or a matrix\n",
              (void *) ir);
@@ -134,7 +134,7 @@ ir_validate::visit_enter(class ir_dereference_array *ir)
       abort();
    }
 
-   if (ir->array->type->is_array()) {
+   if (glsl_type_is_array(ir->array->type)) {
       if (ir->array->type->fields.array != ir->type) {
          printf("ir_dereference_array type is not equal to the array "
                 "element type: ");
@@ -149,13 +149,13 @@ ir_validate::visit_enter(class ir_dereference_array *ir)
       abort();
    }
 
-   if (!ir->array_index->type->is_scalar()) {
+   if (!glsl_type_is_scalar(ir->array_index->type)) {
       printf("ir_dereference_array @ %p does not have scalar index: %s\n",
              (void *) ir, glsl_get_type_name(ir->array_index->type));
       abort();
    }
 
-   if (!ir->array_index->type->is_integer_16_32()) {
+   if (!glsl_type_is_integer_16_32(ir->array_index->type)) {
       printf("ir_dereference_array @ %p does not have integer index: %s\n",
              (void *) ir, glsl_get_type_name(ir->array_index->type));
       abort();
@@ -167,7 +167,7 @@ ir_validate::visit_enter(class ir_dereference_array *ir)
 ir_visitor_status
 ir_validate::visit_enter(class ir_dereference_record *ir)
 {
-   if (!ir->record->type->is_struct() && !ir->record->type->is_interface()) {
+   if (!glsl_type_is_struct(ir->record->type) && !glsl_type_is_interface(ir->record->type)) {
       printf("ir_dereference_record @ %p does not specify a record\n",
              (void *) ir);
       ir->print();
@@ -311,8 +311,8 @@ ir_validate::visit_leave(ir_expression *ir)
       assert(ir->operands[0]->type == ir->type);
       break;
    case ir_unop_logic_not:
-      assert(ir->type->is_boolean());
-      assert(ir->operands[0]->type->is_boolean());
+      assert(glsl_type_is_boolean(ir->type));
+      assert(glsl_type_is_boolean(ir->operands[0]->type));
       break;
 
    case ir_unop_neg:
@@ -321,15 +321,15 @@ ir_validate::visit_leave(ir_expression *ir)
 
    case ir_unop_abs:
    case ir_unop_sign:
-      assert(ir->operands[0]->type->is_int_16_32_64() ||
-             ir->operands[0]->type->is_float_16_32_64());
+      assert(glsl_type_is_int_16_32_64(ir->operands[0]->type) ||
+             glsl_type_is_float_16_32_64(ir->operands[0]->type));
       assert(ir->type == ir->operands[0]->type);
       break;
 
    case ir_unop_rcp:
    case ir_unop_rsq:
    case ir_unop_sqrt:
-      assert(ir->type->is_float_16_32_64());
+      assert(glsl_type_is_float_16_32_64(ir->type));
       assert(ir->type == ir->operands[0]->type);
       break;
 
@@ -338,58 +338,58 @@ ir_validate::visit_leave(ir_expression *ir)
    case ir_unop_exp2:
    case ir_unop_log2:
    case ir_unop_saturate:
-      assert(ir->operands[0]->type->is_float_16_32());
+      assert(glsl_type_is_float_16_32(ir->operands[0]->type));
       assert(ir->type == ir->operands[0]->type);
       break;
 
    case ir_unop_f2i:
-      assert(ir->operands[0]->type->is_float_16_32());
-      assert(ir->type->is_int_16_32());
+      assert(glsl_type_is_float_16_32(ir->operands[0]->type));
+      assert(glsl_type_is_int_16_32(ir->type));
       break;
    case ir_unop_f2u:
-      assert(ir->operands[0]->type->is_float_16_32());
-      assert(ir->type->is_uint_16_32());
+      assert(glsl_type_is_float_16_32(ir->operands[0]->type));
+      assert(glsl_type_is_uint_16_32(ir->type));
       break;
    case ir_unop_i2f:
-      assert(ir->operands[0]->type->is_int_16_32());
-      assert(ir->type->is_float_16_32());
+      assert(glsl_type_is_int_16_32(ir->operands[0]->type));
+      assert(glsl_type_is_float_16_32(ir->type));
       break;
    case ir_unop_f2b:
-      assert(ir->operands[0]->type->is_float_16_32());
-      assert(ir->type->is_boolean());
+      assert(glsl_type_is_float_16_32(ir->operands[0]->type));
+      assert(glsl_type_is_boolean(ir->type));
       break;
    case ir_unop_f162b:
       assert(ir->operands[0]->type->base_type ==
              GLSL_TYPE_FLOAT16);
-      assert(ir->type->is_boolean());
+      assert(glsl_type_is_boolean(ir->type));
       break;
    case ir_unop_b2f:
-      assert(ir->operands[0]->type->is_boolean());
-      assert(ir->type->is_float_16_32());
+      assert(glsl_type_is_boolean(ir->operands[0]->type));
+      assert(glsl_type_is_float_16_32(ir->type));
       break;
    case ir_unop_b2f16:
-      assert(ir->operands[0]->type->is_boolean());
+      assert(glsl_type_is_boolean(ir->operands[0]->type));
       assert(ir->type->base_type == GLSL_TYPE_FLOAT16);
       break;
    case ir_unop_i2b:
-      assert(ir->operands[0]->type->is_int_16_32());
-      assert(ir->type->is_boolean());
+      assert(glsl_type_is_int_16_32(ir->operands[0]->type));
+      assert(glsl_type_is_boolean(ir->type));
       break;
    case ir_unop_b2i:
-      assert(ir->operands[0]->type->is_boolean());
-      assert(ir->type->is_int_16_32());
+      assert(glsl_type_is_boolean(ir->operands[0]->type));
+      assert(glsl_type_is_int_16_32(ir->type));
       break;
    case ir_unop_u2f:
-      assert(ir->operands[0]->type->is_uint_16_32());
-      assert(ir->type->is_float_16_32());
+      assert(glsl_type_is_uint_16_32(ir->operands[0]->type));
+      assert(glsl_type_is_float_16_32(ir->type));
       break;
    case ir_unop_i2u:
-      assert(ir->operands[0]->type->is_int_16_32());
-      assert(ir->type->is_uint_16_32());
+      assert(glsl_type_is_int_16_32(ir->operands[0]->type));
+      assert(glsl_type_is_uint_16_32(ir->type));
       break;
    case ir_unop_u2i:
-      assert(ir->operands[0]->type->is_uint_16_32());
-      assert(ir->type->is_int_16_32());
+      assert(glsl_type_is_uint_16_32(ir->operands[0]->type));
+      assert(glsl_type_is_int_16_32(ir->type));
       break;
    case ir_unop_bitcast_i2f:
       assert(ir->operands[0]->type->base_type == GLSL_TYPE_INT);
@@ -410,90 +410,90 @@ ir_validate::visit_leave(ir_expression *ir)
 
    case ir_unop_bitcast_u642d:
       assert(ir->operands[0]->type->base_type == GLSL_TYPE_UINT64);
-      assert(ir->type->is_double());
+      assert(glsl_type_is_double(ir->type));
       break;
    case ir_unop_bitcast_i642d:
       assert(ir->operands[0]->type->base_type == GLSL_TYPE_INT64);
-      assert(ir->type->is_double());
+      assert(glsl_type_is_double(ir->type));
       break;
    case ir_unop_bitcast_d2u64:
-      assert(ir->operands[0]->type->is_double());
+      assert(glsl_type_is_double(ir->operands[0]->type));
       assert(ir->type->base_type == GLSL_TYPE_UINT64);
       break;
    case ir_unop_bitcast_d2i64:
-      assert(ir->operands[0]->type->is_double());
+      assert(glsl_type_is_double(ir->operands[0]->type));
       assert(ir->type->base_type == GLSL_TYPE_INT64);
       break;
    case ir_unop_i642i:
       assert(ir->operands[0]->type->base_type == GLSL_TYPE_INT64);
-      assert(ir->type->is_int_16_32());
+      assert(glsl_type_is_int_16_32(ir->type));
       break;
    case ir_unop_u642i:
       assert(ir->operands[0]->type->base_type == GLSL_TYPE_UINT64);
-      assert(ir->type->is_int_16_32());
+      assert(glsl_type_is_int_16_32(ir->type));
       break;
    case ir_unop_i642u:
       assert(ir->operands[0]->type->base_type == GLSL_TYPE_INT64);
-      assert(ir->type->is_uint_16_32());
+      assert(glsl_type_is_uint_16_32(ir->type));
       break;
    case ir_unop_u642u:
       assert(ir->operands[0]->type->base_type == GLSL_TYPE_UINT64);
-      assert(ir->type->is_uint_16_32());
+      assert(glsl_type_is_uint_16_32(ir->type));
       break;
    case ir_unop_i642b:
       assert(ir->operands[0]->type->base_type == GLSL_TYPE_INT64);
-      assert(ir->type->is_boolean());
+      assert(glsl_type_is_boolean(ir->type));
       break;
    case ir_unop_i642f:
       assert(ir->operands[0]->type->base_type == GLSL_TYPE_INT64);
-      assert(ir->type->is_float());
+      assert(glsl_type_is_float(ir->type));
       break;
    case ir_unop_u642f:
       assert(ir->operands[0]->type->base_type == GLSL_TYPE_UINT64);
-      assert(ir->type->is_float());
+      assert(glsl_type_is_float(ir->type));
       break;
    case ir_unop_i642d:
       assert(ir->operands[0]->type->base_type == GLSL_TYPE_INT64);
-      assert(ir->type->is_double());
+      assert(glsl_type_is_double(ir->type));
       break;
    case ir_unop_u642d:
       assert(ir->operands[0]->type->base_type == GLSL_TYPE_UINT64);
-      assert(ir->type->is_double());
+      assert(glsl_type_is_double(ir->type));
       break;
    case ir_unop_i2i64:
-      assert(ir->operands[0]->type->is_int_16_32());
+      assert(glsl_type_is_int_16_32(ir->operands[0]->type));
       assert(ir->type->base_type == GLSL_TYPE_INT64);
       break;
    case ir_unop_u2i64:
-      assert(ir->operands[0]->type->is_uint_16_32());
+      assert(glsl_type_is_uint_16_32(ir->operands[0]->type));
       assert(ir->type->base_type == GLSL_TYPE_INT64);
       break;
    case ir_unop_b2i64:
-      assert(ir->operands[0]->type->is_boolean());
+      assert(glsl_type_is_boolean(ir->operands[0]->type));
       assert(ir->type->base_type == GLSL_TYPE_INT64);
       break;
    case ir_unop_f2i64:
-      assert(ir->operands[0]->type->is_float());
+      assert(glsl_type_is_float(ir->operands[0]->type));
       assert(ir->type->base_type == GLSL_TYPE_INT64);
       break;
    case ir_unop_d2i64:
-      assert(ir->operands[0]->type->is_double());
+      assert(glsl_type_is_double(ir->operands[0]->type));
       assert(ir->type->base_type == GLSL_TYPE_INT64);
       break;
    case ir_unop_i2u64:
-      assert(ir->operands[0]->type->is_int_16_32());
+      assert(glsl_type_is_int_16_32(ir->operands[0]->type));
       assert(ir->type->base_type == GLSL_TYPE_UINT64);
       break;
    case ir_unop_u2u64:
-      assert(ir->operands[0]->type->is_uint_16_32());
+      assert(glsl_type_is_uint_16_32(ir->operands[0]->type));
       assert(ir->type->base_type == GLSL_TYPE_UINT64);
       break;
    case ir_unop_f2u64:
-      assert(ir->operands[0]->type->is_float());
+      assert(glsl_type_is_float(ir->operands[0]->type));
       assert(ir->type->base_type == GLSL_TYPE_UINT64);
       break;
    case ir_unop_d2u64:
-      assert(ir->operands[0]->type->is_double());
+      assert(glsl_type_is_double(ir->operands[0]->type));
       assert(ir->type->base_type == GLSL_TYPE_UINT64);
       break;
    case ir_unop_u642i64:
@@ -509,7 +509,7 @@ ir_validate::visit_leave(ir_expression *ir)
    case ir_unop_ceil:
    case ir_unop_floor:
    case ir_unop_fract:
-      assert(ir->operands[0]->type->is_float_16_32_64());
+      assert(glsl_type_is_float_16_32_64(ir->operands[0]->type));
       assert(ir->operands[0]->type == ir->type);
       break;
    case ir_unop_sin:
@@ -520,7 +520,7 @@ ir_validate::visit_leave(ir_expression *ir)
    case ir_unop_dFdy:
    case ir_unop_dFdy_coarse:
    case ir_unop_dFdy_fine:
-      assert(ir->operands[0]->type->is_float_16_32());
+      assert(glsl_type_is_float_16_32(ir->operands[0]->type));
       assert(ir->operands[0]->type == ir->type);
       break;
 
@@ -553,12 +553,12 @@ ir_validate::visit_leave(ir_expression *ir)
       break;
 
    case ir_unop_pack_sampler_2x32:
-      assert(ir->type->is_sampler());
+      assert(glsl_type_is_sampler(ir->type));
       assert(ir->operands[0]->type == &glsl_type_builtin_uvec2);
       break;
 
    case ir_unop_pack_image_2x32:
-      assert(ir->type->is_image());
+      assert(glsl_type_is_image(ir->type));
       assert(ir->operands[0]->type == &glsl_type_builtin_uvec2);
       break;
 
@@ -592,35 +592,35 @@ ir_validate::visit_leave(ir_expression *ir)
 
    case ir_unop_unpack_sampler_2x32:
       assert(ir->type == &glsl_type_builtin_uvec2);
-      assert(ir->operands[0]->type->is_sampler());
+      assert(glsl_type_is_sampler(ir->operands[0]->type));
       break;
 
    case ir_unop_unpack_image_2x32:
       assert(ir->type == &glsl_type_builtin_uvec2);
-      assert(ir->operands[0]->type->is_image());
+      assert(glsl_type_is_image(ir->operands[0]->type));
       break;
 
    case ir_unop_bitfield_reverse:
       assert(ir->operands[0]->type == ir->type);
-      assert(ir->type->is_integer_32());
+      assert(glsl_type_is_integer_32(ir->type));
       break;
 
    case ir_unop_bit_count:
    case ir_unop_find_msb:
    case ir_unop_find_lsb:
       assert(ir->operands[0]->type->vector_elements == ir->type->vector_elements);
-      assert(ir->operands[0]->type->is_integer_16_32());
-      assert(ir->type->is_int_16_32());
+      assert(glsl_type_is_integer_16_32(ir->operands[0]->type));
+      assert(glsl_type_is_int_16_32(ir->type));
       break;
 
    case ir_unop_clz:
       assert(ir->operands[0]->type == ir->type);
-      assert(ir->type->is_uint_16_32());
+      assert(glsl_type_is_uint_16_32(ir->type));
       break;
 
    case ir_unop_interpolate_at_centroid:
       assert(ir->operands[0]->type == ir->type);
-      assert(ir->operands[0]->type->is_float_16_32());
+      assert(glsl_type_is_float_16_32(ir->operands[0]->type));
       break;
 
    case ir_unop_get_buffer_size:
@@ -630,40 +630,40 @@ ir_validate::visit_leave(ir_expression *ir)
 
    case ir_unop_ssbo_unsized_array_length:
       assert(ir->type == &glsl_type_builtin_int);
-      assert(ir->operands[0]->type->is_array());
-      assert(ir->operands[0]->type->is_unsized_array());
+      assert(glsl_type_is_array(ir->operands[0]->type));
+      assert(glsl_type_is_unsized_array(ir->operands[0]->type));
       break;
 
    case ir_unop_implicitly_sized_array_length:
       assert(ir->type == &glsl_type_builtin_int);
-      assert(ir->operands[0]->type->is_array());
+      assert(glsl_type_is_array(ir->operands[0]->type));
       break;
 
    case ir_unop_d2f:
-      assert(ir->operands[0]->type->is_double());
-      assert(ir->type->is_float());
+      assert(glsl_type_is_double(ir->operands[0]->type));
+      assert(glsl_type_is_float(ir->type));
       break;
    case ir_unop_f2d:
-      assert(ir->operands[0]->type->is_float());
-      assert(ir->type->is_double());
+      assert(glsl_type_is_float(ir->operands[0]->type));
+      assert(glsl_type_is_double(ir->type));
       break;
    case ir_unop_f162f:
       assert(ir->operands[0]->type->base_type == GLSL_TYPE_FLOAT16);
-      assert(ir->type->is_float());
+      assert(glsl_type_is_float(ir->type));
       break;
    case ir_unop_f2f16:
    case ir_unop_f2fmp:
-      assert(ir->operands[0]->type->is_float());
+      assert(glsl_type_is_float(ir->operands[0]->type));
       assert(ir->type->base_type == GLSL_TYPE_FLOAT16);
       break;
    case ir_unop_i2i:
-      assert(ir->operands[0]->type->is_int_16_32());
-      assert(ir->type->is_int_16_32());
+      assert(glsl_type_is_int_16_32(ir->operands[0]->type));
+      assert(glsl_type_is_int_16_32(ir->type));
       assert(ir->type->base_type != ir->operands[0]->type->base_type);
       break;
    case ir_unop_u2u:
-      assert(ir->operands[0]->type->is_uint_16_32());
-      assert(ir->type->is_uint_16_32());
+      assert(glsl_type_is_uint_16_32(ir->operands[0]->type));
+      assert(glsl_type_is_uint_16_32(ir->type));
       assert(ir->type->base_type != ir->operands[0]->type->base_type);
       break;
    case ir_unop_i2imp:
@@ -675,31 +675,31 @@ ir_validate::visit_leave(ir_expression *ir)
       assert(ir->type->base_type == GLSL_TYPE_UINT16);
       break;
    case ir_unop_d2i:
-      assert(ir->operands[0]->type->is_double());
-      assert(ir->type->is_int_16_32());
+      assert(glsl_type_is_double(ir->operands[0]->type));
+      assert(glsl_type_is_int_16_32(ir->type));
       break;
    case ir_unop_i2d:
-      assert(ir->operands[0]->type->is_int_16_32());
-      assert(ir->type->is_double());
+      assert(glsl_type_is_int_16_32(ir->operands[0]->type));
+      assert(glsl_type_is_double(ir->type));
       break;
    case ir_unop_d2u:
-      assert(ir->operands[0]->type->is_double());
-      assert(ir->type->is_uint_16_32());
+      assert(glsl_type_is_double(ir->operands[0]->type));
+      assert(glsl_type_is_uint_16_32(ir->type));
       break;
    case ir_unop_u2d:
-      assert(ir->operands[0]->type->is_uint_16_32());
-      assert(ir->type->is_double());
+      assert(glsl_type_is_uint_16_32(ir->operands[0]->type));
+      assert(glsl_type_is_double(ir->type));
       break;
    case ir_unop_d2b:
-      assert(ir->operands[0]->type->is_double());
-      assert(ir->type->is_boolean());
+      assert(glsl_type_is_double(ir->operands[0]->type));
+      assert(glsl_type_is_boolean(ir->type));
       break;
 
    case ir_unop_frexp_sig:
-      assert(ir->operands[0]->type->is_float_32_64());
+      assert(glsl_type_is_float_32_64(ir->operands[0]->type));
       break;
    case ir_unop_frexp_exp:
-      assert(ir->operands[0]->type->is_float_32_64());
+      assert(glsl_type_is_float_32_64(ir->operands[0]->type));
       assert(ir->type->base_type == GLSL_TYPE_INT);
       break;
    case ir_unop_subroutine_to_int:
@@ -708,7 +708,7 @@ ir_validate::visit_leave(ir_expression *ir)
       break;
 
    case ir_unop_atan:
-      assert(ir->operands[0]->type->is_float_16_32_64());
+      assert(glsl_type_is_float_16_32_64(ir->operands[0]->type));
       assert(ir->type == ir->operands[0]->type);
       break;
 
@@ -726,20 +726,20 @@ ir_validate::visit_leave(ir_expression *ir)
       if (ir->operation == ir_binop_mul &&
           (ir->type->base_type == GLSL_TYPE_UINT64 ||
            ir->type->base_type == GLSL_TYPE_INT64) &&
-          (ir->operands[0]->type->is_int_16_32()||
-           ir->operands[1]->type->is_int_16_32()||
-           ir->operands[0]->type->is_uint_16_32() ||
-           ir->operands[1]->type->is_uint_16_32())) {
+          (glsl_type_is_int_16_32(ir->operands[0]->type)||
+           glsl_type_is_int_16_32(ir->operands[1]->type)||
+           glsl_type_is_uint_16_32(ir->operands[0]->type) ||
+           glsl_type_is_uint_16_32(ir->operands[1]->type))) {
          assert(ir->operands[0]->type == ir->operands[1]->type);
          break;
       }
 
-      if (ir->operands[0]->type->is_scalar())
+      if (glsl_type_is_scalar(ir->operands[0]->type))
 	 assert(ir->operands[1]->type == ir->type);
-      else if (ir->operands[1]->type->is_scalar())
+      else if (glsl_type_is_scalar(ir->operands[1]->type))
 	 assert(ir->operands[0]->type == ir->type);
-      else if (ir->operands[0]->type->is_vector() &&
-	       ir->operands[1]->type->is_vector()) {
+      else if (glsl_type_is_vector(ir->operands[0]->type) &&
+	       glsl_type_is_vector(ir->operands[1]->type)) {
 	 assert(ir->operands[0]->type == ir->operands[1]->type);
 	 assert(ir->operands[0]->type == ir->type);
       }
@@ -747,10 +747,10 @@ ir_validate::visit_leave(ir_expression *ir)
 
    case ir_binop_abs_sub:
       assert(ir->operands[0]->type == ir->operands[1]->type);
-      assert(ir->operands[0]->type->is_integer_16_32_64());
+      assert(glsl_type_is_integer_16_32_64(ir->operands[0]->type));
       assert(ir->operands[0]->type->vector_elements ==
              ir->type->vector_elements);
-      assert(ir->type->is_uint_16_32_64());
+      assert(glsl_type_is_uint_16_32_64(ir->type));
       break;
 
    case ir_binop_add_sat:
@@ -759,14 +759,14 @@ ir_validate::visit_leave(ir_expression *ir)
    case ir_binop_avg_round:
       assert(ir->type == ir->operands[0]->type);
       assert(ir->type == ir->operands[1]->type);
-      assert(ir->type->is_integer_16_32_64());
+      assert(glsl_type_is_integer_16_32_64(ir->type));
       break;
 
    case ir_binop_mul_32x16:
    case ir_binop_imul_high:
       assert(ir->type == ir->operands[0]->type);
       assert(ir->type == ir->operands[1]->type);
-      assert(ir->type->is_integer_32());
+      assert(glsl_type_is_integer_32(ir->type));
       break;
 
    case ir_binop_carry:
@@ -785,10 +785,10 @@ ir_validate::visit_leave(ir_expression *ir)
        * comparison on scalar or vector types and return a boolean scalar or
        * vector type of the same size.
        */
-      assert(ir->type->is_boolean());
+      assert(glsl_type_is_boolean(ir->type));
       assert(ir->operands[0]->type == ir->operands[1]->type);
-      assert(ir->operands[0]->type->is_vector()
-	     || ir->operands[0]->type->is_scalar());
+      assert(glsl_type_is_vector(ir->operands[0]->type)
+	     || glsl_type_is_scalar(ir->operands[0]->type));
       assert(ir->operands[0]->type->vector_elements
 	     == ir->type->vector_elements);
       break;
@@ -804,15 +804,15 @@ ir_validate::visit_leave(ir_expression *ir)
 
    case ir_binop_lshift:
    case ir_binop_rshift:
-      assert(ir->operands[0]->type->is_integer_16_32_64() &&
-             ir->operands[1]->type->is_integer_16_32_64());
-      if (ir->operands[0]->type->is_scalar()) {
-          assert(ir->operands[1]->type->is_scalar());
+      assert(glsl_type_is_integer_16_32_64(ir->operands[0]->type) &&
+             glsl_type_is_integer_16_32_64(ir->operands[1]->type));
+      if (glsl_type_is_scalar(ir->operands[0]->type)) {
+          assert(glsl_type_is_scalar(ir->operands[1]->type));
       }
-      if (ir->operands[0]->type->is_vector() &&
-          ir->operands[1]->type->is_vector()) {
-          assert(ir->operands[0]->type->components() ==
-                 ir->operands[1]->type->components());
+      if (glsl_type_is_vector(ir->operands[0]->type) &&
+          glsl_type_is_vector(ir->operands[1]->type)) {
+          assert(glsl_get_components(ir->operands[0]->type) ==
+                 glsl_get_components(ir->operands[1]->type));
       }
       assert(ir->type == ir->operands[0]->type);
       break;
@@ -822,9 +822,9 @@ ir_validate::visit_leave(ir_expression *ir)
    case ir_binop_bit_or:
        assert(ir->operands[0]->type->base_type ==
               ir->operands[1]->type->base_type);
-       assert(ir->type->is_integer_16_32_64());
-       if (ir->operands[0]->type->is_vector() &&
-           ir->operands[1]->type->is_vector()) {
+       assert(glsl_type_is_integer_16_32_64(ir->type));
+       if (glsl_type_is_vector(ir->operands[0]->type) &&
+           glsl_type_is_vector(ir->operands[1]->type)) {
            assert(ir->operands[0]->type->vector_elements ==
                   ir->operands[1]->type->vector_elements);
        }
@@ -833,63 +833,63 @@ ir_validate::visit_leave(ir_expression *ir)
    case ir_binop_logic_and:
    case ir_binop_logic_xor:
    case ir_binop_logic_or:
-      assert(ir->type->is_boolean());
-      assert(ir->operands[0]->type->is_boolean());
-      assert(ir->operands[1]->type->is_boolean());
+      assert(glsl_type_is_boolean(ir->type));
+      assert(glsl_type_is_boolean(ir->operands[0]->type));
+      assert(glsl_type_is_boolean(ir->operands[1]->type));
       break;
 
    case ir_binop_dot:
       assert(ir->type == &glsl_type_builtin_float ||
              ir->type == &glsl_type_builtin_double ||
              ir->type == &glsl_type_builtin_float16_t);
-      assert(ir->operands[0]->type->is_float_16_32_64());
-      assert(ir->operands[0]->type->is_vector());
+      assert(glsl_type_is_float_16_32_64(ir->operands[0]->type));
+      assert(glsl_type_is_vector(ir->operands[0]->type));
       assert(ir->operands[0]->type == ir->operands[1]->type);
       break;
 
    case ir_binop_ldexp:
       assert(ir->operands[0]->type == ir->type);
-      assert(ir->operands[0]->type->is_float_32_64());
+      assert(glsl_type_is_float_32_64(ir->operands[0]->type));
       assert(ir->operands[1]->type->base_type == GLSL_TYPE_INT);
-      assert(ir->operands[0]->type->components() ==
-             ir->operands[1]->type->components());
+      assert(glsl_get_components(ir->operands[0]->type) ==
+             glsl_get_components(ir->operands[1]->type));
       break;
 
    case ir_binop_vector_extract:
-      assert(ir->operands[0]->type->is_vector());
-      assert(ir->operands[1]->type->is_scalar()
-             && ir->operands[1]->type->is_integer_16_32());
+      assert(glsl_type_is_vector(ir->operands[0]->type));
+      assert(glsl_type_is_scalar(ir->operands[1]->type)
+             && glsl_type_is_integer_16_32(ir->operands[1]->type));
       break;
 
    case ir_binop_interpolate_at_offset:
       assert(ir->operands[0]->type == ir->type);
-      assert(ir->operands[0]->type->is_float_16_32());
-      assert(ir->operands[1]->type->components() == 2);
-      assert(ir->operands[1]->type->is_float_16_32());
+      assert(glsl_type_is_float_16_32(ir->operands[0]->type));
+      assert(glsl_get_components(ir->operands[1]->type) == 2);
+      assert(glsl_type_is_float_16_32(ir->operands[1]->type));
       break;
 
    case ir_binop_interpolate_at_sample:
       assert(ir->operands[0]->type == ir->type);
-      assert(ir->operands[0]->type->is_float_16_32());
+      assert(glsl_type_is_float_16_32(ir->operands[0]->type));
       assert(ir->operands[1]->type == &glsl_type_builtin_int ||
              ir->operands[1]->type == &glsl_type_builtin_int16_t);
       break;
 
    case ir_binop_atan2:
-      assert(ir->operands[0]->type->is_float_16_32_64());
+      assert(glsl_type_is_float_16_32_64(ir->operands[0]->type));
       assert(ir->operands[1]->type == ir->operands[0]->type);
       assert(ir->type == ir->operands[0]->type);
       break;
 
    case ir_triop_fma:
-      assert(ir->type->is_float_16_32_64());
+      assert(glsl_type_is_float_16_32_64(ir->type));
       assert(ir->type == ir->operands[0]->type);
       assert(ir->type == ir->operands[1]->type);
       assert(ir->type == ir->operands[2]->type);
       break;
 
    case ir_triop_lrp:
-      assert(ir->operands[0]->type->is_float_16_32_64());
+      assert(glsl_type_is_float_16_32_64(ir->operands[0]->type));
       assert(ir->operands[0]->type == ir->operands[1]->type);
       assert(ir->operands[2]->type == ir->operands[0]->type ||
              ir->operands[2]->type == &glsl_type_builtin_float ||
@@ -898,30 +898,30 @@ ir_validate::visit_leave(ir_expression *ir)
       break;
 
    case ir_triop_csel:
-      assert(ir->operands[0]->type->is_boolean());
+      assert(glsl_type_is_boolean(ir->operands[0]->type));
       assert(ir->type->vector_elements == ir->operands[0]->type->vector_elements);
       assert(ir->type == ir->operands[1]->type);
       assert(ir->type == ir->operands[2]->type);
       break;
 
    case ir_triop_bitfield_extract:
-      assert(ir->type->is_integer_16_32());
+      assert(glsl_type_is_integer_16_32(ir->type));
       assert(ir->operands[0]->type == ir->type);
       assert(ir->operands[1]->type == ir->type);
       assert(ir->operands[2]->type == ir->type);
       break;
 
    case ir_triop_vector_insert:
-      assert(ir->operands[0]->type->is_vector());
-      assert(ir->operands[1]->type->is_scalar());
+      assert(glsl_type_is_vector(ir->operands[0]->type));
+      assert(glsl_type_is_scalar(ir->operands[1]->type));
       assert(ir->operands[0]->type->base_type == ir->operands[1]->type->base_type);
-      assert(ir->operands[2]->type->is_scalar()
-             && ir->operands[2]->type->is_integer_16_32());
+      assert(glsl_type_is_scalar(ir->operands[2]->type)
+             && glsl_type_is_integer_16_32(ir->operands[2]->type));
       assert(ir->type == ir->operands[0]->type);
       break;
 
    case ir_quadop_bitfield_insert:
-      assert(ir->type->is_integer_16_32());
+      assert(glsl_type_is_integer_16_32(ir->type));
       assert(ir->operands[0]->type == ir->type);
       assert(ir->operands[1]->type == ir->type);
       assert(ir->operands[2]->type == ir->type);
@@ -938,37 +938,37 @@ ir_validate::visit_leave(ir_expression *ir)
        */
       switch (ir->type->vector_elements) {
       case 1:
-         assert(ir->operands[0]->type->is_scalar());
+         assert(glsl_type_is_scalar(ir->operands[0]->type));
          assert(ir->operands[0]->type->base_type == ir->type->base_type);
          assert(ir->operands[1] == NULL);
          assert(ir->operands[2] == NULL);
          assert(ir->operands[3] == NULL);
          break;
       case 2:
-	 assert(ir->operands[0]->type->is_scalar());
+	 assert(glsl_type_is_scalar(ir->operands[0]->type));
 	 assert(ir->operands[0]->type->base_type == ir->type->base_type);
-	 assert(ir->operands[1]->type->is_scalar());
+	 assert(glsl_type_is_scalar(ir->operands[1]->type));
 	 assert(ir->operands[1]->type->base_type == ir->type->base_type);
 	 assert(ir->operands[2] == NULL);
 	 assert(ir->operands[3] == NULL);
 	 break;
       case 3:
-	 assert(ir->operands[0]->type->is_scalar());
+	 assert(glsl_type_is_scalar(ir->operands[0]->type));
 	 assert(ir->operands[0]->type->base_type == ir->type->base_type);
-	 assert(ir->operands[1]->type->is_scalar());
+	 assert(glsl_type_is_scalar(ir->operands[1]->type));
 	 assert(ir->operands[1]->type->base_type == ir->type->base_type);
-	 assert(ir->operands[2]->type->is_scalar());
+	 assert(glsl_type_is_scalar(ir->operands[2]->type));
 	 assert(ir->operands[2]->type->base_type == ir->type->base_type);
 	 assert(ir->operands[3] == NULL);
 	 break;
       case 4:
-	 assert(ir->operands[0]->type->is_scalar());
+	 assert(glsl_type_is_scalar(ir->operands[0]->type));
 	 assert(ir->operands[0]->type->base_type == ir->type->base_type);
-	 assert(ir->operands[1]->type->is_scalar());
+	 assert(glsl_type_is_scalar(ir->operands[1]->type));
 	 assert(ir->operands[1]->type->base_type == ir->type->base_type);
-	 assert(ir->operands[2]->type->is_scalar());
+	 assert(glsl_type_is_scalar(ir->operands[2]->type));
 	 assert(ir->operands[2]->type->base_type == ir->type->base_type);
-	 assert(ir->operands[3]->type->is_scalar());
+	 assert(glsl_type_is_scalar(ir->operands[3]->type));
 	 assert(ir->operands[3]->type->base_type == ir->type->base_type);
 	 break;
       default:
@@ -1017,7 +1017,7 @@ ir_validate::visit(ir_variable *ir)
     * bounds.  There was once an error in AST-to-HIR conversion that set this
     * to be out of bounds.
     */
-   if (ir->type->array_size() > 0) {
+   if (glsl_array_size(ir->type) > 0) {
       if (ir->data.max_array_access >= (int)ir->type->length) {
 	 printf("ir_variable has maximum access out of bounds (%d vs %d)\n",
 		ir->data.max_array_access, ir->type->length - 1);
@@ -1034,7 +1034,7 @@ ir_validate::visit(ir_variable *ir)
       const glsl_struct_field *fields =
          ir->get_interface_type()->fields.structure;
       for (unsigned i = 0; i < ir->get_interface_type()->length; i++) {
-         if (fields[i].type->array_size() > 0 &&
+         if (glsl_array_size(fields[i].type) > 0 &&
              !fields[i].implicit_sized_array) {
             const int *const max_ifc_array_access =
                ir->get_max_ifc_array_access();
@@ -1074,10 +1074,10 @@ ir_visitor_status
 ir_validate::visit_enter(ir_assignment *ir)
 {
    const ir_dereference *const lhs = ir->lhs;
-   if (lhs->type->is_scalar() || lhs->type->is_vector()) {
+   if (glsl_type_is_scalar(lhs->type) || glsl_type_is_vector(lhs->type)) {
       if (ir->write_mask == 0) {
 	 printf("Assignment LHS is %s, but write mask is 0:\n",
-		lhs->type->is_scalar() ? "scalar" : "vector");
+		glsl_type_is_scalar(lhs->type) ? "scalar" : "vector");
 	 ir->print();
 	 abort();
       }
diff --git a/src/compiler/glsl/link_functions.cpp b/src/compiler/glsl/link_functions.cpp
index eb1d589f33c26..35116df8733cc 100644
--- a/src/compiler/glsl/link_functions.cpp
+++ b/src/compiler/glsl/link_functions.cpp
@@ -202,9 +202,9 @@ public:
             formal_param_node = formal_param_node->get_next();
             actual_param_node = actual_param_node->get_next();
 
-            if (formal_param->type->is_array()) {
+            if (glsl_type_is_array(formal_param->type)) {
                ir_dereference_variable *deref = actual_param->as_dereference_variable();
-               if (deref && deref->var && deref->var->type->is_array()) {
+               if (deref && deref->var && glsl_type_is_array(deref->var->type)) {
                   deref->var->data.max_array_access =
                      MAX2(formal_param->data.max_array_access,
                          deref->var->data.max_array_access);
@@ -232,7 +232,7 @@ public:
 	    linked->symbols->add_variable(var);
 	    linked->ir->push_head(var);
 	 } else {
-            if (var->type->is_array()) {
+            if (glsl_type_is_array(var->type)) {
                /* It is possible to have a global array declared in multiple
                 * shaders without a size.  The array is implicitly sized by
                 * the maximal access to it in *any* shader.  Because of this,
diff --git a/src/compiler/glsl/link_interface_blocks.cpp b/src/compiler/glsl/link_interface_blocks.cpp
index af4d1fe3afcca..350f076c0b7d0 100644
--- a/src/compiler/glsl/link_interface_blocks.cpp
+++ b/src/compiler/glsl/link_interface_blocks.cpp
@@ -121,7 +121,7 @@ intrastage_match(ir_variable *a,
    bool interface_type_match =
       (prog->IsES ?
        a->get_interface_type() == b->get_interface_type() :
-       a->get_interface_type()->compare_no_precision(b->get_interface_type()));
+       glsl_type_compare_no_precision(a->get_interface_type(), b->get_interface_type()));
 
    /* Types must match. */
    if (!interface_type_match) {
@@ -153,12 +153,12 @@ intrastage_match(ir_variable *a,
 
    bool type_match = (match_precision ?
                       a->type == b->type :
-                      a->type->compare_no_precision(b->type));
+                      glsl_type_compare_no_precision(a->type, b->type));
 
    /* If a block is an array then it must match across the shader.
     * Unsized arrays are also processed and matched agaist sized arrays.
     */
-   if (!type_match && (b->type->is_array() || a->type->is_array()) &&
+   if (!type_match && (glsl_type_is_array(b->type) || glsl_type_is_array(a->type)) &&
        (b->is_interface_instance() || a->is_interface_instance()) &&
        !validate_intrastage_arrays(prog, b, a, match_precision))
       return false;
@@ -209,9 +209,9 @@ interstage_match(struct gl_shader_program *prog, ir_variable *producer,
     * making sure the types are equal.
     */
    if ((consumer->is_interface_instance() &&
-        consumer_instance_type->is_array()) ||
+        glsl_type_is_array(consumer_instance_type)) ||
        (producer->is_interface_instance() &&
-        producer->type->is_array())) {
+        glsl_type_is_array(producer->type))) {
       if (consumer_instance_type != producer->type)
          return false;
    }
@@ -261,7 +261,7 @@ public:
       } else {
          const struct hash_entry *entry =
             _mesa_hash_table_search(ht,
-               glsl_get_type_name(var->get_interface_type()->without_array()));
+               glsl_get_type_name(glsl_without_array(var->get_interface_type())));
          return entry ? (ir_variable *) entry->data : NULL;
       }
    }
@@ -283,7 +283,7 @@ public:
          _mesa_hash_table_insert(ht, ralloc_strdup(mem_ctx, location_str), var);
       } else {
          _mesa_hash_table_insert(ht,
-            glsl_get_type_name(var->get_interface_type()->without_array()), var);
+            glsl_get_type_name(glsl_without_array(var->get_interface_type())), var);
       }
    }
 
diff --git a/src/compiler/glsl/linker.cpp b/src/compiler/glsl/linker.cpp
index a4b233c74ac11..4e77e5fb65a60 100644
--- a/src/compiler/glsl/linker.cpp
+++ b/src/compiler/glsl/linker.cpp
@@ -248,7 +248,7 @@ public:
    virtual ir_visitor_status visit_leave(ir_dereference_array *ir)
    {
       const glsl_type *const vt = ir->array->type;
-      if (vt->is_array())
+      if (glsl_type_is_array(vt))
          ir->type = vt->fields.array;
       return visit_continue;
    }
@@ -285,7 +285,7 @@ public:
 
    virtual ir_visitor_status visit(ir_variable *var)
    {
-      if (!var->type->is_array() || var->data.mode != ir_var_shader_in ||
+      if (!glsl_type_is_array(var->type) || var->data.mode != ir_var_shader_in ||
           var->data.patch)
          return visit_continue;
 
@@ -316,8 +316,8 @@ public:
          }
       }
 
-      var->type = glsl_type::get_array_instance(var->type->fields.array,
-                                                this->num_vertices);
+      var->type = glsl_array_type(var->type->fields.array,
+                                  this->num_vertices, 0);
       var->data.max_array_access = this->num_vertices - 1;
 
       return visit_continue;
@@ -346,9 +346,9 @@ public:
       ir_expression *expr = (*rvalue)->as_expression();
       if (expr) {
          if (expr->operation == ir_unop_implicitly_sized_array_length) {
-            assert(!expr->operands[0]->type->is_unsized_array());
+            assert(!glsl_type_is_unsized_array(expr->operands[0]->type));
             ir_constant *constant = new(expr)
-               ir_constant(expr->operands[0]->type->array_size());
+               ir_constant(glsl_array_size(expr->operands[0]->type));
             if (constant) {
                *rvalue = constant;
             }
@@ -770,14 +770,14 @@ validate_intrastage_arrays(struct gl_shader_program *prog,
     * In addition, set the type of the linked variable to the
     * explicitly sized array.
     */
-   if (var->type->is_array() && existing->type->is_array()) {
+   if (glsl_type_is_array(var->type) && glsl_type_is_array(existing->type)) {
       const glsl_type *no_array_var = var->type->fields.array;
       const glsl_type *no_array_existing = existing->type->fields.array;
       bool type_matches;
 
       type_matches = (match_precision ?
                       no_array_var == no_array_existing :
-                      no_array_var->compare_no_precision(no_array_existing));
+                      glsl_type_compare_no_precision(no_array_var, no_array_existing));
 
       if (type_matches &&
           ((var->type->length == 0)|| (existing->type->length == 0))) {
@@ -829,7 +829,7 @@ cross_validate_globals(const struct gl_constants *consts,
          continue;
 
       /* don't cross validate subroutine uniforms */
-      if (var->type->contains_subroutine())
+      if (glsl_contains_subroutine(var->type))
          continue;
 
       /* Don't cross validate interface instances. These are only relevant
@@ -923,7 +923,7 @@ cross_validate_globals(const struct gl_constants *consts,
             existing->data.explicit_binding = true;
          }
 
-         if (var->type->contains_atomic() &&
+         if (glsl_contains_atomic(var->type) &&
              var->data.offset != existing->data.offset) {
             linker_error(prog, "offset specifications for %s "
                          "`%s' have differing values\n",
@@ -1451,8 +1451,8 @@ public:
                  var->data.from_ssbo_unsized_array,
                  &implicit_sized_array);
       var->data.implicit_sized_array = implicit_sized_array;
-      type_without_array = var->type->without_array();
-      if (var->type->is_interface()) {
+      type_without_array = glsl_without_array(var->type);
+      if (glsl_type_is_interface(var->type)) {
          if (interface_contains_unsized_arrays(var->type)) {
             const glsl_type *new_type =
                resize_interface_members(var->type,
@@ -1461,7 +1461,7 @@ public:
             var->type = new_type;
             var->change_interface_type(new_type);
          }
-      } else if (type_without_array->is_interface()) {
+      } else if (glsl_type_is_interface(type_without_array)) {
          if (interface_contains_unsized_arrays(type_without_array)) {
             const glsl_type *new_type =
                resize_interface_members(type_without_array,
@@ -1486,7 +1486,7 @@ public:
             _mesa_hash_table_insert(this->unnamed_interfaces, ifc_type,
                                     interface_vars);
          }
-         unsigned index = ifc_type->field_index(var->name);
+         unsigned index = glsl_get_field_index(ifc_type, var->name);
          assert(index < ifc_type->length);
          assert(interface_vars[index] == NULL);
          interface_vars[index] = var;
@@ -1514,9 +1514,9 @@ private:
    static void fixup_type(const glsl_type **type, unsigned max_array_access,
                           bool from_ssbo_unsized_array, bool *implicit_sized)
    {
-      if (!from_ssbo_unsized_array && (*type)->is_unsized_array()) {
-         *type = glsl_type::get_array_instance((*type)->fields.array,
-                                               max_array_access + 1);
+      if (!from_ssbo_unsized_array && glsl_type_is_unsized_array(*type)) {
+         *type = glsl_array_type((*type)->fields.array,
+                                 max_array_access + 1, 0);
          *implicit_sized = true;
          assert(*type != NULL);
       }
@@ -1527,13 +1527,12 @@ private:
                                   const glsl_type *new_interface_type)
    {
       const glsl_type *element_type = type->fields.array;
-      if (element_type->is_array()) {
+      if (glsl_type_is_array(element_type)) {
          const glsl_type *new_array_type =
             update_interface_members_array(element_type, new_interface_type);
-         return glsl_type::get_array_instance(new_array_type, type->length);
+         return glsl_array_type(new_array_type, type->length, 0);
       } else {
-         return glsl_type::get_array_instance(new_interface_type,
-                                              type->length);
+         return glsl_array_type(new_interface_type, type->length, 0);
       }
    }
 
@@ -1545,7 +1544,7 @@ private:
    {
       for (unsigned i = 0; i < type->length; i++) {
          const glsl_type *elem_type = type->fields.structure[i].type;
-         if (elem_type->is_unsized_array())
+         if (glsl_type_is_unsized_array(elem_type))
             return true;
       }
       return false;
@@ -1582,8 +1581,8 @@ private:
          (glsl_interface_packing) type->interface_packing;
       bool row_major = (bool) type->interface_row_major;
       const glsl_type *new_ifc_type =
-         glsl_type::get_interface_instance(fields, num_fields,
-                                           packing, row_major, glsl_get_type_name(type));
+         glsl_interface_type(fields, num_fields,
+                             packing, row_major, glsl_get_type_name(type));
       delete [] fields;
       return new_ifc_type;
    }
@@ -1613,8 +1612,8 @@ private:
          (glsl_interface_packing) ifc_type->interface_packing;
       bool row_major = (bool) ifc_type->interface_row_major;
       const glsl_type *new_ifc_type =
-         glsl_type::get_interface_instance(fields, num_fields, packing,
-                                           row_major, glsl_get_type_name(ifc_type));
+         glsl_interface_type(fields, num_fields, packing,
+                             row_major, glsl_get_type_name(ifc_type));
       delete [] fields;
       for (unsigned i = 0; i < num_fields; i++) {
          if (interface_vars[i] != NULL)
@@ -2560,7 +2559,7 @@ static int
 reserve_explicit_locations(struct gl_shader_program *prog,
                            string_to_uint_map *map, ir_variable *var)
 {
-   unsigned slots = var->type->uniform_locations();
+   unsigned slots = glsl_type_uniform_locations(var->type);
    unsigned max_loc = var->data.location + slots - 1;
    unsigned return_value = slots;
 
@@ -2626,7 +2625,7 @@ reserve_subroutine_explicit_locations(struct gl_shader_program *prog,
                                       struct gl_program *p,
                                       ir_variable *var)
 {
-   unsigned slots = var->type->uniform_locations();
+   unsigned slots = glsl_type_uniform_locations(var->type);
    unsigned max_loc = var->data.location + slots - 1;
 
    /* Resize remap table if locations do not fit in the current one. */
@@ -2711,7 +2710,7 @@ check_explicit_uniform_locations(const struct gl_extensions *exts,
 
          if (var->data.explicit_location) {
             bool ret = false;
-            if (var->type->without_array()->is_subroutine())
+            if (glsl_type_is_subroutine(glsl_without_array(var->type)))
                ret = reserve_subroutine_explicit_locations(prog, p, var);
             else {
                int slots = reserve_explicit_locations(prog, uniform_map,
diff --git a/src/compiler/glsl/lower_instructions.cpp b/src/compiler/glsl/lower_instructions.cpp
index df7c7435f72d9..78f3e8f3bc323 100644
--- a/src/compiler/glsl/lower_instructions.cpp
+++ b/src/compiler/glsl/lower_instructions.cpp
@@ -102,11 +102,11 @@ lower_instructions(exec_list *instructions,bool have_gpu_shader5)
 void
 lower_instructions_visitor::double_dot_to_fma(ir_expression *ir)
 {
-   ir_variable *temp = new(ir) ir_variable(ir->operands[0]->type->get_base_type(), "dot_res",
+   ir_variable *temp = new(ir) ir_variable(glsl_get_base_glsl_type(ir->operands[0]->type), "dot_res",
 					   ir_var_temporary);
    this->base_ir->insert_before(temp);
 
-   int nc = ir->operands[0]->type->components();
+   int nc = glsl_get_components(ir->operands[0]->type);
    for (int i = nc - 1; i >= 1; i--) {
       ir_assignment *assig;
       if (i == (nc - 1)) {
@@ -168,13 +168,13 @@ lower_instructions_visitor::find_lsb_to_float_cast(ir_expression *ir)
    ir_constant *c23 = new(ir) ir_constant(int(23), elements);
    ir_constant *c7F = new(ir) ir_constant(int(0x7F), elements);
    ir_variable *temp =
-      new(ir) ir_variable(glsl_type::ivec(elements), "temp", ir_var_temporary);
+      new(ir) ir_variable(glsl_ivec_type(elements), "temp", ir_var_temporary);
    ir_variable *lsb_only =
-      new(ir) ir_variable(glsl_type::uvec(elements), "lsb_only", ir_var_temporary);
+      new(ir) ir_variable(glsl_uvec_type(elements), "lsb_only", ir_var_temporary);
    ir_variable *as_float =
-      new(ir) ir_variable(glsl_type::vec(elements), "as_float", ir_var_temporary);
+      new(ir) ir_variable(glsl_vec_type(elements), "as_float", ir_var_temporary);
    ir_variable *lsb =
-      new(ir) ir_variable(glsl_type::ivec(elements), "lsb", ir_var_temporary);
+      new(ir) ir_variable(glsl_ivec_type(elements), "lsb", ir_var_temporary);
 
    ir_instruction &i = *base_ir;
 
@@ -251,11 +251,11 @@ lower_instructions_visitor::find_msb_to_float_cast(ir_expression *ir)
    ir_constant *c000000FF = new(ir) ir_constant(0x000000FFu, elements);
    ir_constant *cFFFFFF00 = new(ir) ir_constant(0xFFFFFF00u, elements);
    ir_variable *temp =
-      new(ir) ir_variable(glsl_type::uvec(elements), "temp", ir_var_temporary);
+      new(ir) ir_variable(glsl_uvec_type(elements), "temp", ir_var_temporary);
    ir_variable *as_float =
-      new(ir) ir_variable(glsl_type::vec(elements), "as_float", ir_var_temporary);
+      new(ir) ir_variable(glsl_vec_type(elements), "as_float", ir_var_temporary);
    ir_variable *msb =
-      new(ir) ir_variable(glsl_type::ivec(elements), "msb", ir_var_temporary);
+      new(ir) ir_variable(glsl_ivec_type(elements), "msb", ir_var_temporary);
 
    ir_instruction &i = *base_ir;
 
@@ -283,7 +283,7 @@ lower_instructions_visitor::find_msb_to_float_cast(ir_expression *ir)
        * logical-not can be achieved in two instructions.
        */
       ir_variable *as_int =
-         new(ir) ir_variable(glsl_type::ivec(elements), "as_int", ir_var_temporary);
+         new(ir) ir_variable(glsl_ivec_type(elements), "as_int", ir_var_temporary);
       ir_constant *c31 = new(ir) ir_constant(int(31), elements);
 
       i.insert_before(as_int);
@@ -372,25 +372,25 @@ lower_instructions_visitor::imul_high_to_mul(ir_expression *ir)
     */
    const unsigned elements = ir->operands[0]->type->vector_elements;
    ir_variable *src1 =
-      new(ir) ir_variable(glsl_type::uvec(elements), "src1", ir_var_temporary);
+      new(ir) ir_variable(glsl_uvec_type(elements), "src1", ir_var_temporary);
    ir_variable *src1h =
-      new(ir) ir_variable(glsl_type::uvec(elements), "src1h", ir_var_temporary);
+      new(ir) ir_variable(glsl_uvec_type(elements), "src1h", ir_var_temporary);
    ir_variable *src1l =
-      new(ir) ir_variable(glsl_type::uvec(elements), "src1l", ir_var_temporary);
+      new(ir) ir_variable(glsl_uvec_type(elements), "src1l", ir_var_temporary);
    ir_variable *src2 =
-      new(ir) ir_variable(glsl_type::uvec(elements), "src2", ir_var_temporary);
+      new(ir) ir_variable(glsl_uvec_type(elements), "src2", ir_var_temporary);
    ir_variable *src2h =
-      new(ir) ir_variable(glsl_type::uvec(elements), "src2h", ir_var_temporary);
+      new(ir) ir_variable(glsl_uvec_type(elements), "src2h", ir_var_temporary);
    ir_variable *src2l =
-      new(ir) ir_variable(glsl_type::uvec(elements), "src2l", ir_var_temporary);
+      new(ir) ir_variable(glsl_uvec_type(elements), "src2l", ir_var_temporary);
    ir_variable *t1 =
-      new(ir) ir_variable(glsl_type::uvec(elements), "t1", ir_var_temporary);
+      new(ir) ir_variable(glsl_uvec_type(elements), "t1", ir_var_temporary);
    ir_variable *t2 =
-      new(ir) ir_variable(glsl_type::uvec(elements), "t2", ir_var_temporary);
+      new(ir) ir_variable(glsl_uvec_type(elements), "t2", ir_var_temporary);
    ir_variable *lo =
-      new(ir) ir_variable(glsl_type::uvec(elements), "lo", ir_var_temporary);
+      new(ir) ir_variable(glsl_uvec_type(elements), "lo", ir_var_temporary);
    ir_variable *hi =
-      new(ir) ir_variable(glsl_type::uvec(elements), "hi", ir_var_temporary);
+      new(ir) ir_variable(glsl_uvec_type(elements), "hi", ir_var_temporary);
    ir_variable *different_signs = NULL;
    ir_constant *c0000FFFF = new(ir) ir_constant(0x0000FFFFu, elements);
    ir_constant *c16 = new(ir) ir_constant(16u, elements);
@@ -411,9 +411,9 @@ lower_instructions_visitor::imul_high_to_mul(ir_expression *ir)
       assert(ir->operands[0]->type->base_type == GLSL_TYPE_INT);
 
       ir_variable *itmp1 =
-         new(ir) ir_variable(glsl_type::ivec(elements), "itmp1", ir_var_temporary);
+         new(ir) ir_variable(glsl_ivec_type(elements), "itmp1", ir_var_temporary);
       ir_variable *itmp2 =
-         new(ir) ir_variable(glsl_type::ivec(elements), "itmp2", ir_var_temporary);
+         new(ir) ir_variable(glsl_ivec_type(elements), "itmp2", ir_var_temporary);
       ir_constant *c0 = new(ir) ir_constant(int(0), elements);
 
       i.insert_before(itmp1);
@@ -422,7 +422,7 @@ lower_instructions_visitor::imul_high_to_mul(ir_expression *ir)
       i.insert_before(assign(itmp2, ir->operands[1]));
 
       different_signs =
-         new(ir) ir_variable(glsl_type::bvec(elements), "different_signs",
+         new(ir) ir_variable(glsl_bvec_type(elements), "different_signs",
                              ir_var_temporary);
 
       i.insert_before(different_signs);
@@ -474,7 +474,7 @@ lower_instructions_visitor::imul_high_to_mul(ir_expression *ir)
        * -1, not -0!  Recall -x == ~x + 1.
        */
       ir_variable *neg_hi =
-         new(ir) ir_variable(glsl_type::ivec(elements), "neg_hi", ir_var_temporary);
+         new(ir) ir_variable(glsl_ivec_type(elements), "neg_hi", ir_var_temporary);
       ir_constant *c1 = new(ir) ir_constant(1u, elements);
 
       i.insert_before(neg_hi);
@@ -494,11 +494,11 @@ lower_instructions_visitor::visit_leave(ir_expression *ir)
 {
    switch (ir->operation) {
    case ir_binop_dot:
-      if (ir->operands[0]->type->is_double())
+      if (glsl_type_is_double(ir->operands[0]->type))
          double_dot_to_fma(ir);
       break;
    case ir_triop_lrp:
-      if (ir->operands[0]->type->is_double())
+      if (glsl_type_is_double(ir->operands[0]->type))
          double_lrp(ir);
       break;
 
diff --git a/src/compiler/glsl/lower_jumps.cpp b/src/compiler/glsl/lower_jumps.cpp
index 9f12aef6e9618..f6efb9d78b8ac 100644
--- a/src/compiler/glsl/lower_jumps.cpp
+++ b/src/compiler/glsl/lower_jumps.cpp
@@ -225,7 +225,7 @@ struct function_record
    ir_variable* get_return_value()
    {
       if(!this->return_value) {
-         assert(!this->signature->return_type->is_void());
+         assert(!glsl_type_is_void(this->signature->return_type));
          return_value = new(this->signature) ir_variable(this->signature->return_type, "return_value", ir_var_temporary);
          this->signature->body.push_head(this->return_value);
       }
@@ -305,7 +305,7 @@ struct ir_lower_jumps_visitor : public ir_control_flow_visitor {
    void insert_lowered_return(ir_return *ir)
    {
       ir_variable* return_flag = this->function.get_return_flag();
-      if(!this->function.signature->return_type->is_void()) {
+      if(!glsl_type_is_void(this->function.signature->return_type)) {
          ir_variable* return_value = this->function.get_return_value();
          ir->insert_before(
             new(ir) ir_assignment(
@@ -515,7 +515,7 @@ retry: /* we get here if we put code after the if inside a branch */
             else if(jump_strengths[0] == strength_break)
                ir->insert_after(new(ir) ir_loop_jump(ir_loop_jump::jump_break));
             /* FINISHME: unify returns with identical expressions */
-            else if(jump_strengths[0] == strength_return && this->function.signature->return_type->is_void())
+            else if(jump_strengths[0] == strength_return && glsl_type_is_void(this->function.signature->return_type))
                ir->insert_after(new(ir) ir_return(NULL));
 	    else
 	       unify = false;
@@ -846,7 +846,7 @@ lower_continue:
             /* In case the loop is embedded inside an if add a new return to
              * the return flag then branch and let a future pass tidy it up.
              */
-            if (this->function.signature->return_type->is_void())
+            if (glsl_type_is_void(this->function.signature->return_type))
                return_if->then_instructions.push_tail(new(ir) ir_return(NULL));
             else {
                assert(this->function.return_value);
@@ -895,7 +895,7 @@ lower_continue:
        * If the body ended in a return of void, eliminate it because
        * it is redundant.
        */
-      if (ir->return_type->is_void() &&
+      if (glsl_type_is_void(ir->return_type) &&
           get_jump_strength((ir_instruction *) ir->body.get_tail())) {
          ir_jump *jump = (ir_jump *) ir->body.get_tail();
          assert (jump->ir_type == ir_type_return);
diff --git a/src/compiler/glsl/lower_mat_op_to_vec.cpp b/src/compiler/glsl/lower_mat_op_to_vec.cpp
index 61acea6ab2ad4..6aac4e7b3cb2a 100644
--- a/src/compiler/glsl/lower_mat_op_to_vec.cpp
+++ b/src/compiler/glsl/lower_mat_op_to_vec.cpp
@@ -77,7 +77,7 @@ mat_op_to_vec_predicate(ir_instruction *ir)
       return false;
 
    for (i = 0; i < expr->num_operands; i++) {
-      if (expr->operands[i]->type->is_matrix())
+      if (glsl_type_is_matrix(expr->operands[i]->type))
          return true;
    }
 
@@ -113,7 +113,7 @@ ir_mat_op_to_vec_visitor::get_column(ir_dereference *val, int row)
 {
    val = val->clone(mem_ctx, NULL);
 
-   if (val->type->is_matrix()) {
+   if (glsl_type_is_matrix(val->type)) {
       val = new(mem_ctx) ir_dereference_array(val,
                                               new(mem_ctx) ir_constant(row));
    }
@@ -254,7 +254,7 @@ ir_mat_op_to_vec_visitor::do_equal_mat_mat(ir_dereference *result,
     */
    const unsigned columns = a->type->matrix_columns;
    const glsl_type *const bvec_type =
-      glsl_type::get_instance(GLSL_TYPE_BOOL, columns, 1);
+      glsl_simple_type(GLSL_TYPE_BOOL, columns, 1);
 
    ir_variable *const tmp_bvec =
       new(this->mem_ctx) ir_variable(bvec_type, "mat_cmp_bvec",
@@ -295,7 +295,7 @@ static bool
 has_matrix_operand(const ir_expression *expr, unsigned &columns)
 {
    for (unsigned i = 0; i < expr->num_operands; i++) {
-      if (expr->operands[i]->type->is_matrix()) {
+      if (glsl_type_is_matrix(expr->operands[i]->type)) {
          columns = expr->operands[i]->type->matrix_columns;
          return true;
       }
@@ -403,21 +403,21 @@ ir_mat_op_to_vec_visitor::visit_leave(ir_assignment *orig_assign)
       break;
    }
    case ir_binop_mul:
-      if (op[0]->type->is_matrix()) {
-         if (op[1]->type->is_matrix()) {
+      if (glsl_type_is_matrix(op[0]->type)) {
+         if (glsl_type_is_matrix(op[1]->type)) {
             do_mul_mat_mat(result, op[0], op[1]);
-         } else if (op[1]->type->is_vector()) {
+         } else if (glsl_type_is_vector(op[1]->type)) {
             do_mul_mat_vec(result, op[0], op[1]);
          } else {
-            assert(op[1]->type->is_scalar());
+            assert(glsl_type_is_scalar(op[1]->type));
             do_mul_mat_scalar(result, op[0], op[1]);
          }
       } else {
-         assert(op[1]->type->is_matrix());
-         if (op[0]->type->is_vector()) {
+         assert(glsl_type_is_matrix(op[1]->type));
+         if (glsl_type_is_vector(op[0]->type)) {
             do_mul_vec_mat(result, op[0], op[1]);
          } else {
-            assert(op[0]->type->is_scalar());
+            assert(glsl_type_is_scalar(op[0]->type));
             do_mul_mat_scalar(result, op[1], op[0]);
          }
       }
diff --git a/src/compiler/glsl/lower_precision.cpp b/src/compiler/glsl/lower_precision.cpp
index 132ac9c0720b6..a41515aeba198 100644
--- a/src/compiler/glsl/lower_precision.cpp
+++ b/src/compiler/glsl/lower_precision.cpp
@@ -155,7 +155,7 @@ can_lower_type(const struct gl_shader_compiler_options *options,
     * boolean types so that it will do comparisons as 16-bit.
     */
 
-   switch (type->without_array()->base_type) {
+   switch (glsl_without_array(type)->base_type) {
    /* TODO: should we do anything for these two with regard to Int16 vs FP16
     * support?
     */
@@ -421,7 +421,7 @@ handle_call(ir_call *ir, const struct set *lowerable_rvalues)
       ir_variable *resource = param->variable_referenced();
 
       assert(ir->callee->return_precision == GLSL_PRECISION_HIGH);
-      assert(resource->type->without_array()->is_image());
+      assert(glsl_type_is_image(glsl_without_array(resource->type)));
 
       /* GLSL ES 3.20 requires that images have a precision modifier, but if
        * you set one, it doesn't do anything, because all intrinsics are
@@ -464,7 +464,7 @@ handle_call(ir_call *ir, const struct set *lowerable_rvalues)
        * We should lower the type of the return value if the sampler type
        * uses lower precision. The function parameters don't matter.
        */
-      if (var && var->type->without_array()->is_sampler()) {
+      if (var && glsl_type_is_sampler(glsl_without_array(var->type))) {
          /* textureGatherOffsets always takes a highp array of constants. As
           * per the discussion https://gitlab.freedesktop.org/mesa/mesa/-/merge_requests/16547#note_1393704
           * trying to lower the precision results in segfault later on
@@ -612,10 +612,10 @@ find_lowerable_rvalues(const struct gl_shader_compiler_options *options,
 static const glsl_type *
 convert_type(bool up, const glsl_type *type)
 {
-   if (type->is_array()) {
-      return glsl_type::get_array_instance(convert_type(up, type->fields.array),
-                                           type->array_size(),
-                                           type->explicit_stride);
+   if (glsl_type_is_array(type)) {
+      return glsl_array_type(convert_type(up, type->fields.array),
+                             glsl_array_size(type),
+                             type->explicit_stride);
    }
 
    glsl_base_type new_base_type;
@@ -652,11 +652,12 @@ convert_type(bool up, const glsl_type *type)
       }
    }
 
-   return glsl_type::get_instance(new_base_type,
-                                  type->vector_elements,
-                                  type->matrix_columns,
-                                  type->explicit_stride,
-                                  type->interface_row_major);
+   return glsl_simple_explicit_type(new_base_type,
+                                    type->vector_elements,
+                                    type->matrix_columns,
+                                    type->explicit_stride,
+                                    type->interface_row_major,
+                                    0 /* explicit_alignment */);
 }
 
 static const glsl_type *
@@ -716,9 +717,9 @@ lower_precision_visitor::handle_rvalue(ir_rvalue **rvalue)
       return;
 
    if (ir->as_dereference()) {
-      if (!ir->type->is_boolean())
+      if (!glsl_type_is_boolean(ir->type))
          *rvalue = convert_precision(false, ir);
-   } else if (ir->type->is_32bit()) {
+   } else if (glsl_type_is_32bit(ir->type)) {
       ir->type = lower_glsl_type(ir->type);
 
       ir_constant *const_ir = ir->as_constant();
@@ -975,8 +976,8 @@ public:
 static void
 lower_constant(ir_constant *ir)
 {
-   if (ir->type->is_array()) {
-      for (int i = 0; i < ir->type->array_size(); i++)
+   if (glsl_type_is_array(ir->type)) {
+      for (int i = 0; i < glsl_array_size(ir->type); i++)
          lower_constant(ir->get_array_element(i));
 
       ir->type = lower_glsl_type(ir->type);
@@ -1011,8 +1012,8 @@ lower_variables_visitor::visit(ir_variable *var)
         (var->data.mode != ir_var_uniform ||
          var->is_in_buffer_block() ||
          !(options->LowerPrecisionFloat16Uniforms &&
-           var->type->without_array()->base_type == GLSL_TYPE_FLOAT))) ||
-       !var->type->without_array()->is_32bit() ||
+           glsl_without_array(var->type)->base_type == GLSL_TYPE_FLOAT))) ||
+       !glsl_type_is_32bit(glsl_without_array(var->type)) ||
        (var->data.precision != GLSL_PRECISION_MEDIUM &&
         var->data.precision != GLSL_PRECISION_LOW) ||
        !can_lower_type(options, var->type))
@@ -1046,7 +1047,7 @@ lower_variables_visitor::visit(ir_variable *var)
 void
 lower_variables_visitor::fix_types_in_deref_chain(ir_dereference *ir)
 {
-   assert(ir->type->without_array()->is_32bit());
+   assert(glsl_type_is_32bit(glsl_without_array(ir->type)));
    assert(_mesa_set_search(lower_vars, ir->variable_referenced()));
 
    /* Fix the type in the dereference node. */
@@ -1056,7 +1057,7 @@ lower_variables_visitor::fix_types_in_deref_chain(ir_dereference *ir)
    for (ir_dereference_array *deref_array = ir->as_dereference_array();
         deref_array;
         deref_array = deref_array->array->as_dereference_array()) {
-      assert(deref_array->array->type->without_array()->is_32bit());
+      assert(glsl_type_is_32bit(glsl_without_array(deref_array->array->type)));
       deref_array->array->type = lower_glsl_type(deref_array->array->type);
    }
 }
@@ -1068,7 +1069,7 @@ lower_variables_visitor::convert_split_assignment(ir_dereference *lhs,
 {
    void *mem_ctx = ralloc_parent(lhs);
 
-   if (lhs->type->is_array()) {
+   if (glsl_type_is_array(lhs->type)) {
       for (unsigned i = 0; i < lhs->type->length; i++) {
          ir_dereference *l, *r;
 
@@ -1081,12 +1082,12 @@ lower_variables_visitor::convert_split_assignment(ir_dereference *lhs,
       return;
    }
 
-   assert(lhs->type->is_16bit() || lhs->type->is_32bit());
-   assert(rhs->type->is_16bit() || rhs->type->is_32bit());
-   assert(lhs->type->is_16bit() != rhs->type->is_16bit());
+   assert(glsl_type_is_16bit(lhs->type) || glsl_type_is_32bit(lhs->type));
+   assert(glsl_type_is_16bit(rhs->type) || glsl_type_is_32bit(rhs->type));
+   assert(glsl_type_is_16bit(lhs->type) != glsl_type_is_16bit(rhs->type));
 
    ir_assignment *assign =
-      new(mem_ctx) ir_assignment(lhs, convert_precision(lhs->type->is_32bit(), rhs));
+      new(mem_ctx) ir_assignment(lhs, convert_precision(glsl_type_is_32bit(lhs->type), rhs));
 
    if (insert_before)
       base_ir->insert_before(assign);
@@ -1104,17 +1105,17 @@ lower_variables_visitor::visit_enter(ir_assignment *ir)
    ir_constant *rhs_const = ir->rhs->as_constant();
 
    /* Legalize array assignments between lowered and non-lowered variables. */
-   if (lhs->type->is_array() &&
+   if (glsl_type_is_array(lhs->type) &&
        (rhs_var || rhs_const) &&
        (!rhs_var ||
         (var &&
-         var->type->without_array()->is_16bit() !=
-         rhs_var->type->without_array()->is_16bit())) &&
+         glsl_type_is_16bit(glsl_without_array(var->type)) !=
+         glsl_type_is_16bit(glsl_without_array(rhs_var->type)))) &&
        (!rhs_const ||
         (var &&
-         var->type->without_array()->is_16bit() &&
-         rhs_const->type->without_array()->is_32bit()))) {
-      assert(ir->rhs->type->is_array());
+         glsl_type_is_16bit(glsl_without_array(var->type)) &&
+         glsl_type_is_32bit(glsl_without_array(rhs_const->type))))) {
+      assert(glsl_type_is_array(ir->rhs->type));
 
       /* Fix array assignments from lowered to non-lowered. */
       if (rhs_var && _mesa_set_search(lower_vars, rhs_var)) {
@@ -1128,7 +1129,7 @@ lower_variables_visitor::visit_enter(ir_assignment *ir)
       /* Fix array assignments from non-lowered to lowered. */
       if (var &&
           _mesa_set_search(lower_vars, var) &&
-          ir->rhs->type->without_array()->is_32bit()) {
+          glsl_type_is_32bit(glsl_without_array(ir->rhs->type))) {
          fix_types_in_deref_chain(lhs);
          /* Convert to 16 bits for LHS. */
          convert_split_assignment(lhs, ir->rhs, true);
@@ -1141,17 +1142,17 @@ lower_variables_visitor::visit_enter(ir_assignment *ir)
    if (var &&
        _mesa_set_search(lower_vars, var)) {
       /* Fix the LHS type. */
-      if (lhs->type->without_array()->is_32bit())
+      if (glsl_type_is_32bit(glsl_without_array(lhs->type)))
          fix_types_in_deref_chain(lhs);
 
       /* Fix the RHS type if it's a lowered variable. */
       if (rhs_var &&
           _mesa_set_search(lower_vars, rhs_var) &&
-          rhs_deref->type->without_array()->is_32bit())
+          glsl_type_is_32bit(glsl_without_array(rhs_deref->type)))
          fix_types_in_deref_chain(rhs_deref);
 
       /* Fix the RHS type if it's a non-array expression. */
-      if (ir->rhs->type->is_32bit()) {
+      if (glsl_type_is_32bit(ir->rhs->type)) {
          ir_expression *expr = ir->rhs->as_expression();
 
          /* Convert the RHS to the LHS type. */
@@ -1159,7 +1160,7 @@ lower_variables_visitor::visit_enter(ir_assignment *ir)
              (expr->operation == ir_unop_f162f ||
               expr->operation == ir_unop_i2i ||
               expr->operation == ir_unop_u2u) &&
-             expr->operands[0]->type->is_16bit()) {
+             glsl_type_is_16bit(expr->operands[0]->type)) {
             /* If there is an "up" conversion, just remove it.
              * This is optional. We could as well execute the else statement and
              * let NIR eliminate the up+down conversions.
@@ -1187,7 +1188,7 @@ lower_variables_visitor::visit_enter(ir_return *ir)
       /* Fix the type of the return value. */
       if (var &&
           _mesa_set_search(lower_vars, var) &&
-          deref->type->without_array()->is_32bit()) {
+          glsl_type_is_32bit(glsl_without_array(deref->type))) {
          /* Create a 32-bit temporary variable. */
          ir_variable *new_var =
             new(mem_ctx) ir_variable(deref->type, "lowerp", ir_var_temporary);
@@ -1225,8 +1226,8 @@ void lower_variables_visitor::handle_rvalue(ir_rvalue **rvalue)
         expr->operation == ir_unop_f2f16 ||
         expr->operation == ir_unop_i2i ||
         expr->operation == ir_unop_u2u) &&
-       expr->type->without_array()->is_16bit() &&
-       expr_op0_deref->type->without_array()->is_32bit() &&
+       glsl_type_is_16bit(glsl_without_array(expr->type)) &&
+       glsl_type_is_32bit(glsl_without_array(expr_op0_deref->type)) &&
        expr_op0_deref->variable_referenced() &&
        _mesa_set_search(lower_vars, expr_op0_deref->variable_referenced())) {
       fix_types_in_deref_chain(expr_op0_deref);
@@ -1244,7 +1245,7 @@ void lower_variables_visitor::handle_rvalue(ir_rvalue **rvalue)
       /* var can be NULL if we are dereferencing ir_constant. */
       if (var &&
           _mesa_set_search(lower_vars, var) &&
-          deref->type->without_array()->is_32bit()) {
+          glsl_type_is_32bit(glsl_without_array(deref->type))) {
          void *mem_ctx = ralloc_parent(ir);
 
          /* Create a 32-bit temporary variable. */
@@ -1283,7 +1284,7 @@ lower_variables_visitor::visit_enter(ir_call *ir)
       /* var can be NULL if we are dereferencing ir_constant. */
       if (var &&
           _mesa_set_search(lower_vars, var) &&
-          param->type->without_array()->is_32bit()) {
+          glsl_type_is_32bit(glsl_without_array(param->type))) {
          fix_types_in_deref_chain(param_deref);
 
          /* Create a 32-bit temporary variable for the parameter. */
@@ -1316,7 +1317,7 @@ lower_variables_visitor::visit_enter(ir_call *ir)
 
    if (ret_var &&
        _mesa_set_search(lower_vars, ret_var) &&
-       ret_deref->type->without_array()->is_32bit()) {
+       glsl_type_is_32bit(glsl_without_array(ret_deref->type))) {
       /* Create a 32-bit temporary variable. */
       ir_variable *new_var =
          new(mem_ctx) ir_variable(ir->callee->return_type, "lowerp",
diff --git a/src/compiler/glsl/lower_subroutine.cpp b/src/compiler/glsl/lower_subroutine.cpp
index de178a59b07a2..810ada76ce4dd 100644
--- a/src/compiler/glsl/lower_subroutine.cpp
+++ b/src/compiler/glsl/lower_subroutine.cpp
@@ -93,7 +93,7 @@ lower_subroutine_visitor::visit_leave(ir_call *ir)
       bool is_compat = false;
 
       for (int i = 0; i < fn->num_subroutine_types; i++) {
-         if (ir->sub_var->type->without_array() == fn->subroutine_types[i]) {
+         if (glsl_without_array(ir->sub_var->type) == fn->subroutine_types[i]) {
             is_compat = true;
             break;
          }
diff --git a/src/compiler/glsl/lower_vector_derefs.cpp b/src/compiler/glsl/lower_vector_derefs.cpp
index fb081aba3e600..c027ceb130078 100644
--- a/src/compiler/glsl/lower_vector_derefs.cpp
+++ b/src/compiler/glsl/lower_vector_derefs.cpp
@@ -60,7 +60,7 @@ vector_deref_visitor::visit_enter(ir_assignment *ir)
       return ir_rvalue_enter_visitor::visit_enter(ir);
 
    ir_dereference_array *const deref = (ir_dereference_array *) ir->lhs;
-   if (!deref->array->type->is_vector())
+   if (!glsl_type_is_vector(deref->array->type))
       return ir_rvalue_enter_visitor::visit_enter(ir);
 
    /* SSBOs and shared variables are backed by memory and may be accessed by
@@ -172,7 +172,7 @@ vector_deref_visitor::handle_rvalue(ir_rvalue **rv)
       return;
 
    ir_dereference_array *const deref = (ir_dereference_array *) *rv;
-   if (!deref->array->type->is_vector())
+   if (!glsl_type_is_vector(deref->array->type))
       return;
 
    /* Back-ends need to be able to handle derefs on vectors for SSBOs, UBOs,
diff --git a/src/compiler/glsl/opt_algebraic.cpp b/src/compiler/glsl/opt_algebraic.cpp
index 732055943daba..3f13a66bebbda 100644
--- a/src/compiler/glsl/opt_algebraic.cpp
+++ b/src/compiler/glsl/opt_algebraic.cpp
@@ -106,7 +106,7 @@ is_valid_vec_const(ir_constant *ir)
    if (ir == NULL)
       return false;
 
-   if (!ir->type->is_scalar() && !ir->type->is_vector())
+   if (!glsl_type_is_scalar(ir->type) && !glsl_type_is_vector(ir->type))
       return false;
 
    return true;
@@ -115,7 +115,7 @@ is_valid_vec_const(ir_constant *ir)
 static inline bool
 is_less_than_one(ir_constant *ir)
 {
-   assert(ir->type->is_float());
+   assert(glsl_type_is_float(ir->type));
 
    if (!is_valid_vec_const(ir))
       return false;
@@ -132,7 +132,7 @@ is_less_than_one(ir_constant *ir)
 static inline bool
 is_greater_than_zero(ir_constant *ir)
 {
-   assert(ir->type->is_float());
+   assert(glsl_type_is_float(ir->type));
 
    if (!is_valid_vec_const(ir))
       return false;
@@ -149,7 +149,7 @@ is_greater_than_zero(ir_constant *ir)
 static void
 update_type(ir_expression *ir)
 {
-   if (ir->operands[0]->type->is_vector())
+   if (glsl_type_is_vector(ir->operands[0]->type))
       ir->type = ir->operands[0]->type;
    else
       ir->type = ir->operands[1]->type;
@@ -188,10 +188,10 @@ ir_algebraic_visitor::reassociate_constant(ir_expression *ir1, int const_index,
       return false;
 
    /* Don't want to even think about matrices. */
-   if (ir1->operands[0]->type->is_matrix() ||
-       ir1->operands[1]->type->is_matrix() ||
-       ir2->operands[0]->type->is_matrix() ||
-       ir2->operands[1]->type->is_matrix())
+   if (glsl_type_is_matrix(ir1->operands[0]->type) ||
+       glsl_type_is_matrix(ir1->operands[1]->type) ||
+       glsl_type_is_matrix(ir2->operands[0]->type) ||
+       glsl_type_is_matrix(ir2->operands[1]->type))
       return false;
 
    void *mem_ctx = ralloc_parent(ir2);
@@ -234,7 +234,7 @@ ir_rvalue *
 ir_algebraic_visitor::swizzle_if_required(ir_expression *expr,
 					  ir_rvalue *operand)
 {
-   if (expr->type->is_vector() && operand->type->is_scalar()) {
+   if (glsl_type_is_vector(expr->type) && glsl_type_is_scalar(operand->type)) {
       return new(mem_ctx) ir_swizzle(operand, 0, 0, 0, 0,
 				     expr->type->vector_elements);
    } else
@@ -248,13 +248,13 @@ ir_algebraic_visitor::handle_expression(ir_expression *ir)
    ir_expression *op_expr[4] = {NULL, NULL, NULL, NULL};
 
    if (ir->operation == ir_binop_mul &&
-       ir->operands[0]->type->is_matrix() &&
-       ir->operands[1]->type->is_vector()) {
+       glsl_type_is_matrix(ir->operands[0]->type) &&
+       glsl_type_is_vector(ir->operands[1]->type)) {
       ir_expression *matrix_mul = ir->operands[0]->as_expression();
 
       if (matrix_mul && matrix_mul->operation == ir_binop_mul &&
-         matrix_mul->operands[0]->type->is_matrix() &&
-         matrix_mul->operands[1]->type->is_matrix()) {
+         glsl_type_is_matrix(matrix_mul->operands[0]->type) &&
+         glsl_type_is_matrix(matrix_mul->operands[1]->type)) {
 
          return mul(matrix_mul->operands[0],
                     mul(matrix_mul->operands[1], ir->operands[1]));
@@ -263,7 +263,7 @@ ir_algebraic_visitor::handle_expression(ir_expression *ir)
 
    assert(ir->num_operands <= 4);
    for (unsigned i = 0; i < ir->num_operands; i++) {
-      if (ir->operands[i]->type->is_matrix())
+      if (glsl_type_is_matrix(ir->operands[i]->type))
 	 return ir;
 
       op_const[i] =
@@ -298,7 +298,7 @@ ir_algebraic_visitor::handle_expression(ir_expression *ir)
 
    case ir_binop_min:
    case ir_binop_max:
-      if (!ir->type->is_float())
+      if (!glsl_type_is_float(ir->type))
          break;
 
       /* Replace min(max) operations and its commutative combinations with
diff --git a/src/compiler/glsl/opt_dead_code.cpp b/src/compiler/glsl/opt_dead_code.cpp
index c8b31b490cadf..fa6ec846ee616 100644
--- a/src/compiler/glsl/opt_dead_code.cpp
+++ b/src/compiler/glsl/opt_dead_code.cpp
@@ -140,7 +140,7 @@ do_dead_code(exec_list *instructions)
                }
             }
 
-            if (entry->var->type->is_subroutine())
+            if (glsl_type_is_subroutine(entry->var->type))
                continue;
          }
 
diff --git a/src/compiler/glsl/opt_dead_code_local.cpp b/src/compiler/glsl/opt_dead_code_local.cpp
index 40736ce170e0f..5899a5215ee8e 100644
--- a/src/compiler/glsl/opt_dead_code_local.cpp
+++ b/src/compiler/glsl/opt_dead_code_local.cpp
@@ -77,7 +77,7 @@ public:
    {
       foreach_in_list_safe(assignment_entry, entry, this->assignments) {
 	 if (entry->lhs == var) {
-	    if (var->type->is_scalar() || var->type->is_vector()) {
+	    if (glsl_type_is_scalar(var->type) || glsl_type_is_vector(var->type)) {
 	       if (debug)
 		  printf("used %s (0x%01x - 0x%01x)\n", entry->lhs->name,
 			 entry->unused, used & 0xf);
@@ -199,8 +199,8 @@ process_assignment(linear_ctx *lin_ctx, ir_assignment *ir, exec_list *assignment
    /* If it's a vector type, we can do per-channel elimination of
     * use of the RHS.
     */
-   if (deref_var && (deref_var->var->type->is_scalar() ||
-                     deref_var->var->type->is_vector())) {
+   if (deref_var && (glsl_type_is_scalar(deref_var->var->type) ||
+                     glsl_type_is_vector(deref_var->var->type))) {
 
       if (debug)
          printf("looking for %s.0x%01x to remove\n", var->name,
diff --git a/src/compiler/glsl/opt_flip_matrices.cpp b/src/compiler/glsl/opt_flip_matrices.cpp
index 04c6170b845ba..4b36d6ffdd38a 100644
--- a/src/compiler/glsl/opt_flip_matrices.cpp
+++ b/src/compiler/glsl/opt_flip_matrices.cpp
@@ -70,8 +70,8 @@ ir_visitor_status
 matrix_flipper::visit_enter(ir_expression *ir)
 {
    if (ir->operation != ir_binop_mul ||
-       !ir->operands[0]->type->is_matrix() ||
-       !ir->operands[1]->type->is_vector())
+       !glsl_type_is_matrix(ir->operands[0]->type) ||
+       !glsl_type_is_vector(ir->operands[1]->type))
       return visit_continue;
 
    ir_variable *mat_var = ir->operands[0]->variable_referenced();
diff --git a/src/compiler/glsl/opt_function_inlining.cpp b/src/compiler/glsl/opt_function_inlining.cpp
index 56ac90c07ccbc..411d76efe4aed 100644
--- a/src/compiler/glsl/opt_function_inlining.cpp
+++ b/src/compiler/glsl/opt_function_inlining.cpp
@@ -143,7 +143,7 @@ should_replace_variable(ir_variable *sig_param, ir_rvalue *param,
    /* Some places in glsl_to_nir() expect images to always be copied to a temp
     * first.
     */
-   if (sig_param->type->without_array()->is_image() && !param->is_dereference())
+   if (glsl_type_is_image(glsl_without_array(sig_param->type)) && !param->is_dereference())
       return false;
 
    /* SSBO and shared vars might be passed to a built-in such as an atomic
@@ -163,7 +163,7 @@ should_replace_variable(ir_variable *sig_param, ir_rvalue *param,
     * the location information, which an assignment of an opaque
     * variable wouldn't.
     */
-   return sig_param->type->contains_opaque();
+   return glsl_contains_opaque(sig_param->type);
 }
 
 void
diff --git a/src/compiler/glsl/opt_minmax.cpp b/src/compiler/glsl/opt_minmax.cpp
index 9f20ff87f22bf..159e3025072cf 100644
--- a/src/compiler/glsl/opt_minmax.cpp
+++ b/src/compiler/glsl/opt_minmax.cpp
@@ -98,9 +98,9 @@ compare_components(ir_constant *a, ir_constant *b)
 
    assert(a->type->base_type == b->type->base_type);
 
-   unsigned a_inc = a->type->is_scalar() ? 0 : 1;
-   unsigned b_inc = b->type->is_scalar() ? 0 : 1;
-   unsigned components = MAX2(a->type->components(), b->type->components());
+   unsigned a_inc = glsl_type_is_scalar(a->type) ? 0 : 1;
+   unsigned b_inc = glsl_type_is_scalar(b->type) ? 0 : 1;
+   unsigned components = MAX2(glsl_get_components(a->type), glsl_get_components(b->type));
 
    bool foundless = false;
    bool foundgreater = false;
@@ -197,7 +197,7 @@ combine_constant(bool ismin, ir_constant *a, ir_constant *b)
 {
    void *mem_ctx = ralloc_parent(a);
    ir_constant *c = a->clone(mem_ctx, NULL);
-   for (unsigned i = 0; i < c->type->components(); i++) {
+   for (unsigned i = 0; i < glsl_get_components(c->type); i++) {
       switch (c->type->base_type) {
       case GLSL_TYPE_UINT16:
          if ((ismin && b->value.u16[i] < c->value.u16[i]) ||
@@ -490,7 +490,7 @@ ir_minmax_visitor::prune_expression(ir_expression *expr, minmax_range baserange)
 static ir_rvalue *
 swizzle_if_required(ir_expression *expr, ir_rvalue *rval)
 {
-   if (expr->type->is_vector() && rval->type->is_scalar()) {
+   if (glsl_type_is_vector(expr->type) && glsl_type_is_scalar(rval->type)) {
       return swizzle(rval, SWIZZLE_XXXX, expr->type->vector_elements);
    } else {
       return rval;
diff --git a/src/compiler/glsl/opt_rebalance_tree.cpp b/src/compiler/glsl/opt_rebalance_tree.cpp
index 3c3827e597a8d..153aac4836457 100644
--- a/src/compiler/glsl/opt_rebalance_tree.cpp
+++ b/src/compiler/glsl/opt_rebalance_tree.cpp
@@ -233,9 +233,9 @@ is_reduction(ir_instruction *ir, void *data)
     * constant fold once split up. Handling matrices will need some more
     * work.
     */
-   if (expr->type->is_matrix() ||
-       expr->operands[0]->type->is_matrix() ||
-       (expr->operands[1] && expr->operands[1]->type->is_matrix())) {
+   if (glsl_type_is_matrix(expr->type) ||
+       glsl_type_is_matrix(expr->operands[0]->type) ||
+       (expr->operands[1] && glsl_type_is_matrix(expr->operands[1]->type))) {
       ird->is_reduction = false;
       return;
    }
@@ -288,10 +288,10 @@ update_types(ir_instruction *ir, void *)
       return;
 
    const glsl_type *const new_type =
-      glsl_type::get_instance(expr->type->base_type,
-                              MAX2(expr->operands[0]->type->vector_elements,
-                                   expr->operands[1]->type->vector_elements),
-                              1);
+      glsl_simple_type(expr->type->base_type,
+                       MAX2(expr->operands[0]->type->vector_elements,
+                            expr->operands[1]->type->vector_elements),
+                       1);
    assert(new_type != &glsl_type_builtin_error);
    expr->type = new_type;
 }
diff --git a/src/compiler/glsl/opt_tree_grafting.cpp b/src/compiler/glsl/opt_tree_grafting.cpp
index b7f5e5b47aa12..a3f8a61cb4b9d 100644
--- a/src/compiler/glsl/opt_tree_grafting.cpp
+++ b/src/compiler/glsl/opt_tree_grafting.cpp
@@ -379,7 +379,7 @@ tree_grafting_basic_block(ir_instruction *bb_first,
        * any image layout qualifiers (including the image format) are set,
        * since we must not lose those.
        */
-      if (lhs_var->type->is_sampler() || lhs_var->type->is_image())
+      if (glsl_type_is_sampler(lhs_var->type) || glsl_type_is_image(lhs_var->type))
          continue;
 
       ir_variable_refcount_entry *entry = info->refs->get_variable_entry(lhs_var);
diff --git a/src/compiler/glsl/serialize.cpp b/src/compiler/glsl/serialize.cpp
index 9e7a50ebea932..74fcc88f698d7 100644
--- a/src/compiler/glsl/serialize.cpp
+++ b/src/compiler/glsl/serialize.cpp
@@ -480,7 +480,7 @@ write_uniforms(struct blob *metadata, struct gl_shader_program *prog)
    for (unsigned i = 0; i < prog->data->NumUniformStorage; i++) {
       if (has_uniform_storage(prog, i)) {
          unsigned vec_size =
-            prog->data->UniformStorage[i].type->component_slots() *
+            glsl_get_component_slots(prog->data->UniformStorage[i].type) *
             MAX2(prog->data->UniformStorage[i].array_elements, 1);
          unsigned slot =
             prog->data->UniformStorage[i].storage -
@@ -550,7 +550,7 @@ read_uniforms(struct blob_reader *metadata, struct gl_shader_program *prog)
    for (unsigned i = 0; i < prog->data->NumUniformStorage; i++) {
       if (has_uniform_storage(prog, i)) {
          unsigned vec_size =
-            prog->data->UniformStorage[i].type->component_slots() *
+            glsl_get_component_slots(prog->data->UniformStorage[i].type) *
             MAX2(prog->data->UniformStorage[i].array_elements, 1);
          unsigned slot =
             prog->data->UniformStorage[i].storage -
diff --git a/src/compiler/glsl/tests/array_refcount_test.cpp b/src/compiler/glsl/tests/array_refcount_test.cpp
index 6603439766abf..72fa743256caa 100644
--- a/src/compiler/glsl/tests/array_refcount_test.cpp
+++ b/src/compiler/glsl/tests/array_refcount_test.cpp
@@ -102,13 +102,13 @@ array_refcount_test::SetUp()
 
    /* The type of vec4 x[3][4][5]; */
    const glsl_type *const array_5_of_vec4 =
-      glsl_type::get_array_instance(&glsl_type_builtin_vec4, 5);
+      glsl_array_type(&glsl_type_builtin_vec4, 5, 0);
    const glsl_type *const array_4_of_array_5_of_vec4 =
-      glsl_type::get_array_instance(array_5_of_vec4, 4);
+      glsl_array_type(array_5_of_vec4, 4, 0);
    array_3_of_array_4_of_array_5_of_vec4 =
-      glsl_type::get_array_instance(array_4_of_array_5_of_vec4, 3);
+      glsl_array_type(array_4_of_array_5_of_vec4, 3, 0);
 
-   array_3_of_int = glsl_type::get_array_instance(&glsl_type_builtin_int, 3);
+   array_3_of_int = glsl_array_type(&glsl_type_builtin_int, 3, 0);
 }
 
 void
@@ -255,7 +255,7 @@ TEST_F(array_refcount_test, ir_array_refcount_entry_initial_state_for_array)
       new(mem_ctx) ir_variable(array_3_of_array_4_of_array_5_of_vec4,
                                "a",
                                ir_var_auto);
-   const unsigned total_elements = var->type->arrays_of_arrays_size();
+   const unsigned total_elements = glsl_get_aoa_size(var->type);
 
    ir_array_refcount_entry entry(var);
 
@@ -274,7 +274,7 @@ TEST_F(array_refcount_test, mark_array_elements_referenced_simple)
       new(mem_ctx) ir_variable(array_3_of_array_4_of_array_5_of_vec4,
                                "a",
                                ir_var_auto);
-   const unsigned total_elements = var->type->arrays_of_arrays_size();
+   const unsigned total_elements = glsl_get_aoa_size(var->type);
 
    ir_array_refcount_entry entry(var);
 
@@ -486,7 +486,7 @@ TEST_F(array_refcount_test, do_not_process_array_inside_structure)
    };
 
    const glsl_type *const record_of_array_3_of_int =
-      glsl_type::get_struct_instance(fields, ARRAY_SIZE(fields), "S");
+      glsl_struct_type(fields, ARRAY_SIZE(fields), "S", false /* packed */);
 
    ir_variable *var_a = new(mem_ctx) ir_variable(&glsl_type_builtin_int,
                                                  "a",
@@ -541,7 +541,7 @@ TEST_F(array_refcount_test, visit_simple_indexing)
 
    const unsigned accessed_element = 0 + (1 * 5) + (2 * 4 * 5);
    ir_array_refcount_entry *entry_b = v.get_variable_entry(var_b);
-   const unsigned total_elements = var_b->type->arrays_of_arrays_size();
+   const unsigned total_elements = glsl_get_aoa_size(var_b->type);
 
    for (unsigned i = 0; i < total_elements; i++)
       EXPECT_EQ(i == accessed_element, entry_b->is_linearized_index_referenced(i)) <<
@@ -636,7 +636,7 @@ TEST_F(array_refcount_test, visit_array_indexing_an_array)
 
    ir_array_refcount_entry *const entry_c = v.get_variable_entry(var_c);
 
-   for (int i = 0; i < var_c->type->array_size(); i++) {
+   for (int i = 0; i < glsl_array_size(var_c->type); i++) {
       EXPECT_EQ(true, entry_c->is_linearized_index_referenced(i)) <<
          "array c, i = " << i;
    }
@@ -647,10 +647,10 @@ TEST_F(array_refcount_test, visit_array_indexing_an_array)
 TEST_F(array_refcount_test, visit_array_indexing_with_itself)
 {
    const glsl_type *const array_2_of_array_3_of_int =
-      glsl_type::get_array_instance(array_3_of_int, 2);
+      glsl_array_type(array_3_of_int, 2, 0);
 
    const glsl_type *const array_2_of_array_2_of_array_3_of_int =
-      glsl_type::get_array_instance(array_2_of_array_3_of_int, 2);
+      glsl_array_type(array_2_of_array_3_of_int, 2, 0);
 
    ir_variable *var_a = new(mem_ctx) ir_variable(&glsl_type_builtin_int,
                                                  "a",
diff --git a/src/compiler/glsl/tests/builtin_variable_test.cpp b/src/compiler/glsl/tests/builtin_variable_test.cpp
index 6d97ce5b0ba96..1e42840ae4534 100644
--- a/src/compiler/glsl/tests/builtin_variable_test.cpp
+++ b/src/compiler/glsl/tests/builtin_variable_test.cpp
@@ -327,7 +327,7 @@ TEST_F(geometry_builtin, inputs_have_explicit_location)
          EXPECT_FALSE(var->data.explicit_location);
          EXPECT_EQ(-1, var->data.location);
 
-         ASSERT_TRUE(var->type->is_array());
+         ASSERT_TRUE(glsl_type_is_array(var->type));
 
          const glsl_type *const instance_type = var->type->fields.array;
 
diff --git a/src/compiler/glsl/tests/general_ir_test.cpp b/src/compiler/glsl/tests/general_ir_test.cpp
index bfc55a4409204..13a589571fc50 100644
--- a/src/compiler/glsl/tests/general_ir_test.cpp
+++ b/src/compiler/glsl/tests/general_ir_test.cpp
@@ -48,15 +48,15 @@ TEST_F(ir_variable_constructor, interface)
    void *mem_ctx = ralloc_context(NULL);
 
    static const glsl_struct_field f[] = {
-      glsl_struct_field(glsl_type::vec(4), "v")
+      glsl_struct_field(glsl_vec_type(4), "v")
    };
 
    const glsl_type *const iface =
-      glsl_type::get_interface_instance(f,
-                                        ARRAY_SIZE(f),
-                                        GLSL_INTERFACE_PACKING_STD140,
-                                        false,
-                                        "simple_interface");
+      glsl_interface_type(f,
+                          ARRAY_SIZE(f),
+                          GLSL_INTERFACE_PACKING_STD140,
+                          false,
+                          "simple_interface");
 
    static const char name[] = "named_instance";
 
@@ -76,18 +76,17 @@ TEST_F(ir_variable_constructor, interface_array)
    void *mem_ctx = ralloc_context(NULL);
 
    static const glsl_struct_field f[] = {
-      glsl_struct_field(glsl_type::vec(4), "v")
+      glsl_struct_field(glsl_vec_type(4), "v")
    };
 
    const glsl_type *const iface =
-      glsl_type::get_interface_instance(f,
-                                        ARRAY_SIZE(f),
-                                        GLSL_INTERFACE_PACKING_STD140,
-                                        false,
-                                        "simple_interface");
-
-   const glsl_type *const interface_array =
-      glsl_type::get_array_instance(iface, 2);
+      glsl_interface_type(f,
+                          ARRAY_SIZE(f),
+                          GLSL_INTERFACE_PACKING_STD140,
+                          false,
+                          "simple_interface");
+
+   const glsl_type *const interface_array = glsl_array_type(iface, 2, 0);
 
    static const char name[] = "array_instance";
 
diff --git a/src/compiler/glsl/tests/sampler_types_test.cpp b/src/compiler/glsl/tests/sampler_types_test.cpp
index 01d6cdd5020ab..e237986f85ee9 100644
--- a/src/compiler/glsl/tests/sampler_types_test.cpp
+++ b/src/compiler/glsl/tests/sampler_types_test.cpp
@@ -45,7 +45,7 @@ TEST(sampler_types, TYPE)                                   \
    EXPECT_EQ(DATA_TYPE, type->sampled_type);                \
    ARR;                                                     \
    SHAD;                                                    \
-   EXPECT_EQ(COMPS, type->coordinate_components());         \
+   EXPECT_EQ(COMPS, glsl_get_sampler_coordinate_components(type));         \
 }
 
 T( sampler1D,        GLSL_SAMPLER_DIM_1D,   GLSL_TYPE_FLOAT, NONARRAY, COLOR,  1)
-- 
GitLab


From 493e7ead88216471163cb730c0b93d0cc8554f4b Mon Sep 17 00:00:00 2001
From: Caio Oliveira <caio.oliveira@intel.com>
Date: Thu, 14 Dec 2023 22:21:42 -0800
Subject: [PATCH 8/9] compiler/types: Remove glsl_type C++ helpers

All code now use the C functions.  Remove glsl_type_impl.h that
contained the inline C++ wrappers around those.
---
 src/compiler/glsl_types.h      | 176 --------------------
 src/compiler/glsl_types_impl.h | 296 ---------------------------------
 src/compiler/meson.build       |   1 -
 3 files changed, 473 deletions(-)
 delete mode 100644 src/compiler/glsl_types_impl.h

diff --git a/src/compiler/glsl_types.h b/src/compiler/glsl_types.h
index f59d268d583da..e3c56aad09e4c 100644
--- a/src/compiler/glsl_types.h
+++ b/src/compiler/glsl_types.h
@@ -375,178 +375,6 @@ struct glsl_type {
       const struct glsl_type *array;            /**< Type of array elements. */
       const struct glsl_struct_field *structure;      /**< List of struct fields. */
    } fields;
-
-/* C++ parts of glsl_type. */
-#ifdef __cplusplus
-   /**
-    * Convenience accessors for vector types (shorter than get_instance()).
-    * @{
-    */
-   static const glsl_type *vec(unsigned components);
-   static const glsl_type *f16vec(unsigned components);
-   static const glsl_type *dvec(unsigned components);
-   static const glsl_type *ivec(unsigned components);
-   static const glsl_type *uvec(unsigned components);
-   static const glsl_type *bvec(unsigned components);
-   static const glsl_type *i64vec(unsigned components);
-   static const glsl_type *u64vec(unsigned components);
-   static const glsl_type *i16vec(unsigned components);
-   static const glsl_type *u16vec(unsigned components);
-   static const glsl_type *i8vec(unsigned components);
-   static const glsl_type *u8vec(unsigned components);
-   /**@}*/
-
-   const glsl_type *get_base_type() const;
-   const glsl_type *get_scalar_type() const;
-   const glsl_type *get_bare_type() const;
-   const glsl_type *get_float16_type() const;
-   const glsl_type *get_int16_type() const;
-   const glsl_type *get_uint16_type() const;
-
-   static const glsl_type *get_instance(unsigned base_type, unsigned rows,
-                                        unsigned columns,
-                                        unsigned explicit_stride = 0,
-                                        bool row_major = false,
-                                        unsigned explicit_alignment = 0);
-
-   static const glsl_type *get_sampler_instance(enum glsl_sampler_dim dim,
-                                                bool shadow,
-                                                bool array,
-                                                glsl_base_type type);
-
-   static const glsl_type *get_texture_instance(enum glsl_sampler_dim dim,
-                                                bool array,
-                                                glsl_base_type type);
-
-   static const glsl_type *get_image_instance(enum glsl_sampler_dim dim,
-                                              bool array, glsl_base_type type);
-
-   static const glsl_type *get_array_instance(const glsl_type *element,
-                                              unsigned array_size,
-                                              unsigned explicit_stride = 0);
-
-   static const glsl_type *get_cmat_instance(const struct glsl_cmat_description desc);
-
-   static const glsl_type *get_struct_instance(const glsl_struct_field *fields,
-					       unsigned num_fields,
-					       const char *name,
-					       bool packed = false,
-					       unsigned explicit_alignment = 0);
-
-   static const glsl_type *get_interface_instance(const glsl_struct_field *fields,
-						  unsigned num_fields,
-						  enum glsl_interface_packing packing,
-						  bool row_major,
-						  const char *block_name);
-
-   static const glsl_type *get_subroutine_instance(const char *subroutine_name);
-
-   static const glsl_type *get_mul_type(const glsl_type *type_a,
-                                        const glsl_type *type_b);
-
-   unsigned components() const;
-   unsigned component_slots() const;
-   unsigned component_slots_aligned(unsigned offset) const;
-   unsigned struct_location_offset(unsigned length) const;
-   unsigned uniform_locations() const;
-   unsigned varying_count() const;
-   unsigned count_vec4_slots(bool is_gl_vertex_input, bool bindless) const;
-   unsigned count_dword_slots(bool bindless) const;
-   unsigned count_attribute_slots(bool is_gl_vertex_input) const;
-   unsigned std140_base_alignment(bool row_major) const;
-   unsigned std140_size(bool row_major) const;
-   unsigned std430_base_alignment(bool row_major) const;
-   unsigned std430_array_stride(bool row_major) const;
-   unsigned std430_size(bool row_major) const;
-   unsigned cl_alignment() const;
-   unsigned cl_size() const;
-   unsigned explicit_size(bool align_to_stride=false) const;
-   unsigned arrays_of_arrays_size() const;
-   unsigned bit_size() const;
-   unsigned atomic_size() const;
-
-   int field_index(const char *name) const;
-   int array_size() const;
-   int coordinate_components() const;
-
-   const glsl_type *replace_vec3_with_vec4() const;
-   const glsl_type *get_explicit_std140_type(bool row_major) const;
-   const glsl_type *get_explicit_std430_type(bool row_major) const;
-   const glsl_type *get_explicit_interface_type(bool supports_std430) const;
-   const glsl_type *get_explicit_type_for_size_align(glsl_type_size_align_func type_info,
-                                                     unsigned *size, unsigned *alignment) const;
-   const glsl_type *without_array() const;
-   const glsl_type *row_type() const;
-   const glsl_type *column_type() const;
-
-   bool is_scalar() const;
-   bool is_vector() const;
-   bool is_matrix() const;
-   bool is_numeric() const;
-   bool is_integer() const;
-   bool is_integer_16() const;
-   bool is_integer_32() const;
-   bool is_integer_64() const;
-   bool is_integer_32_64() const;
-   bool is_integer_16_32() const;
-   bool is_integer_16_32_64() const;
-   bool is_float() const;
-   bool is_float_16_32() const;
-   bool is_float_16_32_64() const;
-   bool is_float_32_64() const;
-   bool is_int_16_32_64() const;
-   bool is_uint_16_32_64() const;
-   bool is_int_16_32() const;
-   bool is_uint_16_32() const;
-   bool is_double() const;
-   bool is_dual_slot() const;
-   bool is_64bit() const;
-   bool is_16bit() const;
-   bool is_32bit() const;
-   bool is_boolean() const;
-   bool is_sampler() const;
-   bool is_texture() const;
-   bool is_image() const;
-   bool is_array() const;
-   bool is_array_of_arrays() const;
-   bool is_cmat() const;
-   bool is_struct() const;
-   bool is_interface() const;
-   bool is_void() const;
-   bool is_error() const;
-   bool is_subroutine() const;
-   bool is_atomic_uint() const;
-   bool is_unsized_array() const;
-
-   bool contains_integer() const;
-   bool contains_double() const;
-   bool contains_64bit() const;
-   bool contains_sampler() const;
-   bool contains_array() const;
-   bool contains_image() const;
-   bool contains_subroutine() const;
-   bool contains_atomic() const;
-   bool contains_opaque() const;
-
-   bool compare_no_precision(const glsl_type *b) const;
-   bool record_compare(const glsl_type *b, bool match_name,
-                       bool match_locations = true,
-                       bool match_precision = true) const;
-
-   enum glsl_interface_packing get_interface_packing() const;
-   enum glsl_interface_packing get_internal_ifc_packing(bool std430_supported) const;
-   bool get_interface_row_major() const;
-
-   /**
-    * Get the type of a structure field
-    *
-    * \return
-    * Pointer to the type of the named field.  If the type is not a structure
-    * or the named field does not exist, \c glsl_type::error_type is returned.
-    */
-   const glsl_type *field_type(const char *name) const;
-
-#endif /* __cplusplus */
 };
 
 #include "builtin_types.h"
@@ -1527,8 +1355,4 @@ void glsl_get_vec4_size_align_bytes(const struct glsl_type *type, unsigned *size
 } /* extern "C" */
 #endif
 
-#ifdef __cplusplus
-#include "glsl_types_impl.h"
-#endif
-
 #endif /* GLSL_TYPES_H */
diff --git a/src/compiler/glsl_types_impl.h b/src/compiler/glsl_types_impl.h
deleted file mode 100644
index 104a137d0791c..0000000000000
--- a/src/compiler/glsl_types_impl.h
+++ /dev/null
@@ -1,296 +0,0 @@
-/*
- * Copyright  2009 Intel Corporation
- * SPDX-License-Identifier: MIT
- */
-
-#ifndef GLSL_TYPES_IMPL_H
-#define GLSL_TYPES_IMPL_H
-
-#ifdef __cplusplus
-
-inline bool glsl_type::is_boolean() const { return glsl_type_is_boolean(this); }
-inline bool glsl_type::is_sampler() const { return glsl_type_is_sampler(this); }
-inline bool glsl_type::is_texture() const { return glsl_type_is_texture(this); }
-inline bool glsl_type::is_image() const { return glsl_type_is_image(this); }
-inline bool glsl_type::is_array() const { return glsl_type_is_array(this); }
-inline bool glsl_type::is_struct() const { return glsl_type_is_struct(this); }
-inline bool glsl_type::is_interface() const { return glsl_type_is_interface(this); }
-inline bool glsl_type::is_cmat() const { return glsl_type_is_cmat(this); }
-inline bool glsl_type::is_void() const { return glsl_type_is_void(this); }
-inline bool glsl_type::is_error() const { return glsl_type_is_error(this); }
-inline bool glsl_type::is_subroutine() const { return glsl_type_is_subroutine(this); }
-inline bool glsl_type::is_atomic_uint() const { return glsl_type_is_atomic_uint(this); }
-
-inline bool glsl_type::is_scalar() const { return glsl_type_is_scalar(this); }
-inline bool glsl_type::is_vector() const { return glsl_type_is_vector(this); }
-inline bool glsl_type::is_matrix() const { return glsl_type_is_matrix(this); }
-inline bool glsl_type::is_numeric() const { return glsl_type_is_numeric(this); }
-inline bool glsl_type::is_integer() const { return glsl_type_is_integer(this); }
-inline bool glsl_type::is_double() const { return glsl_type_is_double(this); }
-
-inline bool glsl_type::is_array_of_arrays() const { return glsl_type_is_array_of_arrays(this); }
-inline bool glsl_type::is_dual_slot() const { return glsl_type_is_dual_slot(this); }
-inline bool glsl_type::is_16bit() const { return glsl_type_is_16bit(this); }
-inline bool glsl_type::is_32bit() const { return glsl_type_is_32bit(this); }
-inline bool glsl_type::is_64bit() const { return glsl_type_is_64bit(this); }
-
-inline bool glsl_type::contains_64bit() const { return glsl_type_contains_64bit(this); }
-inline bool glsl_type::contains_image() const { return glsl_type_contains_image(this); }
-inline bool glsl_type::contains_atomic() const { return glsl_contains_atomic(this); }
-inline bool glsl_type::contains_opaque() const { return glsl_contains_opaque(this); }
-inline bool glsl_type::contains_double() const { return glsl_contains_double(this); }
-inline bool glsl_type::contains_integer() const { return glsl_contains_integer(this); }
-inline bool glsl_type::contains_sampler() const { return glsl_contains_sampler(this); }
-inline bool glsl_type::contains_array() const { return glsl_contains_array(this); }
-inline bool glsl_type::contains_subroutine() const { return glsl_contains_subroutine(this); }
-
-inline int glsl_type::array_size() const { return glsl_array_size(this); }
-inline const glsl_type *glsl_type::without_array() const { return glsl_without_array(this); }
-
-inline unsigned glsl_type::struct_location_offset(unsigned len) const { return glsl_get_struct_location_offset(this, len); }
-inline int glsl_type::field_index(const char *n) const { return glsl_get_field_index(this, n); }
-
-inline enum glsl_interface_packing glsl_type::get_interface_packing() const { return glsl_get_ifc_packing(this); }
-inline enum glsl_interface_packing glsl_type::get_internal_ifc_packing(bool std430_supported) const { return glsl_get_internal_ifc_packing(this, std430_supported); }
-
-inline bool glsl_type::compare_no_precision(const glsl_type *b) const { return glsl_type_compare_no_precision(this, b); }
-inline bool glsl_type::record_compare(const glsl_type *b, bool match_name, bool match_locations, bool match_precision) const { return glsl_record_compare(this, b, match_name, match_locations, match_precision); }
-
-inline unsigned glsl_type::components() const { return glsl_get_components(this); }
-inline unsigned glsl_type::component_slots() const { return glsl_get_component_slots(this); }
-inline unsigned glsl_type::component_slots_aligned(unsigned int offset) const { return glsl_get_component_slots_aligned(this, offset); }
-inline unsigned glsl_type::count_vec4_slots(bool is_gl_vertex_input, bool bindless) const { return glsl_count_vec4_slots(this, is_gl_vertex_input, bindless); }
-inline unsigned glsl_type::count_dword_slots(bool bindless) const { return glsl_count_dword_slots(this, bindless); };
-inline unsigned glsl_type::count_attribute_slots(bool is_gl_vertex_input) const { return glsl_count_attribute_slots(this, is_gl_vertex_input); }
-inline unsigned glsl_type::varying_count() const { return glsl_varying_count(this); }
-inline unsigned glsl_type::atomic_size() const { return glsl_atomic_size(this); }
-inline int glsl_type::coordinate_components() const { return glsl_get_sampler_coordinate_components(this); }
-inline unsigned glsl_type::uniform_locations() const { return glsl_type_uniform_locations(this); }
-
-inline unsigned glsl_type::cl_size() const { return glsl_get_cl_size(this); }
-inline unsigned glsl_type::cl_alignment() const { return glsl_get_cl_alignment(this); }
-
-inline unsigned glsl_type::std140_base_alignment(bool row_major) const { return glsl_get_std140_base_alignment(this, row_major); }
-inline unsigned glsl_type::std140_size(bool row_major) const { return glsl_get_std140_size(this, row_major); }
-inline unsigned glsl_type::std430_base_alignment(bool row_major) const { return glsl_get_std430_base_alignment(this, row_major); }
-inline unsigned glsl_type::std430_array_stride(bool row_major) const { return glsl_get_std430_array_stride(this, row_major); }
-inline unsigned glsl_type::std430_size(bool row_major) const { return glsl_get_std430_size(this, row_major); }
-inline unsigned glsl_type::explicit_size(bool align_to_stride) const { return glsl_get_explicit_size(this, align_to_stride); }
-
-inline const glsl_type *glsl_type::get_explicit_std140_type(bool row_major) const { return glsl_get_explicit_std140_type(this, row_major); }
-inline const glsl_type *glsl_type::get_explicit_std430_type(bool row_major) const { return glsl_get_explicit_std430_type(this, row_major); }
-inline const glsl_type *glsl_type::get_explicit_interface_type(bool supports_std430) const { return glsl_get_explicit_interface_type(this, supports_std430); }
-
-inline const glsl_type *glsl_type::row_type() const { return glsl_get_row_type(this); }
-inline const glsl_type *glsl_type::column_type() const { return glsl_get_column_type(this); }
-inline const glsl_type *glsl_type::get_bare_type() const { return glsl_get_bare_type(this); }
-inline const glsl_type *glsl_type::get_base_type() const { return glsl_get_base_glsl_type(this); }
-inline const glsl_type *glsl_type::get_scalar_type() const { return glsl_get_scalar_type(this); }
-
-inline const glsl_type *glsl_type::get_float16_type() const { return glsl_float16_type(this); }
-inline const glsl_type *glsl_type::get_int16_type() const { return glsl_int16_type(this); }
-inline const glsl_type *glsl_type::get_uint16_type() const { return glsl_uint16_type(this); }
-
-inline const glsl_type *glsl_type::vec(unsigned components) { return glsl_vec_type(components); }
-inline const glsl_type *glsl_type::f16vec(unsigned components) { return glsl_f16vec_type(components); }
-inline const glsl_type *glsl_type::dvec(unsigned components) { return glsl_dvec_type(components); }
-inline const glsl_type *glsl_type::ivec(unsigned components) { return glsl_ivec_type(components); }
-inline const glsl_type *glsl_type::uvec(unsigned components) { return glsl_uvec_type(components); }
-inline const glsl_type *glsl_type::bvec(unsigned components) { return glsl_bvec_type(components); }
-inline const glsl_type *glsl_type::i64vec(unsigned components) { return glsl_i64vec_type(components); }
-inline const glsl_type *glsl_type::u64vec(unsigned components) { return glsl_u64vec_type(components); }
-inline const glsl_type *glsl_type::i16vec(unsigned components) { return glsl_i16vec_type(components); }
-inline const glsl_type *glsl_type::u16vec(unsigned components) { return glsl_u16vec_type(components); }
-inline const glsl_type *glsl_type::i8vec(unsigned components) { return glsl_i8vec_type(components); }
-inline const glsl_type *glsl_type::u8vec(unsigned components) { return glsl_u8vec_type(components); }
-
-inline const glsl_type *
-glsl_type::get_instance(unsigned base_type, unsigned rows, unsigned columns,
-                        unsigned explicit_stride, bool row_major,
-                        unsigned explicit_alignment)
-{
-   return glsl_simple_explicit_type(base_type, rows, columns, explicit_stride,
-                                    row_major, explicit_alignment);
-}
-
-inline const glsl_type *
-glsl_type::get_sampler_instance(enum glsl_sampler_dim dim, bool shadow,
-                                bool array, glsl_base_type type)
-{
-   return glsl_sampler_type(dim, shadow, array, type);
-}
-
-inline const glsl_type *
-glsl_type::get_texture_instance(enum glsl_sampler_dim dim, bool array, glsl_base_type type)
-{
-   return glsl_texture_type(dim, array, type);
-}
-
-inline const glsl_type *
-glsl_type::get_image_instance(enum glsl_sampler_dim dim, bool array, glsl_base_type type)
-{
-   return glsl_image_type(dim, array, type);
-}
-
-inline const glsl_type *
-glsl_type::get_array_instance(const glsl_type *element, unsigned array_size,
-                              unsigned explicit_stride)
-{
-   return glsl_array_type(element, array_size, explicit_stride);
-}
-
-inline const glsl_type *
-glsl_type::get_cmat_instance(const struct glsl_cmat_description desc)
-{
-   return glsl_cmat_type(&desc);
-}
-
-inline const glsl_type *
-glsl_type::get_struct_instance(const glsl_struct_field *fields, unsigned num_fields,
-                               const char *name, bool packed, unsigned explicit_alignment)
-{
-   return glsl_struct_type_with_explicit_alignment(fields, num_fields, name, packed, explicit_alignment);
-}
-
-inline const glsl_type *
-glsl_type::get_interface_instance(const glsl_struct_field *fields, unsigned num_fields,
-                                  enum glsl_interface_packing packing,
-                                  bool row_major, const char *block_name)
-{
-   return glsl_interface_type(fields, num_fields, packing, row_major, block_name);
-}
-
-inline const glsl_type *
-glsl_type::get_subroutine_instance(const char *subroutine_name)
-{
-   return glsl_subroutine_type(subroutine_name);
-}
-
-inline const glsl_type *
-glsl_type::get_explicit_type_for_size_align(glsl_type_size_align_func type_info,
-                                            unsigned *size, unsigned *align) const
-{
-   return glsl_get_explicit_type_for_size_align(this, type_info, size, align);
-}
-
-inline const glsl_type *glsl_type::replace_vec3_with_vec4() const { return glsl_type_replace_vec3_with_vec4(this); }
-inline const glsl_type *glsl_type::get_mul_type(const glsl_type *type_a, const glsl_type *type_b) { return glsl_get_mul_type(type_a, type_b); }
-
-inline const glsl_type *
-glsl_type::field_type(const char *n) const
-{
-   const int idx = glsl_get_field_index(this, n);
-   if (idx == -1)
-      return &glsl_type_builtin_error;
-   return glsl_get_struct_field(this, (unsigned)idx);
-}
-
-inline bool
-glsl_type::is_integer_16() const
-{
-   return base_type == GLSL_TYPE_UINT16 || base_type == GLSL_TYPE_INT16;
-}
-
-inline bool
-glsl_type::is_integer_32() const
-{
-   return (base_type == GLSL_TYPE_UINT) || (base_type == GLSL_TYPE_INT);
-}
-
-inline bool
-glsl_type::is_integer_64() const
-{
-   return base_type == GLSL_TYPE_UINT64 || base_type == GLSL_TYPE_INT64;
-}
-
-inline bool
-glsl_type::is_integer_32_64() const
-{
-   return is_integer_32() || is_integer_64();
-}
-
-inline bool
-glsl_type::is_integer_16_32() const
-{
-   return is_integer_16() || is_integer_32();
-}
-
-inline bool
-glsl_type::is_integer_16_32_64() const
-{
-   return is_integer_16() || is_integer_32() || is_integer_64();
-}
-
-inline bool
-glsl_type::is_float() const
-{
-   return base_type == GLSL_TYPE_FLOAT;
-}
-
-inline bool
-glsl_type::is_float_16_32() const
-{
-   return base_type == GLSL_TYPE_FLOAT16 || is_float();
-}
-
-inline bool
-glsl_type::is_float_16_32_64() const
-{
-   return base_type == GLSL_TYPE_FLOAT16 || is_float() || is_double();
-}
-
-inline bool
-glsl_type::is_float_32_64() const
-{
-   return is_float() || is_double();
-}
-
-inline bool
-glsl_type::is_int_16_32_64() const
-{
-   return base_type == GLSL_TYPE_INT16 ||
-          base_type == GLSL_TYPE_INT ||
-          base_type == GLSL_TYPE_INT64;
-}
-
-inline bool
-glsl_type::is_uint_16_32_64() const
-{
-   return base_type == GLSL_TYPE_UINT16 ||
-          base_type == GLSL_TYPE_UINT ||
-          base_type == GLSL_TYPE_UINT64;
-}
-
-inline bool
-glsl_type::is_int_16_32() const
-{
-   return base_type == GLSL_TYPE_INT ||
-          base_type == GLSL_TYPE_INT16;
-}
-
-inline bool
-glsl_type::is_uint_16_32() const
-{
-   return base_type == GLSL_TYPE_UINT ||
-          base_type == GLSL_TYPE_UINT16;
-}
-
-inline unsigned glsl_type::arrays_of_arrays_size() const { return glsl_get_aoa_size(this); }
-
-inline unsigned
-glsl_type::bit_size() const
-{
-   return glsl_base_type_bit_size(this->base_type);
-}
-
-inline bool glsl_type::is_unsized_array() const { return glsl_type_is_unsized_array(this); }
-
-inline bool
-glsl_type::get_interface_row_major() const
-{
-   return (bool) interface_row_major;
-}
-
-#endif /* __cplusplus */
-
-#endif /* GLSL_TYPES_H */
diff --git a/src/compiler/meson.build b/src/compiler/meson.build
index f85a9080f6059..ff51bfd5629c5 100644
--- a/src/compiler/meson.build
+++ b/src/compiler/meson.build
@@ -45,7 +45,6 @@ astc_decoder_glsl_file = files('glsl/astc_decoder.glsl')
 files_libcompiler = files(
   'glsl_types.c',
   'glsl_types.h',
-  'glsl_types_impl.h',
   'nir_types.h',
   'shader_enums.c',
   'shader_enums.h',
-- 
GitLab


From f43edfdc4036136b692a059d40e01f8635b1188a Mon Sep 17 00:00:00 2001
From: Caio Oliveira <caio.oliveira@intel.com>
Date: Thu, 14 Dec 2023 23:15:18 -0800
Subject: [PATCH 9/9] compiler/types: Use a typedef for glsl_type

Most of the code now will see `const glsl_type *` instead of
`const struct glsl_type *`.
---
 src/compiler/glsl_types.c | 442 +++++++++++++++++++-------------------
 src/compiler/glsl_types.h | 420 ++++++++++++++++++------------------
 2 files changed, 431 insertions(+), 431 deletions(-)

diff --git a/src/compiler/glsl_types.c b/src/compiler/glsl_types.c
index 633f6e7613b18..71edd9e98b5e4 100644
--- a/src/compiler/glsl_types.c
+++ b/src/compiler/glsl_types.c
@@ -57,7 +57,7 @@ static struct {
    struct hash_table *subroutine_types;
 } glsl_type_cache;
 
-static const struct glsl_type *
+static const glsl_type *
 make_vector_matrix_type(linear_ctx *lin_ctx, uint32_t gl_type,
                         enum glsl_base_type base_type, unsigned vector_elements,
                         unsigned matrix_columns, const char *name,
@@ -71,7 +71,7 @@ make_vector_matrix_type(linear_ctx *lin_ctx, uint32_t gl_type,
    /* Neither dimension is zero or both dimensions are zero. */
    assert((vector_elements == 0) == (matrix_columns == 0));
 
-   struct glsl_type *t = linear_zalloc(lin_ctx, struct glsl_type);
+   glsl_type *t = linear_zalloc(lin_ctx, glsl_type);
    t->gl_type = gl_type;
    t->base_type = base_type;
    t->sampled_type = GLSL_TYPE_VOID;
@@ -86,7 +86,7 @@ make_vector_matrix_type(linear_ctx *lin_ctx, uint32_t gl_type,
 }
 
 static void
-fill_struct_type(struct glsl_type *t, const struct glsl_struct_field *fields, unsigned num_fields,
+fill_struct_type(glsl_type *t, const glsl_struct_field *fields, unsigned num_fields,
                  const char *name, bool packed, unsigned explicit_alignment)
 {
    assert(util_is_power_of_two_or_zero(explicit_alignment));
@@ -99,19 +99,19 @@ fill_struct_type(struct glsl_type *t, const struct glsl_struct_field *fields, un
    t->fields.structure = fields;
 }
 
-static const struct glsl_type *
-make_struct_type(linear_ctx *lin_ctx, const struct glsl_struct_field *fields, unsigned num_fields,
+static const glsl_type *
+make_struct_type(linear_ctx *lin_ctx, const glsl_struct_field *fields, unsigned num_fields,
                  const char *name, bool packed,
                  unsigned explicit_alignment)
 {
    assert(lin_ctx != NULL);
    assert(name != NULL);
 
-   struct glsl_type *t = linear_zalloc(lin_ctx, struct glsl_type);
+   glsl_type *t = linear_zalloc(lin_ctx, glsl_type);
    const char *copied_name = linear_strdup(lin_ctx, name);
 
-   struct glsl_struct_field *copied_fields =
-      linear_zalloc_array(lin_ctx, struct glsl_struct_field, num_fields);
+   glsl_struct_field *copied_fields =
+      linear_zalloc_array(lin_ctx, glsl_struct_field, num_fields);
 
    for (unsigned i = 0; i < num_fields; i++) {
       copied_fields[i] = fields[i];
@@ -124,7 +124,7 @@ make_struct_type(linear_ctx *lin_ctx, const struct glsl_struct_field *fields, un
 }
 
 static void
-fill_interface_type(struct glsl_type *t, const struct glsl_struct_field *fields, unsigned num_fields,
+fill_interface_type(glsl_type *t, const glsl_struct_field *fields, unsigned num_fields,
                     enum glsl_interface_packing packing,
                     bool row_major, const char *name)
 {
@@ -137,19 +137,19 @@ fill_interface_type(struct glsl_type *t, const struct glsl_struct_field *fields,
    t->fields.structure = fields;
 }
 
-static const struct glsl_type *
-make_interface_type(linear_ctx *lin_ctx, const struct glsl_struct_field *fields, unsigned num_fields,
+static const glsl_type *
+make_interface_type(linear_ctx *lin_ctx, const glsl_struct_field *fields, unsigned num_fields,
                     enum glsl_interface_packing packing,
                     bool row_major, const char *name)
 {
    assert(lin_ctx != NULL);
    assert(name != NULL);
 
-   struct glsl_type *t = linear_zalloc(lin_ctx, struct glsl_type);
+   glsl_type *t = linear_zalloc(lin_ctx, glsl_type);
    const char *copied_name = linear_strdup(lin_ctx, name);
 
-   struct glsl_struct_field *copied_fields =
-      linear_zalloc_array(lin_ctx, struct glsl_struct_field, num_fields);
+   glsl_struct_field *copied_fields =
+      linear_zalloc_array(lin_ctx, glsl_struct_field, num_fields);
 
    for (unsigned i = 0; i < num_fields; i++) {
       copied_fields[i] = fields[i];
@@ -161,13 +161,13 @@ make_interface_type(linear_ctx *lin_ctx, const struct glsl_struct_field *fields,
    return t;
 }
 
-static const struct glsl_type *
+static const glsl_type *
 make_subroutine_type(linear_ctx *lin_ctx, const char *subroutine_name)
 {
    assert(lin_ctx != NULL);
    assert(subroutine_name != NULL);
 
-   struct glsl_type *t = linear_zalloc(lin_ctx, struct glsl_type);
+   glsl_type *t = linear_zalloc(lin_ctx, glsl_type);
    t->base_type = GLSL_TYPE_SUBROUTINE;
    t->sampled_type = GLSL_TYPE_VOID;
    t->vector_elements = 1;
@@ -178,7 +178,7 @@ make_subroutine_type(linear_ctx *lin_ctx, const char *subroutine_name)
 }
 
 bool
-glsl_contains_sampler(const struct glsl_type *t)
+glsl_contains_sampler(const glsl_type *t)
 {
    if (glsl_type_is_array(t)) {
       return glsl_contains_sampler(t->fields.array);
@@ -194,7 +194,7 @@ glsl_contains_sampler(const struct glsl_type *t)
 }
 
 bool
-glsl_contains_array(const struct glsl_type *t)
+glsl_contains_array(const glsl_type *t)
 {
    if (glsl_type_is_struct(t) || glsl_type_is_interface(t)) {
       for (unsigned int i = 0; i < t->length; i++) {
@@ -208,7 +208,7 @@ glsl_contains_array(const struct glsl_type *t)
 }
 
 bool
-glsl_contains_integer(const struct glsl_type *t)
+glsl_contains_integer(const glsl_type *t)
 {
    if (glsl_type_is_array(t)) {
       return glsl_contains_integer(t->fields.array);
@@ -224,7 +224,7 @@ glsl_contains_integer(const struct glsl_type *t)
 }
 
 bool
-glsl_contains_double(const struct glsl_type *t)
+glsl_contains_double(const glsl_type *t)
 {
    if (glsl_type_is_array(t)) {
       return glsl_contains_double(t->fields.array);
@@ -240,7 +240,7 @@ glsl_contains_double(const struct glsl_type *t)
 }
 
 bool
-glsl_type_contains_64bit(const struct glsl_type *t)
+glsl_type_contains_64bit(const glsl_type *t)
 {
    if (glsl_type_is_array(t)) {
       return glsl_type_contains_64bit(t->fields.array);
@@ -256,7 +256,7 @@ glsl_type_contains_64bit(const struct glsl_type *t)
 }
 
 bool
-glsl_contains_opaque(const struct glsl_type *t)
+glsl_contains_opaque(const glsl_type *t)
 {
    switch (t->base_type) {
    case GLSL_TYPE_SAMPLER:
@@ -278,7 +278,7 @@ glsl_contains_opaque(const struct glsl_type *t)
 }
 
 bool
-glsl_contains_subroutine(const struct glsl_type *t)
+glsl_contains_subroutine(const glsl_type *t)
 {
    if (glsl_type_is_array(t)) {
       return glsl_contains_subroutine(t->fields.array);
@@ -294,7 +294,7 @@ glsl_contains_subroutine(const struct glsl_type *t)
 }
 
 bool
-glsl_type_contains_image(const struct glsl_type *t)
+glsl_type_contains_image(const glsl_type *t)
 {
    if (glsl_type_is_array(t)) {
       return glsl_type_contains_image(t->fields.array);
@@ -309,8 +309,8 @@ glsl_type_contains_image(const struct glsl_type *t)
    }
 }
 
-const struct glsl_type *
-glsl_get_base_glsl_type(const struct glsl_type *t)
+const glsl_type *
+glsl_get_base_glsl_type(const glsl_type *t)
 {
    switch (t->base_type) {
    case GLSL_TYPE_UINT:
@@ -342,16 +342,16 @@ glsl_get_base_glsl_type(const struct glsl_type *t)
    }
 }
 
-const struct glsl_type *
-glsl_get_scalar_type(const struct glsl_type *t)
+const glsl_type *
+glsl_get_scalar_type(const glsl_type *t)
 {
-   const struct glsl_type *type = t;
+   const glsl_type *type = t;
 
    /* Handle arrays */
    while (type->base_type == GLSL_TYPE_ARRAY)
       type = type->fields.array;
 
-   const struct glsl_type *scalar_type = glsl_get_base_glsl_type(type);
+   const glsl_type *scalar_type = glsl_get_base_glsl_type(type);
    if (scalar_type == &glsl_type_builtin_error)
       return type;
 
@@ -359,8 +359,8 @@ glsl_get_scalar_type(const struct glsl_type *t)
 }
 
 
-const struct glsl_type *
-glsl_get_bare_type(const struct glsl_type *t)
+const glsl_type *
+glsl_get_bare_type(const glsl_type *t)
 {
    switch (t->base_type) {
    case GLSL_TYPE_UINT8:
@@ -380,13 +380,13 @@ glsl_get_bare_type(const struct glsl_type *t)
 
    case GLSL_TYPE_STRUCT:
    case GLSL_TYPE_INTERFACE: {
-      struct glsl_struct_field *bare_fields = (struct glsl_struct_field *)
-         calloc(t->length, sizeof(struct glsl_struct_field));
+      glsl_struct_field *bare_fields = (glsl_struct_field *)
+         calloc(t->length, sizeof(glsl_struct_field));
       for (unsigned i = 0; i < t->length; i++) {
          bare_fields[i].type = glsl_get_bare_type(t->fields.structure[i].type);
          bare_fields[i].name = t->fields.structure[i].name;
       }
-      const struct glsl_type *bare_type =
+      const glsl_type *bare_type =
          glsl_struct_type(bare_fields, t->length, glsl_get_type_name(t), false);
       free(bare_fields);
       return bare_type;
@@ -410,8 +410,8 @@ glsl_get_bare_type(const struct glsl_type *t)
    unreachable("Invalid base type");
 }
 
-const struct glsl_type *
-glsl_float16_type(const struct glsl_type *t)
+const glsl_type *
+glsl_float16_type(const glsl_type *t)
 {
    assert(t->base_type == GLSL_TYPE_FLOAT);
 
@@ -420,8 +420,8 @@ glsl_float16_type(const struct glsl_type *t)
                                     t->interface_row_major, 0);
 }
 
-const struct glsl_type *
-glsl_int16_type(const struct glsl_type *t)
+const glsl_type *
+glsl_int16_type(const glsl_type *t)
 {
    assert(t->base_type == GLSL_TYPE_INT);
 
@@ -430,8 +430,8 @@ glsl_int16_type(const struct glsl_type *t)
                                     t->interface_row_major, 0);
 }
 
-const struct glsl_type *
-glsl_uint16_type(const struct glsl_type *t)
+const glsl_type *
+glsl_uint16_type(const glsl_type *t)
 {
    assert(t->base_type == GLSL_TYPE_UINT);
 
@@ -450,9 +450,9 @@ glsl_type_singleton_init_or_ref()
    STATIC_ASSERT((((unsigned)GLSL_TYPE_INT)   & 3) == (unsigned)GLSL_TYPE_INT);
    STATIC_ASSERT((((unsigned)GLSL_TYPE_FLOAT) & 3) == (unsigned)GLSL_TYPE_FLOAT);
 
-   ASSERT_BITFIELD_SIZE(struct glsl_type, base_type, GLSL_TYPE_ERROR);
-   ASSERT_BITFIELD_SIZE(struct glsl_type, sampled_type, GLSL_TYPE_ERROR);
-   ASSERT_BITFIELD_SIZE(struct glsl_type, sampler_dimensionality,
+   ASSERT_BITFIELD_SIZE(glsl_type, base_type, GLSL_TYPE_ERROR);
+   ASSERT_BITFIELD_SIZE(glsl_type, sampled_type, GLSL_TYPE_ERROR);
+   ASSERT_BITFIELD_SIZE(glsl_type, sampler_dimensionality,
                         GLSL_SAMPLER_DIM_SUBPASS_MS);
 
    simple_mtx_lock(&glsl_type_cache_mutex);
@@ -482,13 +482,13 @@ glsl_type_singleton_decref()
    simple_mtx_unlock(&glsl_type_cache_mutex);
 }
 
-static const struct glsl_type *
-make_array_type(linear_ctx *lin_ctx, const struct glsl_type *element_type, unsigned length,
+static const glsl_type *
+make_array_type(linear_ctx *lin_ctx, const glsl_type *element_type, unsigned length,
                 unsigned explicit_stride)
 {
    assert(lin_ctx != NULL);
 
-   struct glsl_type *t = linear_zalloc(lin_ctx, struct glsl_type);
+   glsl_type *t = linear_zalloc(lin_ctx, glsl_type);
    t->base_type = GLSL_TYPE_ARRAY;
    t->sampled_type = GLSL_TYPE_VOID;
    t->length = length;
@@ -543,8 +543,8 @@ glsl_cmat_use_to_string(enum glsl_cmat_use use)
    }
 };
 
-static const struct glsl_type *
-vec(unsigned components, const struct glsl_type *const ts[])
+static const glsl_type *
+vec(unsigned components, const glsl_type *const ts[])
 {
    unsigned n = components;
 
@@ -560,10 +560,10 @@ vec(unsigned components, const struct glsl_type *const ts[])
 }
 
 #define VECN(components, sname, vname)           \
-const struct glsl_type *              \
+const glsl_type *              \
 glsl_ ## vname ## _type (unsigned components)    \
 {                                                \
-   static const struct glsl_type *const ts[] = { \
+   static const glsl_type *const ts[] = { \
       &glsl_type_builtin_ ## sname,              \
       &glsl_type_builtin_ ## vname ## 2,         \
       &glsl_type_builtin_ ## vname ## 3,         \
@@ -588,11 +588,11 @@ VECN(components, uint16_t, u16vec)
 VECN(components, int8_t, i8vec)
 VECN(components, uint8_t, u8vec)
 
-static const struct glsl_type *
+static const glsl_type *
 get_explicit_matrix_instance(unsigned int base_type, unsigned int rows, unsigned int columns,
                              unsigned int explicit_stride, bool row_major, unsigned int explicit_alignment);
 
-const struct glsl_type *
+const glsl_type *
 glsl_simple_explicit_type(unsigned base_type, unsigned rows, unsigned columns,
                           unsigned explicit_stride, bool row_major,
                           unsigned explicit_alignment)
@@ -732,7 +732,7 @@ compare_explicit_matrix_key(const void *a, const void *b)
    return memcmp(a, b, sizeof(struct explicit_matrix_key)) == 0;
 }
 
-static const struct glsl_type *
+static const glsl_type *
 get_explicit_matrix_instance(unsigned int base_type, unsigned int rows, unsigned int columns,
                              unsigned int explicit_stride, bool row_major, unsigned int explicit_alignment)
 {
@@ -744,7 +744,7 @@ get_explicit_matrix_instance(unsigned int base_type, unsigned int rows, unsigned
       assert(explicit_stride % explicit_alignment == 0);
    }
 
-   const struct glsl_type *bare_type = glsl_simple_type(base_type, rows, columns);
+   const glsl_type *bare_type = glsl_simple_type(base_type, rows, columns);
 
    assert(columns > 1 || (rows > 1 && !row_major));
 
@@ -778,7 +778,7 @@ get_explicit_matrix_instance(unsigned int base_type, unsigned int rows, unsigned
                explicit_stride, explicit_alignment, row_major ? "RM" : "");
 
       linear_ctx *lin_ctx = glsl_type_cache.lin_ctx;
-      const struct glsl_type *t =
+      const glsl_type *t =
          make_vector_matrix_type(lin_ctx, bare_type->gl_type,
                                  (enum glsl_base_type)base_type,
                                  rows, columns, name,
@@ -792,7 +792,7 @@ get_explicit_matrix_instance(unsigned int base_type, unsigned int rows, unsigned
                                                  key_hash, stored_key, (void *)t);
    }
 
-   const struct glsl_type *t = (const struct glsl_type *) entry->data;
+   const glsl_type *t = (const glsl_type *) entry->data;
    simple_mtx_unlock(&glsl_type_cache_mutex);
 
    assert(t->base_type == base_type);
@@ -804,7 +804,7 @@ get_explicit_matrix_instance(unsigned int base_type, unsigned int rows, unsigned
    return t;
 }
 
-const struct glsl_type *
+const glsl_type *
 glsl_sampler_type(enum glsl_sampler_dim dim, bool shadow,
                   bool array, enum glsl_base_type type)
 {
@@ -928,19 +928,19 @@ glsl_sampler_type(enum glsl_sampler_dim dim, bool shadow,
    unreachable("switch statement above should be complete");
 }
 
-const struct glsl_type *
+const glsl_type *
 glsl_bare_sampler_type()
 {
    return &glsl_type_builtin_sampler;
 }
 
-const struct glsl_type *
+const glsl_type *
 glsl_bare_shadow_sampler_type()
 {
    return &glsl_type_builtin_samplerShadow;
 }
 
-const struct glsl_type *
+const glsl_type *
 glsl_texture_type(enum glsl_sampler_dim dim, bool array, enum glsl_base_type type)
 {
    switch (type) {
@@ -1057,7 +1057,7 @@ glsl_texture_type(enum glsl_sampler_dim dim, bool array, enum glsl_base_type typ
    unreachable("switch statement above should be complete");
 }
 
-const struct glsl_type *
+const glsl_type *
 glsl_image_type(enum glsl_sampler_dim dim, bool array, enum glsl_base_type type)
 {
    switch (type) {
@@ -1245,8 +1245,8 @@ compare_array_key(const void *a, const void *b)
    return memcmp(a, b, sizeof(struct array_key)) == 0;
 }
 
-const struct glsl_type *
-glsl_array_type(const struct glsl_type *element,
+const glsl_type *
+glsl_array_type(const glsl_type *element,
                 unsigned array_size,
                 unsigned explicit_stride)
 {
@@ -1273,7 +1273,7 @@ glsl_array_type(const struct glsl_type *element,
    const struct hash_entry *entry = _mesa_hash_table_search_pre_hashed(array_types, key_hash, &key);
    if (entry == NULL) {
       linear_ctx *lin_ctx = glsl_type_cache.lin_ctx;
-      const struct glsl_type *t = make_array_type(lin_ctx, element, array_size, explicit_stride);
+      const glsl_type *t = make_array_type(lin_ctx, element, array_size, explicit_stride);
       struct array_key *stored_key = linear_zalloc(lin_ctx, struct array_key);
       memcpy(stored_key, &key, sizeof(key));
 
@@ -1282,7 +1282,7 @@ glsl_array_type(const struct glsl_type *element,
                                                  (void *) t);
    }
 
-   const struct glsl_type *t = (const struct glsl_type *) entry->data;
+   const glsl_type *t = (const glsl_type *) entry->data;
    simple_mtx_unlock(&glsl_type_cache_mutex);
 
    assert(t->base_type == GLSL_TYPE_ARRAY);
@@ -1292,18 +1292,18 @@ glsl_array_type(const struct glsl_type *element,
    return t;
 }
 
-static const struct glsl_type *
+static const glsl_type *
 make_cmat_type(linear_ctx *lin_ctx, const struct glsl_cmat_description desc)
 {
    assert(lin_ctx != NULL);
 
-   struct glsl_type *t = linear_zalloc(lin_ctx, struct glsl_type);
+   glsl_type *t = linear_zalloc(lin_ctx, glsl_type);
    t->base_type = GLSL_TYPE_COOPERATIVE_MATRIX;
    t->sampled_type = GLSL_TYPE_VOID;
    t->vector_elements = 1;
    t->cmat_desc = desc;
 
-   const struct glsl_type *element_type = glsl_simple_type(desc.element_type, 1, 1);
+   const glsl_type *element_type = glsl_simple_type(desc.element_type, 1, 1);
    t->name_id = (uintptr_t ) linear_asprintf(lin_ctx, "coopmat<%s, %s, %u, %u, %s>",
                                              glsl_get_type_name(element_type),
                                              mesa_scope_name((mesa_scope)desc.scope),
@@ -1313,7 +1313,7 @@ make_cmat_type(linear_ctx *lin_ctx, const struct glsl_cmat_description desc)
    return t;
 }
 
-const struct glsl_type *
+const glsl_type *
 glsl_cmat_type(const struct glsl_cmat_description *desc)
 {
    STATIC_ASSERT(sizeof(struct glsl_cmat_description) == 4);
@@ -1336,12 +1336,12 @@ glsl_cmat_type(const struct glsl_cmat_description *desc)
    const struct hash_entry *entry = _mesa_hash_table_search_pre_hashed(
       cmat_types, key_hash, (void *) (uintptr_t) key);
    if (entry == NULL) {
-      const struct glsl_type *t = make_cmat_type(glsl_type_cache.lin_ctx, *desc);
+      const glsl_type *t = make_cmat_type(glsl_type_cache.lin_ctx, *desc);
       entry = _mesa_hash_table_insert_pre_hashed(cmat_types, key_hash,
                                                  (void *) (uintptr_t) key, (void *) t);
    }
 
-   const struct glsl_type *t = (const struct glsl_type *)entry->data;
+   const glsl_type *t = (const glsl_type *)entry->data;
    simple_mtx_unlock(&glsl_type_cache_mutex);
 
    assert(t->base_type == GLSL_TYPE_COOPERATIVE_MATRIX);
@@ -1355,7 +1355,7 @@ glsl_cmat_type(const struct glsl_cmat_description *desc)
 }
 
 bool
-glsl_type_compare_no_precision(const struct glsl_type *a, const struct glsl_type *b)
+glsl_type_compare_no_precision(const glsl_type *a, const glsl_type *b)
 {
    if (a == b)
       return true;
@@ -1364,7 +1364,7 @@ glsl_type_compare_no_precision(const struct glsl_type *a, const struct glsl_type
       if (!glsl_type_is_array(b) || a->length != b->length)
          return false;
 
-      const struct glsl_type *b_no_array = b->fields.array;
+      const glsl_type *b_no_array = b->fields.array;
 
       return glsl_type_compare_no_precision(a->fields.array, b_no_array);
    }
@@ -1386,7 +1386,7 @@ glsl_type_compare_no_precision(const struct glsl_type *a, const struct glsl_type
 }
 
 bool
-glsl_record_compare(const struct glsl_type *a, const struct glsl_type *b, bool match_name,
+glsl_record_compare(const glsl_type *a, const glsl_type *b, bool match_name,
                     bool match_locations, bool match_precision)
 {
    if (a->length != b->length)
@@ -1426,8 +1426,8 @@ glsl_record_compare(const struct glsl_type *a, const struct glsl_type *b, bool m
          if (a->fields.structure[i].type != b->fields.structure[i].type)
             return false;
       } else {
-         const struct glsl_type *ta = a->fields.structure[i].type;
-         const struct glsl_type *tb = b->fields.structure[i].type;
+         const glsl_type *ta = a->fields.structure[i].type;
+         const glsl_type *tb = b->fields.structure[i].type;
          if (!glsl_type_compare_no_precision(ta, tb))
             return false;
       }
@@ -1498,8 +1498,8 @@ glsl_record_compare(const struct glsl_type *a, const struct glsl_type *b, bool m
 static bool
 record_key_compare(const void *a, const void *b)
 {
-   const struct glsl_type *const key1 = (struct glsl_type *) a;
-   const struct glsl_type *const key2 = (struct glsl_type *) b;
+   const glsl_type *const key1 = (glsl_type *) a;
+   const glsl_type *const key2 = (glsl_type *) b;
 
    return strcmp(glsl_get_type_name(key1), glsl_get_type_name(key2)) == 0 &&
                  glsl_record_compare(key1, key2, true, true, true);
@@ -1512,7 +1512,7 @@ record_key_compare(const void *a, const void *b)
 static unsigned
 record_key_hash(const void *a)
 {
-   const struct glsl_type *const key = (struct glsl_type *) a;
+   const glsl_type *const key = (glsl_type *) a;
    uintptr_t hash = key->length;
    unsigned retval;
 
@@ -1529,13 +1529,13 @@ record_key_hash(const void *a)
    return retval;
 }
 
-const struct glsl_type *
-glsl_struct_type_with_explicit_alignment(const struct glsl_struct_field *fields,
+const glsl_type *
+glsl_struct_type_with_explicit_alignment(const glsl_struct_field *fields,
                                          unsigned num_fields,
                                          const char *name,
                                          bool packed, unsigned explicit_alignment)
 {
-   struct glsl_type key = {0};
+   glsl_type key = {0};
    fill_struct_type(&key, fields, num_fields, name, packed, explicit_alignment);
    const uint32_t key_hash = record_key_hash(&key);
 
@@ -1552,13 +1552,13 @@ glsl_struct_type_with_explicit_alignment(const struct glsl_struct_field *fields,
    const struct hash_entry *entry = _mesa_hash_table_search_pre_hashed(struct_types,
                                                                        key_hash, &key);
    if (entry == NULL) {
-      const struct glsl_type *t = make_struct_type(glsl_type_cache.lin_ctx, fields, num_fields,
+      const glsl_type *t = make_struct_type(glsl_type_cache.lin_ctx, fields, num_fields,
                                             name, packed, explicit_alignment);
 
       entry = _mesa_hash_table_insert_pre_hashed(struct_types, key_hash, t, (void *) t);
    }
 
-   const struct glsl_type *t = (const struct glsl_type *) entry->data;
+   const glsl_type *t = (const glsl_type *) entry->data;
    simple_mtx_unlock(&glsl_type_cache_mutex);
 
    assert(t->base_type == GLSL_TYPE_STRUCT);
@@ -1571,14 +1571,14 @@ glsl_struct_type_with_explicit_alignment(const struct glsl_struct_field *fields,
 }
 
 
-const struct glsl_type *
-glsl_interface_type(const struct glsl_struct_field *fields,
+const glsl_type *
+glsl_interface_type(const glsl_struct_field *fields,
                     unsigned num_fields,
                     enum glsl_interface_packing packing,
                     bool row_major,
                     const char *block_name)
 {
-   struct glsl_type key = {0};
+   glsl_type key = {0};
    fill_interface_type(&key, fields, num_fields, packing, row_major, block_name);
    const uint32_t key_hash = record_key_hash(&key);
 
@@ -1595,13 +1595,13 @@ glsl_interface_type(const struct glsl_struct_field *fields,
    const struct hash_entry *entry = _mesa_hash_table_search_pre_hashed(interface_types,
                                                                        key_hash, &key);
    if (entry == NULL) {
-      const struct glsl_type *t = make_interface_type(glsl_type_cache.lin_ctx, fields, num_fields,
+      const glsl_type *t = make_interface_type(glsl_type_cache.lin_ctx, fields, num_fields,
                                                packing, row_major, block_name);
 
       entry = _mesa_hash_table_insert_pre_hashed(interface_types, key_hash, t, (void *) t);
    }
 
-   const struct glsl_type *t = (const struct glsl_type *) entry->data;
+   const glsl_type *t = (const glsl_type *) entry->data;
    simple_mtx_unlock(&glsl_type_cache_mutex);
 
    assert(t->base_type == GLSL_TYPE_INTERFACE);
@@ -1611,7 +1611,7 @@ glsl_interface_type(const struct glsl_struct_field *fields,
    return t;
 }
 
-const struct glsl_type *
+const glsl_type *
 glsl_subroutine_type(const char *subroutine_name)
 {
    const uint32_t key_hash = _mesa_hash_string(subroutine_name);
@@ -1629,12 +1629,12 @@ glsl_subroutine_type(const char *subroutine_name)
    const struct hash_entry *entry = _mesa_hash_table_search_pre_hashed(subroutine_types,
                                                                        key_hash, subroutine_name);
    if (entry == NULL) {
-      const struct glsl_type *t = make_subroutine_type(glsl_type_cache.lin_ctx, subroutine_name);
+      const glsl_type *t = make_subroutine_type(glsl_type_cache.lin_ctx, subroutine_name);
 
       entry = _mesa_hash_table_insert_pre_hashed(subroutine_types, key_hash, glsl_get_type_name(t), (void *) t);
    }
 
-   const struct glsl_type *t = (const struct glsl_type *) entry->data;
+   const glsl_type *t = (const glsl_type *) entry->data;
    simple_mtx_unlock(&glsl_type_cache_mutex);
 
    assert(t->base_type == GLSL_TYPE_SUBROUTINE);
@@ -1643,8 +1643,8 @@ glsl_subroutine_type(const char *subroutine_name)
    return t;
 }
 
-const struct glsl_type *
-glsl_get_mul_type(const struct glsl_type *type_a, const struct glsl_type *type_b)
+const glsl_type *
+glsl_get_mul_type(const glsl_type *type_a, const glsl_type *type_b)
 {
    if (glsl_type_is_matrix(type_a) && glsl_type_is_matrix(type_b)) {
       /* Matrix multiply.  The columns of A must match the rows of B.  Given
@@ -1658,7 +1658,7 @@ glsl_get_mul_type(const struct glsl_type *type_a, const struct glsl_type *type_b
           * looking at the size of a vector that makes up a column.  The
           * transpose (size of a row) is done for B.
           */
-         const struct glsl_type *const type =
+         const glsl_type *const type =
             glsl_simple_type(type_a->base_type,
                              glsl_get_column_type(type_a)->vector_elements,
                              glsl_get_row_type(type_b)->vector_elements);
@@ -1677,7 +1677,7 @@ glsl_get_mul_type(const struct glsl_type *type_a, const struct glsl_type *type_b
       if (glsl_get_row_type(type_a) == type_b) {
          /* The resulting vector has a number of elements equal to
           * the number of rows of matrix A. */
-         const struct glsl_type *const type =
+         const glsl_type *const type =
             glsl_simple_type(type_a->base_type,
                              glsl_get_column_type(type_a)->vector_elements, 1);
          assert(type != &glsl_type_builtin_error);
@@ -1695,7 +1695,7 @@ glsl_get_mul_type(const struct glsl_type *type_a, const struct glsl_type *type_b
       if (type_a == glsl_get_column_type(type_b)) {
          /* The resulting vector has a number of elements equal to
           * the number of columns of matrix B. */
-         const struct glsl_type *const type =
+         const glsl_type *const type =
             glsl_simple_type(type_a->base_type,
                              glsl_get_row_type(type_b)->vector_elements, 1);
          assert(type != &glsl_type_builtin_error);
@@ -1708,7 +1708,7 @@ glsl_get_mul_type(const struct glsl_type *type_a, const struct glsl_type *type_b
 }
 
 int
-glsl_get_field_index(const struct glsl_type *t, const char *name)
+glsl_get_field_index(const glsl_type *t, const char *name)
 {
    if (t->base_type != GLSL_TYPE_STRUCT &&
        t->base_type != GLSL_TYPE_INTERFACE)
@@ -1722,8 +1722,8 @@ glsl_get_field_index(const struct glsl_type *t, const char *name)
    return -1;
 }
 
-const struct glsl_type *
-glsl_get_field_type(const struct glsl_type *t, const char *name)
+const glsl_type *
+glsl_get_field_type(const glsl_type *t, const char *name)
 {
    const int idx = glsl_get_field_index(t, name);
    if (idx == -1)
@@ -1732,7 +1732,7 @@ glsl_get_field_type(const struct glsl_type *t, const char *name)
 }
 
 unsigned
-glsl_get_component_slots(const struct glsl_type *t)
+glsl_get_component_slots(const glsl_type *t)
 {
    switch (t->base_type) {
    case GLSL_TYPE_UINT:
@@ -1783,7 +1783,7 @@ glsl_get_component_slots(const struct glsl_type *t)
 }
 
 unsigned
-glsl_get_component_slots_aligned(const struct glsl_type *t, unsigned offset)
+glsl_get_component_slots_aligned(const glsl_type *t, unsigned offset)
 {
    /* Align 64bit type only if it crosses attribute slot boundary. */
    switch (t->base_type) {
@@ -1814,7 +1814,7 @@ glsl_get_component_slots_aligned(const struct glsl_type *t, unsigned offset)
       unsigned size = 0;
 
       for (unsigned i = 0; i < t->length; i++) {
-         const struct glsl_type *member = t->fields.structure[i].type;
+         const glsl_type *member = t->fields.structure[i].type;
          size += glsl_get_component_slots_aligned(member, size + offset);
       }
 
@@ -1851,7 +1851,7 @@ glsl_get_component_slots_aligned(const struct glsl_type *t, unsigned offset)
 }
 
 unsigned
-glsl_get_struct_location_offset(const struct glsl_type *t, unsigned length)
+glsl_get_struct_location_offset(const glsl_type *t, unsigned length)
 {
    unsigned offset = 0;
    t = glsl_without_array(t);
@@ -1859,15 +1859,15 @@ glsl_get_struct_location_offset(const struct glsl_type *t, unsigned length)
       assert(length <= t->length);
 
       for (unsigned i = 0; i < length; i++) {
-         const struct glsl_type *st = t->fields.structure[i].type;
-         const struct glsl_type *wa = glsl_without_array(st);
+         const glsl_type *st = t->fields.structure[i].type;
+         const glsl_type *wa = glsl_without_array(st);
          if (glsl_type_is_struct(wa)) {
             unsigned r_offset = glsl_get_struct_location_offset(wa, wa->length);
             offset += glsl_type_is_array(st) ?
                glsl_get_aoa_size(st) * r_offset : r_offset;
          } else if (glsl_type_is_array(st) && glsl_type_is_array(st->fields.array)) {
             unsigned outer_array_size = st->length;
-            const struct glsl_type *base_type = st->fields.array;
+            const glsl_type *base_type = st->fields.array;
 
             /* For arrays of arrays the outer arrays take up a uniform
              * slot for each element. The innermost array elements share a
@@ -1892,7 +1892,7 @@ glsl_get_struct_location_offset(const struct glsl_type *t, unsigned length)
 }
 
 unsigned
-glsl_type_uniform_locations(const struct glsl_type *t)
+glsl_type_uniform_locations(const glsl_type *t)
 {
    unsigned size = 0;
 
@@ -1928,7 +1928,7 @@ glsl_type_uniform_locations(const struct glsl_type *t)
 }
 
 unsigned
-glsl_varying_count(const struct glsl_type *t)
+glsl_varying_count(const glsl_type *t)
 {
    unsigned size = 0;
 
@@ -1967,7 +1967,7 @@ glsl_varying_count(const struct glsl_type *t)
 }
 
 unsigned
-glsl_get_std140_base_alignment(const struct glsl_type *t, bool row_major)
+glsl_get_std140_base_alignment(const glsl_type *t, bool row_major)
 {
    unsigned N = glsl_type_is_64bit(t) ? 8 : 4;
 
@@ -2035,7 +2035,7 @@ glsl_get_std140_base_alignment(const struct glsl_type *t, bool row_major)
     *     row vectors with <C> components each, according to rule (4).
     */
    if (glsl_type_is_matrix(t)) {
-      const struct glsl_type *vec_type, *array_type;
+      const glsl_type *vec_type, *array_type;
       int c = t->matrix_columns;
       int r = t->vector_elements;
 
@@ -2074,7 +2074,7 @@ glsl_get_std140_base_alignment(const struct glsl_type *t, bool row_major)
             field_row_major = false;
          }
 
-         const struct glsl_type *field_type = t->fields.structure[i].type;
+         const glsl_type *field_type = t->fields.structure[i].type;
          base_alignment = MAX2(base_alignment,
                                glsl_get_std140_base_alignment(field_type, field_row_major));
       }
@@ -2086,7 +2086,7 @@ glsl_get_std140_base_alignment(const struct glsl_type *t, bool row_major)
 }
 
 unsigned
-glsl_get_std140_size(const struct glsl_type *t, bool row_major)
+glsl_get_std140_size(const glsl_type *t, bool row_major)
 {
    unsigned N = glsl_type_is_64bit(t) ? 8 : 4;
 
@@ -2124,8 +2124,8 @@ glsl_get_std140_size(const struct glsl_type *t, bool row_major)
     *     row vectors with <C> components each, according to rule (4).
     */
    if (glsl_type_is_matrix(glsl_without_array(t))) {
-      const struct glsl_type *element_type;
-      const struct glsl_type *vec_type;
+      const glsl_type *element_type;
+      const glsl_type *vec_type;
       unsigned int array_len;
 
       if (glsl_type_is_array(t)) {
@@ -2146,7 +2146,7 @@ glsl_get_std140_size(const struct glsl_type *t, bool row_major)
                                      element_type->vector_elements, 1);
          array_len *= element_type->matrix_columns;
       }
-      const struct glsl_type *array_type =
+      const glsl_type *array_type =
          glsl_array_type(vec_type, array_len, 0);
 
       return glsl_get_std140_size(array_type, false);
@@ -2204,7 +2204,7 @@ glsl_get_std140_size(const struct glsl_type *t, bool row_major)
             field_row_major = false;
          }
 
-         const struct glsl_type *field_type = t->fields.structure[i].type;
+         const glsl_type *field_type = t->fields.structure[i].type;
          unsigned base_alignment = glsl_get_std140_base_alignment(field_type,
                                                                   field_row_major);
 
@@ -2228,13 +2228,13 @@ glsl_get_std140_size(const struct glsl_type *t, bool row_major)
    return -1;
 }
 
-const struct glsl_type *
-glsl_get_explicit_std140_type(const struct glsl_type *t, bool row_major)
+const glsl_type *
+glsl_get_explicit_std140_type(const glsl_type *t, bool row_major)
 {
    if (glsl_type_is_vector(t) || glsl_type_is_scalar(t)) {
       return t;
    } else if (glsl_type_is_matrix(t)) {
-      const struct glsl_type *vec_type;
+      const glsl_type *vec_type;
       if (row_major)
          vec_type = glsl_simple_type(t->base_type, t->matrix_columns, 1);
       else
@@ -2246,13 +2246,13 @@ glsl_get_explicit_std140_type(const struct glsl_type *t, bool row_major)
                                        0);
    } else if (glsl_type_is_array(t)) {
       unsigned elem_size = glsl_get_std140_size(t->fields.array, row_major);
-      const struct glsl_type *elem_type =
+      const glsl_type *elem_type =
          glsl_get_explicit_std140_type(t->fields.array, row_major);
       unsigned stride = align(elem_size, 16);
       return glsl_array_type(elem_type, t->length, stride);
    } else if (glsl_type_is_struct(t) || glsl_type_is_interface(t)) {
-      struct glsl_struct_field *fields = (struct glsl_struct_field *)
-         calloc(t->length, sizeof(struct glsl_struct_field));
+      glsl_struct_field *fields = (glsl_struct_field *)
+         calloc(t->length, sizeof(glsl_struct_field));
       unsigned offset = 0;
       for (unsigned i = 0; i < t->length; i++) {
          fields[i] = t->fields.structure[i];
@@ -2289,7 +2289,7 @@ glsl_get_explicit_std140_type(const struct glsl_type *t, bool row_major)
          offset += fsize;
       }
 
-      const struct glsl_type *type;
+      const glsl_type *type;
       if (glsl_type_is_struct(t))
          type = glsl_struct_type(fields, t->length, glsl_get_type_name(t), false);
       else
@@ -2305,7 +2305,7 @@ glsl_get_explicit_std140_type(const struct glsl_type *t, bool row_major)
 }
 
 unsigned
-glsl_get_std430_base_alignment(const struct glsl_type *t, bool row_major)
+glsl_get_std430_base_alignment(const glsl_type *t, bool row_major)
 {
 
    unsigned N = glsl_type_is_64bit(t) ? 8 : 4;
@@ -2364,7 +2364,7 @@ glsl_get_std430_base_alignment(const struct glsl_type *t, bool row_major)
     *     row vectors with <C> components each, according to rule (4).
     */
    if (glsl_type_is_matrix(t)) {
-      const struct glsl_type *vec_type, *array_type;
+      const glsl_type *vec_type, *array_type;
       int c = t->matrix_columns;
       int r = t->vector_elements;
 
@@ -2403,7 +2403,7 @@ glsl_get_std430_base_alignment(const struct glsl_type *t, bool row_major)
             field_row_major = false;
          }
 
-         const struct glsl_type *field_type = t->fields.structure[i].type;
+         const glsl_type *field_type = t->fields.structure[i].type;
          base_alignment = MAX2(base_alignment,
                                glsl_get_std430_base_alignment(field_type, field_row_major));
       }
@@ -2415,7 +2415,7 @@ glsl_get_std430_base_alignment(const struct glsl_type *t, bool row_major)
 }
 
 unsigned
-glsl_get_std430_array_stride(const struct glsl_type *t, bool row_major)
+glsl_get_std430_array_stride(const glsl_type *t, bool row_major)
 {
    unsigned N = glsl_type_is_64bit(t) ? 8 : 4;
 
@@ -2440,7 +2440,7 @@ glsl_get_std430_array_stride(const struct glsl_type *t, bool row_major)
  */
 
 unsigned
-glsl_get_explicit_size(const struct glsl_type *t, bool align_to_stride)
+glsl_get_explicit_size(const glsl_type *t, bool align_to_stride)
 {
    if (glsl_type_is_struct(t) || glsl_type_is_interface(t)) {
       if (t->length > 0) {
@@ -2479,7 +2479,7 @@ glsl_get_explicit_size(const struct glsl_type *t, bool align_to_stride)
 
       return t->explicit_stride * (t->length - 1) + elem_size;
    } else if (glsl_type_is_matrix(t)) {
-      const struct glsl_type *elem_type;
+      const glsl_type *elem_type;
       unsigned length;
 
       if (t->interface_row_major) {
@@ -2503,7 +2503,7 @@ glsl_get_explicit_size(const struct glsl_type *t, bool align_to_stride)
 }
 
 unsigned
-glsl_get_std430_size(const struct glsl_type *t, bool row_major)
+glsl_get_std430_size(const glsl_type *t, bool row_major)
 {
    unsigned N = glsl_type_is_64bit(t) ? 8 : 4;
 
@@ -2521,8 +2521,8 @@ glsl_get_std430_size(const struct glsl_type *t, bool row_major)
    }
 
    if (glsl_type_is_matrix(glsl_without_array(t))) {
-      const struct glsl_type *element_type;
-      const struct glsl_type *vec_type;
+      const glsl_type *element_type;
+      const glsl_type *vec_type;
       unsigned int array_len;
 
       if (glsl_type_is_array(t)) {
@@ -2543,7 +2543,7 @@ glsl_get_std430_size(const struct glsl_type *t, bool row_major)
                                      element_type->vector_elements, 1);
          array_len *= element_type->matrix_columns;
       }
-      const struct glsl_type *array_type =
+      const glsl_type *array_type =
          glsl_array_type(vec_type, array_len, 0);
 
       return glsl_get_std430_size(array_type, false);
@@ -2577,7 +2577,7 @@ glsl_get_std430_size(const struct glsl_type *t, bool row_major)
             field_row_major = false;
          }
 
-         const struct glsl_type *field_type = t->fields.structure[i].type;
+         const glsl_type *field_type = t->fields.structure[i].type;
          unsigned base_alignment = glsl_get_std430_base_alignment(field_type,
                                                                   field_row_major);
          size = align(size, base_alignment);
@@ -2593,13 +2593,13 @@ glsl_get_std430_size(const struct glsl_type *t, bool row_major)
    return -1;
 }
 
-const struct glsl_type *
-glsl_get_explicit_std430_type(const struct glsl_type *t, bool row_major)
+const glsl_type *
+glsl_get_explicit_std430_type(const glsl_type *t, bool row_major)
 {
    if (glsl_type_is_vector(t) || glsl_type_is_scalar(t)) {
       return t;
    } else if (glsl_type_is_matrix(t)) {
-      const struct glsl_type *vec_type;
+      const glsl_type *vec_type;
       if (row_major)
          vec_type = glsl_simple_type(t->base_type, t->matrix_columns, 1);
       else
@@ -2609,14 +2609,14 @@ glsl_get_explicit_std430_type(const struct glsl_type *t, bool row_major)
                                        t->matrix_columns, stride, row_major,
                                        0);
    } else if (glsl_type_is_array(t)) {
-      const struct glsl_type *elem_type =
+      const glsl_type *elem_type =
          glsl_get_explicit_std430_type(t->fields.array, row_major);
       unsigned stride = glsl_get_std430_array_stride(t->fields.array,
                                                      row_major);
       return glsl_array_type(elem_type, t->length, stride);
    } else if (glsl_type_is_struct(t) || glsl_type_is_interface(t)) {
-      struct glsl_struct_field *fields = (struct glsl_struct_field *)
-         calloc(t->length, sizeof(struct glsl_struct_field));
+      glsl_struct_field *fields = (glsl_struct_field *)
+         calloc(t->length, sizeof(glsl_struct_field));
       unsigned offset = 0;
       for (unsigned i = 0; i < t->length; i++) {
          fields[i] = t->fields.structure[i];
@@ -2653,7 +2653,7 @@ glsl_get_explicit_std430_type(const struct glsl_type *t, bool row_major)
          offset += fsize;
       }
 
-      const struct glsl_type *type;
+      const glsl_type *type;
       if (glsl_type_is_struct(t))
          type = glsl_struct_type(fields, t->length, glsl_get_type_name(t), false);
       else
@@ -2669,7 +2669,7 @@ glsl_get_explicit_std430_type(const struct glsl_type *t, bool row_major)
 }
 
 static unsigned
-explicit_type_scalar_byte_size(const struct glsl_type *type)
+explicit_type_scalar_byte_size(const glsl_type *type)
 {
    if (type->base_type == GLSL_TYPE_BOOL)
       return 4;
@@ -2685,8 +2685,8 @@ explicit_type_scalar_byte_size(const struct glsl_type *type)
  * - overrides any struct field offsets but get_explicit_std430_type() tries to
  *   respect any existing ones
  */
-const struct glsl_type *
-glsl_get_explicit_type_for_size_align(const struct glsl_type *t,
+const glsl_type *
+glsl_get_explicit_type_for_size_align(const glsl_type *t,
                                       glsl_type_size_align_func type_info,
                                       unsigned *size, unsigned *alignment)
 {
@@ -2711,7 +2711,7 @@ glsl_get_explicit_type_for_size_align(const struct glsl_type *t,
                                        false, *alignment);
    } else if (glsl_type_is_array(t)) {
       unsigned elem_size, elem_align;
-      const struct glsl_type *explicit_element =
+      const glsl_type *explicit_element =
          glsl_get_explicit_type_for_size_align(t->fields.array, type_info,
                                                &elem_size, &elem_align);
 
@@ -2721,8 +2721,8 @@ glsl_get_explicit_type_for_size_align(const struct glsl_type *t,
       *alignment = elem_align;
       return glsl_array_type(explicit_element, t->length, stride);
    } else if (glsl_type_is_struct(t) || glsl_type_is_interface(t)) {
-      struct glsl_struct_field *fields = (struct glsl_struct_field *)
-         malloc(sizeof(struct glsl_struct_field) * t->length);
+      glsl_struct_field *fields = (glsl_struct_field *)
+         malloc(sizeof(glsl_struct_field) * t->length);
 
       *size = 0;
       *alignment = 1;
@@ -2751,7 +2751,7 @@ glsl_get_explicit_type_for_size_align(const struct glsl_type *t,
        */
       *size = align(*size, *alignment);
 
-      const struct glsl_type *type;
+      const glsl_type *type;
       if (glsl_type_is_struct(t)) {
          type = glsl_struct_type_with_explicit_alignment(fields, t->length,
                                                          glsl_get_type_name(t), t->packed,
@@ -2781,8 +2781,8 @@ glsl_get_explicit_type_for_size_align(const struct glsl_type *t,
    }
 }
 
-const struct glsl_type *
-glsl_type_replace_vec3_with_vec4(const struct glsl_type *t)
+const glsl_type *
+glsl_type_replace_vec3_with_vec4(const glsl_type *t)
 {
    if (glsl_type_is_scalar(t) || glsl_type_is_vector(t) || glsl_type_is_matrix(t)) {
       if (t->interface_row_major) {
@@ -2806,14 +2806,14 @@ glsl_type_replace_vec3_with_vec4(const struct glsl_type *t)
          }
       }
    } else if (glsl_type_is_array(t)) {
-      const struct glsl_type *vec4_elem_type =
+      const glsl_type *vec4_elem_type =
          glsl_type_replace_vec3_with_vec4(t->fields.array);
       if (vec4_elem_type == t->fields.array)
          return t;
       return glsl_array_type(vec4_elem_type, t->length, t->explicit_stride);
    } else if (glsl_type_is_struct(t) || glsl_type_is_interface(t)) {
-      struct glsl_struct_field *fields = (struct glsl_struct_field *)
-         malloc(sizeof(struct glsl_struct_field) * t->length);
+      glsl_struct_field *fields = (glsl_struct_field *)
+         malloc(sizeof(glsl_struct_field) * t->length);
 
       bool needs_new_type = false;
       for (unsigned i = 0; i < t->length; i++) {
@@ -2824,7 +2824,7 @@ glsl_type_replace_vec3_with_vec4(const struct glsl_type *t)
             needs_new_type = true;
       }
 
-      const struct glsl_type *type;
+      const glsl_type *type;
       if (!needs_new_type) {
          type = t;
       } else if (glsl_type_is_struct(t)) {
@@ -2845,7 +2845,7 @@ glsl_type_replace_vec3_with_vec4(const struct glsl_type *t)
 }
 
 unsigned
-glsl_count_vec4_slots(const struct glsl_type *t, bool is_gl_vertex_input, bool is_bindless)
+glsl_count_vec4_slots(const glsl_type *t, bool is_gl_vertex_input, bool is_bindless)
 {
    /* From page 31 (page 37 of the PDF) of the GLSL 1.50 spec:
     *
@@ -2895,7 +2895,7 @@ glsl_count_vec4_slots(const struct glsl_type *t, bool is_gl_vertex_input, bool i
       unsigned size = 0;
 
       for (unsigned i = 0; i < t->length; i++) {
-         const struct glsl_type *member_type = t->fields.structure[i].type;
+         const glsl_type *member_type = t->fields.structure[i].type;
          size += glsl_count_vec4_slots(member_type, is_gl_vertex_input,
                                        is_bindless);
       }
@@ -2904,7 +2904,7 @@ glsl_count_vec4_slots(const struct glsl_type *t, bool is_gl_vertex_input, bool i
    }
 
    case GLSL_TYPE_ARRAY: {
-      const struct glsl_type *element = t->fields.array;
+      const glsl_type *element = t->fields.array;
       return t->length * glsl_count_vec4_slots(element, is_gl_vertex_input,
                                                is_bindless);
    }
@@ -2933,7 +2933,7 @@ glsl_count_vec4_slots(const struct glsl_type *t, bool is_gl_vertex_input, bool i
 }
 
 unsigned
-glsl_count_dword_slots(const struct glsl_type *t, bool is_bindless)
+glsl_count_dword_slots(const glsl_type *t, bool is_bindless)
 {
    switch (t->base_type) {
    case GLSL_TYPE_UINT:
@@ -2986,7 +2986,7 @@ glsl_count_dword_slots(const struct glsl_type *t, bool is_bindless)
 }
 
 int
-glsl_get_sampler_coordinate_components(const struct glsl_type *t)
+glsl_get_sampler_coordinate_components(const glsl_type *t)
 {
    assert(glsl_type_is_sampler(t) ||
           glsl_type_is_texture(t) ||
@@ -3040,7 +3040,7 @@ union packed_type {
 };
 
 static void
-encode_glsl_struct_field(struct blob *blob, const struct glsl_struct_field *struct_field)
+encode_glsl_struct_field(struct blob *blob, const glsl_struct_field *struct_field)
 {
    encode_type_to_blob(blob, struct_field->type);
    blob_write_string(blob, struct_field->name);
@@ -3054,7 +3054,7 @@ encode_glsl_struct_field(struct blob *blob, const struct glsl_struct_field *stru
 }
 
 static void
-decode_glsl_struct_field_from_blob(struct blob_reader *blob, struct glsl_struct_field *struct_field)
+decode_glsl_struct_field_from_blob(struct blob_reader *blob, glsl_struct_field *struct_field)
 {
    struct_field->type = decode_type_from_blob(blob);
    struct_field->name = blob_read_string(blob);
@@ -3068,7 +3068,7 @@ decode_glsl_struct_field_from_blob(struct blob_reader *blob, struct glsl_struct_
 }
 
 void
-encode_type_to_blob(struct blob *blob, const struct glsl_type *type)
+encode_type_to_blob(struct blob *blob, const glsl_type *type)
 {
    if (!type) {
       blob_write_uint32(blob, 0);
@@ -3183,7 +3183,7 @@ encode_type_to_blob(struct blob *blob, const struct glsl_type *type)
    blob_write_uint32(blob, encoded.u32);
 }
 
-const struct glsl_type *
+const glsl_type *
 decode_type_from_blob(struct blob_reader *blob)
 {
    union packed_type encoded;
@@ -3269,12 +3269,12 @@ decode_type_from_blob(struct blob_reader *blob)
       else if (explicit_alignment > 0)
          explicit_alignment = 1 << (explicit_alignment - 1);
 
-      struct glsl_struct_field *fields = (struct glsl_struct_field *)
-         malloc(sizeof(struct glsl_struct_field) * num_fields);
+      glsl_struct_field *fields = (glsl_struct_field *)
+         malloc(sizeof(glsl_struct_field) * num_fields);
       for (unsigned i = 0; i < num_fields; i++)
          decode_glsl_struct_field_from_blob(blob, &fields[i]);
 
-      const struct glsl_type *t;
+      const glsl_type *t;
       if (base_type == GLSL_TYPE_INTERFACE) {
          assert(explicit_alignment == 0);
          enum glsl_interface_packing packing =
@@ -3301,7 +3301,7 @@ decode_type_from_blob(struct blob_reader *blob)
 }
 
 unsigned
-glsl_get_cl_alignment(const struct glsl_type *t)
+glsl_get_cl_alignment(const glsl_type *t)
 {
    /* vectors unlike arrays are aligned to their size */
    if (glsl_type_is_scalar(t) || glsl_type_is_vector(t))
@@ -3315,7 +3315,7 @@ glsl_get_cl_alignment(const struct glsl_type *t)
 
       unsigned res = 1;
       for (unsigned i = 0; i < t->length; ++i) {
-         const struct glsl_struct_field *field = &t->fields.structure[i];
+         const glsl_struct_field *field = &t->fields.structure[i];
          res = MAX2(res, glsl_get_cl_alignment(field->type));
       }
       return res;
@@ -3324,7 +3324,7 @@ glsl_get_cl_alignment(const struct glsl_type *t)
 }
 
 unsigned
-glsl_get_cl_size(const struct glsl_type *t)
+glsl_get_cl_size(const glsl_type *t)
 {
    if (glsl_type_is_scalar(t) || glsl_type_is_vector(t)) {
       return util_next_power_of_two(t->vector_elements) *
@@ -3336,7 +3336,7 @@ glsl_get_cl_size(const struct glsl_type *t)
       unsigned size = 0;
       unsigned max_alignment = 1;
       for (unsigned i = 0; i < t->length; ++i) {
-         const struct glsl_struct_field *field = &t->fields.structure[i];
+         const glsl_struct_field *field = &t->fields.structure[i];
          /* if a struct is packed, members don't get aligned */
          if (!t->packed) {
             unsigned alignment = glsl_get_cl_alignment(field->type);
@@ -3356,7 +3356,7 @@ glsl_get_cl_size(const struct glsl_type *t)
 extern const char glsl_type_builtin_names[];
 
 const char *
-glsl_get_type_name(const struct glsl_type *type)
+glsl_get_type_name(const glsl_type *type)
 {
    if (type->has_builtin_name) {
       return &glsl_type_builtin_names[type->name_id];
@@ -3366,7 +3366,7 @@ glsl_get_type_name(const struct glsl_type *type)
 }
 
 void
-glsl_get_cl_type_size_align(const struct glsl_type *t,
+glsl_get_cl_type_size_align(const glsl_type *t,
                             unsigned *size, unsigned *align)
 {
    *size = glsl_get_cl_size(t);
@@ -3396,7 +3396,7 @@ glsl_get_sampler_dim_coordinate_components(enum glsl_sampler_dim dim)
 }
 
 bool
-glsl_type_is_vector(const struct glsl_type *t)
+glsl_type_is_vector(const glsl_type *t)
 {
    return t->vector_elements > 1 &&
           t->matrix_columns == 1 &&
@@ -3405,7 +3405,7 @@ glsl_type_is_vector(const struct glsl_type *t)
 }
 
 bool
-glsl_type_is_scalar(const struct glsl_type *t)
+glsl_type_is_scalar(const glsl_type *t)
 {
    return t->vector_elements == 1 &&
           t->base_type >= GLSL_TYPE_UINT &&
@@ -3413,13 +3413,13 @@ glsl_type_is_scalar(const struct glsl_type *t)
 }
 
 bool
-glsl_type_is_vector_or_scalar(const struct glsl_type *t)
+glsl_type_is_vector_or_scalar(const glsl_type *t)
 {
    return glsl_type_is_vector(t) || glsl_type_is_scalar(t);
 }
 
 bool
-glsl_type_is_matrix(const struct glsl_type *t)
+glsl_type_is_matrix(const glsl_type *t)
 {
    /* GLSL only has float matrices. */
    return t->matrix_columns > 1 && (t->base_type == GLSL_TYPE_FLOAT ||
@@ -3428,19 +3428,19 @@ glsl_type_is_matrix(const struct glsl_type *t)
 }
 
 bool
-glsl_type_is_array_or_matrix(const struct glsl_type *t)
+glsl_type_is_array_or_matrix(const glsl_type *t)
 {
    return glsl_type_is_array(t) || glsl_type_is_matrix(t);
 }
 
 bool
-glsl_type_is_dual_slot(const struct glsl_type *t)
+glsl_type_is_dual_slot(const glsl_type *t)
 {
    return glsl_type_is_64bit(t) && t->vector_elements > 2;
 }
 
-const struct glsl_type *
-glsl_get_array_element(const struct glsl_type *t)
+const glsl_type *
+glsl_get_array_element(const glsl_type *t)
 {
    if (glsl_type_is_matrix(t))
       return glsl_get_column_type(t);
@@ -3450,7 +3450,7 @@ glsl_get_array_element(const struct glsl_type *t)
 }
 
 bool
-glsl_type_is_leaf(const struct glsl_type *t)
+glsl_type_is_leaf(const glsl_type *t)
 {
    if (glsl_type_is_struct_or_ifc(t) ||
        (glsl_type_is_array(t) &&
@@ -3463,21 +3463,21 @@ glsl_type_is_leaf(const struct glsl_type *t)
 }
 
 bool
-glsl_contains_atomic(const struct glsl_type *t)
+glsl_contains_atomic(const glsl_type *t)
 {
    return glsl_atomic_size(t) > 0;
 }
 
-const struct glsl_type *
-glsl_without_array(const struct glsl_type *t)
+const glsl_type *
+glsl_without_array(const glsl_type *t)
 {
    while (glsl_type_is_array(t))
       t = t->fields.array;
    return t;
 }
 
-const struct glsl_type *
-glsl_without_array_or_matrix(const struct glsl_type *t)
+const glsl_type *
+glsl_without_array_or_matrix(const glsl_type *t)
 {
    t = glsl_without_array(t);
    if (glsl_type_is_matrix(t))
@@ -3485,35 +3485,35 @@ glsl_without_array_or_matrix(const struct glsl_type *t)
    return t;
 }
 
-const struct glsl_type *
-glsl_type_wrap_in_arrays(const struct glsl_type *t,
-                         const struct glsl_type *arrays)
+const glsl_type *
+glsl_type_wrap_in_arrays(const glsl_type *t,
+                         const glsl_type *arrays)
 {
    if (!glsl_type_is_array(arrays))
       return t;
 
-   const struct glsl_type *elem_type =
+   const glsl_type *elem_type =
       glsl_type_wrap_in_arrays(t, glsl_get_array_element(arrays));
    return glsl_array_type(elem_type, glsl_get_length(arrays),
                           glsl_get_explicit_stride(arrays));
 }
 
-const struct glsl_type *
-glsl_get_cmat_element(const struct glsl_type *t)
+const glsl_type *
+glsl_get_cmat_element(const glsl_type *t)
 {
    assert(t->base_type == GLSL_TYPE_COOPERATIVE_MATRIX);
    return glsl_simple_type(t->cmat_desc.element_type, 1, 1);
 }
 
 const struct glsl_cmat_description *
-glsl_get_cmat_description(const struct glsl_type *t)
+glsl_get_cmat_description(const glsl_type *t)
 {
    assert(t->base_type == GLSL_TYPE_COOPERATIVE_MATRIX);
    return &t->cmat_desc;
 }
 
 unsigned
-glsl_get_length(const struct glsl_type *t)
+glsl_get_length(const glsl_type *t)
 {
    if (glsl_type_is_matrix(t))
       return t->matrix_columns;
@@ -3523,13 +3523,13 @@ glsl_get_length(const struct glsl_type *t)
 }
 
 unsigned
-glsl_get_aoa_size(const struct glsl_type *t)
+glsl_get_aoa_size(const glsl_type *t)
 {
    if (!glsl_type_is_array(t))
       return 0;
 
    unsigned size = t->length;
-   const struct glsl_type *array_base_type = t->fields.array;
+   const glsl_type *array_base_type = t->fields.array;
 
    while (glsl_type_is_array(array_base_type)) {
       size = size * array_base_type->length;
@@ -3538,16 +3538,16 @@ glsl_get_aoa_size(const struct glsl_type *t)
    return size;
 }
 
-const struct glsl_type *
-glsl_get_struct_field(const struct glsl_type *t, unsigned index)
+const glsl_type *
+glsl_get_struct_field(const glsl_type *t, unsigned index)
 {
    assert(glsl_type_is_struct(t) || glsl_type_is_interface(t));
    assert(index < t->length);
    return t->fields.structure[index].type;
 }
 
-const struct glsl_struct_field *
-glsl_get_struct_field_data(const struct glsl_type *t, unsigned index)
+const glsl_struct_field *
+glsl_get_struct_field_data(const glsl_type *t, unsigned index)
 {
    assert(glsl_type_is_struct(t) || glsl_type_is_interface(t));
    assert(index < t->length);
@@ -3555,7 +3555,7 @@ glsl_get_struct_field_data(const struct glsl_type *t, unsigned index)
 }
 
 enum glsl_interface_packing
-glsl_get_internal_ifc_packing(const struct glsl_type *t,
+glsl_get_internal_ifc_packing(const glsl_type *t,
                               bool std430_supported)
 {
    enum glsl_interface_packing packing = glsl_get_ifc_packing(t);
@@ -3573,8 +3573,8 @@ glsl_get_internal_ifc_packing(const struct glsl_type *t,
    }
 }
 
-const struct glsl_type *
-glsl_get_row_type(const struct glsl_type *t)
+const glsl_type *
+glsl_get_row_type(const glsl_type *t)
 {
    if (!glsl_type_is_matrix(t))
       return &glsl_type_builtin_error;
@@ -3586,8 +3586,8 @@ glsl_get_row_type(const struct glsl_type *t)
       return glsl_simple_type(t->base_type, t->matrix_columns, 1);
 }
 
-const struct glsl_type *
-glsl_get_column_type(const struct glsl_type *t)
+const glsl_type *
+glsl_get_column_type(const glsl_type *t)
 {
    if (!glsl_type_is_matrix(t))
       return &glsl_type_builtin_error;
@@ -3610,7 +3610,7 @@ glsl_get_column_type(const struct glsl_type *t)
 }
 
 unsigned
-glsl_atomic_size(const struct glsl_type *t)
+glsl_atomic_size(const glsl_type *t)
 {
    if (glsl_type_is_atomic_uint(t))
       return 4; /* ATOMIC_COUNTER_SIZE */
@@ -3620,8 +3620,8 @@ glsl_atomic_size(const struct glsl_type *t)
       return 0;
 }
 
-const struct glsl_type *
-glsl_type_to_16bit(const struct glsl_type *old_type)
+const glsl_type *
+glsl_type_to_16bit(const glsl_type *old_type)
 {
    if (glsl_type_is_array(old_type)) {
       return glsl_array_type(glsl_type_to_16bit(glsl_get_array_element(old_type)),
@@ -3645,8 +3645,8 @@ glsl_type_to_16bit(const struct glsl_type *old_type)
    return old_type;
 }
 
-const struct glsl_type *
-glsl_replace_vector_type(const struct glsl_type *t, unsigned components)
+const glsl_type *
+glsl_replace_vector_type(const glsl_type *t, unsigned components)
 {
    if (glsl_type_is_array(t)) {
       return glsl_array_type(
@@ -3659,8 +3659,8 @@ glsl_replace_vector_type(const struct glsl_type *t, unsigned components)
    }
 }
 
-const struct glsl_type *
-glsl_channel_type(const struct glsl_type *t)
+const glsl_type *
+glsl_channel_type(const glsl_type *t)
 {
    switch (t->base_type) {
    case GLSL_TYPE_ARRAY:
@@ -3685,7 +3685,7 @@ glsl_channel_type(const struct glsl_type *t)
 }
 
 static void
-glsl_size_align_handle_array_and_structs(const struct glsl_type *type,
+glsl_size_align_handle_array_and_structs(const glsl_type *type,
                                          glsl_type_size_align_func size_align,
                                          unsigned *size, unsigned *align)
 {
@@ -3710,7 +3710,7 @@ glsl_size_align_handle_array_and_structs(const struct glsl_type *type,
 }
 
 void
-glsl_get_natural_size_align_bytes(const struct glsl_type *type,
+glsl_get_natural_size_align_bytes(const glsl_type *type,
                                   unsigned *size, unsigned *align)
 {
    switch (type->base_type) {
@@ -3769,7 +3769,7 @@ glsl_get_natural_size_align_bytes(const struct glsl_type *type,
  * field is aligned to 16 bytes.
  */
 void
-glsl_get_vec4_size_align_bytes(const struct glsl_type *type,
+glsl_get_vec4_size_align_bytes(const glsl_type *type,
                                unsigned *size, unsigned *align)
 {
    switch (type->base_type) {
@@ -3819,7 +3819,7 @@ glsl_get_vec4_size_align_bytes(const struct glsl_type *type,
 }
 
 static unsigned
-glsl_type_count(const struct glsl_type *type, enum glsl_base_type base_type)
+glsl_type_count(const glsl_type *type, enum glsl_base_type base_type)
 {
    if (glsl_type_is_array(type)) {
       return glsl_get_length(type) *
@@ -3843,19 +3843,19 @@ glsl_type_count(const struct glsl_type *type, enum glsl_base_type base_type)
 }
 
 unsigned
-glsl_type_get_sampler_count(const struct glsl_type *type)
+glsl_type_get_sampler_count(const glsl_type *type)
 {
    return glsl_type_count(type, GLSL_TYPE_SAMPLER);
 }
 
 unsigned
-glsl_type_get_texture_count(const struct glsl_type *type)
+glsl_type_get_texture_count(const glsl_type *type)
 {
    return glsl_type_count(type, GLSL_TYPE_TEXTURE);
 }
 
 unsigned
-glsl_type_get_image_count(const struct glsl_type *type)
+glsl_type_get_image_count(const glsl_type *type)
 {
    return glsl_type_count(type, GLSL_TYPE_IMAGE);
 }
diff --git a/src/compiler/glsl_types.h b/src/compiler/glsl_types.h
index e3c56aad09e4c..ad1c4dbe0ef52 100644
--- a/src/compiler/glsl_types.h
+++ b/src/compiler/glsl_types.h
@@ -35,12 +35,12 @@
 #include "util/format/u_format.h"
 #include "util/macros.h"
 
-struct glsl_type;
-
 #ifdef __cplusplus
 extern "C" {
 #endif
 
+typedef struct glsl_type glsl_type;
+typedef struct glsl_struct_field glsl_struct_field;
 struct _mesa_glsl_parse_state;
 struct glsl_symbol_table;
 
@@ -53,11 +53,11 @@ glsl_type_singleton_decref(void);
 extern void
 _mesa_glsl_initialize_types(struct _mesa_glsl_parse_state *state);
 
-void encode_type_to_blob(struct blob *blob, const struct glsl_type *type);
+void encode_type_to_blob(struct blob *blob, const glsl_type *type);
 
-const struct glsl_type *decode_type_from_blob(struct blob_reader *blob);
+const glsl_type *decode_type_from_blob(struct blob_reader *blob);
 
-typedef void (*glsl_type_size_align_func)(const struct glsl_type *type,
+typedef void (*glsl_type_size_align_func)(const glsl_type *type,
                                           unsigned *size, unsigned *alignment);
 
 enum glsl_base_type {
@@ -299,7 +299,7 @@ struct glsl_cmat_description {
    uint8_t use; /* enum glsl_cmat_use */
 };
 
-const char *glsl_get_type_name(const struct glsl_type *type);
+const char *glsl_get_type_name(const glsl_type *type);
 
 struct glsl_type {
    uint32_t gl_type;
@@ -372,15 +372,15 @@ struct glsl_type {
     * Subtype of composite data types.
     */
    union {
-      const struct glsl_type *array;            /**< Type of array elements. */
-      const struct glsl_struct_field *structure;      /**< List of struct fields. */
+      const glsl_type *array;            /**< Type of array elements. */
+      const glsl_struct_field *structure;      /**< List of struct fields. */
    } fields;
 };
 
 #include "builtin_types.h"
 
 struct glsl_struct_field {
-   const struct glsl_type *type;
+   const glsl_type *type;
    const char *name;
 
    /**
@@ -485,7 +485,7 @@ struct glsl_struct_field {
    type(_type), name(_name), location(-1), component(-1), offset(-1), \
    xfb_buffer(0),  xfb_stride(0), image_format(PIPE_FORMAT_NONE), flags(0) \
 
-   glsl_struct_field(const struct glsl_type *_type,
+   glsl_struct_field(const glsl_type *_type,
                      int _precision,
                      const char *_name)
       : DEFAULT_CONSTRUCTORS(_type, _name)
@@ -494,7 +494,7 @@ struct glsl_struct_field {
       precision = _precision;
    }
 
-   glsl_struct_field(const struct glsl_type *_type, const char *_name)
+   glsl_struct_field(const glsl_type *_type, const char *_name)
       : DEFAULT_CONSTRUCTORS(_type, _name)
    {
       matrix_layout = GLSL_MATRIX_LAYOUT_INHERITED;
@@ -511,62 +511,62 @@ struct glsl_struct_field {
 #endif
 };
 
-static inline enum glsl_base_type glsl_get_base_type(const struct glsl_type *t) { return t->base_type; }
+static inline enum glsl_base_type glsl_get_base_type(const glsl_type *t) { return t->base_type; }
 
 static inline unsigned
-glsl_get_bit_size(const struct glsl_type *t)
+glsl_get_bit_size(const glsl_type *t)
 {
    return glsl_base_type_get_bit_size(glsl_get_base_type(t));
 }
 
-static inline bool glsl_type_is_boolean(const struct glsl_type *t) { return t->base_type == GLSL_TYPE_BOOL; }
-static inline bool glsl_type_is_sampler(const struct glsl_type *t) { return t->base_type == GLSL_TYPE_SAMPLER; }
-static inline bool glsl_type_is_texture(const struct glsl_type *t) { return t->base_type == GLSL_TYPE_TEXTURE; }
-static inline bool glsl_type_is_image(const struct glsl_type *t) { return t->base_type == GLSL_TYPE_IMAGE; }
-static inline bool glsl_type_is_atomic_uint(const struct glsl_type *t) { return t->base_type == GLSL_TYPE_ATOMIC_UINT; }
-static inline bool glsl_type_is_struct(const struct glsl_type *t) { return t->base_type == GLSL_TYPE_STRUCT; }
-static inline bool glsl_type_is_interface(const struct glsl_type *t) { return t->base_type == GLSL_TYPE_INTERFACE; }
-static inline bool glsl_type_is_array(const struct glsl_type *t) { return t->base_type == GLSL_TYPE_ARRAY; }
-static inline bool glsl_type_is_cmat(const struct glsl_type *t) { return t->base_type == GLSL_TYPE_COOPERATIVE_MATRIX; }
-static inline bool glsl_type_is_void(const struct glsl_type *t) { return t->base_type == GLSL_TYPE_VOID; }
-static inline bool glsl_type_is_subroutine(const struct glsl_type *t) { return t->base_type == GLSL_TYPE_SUBROUTINE; }
-static inline bool glsl_type_is_error(const struct glsl_type *t) { return t->base_type == GLSL_TYPE_ERROR; }
-static inline bool glsl_type_is_double(const struct glsl_type *t) { return t->base_type == GLSL_TYPE_DOUBLE; }
-static inline bool glsl_type_is_float(const struct glsl_type *t) { return t->base_type == GLSL_TYPE_FLOAT; }
+static inline bool glsl_type_is_boolean(const glsl_type *t) { return t->base_type == GLSL_TYPE_BOOL; }
+static inline bool glsl_type_is_sampler(const glsl_type *t) { return t->base_type == GLSL_TYPE_SAMPLER; }
+static inline bool glsl_type_is_texture(const glsl_type *t) { return t->base_type == GLSL_TYPE_TEXTURE; }
+static inline bool glsl_type_is_image(const glsl_type *t) { return t->base_type == GLSL_TYPE_IMAGE; }
+static inline bool glsl_type_is_atomic_uint(const glsl_type *t) { return t->base_type == GLSL_TYPE_ATOMIC_UINT; }
+static inline bool glsl_type_is_struct(const glsl_type *t) { return t->base_type == GLSL_TYPE_STRUCT; }
+static inline bool glsl_type_is_interface(const glsl_type *t) { return t->base_type == GLSL_TYPE_INTERFACE; }
+static inline bool glsl_type_is_array(const glsl_type *t) { return t->base_type == GLSL_TYPE_ARRAY; }
+static inline bool glsl_type_is_cmat(const glsl_type *t) { return t->base_type == GLSL_TYPE_COOPERATIVE_MATRIX; }
+static inline bool glsl_type_is_void(const glsl_type *t) { return t->base_type == GLSL_TYPE_VOID; }
+static inline bool glsl_type_is_subroutine(const glsl_type *t) { return t->base_type == GLSL_TYPE_SUBROUTINE; }
+static inline bool glsl_type_is_error(const glsl_type *t) { return t->base_type == GLSL_TYPE_ERROR; }
+static inline bool glsl_type_is_double(const glsl_type *t) { return t->base_type == GLSL_TYPE_DOUBLE; }
+static inline bool glsl_type_is_float(const glsl_type *t) { return t->base_type == GLSL_TYPE_FLOAT; }
 
 static inline bool
-glsl_type_is_numeric(const struct glsl_type *t)
+glsl_type_is_numeric(const glsl_type *t)
 {
    return t->base_type >= GLSL_TYPE_UINT &&
           t->base_type <= GLSL_TYPE_INT64;
 }
 
 static inline bool
-glsl_type_is_integer(const struct glsl_type *t)
+glsl_type_is_integer(const glsl_type *t)
 {
    return glsl_base_type_is_integer(t->base_type);
 }
 
 static inline bool
-glsl_type_is_struct_or_ifc(const struct glsl_type *t)
+glsl_type_is_struct_or_ifc(const glsl_type *t)
 {
    return glsl_type_is_struct(t) || glsl_type_is_interface(t);
 }
 
 static inline bool
-glsl_type_is_packed(const struct glsl_type *t)
+glsl_type_is_packed(const glsl_type *t)
 {
    return t->packed;
 }
 
 static inline bool
-glsl_type_is_16bit(const struct glsl_type *t)
+glsl_type_is_16bit(const glsl_type *t)
 {
    return glsl_base_type_is_16bit(t->base_type);
 }
 
 static inline bool
-glsl_type_is_32bit(const struct glsl_type *t)
+glsl_type_is_32bit(const glsl_type *t)
 {
    return t->base_type == GLSL_TYPE_UINT ||
           t->base_type == GLSL_TYPE_INT ||
@@ -574,67 +574,67 @@ glsl_type_is_32bit(const struct glsl_type *t)
 }
 
 static inline bool
-glsl_type_is_64bit(const struct glsl_type *t)
+glsl_type_is_64bit(const glsl_type *t)
 {
    return glsl_base_type_is_64bit(t->base_type);
 }
 
 static inline bool
-glsl_type_is_integer_16(const struct glsl_type *t)
+glsl_type_is_integer_16(const glsl_type *t)
 {
    return t->base_type == GLSL_TYPE_UINT16 || t->base_type == GLSL_TYPE_INT16;
 }
 
 static inline bool
-glsl_type_is_integer_32(const struct glsl_type *t)
+glsl_type_is_integer_32(const glsl_type *t)
 {
    return t->base_type == GLSL_TYPE_UINT || t->base_type == GLSL_TYPE_INT;
 }
 
 static inline bool
-glsl_type_is_integer_64(const struct glsl_type *t)
+glsl_type_is_integer_64(const glsl_type *t)
 {
    return t->base_type == GLSL_TYPE_UINT64 || t->base_type == GLSL_TYPE_INT64;
 }
 
 static inline bool
-glsl_type_is_integer_32_64(const struct glsl_type *t)
+glsl_type_is_integer_32_64(const glsl_type *t)
 {
    return glsl_type_is_integer_32(t) || glsl_type_is_integer_64(t);
 }
 
 static inline bool
-glsl_type_is_integer_16_32(const struct glsl_type *t)
+glsl_type_is_integer_16_32(const glsl_type *t)
 {
    return glsl_type_is_integer_16(t) || glsl_type_is_integer_32(t);
 }
 
 static inline bool
-glsl_type_is_integer_16_32_64(const struct glsl_type *t)
+glsl_type_is_integer_16_32_64(const glsl_type *t)
 {
    return glsl_type_is_integer_16(t) || glsl_type_is_integer_32(t) || glsl_type_is_integer_64(t);
 }
 
 static inline bool
-glsl_type_is_float_16_32(const struct glsl_type *t)
+glsl_type_is_float_16_32(const glsl_type *t)
 {
    return t->base_type == GLSL_TYPE_FLOAT16 || glsl_type_is_float(t);
 }
 
 static inline bool
-glsl_type_is_float_16_32_64(const struct glsl_type *t)
+glsl_type_is_float_16_32_64(const glsl_type *t)
 {
    return t->base_type == GLSL_TYPE_FLOAT16 || glsl_type_is_float(t) || glsl_type_is_double(t);
 }
 
 static inline bool
-glsl_type_is_float_32_64(const struct glsl_type *t)
+glsl_type_is_float_32_64(const glsl_type *t)
 {
    return glsl_type_is_float(t) || glsl_type_is_double(t);
 }
 
 static inline bool
-glsl_type_is_int_16_32_64(const struct glsl_type *t)
+glsl_type_is_int_16_32_64(const glsl_type *t)
 {
    return t->base_type == GLSL_TYPE_INT16 ||
           t->base_type == GLSL_TYPE_INT ||
@@ -642,7 +642,7 @@ glsl_type_is_int_16_32_64(const struct glsl_type *t)
 }
 
 static inline bool
-glsl_type_is_uint_16_32_64(const struct glsl_type *t)
+glsl_type_is_uint_16_32_64(const glsl_type *t)
 {
    return t->base_type == GLSL_TYPE_UINT16 ||
           t->base_type == GLSL_TYPE_UINT ||
@@ -650,66 +650,66 @@ glsl_type_is_uint_16_32_64(const struct glsl_type *t)
 }
 
 static inline bool
-glsl_type_is_int_16_32(const struct glsl_type *t)
+glsl_type_is_int_16_32(const glsl_type *t)
 {
    return t->base_type == GLSL_TYPE_INT ||
           t->base_type == GLSL_TYPE_INT16;
 }
 
 static inline bool
-glsl_type_is_uint_16_32(const struct glsl_type *t)
+glsl_type_is_uint_16_32(const glsl_type *t)
 {
    return t->base_type == GLSL_TYPE_UINT ||
           t->base_type == GLSL_TYPE_UINT16;
 }
 
 static inline bool
-glsl_type_is_unsized_array(const struct glsl_type *t)
+glsl_type_is_unsized_array(const glsl_type *t)
 {
    return glsl_type_is_array(t) && t->length == 0;
 }
 
 static inline bool
-glsl_type_is_array_of_arrays(const struct glsl_type *t)
+glsl_type_is_array_of_arrays(const glsl_type *t)
 {
    return glsl_type_is_array(t) && glsl_type_is_array(t->fields.array);
 }
 
 static inline bool
-glsl_type_is_bare_sampler(const struct glsl_type *t)
+glsl_type_is_bare_sampler(const glsl_type *t)
 {
    return glsl_type_is_sampler(t) && t->sampled_type == GLSL_TYPE_VOID;
 }
 
-bool glsl_type_is_vector(const struct glsl_type *t);
-bool glsl_type_is_scalar(const struct glsl_type *t);
-bool glsl_type_is_vector_or_scalar(const struct glsl_type *t);
-bool glsl_type_is_matrix(const struct glsl_type *t);
-bool glsl_type_is_array_or_matrix(const struct glsl_type *t);
+bool glsl_type_is_vector(const glsl_type *t);
+bool glsl_type_is_scalar(const glsl_type *t);
+bool glsl_type_is_vector_or_scalar(const glsl_type *t);
+bool glsl_type_is_matrix(const glsl_type *t);
+bool glsl_type_is_array_or_matrix(const glsl_type *t);
 
 /**
  * Query whether a 64-bit type takes two slots.
  */
-bool glsl_type_is_dual_slot(const struct glsl_type *t);
+bool glsl_type_is_dual_slot(const glsl_type *t);
 
-bool glsl_type_is_leaf(const struct glsl_type *type);
+bool glsl_type_is_leaf(const glsl_type *type);
 
 static inline bool
-glsl_matrix_type_is_row_major(const struct glsl_type *t)
+glsl_matrix_type_is_row_major(const glsl_type *t)
 {
    assert((glsl_type_is_matrix(t) && t->explicit_stride) || glsl_type_is_interface(t));
    return t->interface_row_major;
 }
 
 static inline bool
-glsl_sampler_type_is_shadow(const struct glsl_type *t)
+glsl_sampler_type_is_shadow(const glsl_type *t)
 {
    assert(glsl_type_is_sampler(t));
    return t->sampler_shadow;
 }
 
 static inline bool
-glsl_sampler_type_is_array(const struct glsl_type *t)
+glsl_sampler_type_is_array(const glsl_type *t)
 {
    assert(glsl_type_is_sampler(t) ||
           glsl_type_is_texture(t) ||
@@ -718,7 +718,7 @@ glsl_sampler_type_is_array(const struct glsl_type *t)
 }
 
 static inline bool
-glsl_struct_type_is_packed(const struct glsl_type *t)
+glsl_struct_type_is_packed(const glsl_type *t)
 {
    assert(glsl_type_is_struct(t));
    return t->packed;
@@ -727,7 +727,7 @@ glsl_struct_type_is_packed(const struct glsl_type *t)
 /**
  * Gets the "bare" type without any decorations or layout information.
  */
-const struct glsl_type *glsl_get_bare_type(const struct glsl_type *t);
+const glsl_type *glsl_get_bare_type(const glsl_type *t);
 
 /**
  * Get the basic scalar type which this type aggregates.
@@ -738,7 +738,7 @@ const struct glsl_type *glsl_get_bare_type(const struct glsl_type *t);
  * returns the struct type.  For samplers and arrays of samplers, this
  * function returns the sampler type.
  */
-const struct glsl_type *glsl_get_scalar_type(const struct glsl_type *t);
+const glsl_type *glsl_get_scalar_type(const glsl_type *t);
 
 /**
  * For numeric and boolean derived types returns the basic scalar type
@@ -748,12 +748,12 @@ const struct glsl_type *glsl_get_scalar_type(const struct glsl_type *t);
  * all other types, including arrays of numeric or boolean types, the
  * error type is returned.
  */
-const struct glsl_type *glsl_get_base_glsl_type(const struct glsl_type *t);
+const glsl_type *glsl_get_base_glsl_type(const glsl_type *t);
 
-unsigned glsl_get_length(const struct glsl_type *t);
+unsigned glsl_get_length(const glsl_type *t);
 
 static inline unsigned
-glsl_get_vector_elements(const struct glsl_type *t)
+glsl_get_vector_elements(const glsl_type *t)
 {
    return t->vector_elements;
 }
@@ -762,19 +762,19 @@ glsl_get_vector_elements(const struct glsl_type *t)
  * Query the total number of scalars that make up a scalar, vector or matrix
  */
 static inline unsigned
-glsl_get_components(const struct glsl_type *t)
+glsl_get_components(const glsl_type *t)
 {
    return t->vector_elements * t->matrix_columns;
 }
 
 static inline unsigned
-glsl_get_matrix_columns(const struct glsl_type *t)
+glsl_get_matrix_columns(const glsl_type *t)
 {
    return t->matrix_columns;
 }
 
-const struct glsl_type *glsl_type_wrap_in_arrays(const struct glsl_type *t,
-                                                 const struct glsl_type *arrays);
+const glsl_type *glsl_type_wrap_in_arrays(const glsl_type *t,
+                                                 const glsl_type *arrays);
 
 /**
  * Query the number of elements in an array type
@@ -785,7 +785,7 @@ const struct glsl_type *glsl_type_wrap_in_arrays(const struct glsl_type *t,
  * zero is returned.
  */
 static inline int
-glsl_array_size(const struct glsl_type *t)
+glsl_array_size(const glsl_type *t)
 {
    return glsl_type_is_array(t) ? t->length : -1;
 }
@@ -794,9 +794,9 @@ glsl_array_size(const struct glsl_type *t)
  * Return the total number of elements in an array including the elements
  * in arrays of arrays.
  */
-unsigned glsl_get_aoa_size(const struct glsl_type *t);
+unsigned glsl_get_aoa_size(const glsl_type *t);
 
-const struct glsl_type *glsl_get_array_element(const struct glsl_type *t);
+const glsl_type *glsl_get_array_element(const glsl_type *t);
 
 /**
  * Get the type stripped of any arrays
@@ -805,36 +805,36 @@ const struct glsl_type *glsl_get_array_element(const struct glsl_type *t);
  * Pointer to the type of elements of the first non-array type for array
  * types, or pointer to itself for non-array types.
  */
-const struct glsl_type *glsl_without_array(const struct glsl_type *t);
+const glsl_type *glsl_without_array(const glsl_type *t);
 
-const struct glsl_type *glsl_without_array_or_matrix(const struct glsl_type *t);
-const struct glsl_type *glsl_type_wrap_in_arrays(const struct glsl_type *t,
-                                                 const struct glsl_type *arrays);
+const glsl_type *glsl_without_array_or_matrix(const glsl_type *t);
+const glsl_type *glsl_type_wrap_in_arrays(const glsl_type *t,
+                                                 const glsl_type *arrays);
 
-const struct glsl_type *glsl_get_cmat_element(const struct glsl_type *t);
-const struct glsl_cmat_description *glsl_get_cmat_description(const struct glsl_type *t);
+const glsl_type *glsl_get_cmat_element(const glsl_type *t);
+const struct glsl_cmat_description *glsl_get_cmat_description(const glsl_type *t);
 
 /**
  * Return the amount of atomic counter storage required for a type.
  */
-unsigned glsl_atomic_size(const struct glsl_type *type);
+unsigned glsl_atomic_size(const glsl_type *type);
 
 /**
  * Type A contains type B if A is B or A is a composite type (struct,
  * interface, array) that has an element that contains B.
  */
-bool glsl_type_contains_64bit(const struct glsl_type *t);
-bool glsl_type_contains_image(const struct glsl_type *t);
-bool glsl_contains_atomic(const struct glsl_type *t);
-bool glsl_contains_double(const struct glsl_type *t);
-bool glsl_contains_integer(const struct glsl_type *t);
-bool glsl_contains_opaque(const struct glsl_type *t);
-bool glsl_contains_sampler(const struct glsl_type *t);
-bool glsl_contains_array(const struct glsl_type *t);
-bool glsl_contains_subroutine(const struct glsl_type *t);
+bool glsl_type_contains_64bit(const glsl_type *t);
+bool glsl_type_contains_image(const glsl_type *t);
+bool glsl_contains_atomic(const glsl_type *t);
+bool glsl_contains_double(const glsl_type *t);
+bool glsl_contains_integer(const glsl_type *t);
+bool glsl_contains_opaque(const glsl_type *t);
+bool glsl_contains_sampler(const glsl_type *t);
+bool glsl_contains_array(const glsl_type *t);
+bool glsl_contains_subroutine(const glsl_type *t);
 
 static inline enum glsl_sampler_dim
-glsl_get_sampler_dim(const struct glsl_type *t)
+glsl_get_sampler_dim(const glsl_type *t)
 {
    assert(glsl_type_is_sampler(t) ||
           glsl_type_is_texture(t) ||
@@ -843,7 +843,7 @@ glsl_get_sampler_dim(const struct glsl_type *t)
 }
 
 static inline enum glsl_base_type
-glsl_get_sampler_result_type(const struct glsl_type *t)
+glsl_get_sampler_result_type(const glsl_type *t)
 {
    assert(glsl_type_is_sampler(t) ||
           glsl_type_is_texture(t) ||
@@ -862,7 +862,7 @@ glsl_get_sampler_result_type(const struct glsl_type *t)
  * a texturing built-in function, since those pack additional values (such
  * as the shadow comparator or projector) into the coordinate type.
  */
-int glsl_get_sampler_coordinate_components(const struct glsl_type *t);
+int glsl_get_sampler_coordinate_components(const glsl_type *t);
 
 /**
  * Compares whether this type matches another type without taking into
@@ -871,7 +871,7 @@ int glsl_get_sampler_coordinate_components(const struct glsl_type *t);
  * This is applied recursively so that structures containing structure
  * members can also ignore the precision.
  */
-bool glsl_type_compare_no_precision(const struct glsl_type *a, const struct glsl_type *b);
+bool glsl_type_compare_no_precision(const glsl_type *a, const glsl_type *b);
 
 /**
  * Compare a record type against another record type.
@@ -883,12 +883,12 @@ bool glsl_type_compare_no_precision(const struct glsl_type *a, const struct glsl
  * The option to not match locations is to deal with places where the
  * same struct is defined in a block which has a location set on it.
  */
-bool glsl_record_compare(const struct glsl_type *a, const struct glsl_type *b,
+bool glsl_record_compare(const glsl_type *a, const glsl_type *b,
                          bool match_name, bool match_locations,
                          bool match_precision);
 
-const struct glsl_type *glsl_get_struct_field(const struct glsl_type *t, unsigned index);
-const struct glsl_struct_field *glsl_get_struct_field_data(const struct glsl_type *t, unsigned index);
+const glsl_type *glsl_get_struct_field(const glsl_type *t, unsigned index);
+const glsl_struct_field *glsl_get_struct_field_data(const glsl_type *t, unsigned index);
 
 /**
  * Calculate offset between the base location of the struct in
@@ -896,12 +896,12 @@ const struct glsl_struct_field *glsl_get_struct_field_data(const struct glsl_typ
  * For the initial call, length is the index of the member to find the
  * offset for.
  */
-unsigned glsl_get_struct_location_offset(const struct glsl_type *t, unsigned length);
+unsigned glsl_get_struct_location_offset(const glsl_type *t, unsigned length);
 
 /**
  * Get the location of a field within a record type
  */
-int glsl_get_field_index(const struct glsl_type *t, const char *name);
+int glsl_get_field_index(const glsl_type *t, const char *name);
 
 /**
  * Get the type of a structure field
@@ -910,46 +910,46 @@ int glsl_get_field_index(const struct glsl_type *t, const char *name);
  * Pointer to the type of the named field.  If the type is not a structure
  * or the named field does not exist, \c &glsl_type_builtin_error is returned.
  */
-const struct glsl_type *glsl_get_field_type(const struct glsl_type *t, const char *name);
+const glsl_type *glsl_get_field_type(const glsl_type *t, const char *name);
 
 static inline int
-glsl_get_struct_field_offset(const struct glsl_type *t, unsigned index)
+glsl_get_struct_field_offset(const glsl_type *t, unsigned index)
 {
    return t->fields.structure[index].offset;
 }
 
 static inline const char *
-glsl_get_struct_elem_name(const struct glsl_type *t, unsigned index)
+glsl_get_struct_elem_name(const glsl_type *t, unsigned index)
 {
    return t->fields.structure[index].name;
 }
 
-static inline const struct glsl_type *glsl_void_type(void) { return &glsl_type_builtin_void; }
-static inline const struct glsl_type *glsl_float_type(void) { return &glsl_type_builtin_float; }
-static inline const struct glsl_type *glsl_float16_t_type(void) { return &glsl_type_builtin_float16_t; }
-static inline const struct glsl_type *glsl_double_type(void) { return &glsl_type_builtin_double; }
-static inline const struct glsl_type *glsl_vec2_type(void) { return &glsl_type_builtin_vec2; }
-static inline const struct glsl_type *glsl_dvec2_type(void) { return &glsl_type_builtin_ivec2; }
-static inline const struct glsl_type *glsl_uvec2_type(void) { return &glsl_type_builtin_uvec2; }
-static inline const struct glsl_type *glsl_ivec2_type(void) { return &glsl_type_builtin_ivec2; }
-static inline const struct glsl_type *glsl_bvec2_type(void) { return &glsl_type_builtin_bvec2; }
-static inline const struct glsl_type *glsl_vec4_type(void) { return &glsl_type_builtin_vec4; }
-static inline const struct glsl_type *glsl_dvec4_type(void) { return &glsl_type_builtin_ivec4; }
-static inline const struct glsl_type *glsl_uvec4_type(void) { return &glsl_type_builtin_uvec4; }
-static inline const struct glsl_type *glsl_ivec4_type(void) { return &glsl_type_builtin_ivec4; }
-static inline const struct glsl_type *glsl_bvec4_type(void) { return &glsl_type_builtin_bvec4; }
-static inline const struct glsl_type *glsl_int_type(void) { return &glsl_type_builtin_int; }
-static inline const struct glsl_type *glsl_uint_type(void) { return &glsl_type_builtin_uint; }
-static inline const struct glsl_type *glsl_int64_t_type(void) { return &glsl_type_builtin_int64_t; }
-static inline const struct glsl_type *glsl_uint64_t_type(void) { return &glsl_type_builtin_uint64_t; }
-static inline const struct glsl_type *glsl_int16_t_type(void) { return &glsl_type_builtin_int16_t; }
-static inline const struct glsl_type *glsl_uint16_t_type(void) { return &glsl_type_builtin_uint16_t; }
-static inline const struct glsl_type *glsl_int8_t_type(void) { return &glsl_type_builtin_int8_t; }
-static inline const struct glsl_type *glsl_uint8_t_type(void) { return &glsl_type_builtin_uint8_t; }
-static inline const struct glsl_type *glsl_bool_type(void) { return &glsl_type_builtin_bool; }
-static inline const struct glsl_type *glsl_atomic_uint_type(void) { return &glsl_type_builtin_atomic_uint; }
-
-static inline const struct glsl_type *
+static inline const glsl_type *glsl_void_type(void) { return &glsl_type_builtin_void; }
+static inline const glsl_type *glsl_float_type(void) { return &glsl_type_builtin_float; }
+static inline const glsl_type *glsl_float16_t_type(void) { return &glsl_type_builtin_float16_t; }
+static inline const glsl_type *glsl_double_type(void) { return &glsl_type_builtin_double; }
+static inline const glsl_type *glsl_vec2_type(void) { return &glsl_type_builtin_vec2; }
+static inline const glsl_type *glsl_dvec2_type(void) { return &glsl_type_builtin_ivec2; }
+static inline const glsl_type *glsl_uvec2_type(void) { return &glsl_type_builtin_uvec2; }
+static inline const glsl_type *glsl_ivec2_type(void) { return &glsl_type_builtin_ivec2; }
+static inline const glsl_type *glsl_bvec2_type(void) { return &glsl_type_builtin_bvec2; }
+static inline const glsl_type *glsl_vec4_type(void) { return &glsl_type_builtin_vec4; }
+static inline const glsl_type *glsl_dvec4_type(void) { return &glsl_type_builtin_ivec4; }
+static inline const glsl_type *glsl_uvec4_type(void) { return &glsl_type_builtin_uvec4; }
+static inline const glsl_type *glsl_ivec4_type(void) { return &glsl_type_builtin_ivec4; }
+static inline const glsl_type *glsl_bvec4_type(void) { return &glsl_type_builtin_bvec4; }
+static inline const glsl_type *glsl_int_type(void) { return &glsl_type_builtin_int; }
+static inline const glsl_type *glsl_uint_type(void) { return &glsl_type_builtin_uint; }
+static inline const glsl_type *glsl_int64_t_type(void) { return &glsl_type_builtin_int64_t; }
+static inline const glsl_type *glsl_uint64_t_type(void) { return &glsl_type_builtin_uint64_t; }
+static inline const glsl_type *glsl_int16_t_type(void) { return &glsl_type_builtin_int16_t; }
+static inline const glsl_type *glsl_uint16_t_type(void) { return &glsl_type_builtin_uint16_t; }
+static inline const glsl_type *glsl_int8_t_type(void) { return &glsl_type_builtin_int8_t; }
+static inline const glsl_type *glsl_uint8_t_type(void) { return &glsl_type_builtin_uint8_t; }
+static inline const glsl_type *glsl_bool_type(void) { return &glsl_type_builtin_bool; }
+static inline const glsl_type *glsl_atomic_uint_type(void) { return &glsl_type_builtin_atomic_uint; }
+
+static inline const glsl_type *
 glsl_floatN_t_type(unsigned bit_size)
 {
    switch (bit_size) {
@@ -961,7 +961,7 @@ glsl_floatN_t_type(unsigned bit_size)
    }
 }
 
-static inline const struct glsl_type *
+static inline const glsl_type *
 glsl_intN_t_type(unsigned bit_size)
 {
    switch (bit_size) {
@@ -974,7 +974,7 @@ glsl_intN_t_type(unsigned bit_size)
    }
 }
 
-static inline const struct glsl_type *
+static inline const glsl_type *
 glsl_uintN_t_type(unsigned bit_size)
 {
    switch (bit_size) {
@@ -987,65 +987,65 @@ glsl_uintN_t_type(unsigned bit_size)
    }
 }
 
-const struct glsl_type *glsl_vec_type(unsigned components);
-const struct glsl_type *glsl_f16vec_type(unsigned components);
-const struct glsl_type *glsl_dvec_type(unsigned components);
-const struct glsl_type *glsl_ivec_type(unsigned components);
-const struct glsl_type *glsl_uvec_type(unsigned components);
-const struct glsl_type *glsl_bvec_type(unsigned components);
-const struct glsl_type *glsl_i64vec_type(unsigned components);
-const struct glsl_type *glsl_u64vec_type(unsigned components);
-const struct glsl_type *glsl_i16vec_type(unsigned components);
-const struct glsl_type *glsl_u16vec_type(unsigned components);
-const struct glsl_type *glsl_i8vec_type(unsigned components);
-const struct glsl_type *glsl_u8vec_type(unsigned components);
-
-const struct glsl_type *glsl_simple_explicit_type(unsigned base_type, unsigned rows,
+const glsl_type *glsl_vec_type(unsigned components);
+const glsl_type *glsl_f16vec_type(unsigned components);
+const glsl_type *glsl_dvec_type(unsigned components);
+const glsl_type *glsl_ivec_type(unsigned components);
+const glsl_type *glsl_uvec_type(unsigned components);
+const glsl_type *glsl_bvec_type(unsigned components);
+const glsl_type *glsl_i64vec_type(unsigned components);
+const glsl_type *glsl_u64vec_type(unsigned components);
+const glsl_type *glsl_i16vec_type(unsigned components);
+const glsl_type *glsl_u16vec_type(unsigned components);
+const glsl_type *glsl_i8vec_type(unsigned components);
+const glsl_type *glsl_u8vec_type(unsigned components);
+
+const glsl_type *glsl_simple_explicit_type(unsigned base_type, unsigned rows,
                                                   unsigned columns,
                                                   unsigned explicit_stride,
                                                   bool row_major,
                                                   unsigned explicit_alignment);
 
-static inline const struct glsl_type *
+static inline const glsl_type *
 glsl_simple_type(unsigned base_type, unsigned rows, unsigned columns)
 {
    return glsl_simple_explicit_type(base_type, rows, columns, 0, false, 0);
 }
 
-const struct glsl_type *glsl_sampler_type(enum glsl_sampler_dim dim,
+const glsl_type *glsl_sampler_type(enum glsl_sampler_dim dim,
                                           bool shadow,
                                           bool array,
                                           enum glsl_base_type type);
-const struct glsl_type *glsl_bare_sampler_type(void);
-const struct glsl_type *glsl_bare_shadow_sampler_type(void);
-const struct glsl_type *glsl_texture_type(enum glsl_sampler_dim dim,
+const glsl_type *glsl_bare_sampler_type(void);
+const glsl_type *glsl_bare_shadow_sampler_type(void);
+const glsl_type *glsl_texture_type(enum glsl_sampler_dim dim,
                                           bool array,
                                           enum glsl_base_type type);
-const struct glsl_type *glsl_image_type(enum glsl_sampler_dim dim,
+const glsl_type *glsl_image_type(enum glsl_sampler_dim dim,
                                         bool array, enum glsl_base_type type);
-const struct glsl_type *glsl_array_type(const struct glsl_type *element,
+const glsl_type *glsl_array_type(const glsl_type *element,
                                         unsigned array_size,
                                         unsigned explicit_stride);
-const struct glsl_type *glsl_cmat_type(const struct glsl_cmat_description *desc);
-const struct glsl_type *glsl_struct_type_with_explicit_alignment(const struct glsl_struct_field *fields,
+const glsl_type *glsl_cmat_type(const struct glsl_cmat_description *desc);
+const glsl_type *glsl_struct_type_with_explicit_alignment(const glsl_struct_field *fields,
                                                                  unsigned num_fields,
                                                                  const char *name,
                                                                  bool packed,
                                                                  unsigned explicit_alignment);
 
-static inline const struct glsl_type *
-glsl_struct_type(const struct glsl_struct_field *fields, unsigned num_fields,
+static inline const glsl_type *
+glsl_struct_type(const glsl_struct_field *fields, unsigned num_fields,
                  const char *name, bool packed)
 {
    return glsl_struct_type_with_explicit_alignment(fields, num_fields, name, packed, 0);
 }
 
-const struct glsl_type *glsl_interface_type(const struct glsl_struct_field *fields,
+const glsl_type *glsl_interface_type(const glsl_struct_field *fields,
                                             unsigned num_fields,
                                             enum glsl_interface_packing packing,
                                             bool row_major,
                                             const char *block_name);
-const struct glsl_type *glsl_subroutine_type(const char *subroutine_name);
+const glsl_type *glsl_subroutine_type(const char *subroutine_name);
 
 /**
  * Query the full type of a matrix row
@@ -1054,7 +1054,7 @@ const struct glsl_type *glsl_subroutine_type(const char *subroutine_name);
  * If the type is not a matrix, \c glsl_type::error_type is returned.
  * Otherwise a type matching the rows of the matrix is returned.
  */
-const struct glsl_type *glsl_get_row_type(const struct glsl_type *t);
+const glsl_type *glsl_get_row_type(const glsl_type *t);
 
 /**
  * Query the full type of a matrix column
@@ -1063,7 +1063,7 @@ const struct glsl_type *glsl_get_row_type(const struct glsl_type *t);
  * If the type is not a matrix, \c glsl_type::error_type is returned.
  * Otherwise a type matching the columns of the matrix is returned.
  */
-const struct glsl_type *glsl_get_column_type(const struct glsl_type *t);
+const glsl_type *glsl_get_column_type(const glsl_type *t);
 
 /** Returns an explicitly laid out type given a type and size/align func
  *
@@ -1082,57 +1082,57 @@ const struct glsl_type *glsl_get_column_type(const struct glsl_type *t);
  * or SSBO layout because they do not add the extra array and substructure
  * alignment that is required by std140 and std430.
  */
-const struct glsl_type *glsl_get_explicit_type_for_size_align(const struct glsl_type *type,
+const glsl_type *glsl_get_explicit_type_for_size_align(const glsl_type *type,
                                                               glsl_type_size_align_func type_info,
                                                               unsigned *size, unsigned *align);
 
-const struct glsl_type *glsl_type_replace_vec3_with_vec4(const struct glsl_type *type);
+const glsl_type *glsl_type_replace_vec3_with_vec4(const glsl_type *type);
 
 /**
  * Gets the float16 version of this type.
  */
-const struct glsl_type *glsl_float16_type(const struct glsl_type *t);
+const glsl_type *glsl_float16_type(const glsl_type *t);
 
 /**
  * Gets the int16 version of this type.
  */
-const struct glsl_type *glsl_int16_type(const struct glsl_type *t);
+const glsl_type *glsl_int16_type(const glsl_type *t);
 
 /**
  * Gets the uint16 version of this type.
  */
-const struct glsl_type *glsl_uint16_type(const struct glsl_type *t);
+const glsl_type *glsl_uint16_type(const glsl_type *t);
 
-const struct glsl_type *glsl_type_to_16bit(const struct glsl_type *old_type);
+const glsl_type *glsl_type_to_16bit(const glsl_type *old_type);
 
-static inline const struct glsl_type *
+static inline const glsl_type *
 glsl_scalar_type(enum glsl_base_type base_type)
 {
    return glsl_simple_type(base_type, 1, 1);
 }
 
-static inline const struct glsl_type *
+static inline const glsl_type *
 glsl_vector_type(enum glsl_base_type base_type, unsigned components)
 {
-   const struct glsl_type *t = glsl_simple_type(base_type, components, 1);
+   const glsl_type *t = glsl_simple_type(base_type, components, 1);
    assert(t != &glsl_type_builtin_error);
    return t;
 }
 
-static inline const struct glsl_type *
+static inline const glsl_type *
 glsl_matrix_type(enum glsl_base_type base_type,
                  unsigned rows, unsigned columns)
 {
-   const struct glsl_type *t = glsl_simple_type(base_type, rows, columns);
+   const glsl_type *t = glsl_simple_type(base_type, rows, columns);
    assert(t != &glsl_type_builtin_error);
    return t;
 }
 
-static inline const struct glsl_type *
-glsl_explicit_matrix_type(const struct glsl_type *mat, unsigned stride,
+static inline const glsl_type *
+glsl_explicit_matrix_type(const glsl_type *mat, unsigned stride,
                           bool row_major) {
    assert(stride > 0);
-   const struct glsl_type *t = glsl_simple_explicit_type(mat->base_type,
+   const glsl_type *t = glsl_simple_explicit_type(mat->base_type,
                                                          mat->vector_elements,
                                                          mat->matrix_columns,
                                                          stride, row_major, 0);
@@ -1141,15 +1141,15 @@ glsl_explicit_matrix_type(const struct glsl_type *mat, unsigned stride,
 
 }
 
-static inline const struct glsl_type *
-glsl_transposed_type(const struct glsl_type *t)
+static inline const glsl_type *
+glsl_transposed_type(const glsl_type *t)
 {
    assert(glsl_type_is_matrix(t));
    return glsl_simple_type(t->base_type, t->matrix_columns, t->vector_elements);
 }
 
-static inline const struct glsl_type *
-glsl_texture_type_to_sampler(const struct glsl_type *t, bool is_shadow)
+static inline const glsl_type *
+glsl_texture_type_to_sampler(const glsl_type *t, bool is_shadow)
 {
    assert(glsl_type_is_texture(t));
    return glsl_sampler_type((enum glsl_sampler_dim)t->sampler_dimensionality,
@@ -1157,8 +1157,8 @@ glsl_texture_type_to_sampler(const struct glsl_type *t, bool is_shadow)
                             (enum glsl_base_type)t->sampled_type);
 }
 
-static inline const struct glsl_type *
-glsl_sampler_type_to_texture(const struct glsl_type *t)
+static inline const glsl_type *
+glsl_sampler_type_to_texture(const glsl_type *t)
 {
    assert(glsl_type_is_sampler(t) && !glsl_type_is_bare_sampler(t));
    return glsl_texture_type((enum glsl_sampler_dim)t->sampler_dimensionality,
@@ -1166,17 +1166,17 @@ glsl_sampler_type_to_texture(const struct glsl_type *t)
                             (enum glsl_base_type)t->sampled_type);
 }
 
-const struct glsl_type *glsl_replace_vector_type(const struct glsl_type *t, unsigned components);
-const struct glsl_type *glsl_channel_type(const struct glsl_type *t);
+const glsl_type *glsl_replace_vector_type(const glsl_type *t, unsigned components);
+const glsl_type *glsl_channel_type(const glsl_type *t);
 
 /**
  * Get the type resulting from a multiplication of \p type_a * \p type_b
  */
-const struct glsl_type *glsl_get_mul_type(const struct glsl_type *type_a, const struct glsl_type *type_b);
+const glsl_type *glsl_get_mul_type(const glsl_type *type_a, const glsl_type *type_b);
 
-unsigned glsl_type_get_sampler_count(const struct glsl_type *t);
-unsigned glsl_type_get_texture_count(const struct glsl_type *t);
-unsigned glsl_type_get_image_count(const struct glsl_type *t);
+unsigned glsl_type_get_sampler_count(const glsl_type *t);
+unsigned glsl_type_get_texture_count(const glsl_type *t);
+unsigned glsl_type_get_image_count(const glsl_type *t);
 
 /**
  * Calculate the number of vec4 slots required to hold this type.
@@ -1185,7 +1185,7 @@ unsigned glsl_type_get_image_count(const struct glsl_type *t);
  * count_attribute_slots() (vertex inputs and varyings) but also for
  * gallium's !PIPE_CAP_PACKED_UNIFORMS case.
  */
-unsigned glsl_count_vec4_slots(const struct glsl_type *t, bool is_gl_vertex_input, bool is_bindless);
+unsigned glsl_count_vec4_slots(const glsl_type *t, bool is_gl_vertex_input, bool is_bindless);
 
 /**
  * Calculate the number of vec4 slots required to hold this type.
@@ -1193,7 +1193,7 @@ unsigned glsl_count_vec4_slots(const struct glsl_type *t, bool is_gl_vertex_inpu
  * This is the underlying recursive type_size function for
  * gallium's PIPE_CAP_PACKED_UNIFORMS case.
  */
-unsigned glsl_count_dword_slots(const struct glsl_type *t, bool is_bindless);
+unsigned glsl_count_dword_slots(const glsl_type *t, bool is_bindless);
 
 /**
  * Calculate the number of components slots required to hold this type
@@ -1201,15 +1201,15 @@ unsigned glsl_count_dword_slots(const struct glsl_type *t, bool is_bindless);
  * This is used to determine how many uniform or varying locations a type
  * might occupy.
  */
-unsigned glsl_get_component_slots(const struct glsl_type *t);
+unsigned glsl_get_component_slots(const glsl_type *t);
 
-unsigned glsl_get_component_slots_aligned(const struct glsl_type *t, unsigned offset);
+unsigned glsl_get_component_slots_aligned(const glsl_type *t, unsigned offset);
 
 /**
  * Used to count the number of varyings contained in the type ignoring
  * innermost array elements.
  */
-unsigned glsl_varying_count(const struct glsl_type *t);
+unsigned glsl_varying_count(const glsl_type *t);
 
 /**
  * Calculate the number of unique values from glGetUniformLocation for the
@@ -1218,7 +1218,7 @@ unsigned glsl_varying_count(const struct glsl_type *t);
  * This is used to allocate slots in the UniformRemapTable, the amount of
  * locations may not match with actual used storage space by the driver.
  */
-unsigned glsl_type_uniform_locations(const struct glsl_type *t);
+unsigned glsl_type_uniform_locations(const glsl_type *t);
 
 /**
  * Calculate the number of attribute slots required to hold this type
@@ -1236,7 +1236,7 @@ unsigned glsl_type_uniform_locations(const struct glsl_type *t);
  * false.
  */
 static inline unsigned
-glsl_count_attribute_slots(const struct glsl_type *t, bool is_gl_vertex_input)
+glsl_count_attribute_slots(const glsl_type *t, bool is_gl_vertex_input)
 {
    return glsl_count_vec4_slots(t, is_gl_vertex_input, true);
 }
@@ -1244,24 +1244,24 @@ glsl_count_attribute_slots(const struct glsl_type *t, bool is_gl_vertex_input)
 /**
  * Size in bytes of this type in OpenCL memory
  */
-unsigned glsl_get_cl_size(const struct glsl_type *t);
+unsigned glsl_get_cl_size(const glsl_type *t);
 
 /**
  * Alignment in bytes of the start of this type in OpenCL memory.
  */
-unsigned glsl_get_cl_alignment(const struct glsl_type *t);
+unsigned glsl_get_cl_alignment(const glsl_type *t);
 
-void glsl_get_cl_type_size_align(const struct glsl_type *t,
+void glsl_get_cl_type_size_align(const glsl_type *t,
                                  unsigned *size, unsigned *align);
 
 /**
  * Get the type interface packing used internally. For shared and packing
  * layouts this is implementation defined.
  */
-enum glsl_interface_packing glsl_get_internal_ifc_packing(const struct glsl_type *t, bool std430_supported);
+enum glsl_interface_packing glsl_get_internal_ifc_packing(const glsl_type *t, bool std430_supported);
 
 static inline enum glsl_interface_packing
-glsl_get_ifc_packing(const struct glsl_type *t)
+glsl_get_ifc_packing(const glsl_type *t)
 {
    return (enum glsl_interface_packing)t->interface_packing;
 }
@@ -1270,33 +1270,33 @@ glsl_get_ifc_packing(const struct glsl_type *t)
  * Alignment in bytes of the start of this type in a std140 uniform
  * block.
  */
-unsigned glsl_get_std140_base_alignment(const struct glsl_type *t, bool row_major);
+unsigned glsl_get_std140_base_alignment(const glsl_type *t, bool row_major);
 
 /** Size in bytes of this type in a std140 uniform block.
  *
  * Note that this is not GL_UNIFORM_SIZE (which is the number of
  * elements in the array)
  */
-unsigned glsl_get_std140_size(const struct glsl_type *t, bool row_major);
+unsigned glsl_get_std140_size(const glsl_type *t, bool row_major);
 
 /**
  * Calculate array stride in bytes of this type in a std430 shader storage
  * block.
  */
-unsigned glsl_get_std430_array_stride(const struct glsl_type *t, bool row_major);
+unsigned glsl_get_std430_array_stride(const glsl_type *t, bool row_major);
 
 /**
  * Alignment in bytes of the start of this type in a std430 shader
  * storage block.
  */
-unsigned glsl_get_std430_base_alignment(const struct glsl_type *t, bool row_major);
+unsigned glsl_get_std430_base_alignment(const glsl_type *t, bool row_major);
 
 /**
  * Size in bytes of this type in a std430 shader storage block.
  *
  * Note that this is not GL_BUFFER_SIZE
  */
-unsigned glsl_get_std430_size(const struct glsl_type *t, bool row_major);
+unsigned glsl_get_std430_size(const glsl_type *t, bool row_major);
 
 /**
  * Size in bytes of this type based on its explicit data.
@@ -1309,16 +1309,16 @@ unsigned glsl_get_std430_size(const struct glsl_type *t, bool row_major);
  * values are set, so only with SPIR-V shaders. Should not be used with
  * GLSL shaders.
  */
-unsigned glsl_get_explicit_size(const struct glsl_type *t, bool align_to_stride);
+unsigned glsl_get_explicit_size(const glsl_type *t, bool align_to_stride);
 
 static inline unsigned
-glsl_get_explicit_stride(const struct glsl_type *t)
+glsl_get_explicit_stride(const glsl_type *t)
 {
    return t->explicit_stride;
 }
 
 static inline unsigned
-glsl_get_explicit_alignment(const struct glsl_type *t)
+glsl_get_explicit_alignment(const glsl_type *t)
 {
    return t->explicit_alignment;
 }
@@ -1326,18 +1326,18 @@ glsl_get_explicit_alignment(const struct glsl_type *t)
 /**
  * Gets an explicitly laid out type with the std140 layout.
  */
-const struct glsl_type *glsl_get_explicit_std140_type(const struct glsl_type *t, bool row_major);
+const glsl_type *glsl_get_explicit_std140_type(const glsl_type *t, bool row_major);
 
 /**
  * Gets an explicitly laid out type with the std430 layout.
  */
-const struct glsl_type *glsl_get_explicit_std430_type(const struct glsl_type *t, bool row_major);
+const glsl_type *glsl_get_explicit_std430_type(const glsl_type *t, bool row_major);
 
 /**
  * Gets an explicitly laid out interface type.
  */
-static inline const struct glsl_type *
-glsl_get_explicit_interface_type(const struct glsl_type *t, bool supports_std430)
+static inline const glsl_type *
+glsl_get_explicit_interface_type(const glsl_type *t, bool supports_std430)
 {
    enum glsl_interface_packing packing = glsl_get_internal_ifc_packing(t, supports_std430);
    if (packing == GLSL_INTERFACE_PACKING_STD140) {
@@ -1348,8 +1348,8 @@ glsl_get_explicit_interface_type(const struct glsl_type *t, bool supports_std430
    }
 }
 
-void glsl_get_natural_size_align_bytes(const struct glsl_type *t, unsigned *size, unsigned *align);
-void glsl_get_vec4_size_align_bytes(const struct glsl_type *type, unsigned *size, unsigned *align);
+void glsl_get_natural_size_align_bytes(const glsl_type *t, unsigned *size, unsigned *align);
+void glsl_get_vec4_size_align_bytes(const glsl_type *type, unsigned *size, unsigned *align);
 
 #ifdef __cplusplus
 } /* extern "C" */
-- 
GitLab

