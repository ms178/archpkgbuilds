From fb4237e4cec7c86540409de781f4a1dde44217a7 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Daniel=20Sch=C3=BCrmann?= <daniel@schuermann.dev>
Date: Wed, 17 Aug 2022 00:18:54 +0200
Subject: [PATCH 1/2] aco: use std::vector::reserve() more often

This removes the majority of vector re-allocations.
---
 src/amd/compiler/aco_instruction_selection.cpp | 18 ++++++++++++++++--
 .../aco_instruction_selection_setup.cpp        |  3 ---
 src/amd/compiler/aco_lower_to_hw_instr.cpp     |  3 ++-
 src/amd/compiler/aco_optimizer.cpp             |  4 ++--
 src/amd/compiler/aco_register_allocation.cpp   |  1 +
 5 files changed, 21 insertions(+), 8 deletions(-)

diff --git a/src/amd/compiler/aco_instruction_selection.cpp b/src/amd/compiler/aco_instruction_selection.cpp
index 252b4d42a5b4..7c159f8c0910 100644
--- a/src/amd/compiler/aco_instruction_selection.cpp
+++ b/src/amd/compiler/aco_instruction_selection.cpp
@@ -10407,6 +10407,8 @@ visit_jump(isel_context* ctx, nir_jump_instr* instr)
 void
 visit_block(isel_context* ctx, nir_block* block)
 {
+   ctx->block->instructions.reserve(ctx->block->instructions.size() +
+                                    exec_list_length(&block->instr_list) * 2);
    nir_foreach_instr (instr, block) {
       switch (instr->type) {
       case nir_instr_type_alu: visit_alu_instr(ctx, nir_instr_as_alu(instr)); break;
@@ -11912,6 +11914,13 @@ select_program(Program* program, unsigned shader_count, struct nir_shader* const
                const struct radv_shader_args* args)
 {
    isel_context ctx = setup_isel_context(program, shader_count, shaders, config, options, info, args, false, false);
+   unsigned nir_num_blocks = 0;
+   for (unsigned i = 0; i < shader_count; i++)
+      nir_num_blocks += nir_shader_get_entrypoint(shaders[i])->num_blocks;
+   ctx.program->blocks.reserve(nir_num_blocks * 2);
+   ctx.block = ctx.program->create_and_insert_block();
+   ctx.block->kind = block_kind_top_level;
+
    if_context ic_merged_wave_info;
    bool ngg_gs = ctx.stage.hw == HWStage::NGG && ctx.stage.has(SWStage::GS);
 
@@ -11963,6 +11972,8 @@ select_program(Program* program, unsigned shader_count, struct nir_shader* const
       }
 
       if (i) {
+         ctx.program->blocks.reserve(ctx.program->blocks.size() +
+                                     nir_shader_get_entrypoint(nir)->num_blocks * 2);
          Builder bld(ctx.program, ctx.block);
 
          /* Skip s_barrier from TCS when VS outputs are not stored in the LDS. */
@@ -12041,7 +12052,9 @@ select_gs_copy_shader(Program* program, struct nir_shader* gs_shader, ac_shader_
                       const struct radv_shader_args* args)
 {
    isel_context ctx = setup_isel_context(program, 1, &gs_shader, config, options, info, args, true, false);
-
+   ctx.program->blocks.reserve(16);
+   ctx.block = ctx.program->create_and_insert_block();
+   ctx.block->kind = block_kind_top_level;
    ctx.block->fp_mode = program->next_fp_mode;
 
    add_startpgm(&ctx);
@@ -12529,7 +12542,8 @@ select_ps_epilog(Program* program, const struct aco_ps_epilog_key* key, ac_shade
                  const struct radv_shader_args* args)
 {
    isel_context ctx = setup_isel_context(program, 0, NULL, config, options, info, args, false, true);
-
+   ctx.block = ctx.program->create_and_insert_block();
+   ctx.block->kind = block_kind_top_level;
    ctx.block->fp_mode = program->next_fp_mode;
 
    add_startpgm(&ctx);
diff --git a/src/amd/compiler/aco_instruction_selection_setup.cpp b/src/amd/compiler/aco_instruction_selection_setup.cpp
index 44cfef4022d9..52ab4ede6086 100644
--- a/src/amd/compiler/aco_instruction_selection_setup.cpp
+++ b/src/amd/compiler/aco_instruction_selection_setup.cpp
@@ -933,9 +933,6 @@ setup_isel_context(Program* program, unsigned shader_count, struct nir_shader* c
 
    ctx.program->config->scratch_bytes_per_wave = align(scratch_size * ctx.program->wave_size, 1024);
 
-   ctx.block = ctx.program->create_and_insert_block();
-   ctx.block->kind = block_kind_top_level;
-
    return ctx;
 }
 
diff --git a/src/amd/compiler/aco_lower_to_hw_instr.cpp b/src/amd/compiler/aco_lower_to_hw_instr.cpp
index 6250b7f285dc..82aca55b45af 100644
--- a/src/amd/compiler/aco_lower_to_hw_instr.cpp
+++ b/src/amd/compiler/aco_lower_to_hw_instr.cpp
@@ -2009,6 +2009,7 @@ lower_to_hw_instr(Program* program)
       lower_context ctx;
       ctx.program = program;
       ctx.block = block;
+      ctx.instructions.reserve(block->instructions.size());
       Builder bld(program, &ctx.instructions);
 
       emit_set_mode_from_block(bld, *program, block, (block_idx == 0));
@@ -2520,7 +2521,7 @@ lower_to_hw_instr(Program* program)
             ctx.instructions.emplace_back(std::move(instr));
          }
       }
-      block->instructions.swap(ctx.instructions);
+      block->instructions = std::move(ctx.instructions);
    }
 }
 
diff --git a/src/amd/compiler/aco_optimizer.cpp b/src/amd/compiler/aco_optimizer.cpp
index d8337418e22e..56f8f0a1fc3c 100644
--- a/src/amd/compiler/aco_optimizer.cpp
+++ b/src/amd/compiler/aco_optimizer.cpp
@@ -4828,11 +4828,11 @@ optimize(Program* program)
 
    /* 4. Add literals to instructions */
    for (Block& block : program->blocks) {
-      ctx.instructions.clear();
+      ctx.instructions.reserve(block.instructions.size());
       ctx.fp_mode = block.fp_mode;
       for (aco_ptr<Instruction>& instr : block.instructions)
          apply_literals(ctx, instr);
-      block.instructions.swap(ctx.instructions);
+      block.instructions = std::move(ctx.instructions);
    }
 }
 
diff --git a/src/amd/compiler/aco_register_allocation.cpp b/src/amd/compiler/aco_register_allocation.cpp
index c1cc2d917c58..9058b14b0574 100644
--- a/src/amd/compiler/aco_register_allocation.cpp
+++ b/src/amd/compiler/aco_register_allocation.cpp
@@ -2674,6 +2674,7 @@ register_allocation(Program* program, std::vector<IDSet>& live_out_per_block, ra
       ctx.war_hint.reset();
 
       std::vector<aco_ptr<Instruction>> instructions;
+      instructions.reserve(block.instructions.size());
 
       /* this is a slight adjustment from the paper as we already have phi nodes:
        * We consider them incomplete phis and only handle the definition. */
-- 
GitLab


From 95317189a66f1d86bb37c18946cd4ee9d296244a Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Daniel=20Sch=C3=BCrmann?= <daniel@schuermann.dev>
Date: Wed, 17 Aug 2022 00:23:36 +0200
Subject: [PATCH 2/2] aco/live_var_analysis: implement faster merging of
 live_out sets for some cases

If we know that logical and linear predecessors are the same,
we don't need to check for the register type of each variable.
---
 src/amd/compiler/aco_live_var_analysis.cpp | 29 ++++++++++++++--------
 src/amd/compiler/aco_util.h                | 15 +++++++++++
 2 files changed, 34 insertions(+), 10 deletions(-)

diff --git a/src/amd/compiler/aco_live_var_analysis.cpp b/src/amd/compiler/aco_live_var_analysis.cpp
index 0d6274d6b827..e116b95580d8 100644
--- a/src/amd/compiler/aco_live_var_analysis.cpp
+++ b/src/amd/compiler/aco_live_var_analysis.cpp
@@ -227,20 +227,29 @@ process_live_temps_per_block(Program* program, live& lives, Block* block, unsign
       phi_info[pred_idx].linear_phi_defs = linear_phi_defs;
 
    /* now, we need to merge the live-ins into the live-out sets */
-   for (unsigned t : live) {
-      RegClass rc = program->temp_rc[t];
-      std::vector<unsigned>& preds = rc.is_linear() ? block->linear_preds : block->logical_preds;
+   bool fast_merge =
+      block->logical_preds.size() == 0 || block->logical_preds == block->linear_preds;
+   if (NDEBUG && fast_merge) {
+      for (unsigned pred_idx : block->linear_preds) {
+         if (lives.live_out[pred_idx].insert(live))
+            worklist = std::max(worklist, pred_idx + 1);
+      }
+   } else {
+      for (unsigned t : live) {
+         RegClass rc = program->temp_rc[t];
+         std::vector<unsigned>& preds = rc.is_linear() ? block->linear_preds : block->logical_preds;
 
 #ifndef NDEBUG
-      if (preds.empty())
-         aco_err(program, "Temporary never defined or are defined after use: %%%d in BB%d", t,
-                 block->index);
+         if (preds.empty())
+            aco_err(program, "Temporary never defined or are defined after use: %%%d in BB%d", t,
+                    block->index);
 #endif
 
-      for (unsigned pred_idx : preds) {
-         auto it = lives.live_out[pred_idx].insert(t);
-         if (it.second)
-            worklist = std::max(worklist, pred_idx + 1);
+         for (unsigned pred_idx : preds) {
+            auto it = lives.live_out[pred_idx].insert(t);
+            if (it.second)
+               worklist = std::max(worklist, pred_idx + 1);
+         }
       }
    }
 
diff --git a/src/amd/compiler/aco_util.h b/src/amd/compiler/aco_util.h
index 2b32e94a805f..fd404480949f 100644
--- a/src/amd/compiler/aco_util.h
+++ b/src/amd/compiler/aco_util.h
@@ -297,6 +297,21 @@ struct IDSet {
       return std::make_pair(it, true);
    }
 
+   bool insert(const IDSet other)
+   {
+      bool inserted = false;
+      words.resize(std::max(words.size(), other.words.size()));
+      for (unsigned i = 0; i < other.words.size(); i++) {
+         uint64_t new_bits = other.words[i] & ~words[i];
+         if (new_bits) {
+            inserted = true;
+            bits_set += util_bitcount64(new_bits);
+            words[i] |= new_bits;
+         }
+      }
+      return inserted;
+   }
+
    size_t erase(uint32_t id)
    {
       if (!count(id))
-- 
GitLab

