From 283997a91e161304ee5c0501dd681a5bb1480676 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Fri, 1 Sep 2023 18:56:10 -0400
Subject: [PATCH 1/7] nir: sort variables by location in nir_lower_io_passes to
 work around a bug

I don't know why this is necessary, but it unblocks the work on varying
optimizations.
---
 src/compiler/nir/nir.h                 |  1 +
 src/compiler/nir/nir_linking_helpers.c |  9 +++++++++
 src/compiler/nir/nir_lower_io.c        | 13 +++++++++++++
 3 files changed, 23 insertions(+)

diff --git a/src/compiler/nir/nir.h b/src/compiler/nir/nir.h
index e958bedc0ccb3..f875b56833442 100644
--- a/src/compiler/nir/nir.h
+++ b/src/compiler/nir/nir.h
@@ -4978,6 +4978,7 @@ bool nir_lower_amul(nir_shader *shader,
 
 bool nir_lower_ubo_vec4(nir_shader *shader);
 
+void nir_sort_variables_by_location(nir_shader *shader, nir_variable_mode mode);
 void nir_assign_io_var_locations(nir_shader *shader,
                                  nir_variable_mode mode,
                                  unsigned *size,
diff --git a/src/compiler/nir/nir_linking_helpers.c b/src/compiler/nir/nir_linking_helpers.c
index 0d37738f1b05b..4ba7d717cfb25 100644
--- a/src/compiler/nir/nir_linking_helpers.c
+++ b/src/compiler/nir/nir_linking_helpers.c
@@ -1473,6 +1473,15 @@ sort_varyings(nir_shader *shader, nir_variable_mode mode,
    }
 }
 
+void
+nir_sort_variables_by_location(nir_shader *shader, nir_variable_mode mode)
+{
+   struct exec_list vars;
+
+   sort_varyings(shader, mode, &vars);
+   exec_list_append(&shader->variables, &vars);
+}
+
 void
 nir_assign_io_var_locations(nir_shader *shader, nir_variable_mode mode,
                             unsigned *size, gl_shader_stage stage)
diff --git a/src/compiler/nir/nir_lower_io.c b/src/compiler/nir/nir_lower_io.c
index cdf64e9a1ee03..67988a1716e7c 100644
--- a/src/compiler/nir/nir_lower_io.c
+++ b/src/compiler/nir/nir_lower_io.c
@@ -3127,6 +3127,19 @@ nir_lower_io_passes(nir_shader *nir, bool renumber_vs_inputs)
       (nir->options->support_indirect_outputs >> nir->info.stage) & 0x1 &&
       nir->xfb_info == NULL;
 
+   /* TODO: Sorting variables by location is required due to some bug
+    * in nir_lower_io_to_temporaries. If variables are not sorted,
+    * dEQP-GLES31.functional.separate_shader.random.0 fails.
+    *
+    * This isn't needed if nir_assign_io_var_locations is called because it
+    * also sorts variables. However, if IO is lowered sooner than that, we
+    * must sort explicitly here to get what nir_assign_io_var_locations does.
+    */
+   unsigned varying_var_mask =
+      (nir->info.stage != MESA_SHADER_VERTEX ? nir_var_shader_in : 0) |
+      (nir->info.stage != MESA_SHADER_FRAGMENT ? nir_var_shader_out : 0);
+   nir_sort_variables_by_location(nir, varying_var_mask);
+
    if (!has_indirect_inputs || !has_indirect_outputs) {
       NIR_PASS_V(nir, nir_lower_io_to_temporaries,
                  nir_shader_get_entrypoint(nir), !has_indirect_outputs,
-- 
GitLab


From 16cd47208ebe628b037580461cae0d94bf17f6b1 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Thu, 31 Aug 2023 10:54:39 -0400
Subject: [PATCH 2/7] nir: recompute IO bases after DCE in nir_lower_io_passes

otherwise the IO bases can be incorrect due to non-DCE'd input loads
---
 src/compiler/nir/nir_lower_io.c | 27 +++++++++++++--------------
 1 file changed, 13 insertions(+), 14 deletions(-)

diff --git a/src/compiler/nir/nir_lower_io.c b/src/compiler/nir/nir_lower_io.c
index 67988a1716e7c..8ab6e512495cf 100644
--- a/src/compiler/nir/nir_lower_io.c
+++ b/src/compiler/nir/nir_lower_io.c
@@ -3156,6 +3156,15 @@ nir_lower_io_passes(nir_shader *nir, bool renumber_vs_inputs)
    NIR_PASS_V(nir, nir_lower_io, nir_var_shader_out | nir_var_shader_in,
               type_size_vec4, nir_lower_io_lower_64bit_to_32);
 
+   /* nir_io_add_const_offset_to_base needs actual constants. */
+   NIR_PASS_V(nir, nir_opt_constant_folding);
+   NIR_PASS_V(nir, nir_io_add_const_offset_to_base, nir_var_shader_in | nir_var_shader_out);
+
+   /* Lower and remove dead derefs and variables to clean up the IR. */
+   NIR_PASS_V(nir, nir_lower_vars_to_ssa);
+   NIR_PASS_V(nir, nir_opt_dce);
+   NIR_PASS_V(nir, nir_remove_dead_variables, nir_var_function_temp, NULL);
+
    /* If IO is lowered before var->data.driver_location is assigned, driver
     * locations are all 0, which means IO bases are all 0. It's not necessary
     * to set driver_location before lowering IO because the only thing that
@@ -3166,22 +3175,12 @@ nir_lower_io_passes(nir_shader *nir, bool renumber_vs_inputs)
     * intrinsics refer to the same IO. If the bases already exist, they
     * will be reassigned, sorted by the semantic, and all holes removed.
     * This kind of canonicalizes all bases.
+    *
+    * This must be done after DCE to remove dead load_input intrinsics.
     */
    NIR_PASS_V(nir, nir_recompute_io_bases,
-              (nir->info.stage != MESA_SHADER_VERTEX ||
-                     renumber_vs_inputs
-                  ? nir_var_shader_in
-                  : 0) |
-                 nir_var_shader_out);
-
-   /* nir_io_add_const_offset_to_base needs actual constants. */
-   NIR_PASS_V(nir, nir_opt_constant_folding);
-   NIR_PASS_V(nir, nir_io_add_const_offset_to_base, nir_var_shader_in | nir_var_shader_out);
-
-   /* Lower and remove dead derefs and variables to clean up the IR. */
-   NIR_PASS_V(nir, nir_lower_vars_to_ssa);
-   NIR_PASS_V(nir, nir_opt_dce);
-   NIR_PASS_V(nir, nir_remove_dead_variables, nir_var_function_temp, NULL);
+              (nir->info.stage != MESA_SHADER_VERTEX || renumber_vs_inputs ?
+               nir_var_shader_in : 0) | nir_var_shader_out);
 
    if (nir->xfb_info)
       NIR_PASS_V(nir, nir_io_add_intrinsic_xfb_info);
-- 
GitLab


From e7e3258f23215a60034451dce5dacf54b77f387b Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Mon, 13 Mar 2023 00:18:47 -0400
Subject: [PATCH 3/7] nir: add dual-slot input information into load_input
 intrinsics

This is necessary to allow optimizing VS inputs after nir_lower_io, which
is currently impossible because the loss of dual-slot information in NIR
would break VS inputs. With this, driver locations can be recomputed by
calling nir_recompute_io_bases. It's a prerequisite for optimizing varyings
with lowered IO.

When this is used, we will be able to eliminate unused dual-slot VS inputs
as well as unused low and high halves of dual-slot VS inputs for the first
time, which can happen due to optimizations of varyings. Without this,
st/mesa binds vertex buffers for dual-slot inputs that are fully or
partially unused in the shader.
---
 src/compiler/nir/nir.h          | 21 ++++++++++++++-
 src/compiler/nir/nir_lower_io.c | 46 +++++++++++++++++++++++++++------
 src/compiler/nir/nir_print.c    |  3 +++
 3 files changed, 61 insertions(+), 9 deletions(-)

diff --git a/src/compiler/nir/nir.h b/src/compiler/nir/nir.h
index f875b56833442..5b73a8404ed57 100644
--- a/src/compiler/nir/nir.h
+++ b/src/compiler/nir/nir.h
@@ -1847,6 +1847,7 @@ typedef struct nir_io_semantics {
    unsigned per_view : 1;
    unsigned high_16bits : 1; /* whether accessing low or high half of the slot */
    unsigned invariant : 1;   /* The variable has the invariant flag set */
+   unsigned high_dvec2 : 1; /* whether accessing the high half of dvec3/dvec4 */
    /* CLIP_DISTn, LAYER, VIEWPORT, and TESS_LEVEL_* have up to 3 uses:
     * - an output consumed by the next stage
     * - a system value output affecting fixed-func hardware, e.g. the clipper
@@ -1857,7 +1858,7 @@ typedef struct nir_io_semantics {
    unsigned no_varying : 1;       /* whether this output isn't consumed by the next stage */
    unsigned no_sysval_output : 1; /* whether this system value output has no
                                      effect due to current pipeline states */
-   unsigned _pad : 3;
+   unsigned _pad : 2;
 } nir_io_semantics;
 
 /* Transform feedback info for 2 outputs. nir_intrinsic_store_output contains
@@ -4997,13 +4998,31 @@ typedef enum {
    /* If set, this causes all 64-bit IO operations to be lowered on-the-fly
     * to 32-bit operations.  This is only valid for nir_var_shader_in/out
     * modes.
+    *
+    * Note that this destroys dual-slot information i.e. whether an input
+    * occupies the low or high half of dvec4. Instead, it adds an offset of 1
+    * to the load (which is ambiguous) and expects driver locations of inputs
+    * to be final, which prevents any further optimizations.
+    *
+    * TODO: remove this in favor of nir_lower_io_lower_64bit_to_32_new.
     */
    nir_lower_io_lower_64bit_to_32 = (1 << 0),
+
    /* If set, this causes the subset of 64-bit IO operations involving floats to be lowered on-the-fly
     * to 32-bit operations.  This is only valid for nir_var_shader_in/out
     * modes.
     */
    nir_lower_io_lower_64bit_float_to_32 = (1 << 1),
+
+   /* This causes all 64-bit IO operations to be lowered to 32-bit operations.
+    * This is only valid for nir_var_shader_in/out modes.
+    *
+    * Only VS inputs: Dual slot information is preserved as nir_io_semantics::
+    * high_dvec2 and gathered into shader_info::dual_slot_inputs, so that
+    * the shader can be arbitrarily optimized and the low or high half of
+    * dvec4 can be DCE'd independently without affecting the other half.
+    */
+   nir_lower_io_lower_64bit_to_32_new = (1 << 2),
 } nir_lower_io_options;
 bool nir_lower_io(nir_shader *shader,
                   nir_variable_mode modes,
diff --git a/src/compiler/nir/nir_lower_io.c b/src/compiler/nir/nir_lower_io.c
index 8ab6e512495cf..107cb8735dcdb 100644
--- a/src/compiler/nir/nir_lower_io.c
+++ b/src/compiler/nir/nir_lower_io.c
@@ -158,6 +158,16 @@ nir_is_arrayed_io(const nir_variable *var, gl_shader_stage stage)
    return false;
 }
 
+static bool
+uses_high_dvec2_semantic(struct lower_io_state *state,
+                         const nir_variable *var)
+{
+   return state->builder.shader->info.stage == MESA_SHADER_VERTEX &&
+          state->options & nir_lower_io_lower_64bit_to_32_new &&
+          var->data.mode == nir_var_shader_in &&
+          glsl_type_is_dual_slot(glsl_without_array(var->type));
+}
+
 static unsigned
 get_number_of_slots(struct lower_io_state *state,
                     const nir_variable *var)
@@ -181,7 +191,8 @@ get_number_of_slots(struct lower_io_state *state,
        !nir_is_arrayed_io(var, state->builder.shader->info.stage))
       return 1;
 
-   return state->type_size(type, var->data.bindless);
+   return state->type_size(type, var->data.bindless) /
+          (uses_high_dvec2_semantic(state, var) ? 2 : 1);
 }
 
 static nir_def *
@@ -251,7 +262,7 @@ static nir_def *
 emit_load(struct lower_io_state *state,
           nir_def *array_index, nir_variable *var, nir_def *offset,
           unsigned component, unsigned num_components, unsigned bit_size,
-          nir_alu_type dest_type)
+          nir_alu_type dest_type, bool high_dvec2)
 {
    nir_builder *b = &state->builder;
    const nir_shader *nir = b->shader;
@@ -324,6 +335,7 @@ emit_load(struct lower_io_state *state,
       semantics.medium_precision =
          var->data.precision == GLSL_PRECISION_MEDIUM ||
          var->data.precision == GLSL_PRECISION_LOW;
+      semantics.high_dvec2 = high_dvec2;
       nir_intrinsic_set_io_semantics(load, semantics);
    }
 
@@ -350,14 +362,23 @@ lower_load(nir_intrinsic_instr *intrin, struct lower_io_state *state,
 {
    const bool lower_double = !glsl_type_is_integer(type) && state->options & nir_lower_io_lower_64bit_float_to_32;
    if (intrin->def.bit_size == 64 &&
-       (lower_double || (state->options & nir_lower_io_lower_64bit_to_32))) {
+       (lower_double || (state->options & (nir_lower_io_lower_64bit_to_32_new |
+                                           nir_lower_io_lower_64bit_to_32)))) {
       nir_builder *b = &state->builder;
+      bool use_high_dvec2_semantic = uses_high_dvec2_semantic(state, var);
+
+      /* Each slot is a dual slot, so divide the offset within the variable
+       * by 2.
+       */
+      if (use_high_dvec2_semantic)
+         offset = nir_ushr_imm(b, offset, 1);
 
       const unsigned slot_size = state->type_size(glsl_dvec_type(2), false);
 
       nir_def *comp64[4];
       assert(component == 0 || component == 2);
       unsigned dest_comp = 0;
+      bool high_dvec2 = false;
       while (dest_comp < intrin->def.num_components) {
          const unsigned num_comps =
             MIN2(intrin->def.num_components - dest_comp,
@@ -365,7 +386,7 @@ lower_load(nir_intrinsic_instr *intrin, struct lower_io_state *state,
 
          nir_def *data32 =
             emit_load(state, array_index, var, offset, component,
-                      num_comps * 2, 32, nir_type_uint32);
+                      num_comps * 2, 32, nir_type_uint32, high_dvec2);
          for (unsigned i = 0; i < num_comps; i++) {
             comp64[dest_comp + i] =
                nir_pack_64_2x32(b, nir_channels(b, data32, 3 << (i * 2)));
@@ -374,7 +395,15 @@ lower_load(nir_intrinsic_instr *intrin, struct lower_io_state *state,
          /* Only the first store has a component offset */
          component = 0;
          dest_comp += num_comps;
-         offset = nir_iadd_imm(b, offset, slot_size);
+
+         if (use_high_dvec2_semantic) {
+            /* Increment the offset when we wrap around the dual slot. */
+            if (high_dvec2)
+               offset = nir_iadd_imm(b, offset, slot_size);
+            high_dvec2 = !high_dvec2;
+         } else {
+            offset = nir_iadd_imm(b, offset, slot_size);
+         }
       }
 
       return nir_vec(b, comp64, intrin->def.num_components);
@@ -384,12 +413,12 @@ lower_load(nir_intrinsic_instr *intrin, struct lower_io_state *state,
       return nir_b2b1(&state->builder,
                       emit_load(state, array_index, var, offset, component,
                                 intrin->def.num_components, 32,
-                                nir_type_bool32));
+                                nir_type_bool32, false));
    } else {
       return emit_load(state, array_index, var, offset, component,
                        intrin->def.num_components,
                        intrin->def.bit_size,
-                       nir_get_nir_type_for_glsl_type(type));
+                       nir_get_nir_type_for_glsl_type(type), false);
    }
 }
 
@@ -461,7 +490,8 @@ lower_store(nir_intrinsic_instr *intrin, struct lower_io_state *state,
 {
    const bool lower_double = !glsl_type_is_integer(type) && state->options & nir_lower_io_lower_64bit_float_to_32;
    if (intrin->src[1].ssa->bit_size == 64 &&
-       (lower_double || (state->options & nir_lower_io_lower_64bit_to_32))) {
+       (lower_double || (state->options & (nir_lower_io_lower_64bit_to_32 |
+                                           nir_lower_io_lower_64bit_to_32_new)))) {
       nir_builder *b = &state->builder;
 
       const unsigned slot_size = state->type_size(glsl_dvec_type(2), false);
diff --git a/src/compiler/nir/nir_print.c b/src/compiler/nir/nir_print.c
index e87e8b5a40e74..301b98a256e79 100644
--- a/src/compiler/nir/nir_print.c
+++ b/src/compiler/nir/nir_print.c
@@ -1378,6 +1378,9 @@ print_intrinsic_instr(nir_intrinsic_instr *instr, print_state *state)
          if (io.high_16bits)
             fprintf(fp, " high_16bits");
 
+         if (io.high_dvec2)
+            fprintf(fp, " high_dvec2");
+
          if (io.no_varying)
             fprintf(fp, " no_varying");
 
-- 
GitLab


From 7950d1dbb4c7e3767992949c54f8c069d459393b Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Tue, 26 Sep 2023 00:09:49 -0400
Subject: [PATCH 4/7] nir: take dual slot input info into account when
 computing IO driver locations

---
 src/compiler/nir/nir_lower_mediump.c | 11 +++++++++--
 1 file changed, 9 insertions(+), 2 deletions(-)

diff --git a/src/compiler/nir/nir_lower_mediump.c b/src/compiler/nir/nir_lower_mediump.c
index e2604996c2525..68da6ce30a918 100644
--- a/src/compiler/nir/nir_lower_mediump.c
+++ b/src/compiler/nir/nir_lower_mediump.c
@@ -67,8 +67,10 @@ nir_recompute_io_bases(nir_shader *nir, nir_variable_mode modes)
    nir_function_impl *impl = nir_shader_get_entrypoint(nir);
 
    BITSET_DECLARE(inputs, NUM_TOTAL_VARYING_SLOTS);
+   BITSET_DECLARE(dual_slot_inputs, NUM_TOTAL_VARYING_SLOTS);
    BITSET_DECLARE(outputs, NUM_TOTAL_VARYING_SLOTS);
    BITSET_ZERO(inputs);
+   BITSET_ZERO(dual_slot_inputs);
    BITSET_ZERO(outputs);
 
    /* Gather the bitmasks of used locations. */
@@ -85,8 +87,11 @@ nir_recompute_io_bases(nir_shader *nir, nir_variable_mode modes)
             num_slots = (num_slots + sem.high_16bits + 1) / 2;
 
          if (mode == nir_var_shader_in) {
-            for (unsigned i = 0; i < num_slots; i++)
+            for (unsigned i = 0; i < num_slots; i++) {
                BITSET_SET(inputs, sem.location + i);
+               if (sem.high_dvec2)
+                  BITSET_SET(dual_slot_inputs, sem.location + i);
+            }
          } else if (!sem.dual_source_blend_index) {
             for (unsigned i = 0; i < num_slots; i++)
                BITSET_SET(outputs, sem.location + i);
@@ -111,7 +116,9 @@ nir_recompute_io_bases(nir_shader *nir, nir_variable_mode modes)
 
          if (mode == nir_var_shader_in) {
             nir_intrinsic_set_base(intr,
-                                   BITSET_PREFIX_SUM(inputs, sem.location));
+                                   BITSET_PREFIX_SUM(inputs, sem.location) +
+                                   BITSET_PREFIX_SUM(dual_slot_inputs, sem.location) +
+                                   (sem.high_dvec2 ? 1 : 0));
          } else if (sem.dual_source_blend_index) {
             nir_intrinsic_set_base(intr,
                                    BITSET_PREFIX_SUM(outputs, NUM_TOTAL_VARYING_SLOTS));
-- 
GitLab


From b53b2ed4d75280fcee2cfd69ac0e1c203bbd5240 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Tue, 26 Sep 2023 00:10:44 -0400
Subject: [PATCH 5/7] nir: gather dual slot input information

---
 src/compiler/nir/nir_gather_info.c | 3 +++
 src/compiler/nir/nir_print.c       | 1 +
 src/compiler/shader_info.h         | 2 ++
 3 files changed, 6 insertions(+)

diff --git a/src/compiler/nir/nir_gather_info.c b/src/compiler/nir/nir_gather_info.c
index 865d976a98e06..d02018986b635 100644
--- a/src/compiler/nir/nir_gather_info.c
+++ b/src/compiler/nir/nir_gather_info.c
@@ -508,6 +508,8 @@ gather_intrinsic_info(nir_intrinsic_instr *instr, nir_shader *shader,
             shader->info.patch_inputs_read_indirectly |= slot_mask;
       } else {
          shader->info.inputs_read |= slot_mask;
+         if (nir_intrinsic_io_semantics(instr).high_dvec2)
+            shader->info.dual_slot_inputs |= slot_mask;
          shader->info.inputs_read_16bit |= slot_mask_16bit;
          if (!nir_src_is_const(*nir_get_io_offset_src(instr))) {
             shader->info.inputs_read_indirectly |= slot_mask;
@@ -926,6 +928,7 @@ nir_shader_gather_info(nir_shader *shader, nir_function_impl *entrypoint)
    }
 
    shader->info.inputs_read = 0;
+   shader->info.dual_slot_inputs = 0;
    shader->info.outputs_written = 0;
    shader->info.outputs_read = 0;
    shader->info.inputs_read_16bit = 0;
diff --git a/src/compiler/nir/nir_print.c b/src/compiler/nir/nir_print.c
index 301b98a256e79..56d280cbb6dea 100644
--- a/src/compiler/nir/nir_print.c
+++ b/src/compiler/nir/nir_print.c
@@ -2397,6 +2397,7 @@ print_shader_info(const struct shader_info *info, FILE *fp)
    print_nz_unsigned(fp, "num_images", info->num_images);
 
    print_nz_x64(fp, "inputs_read", info->inputs_read);
+   print_nz_x64(fp, "dual_slot_inputs", info->dual_slot_inputs);
    print_nz_x64(fp, "outputs_written", info->outputs_written);
    print_nz_x64(fp, "outputs_read", info->outputs_read);
 
diff --git a/src/compiler/shader_info.h b/src/compiler/shader_info.h
index ad2c7afcc8ccb..052ef6ab5b2f5 100644
--- a/src/compiler/shader_info.h
+++ b/src/compiler/shader_info.h
@@ -167,6 +167,8 @@ typedef struct shader_info {
 
    /* Which inputs are actually read */
    uint64_t inputs_read;
+   /* Which inputs occupy 2 slots. */
+   uint64_t dual_slot_inputs;
    /* Which outputs are actually written */
    uint64_t outputs_written;
    /* Which outputs are actually read */
-- 
GitLab


From c2225d88efbfc7e67bfbd388c93827862dbf0d79 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Wed, 5 Apr 2023 06:40:59 -0400
Subject: [PATCH 6/7] nir: expose reusable linking helpers for cloning uniform
 loads

for the new varying optimizer
---
 src/compiler/nir/nir.h                 |  5 +++++
 src/compiler/nir/nir_linking_helpers.c | 30 +++++++++++++++-----------
 2 files changed, 23 insertions(+), 12 deletions(-)

diff --git a/src/compiler/nir/nir.h b/src/compiler/nir/nir.h
index 5b73a8404ed57..5a1f5cc38582a 100644
--- a/src/compiler/nir/nir.h
+++ b/src/compiler/nir/nir.h
@@ -4965,6 +4965,11 @@ void nir_compact_varyings(nir_shader *producer, nir_shader *consumer,
 void nir_link_xfb_varyings(nir_shader *producer, nir_shader *consumer);
 bool nir_link_opt_varyings(nir_shader *producer, nir_shader *consumer);
 void nir_link_varying_precision(nir_shader *producer, nir_shader *consumer);
+nir_variable *nir_clone_uniform_variable(nir_shader *nir,
+                                         nir_variable *uniform);
+nir_deref_instr *nir_clone_deref_instr(struct nir_builder *b,
+                                       nir_variable *var,
+                                       nir_deref_instr *deref);
 
 bool nir_slot_is_sysval_output(gl_varying_slot slot,
                                gl_shader_stage next_shader);
diff --git a/src/compiler/nir/nir_linking_helpers.c b/src/compiler/nir/nir_linking_helpers.c
index 4ba7d717cfb25..364623359fcee 100644
--- a/src/compiler/nir/nir_linking_helpers.c
+++ b/src/compiler/nir/nir_linking_helpers.c
@@ -1166,14 +1166,19 @@ is_direct_uniform_load(nir_def *def, nir_scalar *s)
    return !nir_deref_instr_has_indirect(deref);
 }
 
-static nir_variable *
-get_uniform_var_in_consumer(nir_shader *consumer,
-                            nir_variable *var_in_producer)
+/**
+ * Add a uniform variable from one shader to a different shader.
+ *
+ * \param nir     The shader where to add the uniform
+ * \param uniform The uniform that's declared in another shader.
+ */
+nir_variable *
+nir_clone_uniform_variable(nir_shader *nir, nir_variable *uniform)
 {
    /* Find if uniform already exists in consumer. */
    nir_variable *new_var = NULL;
-   nir_foreach_uniform_variable(v, consumer) {
-      if (!strcmp(var_in_producer->name, v->name)) {
+   nir_foreach_uniform_variable(v, nir) {
+      if (!strcmp(uniform->name, v->name)) {
          new_var = v;
          break;
       }
@@ -1181,21 +1186,22 @@ get_uniform_var_in_consumer(nir_shader *consumer,
 
    /* Create a variable if not exist. */
    if (!new_var) {
-      new_var = nir_variable_clone(var_in_producer, consumer);
-      nir_shader_add_variable(consumer, new_var);
+      new_var = nir_variable_clone(uniform, nir);
+      nir_shader_add_variable(nir, new_var);
    }
 
    return new_var;
 }
 
-static nir_deref_instr *
-clone_deref_instr(nir_builder *b, nir_variable *var, nir_deref_instr *deref)
+nir_deref_instr *
+nir_clone_deref_instr(nir_builder *b, nir_variable *var,
+                      nir_deref_instr *deref)
 {
    if (deref->deref_type == nir_deref_type_var)
       return nir_build_deref_var(b, var);
 
    nir_deref_instr *parent_deref = nir_deref_instr_parent(deref);
-   nir_deref_instr *parent = clone_deref_instr(b, var, parent_deref);
+   nir_deref_instr *parent = nir_clone_deref_instr(b, var, parent_deref);
 
    /* Build array and struct deref instruction.
     * "deref" instr is sure to be direct (see is_direct_uniform_load()).
@@ -1235,7 +1241,7 @@ replace_varying_input_by_uniform_load(nir_shader *shader,
    nir_intrinsic_instr *load = nir_instr_as_intrinsic(scalar->def->parent_instr);
    nir_deref_instr *deref = nir_src_as_deref(load->src[0]);
    nir_variable *uni_var = nir_deref_instr_get_variable(deref);
-   uni_var = get_uniform_var_in_consumer(shader, uni_var);
+   uni_var = nir_clone_uniform_variable(shader, uni_var);
 
    bool progress = false;
    nir_foreach_block(block, impl) {
@@ -1259,7 +1265,7 @@ replace_varying_input_by_uniform_load(nir_shader *shader,
          b.cursor = nir_before_instr(instr);
 
          /* Clone instructions start from deref load to variable deref. */
-         nir_deref_instr *uni_deref = clone_deref_instr(&b, uni_var, deref);
+         nir_deref_instr *uni_deref = nir_clone_deref_instr(&b, uni_var, deref);
          nir_def *uni_def = nir_load_deref(&b, uni_deref);
 
          /* Add a vector to scalar move if uniform is a vector. */
-- 
GitLab


From daa3676adfc899048b4f7fc38f41c7b6603ab01d Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Thu, 6 Apr 2023 23:34:47 -0400
Subject: [PATCH 7/7] nir: handle nir_var_mem_ubo in nir_clone_uniform_variable

for UBOs
---
 src/compiler/nir/nir.h                 |  2 +-
 src/compiler/nir/nir_linking_helpers.c | 10 ++++++----
 2 files changed, 7 insertions(+), 5 deletions(-)

diff --git a/src/compiler/nir/nir.h b/src/compiler/nir/nir.h
index 5a1f5cc38582a..120da59b2f8f2 100644
--- a/src/compiler/nir/nir.h
+++ b/src/compiler/nir/nir.h
@@ -4966,7 +4966,7 @@ void nir_link_xfb_varyings(nir_shader *producer, nir_shader *consumer);
 bool nir_link_opt_varyings(nir_shader *producer, nir_shader *consumer);
 void nir_link_varying_precision(nir_shader *producer, nir_shader *consumer);
 nir_variable *nir_clone_uniform_variable(nir_shader *nir,
-                                         nir_variable *uniform);
+                                         nir_variable *uniform, bool spirv);
 nir_deref_instr *nir_clone_deref_instr(struct nir_builder *b,
                                        nir_variable *var,
                                        nir_deref_instr *deref);
diff --git a/src/compiler/nir/nir_linking_helpers.c b/src/compiler/nir/nir_linking_helpers.c
index 364623359fcee..f3be6b1c6f604 100644
--- a/src/compiler/nir/nir_linking_helpers.c
+++ b/src/compiler/nir/nir_linking_helpers.c
@@ -1173,12 +1173,14 @@ is_direct_uniform_load(nir_def *def, nir_scalar *s)
  * \param uniform The uniform that's declared in another shader.
  */
 nir_variable *
-nir_clone_uniform_variable(nir_shader *nir, nir_variable *uniform)
+nir_clone_uniform_variable(nir_shader *nir, nir_variable *uniform, bool spirv)
 {
    /* Find if uniform already exists in consumer. */
    nir_variable *new_var = NULL;
-   nir_foreach_uniform_variable(v, nir) {
-      if (!strcmp(uniform->name, v->name)) {
+   nir_foreach_variable_with_modes(v, nir, uniform->data.mode) {
+      if ((spirv && uniform->data.mode & nir_var_mem_ubo &&
+           v->data.binding == uniform->data.binding) ||
+          (!spirv && !strcmp(uniform->name, v->name))) {
          new_var = v;
          break;
       }
@@ -1241,7 +1243,7 @@ replace_varying_input_by_uniform_load(nir_shader *shader,
    nir_intrinsic_instr *load = nir_instr_as_intrinsic(scalar->def->parent_instr);
    nir_deref_instr *deref = nir_src_as_deref(load->src[0]);
    nir_variable *uni_var = nir_deref_instr_get_variable(deref);
-   uni_var = nir_clone_uniform_variable(shader, uni_var);
+   uni_var = nir_clone_uniform_variable(shader, uni_var, false);
 
    bool progress = false;
    nir_foreach_block(block, impl) {
-- 
GitLab

