From dcffcbfdc7cfbb0c19f6a4b2570db141d637046d Mon Sep 17 00:00:00 2001
From: Jesse Natalie <jenatali@microsoft.com>
Date: Fri, 24 Sep 2021 08:41:05 -0700
Subject: [PATCH 01/19] egl/wgl: Don't require a native display to support
 window surfaces

Found a Windows EGL/GLES app that inits EGL without a native display,
and then creates a window surface from that EGL display:
https://github.com/danginsburg/opengles3-book/
---
 src/egl/drivers/wgl/egl_wgl.c | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/src/egl/drivers/wgl/egl_wgl.c b/src/egl/drivers/wgl/egl_wgl.c
index b98445133c42..bde80adaa3c0 100644
--- a/src/egl/drivers/wgl/egl_wgl.c
+++ b/src/egl/drivers/wgl/egl_wgl.c
@@ -171,10 +171,10 @@ wgl_add_config(_EGLDisplay *disp, const struct stw_pixelformat_info *stw_config,
 }
 
 static EGLBoolean
-wgl_add_configs(_EGLDisplay *disp, HDC hdc)
+wgl_add_configs(_EGLDisplay *disp)
 {
    unsigned int config_count = 0;
-   unsigned surface_type = EGL_PBUFFER_BIT | (hdc ? EGL_WINDOW_BIT : 0);
+   unsigned surface_type = EGL_PBUFFER_BIT | EGL_WINDOW_BIT;
 
    // This is already a filtered set of what the driver supports,
    // and there's no further filtering needed per-visual
@@ -256,7 +256,7 @@ wgl_initialize_impl(_EGLDisplay *disp, HDC hdc)
    }
 #endif
 
-   if (!wgl_add_configs(disp, hdc)) {
+   if (!wgl_add_configs(disp)) {
       err = "wgl: failed to add configs";
       goto cleanup;
    }
-- 
GitLab


From bae09f7dcd2a0d13e2ef86ba216832f32500dd5e Mon Sep 17 00:00:00 2001
From: Jesse Natalie <jenatali@microsoft.com>
Date: Thu, 16 Sep 2021 11:52:05 -0700
Subject: [PATCH 02/19] egl/wgl: Implement QuerySurface

---
 src/egl/drivers/wgl/egl_wgl.c | 22 ++++++++++++++++++++++
 1 file changed, 22 insertions(+)

diff --git a/src/egl/drivers/wgl/egl_wgl.c b/src/egl/drivers/wgl/egl_wgl.c
index bde80adaa3c0..ad5962f695d6 100644
--- a/src/egl/drivers/wgl/egl_wgl.c
+++ b/src/egl/drivers/wgl/egl_wgl.c
@@ -688,6 +688,27 @@ wgl_create_window_surface(_EGLDisplay *disp, _EGLConfig *conf,
    return &wgl_surf->base;
 }
 
+static EGLBoolean
+wgl_query_surface(_EGLDisplay *disp, _EGLSurface *surf,
+                  EGLint attribute, EGLint *value)
+{
+   struct wgl_egl_surface *wgl_surf = wgl_egl_surface(surf);
+   RECT client_rect;
+
+   switch (attribute) {
+   case EGL_WIDTH:
+   case EGL_HEIGHT:
+      if (GetClientRect(wgl_surf->fb->hWnd, &client_rect)) {
+         surf->Width = client_rect.right;
+         surf->Height = client_rect.bottom;
+      }
+      break;
+   default:
+      break;
+   }
+   return _eglQuerySurface(disp, surf, attribute, value);
+}
+
 static EGLBoolean
 wgl_swap_buffers(_EGLDisplay *disp, _EGLSurface *draw)
 {
@@ -710,6 +731,7 @@ struct _egl_driver _eglDriver = {
    .MakeCurrent = wgl_make_current,
    .CreateWindowSurface = wgl_create_window_surface,
    .DestroySurface = wgl_destroy_surface,
+   .QuerySurface = wgl_query_surface,
    .GetProcAddress = _glapi_get_proc_address,
    .SwapBuffers = wgl_swap_buffers,
 };
-- 
GitLab


From eadee302dacabbdfdb38ff8c101ebeaa5306acc1 Mon Sep 17 00:00:00 2001
From: Jesse Natalie <jenatali@microsoft.com>
Date: Thu, 16 Sep 2021 13:31:04 -0700
Subject: [PATCH 03/19] wgl: Split pbuffer creation into two functions

One creates a window and framebuffer, the other deals with
wgl-specific attribute parsing and GDI interactions.
---
 src/gallium/frontends/wgl/stw_ext_pbuffer.c | 168 ++++++++++----------
 src/gallium/frontends/wgl/stw_framebuffer.h |   3 +
 src/gallium/targets/wgl/gallium_wgl.def.in  |   1 +
 3 files changed, 88 insertions(+), 84 deletions(-)

diff --git a/src/gallium/frontends/wgl/stw_ext_pbuffer.c b/src/gallium/frontends/wgl/stw_ext_pbuffer.c
index 9e0e564dbf19..824ce000ce83 100644
--- a/src/gallium/frontends/wgl/stw_ext_pbuffer.c
+++ b/src/gallium/frontends/wgl/stw_ext_pbuffer.c
@@ -65,6 +65,87 @@ WndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
     return DefWindowProc(hWnd, uMsg, wParam, lParam);
 }
 
+struct stw_framebuffer *
+stw_pbuffer_create(int iPixelFormat, int iWidth, int iHeight)
+{
+   static boolean first = TRUE;
+
+   /*
+    * Implement pbuffers through invisible windows
+    */
+
+   if (first) {
+      WNDCLASS wc;
+      memset(&wc, 0, sizeof wc);
+      wc.hbrBackground = (HBRUSH) (COLOR_BTNFACE + 1);
+      wc.hCursor = LoadCursor(NULL, IDC_ARROW);
+      wc.hIcon = LoadIcon(NULL, IDI_APPLICATION);
+      wc.lpfnWndProc = WndProc;
+      wc.lpszClassName = "wglpbuffer";
+      wc.style = CS_OWNDC | CS_HREDRAW | CS_VREDRAW;
+      RegisterClass(&wc);
+      first = FALSE;
+   }
+
+   DWORD dwExStyle = 0;
+   DWORD dwStyle = WS_CLIPSIBLINGS | WS_CLIPCHILDREN;
+
+   if (0) {
+      /*
+       * Don't hide the window -- useful for debugging what the application is
+       * drawing
+       */
+
+      dwStyle |= WS_VISIBLE | WS_OVERLAPPEDWINDOW;
+   } else {
+      dwStyle |= WS_POPUPWINDOW;
+   }
+
+   RECT rect = { 0, 0, iWidth, iHeight };
+
+   /*
+    * The CreateWindowEx parameters are the total (outside) dimensions of the
+    * window, which can vary with Windows version and user settings.  Use
+    * AdjustWindowRect to get the required total area for the given client area.
+    *
+    * AdjustWindowRectEx does not accept WS_OVERLAPPED style (which is defined
+    * as 0), which means we need to use some other style instead, e.g.,
+    * WS_OVERLAPPEDWINDOW or WS_POPUPWINDOW as above.
+    */
+
+   AdjustWindowRectEx(&rect, dwStyle, FALSE, dwExStyle);
+
+   HWND hWnd = CreateWindowEx(dwExStyle,
+                              "wglpbuffer", /* wc.lpszClassName */
+                              NULL,
+                              dwStyle,
+                              CW_USEDEFAULT, /* x */
+                              CW_USEDEFAULT, /* y */
+                              rect.right - rect.left, /* width */
+                              rect.bottom - rect.top, /* height */
+                              NULL,
+                              NULL,
+                              NULL,
+                              NULL);
+   if (!hWnd) {
+      return 0;
+   }
+
+#ifdef DEBUG
+   /*
+    * Verify the client area size matches the specified size.
+    */
+
+   GetClientRect(hWnd, &rect);
+   assert(rect.left == 0);
+   assert(rect.top == 0);
+   assert(rect.right - rect.left == iWidth);
+   assert(rect.bottom - rect.top == iHeight);
+#endif
+
+   return stw_framebuffer_create(hWnd, iPixelFormat, STW_FRAMEBUFFER_PBUFFER);
+}
+
 
 HPBUFFERARB WINAPI
 wglCreatePbufferARB(HDC hCurrentDC,
@@ -73,14 +154,9 @@ wglCreatePbufferARB(HDC hCurrentDC,
                     int iHeight,
                     const int *piAttribList)
 {
-   static boolean first = TRUE;
    const int *piAttrib;
    int useLargest = 0;
-   const struct stw_pixelformat_info *info;
    struct stw_framebuffer *fb;
-   DWORD dwExStyle;
-   DWORD dwStyle;
-   RECT rect;
    HWND hWnd;
    int iDisplayablePixelFormat;
    PIXELFORMATDESCRIPTOR pfd;
@@ -89,8 +165,7 @@ wglCreatePbufferARB(HDC hCurrentDC,
    int textureTarget = WGL_NO_TEXTURE_ARB;
    BOOL textureMipmap = FALSE;
 
-   info = stw_pixelformat_get_info(iPixelFormat);
-   if (!info) {
+   if (!stw_pixelformat_get_info(iPixelFormat)) {
       SetLastError(ERROR_INVALID_PIXEL_FORMAT);
       return 0;
    }
@@ -162,87 +237,11 @@ wglCreatePbufferARB(HDC hCurrentDC,
       }
    }
 
-   /*
-    * Implement pbuffers through invisible windows
-    */
-
-   if (first) {
-      WNDCLASS wc;
-      memset(&wc, 0, sizeof wc);
-      wc.hbrBackground = (HBRUSH) (COLOR_BTNFACE + 1);
-      wc.hCursor = LoadCursor(NULL, IDC_ARROW);
-      wc.hIcon = LoadIcon(NULL, IDI_APPLICATION);
-      wc.lpfnWndProc = WndProc;
-      wc.lpszClassName = "wglpbuffer";
-      wc.style = CS_OWNDC | CS_HREDRAW | CS_VREDRAW;
-      RegisterClass(&wc);
-      first = FALSE;
-   }
-
-   dwExStyle = 0;
-   dwStyle = WS_CLIPSIBLINGS | WS_CLIPCHILDREN;
-
-   if (0) {
-      /*
-       * Don't hide the window -- useful for debugging what the application is
-       * drawing
-       */
-
-      dwStyle |= WS_VISIBLE | WS_OVERLAPPEDWINDOW;
-   } else {
-      dwStyle |= WS_POPUPWINDOW;
-   }
-
-   rect.left = 0;
-   rect.top = 0;
-   rect.right = rect.left + iWidth;
-   rect.bottom = rect.top + iHeight;
-
-   /*
-    * The CreateWindowEx parameters are the total (outside) dimensions of the
-    * window, which can vary with Windows version and user settings.  Use
-    * AdjustWindowRect to get the required total area for the given client area.
-    *
-    * AdjustWindowRectEx does not accept WS_OVERLAPPED style (which is defined
-    * as 0), which means we need to use some other style instead, e.g.,
-    * WS_OVERLAPPEDWINDOW or WS_POPUPWINDOW as above.
-    */
-
-   AdjustWindowRectEx(&rect, dwStyle, FALSE, dwExStyle);
-
-   hWnd = CreateWindowEx(dwExStyle,
-                         "wglpbuffer", /* wc.lpszClassName */
-                         NULL,
-                         dwStyle,
-                         CW_USEDEFAULT, /* x */
-                         CW_USEDEFAULT, /* y */
-                         rect.right - rect.left, /* width */
-                         rect.bottom - rect.top, /* height */
-                         NULL,
-                         NULL,
-                         NULL,
-                         NULL);
-   if (!hWnd) {
-      return 0;
-   }
-
-#ifdef DEBUG
-   /*
-    * Verify the client area size matches the specified size.
-    */
-
-   GetClientRect(hWnd, &rect);
-   assert(rect.left == 0);
-   assert(rect.top == 0);
-   assert(rect.right - rect.left == iWidth);
-   assert(rect.bottom - rect.top == iHeight);
-#endif
-
    /*
     * We can't pass non-displayable pixel formats to GDI, which is why we
     * create the framebuffer object before calling SetPixelFormat().
     */
-   fb = stw_framebuffer_create(hWnd, iPixelFormat, STW_FRAMEBUFFER_PBUFFER);
+   fb = stw_pbuffer_create(iPixelFormat, iWidth, iHeight);
    if (!fb) {
       SetLastError(ERROR_NO_SYSTEM_RESOURCES);
       return NULL;
@@ -254,6 +253,7 @@ wglCreatePbufferARB(HDC hCurrentDC,
    fb->textureMipmap = textureMipmap;
 
    iDisplayablePixelFormat = fb->iDisplayablePixelFormat;
+   hWnd = fb->hWnd;
 
    stw_framebuffer_unlock(fb);
 
diff --git a/src/gallium/frontends/wgl/stw_framebuffer.h b/src/gallium/frontends/wgl/stw_framebuffer.h
index 932c8e0925f8..db8a82a6851f 100644
--- a/src/gallium/frontends/wgl/stw_framebuffer.h
+++ b/src/gallium/frontends/wgl/stw_framebuffer.h
@@ -154,6 +154,9 @@ struct stw_framebuffer
 struct stw_framebuffer *
 stw_framebuffer_create(HWND hwnd, int iPixelFormat, enum stw_framebuffer_owner owner);
 
+struct stw_framebuffer *
+stw_pbuffer_create(int iPixelFormat, int iWidth, int iHeight);
+
 
 /**
  * Increase fb reference count.  The referenced framebuffer should be locked.
diff --git a/src/gallium/targets/wgl/gallium_wgl.def.in b/src/gallium/targets/wgl/gallium_wgl.def.in
index 860389d48cc4..109016b4cc75 100644
--- a/src/gallium/targets/wgl/gallium_wgl.def.in
+++ b/src/gallium/targets/wgl/gallium_wgl.def.in
@@ -37,3 +37,4 @@ stw_framebuffer_create
 stw_framebuffer_release_locked
 stw_framebuffer_unlock
 stw_framebuffer_swap_locked
+stw_pbuffer_create
-- 
GitLab


From 45841bce7796fec38905c3e393fd29613a4ac151 Mon Sep 17 00:00:00 2001
From: Jesse Natalie <jenatali@microsoft.com>
Date: Thu, 16 Sep 2021 14:43:02 -0700
Subject: [PATCH 04/19] egl/wgl: Implement PBuffer surfaces

---
 src/egl/drivers/wgl/egl_wgl.c | 39 ++++++++++++++++++++++++++++++++---
 1 file changed, 36 insertions(+), 3 deletions(-)

diff --git a/src/egl/drivers/wgl/egl_wgl.c b/src/egl/drivers/wgl/egl_wgl.c
index ad5962f695d6..108f8eb9e4e5 100644
--- a/src/egl/drivers/wgl/egl_wgl.c
+++ b/src/egl/drivers/wgl/egl_wgl.c
@@ -491,9 +491,13 @@ wgl_destroy_surface(_EGLDisplay *disp, _EGLSurface *surf)
    if (!_eglPutSurface(surf))
       return EGL_TRUE;
 
-   struct stw_context *ctx = stw_current_context();
-   stw_framebuffer_lock(wgl_surf->fb);
-   stw_framebuffer_release_locked(wgl_surf->fb, ctx ? ctx->st : NULL);
+   if (wgl_surf->fb->owner == STW_FRAMEBUFFER_PBUFFER) {
+      DestroyWindow(wgl_surf->fb->hWnd);
+   } else {
+      struct stw_context *ctx = stw_current_context();
+      stw_framebuffer_lock(wgl_surf->fb);
+      stw_framebuffer_release_locked(wgl_surf->fb, ctx ? ctx->st : NULL);
+   }
    return EGL_TRUE;
 }
 
@@ -688,6 +692,34 @@ wgl_create_window_surface(_EGLDisplay *disp, _EGLConfig *conf,
    return &wgl_surf->base;
 }
 
+static _EGLSurface*
+wgl_create_pbuffer_surface(_EGLDisplay *disp, _EGLConfig *conf,
+                           const EGLint *attrib_list)
+{
+   struct wgl_egl_config *wgl_conf = wgl_egl_config(conf);
+
+   struct wgl_egl_surface *wgl_surf = calloc(1, sizeof(*wgl_surf));
+   if (!wgl_surf)
+      return NULL;
+
+   if (!_eglInitSurface(&wgl_surf->base, disp, EGL_PBUFFER_BIT, conf, attrib_list, NULL)) {
+      free(wgl_surf);
+      return NULL;
+   }
+
+   const struct stw_pixelformat_info *stw_conf = wgl_conf->stw_config[1] ?
+      wgl_conf->stw_config[1] : wgl_conf->stw_config[0];
+   wgl_surf->fb = stw_pbuffer_create(stw_conf->iPixelFormat, wgl_surf->base.Width, wgl_surf->base.Height);
+   if (!wgl_surf->fb) {
+      free(wgl_surf);
+      return NULL;
+   }
+
+   stw_framebuffer_unlock(wgl_surf->fb);
+
+   return &wgl_surf->base;
+}
+
 static EGLBoolean
 wgl_query_surface(_EGLDisplay *disp, _EGLSurface *surf,
                   EGLint attribute, EGLint *value)
@@ -730,6 +762,7 @@ struct _egl_driver _eglDriver = {
    .DestroyContext = wgl_destroy_context,
    .MakeCurrent = wgl_make_current,
    .CreateWindowSurface = wgl_create_window_surface,
+   .CreatePbufferSurface = wgl_create_pbuffer_surface,
    .DestroySurface = wgl_destroy_surface,
    .QuerySurface = wgl_query_surface,
    .GetProcAddress = _glapi_get_proc_address,
-- 
GitLab


From 62a4d28cf0360b49c4b84e50240881884e1fcd20 Mon Sep 17 00:00:00 2001
From: Jesse Natalie <jenatali@microsoft.com>
Date: Fri, 17 Sep 2021 18:54:02 -0700
Subject: [PATCH 05/19] egl/wgl: Set YInvert attribute to always true

---
 src/egl/drivers/wgl/egl_wgl.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/src/egl/drivers/wgl/egl_wgl.c b/src/egl/drivers/wgl/egl_wgl.c
index 108f8eb9e4e5..a6f938fbcb7c 100644
--- a/src/egl/drivers/wgl/egl_wgl.c
+++ b/src/egl/drivers/wgl/egl_wgl.c
@@ -126,6 +126,7 @@ wgl_add_config(_EGLDisplay *disp, const struct stw_pixelformat_info *stw_config,
 
    base.MinSwapInterval = 0;
    base.MaxSwapInterval = 1;
+   base.YInvertedNOK = EGL_TRUE;
 
    if (!_eglValidateConfig(&base, EGL_FALSE)) {
       _eglLog(_EGL_DEBUG, "wgl: failed to validate config %d", id);
-- 
GitLab


From 40e0b0e9b2251d360c6fb0a5b2fe7b5027467760 Mon Sep 17 00:00:00 2001
From: Jesse Natalie <jenatali@microsoft.com>
Date: Fri, 17 Sep 2021 18:54:19 -0700
Subject: [PATCH 06/19] egl/wgl: Implement bind/release texture buffer

---
 src/egl/drivers/wgl/egl_wgl.c              | 58 ++++++++++++++++++++++
 src/gallium/targets/wgl/gallium_wgl.def.in |  1 +
 2 files changed, 59 insertions(+)

diff --git a/src/egl/drivers/wgl/egl_wgl.c b/src/egl/drivers/wgl/egl_wgl.c
index a6f938fbcb7c..d6832fe7a1a1 100644
--- a/src/egl/drivers/wgl/egl_wgl.c
+++ b/src/egl/drivers/wgl/egl_wgl.c
@@ -37,6 +37,7 @@
 #include <GL/wglext.h>
 
 #include <pipe/p_screen.h>
+#include <pipe/p_state.h>
 
 #include <mapi/glapi/glapi.h>
 
@@ -742,6 +743,61 @@ wgl_query_surface(_EGLDisplay *disp, _EGLSurface *surf,
    return _eglQuerySurface(disp, surf, attribute, value);
 }
 
+static EGLBoolean
+wgl_bind_tex_image(_EGLDisplay *disp, _EGLSurface *surf, EGLint buffer)
+{
+   struct wgl_egl_surface *wgl_surf = wgl_egl_surface(surf);
+   enum st_attachment_type target = ST_TEXTURE_2D;
+
+   _EGLContext *ctx = _eglGetCurrentContext();
+   struct wgl_egl_context *wgl_ctx = wgl_egl_context(ctx);
+
+   if (!_eglBindTexImage(disp, surf, buffer))
+      return EGL_FALSE;
+
+   struct pipe_resource *pres = stw_get_framebuffer_resource(wgl_surf->fb->stfb, ST_ATTACHMENT_FRONT_LEFT);
+   enum pipe_format format = pres->format;
+
+   switch (surf->TextureFormat) {
+   case EGL_TEXTURE_RGB:
+      switch (format) {
+      case PIPE_FORMAT_R16G16B16A16_FLOAT:
+         format = PIPE_FORMAT_R16G16B16X16_FLOAT;
+         break;
+      case PIPE_FORMAT_B10G10R10A2_UNORM:
+         format = PIPE_FORMAT_B10G10R10X2_UNORM;
+         break;
+      case PIPE_FORMAT_R10G10B10A2_UNORM:
+         format = PIPE_FORMAT_R10G10B10X2_UNORM;
+         break;
+      case PIPE_FORMAT_BGRA8888_UNORM:
+         format = PIPE_FORMAT_BGRX8888_UNORM;
+         break;
+      case PIPE_FORMAT_ARGB8888_UNORM:
+         format = PIPE_FORMAT_XRGB8888_UNORM;
+         break;
+      default:
+         break;
+      }
+      break;
+   case EGL_TEXTURE_RGBA:
+      break;
+   default:
+      assert(!"Unexpected texture format in wgl_bind_tex_image()");
+   }
+
+   switch (surf->TextureTarget) {
+   case EGL_TEXTURE_2D:
+      break;
+   default:
+      assert(!"Unexpected texture target in wgl_bind_tex_image()");
+   }
+
+   wgl_ctx->ctx->st->teximage(wgl_ctx->ctx->st, target, 0, format, pres, false);
+
+   return EGL_TRUE;
+}
+
 static EGLBoolean
 wgl_swap_buffers(_EGLDisplay *disp, _EGLSurface *draw)
 {
@@ -766,6 +822,8 @@ struct _egl_driver _eglDriver = {
    .CreatePbufferSurface = wgl_create_pbuffer_surface,
    .DestroySurface = wgl_destroy_surface,
    .QuerySurface = wgl_query_surface,
+   .BindTexImage = wgl_bind_tex_image,
+   .ReleaseTexImage = _eglReleaseTexImage,
    .GetProcAddress = _glapi_get_proc_address,
    .SwapBuffers = wgl_swap_buffers,
 };
diff --git a/src/gallium/targets/wgl/gallium_wgl.def.in b/src/gallium/targets/wgl/gallium_wgl.def.in
index 109016b4cc75..49e0963f727e 100644
--- a/src/gallium/targets/wgl/gallium_wgl.def.in
+++ b/src/gallium/targets/wgl/gallium_wgl.def.in
@@ -37,4 +37,5 @@ stw_framebuffer_create
 stw_framebuffer_release_locked
 stw_framebuffer_unlock
 stw_framebuffer_swap_locked
+stw_get_framebuffer_resource
 stw_pbuffer_create
-- 
GitLab


From 6e7465389bee7ac2b29303e7de77b16be6a0d673 Mon Sep 17 00:00:00 2001
From: Jesse Natalie <jenatali@microsoft.com>
Date: Mon, 20 Sep 2021 09:39:55 -0700
Subject: [PATCH 07/19] wgl: Allow per-framebuffer swap interval overrides

---
 src/gallium/frontends/wgl/stw_framebuffer.c       | 15 ++++++++++-----
 src/gallium/frontends/wgl/stw_framebuffer.h       |  1 +
 src/gallium/frontends/wgl/stw_winsys.h            |  3 ++-
 .../winsys/d3d12/wgl/d3d12_wgl_framebuffer.cpp    |  6 +++---
 4 files changed, 16 insertions(+), 9 deletions(-)

diff --git a/src/gallium/frontends/wgl/stw_framebuffer.c b/src/gallium/frontends/wgl/stw_framebuffer.c
index 0e4a7a77f812..762164b40d0c 100644
--- a/src/gallium/frontends/wgl/stw_framebuffer.c
+++ b/src/gallium/frontends/wgl/stw_framebuffer.c
@@ -302,6 +302,9 @@ stw_framebuffer_create(HWND hWnd, int iPixelFormat, enum stw_framebuffer_owner o
 
    fb->refcnt = 1;
 
+   /* A -1 means defer to the global stw_dev->swap_interval */
+   fb->swap_interval = -1;
+
    /*
     * Windows can be sometimes have zero width and or height, but we ensure
     * a non-zero framebuffer size at all times.
@@ -604,7 +607,8 @@ stw_framebuffer_present_locked(HDC hdc,
                                struct pipe_resource *res)
 {
    if (fb->winsys_framebuffer) {
-      BOOL result = fb->winsys_framebuffer->present(fb->winsys_framebuffer);
+      int interval = fb->swap_interval == -1 ? stw_dev->swap_interval : fb->swap_interval;
+      BOOL result = fb->winsys_framebuffer->present(fb->winsys_framebuffer, interval);
 
       stw_framebuffer_update(fb);
       stw_notify_current_locked(fb);
@@ -653,7 +657,7 @@ stw_framebuffer_present_locked(HDC hdc,
  * This is for the WGL_ARB_swap_interval extension.
  */
 static void
-wait_swap_interval(struct stw_framebuffer *fb)
+wait_swap_interval(struct stw_framebuffer *fb, int interval)
 {
    /* Note: all time variables here are in units of microseconds */
    int64_t cur_time = os_time_get_nano() / 1000;
@@ -662,7 +666,7 @@ wait_swap_interval(struct stw_framebuffer *fb)
       /* Compute time since previous swap */
       int64_t delta = cur_time - fb->prev_swap_time;
       int64_t min_swap_period =
-         1.0e6 / stw_dev->refresh_rate * stw_dev->swap_interval;
+         1.0e6 / stw_dev->refresh_rate * interval;
 
       /* If time since last swap is less than wait period, wait.
        * Note that it's possible for the delta to be negative because of
@@ -704,8 +708,9 @@ stw_framebuffer_swap_locked(HDC hdc, struct stw_framebuffer *fb)
       }
    }
 
-   if (stw_dev->swap_interval != 0 && !fb->winsys_framebuffer) {
-      wait_swap_interval(fb);
+   int interval = fb->swap_interval == -1 ? stw_dev->swap_interval : fb->swap_interval;
+   if (interval != 0 && !fb->winsys_framebuffer) {
+      wait_swap_interval(fb, interval);
    }
 
    return stw_st_swap_framebuffer_locked(hdc, ctx->st, fb->stfb);
diff --git a/src/gallium/frontends/wgl/stw_framebuffer.h b/src/gallium/frontends/wgl/stw_framebuffer.h
index db8a82a6851f..0d120f00b5de 100644
--- a/src/gallium/frontends/wgl/stw_framebuffer.h
+++ b/src/gallium/frontends/wgl/stw_framebuffer.h
@@ -129,6 +129,7 @@ struct stw_framebuffer
    struct stw_winsys_framebuffer *winsys_framebuffer;
 
    /* For WGL_EXT_swap_control */
+   int swap_interval;
    int64_t prev_swap_time;
 
    /** 
diff --git a/src/gallium/frontends/wgl/stw_winsys.h b/src/gallium/frontends/wgl/stw_winsys.h
index 66fb30eb8d4f..e46137d3cbb8 100644
--- a/src/gallium/frontends/wgl/stw_winsys.h
+++ b/src/gallium/frontends/wgl/stw_winsys.h
@@ -52,7 +52,8 @@ struct stw_winsys_framebuffer
               struct pipe_context *context);
 
    boolean
-   (*present)(struct stw_winsys_framebuffer *fb);
+   (*present)(struct stw_winsys_framebuffer *fb,
+              int interval);
 
    void
    (*resize)(struct stw_winsys_framebuffer *fb,
diff --git a/src/gallium/winsys/d3d12/wgl/d3d12_wgl_framebuffer.cpp b/src/gallium/winsys/d3d12/wgl/d3d12_wgl_framebuffer.cpp
index 90e9ec929429..226ce4836c0b 100644
--- a/src/gallium/winsys/d3d12/wgl/d3d12_wgl_framebuffer.cpp
+++ b/src/gallium/winsys/d3d12/wgl/d3d12_wgl_framebuffer.cpp
@@ -149,7 +149,7 @@ d3d12_wgl_framebuffer_resize(stw_winsys_framebuffer *fb,
 }
 
 static boolean
-d3d12_wgl_framebuffer_present(stw_winsys_framebuffer *fb)
+d3d12_wgl_framebuffer_present(stw_winsys_framebuffer *fb, int interval)
 {
    auto framebuffer = d3d12_wgl_framebuffer(fb);
    if (!framebuffer->swapchain) {
@@ -157,10 +157,10 @@ d3d12_wgl_framebuffer_present(stw_winsys_framebuffer *fb)
       return false;
    }
 
-   if (stw_dev->swap_interval < 1)
+   if (interval < 1)
       return S_OK == framebuffer->swapchain->Present(0, DXGI_PRESENT_ALLOW_TEARING);
    else
-       return S_OK == framebuffer->swapchain->Present(stw_dev->swap_interval, 0);
+      return S_OK == framebuffer->swapchain->Present(interval, 0);
 }
 
 static struct pipe_resource *
-- 
GitLab


From 53c3eb906c543ec2d319a86c0de468332fc671d8 Mon Sep 17 00:00:00 2001
From: Jesse Natalie <jenatali@microsoft.com>
Date: Mon, 20 Sep 2021 09:41:52 -0700
Subject: [PATCH 08/19] egl/wgl: Support eglSwapInterval

Note, eglSwapInterval spec says "The default swap interval is 1."
---
 src/egl/drivers/wgl/egl_wgl.c | 13 ++++++++++++-
 1 file changed, 12 insertions(+), 1 deletion(-)

diff --git a/src/egl/drivers/wgl/egl_wgl.c b/src/egl/drivers/wgl/egl_wgl.c
index d6832fe7a1a1..3e65308492eb 100644
--- a/src/egl/drivers/wgl/egl_wgl.c
+++ b/src/egl/drivers/wgl/egl_wgl.c
@@ -126,7 +126,7 @@ wgl_add_config(_EGLDisplay *disp, const struct stw_pixelformat_info *stw_config,
    base.Conformant = disp->ClientAPIs;
 
    base.MinSwapInterval = 0;
-   base.MaxSwapInterval = 1;
+   base.MaxSwapInterval = 4;
    base.YInvertedNOK = EGL_TRUE;
 
    if (!_eglValidateConfig(&base, EGL_FALSE)) {
@@ -689,6 +689,7 @@ wgl_create_window_surface(_EGLDisplay *disp, _EGLConfig *conf,
       return NULL;
    }
 
+   wgl_surf->fb->swap_interval = 1;
    stw_framebuffer_unlock(wgl_surf->fb);
 
    return &wgl_surf->base;
@@ -717,6 +718,7 @@ wgl_create_pbuffer_surface(_EGLDisplay *disp, _EGLConfig *conf,
       return NULL;
    }
 
+   wgl_surf->fb->swap_interval = 1;
    stw_framebuffer_unlock(wgl_surf->fb);
 
    return &wgl_surf->base;
@@ -798,6 +800,14 @@ wgl_bind_tex_image(_EGLDisplay *disp, _EGLSurface *surf, EGLint buffer)
    return EGL_TRUE;
 }
 
+static EGLBoolean
+wgl_swap_interval(_EGLDisplay *disp, _EGLSurface *surf, EGLint interval)
+{
+   struct wgl_egl_surface *wgl_surf = wgl_egl_surface(surf);
+   wgl_surf->fb->swap_interval = interval;
+   return EGL_TRUE;
+}
+
 static EGLBoolean
 wgl_swap_buffers(_EGLDisplay *disp, _EGLSurface *draw)
 {
@@ -825,6 +835,7 @@ struct _egl_driver _eglDriver = {
    .BindTexImage = wgl_bind_tex_image,
    .ReleaseTexImage = _eglReleaseTexImage,
    .GetProcAddress = _glapi_get_proc_address,
+   .SwapInterval = wgl_swap_interval,
    .SwapBuffers = wgl_swap_buffers,
 };
 
-- 
GitLab


From 5aa2c58a8b55be8ee8c47015accdc33e17afccae Mon Sep 17 00:00:00 2001
From: Jesse Natalie <jenatali@microsoft.com>
Date: Mon, 20 Sep 2021 09:49:48 -0700
Subject: [PATCH 09/19] egl/wgl: Support eglWaitClient

---
 src/egl/drivers/wgl/egl_wgl.c | 10 ++++++++++
 1 file changed, 10 insertions(+)

diff --git a/src/egl/drivers/wgl/egl_wgl.c b/src/egl/drivers/wgl/egl_wgl.c
index 3e65308492eb..f1d17be7c1a9 100644
--- a/src/egl/drivers/wgl/egl_wgl.c
+++ b/src/egl/drivers/wgl/egl_wgl.c
@@ -822,6 +822,15 @@ wgl_swap_buffers(_EGLDisplay *disp, _EGLSurface *draw)
    return ret;
 }
 
+static EGLBoolean
+wgl_wait_client(_EGLDisplay *disp, _EGLContext *ctx)
+{
+   struct wgl_egl_context *wgl_ctx = wgl_egl_context(ctx);
+   struct pipe_fence *fence = NULL;
+   wgl_ctx->ctx->st->flush(wgl_ctx->ctx->st, ST_FLUSH_END_OF_FRAME | ST_FLUSH_WAIT, &fence, NULL, NULL);
+   return EGL_TRUE;
+}
+
 struct _egl_driver _eglDriver = {
    .Initialize = wgl_initialize,
    .Terminate = wgl_terminate,
@@ -837,5 +846,6 @@ struct _egl_driver _eglDriver = {
    .GetProcAddress = _glapi_get_proc_address,
    .SwapInterval = wgl_swap_interval,
    .SwapBuffers = wgl_swap_buffers,
+   .WaitClient = wgl_wait_client,
 };
 
-- 
GitLab


From ffe3173f23d018056b8f17cd8568d424d30e517b Mon Sep 17 00:00:00 2001
From: Jesse Natalie <jenatali@microsoft.com>
Date: Mon, 20 Sep 2021 09:51:01 -0700
Subject: [PATCH 10/19] egl/wgl: Support eglWaitNative

---
 src/egl/drivers/wgl/egl_wgl.c | 11 +++++++++++
 1 file changed, 11 insertions(+)

diff --git a/src/egl/drivers/wgl/egl_wgl.c b/src/egl/drivers/wgl/egl_wgl.c
index f1d17be7c1a9..bf51429fb246 100644
--- a/src/egl/drivers/wgl/egl_wgl.c
+++ b/src/egl/drivers/wgl/egl_wgl.c
@@ -831,6 +831,16 @@ wgl_wait_client(_EGLDisplay *disp, _EGLContext *ctx)
    return EGL_TRUE;
 }
 
+static EGLBoolean
+wgl_wait_native(EGLint engine)
+{
+   if (engine != EGL_CORE_NATIVE_ENGINE)
+      return _eglError(EGL_BAD_PARAMETER, "eglWaitNative");
+   /* It's unclear what "native" means, but GDI is as good a guess as any */
+   GdiFlush();
+   return EGL_TRUE;
+}
+
 struct _egl_driver _eglDriver = {
    .Initialize = wgl_initialize,
    .Terminate = wgl_terminate,
@@ -847,5 +857,6 @@ struct _egl_driver _eglDriver = {
    .SwapInterval = wgl_swap_interval,
    .SwapBuffers = wgl_swap_buffers,
    .WaitClient = wgl_wait_client,
+   .WaitNative = wgl_wait_native,
 };
 
-- 
GitLab


From 1031316674325647d94ff397a04ac35e0363627a Mon Sep 17 00:00:00 2001
From: Jesse Natalie <jenatali@microsoft.com>
Date: Mon, 20 Sep 2021 15:24:19 -0700
Subject: [PATCH 11/19] egl,wgl: Support eglCreateImageKHR

---
 src/egl/drivers/wgl/egl_wgl.c              | 175 +++++++++++++++++++--
 src/egl/drivers/wgl/egl_wgl.h              |   8 +
 src/gallium/frontends/wgl/meson.build      |   1 +
 src/gallium/frontends/wgl/stw_context.h    |   2 +
 src/gallium/frontends/wgl/stw_image.c      | 135 ++++++++++++++++
 src/gallium/frontends/wgl/stw_image.h      |  57 +++++++
 src/gallium/targets/wgl/gallium_wgl.def.in |   3 +
 7 files changed, 368 insertions(+), 13 deletions(-)
 create mode 100644 src/gallium/frontends/wgl/stw_image.c
 create mode 100644 src/gallium/frontends/wgl/stw_image.h

diff --git a/src/egl/drivers/wgl/egl_wgl.c b/src/egl/drivers/wgl/egl_wgl.c
index bf51429fb246..d61aecdd883d 100644
--- a/src/egl/drivers/wgl/egl_wgl.c
+++ b/src/egl/drivers/wgl/egl_wgl.c
@@ -33,6 +33,7 @@
 #include <stw_pixelformat.h>
 #include <stw_context.h>
 #include <stw_framebuffer.h>
+#include <stw_image.h>
 
 #include <GL/wglext.h>
 
@@ -242,21 +243,12 @@ wgl_initialize_impl(_EGLDisplay *disp, HDC hdc)
       disp->Extensions.KHR_gl_colorspace = EGL_TRUE;
 
    disp->Extensions.KHR_create_context = EGL_TRUE;
-   disp->Extensions.KHR_reusable_sync = EGL_TRUE;
 
-#if 0
    disp->Extensions.KHR_image_base = EGL_TRUE;
    disp->Extensions.KHR_gl_renderbuffer_image = EGL_TRUE;
-   if (wgl_dpy->image->base.version >= 5 &&
-      wgl_dpy->image->createImageFromTexture) {
-      disp->Extensions.KHR_gl_texture_2D_image = EGL_TRUE;
-      disp->Extensions.KHR_gl_texture_cubemap_image = EGL_TRUE;
-
-      if (wgl_renderer_query_integer(wgl_dpy,
-         __wgl_RENDERER_HAS_TEXTURE_3D))
-         disp->Extensions.KHR_gl_texture_3D_image = EGL_TRUE;
-   }
-#endif
+   disp->Extensions.KHR_gl_texture_2D_image = EGL_TRUE;
+   disp->Extensions.KHR_gl_texture_cubemap_image = EGL_TRUE;
+   disp->Extensions.KHR_gl_texture_3D_image = EGL_TRUE;
 
    if (!wgl_add_configs(disp)) {
       err = "wgl: failed to add configs";
@@ -826,7 +818,7 @@ static EGLBoolean
 wgl_wait_client(_EGLDisplay *disp, _EGLContext *ctx)
 {
    struct wgl_egl_context *wgl_ctx = wgl_egl_context(ctx);
-   struct pipe_fence *fence = NULL;
+   struct pipe_fence_handle *fence = NULL;
    wgl_ctx->ctx->st->flush(wgl_ctx->ctx->st, ST_FLUSH_END_OF_FRAME | ST_FLUSH_WAIT, &fence, NULL, NULL);
    return EGL_TRUE;
 }
@@ -841,6 +833,161 @@ wgl_wait_native(EGLint engine)
    return EGL_TRUE;
 }
 
+static EGLint
+egl_error_from_stw_image_error(enum stw_image_error err)
+{
+   switch (err) {
+   case STW_IMAGE_ERROR_SUCCESS:
+      return EGL_SUCCESS;
+   case STW_IMAGE_ERROR_BAD_ALLOC:
+      return EGL_BAD_ALLOC;
+   case STW_IMAGE_ERROR_BAD_MATCH:
+      return EGL_BAD_MATCH;
+   case STW_IMAGE_ERROR_BAD_PARAMETER:
+      return EGL_BAD_PARAMETER;
+   case STW_IMAGE_ERROR_BAD_ACCESS:
+      return EGL_BAD_ACCESS;
+   default:
+      assert(!"unknown stw_image_error code");
+      return EGL_BAD_ALLOC;
+   }
+}
+
+static _EGLImage *
+wgl_create_image_khr_texture(_EGLDisplay *disp, _EGLContext *ctx,
+                                   EGLenum target,
+                                   EGLClientBuffer buffer,
+                                   const EGLint *attr_list)
+{
+   struct wgl_egl_context *wgl_ctx = wgl_egl_context(ctx);
+   struct wgl_egl_image *wgl_img;
+   GLuint texture = (GLuint) (uintptr_t) buffer;
+   _EGLImageAttribs attrs;
+   GLuint depth;
+   GLenum gl_target;
+   enum stw_image_error error;
+
+   if (texture == 0) {
+      _eglError(EGL_BAD_PARAMETER, "wgl_create_image_khr");
+      return EGL_NO_IMAGE_KHR;
+   }
+
+   if (!_eglParseImageAttribList(&attrs, disp, attr_list))
+      return EGL_NO_IMAGE_KHR;
+
+   switch (target) {
+   case EGL_GL_TEXTURE_2D_KHR:
+      depth = 0;
+      gl_target = GL_TEXTURE_2D;
+      break;
+   case EGL_GL_TEXTURE_3D_KHR:
+      depth = attrs.GLTextureZOffset;
+      gl_target = GL_TEXTURE_3D;
+      break;
+   case EGL_GL_TEXTURE_CUBE_MAP_POSITIVE_X_KHR:
+   case EGL_GL_TEXTURE_CUBE_MAP_NEGATIVE_X_KHR:
+   case EGL_GL_TEXTURE_CUBE_MAP_POSITIVE_Y_KHR:
+   case EGL_GL_TEXTURE_CUBE_MAP_NEGATIVE_Y_KHR:
+   case EGL_GL_TEXTURE_CUBE_MAP_POSITIVE_Z_KHR:
+   case EGL_GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_KHR:
+      depth = target - EGL_GL_TEXTURE_CUBE_MAP_POSITIVE_X_KHR;
+      gl_target = GL_TEXTURE_CUBE_MAP;
+      break;
+   default:
+      unreachable("Unexpected target in wgl_create_image_khr_texture()");
+      return EGL_NO_IMAGE_KHR;
+   }
+
+   wgl_img = malloc(sizeof *wgl_img);
+   if (!wgl_img) {
+      _eglError(EGL_BAD_ALLOC, "wgl_create_image_khr");
+      return EGL_NO_IMAGE_KHR;
+   }
+
+   _eglInitImage(&wgl_img->base, disp);
+
+   wgl_img->img = stw_create_image_from_texture(wgl_ctx->ctx,
+                                                gl_target,
+                                                texture,
+                                                depth,
+                                                attrs.GLTextureLevel,
+                                                &error);
+   assert(!!wgl_img->img == (error == STW_IMAGE_ERROR_SUCCESS));
+
+   if (!wgl_img->img) {
+      free(wgl_img);
+      _eglError(egl_error_from_stw_image_error(error), "wgl_create_image_khr");
+      return EGL_NO_IMAGE_KHR;
+   }
+   return &wgl_img->base;
+}
+
+static _EGLImage *
+wgl_create_image_khr_renderbuffer(_EGLDisplay *disp, _EGLContext *ctx,
+                                   EGLClientBuffer buffer,
+                                   const EGLint *attr_list)
+{
+   struct wgl_egl_context *wgl_ctx = wgl_egl_context(ctx);
+   struct wgl_egl_image *wgl_img;
+   GLuint renderbuffer = (GLuint) (uintptr_t) buffer;
+   enum stw_image_error error;
+
+   if (renderbuffer == 0) {
+      _eglError(EGL_BAD_PARAMETER, "wgl_create_image_khr");
+      return EGL_NO_IMAGE_KHR;
+   }
+
+   wgl_img = malloc(sizeof * wgl_img);
+   if (!wgl_img) {
+      _eglError(EGL_BAD_ALLOC, "wgl_create_image");
+      return NULL;
+   }
+
+   _eglInitImage(&wgl_img->base, disp);
+
+   wgl_img->img = stw_create_image_from_renderbuffer(wgl_ctx->ctx, renderbuffer, &error);
+   assert(!!wgl_img->img == (error == STW_IMAGE_ERROR_SUCCESS));
+
+   if (!wgl_img->img) {
+      free(wgl_img);
+      _eglError(egl_error_from_stw_image_error(error), "wgl_create_image_khr");
+      return EGL_NO_IMAGE_KHR;
+   }
+
+   return &wgl_img->base;
+}
+
+static _EGLImage *
+wgl_create_image_khr(_EGLDisplay *disp, _EGLContext *ctx, EGLenum target,
+                      EGLClientBuffer buffer, const EGLint *attr_list)
+{
+   switch (target) {
+   case EGL_GL_TEXTURE_2D_KHR:
+   case EGL_GL_TEXTURE_CUBE_MAP_POSITIVE_X_KHR:
+   case EGL_GL_TEXTURE_CUBE_MAP_NEGATIVE_X_KHR:
+   case EGL_GL_TEXTURE_CUBE_MAP_POSITIVE_Y_KHR:
+   case EGL_GL_TEXTURE_CUBE_MAP_NEGATIVE_Y_KHR:
+   case EGL_GL_TEXTURE_CUBE_MAP_POSITIVE_Z_KHR:
+   case EGL_GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_KHR:
+   case EGL_GL_TEXTURE_3D_KHR:
+      return wgl_create_image_khr_texture(disp, ctx, target, buffer, attr_list);
+   case EGL_GL_RENDERBUFFER_KHR:
+      return wgl_create_image_khr_renderbuffer(disp, ctx, buffer, attr_list);
+   default:
+      _eglError(EGL_BAD_PARAMETER, "wgl_create_image_khr");
+      return EGL_NO_IMAGE_KHR;
+   }
+}
+
+static EGLBoolean
+wgl_destroy_image_khr(_EGLDisplay *disp, _EGLImage *img)
+{
+   struct wgl_egl_image *wgl_img = wgl_egl_image(img);
+   stw_destroy_image(wgl_img->img);
+   free(wgl_img);
+   return EGL_TRUE;
+}
+
 struct _egl_driver _eglDriver = {
    .Initialize = wgl_initialize,
    .Terminate = wgl_terminate,
@@ -858,5 +1005,7 @@ struct _egl_driver _eglDriver = {
    .SwapBuffers = wgl_swap_buffers,
    .WaitClient = wgl_wait_client,
    .WaitNative = wgl_wait_native,
+   .CreateImageKHR = wgl_create_image_khr,
+   .DestroyImageKHR = wgl_destroy_image_khr,
 };
 
diff --git a/src/egl/drivers/wgl/egl_wgl.h b/src/egl/drivers/wgl/egl_wgl.h
index d7bb68daf647..7fd5408d1b3b 100644
--- a/src/egl/drivers/wgl/egl_wgl.h
+++ b/src/egl/drivers/wgl/egl_wgl.h
@@ -26,6 +26,7 @@
 #include <egldriver.h>
 #include <egldisplay.h>
 #include <eglconfig.h>
+#include <eglimage.h>
 
 #include <stw_pixelformat.h>
 #include <windows.h>
@@ -54,4 +55,11 @@ struct wgl_egl_surface
    struct stw_framebuffer *fb;
 };
 
+struct wgl_egl_image
+{
+   _EGLImage base;
+   struct stw_image *img;
+};
+
 _EGL_DRIVER_STANDARD_TYPECASTS(wgl_egl)
+_EGL_DRIVER_TYPECAST(wgl_egl_image, _EGLImage, obj)
diff --git a/src/gallium/frontends/wgl/meson.build b/src/gallium/frontends/wgl/meson.build
index 0e75e510f73c..340e9cf0dd9d 100644
--- a/src/gallium/frontends/wgl/meson.build
+++ b/src/gallium/frontends/wgl/meson.build
@@ -38,6 +38,7 @@ libwgl = static_library(
     'stw_ext_swapinterval.c',
     'stw_framebuffer.c',
     'stw_getprocaddress.c',
+    'stw_image.c',
     'stw_nopfuncs.c',
     'stw_nopfuncs.h',
     'stw_pixelformat.c',
diff --git a/src/gallium/frontends/wgl/stw_context.h b/src/gallium/frontends/wgl/stw_context.h
index caf3efa4ffa0..170cd7def196 100644
--- a/src/gallium/frontends/wgl/stw_context.h
+++ b/src/gallium/frontends/wgl/stw_context.h
@@ -29,6 +29,8 @@
 #define STW_CONTEXT_H
 
 #include <windows.h>
+#include <GL/gl.h>
+#include <gldrv.h>
 
 struct hud_context;
 struct stw_framebuffer;
diff --git a/src/gallium/frontends/wgl/stw_image.c b/src/gallium/frontends/wgl/stw_image.c
new file mode 100644
index 000000000000..cedd8d25c29b
--- /dev/null
+++ b/src/gallium/frontends/wgl/stw_image.c
@@ -0,0 +1,135 @@
+/*
+ * Copyright © Microsoft Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+#include "stw_image.h"
+#include <pipe/p_state.h>
+#include <util/u_inlines.h>
+#include <frontend/api.h>
+
+#include <main/mtypes.h>
+#include <main/texobj.h>
+#include <state_tracker/st_context.h>
+#include <state_tracker/st_texture.h>
+
+struct stw_image *
+stw_create_image_from_texture(struct stw_context *ctx, GLenum gl_target, GLuint texture,
+                              GLuint depth, GLint level, enum stw_image_error *error)
+{
+   struct st_context *st_ctx = (struct st_context *)ctx->st;
+   struct gl_context *gl_ctx = st_ctx->ctx;
+   struct gl_texture_object *obj;
+   struct pipe_resource *tex;
+   GLuint face = 0;
+
+   obj = _mesa_lookup_texture(gl_ctx, texture);
+   if (!obj || obj->Target != gl_target) {
+      *error = STW_IMAGE_ERROR_BAD_PARAMETER;
+      return NULL;
+   }
+
+   tex = st_get_texobj_resource(obj);
+   if (!tex) {
+      *error = STW_IMAGE_ERROR_BAD_PARAMETER;
+      return NULL;
+   }
+
+   if (gl_target == GL_TEXTURE_CUBE_MAP)
+      face = depth;
+
+   _mesa_test_texobj_completeness(gl_ctx, obj);
+   if (!obj->_BaseComplete || (level > 0 && !obj->_MipmapComplete)) {
+      *error = STW_IMAGE_ERROR_BAD_PARAMETER;
+      return NULL;
+   }
+
+   if (level < obj->Attrib.BaseLevel || level > obj->_MaxLevel) {
+      *error = STW_IMAGE_ERROR_BAD_MATCH;
+      return NULL;
+   }
+
+   if (gl_target == GL_TEXTURE_3D && obj->Image[face][level]->Depth < depth) {
+      *error = STW_IMAGE_ERROR_BAD_MATCH;
+      return NULL;
+   }
+
+   struct stw_image *ret = calloc(1, sizeof(struct stw_image));
+   pipe_resource_reference(&ret->pres, tex);
+   ret->level = level;
+   ret->layer = depth;
+   ret->format = tex->format;
+
+   gl_ctx->Shared->HasExternallySharedImages = true;
+   *error = STW_IMAGE_ERROR_SUCCESS;
+   return ret;
+}
+
+struct stw_image *
+stw_create_image_from_renderbuffer(struct stw_context *ctx, GLuint renderbuffer,
+                                   enum stw_image_error *error)
+{
+   struct st_context *st_ctx = (struct st_context *)ctx->st;
+   struct gl_context *gl_ctx = st_ctx->ctx;
+   struct gl_renderbuffer *rb;
+   struct pipe_resource *tex;
+
+   /* Section 3.9 (EGLImage Specification and Management) of the EGL 1.5
+    * specification says:
+    *
+    *   "If target is EGL_GL_RENDERBUFFER and buffer is not the name of a
+    *    renderbuffer object, or if buffer is the name of a multisampled
+    *    renderbuffer object, the error EGL_BAD_PARAMETER is generated."
+    *
+    *   "If target is EGL_GL_TEXTURE_2D , EGL_GL_TEXTURE_CUBE_MAP_*,
+    *    EGL_GL_RENDERBUFFER or EGL_GL_TEXTURE_3D and buffer refers to the
+    *    default GL texture object (0) for the corresponding GL target, the
+    *    error EGL_BAD_PARAMETER is generated."
+    *   (rely on _mesa_lookup_renderbuffer returning NULL in this case)
+    */
+   rb = _mesa_lookup_renderbuffer(gl_ctx, renderbuffer);
+   if (!rb || rb->NumSamples > 0) {
+      *error = STW_IMAGE_ERROR_BAD_PARAMETER;
+      return NULL;
+   }
+
+   tex = rb->texture;
+   if (!tex) {
+      *error = STW_IMAGE_ERROR_BAD_PARAMETER;
+      return NULL;
+   }
+
+   struct stw_image *ret = calloc(1, sizeof(struct stw_image));
+   pipe_resource_reference(&ret->pres, tex);
+   ret->format = tex->format;
+
+   gl_ctx->Shared->HasExternallySharedImages = true;
+   *error = STW_IMAGE_ERROR_SUCCESS;
+   return ret;
+}
+
+void
+stw_destroy_image(struct stw_image *img)
+{
+   pipe_resource_reference(&img->pres, NULL);
+   free(img);
+}
+
diff --git a/src/gallium/frontends/wgl/stw_image.h b/src/gallium/frontends/wgl/stw_image.h
new file mode 100644
index 000000000000..2a1e04bcd16e
--- /dev/null
+++ b/src/gallium/frontends/wgl/stw_image.h
@@ -0,0 +1,57 @@
+/*
+ * Copyright © Microsoft Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+#pragma once
+
+#include <pipe/p_state.h>
+#include "stw_context.h"
+
+#include <GL/gl.h>
+
+enum stw_image_error
+{
+   STW_IMAGE_ERROR_SUCCESS,
+   STW_IMAGE_ERROR_BAD_ALLOC,
+   STW_IMAGE_ERROR_BAD_PARAMETER,
+   STW_IMAGE_ERROR_BAD_MATCH,
+   STW_IMAGE_ERROR_BAD_ACCESS,
+};
+
+struct stw_image
+{
+   struct pipe_resource *pres;
+   unsigned level;
+   unsigned layer;
+   enum pipe_format format;
+};
+
+struct stw_image *
+stw_create_image_from_texture(struct stw_context *ctx, GLenum gl_target, GLuint texture,
+                              GLuint depth, GLint level, enum stw_image_error *error);
+
+struct stw_image *
+stw_create_image_from_renderbuffer(struct stw_context *ctx, GLuint renderbuffer,
+                                   enum stw_image_error *error);
+
+void
+stw_destroy_image(struct stw_image *img);
diff --git a/src/gallium/targets/wgl/gallium_wgl.def.in b/src/gallium/targets/wgl/gallium_wgl.def.in
index 49e0963f727e..76b93264382d 100644
--- a/src/gallium/targets/wgl/gallium_wgl.def.in
+++ b/src/gallium/targets/wgl/gallium_wgl.def.in
@@ -39,3 +39,6 @@ stw_framebuffer_unlock
 stw_framebuffer_swap_locked
 stw_get_framebuffer_resource
 stw_pbuffer_create
+stw_create_image_from_texture
+stw_create_image_from_renderbuffer
+stw_destroy_image
-- 
GitLab


From 17c51176ca692b59d3b5f1d96718fb80f1ae4ed5 Mon Sep 17 00:00:00 2001
From: Jesse Natalie <jenatali@microsoft.com>
Date: Tue, 21 Sep 2021 08:39:23 -0700
Subject: [PATCH 12/19] wgl: Pass smapi explicitly to context creation

---
 src/egl/drivers/wgl/egl_wgl.c               | 5 ++++-
 src/egl/drivers/wgl/egl_wgl.h               | 1 +
 src/gallium/frontends/wgl/stw_context.c     | 8 ++++++--
 src/gallium/frontends/wgl/stw_context.h     | 2 ++
 src/gallium/frontends/wgl/stw_ext_context.c | 4 ++++
 5 files changed, 17 insertions(+), 3 deletions(-)

diff --git a/src/egl/drivers/wgl/egl_wgl.c b/src/egl/drivers/wgl/egl_wgl.c
index d61aecdd883d..f79fb80badac 100644
--- a/src/egl/drivers/wgl/egl_wgl.c
+++ b/src/egl/drivers/wgl/egl_wgl.c
@@ -218,7 +218,9 @@ wgl_initialize_impl(_EGLDisplay *disp, HDC hdc)
       goto cleanup;
    }
 
-   wgl_dpy->screen = stw_get_device()->screen;
+   struct stw_device *stw_dev = stw_get_device();
+   wgl_dpy->screen = stw_dev->screen;
+   wgl_dpy->smapi = stw_dev->smapi;
 
    disp->ClientAPIs = 0;
    if (_eglIsApiValid(EGL_OPENGL_API))
@@ -443,6 +445,7 @@ wgl_create_context(_EGLDisplay *disp, _EGLConfig *conf,
    if (wgl_ctx->base.ResetNotificationStrategy != EGL_NO_RESET_NOTIFICATION)
       resetStrategy = WGL_LOSE_CONTEXT_ON_RESET_ARB;
    wgl_ctx->ctx = stw_create_context_attribs(disp->PlatformDisplay, 0, shared,
+      wgl_dpy->smapi,
       wgl_ctx->base.ClientMajorVersion,
       wgl_ctx->base.ClientMinorVersion,
       flags,
diff --git a/src/egl/drivers/wgl/egl_wgl.h b/src/egl/drivers/wgl/egl_wgl.h
index 7fd5408d1b3b..8c572b613534 100644
--- a/src/egl/drivers/wgl/egl_wgl.h
+++ b/src/egl/drivers/wgl/egl_wgl.h
@@ -35,6 +35,7 @@ struct wgl_egl_display
 {
    int ref_count;
    struct pipe_screen *screen;
+   struct st_manager *smapi;
 };
 
 struct wgl_egl_config
diff --git a/src/gallium/frontends/wgl/stw_context.c b/src/gallium/frontends/wgl/stw_context.c
index 5fa0ca31fc99..85dcf6cfb844 100644
--- a/src/gallium/frontends/wgl/stw_context.c
+++ b/src/gallium/frontends/wgl/stw_context.c
@@ -126,7 +126,10 @@ DrvCreateContext(HDC hdc)
 DHGLRC APIENTRY
 DrvCreateLayerContext(HDC hdc, INT iLayerPlane)
 {
-   struct stw_context *ctx = stw_create_context_attribs(hdc, iLayerPlane, 0, 1, 0, 0,
+   if (!stw_dev)
+      return 0;
+
+   struct stw_context *ctx = stw_create_context_attribs(hdc, iLayerPlane, NULL, stw_dev->smapi, 1, 0, 0,
                                                         WGL_CONTEXT_COMPATIBILITY_PROFILE_BIT_ARB,
                                                         0, WGL_NO_RESET_NOTIFICATION_ARB);
    if (!ctx)
@@ -165,6 +168,7 @@ get_matching_pixel_format(HDC hdc)
  */
 struct stw_context *
 stw_create_context_attribs(HDC hdc, INT iLayerPlane, struct stw_context *shareCtx,
+                           struct st_manager *smapi,
                            int majorVersion, int minorVersion,
                            int contextFlags, int profileMask,
                            int iPixelFormat, int resetStrategy)
@@ -279,7 +283,7 @@ stw_create_context_attribs(HDC hdc, INT iLayerPlane, struct stw_context *shareCt
    attribs.options = stw_dev->st_options;
 
    ctx->st = stw_dev->stapi->create_context(stw_dev->stapi,
-         stw_dev->smapi, &attribs, &ctx_err, shareCtx ? shareCtx->st : NULL);
+         smapi, &attribs, &ctx_err, shareCtx ? shareCtx->st : NULL);
    if (ctx->st == NULL)
       goto no_st_ctx;
 
diff --git a/src/gallium/frontends/wgl/stw_context.h b/src/gallium/frontends/wgl/stw_context.h
index 170cd7def196..5f4096f362c4 100644
--- a/src/gallium/frontends/wgl/stw_context.h
+++ b/src/gallium/frontends/wgl/stw_context.h
@@ -35,6 +35,7 @@
 struct hud_context;
 struct stw_framebuffer;
 struct st_context_iface;
+struct st_manager;
 
 struct stw_context
 {
@@ -53,6 +54,7 @@ struct stw_context
 
 struct stw_context *stw_create_context_attribs(HDC hdc, INT iLayerPlane,
                                                struct stw_context *shareCtx,
+                                               struct st_manager *smapi,
                                                int majorVersion, int minorVersion,
                                                int contextFlags, int profileMask,
                                                int iPixelFormat, int resetStrategy);
diff --git a/src/gallium/frontends/wgl/stw_ext_context.c b/src/gallium/frontends/wgl/stw_ext_context.c
index 44161f948a65..2156726f3390 100644
--- a/src/gallium/frontends/wgl/stw_ext_context.c
+++ b/src/gallium/frontends/wgl/stw_ext_context.c
@@ -83,6 +83,9 @@ wglCreateContextAttribsARB(HDC hDC, HGLRC hShareContext, const int *attribList)
                                 WGL_CONTEXT_FORWARD_COMPATIBLE_BIT_ARB |
                                 WGL_CONTEXT_ROBUST_ACCESS_BIT_ARB);
 
+   if (!stw_dev)
+      return NULL;
+
    /* parse attrib_list */
    if (attribList) {
       for (i = 0; !done && attribList[i]; i++) {
@@ -211,6 +214,7 @@ wglCreateContextAttribsARB(HDC hDC, HGLRC hShareContext, const int *attribList)
       struct stw_context *share_stw = stw_lookup_context(share_dhglrc);
 
       struct stw_context *stw_ctx = stw_create_context_attribs(hDC, layerPlane, share_stw,
+                                                               stw_dev->smapi,
                                                                majorVersion, minorVersion,
                                                                contextFlags, profileMask, 0,
                                                                resetStrategy);
-- 
GitLab


From 153a16fafe165d0522d570e60f4798962b6f97c1 Mon Sep 17 00:00:00 2001
From: Jesse Natalie <jenatali@microsoft.com>
Date: Tue, 21 Sep 2021 08:45:04 -0700
Subject: [PATCH 13/19] wgl: Pass smapi explicitly to framebuffer creation

---
 src/egl/drivers/wgl/egl_wgl.c               | 6 ++++--
 src/gallium/frontends/wgl/stw_context.c     | 2 +-
 src/gallium/frontends/wgl/stw_ext_pbuffer.c | 6 +++---
 src/gallium/frontends/wgl/stw_framebuffer.c | 7 ++++---
 src/gallium/frontends/wgl/stw_framebuffer.h | 6 ++++--
 src/gallium/frontends/wgl/stw_st.c          | 4 ++--
 src/gallium/frontends/wgl/stw_st.h          | 2 +-
 7 files changed, 19 insertions(+), 14 deletions(-)

diff --git a/src/egl/drivers/wgl/egl_wgl.c b/src/egl/drivers/wgl/egl_wgl.c
index f79fb80badac..350491ae7c74 100644
--- a/src/egl/drivers/wgl/egl_wgl.c
+++ b/src/egl/drivers/wgl/egl_wgl.c
@@ -665,6 +665,7 @@ static _EGLSurface*
 wgl_create_window_surface(_EGLDisplay *disp, _EGLConfig *conf,
                           void *native_window, const EGLint *attrib_list)
 {
+   struct wgl_egl_display *wgl_dpy = wgl_egl_display(disp);
    struct wgl_egl_config *wgl_conf = wgl_egl_config(conf);
 
    struct wgl_egl_surface *wgl_surf = calloc(1, sizeof(*wgl_surf));
@@ -678,7 +679,7 @@ wgl_create_window_surface(_EGLDisplay *disp, _EGLConfig *conf,
 
    const struct stw_pixelformat_info *stw_conf = wgl_conf->stw_config[1] ?
       wgl_conf->stw_config[1] : wgl_conf->stw_config[0];
-   wgl_surf->fb = stw_framebuffer_create(native_window, stw_conf->iPixelFormat, STW_FRAMEBUFFER_EGL_WINDOW);
+   wgl_surf->fb = stw_framebuffer_create(native_window, stw_conf->iPixelFormat, STW_FRAMEBUFFER_EGL_WINDOW, wgl_dpy->smapi);
    if (!wgl_surf->fb) {
       free(wgl_surf);
       return NULL;
@@ -694,6 +695,7 @@ static _EGLSurface*
 wgl_create_pbuffer_surface(_EGLDisplay *disp, _EGLConfig *conf,
                            const EGLint *attrib_list)
 {
+   struct wgl_egl_display *wgl_dpy = wgl_egl_display(disp);
    struct wgl_egl_config *wgl_conf = wgl_egl_config(conf);
 
    struct wgl_egl_surface *wgl_surf = calloc(1, sizeof(*wgl_surf));
@@ -707,7 +709,7 @@ wgl_create_pbuffer_surface(_EGLDisplay *disp, _EGLConfig *conf,
 
    const struct stw_pixelformat_info *stw_conf = wgl_conf->stw_config[1] ?
       wgl_conf->stw_config[1] : wgl_conf->stw_config[0];
-   wgl_surf->fb = stw_pbuffer_create(stw_conf->iPixelFormat, wgl_surf->base.Width, wgl_surf->base.Height);
+   wgl_surf->fb = stw_pbuffer_create(stw_conf->iPixelFormat, wgl_surf->base.Width, wgl_surf->base.Height, wgl_dpy->smapi);
    if (!wgl_surf->fb) {
       free(wgl_surf);
       return NULL;
diff --git a/src/gallium/frontends/wgl/stw_context.c b/src/gallium/frontends/wgl/stw_context.c
index 85dcf6cfb844..78a5396df9b0 100644
--- a/src/gallium/frontends/wgl/stw_context.c
+++ b/src/gallium/frontends/wgl/stw_context.c
@@ -579,7 +579,7 @@ get_unlocked_refd_framebuffer_from_dc(HDC hDC)
        */
       int iPixelFormat = get_matching_pixel_format(hDC);
       if (iPixelFormat)
-         fb = stw_framebuffer_create(WindowFromDC(hDC), iPixelFormat, STW_FRAMEBUFFER_WGL_WINDOW);
+         fb = stw_framebuffer_create(WindowFromDC(hDC), iPixelFormat, STW_FRAMEBUFFER_WGL_WINDOW, stw_dev->smapi);
       if (!fb)
          return NULL;
    }
diff --git a/src/gallium/frontends/wgl/stw_ext_pbuffer.c b/src/gallium/frontends/wgl/stw_ext_pbuffer.c
index 824ce000ce83..f06139130226 100644
--- a/src/gallium/frontends/wgl/stw_ext_pbuffer.c
+++ b/src/gallium/frontends/wgl/stw_ext_pbuffer.c
@@ -66,7 +66,7 @@ WndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
 }
 
 struct stw_framebuffer *
-stw_pbuffer_create(int iPixelFormat, int iWidth, int iHeight)
+stw_pbuffer_create(int iPixelFormat, int iWidth, int iHeight, struct st_manager *smapi)
 {
    static boolean first = TRUE;
 
@@ -143,7 +143,7 @@ stw_pbuffer_create(int iPixelFormat, int iWidth, int iHeight)
    assert(rect.bottom - rect.top == iHeight);
 #endif
 
-   return stw_framebuffer_create(hWnd, iPixelFormat, STW_FRAMEBUFFER_PBUFFER);
+   return stw_framebuffer_create(hWnd, iPixelFormat, STW_FRAMEBUFFER_PBUFFER, smapi);
 }
 
 
@@ -241,7 +241,7 @@ wglCreatePbufferARB(HDC hCurrentDC,
     * We can't pass non-displayable pixel formats to GDI, which is why we
     * create the framebuffer object before calling SetPixelFormat().
     */
-   fb = stw_pbuffer_create(iPixelFormat, iWidth, iHeight);
+   fb = stw_pbuffer_create(iPixelFormat, iWidth, iHeight, stw_dev->smapi);
    if (!fb) {
       SetLastError(ERROR_NO_SYSTEM_RESOURCES);
       return NULL;
diff --git a/src/gallium/frontends/wgl/stw_framebuffer.c b/src/gallium/frontends/wgl/stw_framebuffer.c
index 762164b40d0c..768f2fa7e1f9 100644
--- a/src/gallium/frontends/wgl/stw_framebuffer.c
+++ b/src/gallium/frontends/wgl/stw_framebuffer.c
@@ -269,7 +269,8 @@ stw_call_window_proc(int nCode, WPARAM wParam, LPARAM lParam)
  * with its mutex locked.
  */
 struct stw_framebuffer *
-stw_framebuffer_create(HWND hWnd, int iPixelFormat, enum stw_framebuffer_owner owner)
+stw_framebuffer_create(HWND hWnd, int iPixelFormat, enum stw_framebuffer_owner owner,
+                       struct st_manager *smapi)
 {
    struct stw_framebuffer *fb;
    const struct stw_pixelformat_info *pfi;
@@ -294,7 +295,7 @@ stw_framebuffer_create(HWND hWnd, int iPixelFormat, enum stw_framebuffer_owner o
    fb->owner = owner;
 
    fb->pfi = pfi = stw_pixelformat_get_info( iPixelFormat );
-   fb->stfb = stw_st_create_framebuffer( fb );
+   fb->stfb = stw_st_create_framebuffer( fb, smapi );
    if (!fb->stfb) {
       FREE( fb );
       return NULL;
@@ -498,7 +499,7 @@ DrvSetPixelFormat(HDC hdc, LONG iPixelFormat)
       return bPbuffer;
    }
 
-   fb = stw_framebuffer_create(WindowFromDC(hdc), iPixelFormat, STW_FRAMEBUFFER_WGL_WINDOW);
+   fb = stw_framebuffer_create(WindowFromDC(hdc), iPixelFormat, STW_FRAMEBUFFER_WGL_WINDOW, stw_dev->smapi);
    if (!fb) {
       return FALSE;
    }
diff --git a/src/gallium/frontends/wgl/stw_framebuffer.h b/src/gallium/frontends/wgl/stw_framebuffer.h
index 0d120f00b5de..de45f340fee7 100644
--- a/src/gallium/frontends/wgl/stw_framebuffer.h
+++ b/src/gallium/frontends/wgl/stw_framebuffer.h
@@ -40,6 +40,7 @@
 struct pipe_resource;
 struct st_framebuffer_iface;
 struct stw_pixelformat_info;
+struct st_manager;
 
 enum stw_framebuffer_owner
 {
@@ -153,10 +154,11 @@ struct stw_framebuffer
  * must be called when done 
  */
 struct stw_framebuffer *
-stw_framebuffer_create(HWND hwnd, int iPixelFormat, enum stw_framebuffer_owner owner);
+stw_framebuffer_create(HWND hwnd, int iPixelFormat, enum stw_framebuffer_owner owner,
+                       struct st_manager *smapi);
 
 struct stw_framebuffer *
-stw_pbuffer_create(int iPixelFormat, int iWidth, int iHeight);
+stw_pbuffer_create(int iPixelFormat, int iWidth, int iHeight, struct st_manager *smapi);
 
 
 /**
diff --git a/src/gallium/frontends/wgl/stw_st.c b/src/gallium/frontends/wgl/stw_st.c
index 7050a4e24b98..bd510a8f7ac3 100644
--- a/src/gallium/frontends/wgl/stw_st.c
+++ b/src/gallium/frontends/wgl/stw_st.c
@@ -494,7 +494,7 @@ stw_st_framebuffer_flush_front(struct st_context_iface *stctx,
  * Create a framebuffer interface.
  */
 struct st_framebuffer_iface *
-stw_st_create_framebuffer(struct stw_framebuffer *fb)
+stw_st_create_framebuffer(struct stw_framebuffer *fb, struct st_manager *smapi)
 {
    struct stw_st_framebuffer *stwfb;
 
@@ -505,7 +505,7 @@ stw_st_create_framebuffer(struct stw_framebuffer *fb)
    stwfb->fb = fb;
    stwfb->stvis = fb->pfi->stvis;
    stwfb->base.ID = p_atomic_inc_return(&stwfb_ID);
-   stwfb->base.state_manager = stw_dev->smapi;
+   stwfb->base.state_manager = smapi;
 
    stwfb->base.visual = &stwfb->stvis;
    p_atomic_set(&stwfb->base.stamp, 1);
diff --git a/src/gallium/frontends/wgl/stw_st.h b/src/gallium/frontends/wgl/stw_st.h
index c4d735663e67..7a2b72ed8e2e 100644
--- a/src/gallium/frontends/wgl/stw_st.h
+++ b/src/gallium/frontends/wgl/stw_st.h
@@ -41,7 +41,7 @@ struct st_api *
 stw_st_create_api(void);
 
 struct st_framebuffer_iface *
-stw_st_create_framebuffer(struct stw_framebuffer *fb);
+stw_st_create_framebuffer(struct stw_framebuffer *fb, struct st_manager *smapi);
 
 void
 stw_st_destroy_framebuffer_locked(struct st_framebuffer_iface *stfb);
-- 
GitLab


From 7a86df298f0d05d8f1a4397f0a7e8a8730a2b89a Mon Sep 17 00:00:00 2001
From: Jesse Natalie <jenatali@microsoft.com>
Date: Tue, 21 Sep 2021 09:00:29 -0700
Subject: [PATCH 14/19] egl/wgl: Use a per-display st_manager

---
 src/egl/drivers/wgl/egl_wgl.c | 23 ++++++++++++++++++-----
 src/egl/drivers/wgl/egl_wgl.h |  3 ++-
 2 files changed, 20 insertions(+), 6 deletions(-)

diff --git a/src/egl/drivers/wgl/egl_wgl.c b/src/egl/drivers/wgl/egl_wgl.c
index 350491ae7c74..2da33c20a4c5 100644
--- a/src/egl/drivers/wgl/egl_wgl.c
+++ b/src/egl/drivers/wgl/egl_wgl.c
@@ -198,7 +198,17 @@ wgl_add_configs(_EGLDisplay *disp)
 static void
 wgl_display_destroy(_EGLDisplay *disp)
 {
-   free(disp);
+   struct wgl_egl_display *wgl_dpy = wgl_egl_display(disp);
+   if (wgl_dpy->base.destroy)
+      wgl_dpy->base.destroy(&wgl_dpy->base);
+   free(wgl_dpy);
+}
+
+static int
+wgl_egl_st_get_param(struct st_manager *smapi, enum st_manager_param param)
+{
+   /* no-op */
+   return 0;
 }
 
 static EGLBoolean
@@ -212,6 +222,7 @@ wgl_initialize_impl(_EGLDisplay *disp, HDC hdc)
       return _eglError(EGL_BAD_ALLOC, "eglInitialize");
 
    disp->DriverData = (void *)wgl_dpy;
+   wgl_dpy->parent = disp;
 
    if (!stw_init_screen(hdc)) {
       err = "wgl: failed to initialize screen";
@@ -220,7 +231,9 @@ wgl_initialize_impl(_EGLDisplay *disp, HDC hdc)
 
    struct stw_device *stw_dev = stw_get_device();
    wgl_dpy->screen = stw_dev->screen;
-   wgl_dpy->smapi = stw_dev->smapi;
+
+   wgl_dpy->base.screen = stw_dev->screen;
+   wgl_dpy->base.get_param = wgl_egl_st_get_param;
 
    disp->ClientAPIs = 0;
    if (_eglIsApiValid(EGL_OPENGL_API))
@@ -445,7 +458,7 @@ wgl_create_context(_EGLDisplay *disp, _EGLConfig *conf,
    if (wgl_ctx->base.ResetNotificationStrategy != EGL_NO_RESET_NOTIFICATION)
       resetStrategy = WGL_LOSE_CONTEXT_ON_RESET_ARB;
    wgl_ctx->ctx = stw_create_context_attribs(disp->PlatformDisplay, 0, shared,
-      wgl_dpy->smapi,
+      &wgl_dpy->base,
       wgl_ctx->base.ClientMajorVersion,
       wgl_ctx->base.ClientMinorVersion,
       flags,
@@ -679,7 +692,7 @@ wgl_create_window_surface(_EGLDisplay *disp, _EGLConfig *conf,
 
    const struct stw_pixelformat_info *stw_conf = wgl_conf->stw_config[1] ?
       wgl_conf->stw_config[1] : wgl_conf->stw_config[0];
-   wgl_surf->fb = stw_framebuffer_create(native_window, stw_conf->iPixelFormat, STW_FRAMEBUFFER_EGL_WINDOW, wgl_dpy->smapi);
+   wgl_surf->fb = stw_framebuffer_create(native_window, stw_conf->iPixelFormat, STW_FRAMEBUFFER_EGL_WINDOW, &wgl_dpy->base);
    if (!wgl_surf->fb) {
       free(wgl_surf);
       return NULL;
@@ -709,7 +722,7 @@ wgl_create_pbuffer_surface(_EGLDisplay *disp, _EGLConfig *conf,
 
    const struct stw_pixelformat_info *stw_conf = wgl_conf->stw_config[1] ?
       wgl_conf->stw_config[1] : wgl_conf->stw_config[0];
-   wgl_surf->fb = stw_pbuffer_create(stw_conf->iPixelFormat, wgl_surf->base.Width, wgl_surf->base.Height, wgl_dpy->smapi);
+   wgl_surf->fb = stw_pbuffer_create(stw_conf->iPixelFormat, wgl_surf->base.Width, wgl_surf->base.Height, &wgl_dpy->base);
    if (!wgl_surf->fb) {
       free(wgl_surf);
       return NULL;
diff --git a/src/egl/drivers/wgl/egl_wgl.h b/src/egl/drivers/wgl/egl_wgl.h
index 8c572b613534..b609fd953959 100644
--- a/src/egl/drivers/wgl/egl_wgl.h
+++ b/src/egl/drivers/wgl/egl_wgl.h
@@ -33,9 +33,10 @@
 
 struct wgl_egl_display
 {
+   struct st_manager base;
+   _EGLDisplay *parent;
    int ref_count;
    struct pipe_screen *screen;
-   struct st_manager *smapi;
 };
 
 struct wgl_egl_config
-- 
GitLab


From 6a8ce746ae70b5eb19e64038cafc4cdb41fb88c4 Mon Sep 17 00:00:00 2001
From: Jesse Natalie <jenatali@microsoft.com>
Date: Tue, 21 Sep 2021 09:21:42 -0700
Subject: [PATCH 15/19] egl/wgl: Hook up image validate/get in smapi

---
 src/egl/drivers/wgl/egl_wgl.c              | 29 ++++++++++++++++++++++
 src/gallium/frontends/wgl/stw_image.c      |  8 ++++++
 src/gallium/frontends/wgl/stw_image.h      |  5 ++++
 src/gallium/targets/wgl/gallium_wgl.def.in |  1 +
 4 files changed, 43 insertions(+)

diff --git a/src/egl/drivers/wgl/egl_wgl.c b/src/egl/drivers/wgl/egl_wgl.c
index 2da33c20a4c5..cffbd8c108a4 100644
--- a/src/egl/drivers/wgl/egl_wgl.c
+++ b/src/egl/drivers/wgl/egl_wgl.c
@@ -211,6 +211,33 @@ wgl_egl_st_get_param(struct st_manager *smapi, enum st_manager_param param)
    return 0;
 }
 
+static bool
+wgl_get_egl_image(struct st_manager *smapi, void *image, struct st_egl_image *out)
+{
+   struct wgl_egl_image *wgl_img = (struct wgl_egl_image *)image;
+   stw_translate_image(wgl_img->img, out);
+   return true;
+}
+
+static bool
+wgl_validate_egl_image(struct st_manager *smapi, void *image)
+{
+   struct wgl_egl_display *wgl_dpy = (struct wgl_egl_display *)smapi;
+   _EGLDisplay *disp = wgl_dpy->parent;
+   _EGLImage *img;
+
+   mtx_lock(&disp->Mutex);
+   img = _eglLookupImage(image, disp);
+   mtx_unlock(&disp->Mutex);
+
+   if (img == NULL) {
+      _eglError(EGL_BAD_PARAMETER, "wgl_validate_egl_image");
+      return false;
+   }
+
+   return true;
+}
+
 static EGLBoolean
 wgl_initialize_impl(_EGLDisplay *disp, HDC hdc)
 {
@@ -234,6 +261,8 @@ wgl_initialize_impl(_EGLDisplay *disp, HDC hdc)
 
    wgl_dpy->base.screen = stw_dev->screen;
    wgl_dpy->base.get_param = wgl_egl_st_get_param;
+   wgl_dpy->base.get_egl_image = wgl_get_egl_image;
+   wgl_dpy->base.validate_egl_image = wgl_validate_egl_image;
 
    disp->ClientAPIs = 0;
    if (_eglIsApiValid(EGL_OPENGL_API))
diff --git a/src/gallium/frontends/wgl/stw_image.c b/src/gallium/frontends/wgl/stw_image.c
index cedd8d25c29b..78b245242d79 100644
--- a/src/gallium/frontends/wgl/stw_image.c
+++ b/src/gallium/frontends/wgl/stw_image.c
@@ -133,3 +133,11 @@ stw_destroy_image(struct stw_image *img)
    free(img);
 }
 
+void
+stw_translate_image(struct stw_image *in, struct st_egl_image *out)
+{
+   pipe_resource_reference(&out->texture, in->pres);
+   out->format = in->format;
+   out->layer = in->layer;
+   out->level = in->level;
+}
diff --git a/src/gallium/frontends/wgl/stw_image.h b/src/gallium/frontends/wgl/stw_image.h
index 2a1e04bcd16e..2c477a3d8b4c 100644
--- a/src/gallium/frontends/wgl/stw_image.h
+++ b/src/gallium/frontends/wgl/stw_image.h
@@ -28,6 +28,8 @@
 
 #include <GL/gl.h>
 
+struct st_egl_image;
+
 enum stw_image_error
 {
    STW_IMAGE_ERROR_SUCCESS,
@@ -55,3 +57,6 @@ stw_create_image_from_renderbuffer(struct stw_context *ctx, GLuint renderbuffer,
 
 void
 stw_destroy_image(struct stw_image *img);
+
+void
+stw_translate_image(struct stw_image *in, struct st_egl_image *out);
diff --git a/src/gallium/targets/wgl/gallium_wgl.def.in b/src/gallium/targets/wgl/gallium_wgl.def.in
index 76b93264382d..7b482218fa4e 100644
--- a/src/gallium/targets/wgl/gallium_wgl.def.in
+++ b/src/gallium/targets/wgl/gallium_wgl.def.in
@@ -42,3 +42,4 @@ stw_pbuffer_create
 stw_create_image_from_texture
 stw_create_image_from_renderbuffer
 stw_destroy_image
+stw_translate_image
-- 
GitLab


From d54fa6e6c39a8e898f21b2d4fc9887da9f543d3d Mon Sep 17 00:00:00 2001
From: Jesse Natalie <jenatali@microsoft.com>
Date: Tue, 21 Sep 2021 09:42:16 -0700
Subject: [PATCH 16/19] egl/wgl: Support EGL_MESA_query_driver

---
 src/egl/drivers/wgl/egl_wgl.c              | 15 +++++++++++++++
 src/gallium/frontends/wgl/stw_device.c     | 14 ++++++++++----
 src/gallium/frontends/wgl/stw_device.h     |  3 +++
 src/gallium/targets/wgl/gallium_wgl.def.in |  1 +
 4 files changed, 29 insertions(+), 4 deletions(-)

diff --git a/src/egl/drivers/wgl/egl_wgl.c b/src/egl/drivers/wgl/egl_wgl.c
index cffbd8c108a4..dd8f62b5669a 100644
--- a/src/egl/drivers/wgl/egl_wgl.c
+++ b/src/egl/drivers/wgl/egl_wgl.c
@@ -34,6 +34,7 @@
 #include <stw_context.h>
 #include <stw_framebuffer.h>
 #include <stw_image.h>
+#include <stw_winsys.h>
 
 #include <GL/wglext.h>
 
@@ -1035,6 +1036,18 @@ wgl_destroy_image_khr(_EGLDisplay *disp, _EGLImage *img)
    return EGL_TRUE;
 }
 
+static const char *
+wgl_query_driver_name(_EGLDisplay *disp)
+{
+   return stw_get_device()->stw_winsys->get_name();
+}
+
+static char *
+wgl_query_driver_config(_EGLDisplay *disp)
+{
+   return stw_get_config_xml();
+}
+
 struct _egl_driver _eglDriver = {
    .Initialize = wgl_initialize,
    .Terminate = wgl_terminate,
@@ -1054,5 +1067,7 @@ struct _egl_driver _eglDriver = {
    .WaitNative = wgl_wait_native,
    .CreateImageKHR = wgl_create_image_khr,
    .DestroyImageKHR = wgl_destroy_image_khr,
+   .QueryDriverName = wgl_query_driver_name,
+   .QueryDriverConfig = wgl_query_driver_config,
 };
 
diff --git a/src/gallium/frontends/wgl/stw_device.c b/src/gallium/frontends/wgl/stw_device.c
index c0a6cb17cc76..557eca8a0683 100644
--- a/src/gallium/frontends/wgl/stw_device.c
+++ b/src/gallium/frontends/wgl/stw_device.c
@@ -102,13 +102,13 @@ init_screen(const struct stw_winsys *stw_winsys, HDC hdc)
    return true;
 }
 
+static const driOptionDescription gallium_driconf[] = {
+   #include "pipe-loader/driinfo_gallium.h"
+};
+
 static void
 init_options()
 {
-   const driOptionDescription gallium_driconf[] = {
-      #include "pipe-loader/driinfo_gallium.h"
-   };
-
    const char *driver_name = stw_dev->stw_winsys->get_name ? stw_dev->stw_winsys->get_name() : NULL;
    driParseOptionInfo(&stw_dev->option_info, gallium_driconf, ARRAY_SIZE(gallium_driconf));
    driParseConfigFiles(&stw_dev->option_cache, &stw_dev->option_info, 0,
@@ -117,6 +117,12 @@ init_options()
    u_driconf_fill_st_options(&stw_dev->st_options, &stw_dev->option_cache);
 }
 
+char *
+stw_get_config_xml(void)
+{
+   return driGetOptionsXml(gallium_driconf, ARRAY_SIZE(gallium_driconf));
+}
+
 boolean
 stw_init(const struct stw_winsys *stw_winsys)
 {
diff --git a/src/gallium/frontends/wgl/stw_device.h b/src/gallium/frontends/wgl/stw_device.h
index b251a17409dd..27c3bd1a3785 100644
--- a/src/gallium/frontends/wgl/stw_device.h
+++ b/src/gallium/frontends/wgl/stw_device.h
@@ -103,6 +103,9 @@ stw_init_screen(HDC hdc);
 struct stw_device *
 stw_get_device(void);
 
+char *
+stw_get_config_xml(void);
+
 static inline struct stw_context *
 stw_lookup_context_locked( DHGLRC dhglrc )
 {
diff --git a/src/gallium/targets/wgl/gallium_wgl.def.in b/src/gallium/targets/wgl/gallium_wgl.def.in
index 7b482218fa4e..b4c719fb851e 100644
--- a/src/gallium/targets/wgl/gallium_wgl.def.in
+++ b/src/gallium/targets/wgl/gallium_wgl.def.in
@@ -43,3 +43,4 @@ stw_create_image_from_texture
 stw_create_image_from_renderbuffer
 stw_destroy_image
 stw_translate_image
+stw_get_config_xml
-- 
GitLab


From 603aa2ddf26f24f4967d7178ae925fc8de01d2cf Mon Sep 17 00:00:00 2001
From: Jesse Natalie <jenatali@microsoft.com>
Date: Tue, 21 Sep 2021 10:43:07 -0700
Subject: [PATCH 17/19] egl/wgl: Support sync objects

---
 src/egl/drivers/wgl/egl_wgl.c | 167 ++++++++++++++++++++++++++++++++++
 src/egl/drivers/wgl/egl_wgl.h |  10 ++
 2 files changed, 177 insertions(+)

diff --git a/src/egl/drivers/wgl/egl_wgl.c b/src/egl/drivers/wgl/egl_wgl.c
index dd8f62b5669a..197861ba9d70 100644
--- a/src/egl/drivers/wgl/egl_wgl.c
+++ b/src/egl/drivers/wgl/egl_wgl.c
@@ -40,6 +40,7 @@
 
 #include <pipe/p_screen.h>
 #include <pipe/p_state.h>
+#include <pipe/p_context.h>
 
 #include <mapi/glapi/glapi.h>
 
@@ -295,6 +296,10 @@ wgl_initialize_impl(_EGLDisplay *disp, HDC hdc)
    disp->Extensions.KHR_gl_texture_cubemap_image = EGL_TRUE;
    disp->Extensions.KHR_gl_texture_3D_image = EGL_TRUE;
 
+   disp->Extensions.KHR_fence_sync = EGL_TRUE;
+   disp->Extensions.KHR_reusable_sync = EGL_TRUE;
+   disp->Extensions.KHR_wait_sync = EGL_TRUE;
+
    if (!wgl_add_configs(disp)) {
       err = "wgl: failed to add configs";
       goto cleanup;
@@ -1036,6 +1041,163 @@ wgl_destroy_image_khr(_EGLDisplay *disp, _EGLImage *img)
    return EGL_TRUE;
 }
 
+static _EGLSync *
+wgl_create_sync_khr(_EGLDisplay *disp, EGLenum type, const EGLAttrib *attrib_list)
+{
+
+   _EGLContext *ctx = _eglGetCurrentContext();
+   struct wgl_egl_context *wgl_ctx = wgl_egl_context(ctx);
+   struct wgl_egl_sync *wgl_sync;
+
+   struct st_context_iface *st_ctx = wgl_ctx ? wgl_ctx->ctx->st : NULL;
+
+   wgl_sync = calloc(1, sizeof(struct wgl_egl_sync));
+   if (!wgl_sync) {
+      _eglError(EGL_BAD_ALLOC, "eglCreateSyncKHR");
+      return NULL;
+   }
+
+   if (!_eglInitSync(&wgl_sync->base, disp, type, attrib_list)) {
+      free(wgl_sync);
+      return NULL;
+   }
+
+   switch (type) {
+   case EGL_SYNC_FENCE_KHR:
+      st_ctx->flush(st_ctx, 0, &wgl_sync->fence, NULL, NULL);
+      if (!wgl_sync->fence) {
+         _eglError(EGL_BAD_ALLOC, "eglCreateSyncKHR");
+         free(wgl_sync);
+         return NULL;
+      }
+      break;
+
+   case EGL_SYNC_REUSABLE_KHR:
+      wgl_sync->event = CreateEvent(NULL, TRUE, FALSE, NULL);
+      if (!wgl_sync->event) {
+         _eglError(EGL_BAD_ALLOC, "eglCreateSyncKHR");
+         free(wgl_sync);
+         return NULL;
+      }
+   }
+
+   wgl_sync->refcount = 1;
+   return &wgl_sync->base;
+}
+
+static void
+wgl_egl_unref_sync(struct wgl_egl_display *wgl_dpy, struct wgl_egl_sync *wgl_sync)
+{
+   if (InterlockedDecrement((volatile LONG *)&wgl_sync->refcount) > 0)
+      return;
+
+   if (wgl_sync->fence)
+      wgl_dpy->screen->fence_reference(wgl_dpy->screen, &wgl_sync->fence, NULL);
+   if (wgl_sync->event)
+      CloseHandle(wgl_sync->event);
+   free(wgl_sync);
+}
+
+static EGLBoolean
+wgl_destroy_sync_khr(_EGLDisplay *disp, _EGLSync *sync)
+{
+   struct wgl_egl_display *wgl_dpy = wgl_egl_display(disp);
+   struct wgl_egl_sync *wgl_sync = wgl_egl_sync(sync);
+   wgl_egl_unref_sync(wgl_dpy, wgl_sync);
+   return EGL_TRUE;
+}
+
+static EGLint
+wgl_client_wait_sync_khr(_EGLDisplay *disp, _EGLSync *sync, EGLint flags, EGLTime timeout)
+{
+   _EGLContext *ctx = _eglGetCurrentContext();
+   struct wgl_egl_display *wgl_dpy = wgl_egl_display(disp);
+   struct wgl_egl_context *wgl_ctx = wgl_egl_context(ctx);
+   struct wgl_egl_sync *wgl_sync = wgl_egl_sync(sync);
+
+   EGLint ret = EGL_CONDITION_SATISFIED_KHR;
+
+   /* the sync object should take a reference while waiting */
+   InterlockedIncrement((volatile LONG *)&wgl_sync->refcount);
+
+   switch (sync->Type) {
+   case EGL_SYNC_FENCE_KHR:
+      if (wgl_dpy->screen->fence_finish(wgl_dpy->screen, NULL, wgl_sync->fence, timeout))
+         wgl_sync->base.SyncStatus = EGL_SIGNALED_KHR;
+      else
+         ret = EGL_TIMEOUT_EXPIRED_KHR;
+      break;
+
+   case EGL_SYNC_REUSABLE_KHR:
+      if (wgl_ctx && wgl_sync->base.SyncStatus == EGL_UNSIGNALED_KHR &&
+          (flags & EGL_SYNC_FLUSH_COMMANDS_BIT_KHR)) {
+         /* flush context if EGL_SYNC_FLUSH_COMMANDS_BIT_KHR is set */
+         wgl_gl_flush();
+      }
+
+      DWORD wait_milliseconds = (timeout == EGL_FOREVER_KHR) ? INFINITE : (DWORD)(timeout / 1000000ull);
+      DWORD wait_ret = WaitForSingleObject(wgl_sync->event, wait_milliseconds);
+      switch (wait_ret) {
+      case WAIT_OBJECT_0:
+         assert(wgl_sync->base.SyncStatus == EGL_SIGNALED_KHR);
+         break;
+      case WAIT_TIMEOUT:
+         assert(wgl_sync->base.SyncStatus == EGL_UNSIGNALED_KHR);
+         ret = EGL_TIMEOUT_EXPIRED_KHR;
+         break;
+      default:
+         _eglError(EGL_BAD_ACCESS, "eglClientWaitSyncKHR");
+         ret = EGL_FALSE;
+         break;
+      }
+      break;
+  }
+  wgl_egl_unref_sync(wgl_dpy, wgl_sync);
+
+  return ret;
+}
+
+static EGLint
+wgl_wait_sync_khr(_EGLDisplay *disp, _EGLSync *sync)
+{
+   _EGLContext *ctx = _eglGetCurrentContext();
+   struct wgl_egl_context *wgl_ctx = wgl_egl_context(ctx);
+   struct wgl_egl_sync *wgl_sync = wgl_egl_sync(sync);
+
+   if (!wgl_sync->fence)
+      return EGL_TRUE;
+
+   struct pipe_context *pipe = wgl_ctx->ctx->st->pipe;
+   if (pipe->fence_server_sync)
+      pipe->fence_server_sync(pipe, wgl_sync->fence);
+
+   return EGL_TRUE;
+}
+
+static EGLBoolean
+wgl_signal_sync_khr(_EGLDisplay *disp, _EGLSync *sync, EGLenum mode)
+{
+   struct wgl_egl_sync *wgl_sync = wgl_egl_sync(sync);
+
+   if (sync->Type != EGL_SYNC_REUSABLE_KHR)
+      return _eglError(EGL_BAD_MATCH, "eglSignalSyncKHR");
+
+   if (mode != EGL_SIGNALED_KHR && mode != EGL_UNSIGNALED_KHR)
+      return _eglError(EGL_BAD_ATTRIBUTE, "eglSignalSyncKHR");
+
+   wgl_sync->base.SyncStatus = mode;
+
+   if (mode == EGL_SIGNALED_KHR) {
+      if (!SetEvent(wgl_sync->event))
+         return _eglError(EGL_BAD_ACCESS, "eglSignalSyncKHR");
+   } else {
+      if (!ResetEvent(wgl_sync->event))
+         return _eglError(EGL_BAD_ACCESS, "eglSignalSyncKHR");
+   }
+
+   return EGL_TRUE;
+}
+
 static const char *
 wgl_query_driver_name(_EGLDisplay *disp)
 {
@@ -1067,6 +1229,11 @@ struct _egl_driver _eglDriver = {
    .WaitNative = wgl_wait_native,
    .CreateImageKHR = wgl_create_image_khr,
    .DestroyImageKHR = wgl_destroy_image_khr,
+   .CreateSyncKHR = wgl_create_sync_khr,
+   .DestroySyncKHR = wgl_destroy_sync_khr,
+   .ClientWaitSyncKHR = wgl_client_wait_sync_khr,
+   .WaitSyncKHR = wgl_wait_sync_khr,
+   .SignalSyncKHR = wgl_signal_sync_khr,
    .QueryDriverName = wgl_query_driver_name,
    .QueryDriverConfig = wgl_query_driver_config,
 };
diff --git a/src/egl/drivers/wgl/egl_wgl.h b/src/egl/drivers/wgl/egl_wgl.h
index b609fd953959..b9b99f00dddb 100644
--- a/src/egl/drivers/wgl/egl_wgl.h
+++ b/src/egl/drivers/wgl/egl_wgl.h
@@ -27,6 +27,7 @@
 #include <egldisplay.h>
 #include <eglconfig.h>
 #include <eglimage.h>
+#include <eglsync.h>
 
 #include <stw_pixelformat.h>
 #include <windows.h>
@@ -63,5 +64,14 @@ struct wgl_egl_image
    struct stw_image *img;
 };
 
+struct wgl_egl_sync
+{
+   _EGLSync base;
+   int refcount;
+   struct pipe_fence_handle *fence;
+   HANDLE event;
+};
+
 _EGL_DRIVER_STANDARD_TYPECASTS(wgl_egl)
 _EGL_DRIVER_TYPECAST(wgl_egl_image, _EGLImage, obj)
+_EGL_DRIVER_TYPECAST(wgl_egl_sync, _EGLSync, obj)
-- 
GitLab


From 9cdd518f07c1bafd3aa6bd6aeb970dfe812f43a0 Mon Sep 17 00:00:00 2001
From: Jesse Natalie <jenatali@microsoft.com>
Date: Tue, 21 Sep 2021 15:33:26 -0700
Subject: [PATCH 18/19] wgl: Use pfi instead of iPixelFormat more often

Also, support config-less contexts, and surface-less contexts.
---
 src/egl/drivers/wgl/egl_wgl.c                 |  6 +-
 src/gallium/frontends/wgl/stw_context.c       | 97 ++++++-------------
 src/gallium/frontends/wgl/stw_context.h       |  5 +-
 src/gallium/frontends/wgl/stw_ext_context.c   |  6 +-
 src/gallium/frontends/wgl/stw_ext_pbuffer.c   |  9 +-
 .../frontends/wgl/stw_ext_rendertexture.c     |  8 +-
 src/gallium/frontends/wgl/stw_framebuffer.c   | 18 ++--
 src/gallium/frontends/wgl/stw_framebuffer.h   |  5 +-
 src/gallium/frontends/wgl/stw_pixelformat.c   | 47 +++++++++
 src/gallium/frontends/wgl/stw_pixelformat.h   |  6 ++
 10 files changed, 113 insertions(+), 94 deletions(-)

diff --git a/src/egl/drivers/wgl/egl_wgl.c b/src/egl/drivers/wgl/egl_wgl.c
index 197861ba9d70..607b2157b96a 100644
--- a/src/egl/drivers/wgl/egl_wgl.c
+++ b/src/egl/drivers/wgl/egl_wgl.c
@@ -498,7 +498,7 @@ wgl_create_context(_EGLDisplay *disp, _EGLConfig *conf,
       wgl_ctx->base.ClientMinorVersion,
       flags,
       profile_mask,
-      stw_config->iPixelFormat,
+      stw_config,
       resetStrategy);
 
    if (!wgl_ctx->ctx)
@@ -727,7 +727,7 @@ wgl_create_window_surface(_EGLDisplay *disp, _EGLConfig *conf,
 
    const struct stw_pixelformat_info *stw_conf = wgl_conf->stw_config[1] ?
       wgl_conf->stw_config[1] : wgl_conf->stw_config[0];
-   wgl_surf->fb = stw_framebuffer_create(native_window, stw_conf->iPixelFormat, STW_FRAMEBUFFER_EGL_WINDOW, &wgl_dpy->base);
+   wgl_surf->fb = stw_framebuffer_create(native_window, stw_conf, STW_FRAMEBUFFER_EGL_WINDOW, &wgl_dpy->base);
    if (!wgl_surf->fb) {
       free(wgl_surf);
       return NULL;
@@ -757,7 +757,7 @@ wgl_create_pbuffer_surface(_EGLDisplay *disp, _EGLConfig *conf,
 
    const struct stw_pixelformat_info *stw_conf = wgl_conf->stw_config[1] ?
       wgl_conf->stw_config[1] : wgl_conf->stw_config[0];
-   wgl_surf->fb = stw_pbuffer_create(stw_conf->iPixelFormat, wgl_surf->base.Width, wgl_surf->base.Height, &wgl_dpy->base);
+   wgl_surf->fb = stw_pbuffer_create(stw_conf, wgl_surf->base.Width, wgl_surf->base.Height, &wgl_dpy->base);
    if (!wgl_surf->fb) {
       free(wgl_surf);
       return NULL;
diff --git a/src/gallium/frontends/wgl/stw_context.c b/src/gallium/frontends/wgl/stw_context.c
index 78a5396df9b0..5124efe63f04 100644
--- a/src/gallium/frontends/wgl/stw_context.c
+++ b/src/gallium/frontends/wgl/stw_context.c
@@ -129,9 +129,13 @@ DrvCreateLayerContext(HDC hdc, INT iLayerPlane)
    if (!stw_dev)
       return 0;
 
+   const struct stw_pixelformat_info *pfi = stw_pixelformat_get_info_from_hdc(hdc);
+   if (!pfi)
+      return 0;
+
    struct stw_context *ctx = stw_create_context_attribs(hdc, iLayerPlane, NULL, stw_dev->smapi, 1, 0, 0,
                                                         WGL_CONTEXT_COMPATIBILITY_PROFILE_BIT_ARB,
-                                                        0, WGL_NO_RESET_NOTIFICATION_ARB);
+                                                        pfi, WGL_NO_RESET_NOTIFICATION_ARB);
    if (!ctx)
       return 0;
 
@@ -142,26 +146,6 @@ DrvCreateLayerContext(HDC hdc, INT iLayerPlane)
    return ret;
 }
 
-
-/**
- * Return the stw pixel format that most closely matches the pixel format
- * on HDC.
- * Used to get a pixel format when SetPixelFormat() hasn't been called before.
- */
-static int
-get_matching_pixel_format(HDC hdc)
-{
-   int iPixelFormat = GetPixelFormat(hdc);
-   PIXELFORMATDESCRIPTOR pfd;
-
-   if (!iPixelFormat)
-      return 0;
-   if (!DescribePixelFormat(hdc, iPixelFormat, sizeof(pfd), &pfd))
-      return 0;
-   return stw_pixelformat_choose(hdc, &pfd);
-}
-
-
 /**
  * Called via DrvCreateContext(), DrvCreateLayerContext() and
  * wglCreateContextAttribsARB() to actually create a rendering context.
@@ -171,9 +155,9 @@ stw_create_context_attribs(HDC hdc, INT iLayerPlane, struct stw_context *shareCt
                            struct st_manager *smapi,
                            int majorVersion, int minorVersion,
                            int contextFlags, int profileMask,
-                           int iPixelFormat, int resetStrategy)
+                           const struct stw_pixelformat_info *pfi,
+                           int resetStrategy)
 {
-   const struct stw_pixelformat_info *pfi;
    struct st_context_attribs attribs;
    struct stw_context *ctx = NULL;
    enum st_context_error ctx_err = 0;
@@ -184,32 +168,6 @@ stw_create_context_attribs(HDC hdc, INT iLayerPlane, struct stw_context *shareCt
    if (iLayerPlane != 0)
       return 0;
 
-   if (!iPixelFormat) {
-      /*
-       * GDI only knows about displayable pixel formats, so determine the pixel
-       * format from the framebuffer.
-       *
-       * This also allows to use a OpenGL DLL / ICD without installing.
-       */
-      struct stw_framebuffer *fb;
-      fb = stw_framebuffer_from_hdc(hdc);
-      if (fb) {
-         iPixelFormat = fb->iPixelFormat;
-         stw_framebuffer_unlock(fb);
-      }
-      else {
-         /* Applications should call SetPixelFormat before creating a context,
-          * but not all do, and the opengl32 runtime seems to use a default
-          * pixel format in some cases, so use that.
-          */
-         iPixelFormat = get_matching_pixel_format(hdc);
-         if (!iPixelFormat)
-            return 0;
-      }
-   }
-
-   pfi = stw_pixelformat_get_info( iPixelFormat );
-
    if (shareCtx != NULL)
       shareCtx->shared = TRUE;
 
@@ -219,11 +177,12 @@ stw_create_context_attribs(HDC hdc, INT iLayerPlane, struct stw_context *shareCt
 
    ctx->hDrawDC = hdc;
    ctx->hReadDC = hdc;
-   ctx->iPixelFormat = iPixelFormat;
+   ctx->pfi = pfi;
    ctx->shared = shareCtx != NULL;
 
    memset(&attribs, 0, sizeof(attribs));
-   attribs.visual = pfi->stvis;
+   if (pfi)
+      attribs.visual = pfi->stvis;
    attribs.major = majorVersion;
    attribs.minor = minorVersion;
    if (contextFlags & WGL_CONTEXT_FORWARD_COMPATIBLE_BIT_ARB)
@@ -500,28 +459,29 @@ stw_make_current(struct stw_framebuffer *fb, struct stw_framebuffer *fbRead, str
    }
 
    if (ctx) {
-      if (!fb || !fbRead)
-         goto fail;
-
-      if (fb->iPixelFormat != ctx->iPixelFormat) {
+      if (ctx->pfi && fb && fb->pfi != ctx->pfi) {
          SetLastError(ERROR_INVALID_PIXEL_FORMAT);
          goto fail;
       }
-      if (fbRead->iPixelFormat != ctx->iPixelFormat) {
+      if (ctx->pfi && fbRead && fbRead->pfi != ctx->pfi) {
          SetLastError(ERROR_INVALID_PIXEL_FORMAT);
          goto fail;
       }
 
-      stw_framebuffer_lock(fb);
-      stw_framebuffer_update(fb);
-      stw_framebuffer_reference_locked(fb);
-      stw_framebuffer_unlock(fb);
+      if (fb) {
+         stw_framebuffer_lock(fb);
+         stw_framebuffer_update(fb);
+         stw_framebuffer_reference_locked(fb);
+         stw_framebuffer_unlock(fb);
+      }
 
-      stw_framebuffer_lock(fbRead);
-      if (fbRead != fb)
-         stw_framebuffer_update(fbRead);
-      stw_framebuffer_reference_locked(fbRead);
-      stw_framebuffer_unlock(fbRead);
+      if (fbRead) {
+         stw_framebuffer_lock(fbRead);
+         if (fbRead != fb)
+            stw_framebuffer_update(fbRead);
+         stw_framebuffer_reference_locked(fbRead);
+         stw_framebuffer_unlock(fbRead);
+      }
 
       struct stw_framebuffer *old_fb = ctx->current_framebuffer;
       struct stw_framebuffer *old_fbRead = ctx->current_read_framebuffer;
@@ -529,7 +489,8 @@ stw_make_current(struct stw_framebuffer *fb, struct stw_framebuffer *fbRead, str
       ctx->current_read_framebuffer = fbRead;
 
       ret = stw_dev->stapi->make_current(stw_dev->stapi, ctx->st,
-                                          fb->stfb, fbRead->stfb);
+                                         fb ? fb->stfb : NULL,
+                                         fbRead ? fbRead->stfb : NULL);
 
       /* Release the old framebuffers from this context. */
       release_old_framebuffers(old_fb, old_fbRead, ctx);
@@ -577,9 +538,9 @@ get_unlocked_refd_framebuffer_from_dc(HDC hDC)
        * pixel format in some cases, so we must create a framebuffer for
        * those here.
        */
-      int iPixelFormat = get_matching_pixel_format(hDC);
+      int iPixelFormat = stw_pixelformat_guess(hDC);
       if (iPixelFormat)
-         fb = stw_framebuffer_create(WindowFromDC(hDC), iPixelFormat, STW_FRAMEBUFFER_WGL_WINDOW, stw_dev->smapi);
+         fb = stw_framebuffer_create(WindowFromDC(hDC), stw_pixelformat_get_info(iPixelFormat), STW_FRAMEBUFFER_WGL_WINDOW, stw_dev->smapi);
       if (!fb)
          return NULL;
    }
diff --git a/src/gallium/frontends/wgl/stw_context.h b/src/gallium/frontends/wgl/stw_context.h
index 5f4096f362c4..7faf4c14c871 100644
--- a/src/gallium/frontends/wgl/stw_context.h
+++ b/src/gallium/frontends/wgl/stw_context.h
@@ -41,7 +41,7 @@ struct stw_context
 {
    struct st_context_iface *st;
    DHGLRC dhglrc;
-   int iPixelFormat;
+   const struct stw_pixelformat_info *pfi;
    HDC hDrawDC;
    HDC hReadDC;
    BOOL shared;
@@ -57,7 +57,8 @@ struct stw_context *stw_create_context_attribs(HDC hdc, INT iLayerPlane,
                                                struct st_manager *smapi,
                                                int majorVersion, int minorVersion,
                                                int contextFlags, int profileMask,
-                                               int iPixelFormat, int resetStrategy);
+                                               const struct stw_pixelformat_info *pfi,
+                                               int resetStrategy);
 
 DHGLRC stw_create_context_handle(struct stw_context *context, DHGLRC handle);
 
diff --git a/src/gallium/frontends/wgl/stw_ext_context.c b/src/gallium/frontends/wgl/stw_ext_context.c
index 2156726f3390..0bc5b03e4d50 100644
--- a/src/gallium/frontends/wgl/stw_ext_context.c
+++ b/src/gallium/frontends/wgl/stw_ext_context.c
@@ -213,10 +213,14 @@ wglCreateContextAttribsARB(HDC hDC, HGLRC hShareContext, const int *attribList)
 
       struct stw_context *share_stw = stw_lookup_context(share_dhglrc);
 
+      const struct stw_pixelformat_info *pfi = stw_pixelformat_get_info_from_hdc(hDC);
+      if (!pfi)
+         return 0;
+
       struct stw_context *stw_ctx = stw_create_context_attribs(hDC, layerPlane, share_stw,
                                                                stw_dev->smapi,
                                                                majorVersion, minorVersion,
-                                                               contextFlags, profileMask, 0,
+                                                               contextFlags, profileMask, pfi,
                                                                resetStrategy);
 
       if (!stw_ctx) {
diff --git a/src/gallium/frontends/wgl/stw_ext_pbuffer.c b/src/gallium/frontends/wgl/stw_ext_pbuffer.c
index f06139130226..e9f904be1885 100644
--- a/src/gallium/frontends/wgl/stw_ext_pbuffer.c
+++ b/src/gallium/frontends/wgl/stw_ext_pbuffer.c
@@ -66,7 +66,7 @@ WndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
 }
 
 struct stw_framebuffer *
-stw_pbuffer_create(int iPixelFormat, int iWidth, int iHeight, struct st_manager *smapi)
+stw_pbuffer_create(const struct stw_pixelformat_info *pfi, int iWidth, int iHeight, struct st_manager *smapi)
 {
    static boolean first = TRUE;
 
@@ -143,7 +143,7 @@ stw_pbuffer_create(int iPixelFormat, int iWidth, int iHeight, struct st_manager
    assert(rect.bottom - rect.top == iHeight);
 #endif
 
-   return stw_framebuffer_create(hWnd, iPixelFormat, STW_FRAMEBUFFER_PBUFFER, smapi);
+   return stw_framebuffer_create(hWnd, pfi, STW_FRAMEBUFFER_PBUFFER, smapi);
 }
 
 
@@ -164,8 +164,9 @@ wglCreatePbufferARB(HDC hCurrentDC,
    int textureFormat = WGL_NO_TEXTURE_ARB;
    int textureTarget = WGL_NO_TEXTURE_ARB;
    BOOL textureMipmap = FALSE;
+   const struct stw_pixelformat_info *pfi = stw_pixelformat_get_info(iPixelFormat);
 
-   if (!stw_pixelformat_get_info(iPixelFormat)) {
+   if (!pfi) {
       SetLastError(ERROR_INVALID_PIXEL_FORMAT);
       return 0;
    }
@@ -241,7 +242,7 @@ wglCreatePbufferARB(HDC hCurrentDC,
     * We can't pass non-displayable pixel formats to GDI, which is why we
     * create the framebuffer object before calling SetPixelFormat().
     */
-   fb = stw_pbuffer_create(iPixelFormat, iWidth, iHeight, stw_dev->smapi);
+   fb = stw_pbuffer_create(pfi, iWidth, iHeight, stw_dev->smapi);
    if (!fb) {
       SetLastError(ERROR_NO_SYSTEM_RESOURCES);
       return NULL;
diff --git a/src/gallium/frontends/wgl/stw_ext_rendertexture.c b/src/gallium/frontends/wgl/stw_ext_rendertexture.c
index 2b7d90eeea86..746727ec40eb 100644
--- a/src/gallium/frontends/wgl/stw_ext_rendertexture.c
+++ b/src/gallium/frontends/wgl/stw_ext_rendertexture.c
@@ -107,7 +107,7 @@ wglBindTexImageARB(HPBUFFERARB hPbuffer, int iBuffer)
    struct stw_framebuffer *fb, *old_fb, *old_fbRead;
    GLenum texFormat, srcBuffer, target;
    boolean retVal;
-   int pixelFormatSave;
+   const struct stw_pixelformat_info *pfiSave;
 
    /*
     * Implementation notes:
@@ -170,10 +170,10 @@ wglBindTexImageARB(HPBUFFERARB hPbuffer, int iBuffer)
     * an error condition.  After the stw_make_current() we restore the
     * buffer's pixel format.
     */
-   pixelFormatSave = fb->iPixelFormat;
-   fb->iPixelFormat = curctx->iPixelFormat;
+   pfiSave = fb->pfi;
+   fb->pfi = curctx->pfi;
    retVal = stw_make_current(fb, fb, curctx);
-   fb->iPixelFormat = pixelFormatSave;
+   fb->pfi = pfiSave;
    if (!retVal) {
       debug_printf("stw_make_current(#1) failed in wglBindTexImageARB()\n");
       return FALSE;
diff --git a/src/gallium/frontends/wgl/stw_framebuffer.c b/src/gallium/frontends/wgl/stw_framebuffer.c
index 768f2fa7e1f9..02fed21c6b42 100644
--- a/src/gallium/frontends/wgl/stw_framebuffer.c
+++ b/src/gallium/frontends/wgl/stw_framebuffer.c
@@ -269,32 +269,30 @@ stw_call_window_proc(int nCode, WPARAM wParam, LPARAM lParam)
  * with its mutex locked.
  */
 struct stw_framebuffer *
-stw_framebuffer_create(HWND hWnd, int iPixelFormat, enum stw_framebuffer_owner owner,
+stw_framebuffer_create(HWND hWnd, const struct stw_pixelformat_info *pfi, enum stw_framebuffer_owner owner,
                        struct st_manager *smapi)
 {
    struct stw_framebuffer *fb;
-   const struct stw_pixelformat_info *pfi;
 
    fb = CALLOC_STRUCT( stw_framebuffer );
    if (fb == NULL)
       return NULL;
 
    fb->hWnd = hWnd;
-   fb->iPixelFormat = iPixelFormat;
 
    if (stw_dev->stw_winsys->create_framebuffer)
       fb->winsys_framebuffer =
-         stw_dev->stw_winsys->create_framebuffer(stw_dev->screen, hWnd, iPixelFormat);
+         stw_dev->stw_winsys->create_framebuffer(stw_dev->screen, hWnd, pfi->iPixelFormat);
 
    /*
     * We often need a displayable pixel format to make GDI happy. Set it
     * here (always 1, i.e., out first pixel format) where appropriate.
     */
-   fb->iDisplayablePixelFormat = iPixelFormat <= stw_dev->pixelformat_count
-      ? iPixelFormat : 1;
+   fb->iDisplayablePixelFormat = pfi->iPixelFormat <= stw_dev->pixelformat_count
+      ? pfi->iPixelFormat : 1;
    fb->owner = owner;
 
-   fb->pfi = pfi = stw_pixelformat_get_info( iPixelFormat );
+   fb->pfi = pfi;
    fb->stfb = stw_st_create_framebuffer( fb, smapi );
    if (!fb->stfb) {
       FREE( fb );
@@ -499,7 +497,9 @@ DrvSetPixelFormat(HDC hdc, LONG iPixelFormat)
       return bPbuffer;
    }
 
-   fb = stw_framebuffer_create(WindowFromDC(hdc), iPixelFormat, STW_FRAMEBUFFER_WGL_WINDOW, stw_dev->smapi);
+   const struct stw_pixelformat_info *pfi = stw_pixelformat_get_info(iPixelFormat);
+
+   fb = stw_framebuffer_create(WindowFromDC(hdc), pfi, STW_FRAMEBUFFER_WGL_WINDOW, stw_dev->smapi);
    if (!fb) {
       return FALSE;
    }
@@ -528,7 +528,7 @@ stw_pixelformat_get(HDC hdc)
 
    fb = stw_framebuffer_from_hdc(hdc);
    if (fb) {
-      iPixelFormat = fb->iPixelFormat;
+      iPixelFormat = fb->pfi->iPixelFormat;
       stw_framebuffer_unlock(fb);
    }
 
diff --git a/src/gallium/frontends/wgl/stw_framebuffer.h b/src/gallium/frontends/wgl/stw_framebuffer.h
index de45f340fee7..d3366ce9889c 100644
--- a/src/gallium/frontends/wgl/stw_framebuffer.h
+++ b/src/gallium/frontends/wgl/stw_framebuffer.h
@@ -84,7 +84,6 @@ struct stw_framebuffer
    
    HWND hWnd;
 
-   int iPixelFormat;
    const struct stw_pixelformat_info *pfi;
 
    /* A pixel format that can be used by GDI */
@@ -154,11 +153,11 @@ struct stw_framebuffer
  * must be called when done 
  */
 struct stw_framebuffer *
-stw_framebuffer_create(HWND hwnd, int iPixelFormat, enum stw_framebuffer_owner owner,
+stw_framebuffer_create(HWND hwnd, const struct stw_pixelformat_info *pfi, enum stw_framebuffer_owner owner,
                        struct st_manager *smapi);
 
 struct stw_framebuffer *
-stw_pbuffer_create(int iPixelFormat, int iWidth, int iHeight, struct st_manager *smapi);
+stw_pbuffer_create(const struct stw_pixelformat_info *pfi, int iWidth, int iHeight, struct st_manager *smapi);
 
 
 /**
diff --git a/src/gallium/frontends/wgl/stw_pixelformat.c b/src/gallium/frontends/wgl/stw_pixelformat.c
index 3994ab0766cc..2c0d1561c324 100644
--- a/src/gallium/frontends/wgl/stw_pixelformat.c
+++ b/src/gallium/frontends/wgl/stw_pixelformat.c
@@ -36,6 +36,7 @@
 #include <GL/gl.h>
 #include "gldrv.h"
 #include "stw_device.h"
+#include "stw_framebuffer.h"
 #include "stw_pixelformat.h"
 #include "stw_tls.h"
 #include "stw_winsys.h"
@@ -382,6 +383,52 @@ stw_pixelformat_get_info(int iPixelFormat)
                                 index);
 }
 
+/**
+ * Return the stw pixel format that most closely matches the pixel format
+ * on HDC.
+ * Used to get a pixel format when SetPixelFormat() hasn't been called before.
+ */
+int
+stw_pixelformat_guess(HDC hdc)
+{
+   int iPixelFormat = GetPixelFormat(hdc);
+   PIXELFORMATDESCRIPTOR pfd;
+
+   if (!iPixelFormat)
+      return 0;
+   if (!DescribePixelFormat(hdc, iPixelFormat, sizeof(pfd), &pfd))
+      return 0;
+   return stw_pixelformat_choose(hdc, &pfd);
+}
+
+const struct stw_pixelformat_info *
+stw_pixelformat_get_info_from_hdc(HDC hdc)
+{
+   /*
+    * GDI only knows about displayable pixel formats, so determine the pixel
+    * format from the framebuffer.
+    *
+    * This also allows to use a OpenGL DLL / ICD without installing.
+    */
+   struct stw_framebuffer *fb;
+   fb = stw_framebuffer_from_hdc(hdc);
+   if (fb) {
+      const struct stw_pixelformat_info *pfi = fb->pfi;
+      stw_framebuffer_unlock(fb);
+      return pfi;
+   }
+
+   /* Applications should call SetPixelFormat before creating a context,
+    * but not all do, and the opengl32 runtime seems to use a default
+    * pixel format in some cases, so use that.
+    */
+   int iPixelFormat = stw_pixelformat_guess(hdc);
+   if (!iPixelFormat)
+      return 0;
+   
+   return stw_pixelformat_get_info( iPixelFormat );
+}
+
 
 LONG APIENTRY
 DrvDescribePixelFormat(HDC hdc, INT iPixelFormat, ULONG cjpfd,
diff --git a/src/gallium/frontends/wgl/stw_pixelformat.h b/src/gallium/frontends/wgl/stw_pixelformat.h
index 036baeb80456..3999c8e4ab4d 100644
--- a/src/gallium/frontends/wgl/stw_pixelformat.h
+++ b/src/gallium/frontends/wgl/stw_pixelformat.h
@@ -67,6 +67,12 @@ stw_pixelformat_get_extended_count( HDC hdc );
 const struct stw_pixelformat_info *
 stw_pixelformat_get_info( int iPixelFormat );
 
+const struct stw_pixelformat_info *
+stw_pixelformat_get_info_from_hdc( HDC hdc );
+
+int
+stw_pixelformat_guess( HDC );
+
 int
 stw_pixelformat_choose( HDC hdc,
                         CONST PIXELFORMATDESCRIPTOR *ppfd );
-- 
GitLab


From 56d657898cd0e2799c89bd72f6eb3b88c393bb7a Mon Sep 17 00:00:00 2001
From: Jesse Natalie <jenatali@microsoft.com>
Date: Thu, 28 Apr 2022 10:41:12 -0700
Subject: [PATCH 19/19] egl/wgl: Delete unused variables/code

Fixes: 3415bf02 ("egl: Add a basic Windows driver")
Suggested-by: Yonggang Luo <luoyonggang@gmail.com>
---
 src/egl/drivers/wgl/egl_wgl.c | 49 -----------------------------------
 1 file changed, 49 deletions(-)

diff --git a/src/egl/drivers/wgl/egl_wgl.c b/src/egl/drivers/wgl/egl_wgl.c
index 607b2157b96a..fcd5fa1036f0 100644
--- a/src/egl/drivers/wgl/egl_wgl.c
+++ b/src/egl/drivers/wgl/egl_wgl.c
@@ -60,11 +60,8 @@ static struct wgl_egl_config *
 wgl_add_config(_EGLDisplay *disp, const struct stw_pixelformat_info *stw_config, int id, EGLint surface_type)
 {
    struct wgl_egl_config *conf;
-   struct wgl_egl_display *wgl_dpy = wgl_egl_display(disp);
    _EGLConfig base;
    unsigned int double_buffer;
-   int wgl_shifts[4] = { -1, -1, -1, -1 };
-   unsigned int wgl_sizes[4] = { 0, 0, 0, 0 };
    _EGLConfig *matching_config;
    EGLint num_configs = 0;
    EGLint config_id;
@@ -76,22 +73,12 @@ wgl_add_config(_EGLDisplay *disp, const struct stw_pixelformat_info *stw_config,
    if (stw_config->pfd.iPixelType != PFD_TYPE_RGBA)
       return NULL;
 
-   wgl_sizes[0] = stw_config->pfd.cRedBits;
-   wgl_sizes[1] = stw_config->pfd.cGreenBits;
-   wgl_sizes[2] = stw_config->pfd.cBlueBits;
-   wgl_sizes[3] = stw_config->pfd.cAlphaBits;
-
    base.RedSize = stw_config->pfd.cRedBits;
    base.GreenSize = stw_config->pfd.cGreenBits;
    base.BlueSize = stw_config->pfd.cBlueBits;
    base.AlphaSize = stw_config->pfd.cAlphaBits;
    base.BufferSize = stw_config->pfd.cColorBits;
 
-   wgl_shifts[0] = stw_config->pfd.cRedShift;
-   wgl_shifts[1] = stw_config->pfd.cGreenShift;
-   wgl_shifts[2] = stw_config->pfd.cBlueShift;
-   wgl_shifts[3] = stw_config->pfd.cAlphaShift;
-
    if (stw_config->pfd.cAccumBits) {
       /* Don't expose visuals with the accumulation buffer. */
       return NULL;
@@ -518,7 +505,6 @@ static EGLBoolean
 wgl_destroy_context(_EGLDisplay *disp, _EGLContext *ctx)
 {
    struct wgl_egl_context *wgl_ctx = wgl_egl_context(ctx);
-   struct wgl_egl_display *wgl_dpy = wgl_egl_display(disp);
 
    if (_eglPutContext(ctx)) {
       stw_destroy_context(wgl_ctx->ctx);
@@ -576,7 +562,6 @@ wgl_make_current(_EGLDisplay *disp, _EGLSurface *dsurf,
    struct wgl_egl_display *wgl_dpy = wgl_egl_display(disp);
    struct wgl_egl_context *wgl_ctx = wgl_egl_context(ctx);
    _EGLDisplay *old_disp = NULL;
-   struct wgl_egl_display *old_wgl_dpy = NULL;
    _EGLContext *old_ctx;
    _EGLSurface *old_dsurf, *old_rsurf;
    _EGLSurface *tmp_dsurf, *tmp_rsurf;
@@ -594,22 +579,10 @@ wgl_make_current(_EGLDisplay *disp, _EGLSurface *dsurf,
    if (old_ctx) {
       struct stw_context *old_cctx = wgl_egl_context(old_ctx)->ctx;
       old_disp = old_ctx->Resource.Display;
-      old_wgl_dpy = wgl_egl_display(old_disp);
 
       /* flush before context switch */
       wgl_gl_flush();
 
-#if 0
-      if (old_dsurf)
-         wgl_surf_update_fence_fd(old_ctx, disp, old_dsurf);
-
-      /* Disable shared buffer mode */
-      if (old_dsurf && _eglSurfaceInSharedBufferMode(old_dsurf) &&
-         old_wgl_dpy->vtbl->set_shared_buffer_mode) {
-         old_wgl_dpy->vtbl->set_shared_buffer_mode(old_disp, old_dsurf, false);
-      }
-#endif
-
       stw_unbind_context(old_cctx);
    }
 
@@ -647,13 +620,6 @@ wgl_make_current(_EGLDisplay *disp, _EGLSurface *dsurf,
 
          /* undo the previous wgl_dpy->core->unbindContext */
          if (stw_make_current(ddraw, rdraw, cctx)) {
-#if 0
-            if (old_dsurf && _eglSurfaceInSharedBufferMode(old_dsurf) &&
-               old_wgl_dpy->vtbl->set_shared_buffer_mode) {
-               old_wgl_dpy->vtbl->set_shared_buffer_mode(old_disp, old_dsurf, true);
-            }
-#endif
-
             return _eglError(egl_error, "eglMakeCurrent");
          }
 
@@ -692,20 +658,6 @@ wgl_make_current(_EGLDisplay *disp, _EGLSurface *dsurf,
    if (egl_error != EGL_SUCCESS)
       return _eglError(egl_error, "eglMakeCurrent");
 
-#if 0
-   if (dsurf && _eglSurfaceHasMutableRenderBuffer(dsurf) &&
-      wgl_dpy->vtbl->set_shared_buffer_mode) {
-      /* Always update the shared buffer mode. This is obviously needed when
-       * the active EGL_RENDER_BUFFER is EGL_SINGLE_BUFFER. When
-       * EGL_RENDER_BUFFER is EGL_BACK_BUFFER, the update protects us in the
-       * case where external non-EGL API may have changed window's shared
-       * buffer mode since we last saw it.
-       */
-      bool mode = (dsurf->ActiveRenderBuffer == EGL_SINGLE_BUFFER);
-      wgl_dpy->vtbl->set_shared_buffer_mode(disp, dsurf, mode);
-   }
-#endif
-
    return EGL_TRUE;
 }
 
@@ -856,7 +808,6 @@ wgl_swap_interval(_EGLDisplay *disp, _EGLSurface *surf, EGLint interval)
 static EGLBoolean
 wgl_swap_buffers(_EGLDisplay *disp, _EGLSurface *draw)
 {
-   struct wgl_egl_display *wgl_disp = wgl_egl_display(disp);
    struct wgl_egl_surface *wgl_surf = wgl_egl_surface(draw);
 
    stw_framebuffer_lock(wgl_surf->fb);
-- 
GitLab

