From b6f1f6ff377e913fcd3c9c1254f2c8eeded8245a Mon Sep 17 00:00:00 2001
From: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
Date: Wed, 24 Sep 2025 09:27:32 +0200
Subject: [PATCH 01/13] ac/virtio: fix incorrect NULL check

---
 src/amd/common/virtio/amdgpu_virtio.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/amd/common/virtio/amdgpu_virtio.c b/src/amd/common/virtio/amdgpu_virtio.c
index 12dbd6b04eaf2..18ea67a985421 100644
--- a/src/amd/common/virtio/amdgpu_virtio.c
+++ b/src/amd/common/virtio/amdgpu_virtio.c
@@ -406,7 +406,7 @@ amdvgpu_cs_submit_raw2(amdvgpu_device_handle dev, uint32_t ctx_id,
 
 
          *syncobjs = realloc(*syncobjs, (*count + new_syncobj_count) * sizeof(struct drm_virtgpu_execbuffer_syncobj));
-         if (syncobjs == NULL) {
+         if (*syncobjs == NULL) {
             ret = -ENOMEM;
             goto error;
          }
-- 
GitLab


From d1ea729bf80f4061e8b258384ca1a6be322855e4 Mon Sep 17 00:00:00 2001
From: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
Date: Wed, 24 Sep 2025 09:27:52 +0200
Subject: [PATCH 02/13] mesa/st: fix potential overflow warnings

The multiplication of 32 bits integers will be truncated before
being widened to the destination variable' size.
Reported by static analysis.
---
 src/mesa/state_tracker/st_cb_bitmap.c     | 2 +-
 src/mesa/state_tracker/st_cb_drawpixels.c | 9 +++++----
 src/mesa/state_tracker/st_cb_readpixels.c | 2 +-
 src/mesa/state_tracker/st_cb_texture.c    | 8 ++++----
 src/mesa/state_tracker/st_pbo.c           | 2 +-
 src/mesa/state_tracker/st_pbo_compute.c   | 2 +-
 6 files changed, 13 insertions(+), 12 deletions(-)

diff --git a/src/mesa/state_tracker/st_cb_bitmap.c b/src/mesa/state_tracker/st_cb_bitmap.c
index a1f05f342a48a..184f7c321ada1 100644
--- a/src/mesa/state_tracker/st_cb_bitmap.c
+++ b/src/mesa/state_tracker/st_cb_bitmap.c
@@ -153,7 +153,7 @@ st_make_bitmap_texture(struct gl_context *ctx, GLsizei width, GLsizei height,
                             0, 0, width, height, &transfer);
 
    /* Put image into texture transfer */
-   memset(dest, 0xff, height * transfer->stride);
+   memset(dest, 0xff, height * (size_t)transfer->stride);
    unpack_bitmap(st, 0, 0, width, height, unpack, bitmap,
                  dest, transfer->stride);
 
diff --git a/src/mesa/state_tracker/st_cb_drawpixels.c b/src/mesa/state_tracker/st_cb_drawpixels.c
index e82a685c81069..9d5ad7f6bd726 100644
--- a/src/mesa/state_tracker/st_cb_drawpixels.c
+++ b/src/mesa/state_tracker/st_cb_drawpixels.c
@@ -492,7 +492,7 @@ search_drawpixels_cache(struct st_context *st,
             continue;
 
          /* check if the pixel data is the same */
-         if (memcmp(pixels, entry->image, width * height * bpp) == 0) {
+         if (memcmp(pixels, entry->image, (size_t)width * height * bpp) == 0) {
             /* Success - found a cache match */
             pipe_resource_reference(&pt, entry->texture);
             /* refcount of returned texture should be at least two here.  One
@@ -556,6 +556,7 @@ cache_drawpixels_image(struct st_context *st,
       const GLint bpp = _mesa_bytes_per_pixel(format, type);
       struct drawpix_cache_entry *entry =
          find_oldest_drawpixels_cache_entry(st);
+      const size_t n_bytes = (size_t)width * height * bpp;
       assert(entry);
       entry->width = width;
       entry->height = height;
@@ -565,9 +566,9 @@ cache_drawpixels_image(struct st_context *st,
              sizeof(struct gl_pixelmaps));
       entry->user_pointer = pixels;
       free(entry->image);
-      entry->image = malloc(width * height * bpp);
+      entry->image = malloc(n_bytes);
       if (entry->image) {
-         memcpy(entry->image, pixels, width * height * bpp);
+         memcpy(entry->image, pixels, n_bytes);
          pipe_resource_reference(&entry->texture, pt);
          entry->age = ++st->drawpix_cache.age;
       }
@@ -1410,7 +1411,7 @@ copy_stencil_pixels(struct gl_context *ctx, GLint srcx, GLint srcy,
    uint8_t *buffer;
    int i;
 
-   buffer = malloc(width * height * sizeof(uint8_t));
+   buffer = malloc((size_t)width * height * sizeof(uint8_t));
    if (!buffer) {
       _mesa_error(ctx, GL_OUT_OF_MEMORY, "glCopyPixels(stencil)");
       return;
diff --git a/src/mesa/state_tracker/st_cb_readpixels.c b/src/mesa/state_tracker/st_cb_readpixels.c
index 0e4f824cd215c..6d0adf02591cb 100644
--- a/src/mesa/state_tracker/st_cb_readpixels.c
+++ b/src/mesa/state_tracker/st_cb_readpixels.c
@@ -544,7 +544,7 @@ st_ReadPixels(struct gl_context *ctx, GLint x, GLint y,
 
    /* memcpy data into a user buffer */
    {
-      const uint bytesPerRow = width * util_format_get_blocksize(dst_format);
+      const size_t bytesPerRow = (size_t)width * util_format_get_blocksize(dst_format);
       const int destStride = _mesa_image_row_stride(pack, width, format, type);
       char *dest = _mesa_image_address2d(pack, pixels,
                                          width, height, format,
diff --git a/src/mesa/state_tracker/st_cb_texture.c b/src/mesa/state_tracker/st_cb_texture.c
index 75f3803cb7449..2abdb78ecbf2e 100644
--- a/src/mesa/state_tracker/st_cb_texture.c
+++ b/src/mesa/state_tracker/st_cb_texture.c
@@ -300,7 +300,7 @@ copy_to_staging_dest(struct gl_context * ctx, struct pipe_resource *dst,
 
       assert(util_format_is_compressed(src->format));
 
-      rgba = malloc(width * height * 4 * sizeof(GLfloat));
+      rgba = malloc((size_t)width * height * 4 * sizeof(GLfloat));
       if (!rgba) {
          goto end;
       }
@@ -552,7 +552,7 @@ compressed_tex_fallback_allocate(struct st_context *st,
 
    texImage->compressed_data = CALLOC_STRUCT(st_compressed_data);
    texImage->compressed_data->ptr =
-      malloc(data_size * _mesa_num_tex_faces(texImage->TexObject->Target));
+      malloc((size_t)data_size * _mesa_num_tex_faces(texImage->TexObject->Target));
    pipe_reference_init(&texImage->compressed_data->reference, 1);
 }
 
@@ -2576,7 +2576,7 @@ st_CompressedTexSubImage(struct gl_context *ctx, GLuint dims,
          /* By incrementing layer here, we ensure the fallback only uploads
          * layers we failed to upload.
          */
-         buf_offset += addr.pixels_per_row * addr.image_height;
+         buf_offset += (size_t)addr.pixels_per_row * addr.image_height;
          layer++;
          addr.depth--;
       }
@@ -2898,7 +2898,7 @@ fallback_copy_texsubimage(struct gl_context *ctx,
    else {
       /* RGBA format */
       GLfloat *tempSrc =
-         malloc(width * height * 4 * sizeof(GLfloat));
+         malloc((size_t)width * height * 4 * sizeof(GLfloat));
 
       if (tempSrc) {
          const GLint dims = 2;
diff --git a/src/mesa/state_tracker/st_pbo.c b/src/mesa/state_tracker/st_pbo.c
index a7f71f78b5310..d792bcff4226f 100644
--- a/src/mesa/state_tracker/st_pbo.c
+++ b/src/mesa/state_tracker/st_pbo.c
@@ -76,7 +76,7 @@ st_pbo_addresses_setup(struct st_context *st,
    addr->buffer = buf;
    addr->first_element = buf_offset;
    addr->last_element = buf_offset + skip_pixels + addr->width - 1
-         + (addr->height - 1 + (addr->depth - 1) * addr->image_height) * addr->pixels_per_row;
+         + (addr->height - 1 + (addr->depth - 1) * addr->image_height) * (uint64_t)addr->pixels_per_row;
 
    if (addr->last_element - addr->first_element > st->ctx->Const.MaxTextureBufferSize - 1)
       return false;
diff --git a/src/mesa/state_tracker/st_pbo_compute.c b/src/mesa/state_tracker/st_pbo_compute.c
index 08285d00be16e..449307359e084 100644
--- a/src/mesa/state_tracker/st_pbo_compute.c
+++ b/src/mesa/state_tracker/st_pbo_compute.c
@@ -1126,7 +1126,7 @@ download_texture_compute(struct st_context *st,
                          src->target == PIPE_TEXTURE_CUBE_ARRAY ?
                          /* only use image stride for 3d images to avoid pulling in IMAGE_HEIGHT pixelstore */
                          _mesa_image_image_stride(pack, width, height, format, type) :
-                         _mesa_image_row_stride(pack, width, format, type) * height;
+                         (size_t)_mesa_image_row_stride(pack, width, format, type) * height;
    intptr_t buffer_size = (depth + (dim == 3 ? pack->SkipImages : 0)) * img_stride;
    assert(buffer_size <= UINT32_MAX);
    {
-- 
GitLab


From 4b5046b11dcdee0d4a817220bdc46de9167800da Mon Sep 17 00:00:00 2001
From: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
Date: Wed, 24 Sep 2025 09:29:01 +0200
Subject: [PATCH 03/13] mesa: fix potential overflow warnings

The multiplication of 32 bits integers will be truncated before
being widened to the destination variable' size.
Reported by static analysis.

This also removes unused debug functions.
---
 src/mesa/main/debug.c            | 473 -------------------------------
 src/mesa/main/draw.c             |   8 +-
 src/mesa/main/eval.c             |   4 +-
 src/mesa/main/format_utils.c     |   2 +-
 src/mesa/main/glthread_draw.c    |   4 +-
 src/mesa/main/image.c            |   2 +-
 src/mesa/main/mipmap.c           |   4 +-
 src/mesa/main/pack.c             |   4 +-
 src/mesa/main/readpix.c          |   7 +-
 src/mesa/main/texcompress_bptc.c |   4 +-
 src/mesa/main/texcompress_cpal.c |   2 +-
 src/mesa/main/texcompress_fxt1.c |   2 +-
 src/mesa/main/texcompress_rgtc.c |   8 +-
 src/mesa/main/texcompress_s3tc.c |  10 +-
 src/mesa/main/texgetimage.c      |   6 +-
 src/mesa/main/texstore.c         |   8 +-
 src/mesa/main/uniform_query.cpp  |   2 +-
 src/mesa/vbo/vbo_exec.c          |   2 +-
 src/mesa/vbo/vbo_save_api.c      |   8 +-
 19 files changed, 44 insertions(+), 516 deletions(-)

diff --git a/src/mesa/main/debug.c b/src/mesa/main/debug.c
index dcd35fd32b253..b2b8dbc96c4b1 100644
--- a/src/mesa/main/debug.c
+++ b/src/mesa/main/debug.c
@@ -42,36 +42,6 @@
 #include "state_tracker/st_cb_texture.h"
 #include "state_tracker/st_cb_readpixels.h"
 
-static const char *
-tex_target_name(GLenum tgt)
-{
-   static const struct {
-      GLenum target;
-      const char *name;
-   } tex_targets[] = {
-      { GL_TEXTURE_1D, "GL_TEXTURE_1D" },
-      { GL_TEXTURE_2D, "GL_TEXTURE_2D" },
-      { GL_TEXTURE_3D, "GL_TEXTURE_3D" },
-      { GL_TEXTURE_CUBE_MAP, "GL_TEXTURE_CUBE_MAP" },
-      { GL_TEXTURE_RECTANGLE, "GL_TEXTURE_RECTANGLE" },
-      { GL_TEXTURE_1D_ARRAY_EXT, "GL_TEXTURE_1D_ARRAY" },
-      { GL_TEXTURE_2D_ARRAY_EXT, "GL_TEXTURE_2D_ARRAY" },
-      { GL_TEXTURE_CUBE_MAP_ARRAY, "GL_TEXTURE_CUBE_MAP_ARRAY" },
-      { GL_TEXTURE_BUFFER, "GL_TEXTURE_BUFFER" },
-      { GL_TEXTURE_2D_MULTISAMPLE, "GL_TEXTURE_2D_MULTISAMPLE" },
-      { GL_TEXTURE_2D_MULTISAMPLE_ARRAY, "GL_TEXTURE_2D_MULTISAMPLE_ARRAY" },
-      { GL_TEXTURE_EXTERNAL_OES, "GL_TEXTURE_EXTERNAL_OES" }
-   };
-   GLuint i;
-   STATIC_ASSERT(ARRAY_SIZE(tex_targets) == NUM_TEXTURE_TARGETS);
-   for (i = 0; i < ARRAY_SIZE(tex_targets); i++) {
-      if (tex_targets[i].target == tgt)
-         return tex_targets[i].name;
-   }
-   return "UNKNOWN TEX TARGET";
-}
-
-
 void
 _mesa_print_state( const char *msg, GLuint state )
 {
@@ -231,446 +201,3 @@ _mesa_init_debug( struct gl_context *ctx )
    set_debug_flags(getenv("MESA_DEBUG"));
    set_verbose_flags(getenv("MESA_VERBOSE"));
 }
-
-
-/*
- * Write ppm file
- */
-static void
-write_ppm(const char *filename, const GLubyte *buffer, int width, int height,
-          int comps, int rcomp, int gcomp, int bcomp, GLboolean invert)
-{
-   FILE *f = fopen( filename, "w" );
-   if (f) {
-      int x, y;
-      const GLubyte *ptr = buffer;
-      fprintf(f,"P6\n");
-      fprintf(f,"# ppm-file created by osdemo.c\n");
-      fprintf(f,"%i %i\n", width,height);
-      fprintf(f,"255\n");
-      fclose(f);
-      f = fopen( filename, "ab" );  /* reopen in binary append mode */
-      if (!f) {
-         fprintf(stderr, "Error while reopening %s in write_ppm()\n",
-                 filename);
-         return;
-      }
-      for (y=0; y < height; y++) {
-         for (x = 0; x < width; x++) {
-            int yy = invert ? (height - 1 - y) : y;
-            int i = (yy * width + x) * comps;
-            fputc(ptr[i+rcomp], f); /* write red */
-            fputc(ptr[i+gcomp], f); /* write green */
-            fputc(ptr[i+bcomp], f); /* write blue */
-         }
-      }
-      fclose(f);
-   }
-   else {
-      fprintf(stderr, "Unable to create %s in write_ppm()\n", filename);
-   }
-}
-
-
-/**
- * Write a texture image to a ppm file.
- * \param face  cube face in [0,5]
- * \param level  mipmap level
- */
-static void
-write_texture_image(struct gl_texture_object *texObj,
-                    GLuint face, GLuint level)
-{
-   struct gl_texture_image *img = texObj->Image[face][level];
-   if (img) {
-      GET_CURRENT_CONTEXT(ctx);
-      struct gl_pixelstore_attrib store;
-      GLubyte *buffer;
-      char s[100];
-
-      buffer = malloc(img->Width * img->Height
-                                        * img->Depth * 4);
-
-      store = ctx->Pack; /* save */
-      ctx->Pack = ctx->DefaultPacking;
-
-      st_GetTexSubImage(ctx,
-                        0, 0, 0, img->Width, img->Height, img->Depth,
-                        GL_RGBA, GL_UNSIGNED_BYTE, buffer, img);
-
-      /* make filename */
-      snprintf(s, sizeof(s), "/tmp/tex%u.l%u.f%u.ppm", texObj->Name, level, face);
-
-      printf("  Writing image level %u to %s\n", level, s);
-      write_ppm(s, buffer, img->Width, img->Height, 4, 0, 1, 2, GL_FALSE);
-
-      ctx->Pack = store; /* restore */
-
-      free(buffer);
-   }
-}
-
-
-/**
- * Write renderbuffer image to a ppm file.
- */
-void
-_mesa_write_renderbuffer_image(const struct gl_renderbuffer *rb)
-{
-   GET_CURRENT_CONTEXT(ctx);
-   GLubyte *buffer;
-   char s[100];
-   GLenum format, type;
-
-   if (rb->_BaseFormat == GL_RGB ||
-       rb->_BaseFormat == GL_RGBA) {
-      format = GL_RGBA;
-      type = GL_UNSIGNED_BYTE;
-   }
-   else if (rb->_BaseFormat == GL_DEPTH_STENCIL) {
-      format = GL_DEPTH_STENCIL;
-      type = GL_UNSIGNED_INT_24_8;
-   }
-   else {
-      _mesa_debug(NULL,
-                  "Unsupported BaseFormat 0x%x in "
-                  "_mesa_write_renderbuffer_image()\n",
-                  rb->_BaseFormat);
-      return;
-   }
-
-   buffer = malloc(rb->Width * rb->Height * 4);
-
-   st_ReadPixels(ctx, 0, 0, rb->Width, rb->Height,
-                 format, type, &ctx->DefaultPacking, buffer);
-
-   /* make filename */
-   snprintf(s, sizeof(s), "/tmp/renderbuffer%u.ppm", rb->Name);
-   snprintf(s, sizeof(s), "C:\\renderbuffer%u.ppm", rb->Name);
-
-   printf("  Writing renderbuffer image to %s\n", s);
-
-   _mesa_debug(NULL, "  Writing renderbuffer image to %s\n", s);
-
-   write_ppm(s, buffer, rb->Width, rb->Height, 4, 0, 1, 2, GL_TRUE);
-
-   free(buffer);
-}
-
-
-/** How many texture images (mipmap levels, faces) to write to files */
-#define WRITE_NONE 0
-#define WRITE_ONE  1
-#define WRITE_ALL  2
-
-static GLuint WriteImages;
-
-
-static void
-dump_texture(struct gl_texture_object *texObj, GLuint writeImages)
-{
-   const GLuint numFaces = texObj->Target == GL_TEXTURE_CUBE_MAP ? 6 : 1;
-   GLboolean written = GL_FALSE;
-   GLuint i, j;
-
-   printf("Texture %u\n", texObj->Name);
-   printf("  Target %s\n", tex_target_name(texObj->Target));
-   for (i = 0; i < MAX_TEXTURE_LEVELS; i++) {
-      for (j = 0; j < numFaces; j++) {
-         struct gl_texture_image *texImg = texObj->Image[j][i];
-         if (texImg) {
-            printf("  Face %u level %u: %d x %d x %d, format %s\n",
-		   j, i,
-		   texImg->Width, texImg->Height, texImg->Depth,
-		   _mesa_get_format_name(texImg->TexFormat));
-            if (writeImages == WRITE_ALL ||
-                (writeImages == WRITE_ONE && !written)) {
-               write_texture_image(texObj, j, i);
-               written = GL_TRUE;
-            }
-         }
-      }
-   }
-}
-
-
-/**
- * Dump a single texture.
- */
-void
-_mesa_dump_texture(GLuint texture, GLuint writeImages)
-{
-   GET_CURRENT_CONTEXT(ctx);
-   struct gl_texture_object *texObj = _mesa_lookup_texture(ctx, texture);
-   if (texObj) {
-      dump_texture(texObj, writeImages);
-   }
-}
-
-
-static void
-dump_texture_cb(void *data, UNUSED void *userData)
-{
-   struct gl_texture_object *texObj = (struct gl_texture_object *) data;
-   dump_texture(texObj, WriteImages);
-}
-
-
-/**
- * Print basic info about all texture objext to stdout.
- * If dumpImages is true, write PPM of level[0] image to a file.
- */
-void
-_mesa_dump_textures(GLuint writeImages)
-{
-   GET_CURRENT_CONTEXT(ctx);
-   WriteImages = writeImages;
-   _mesa_HashWalk(&ctx->Shared->TexObjects, dump_texture_cb, ctx);
-}
-
-
-static void
-dump_renderbuffer(const struct gl_renderbuffer *rb, GLboolean writeImage)
-{
-   printf("Renderbuffer %u: %u x %u  IntFormat = %s\n",
-	  rb->Name, rb->Width, rb->Height,
-	  _mesa_enum_to_string(rb->InternalFormat));
-   if (writeImage) {
-      _mesa_write_renderbuffer_image(rb);
-   }
-}
-
-
-static void
-dump_renderbuffer_cb(void *data, UNUSED void *userData)
-{
-   const struct gl_renderbuffer *rb = (const struct gl_renderbuffer *) data;
-   dump_renderbuffer(rb, WriteImages);
-}
-
-
-/**
- * Print basic info about all renderbuffers to stdout.
- * If dumpImages is true, write PPM of level[0] image to a file.
- */
-void
-_mesa_dump_renderbuffers(GLboolean writeImages)
-{
-   GET_CURRENT_CONTEXT(ctx);
-   WriteImages = writeImages;
-   _mesa_HashWalk(&ctx->Shared->RenderBuffers, dump_renderbuffer_cb, ctx);
-}
-
-
-
-void
-_mesa_dump_color_buffer(const char *filename)
-{
-   GET_CURRENT_CONTEXT(ctx);
-   const GLuint w = ctx->DrawBuffer->Width;
-   const GLuint h = ctx->DrawBuffer->Height;
-   GLubyte *buf;
-
-   buf = malloc(w * h * 4);
-
-   _mesa_PushClientAttrib(GL_CLIENT_PIXEL_STORE_BIT);
-   _mesa_PixelStorei(GL_PACK_ALIGNMENT, 1);
-   _mesa_PixelStorei(GL_PACK_INVERT_MESA, GL_TRUE);
-
-   _mesa_ReadPixels(0, 0, w, h, GL_RGBA, GL_UNSIGNED_BYTE, buf);
-
-   printf("ReadBuffer %p 0x%x  DrawBuffer %p 0x%x\n",
-	  (void *) ctx->ReadBuffer->_ColorReadBuffer,
-	  ctx->ReadBuffer->ColorReadBuffer,
-	  (void *) ctx->DrawBuffer->_ColorDrawBuffers[0],
-	  ctx->DrawBuffer->ColorDrawBuffer[0]);
-   printf("Writing %d x %d color buffer to %s\n", w, h, filename);
-   write_ppm(filename, buf, w, h, 4, 0, 1, 2, GL_TRUE);
-
-   _mesa_PopClientAttrib();
-
-   free(buf);
-}
-
-
-void
-_mesa_dump_depth_buffer(const char *filename)
-{
-   GET_CURRENT_CONTEXT(ctx);
-   const GLuint w = ctx->DrawBuffer->Width;
-   const GLuint h = ctx->DrawBuffer->Height;
-   GLuint *buf;
-   GLubyte *buf2;
-   GLuint i;
-
-   buf = malloc(w * h * 4);  /* 4 bpp */
-   buf2 = malloc(w * h * 3); /* 3 bpp */
-
-   _mesa_PushClientAttrib(GL_CLIENT_PIXEL_STORE_BIT);
-   _mesa_PixelStorei(GL_PACK_ALIGNMENT, 1);
-   _mesa_PixelStorei(GL_PACK_INVERT_MESA, GL_TRUE);
-
-   _mesa_ReadPixels(0, 0, w, h, GL_DEPTH_COMPONENT, GL_UNSIGNED_INT, buf);
-
-   /* spread 24 bits of Z across R, G, B */
-   for (i = 0; i < w * h; i++) {
-      buf2[i*3+0] = (buf[i] >> 24) & 0xff;
-      buf2[i*3+1] = (buf[i] >> 16) & 0xff;
-      buf2[i*3+2] = (buf[i] >>  8) & 0xff;
-   }
-
-   printf("Writing %d x %d depth buffer to %s\n", w, h, filename);
-   write_ppm(filename, buf2, w, h, 3, 0, 1, 2, GL_TRUE);
-
-   _mesa_PopClientAttrib();
-
-   free(buf);
-   free(buf2);
-}
-
-
-void
-_mesa_dump_stencil_buffer(const char *filename)
-{
-   GET_CURRENT_CONTEXT(ctx);
-   const GLuint w = ctx->DrawBuffer->Width;
-   const GLuint h = ctx->DrawBuffer->Height;
-   GLubyte *buf;
-   GLubyte *buf2;
-   GLuint i;
-
-   buf = malloc(w * h);  /* 1 bpp */
-   buf2 = malloc(w * h * 3); /* 3 bpp */
-
-   _mesa_PushClientAttrib(GL_CLIENT_PIXEL_STORE_BIT);
-   _mesa_PixelStorei(GL_PACK_ALIGNMENT, 1);
-   _mesa_PixelStorei(GL_PACK_INVERT_MESA, GL_TRUE);
-
-   _mesa_ReadPixels(0, 0, w, h, GL_STENCIL_INDEX, GL_UNSIGNED_BYTE, buf);
-
-   for (i = 0; i < w * h; i++) {
-      buf2[i*3+0] = buf[i];
-      buf2[i*3+1] = (buf[i] & 127) * 2;
-      buf2[i*3+2] = (buf[i] - 128) * 2;
-   }
-
-   printf("Writing %d x %d stencil buffer to %s\n", w, h, filename);
-   write_ppm(filename, buf2, w, h, 3, 0, 1, 2, GL_TRUE);
-
-   _mesa_PopClientAttrib();
-
-   free(buf);
-   free(buf2);
-}
-
-
-void
-_mesa_dump_image(const char *filename, const void *image, GLuint w, GLuint h,
-                 GLenum format, GLenum type)
-{
-   GLboolean invert = GL_TRUE;
-
-   if (format == GL_RGBA && type == GL_UNSIGNED_BYTE) {
-      write_ppm(filename, image, w, h, 4, 0, 1, 2, invert);
-   }
-   else if (format == GL_BGRA && type == GL_UNSIGNED_BYTE) {
-      write_ppm(filename, image, w, h, 4, 2, 1, 0, invert);
-   }
-   else if (format == GL_LUMINANCE_ALPHA && type == GL_UNSIGNED_BYTE) {
-      write_ppm(filename, image, w, h, 2, 1, 0, 0, invert);
-   }
-   else if (format == GL_RED && type == GL_UNSIGNED_BYTE) {
-      write_ppm(filename, image, w, h, 1, 0, 0, 0, invert);
-   }
-   else if (format == GL_RGBA && type == GL_FLOAT) {
-      /* convert floats to ubyte */
-      GLubyte *buf = malloc(w * h * 4 * sizeof(GLubyte));
-      const GLfloat *f = (const GLfloat *) image;
-      GLuint i;
-      for (i = 0; i < w * h * 4; i++) {
-         UNCLAMPED_FLOAT_TO_UBYTE(buf[i], f[i]);
-      }
-      write_ppm(filename, buf, w, h, 4, 0, 1, 2, invert);
-      free(buf);
-   }
-   else if (format == GL_RED && type == GL_FLOAT) {
-      /* convert floats to ubyte */
-      GLubyte *buf = malloc(w * h * sizeof(GLubyte));
-      const GLfloat *f = (const GLfloat *) image;
-      GLuint i;
-      for (i = 0; i < w * h; i++) {
-         UNCLAMPED_FLOAT_TO_UBYTE(buf[i], f[i]);
-      }
-      write_ppm(filename, buf, w, h, 1, 0, 0, 0, invert);
-      free(buf);
-   }
-   else {
-      _mesa_problem(NULL,
-                 "Unsupported format 0x%x / type 0x%x in _mesa_dump_image()",
-                 format, type);
-   }
-}
-
-
-/**
- * Quick and dirty function to "print" a texture to stdout.
- */
-void
-_mesa_print_texture(struct gl_context *ctx, struct gl_texture_image *img)
-{
-   const GLint slice = 0;
-   GLint srcRowStride;
-   GLuint i, j, c;
-   GLubyte *data;
-
-   st_MapTextureImage(ctx, img, slice,
-                      0, 0, img->Width, img->Height, GL_MAP_READ_BIT,
-                      &data, &srcRowStride);
-
-   if (!data) {
-      printf("No texture data\n");
-   }
-   else {
-      /* XXX add more formats or make into a new format utility function */
-      switch (img->TexFormat) {
-         case MESA_FORMAT_A_UNORM8:
-         case MESA_FORMAT_L_UNORM8:
-         case MESA_FORMAT_I_UNORM8:
-            c = 1;
-            break;
-         case MESA_FORMAT_LA_UNORM8:
-            c = 2;
-            break;
-         case MESA_FORMAT_BGR_UNORM8:
-         case MESA_FORMAT_RGB_UNORM8:
-            c = 3;
-            break;
-         case MESA_FORMAT_A8B8G8R8_UNORM:
-         case MESA_FORMAT_B8G8R8A8_UNORM:
-            c = 4;
-            break;
-         default:
-            _mesa_problem(NULL, "error in PrintTexture\n");
-            return;
-      }
-
-      for (i = 0; i < img->Height; i++) {
-         for (j = 0; j < img->Width; j++) {
-            if (c==1)
-               printf("%02x  ", data[0]);
-            else if (c==2)
-               printf("%02x%02x  ", data[0], data[1]);
-            else if (c==3)
-               printf("%02x%02x%02x  ", data[0], data[1], data[2]);
-            else if (c==4)
-               printf("%02x%02x%02x%02x  ", data[0], data[1], data[2], data[3]);
-            data += (srcRowStride - img->Width) * c;
-         }
-         /* XXX use img->ImageStride here */
-         printf("\n");
-
-      }
-   }
-
-   st_UnmapTextureImage(ctx, img, slice);
-}
diff --git a/src/mesa/main/draw.c b/src/mesa/main/draw.c
index 15cbe17064f41..3aeafe5e77e8d 100644
--- a/src/mesa/main/draw.c
+++ b/src/mesa/main/draw.c
@@ -799,7 +799,7 @@ _mesa_validate_MultiDrawArraysIndirect(struct gl_context *ctx,
 
    /* number of bytes of the indirect buffer which will be read */
    size = primcount
-      ? (primcount - 1) * stride + drawArraysNumParams * sizeof(GLuint)
+      ? (primcount - 1) * (size_t)stride + drawArraysNumParams * (size_t)sizeof(GLuint)
       : 0;
 
    GLenum error = valid_draw_indirect(ctx, mode, indirect, size);
@@ -827,7 +827,7 @@ _mesa_validate_MultiDrawElementsIndirect(struct gl_context *ctx,
 
    /* number of bytes of the indirect buffer which will be read */
    size = primcount
-      ? (primcount - 1) * stride + drawElementsNumParams * sizeof(GLuint)
+      ? (primcount - 1) * (size_t)stride + drawElementsNumParams * (size_t)sizeof(GLuint)
       : 0;
 
    GLenum error = valid_draw_indirect_elements(ctx, mode, type, indirect,
@@ -893,7 +893,7 @@ _mesa_validate_MultiDrawArraysIndirectCount(struct gl_context *ctx,
 
    /* number of bytes of the indirect buffer which will be read */
    size = maxdrawcount
-      ? (maxdrawcount - 1) * stride + drawArraysNumParams * sizeof(GLuint)
+      ? (maxdrawcount - 1) * (size_t)stride + drawArraysNumParams * (size_t)sizeof(GLuint)
       : 0;
 
    GLenum error = valid_draw_indirect(ctx, mode, (void *)indirect, size);
@@ -926,7 +926,7 @@ _mesa_validate_MultiDrawElementsIndirectCount(struct gl_context *ctx,
 
    /* number of bytes of the indirect buffer which will be read */
    size = maxdrawcount
-      ? (maxdrawcount - 1) * stride + drawElementsNumParams * sizeof(GLuint)
+      ? (maxdrawcount - 1) * (size_t)stride + drawElementsNumParams * (size_t)sizeof(GLuint)
       : 0;
 
    GLenum error = valid_draw_indirect_elements(ctx, mode, type,
diff --git a/src/mesa/main/eval.c b/src/mesa/main/eval.c
index a37e10b024bd3..8108fd4f2a667 100644
--- a/src/mesa/main/eval.c
+++ b/src/mesa/main/eval.c
@@ -162,7 +162,7 @@ GLfloat *_mesa_copy_map_points1f( GLenum target, GLint ustride, GLint uorder,
    if (!points || !size)
       return NULL;
 
-   buffer = malloc(uorder * size * sizeof(GLfloat));
+   buffer = malloc((size_t)uorder * size * sizeof(GLfloat));
 
    if (buffer)
       for (i = 0, p = buffer; i < uorder; i++, points += ustride)
@@ -186,7 +186,7 @@ GLfloat *_mesa_copy_map_points1d( GLenum target, GLint ustride, GLint uorder,
    if (!points || !size)
       return NULL;
 
-   buffer = malloc(uorder * size * sizeof(GLfloat));
+   buffer = malloc((size_t)uorder * size * sizeof(GLfloat));
 
    if (buffer)
       for (i = 0, p = buffer; i < uorder; i++, points += ustride)
diff --git a/src/mesa/main/format_utils.c b/src/mesa/main/format_utils.c
index ac6f8a624be64..002c81e2fe036 100644
--- a/src/mesa/main/format_utils.c
+++ b/src/mesa/main/format_utils.c
@@ -698,7 +698,7 @@ swizzle_convert_try_memcpy(void *dst,
       if (swizzle[i] != i && swizzle[i] != MESA_FORMAT_SWIZZLE_NONE)
          return false;
 
-   memcpy(dst, src, count * num_src_channels *
+   memcpy(dst, src, (size_t)count * num_src_channels *
           _mesa_array_format_datatype_get_size(src_type));
 
    return true;
diff --git a/src/mesa/main/glthread_draw.c b/src/mesa/main/glthread_draw.c
index 1ae5ac8a9ca38..204b43dc0f2ff 100644
--- a/src/mesa/main/glthread_draw.c
+++ b/src/mesa/main/glthread_draw.c
@@ -68,7 +68,7 @@ upload_indices(struct gl_context *ctx, unsigned count, unsigned index_size,
 
    assert(count);
 
-   _mesa_glthread_upload(ctx, *indices, index_size * count,
+   _mesa_glthread_upload(ctx, *indices, index_size * (size_t)count,
                          &upload_offset, &upload_buffer, NULL, 0);
    *indices = (const GLvoid*)(intptr_t)upload_offset;
 
@@ -90,7 +90,7 @@ upload_multi_indices(struct gl_context *ctx, unsigned total_count,
 
    assert(total_count);
 
-   _mesa_glthread_upload(ctx, NULL, index_size * total_count,
+   _mesa_glthread_upload(ctx, NULL, index_size * (size_t)total_count,
                          &upload_offset, &upload_buffer, &upload_ptr, 0);
    if (!upload_buffer) {
       _mesa_marshal_InternalSetError(GL_OUT_OF_MEMORY);
diff --git a/src/mesa/main/image.c b/src/mesa/main/image.c
index 728f78aebc58b..93445b93767ec 100644
--- a/src/mesa/main/image.c
+++ b/src/mesa/main/image.c
@@ -159,7 +159,7 @@ _mesa_image_offset( GLuint dimensions,
       /* The pixel type and format should have been error checked earlier */
       assert(format == GL_COLOR_INDEX || format == GL_STENCIL_INDEX);
 
-      bytes_per_row = alignment
+      bytes_per_row = (GLintptr)alignment
                     * DIV_ROUND_UP( comp_per_pixel*pixels_per_row, 8*alignment );
 
       bytes_per_image = bytes_per_row * rows_per_image;
diff --git a/src/mesa/main/mipmap.c b/src/mesa/main/mipmap.c
index e98da79498b8f..3a5797c586e78 100644
--- a/src/mesa/main/mipmap.c
+++ b/src/mesa/main/mipmap.c
@@ -959,7 +959,7 @@ generate_mipmap_compressed(struct gl_context *ctx, GLenum target,
    temp_src_row_stride = _mesa_format_row_stride(temp_format, srcImage->Width);
    temp_src_img_stride = _mesa_format_image_size(temp_format, srcImage->Width,
                                                  srcImage->Height, 1);
-   temp_src = malloc(temp_src_img_stride * srcImage->Depth);
+   temp_src = malloc((size_t)temp_src_img_stride * srcImage->Depth);
 
    /* Allocate storage for arrays of slice pointers */
    temp_src_slices = malloc(srcImage->Depth * sizeof(GLubyte *));
@@ -1021,7 +1021,7 @@ generate_mipmap_compressed(struct gl_context *ctx, GLenum target,
       temp_dst_img_stride = _mesa_format_image_size(temp_format, dstWidth,
                                                     dstHeight, 1);
       if (!temp_dst) {
-         temp_dst = malloc(temp_dst_img_stride * dstDepth);
+         temp_dst = malloc((size_t)temp_dst_img_stride * dstDepth);
          if (!temp_dst) {
             _mesa_error(ctx, GL_OUT_OF_MEMORY, "generate mipmaps");
             goto end;
diff --git a/src/mesa/main/pack.c b/src/mesa/main/pack.c
index 179af484af24c..6bab280a75fcc 100644
--- a/src/mesa/main/pack.c
+++ b/src/mesa/main/pack.c
@@ -1240,7 +1240,7 @@ _mesa_unpack_image( GLuint dimensions,
 
    {
       GLubyte *destBuffer
-         = malloc(bytesPerRow * height * depth);
+         = malloc((size_t)bytesPerRow * height * depth);
       GLubyte *dst;
       GLint img, row;
       if (!destBuffer)
@@ -1565,7 +1565,7 @@ _mesa_unpack_color_index_to_rgba_float(struct gl_context *ctx, GLuint dims,
       return NULL;
    }
 
-   rgba = malloc(4 * count * srcDepth * sizeof(GLfloat));
+   rgba = malloc(4 * (size_t)count * srcDepth * sizeof(GLfloat));
    if (!rgba) {
       free(indexes);
       _mesa_error(ctx, GL_OUT_OF_MEMORY, "pixel unpacking");
diff --git a/src/mesa/main/readpix.c b/src/mesa/main/readpix.c
index 371114319474d..c3d924866e632 100644
--- a/src/mesa/main/readpix.c
+++ b/src/mesa/main/readpix.c
@@ -247,7 +247,8 @@ readpixels_memcpy(struct gl_context *ctx,
    struct gl_renderbuffer *rb =
          _mesa_get_read_renderbuffer_for_format(ctx, format);
    GLubyte *dst, *map;
-   int dstStride, stride, j, texelBytes, bytesPerRow;
+   int dstStride, stride, j, texelBytes;
+   size_t bytesPerRow;
 
    /* Fail if memcpy cannot be used. */
    if (!readpixels_can_use_memcpy(ctx, format, type, packing)) {
@@ -266,7 +267,7 @@ readpixels_memcpy(struct gl_context *ctx,
    }
 
    texelBytes = _mesa_get_format_bytes(rb->Format);
-   bytesPerRow = texelBytes * width;
+   bytesPerRow = (size_t)texelBytes * width;
 
    /* memcpy*/
    if (dstStride == stride && dstStride == bytesPerRow) {
@@ -533,7 +534,7 @@ read_rgba_pixels( struct gl_context *ctx,
    rgba = NULL;
    if (needs_rgba) {
       uint32_t rgba_format;
-      int rgba_stride;
+      size_t rgba_stride;
       bool need_convert;
 
       /* Convert to RGBA float or int/uint depending on the type of the src */
diff --git a/src/mesa/main/texcompress_bptc.c b/src/mesa/main/texcompress_bptc.c
index 09e2a64f76397..2102b910956dd 100644
--- a/src/mesa/main/texcompress_bptc.c
+++ b/src/mesa/main/texcompress_bptc.c
@@ -136,7 +136,7 @@ _mesa_texstore_bptc_rgba_unorm(TEXSTORE_PARAMS)
       /* convert image to RGBA/ubyte */
       GLubyte *tempImageSlices[1];
       int rgbaRowStride = 4 * srcWidth * sizeof(GLubyte);
-      tempImage = malloc(srcWidth * srcHeight * 4 * sizeof(GLubyte));
+      tempImage = malloc((size_t)srcWidth * srcHeight * 4 * sizeof(GLubyte));
       if (!tempImage)
          return GL_FALSE; /* out of memory */
       tempImageSlices[0] = (GLubyte *) tempImage;
@@ -185,7 +185,7 @@ texstore_bptc_rgb_float(TEXSTORE_PARAMS,
       /* convert image to RGB/float */
       GLfloat *tempImageSlices[1];
       int rgbRowStride = 3 * srcWidth * sizeof(GLfloat);
-      tempImage = malloc(srcWidth * srcHeight * 3 * sizeof(GLfloat));
+      tempImage = malloc((size_t)srcWidth * srcHeight * 3 * sizeof(GLfloat));
       if (!tempImage)
          return GL_FALSE; /* out of memory */
       tempImageSlices[0] = (GLfloat *) tempImage;
diff --git a/src/mesa/main/texcompress_cpal.c b/src/mesa/main/texcompress_cpal.c
index 0db3bf6536e1d..32cab9d96d49c 100644
--- a/src/mesa/main/texcompress_cpal.c
+++ b/src/mesa/main/texcompress_cpal.c
@@ -191,7 +191,7 @@ _mesa_cpal_compressed_teximage2d(GLenum target, GLint level,
 
       /* allocate and fill dest image buffer */
       if (palette) {
-         image = malloc(num_texels * info->size);
+         image = malloc((size_t)num_texels * info->size);
          paletted_to_color(info, palette, indices, num_texels, image);
       }
 
diff --git a/src/mesa/main/texcompress_fxt1.c b/src/mesa/main/texcompress_fxt1.c
index 2af091637a74d..bd35743b4ca3a 100644
--- a/src/mesa/main/texcompress_fxt1.c
+++ b/src/mesa/main/texcompress_fxt1.c
@@ -61,7 +61,7 @@ _mesa_texstore_fxt1(TEXSTORE_PARAMS)
       /* convert image to RGBA/uint8_t */
       uint8_t *tempImageSlices[1];
       int rgbaRowStride = 4 * srcWidth * sizeof(uint8_t);
-      tempImage = malloc(srcWidth * srcHeight * 4 * sizeof(uint8_t));
+      tempImage = malloc((size_t)srcWidth * srcHeight * 4 * sizeof(uint8_t));
       if (!tempImage)
          return GL_FALSE; /* out of memory */
       tempImageSlices[0] = (uint8_t *) tempImage;
diff --git a/src/mesa/main/texcompress_rgtc.c b/src/mesa/main/texcompress_rgtc.c
index 0b280377bb8c7..57e3ae37cf911 100644
--- a/src/mesa/main/texcompress_rgtc.c
+++ b/src/mesa/main/texcompress_rgtc.c
@@ -91,7 +91,7 @@ _mesa_texstore_red_rgtc1(TEXSTORE_PARAMS)
    assert(dstFormat == MESA_FORMAT_R_RGTC1_UNORM ||
           dstFormat == MESA_FORMAT_L_LATC1_UNORM);
 
-   tempImage = malloc(srcWidth * srcHeight * 1 * sizeof(GLubyte));
+   tempImage = malloc((size_t)srcWidth * srcHeight * 1 * sizeof(GLubyte));
    if (!tempImage)
       return GL_FALSE; /* out of memory */
    redRowStride = 1 * srcWidth * sizeof(GLubyte);
@@ -145,7 +145,7 @@ _mesa_texstore_signed_red_rgtc1(TEXSTORE_PARAMS)
           dstFormat == MESA_FORMAT_L_LATC1_SNORM);
 
    redRowStride = 1 * srcWidth * sizeof(GLbyte);
-   tempImage = malloc(srcWidth * srcHeight * 1 * sizeof(GLbyte));
+   tempImage = malloc((size_t)srcWidth * srcHeight * 1 * sizeof(GLbyte));
    if (!tempImage)
       return GL_FALSE; /* out of memory */
    tempImageSlices[0] = (GLbyte *) tempImage;
@@ -204,7 +204,7 @@ _mesa_texstore_rg_rgtc2(TEXSTORE_PARAMS)
       tempFormat = MESA_FORMAT_LA_UNORM8;
 
    rgRowStride = 2 * srcWidth * sizeof(GLubyte);
-   tempImage = malloc(srcWidth * srcHeight * 2 * sizeof(GLubyte));
+   tempImage = malloc((size_t)srcWidth * srcHeight * 2 * sizeof(GLubyte));
    if (!tempImage)
       return GL_FALSE; /* out of memory */
    tempImageSlices[0] = (GLubyte *) tempImage;
@@ -269,7 +269,7 @@ _mesa_texstore_signed_rg_rgtc2(TEXSTORE_PARAMS)
       tempFormat = MESA_FORMAT_LA_SNORM8;
 
    rgRowStride = 2 * srcWidth * sizeof(GLbyte);
-   tempImage = malloc(srcWidth * srcHeight * 2 * sizeof(GLbyte));
+   tempImage = malloc((size_t)srcWidth * srcHeight * 2 * sizeof(GLbyte));
    if (!tempImage)
       return GL_FALSE; /* out of memory */
    tempImageSlices[0] = (GLbyte *) tempImage;
diff --git a/src/mesa/main/texcompress_s3tc.c b/src/mesa/main/texcompress_s3tc.c
index add08aaae7c67..a39970676ffcf 100644
--- a/src/mesa/main/texcompress_s3tc.c
+++ b/src/mesa/main/texcompress_s3tc.c
@@ -60,13 +60,13 @@ _mesa_texstore_rgb_dxt1(TEXSTORE_PARAMS)
    if (!(srcFormat == GL_RGB || srcFormat == GL_RGBA) ||
        srcType != GL_UNSIGNED_BYTE ||
        ctx->_ImageTransferState ||
-       _mesa_image_row_stride(srcPacking, srcWidth, srcFormat, srcType) != srccomps * srcWidth * sizeof(GLubyte) ||
+       _mesa_image_row_stride(srcPacking, srcWidth, srcFormat, srcType) != srccomps * (size_t)srcWidth * sizeof(GLubyte) ||
        srcPacking->SkipImages ||
        srcPacking->SwapBytes) {
       /* convert image to RGB/GLubyte */
       GLubyte *tempImageSlices[1];
       int rgbRowStride = 3 * srcWidth * sizeof(GLubyte);
-      tempImage = malloc(srcWidth * srcHeight * 3 * sizeof(GLubyte));
+      tempImage = malloc((size_t)srcWidth * srcHeight * 3 * sizeof(GLubyte));
       if (!tempImage)
          return GL_FALSE; /* out of memory */
       tempImageSlices[0] = (GLubyte *) tempImage;
@@ -119,7 +119,7 @@ _mesa_texstore_rgba_dxt1(TEXSTORE_PARAMS)
        srcPacking->SwapBytes) {
       /* convert image to RGBA/GLubyte */
       GLubyte *tempImageSlices[1];
-      tempImage = malloc(srcWidth * srcHeight * 4 * sizeof(GLubyte));
+      tempImage = malloc((size_t)srcWidth * srcHeight * 4 * sizeof(GLubyte));
       if (!tempImage)
          return GL_FALSE; /* out of memory */
       tempImageSlices[0] = (GLubyte *) tempImage;
@@ -174,7 +174,7 @@ _mesa_texstore_rgba_dxt3(TEXSTORE_PARAMS)
        srcPacking->SwapBytes) {
       /* convert image to RGBA/GLubyte */
       GLubyte *tempImageSlices[1];
-      tempImage = malloc(srcWidth * srcHeight * 4 * sizeof(GLubyte));
+      tempImage = malloc((size_t)srcWidth * srcHeight * 4 * sizeof(GLubyte));
       if (!tempImage)
          return GL_FALSE; /* out of memory */
       tempImageSlices[0] = (GLubyte *) tempImage;
@@ -228,7 +228,7 @@ _mesa_texstore_rgba_dxt5(TEXSTORE_PARAMS)
        srcPacking->SwapBytes) {
       /* convert image to RGBA/GLubyte */
       GLubyte *tempImageSlices[1];
-      tempImage = malloc(srcWidth * srcHeight * 4 * sizeof(GLubyte));
+      tempImage = malloc((size_t)srcWidth * srcHeight * 4 * sizeof(GLubyte));
       if (!tempImage)
          return GL_FALSE; /* out of memory */
       tempImageSlices[0] = (GLubyte *) tempImage;
diff --git a/src/mesa/main/texgetimage.c b/src/mesa/main/texgetimage.c
index f9e223e8e66d3..03b85b6819ba9 100644
--- a/src/mesa/main/texgetimage.c
+++ b/src/mesa/main/texgetimage.c
@@ -333,7 +333,7 @@ get_tex_rgba_compressed(struct gl_context *ctx, GLuint dimensions,
    uint8_t rebaseSwizzle[4];
 
    /* Decompress into temp float buffer, then pack into user buffer */
-   tempImage = malloc(width * height * depth * 4 * sizeof(GLfloat));
+   tempImage = malloc((size_t)width * height * depth * 4 * sizeof(GLfloat));
    if (!tempImage) {
       _mesa_error(ctx, GL_OUT_OF_MEMORY, "glGetTexImage()");
       return;
@@ -508,7 +508,7 @@ get_tex_rgba_uncompressed(struct gl_context *ctx, GLuint dimensions,
          } else {
             need_convert = true;
             if (rgba == NULL) { /* Allocate the RGBA buffer only once */
-               rgba = malloc(height * rgba_stride);
+               rgba = malloc(height * (size_t)rgba_stride);
                if (!rgba) {
                   _mesa_error(ctx, GL_OUT_OF_MEMORY, "glGetTexImage()");
                   st_UnmapTextureImage(ctx, texImage, img);
@@ -664,7 +664,7 @@ get_tex_memcpy(struct gl_context *ctx,
 
       if (src) {
          if (bytesPerRow == dstRowStride && bytesPerRow == srcRowStride) {
-            memcpy(dst, src, bytesPerRow * height);
+            memcpy(dst, src, (size_t)bytesPerRow * height);
          }
          else {
             GLuint row;
diff --git a/src/mesa/main/texstore.c b/src/mesa/main/texstore.c
index d2f2d93579d3d..a1fb64fcf2139 100644
--- a/src/mesa/main/texstore.c
+++ b/src/mesa/main/texstore.c
@@ -121,7 +121,7 @@ _mesa_memcpy_texture(struct gl_context *ctx,
       GLint img;
       for (img = 0; img < srcDepth; img++) {
          GLubyte *dstImage = dstSlices[img];
-         memcpy(dstImage, srcImage, bytesPerRow * srcHeight);
+         memcpy(dstImage, srcImage, (size_t)bytesPerRow * srcHeight);
          srcImage += srcImageStride;
       }
    }
@@ -785,7 +785,7 @@ texstore_rgba(TEXSTORE_PARAMS)
                               src, srcMesaFormat, srcRowStride,
                               srcWidth, srcHeight, NULL);
          src += srcHeight * srcRowStride;
-         dst += srcHeight * 4 * srcWidth * sizeof(float);
+         dst += (size_t)srcHeight * 4 * srcWidth * sizeof(float);
       }
 
       /* Apply transferOps */
@@ -1130,7 +1130,7 @@ clear_image_to_zero(GLubyte *dstMap, GLint dstRowStride,
    GLsizei y;
 
    for (y = 0; y < height; y++) {
-      memset(dstMap, 0, clearValueSize * width);
+      memset(dstMap, 0, (size_t)clearValueSize * width);
       dstMap += dstRowStride;
    }
 }
@@ -1344,7 +1344,7 @@ _mesa_store_compressed_texsubimage(struct gl_context *ctx, GLuint dims,
          /* copy rows of blocks */
          if (dstRowStride == store.TotalBytesPerRow &&
              dstRowStride == store.CopyBytesPerRow) {
-            memcpy(dstMap, src, store.CopyBytesPerRow * store.CopyRowsPerSlice);
+            memcpy(dstMap, src, (size_t)store.CopyBytesPerRow * store.CopyRowsPerSlice);
             src += store.CopyBytesPerRow * store.CopyRowsPerSlice;
          }
          else {
diff --git a/src/mesa/main/uniform_query.cpp b/src/mesa/main/uniform_query.cpp
index 54957c0d762da..7f6d61709e5b1 100644
--- a/src/mesa/main/uniform_query.cpp
+++ b/src/mesa/main/uniform_query.cpp
@@ -877,7 +877,7 @@ _mesa_propagate_uniforms_to_driver_storage(struct gl_uniform_storage *uni,
 	       }
 	    } else {
 	       /* Unigine Heaven benchmark gets here */
-	       memcpy(dst, src, src_vector_byte_stride * vectors * count);
+	       memcpy(dst, src, (size_t)src_vector_byte_stride * vectors * count);
 	       src += src_vector_byte_stride * vectors * count;
 	       dst += store->vector_stride * vectors * count;
 	    }
diff --git a/src/mesa/vbo/vbo_exec.c b/src/mesa/vbo/vbo_exec.c
index c669fbd603f04..9ebafb5239d35 100644
--- a/src/mesa/vbo/vbo_exec.c
+++ b/src/mesa/vbo/vbo_exec.c
@@ -355,6 +355,6 @@ vbo_copy_vertices(struct gl_context *ctx,
    }
 
    memcpy(dst, src + (count - copy) * vertex_size,
-          copy * vertex_size * sizeof(GLfloat));
+          (size_t)copy * vertex_size * sizeof(GLfloat));
    return copy;
 }
diff --git a/src/mesa/vbo/vbo_save_api.c b/src/mesa/vbo/vbo_save_api.c
index 748404b2f11a2..25e7f7e58d4ad 100644
--- a/src/mesa/vbo/vbo_save_api.c
+++ b/src/mesa/vbo/vbo_save_api.c
@@ -767,8 +767,8 @@ compile_vertex_list(struct gl_context *ctx)
 
    /* How many bytes do we need to store the indices and the vertices */
    total_vert_count = vertex_to_index ? (max_index + 1) : idx;
-   unsigned total_bytes_needed = idx * sizeof(uint32_t) +
-                                 total_vert_count * save->vertex_size * sizeof(fi_type);
+   size_t total_bytes_needed = idx * sizeof(uint32_t) +
+                               (size_t)total_vert_count * save->vertex_size * sizeof(fi_type);
 
    const GLintptr old_offset = save->VAO[0] ?
       save->VAO[0]->BufferBinding[0].Offset + save->VAO[0]->VertexAttrib[VERT_ATTRIB_POS].RelativeOffset : 0;
@@ -846,10 +846,10 @@ compile_vertex_list(struct gl_context *ctx)
    /* Upload the vertices first (see buffer_offset) */
    _mesa_bufferobj_subdata(ctx,
                            save->current_bo_bytes_used,
-                           total_vert_count * save->vertex_size * sizeof(fi_type),
+                           (GLsizeiptr)total_vert_count * save->vertex_size * sizeof(fi_type),
                            vertex_to_index ? temp_vertices_buffer : save->vertex_store->buffer_in_ram,
                            node->cold->ib.obj);
-   save->current_bo_bytes_used += total_vert_count * save->vertex_size * sizeof(fi_type);
+   save->current_bo_bytes_used += (size_t)total_vert_count * save->vertex_size * sizeof(fi_type);
    node->cold->bo_bytes_used = save->current_bo_bytes_used;
 
   if (vertex_to_index) {
-- 
GitLab


From d6a5aa65c55c0b6f8d78d7a8230db16144580d55 Mon Sep 17 00:00:00 2001
From: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
Date: Wed, 24 Sep 2025 09:29:14 +0200
Subject: [PATCH 04/13] aco: fix loop counter warnings

Mixing types of different sizes in loop counter and condition
can trigger unwanted behavior. Switch loop counters to int to
fix this issue.
Reported by static analysis.
---
 src/amd/compiler/aco_lower_to_hw_instr.cpp |  8 ++++----
 src/amd/compiler/aco_scheduler.cpp         | 10 +++++-----
 2 files changed, 9 insertions(+), 9 deletions(-)

diff --git a/src/amd/compiler/aco_lower_to_hw_instr.cpp b/src/amd/compiler/aco_lower_to_hw_instr.cpp
index 1f16271fa3cc3..b456fc8c09efe 100644
--- a/src/amd/compiler/aco_lower_to_hw_instr.cpp
+++ b/src/amd/compiler/aco_lower_to_hw_instr.cpp
@@ -1819,7 +1819,7 @@ handle_operands(std::map<PhysReg, copy_operation>& copy_map, lower_context* ctx,
       for (std::pair<const PhysReg, copy_operation>& copy : copy_map) {
          if (copy.second.op.isConstant())
             continue;
-         for (uint16_t i = 0; i < it->second.bytes; i++) {
+         for (unsigned i = 0; i < it->second.bytes; i++) {
             /* distance might underflow */
             unsigned distance = it->first.reg_b + i - copy.second.op.physReg().reg_b;
             if (distance < copy.second.bytes)
@@ -1863,7 +1863,7 @@ handle_operands(std::map<PhysReg, copy_operation>& copy_map, lower_context* ctx,
                copy_map.erase(other);
 
                for (std::pair<const PhysReg, copy_operation>& other2 : copy_map) {
-                  for (uint16_t i = 0; i < other2.second.bytes; i++) {
+                  for (unsigned i = 0; i < other2.second.bytes; i++) {
                      /* distance might underflow */
                      unsigned distance_lo = other2.first.reg_b + i - lo.physReg().reg_b;
                      unsigned distance_hi = other2.first.reg_b + i - hi.physReg().reg_b;
@@ -1915,7 +1915,7 @@ handle_operands(std::map<PhysReg, copy_operation>& copy_map, lower_context* ctx,
             for (std::pair<const PhysReg, copy_operation>& copy : copy_map) {
                if (partial_copy)
                   break;
-               for (uint16_t i = 0; i < copy.second.bytes; i++) {
+               for (unsigned i = 0; i < copy.second.bytes; i++) {
                   /* distance might underflow */
                   unsigned distance = copy.first.reg_b + i - it->second.op.physReg().reg_b;
                   if (distance < it->second.bytes && copy.second.uses[i] == 1 &&
@@ -1974,7 +1974,7 @@ handle_operands(std::map<PhysReg, copy_operation>& copy_map, lower_context* ctx,
        * operand (for example, v[7:8] = v[8:9]) */
       if (did_copy && !copy.second.op.isConstant()) {
          for (std::pair<const PhysReg, copy_operation>& other : copy_map) {
-            for (uint16_t i = 0; i < other.second.bytes; i++) {
+            for (unsigned i = 0; i < other.second.bytes; i++) {
                /* distance might underflow */
                unsigned distance = other.first.reg_b + i - copy.second.op.physReg().reg_b;
                if (distance < copy.second.bytes && !copy.second.uses[distance])
diff --git a/src/amd/compiler/aco_scheduler.cpp b/src/amd/compiler/aco_scheduler.cpp
index afbb7278363d6..210d18d79db9c 100644
--- a/src/amd/compiler/aco_scheduler.cpp
+++ b/src/amd/compiler/aco_scheduler.cpp
@@ -744,7 +744,7 @@ schedule_SMEM(sched_ctx& ctx, Block* block, Instruction* current, int idx)
    assert(idx != 0);
    int window_size = SMEM_WINDOW_SIZE;
    int max_moves = SMEM_MAX_MOVES;
-   int16_t k = 0;
+   int k = 0;
 
    /* don't move s_memtime/s_memrealtime */
    if (current->opcode == aco_opcode::s_memtime || current->opcode == aco_opcode::s_memrealtime ||
@@ -890,7 +890,7 @@ schedule_VMEM(sched_ctx& ctx, Block* block, Instruction* current, int idx)
    int max_moves = VMEM_MAX_MOVES;
    int clause_max_grab_dist = VMEM_CLAUSE_MAX_GRAB_DIST;
    bool only_clauses = false;
-   int16_t k = 0;
+   int k = 0;
 
    /* first, check if we have instructions before current to move down */
    hazard_query indep_hq;
@@ -1040,7 +1040,7 @@ schedule_LDS(sched_ctx& ctx, Block* block, Instruction* current, int idx)
    assert(idx != 0);
    int window_size = LDS_WINDOW_SIZE;
    int max_moves = current->isLDSDIR() ? LDSDIR_MAX_MOVES : LDS_MAX_MOVES;
-   int16_t k = 0;
+   int k = 0;
 
    /* first, check if we have instructions before current to move down */
    hazard_query hq;
@@ -1118,7 +1118,7 @@ schedule_position_export(sched_ctx& ctx, Block* block, Instruction* current, int
    assert(idx != 0);
    int window_size = POS_EXP_WINDOW_SIZE / ctx.schedule_pos_export_div;
    int max_moves = POS_EXP_MAX_MOVES / ctx.schedule_pos_export_div;
-   int16_t k = 0;
+   int k = 0;
 
    DownwardsCursor cursor = ctx.mv.downwards_init(idx, true, false);
 
@@ -1172,7 +1172,7 @@ schedule_VMEM_store(sched_ctx& ctx, Block* block, Instruction* current, int idx)
 
    DownwardsCursor cursor = ctx.mv.downwards_init(idx, true, true);
 
-   for (int16_t k = 0; k < VMEM_STORE_CLAUSE_MAX_GRAB_DIST;) {
+   for (int k = 0; k < VMEM_STORE_CLAUSE_MAX_GRAB_DIST;) {
       aco_ptr<Instruction>& candidate = block->instructions[cursor.source_idx];
       if (!is_reorderable(candidate.get()))
          break;
-- 
GitLab


From 214273669677820a90235ab020882662ba9fd282 Mon Sep 17 00:00:00 2001
From: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
Date: Wed, 24 Sep 2025 09:30:54 +0200
Subject: [PATCH 05/13] glx: fix potential overflow warnings

The multiplication of 32 bits integers will be truncated before
being widened to the destination variable' size.
Reported by static analysis.
---
 src/glx/eval.c                  | 8 ++++----
 src/glx/indirect_vertex_array.c | 4 ++--
 src/glx/pixel.c                 | 8 ++++----
 src/glx/xfont.c                 | 2 +-
 4 files changed, 11 insertions(+), 11 deletions(-)

diff --git a/src/glx/eval.c b/src/glx/eval.c
index 78963a5408d43..4c4bc41c49421 100644
--- a/src/glx/eval.c
+++ b/src/glx/eval.c
@@ -19,7 +19,7 @@ __glFillMap1f(GLint k, GLint order, GLint stride,
 {
    if (stride == k) {
       /* Just copy the data */
-      __GLX_PUT_FLOAT_ARRAY(0, points, order * k);
+      __GLX_PUT_FLOAT_ARRAY(0, points, order * (size_t)k);
    }
    else {
       GLint i;
@@ -38,7 +38,7 @@ __glFillMap1d(GLint k, GLint order, GLint stride,
 {
    if (stride == k) {
       /* Just copy the data */
-      __GLX_PUT_DOUBLE_ARRAY(0, points, order * k);
+      __GLX_PUT_DOUBLE_ARRAY(0, points, order * (size_t)k);
    }
    else {
       GLint i;
@@ -59,7 +59,7 @@ __glFillMap2f(GLint k, GLint majorOrder, GLint minorOrder,
 
    if ((minorStride == k) && (majorStride == minorOrder * k)) {
       /* Just copy the data */
-      __GLX_MEM_COPY(data, points, majorOrder * majorStride *
+      __GLX_MEM_COPY(data, points, majorOrder * (size_t)majorStride *
                      __GLX_SIZE_FLOAT32);
       return;
    }
@@ -84,7 +84,7 @@ __glFillMap2d(GLint k, GLint majorOrder, GLint minorOrder,
 
    if ((minorStride == k) && (majorStride == minorOrder * k)) {
       /* Just copy the data */
-      __GLX_MEM_COPY(data, points, majorOrder * majorStride *
+      __GLX_MEM_COPY(data, points, majorOrder * (size_t)majorStride *
                      __GLX_SIZE_FLOAT64);
       return;
    }
diff --git a/src/glx/indirect_vertex_array.c b/src/glx/indirect_vertex_array.c
index 281d97afc86a5..9b7aea6530aa5 100644
--- a/src/glx/indirect_vertex_array.c
+++ b/src/glx/indirect_vertex_array.c
@@ -341,7 +341,7 @@ emit_element_none(GLubyte * dst,
 
    for (i = 0; i < arrays->num_arrays; i++) {
       if (arrays->arrays[i].enabled) {
-         const size_t offset = index * arrays->arrays[i].true_stride;
+         const size_t offset = index * (size_t)arrays->arrays[i].true_stride;
 
          /* The generic attributes can have more data than is in the
           * elements.  This is because a vertex array can be a 2 element,
@@ -408,7 +408,7 @@ emit_element_old(GLubyte * dst,
 
    for (i = 0; i < arrays->num_arrays; i++) {
       if (arrays->arrays[i].enabled) {
-         const size_t offset = index * arrays->arrays[i].true_stride;
+         const size_t offset = index * (size_t)arrays->arrays[i].true_stride;
 
          (void) memcpy(dst, ((GLubyte *) arrays->arrays[i].data) + offset,
                        arrays->arrays[i].element_size);
diff --git a/src/glx/pixel.c b/src/glx/pixel.c
index 237a42cc87b19..daa93a57ffd31 100644
--- a/src/glx/pixel.c
+++ b/src/glx/pixel.c
@@ -213,13 +213,13 @@ __glFillImage(struct glx_context * gc, GLint dim, GLint width, GLint height,
             if (rowSize == elementsPerRow * elementSize) {
                /* Ha!  This is mondo easy! */
                __GLX_MEM_COPY(iter2, itera,
-                              elementsPerRow * elementSize * height);
+                              (size_t)elementsPerRow * elementSize * height);
                iter2 += elementsPerRow * elementSize * height;
             }
             else {
                iter = itera;
                for (i = 0; i < height; i++) {
-                  __GLX_MEM_COPY(iter2, iter, elementsPerRow * elementSize);
+                  __GLX_MEM_COPY(iter2, iter, (size_t)elementsPerRow * elementSize);
                   iter2 += elementsPerRow * elementSize;
                   iter += rowSize;
                }
@@ -420,14 +420,14 @@ __glEmptyImage(struct glx_context * gc, GLint dim, GLint width, GLint height,
          if ((rowSize == sourceRowSize) && (sourcePadding == 0)) {
             /* Ha!  This is mondo easy! */
             __GLX_MEM_COPY(itera, sourceImage,
-                           elementsPerRow * elementSize * height);
+                           (size_t)elementsPerRow * elementSize * height);
             sourceImage += elementsPerRow * elementSize * height;
          }
          else {
             iter = itera;
             for (i = 0; i < height; i++) {
                __GLX_MEM_COPY(iter, sourceImage,
-                              elementsPerRow * elementSize);
+                              (size_t)elementsPerRow * elementSize);
                sourceImage += sourceRowSize;
                iter += rowSize;
             }
diff --git a/src/glx/xfont.c b/src/glx/xfont.c
index 472dfb5dfc1de..3950af280ebbd 100644
--- a/src/glx/xfont.c
+++ b/src/glx/xfont.c
@@ -265,7 +265,7 @@ DRI_glXUseXFont(struct glx_context *CC, Font font, int first, int count, int lis
       CALL_NewList(GET_DISPATCH(), (list, GL_COMPILE));
       if (valid && (bm_width > 0) && (bm_height > 0)) {
 
-         memset(bm, '\0', bm_width * bm_height);
+         memset(bm, '\0', (size_t)bm_width * bm_height);
          fill_bitmap(dpy, screen, gc, bm_width, bm_height, x, y, c, bm);
 
          CALL_Bitmap(GET_DISPATCH(), (width, height, x0, y0, dx, dy, bm));
-- 
GitLab


From 6d837cb2a40471a23e45501449348836b2b383c4 Mon Sep 17 00:00:00 2001
From: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
Date: Wed, 24 Sep 2025 09:31:17 +0200
Subject: [PATCH 06/13] llvmpipe: fix potential overflow warnings

The multiplication of 32 bits integers will be truncated before
being widened to the destination variable' size.
Reported by static analysis.
---
 src/gallium/drivers/llvmpipe/lp_rast_tri_tmp.h | 10 +++++-----
 src/gallium/drivers/llvmpipe/lp_state_cs.c     | 13 ++++++++-----
 src/gallium/drivers/llvmpipe/lp_state_fs.c     |  9 +++++----
 src/gallium/drivers/llvmpipe/lp_texture.c      |  4 ++--
 4 files changed, 20 insertions(+), 16 deletions(-)

diff --git a/src/gallium/drivers/llvmpipe/lp_rast_tri_tmp.h b/src/gallium/drivers/llvmpipe/lp_rast_tri_tmp.h
index b13af28f37662..1ffdb015ffc23 100644
--- a/src/gallium/drivers/llvmpipe/lp_rast_tri_tmp.h
+++ b/src/gallium/drivers/llvmpipe/lp_rast_tri_tmp.h
@@ -385,7 +385,7 @@ TRI_16(struct lp_rasterizer_task *task,
       cstep4[j][3] = _mm_add_epi32(cstep4[j][2], xdcdy);
 
       {
-         const int c = plane[j].c + plane[j].dcdy * y - plane[j].dcdx * x;
+         const int c = plane[j].c + (int64_t)plane[j].dcdy * y - (int64_t)plane[j].dcdx * x;
          const int cox = plane[j].eo * 4;
 
          outmask |= sign_bits4(cstep4[j], c + cox);
@@ -415,8 +415,8 @@ TRI_16(struct lp_rasterizer_task *task,
 
       for (unsigned j = 0; j < NR_PLANES; j++) {
          const int cx = (plane[j].c - 1
-                         - plane[j].dcdx * px
-                         + plane[j].dcdy * py) * 4;
+                         - (int64_t)plane[j].dcdx * px
+                         + (int64_t)plane[j].dcdy * py) * 4;
 
          mask &= ~sign_bits4(cstep4[j], cx);
       }
@@ -445,8 +445,8 @@ TRI_4(struct lp_rasterizer_task *task,
 
    for (unsigned j = 0; j < NR_PLANES; j++) {
       const int cx = (plane[j].c
-                      - plane[j].dcdx * x
-                      + plane[j].dcdy * y);
+                      - (int64_t)plane[j].dcdx * x
+                      + (int64_t)plane[j].dcdy * y);
 
       const int dcdx = -plane[j].dcdx;
       const int dcdy = plane[j].dcdy;
diff --git a/src/gallium/drivers/llvmpipe/lp_state_cs.c b/src/gallium/drivers/llvmpipe/lp_state_cs.c
index 916cf362c2e18..22d6c674bc7a9 100644
--- a/src/gallium/drivers/llvmpipe/lp_state_cs.c
+++ b/src/gallium/drivers/llvmpipe/lp_state_cs.c
@@ -1805,7 +1805,8 @@ llvmpipe_launch_grid(struct pipe_context *pipe,
       lp_cs_tpool_wait_for_task(screen->cs_tpool, &task);
    }
    if (!llvmpipe->queries_disabled)
-      llvmpipe->pipeline_statistics.cs_invocations += num_tasks * info->block[0] * info->block[1] * info->block[2];
+      llvmpipe->pipeline_statistics.cs_invocations +=
+         (uint64_t)num_tasks * info->block[0] * info->block[1] * info->block[2];
 }
 
 
@@ -2167,8 +2168,8 @@ llvmpipe_draw_mesh_tasks(struct pipe_context *pipe,
    int per_vert_count = out_count - per_prim_count;
    int vsize = (sizeof(struct vertex_header) + per_vert_count * 4 * sizeof(float)) * 8;
    int psize = (per_prim_count * 4 * sizeof(float)) * 8;
-   size_t prim_offset = vsize * (mhs_shader->info.mesh.max_vertices_out + 8);
-   size_t task_out_size = prim_offset + psize * (mhs_shader->info.mesh.max_primitives_out + 8);
+   size_t prim_offset = (size_t)vsize * (mhs_shader->info.mesh.max_vertices_out + 8);
+   size_t task_out_size = prim_offset + (size_t)psize * (mhs_shader->info.mesh.max_primitives_out + 8);
 
    for (unsigned dr = 0; dr < draw_count; dr++) {
       fill_grid_size(pipe, dr, info, job_info.grid_size);
@@ -2207,7 +2208,8 @@ llvmpipe_draw_mesh_tasks(struct pipe_context *pipe,
             lp_cs_tpool_wait_for_task(screen->cs_tpool, &task);
          }
          if (!lp->queries_disabled)
-            lp->pipeline_statistics.ts_invocations += num_tasks * info->block[0] * info->block[1] * info->block[2];
+            lp->pipeline_statistics.ts_invocations +=
+               (uint64_t)num_tasks * info->block[0] * info->block[1] * info->block[2];
          num_mesh_invocs = num_tasks;
       }
 
@@ -2271,7 +2273,8 @@ llvmpipe_draw_mesh_tasks(struct pipe_context *pipe,
                      lp_cs_tpool_wait_for_task(screen->cs_tpool, &task);
                   }
                   if (!lp->queries_disabled)
-                     lp->pipeline_statistics.ms_invocations += num_tasks * job_info.block_size[0] * job_info.block_size[1] * job_info.block_size[2];
+                     lp->pipeline_statistics.ms_invocations +=
+                        (uint64_t)num_tasks * job_info.block_size[0] * job_info.block_size[1] * job_info.block_size[2];
 
                   for (unsigned t = 0; t < num_tasks; t++)
                      lp_mesh_call_draw(lp,
diff --git a/src/gallium/drivers/llvmpipe/lp_state_fs.c b/src/gallium/drivers/llvmpipe/lp_state_fs.c
index 5e1384210b84d..efde93a6e5f34 100644
--- a/src/gallium/drivers/llvmpipe/lp_state_fs.c
+++ b/src/gallium/drivers/llvmpipe/lp_state_fs.c
@@ -460,7 +460,7 @@ lp_build_sample_alpha_to_coverage(struct gallivm_state *gallivm,
 
    lp_build_context_init(&bld, gallivm, type);
    for (unsigned s = 0; s < coverage_samples; s++) {
-      LLVMValueRef alpha_ref_value = lp_build_const_vec(gallivm, type, step * s);
+      LLVMValueRef alpha_ref_value = lp_build_const_vec(gallivm, type, (double)step * s);
       LLVMValueRef test = lp_build_cmp(&bld, PIPE_FUNC_GREATER, alpha, alpha_ref_value);
 
       LLVMValueRef s_mask_idx = LLVMBuildMul(builder, lp_build_const_int32(gallivm, s), num_loop, "");
@@ -1479,7 +1479,7 @@ generate_fs_twiddle(struct gallivm_state *gallivm,
    unsigned src_count = num_fs * src_channels;
 
    assert(pixels == 2 || pixels == 1);
-   assert(num_fs * src_channels <= ARRAY_SIZE(src));
+   assert(num_fs * src_channels <= (unsigned)ARRAY_SIZE(src));
 
    /*
     * Transpose from SoA -> AoS
@@ -2128,7 +2128,8 @@ convert_to_blend_type(struct gallivm_state *gallivm,
          /* Insert bits into correct position */
          chans = LLVMBuildShl(builder,
                               chans,
-                              lp_build_const_int_vec(gallivm, src_type, from_lsb * blend_type.width),
+                              lp_build_const_int_vec(gallivm, src_type,
+                                                     (long long)from_lsb * blend_type.width),
                               "");
 
          if (j == 0) {
@@ -2298,7 +2299,7 @@ convert_from_blend_type(struct gallivm_state *gallivm,
          chans = LLVMBuildLShr(builder,
                                dst[i],
                                lp_build_const_int_vec(gallivm, src_type,
-                                                      from_lsb * blend_type.width),
+                                                      from_lsb * (long long)blend_type.width),
                                "");
 
          chans = LLVMBuildAnd(builder,
diff --git a/src/gallium/drivers/llvmpipe/lp_texture.c b/src/gallium/drivers/llvmpipe/lp_texture.c
index 241b8786c9925..9fdb7b5328300 100644
--- a/src/gallium/drivers/llvmpipe/lp_texture.c
+++ b/src/gallium/drivers/llvmpipe/lp_texture.c
@@ -748,7 +748,7 @@ llvmpipe_resource_from_handle(struct pipe_screen *_screen,
    if (whandle->type == WINSYS_HANDLE_TYPE_UNBACKED && whandle->image_stride)
       lpr->img_stride[0] = whandle->image_stride;
    else
-      lpr->img_stride[0] = whandle->stride * nblocksy;
+      lpr->img_stride[0] = (uint64_t)whandle->stride * nblocksy;
    lpr->sample_stride = lpr->img_stride[0];
    lpr->size_required = lpr->sample_stride;
 
@@ -1017,7 +1017,7 @@ llvmpipe_transfer_map_ms(struct pipe_context *pipe,
 
       uint32_t block_stride = util_format_get_blocksize(format);
       pt->stride = lpt->block_box.width * block_stride;
-      pt->layer_stride = pt->stride * lpt->block_box.height;
+      pt->layer_stride = (uint64_t)pt->stride * lpt->block_box.height;
 
       uint8_t *staging_map = malloc(pt->layer_stride * lpt->block_box.depth);
       lpt->map = staging_map;
-- 
GitLab


From 9a94006d50a4ddd5b08bc4e6fa89f8ba3bac8418 Mon Sep 17 00:00:00 2001
From: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
Date: Wed, 24 Sep 2025 09:31:39 +0200
Subject: [PATCH 07/13] radeonsi: fix potential overflow warnings

The multiplication of 32 bits integers will be truncated before
being widened to the destination variable' size.
Reported by static analysis.
---
 src/gallium/drivers/radeonsi/radeon_vcn_enc.c  | 2 +-
 src/gallium/drivers/radeonsi/si_shader.c       | 2 +-
 src/gallium/drivers/radeonsi/si_state_draw.cpp | 2 +-
 3 files changed, 3 insertions(+), 3 deletions(-)

diff --git a/src/gallium/drivers/radeonsi/radeon_vcn_enc.c b/src/gallium/drivers/radeonsi/radeon_vcn_enc.c
index c57d9cd3e82a9..1bf6b4ff934c4 100644
--- a/src/gallium/drivers/radeonsi/radeon_vcn_enc.c
+++ b/src/gallium/drivers/radeonsi/radeon_vcn_enc.c
@@ -1424,7 +1424,7 @@ static uint32_t roi_buffer_size(struct radeon_encoder *enc)
       qp_map->qp_map_pitch = pitch_size_in_dword * 2;
    }
 
-   return pitch_size_in_dword * qp_map->height_in_block * sizeof(uint32_t);
+   return pitch_size_in_dword * qp_map->height_in_block * (uint32_t)sizeof(uint32_t);
 }
 
 static void arrange_qp_map(void *start,
diff --git a/src/gallium/drivers/radeonsi/si_shader.c b/src/gallium/drivers/radeonsi/si_shader.c
index 82ee5f6ed531d..cbac1d7107804 100644
--- a/src/gallium/drivers/radeonsi/si_shader.c
+++ b/src/gallium/drivers/radeonsi/si_shader.c
@@ -650,7 +650,7 @@ static void si_calculate_max_simd_waves(struct si_shader *shader)
       unsigned num_vgprs = conf->num_vgprs;
       if (sscreen->info.gfx_level >= GFX10_3) {
          unsigned real_vgpr_gran = sscreen->info.num_physical_wave64_vgprs_per_simd / 64;
-         num_vgprs = util_align_npot(num_vgprs, real_vgpr_gran * (shader->wave_size == 32 ? 2 : 1));
+         num_vgprs = util_align_npot(num_vgprs, (size_t)real_vgpr_gran * (shader->wave_size == 32 ? 2 : 1));
       } else {
          num_vgprs = align(num_vgprs, shader->wave_size == 32 ? 8 : 4);
       }
diff --git a/src/gallium/drivers/radeonsi/si_state_draw.cpp b/src/gallium/drivers/radeonsi/si_state_draw.cpp
index 5ec4d78dfd957..70ead87d95377 100644
--- a/src/gallium/drivers/radeonsi/si_state_draw.cpp
+++ b/src/gallium/drivers/radeonsi/si_state_draw.cpp
@@ -2003,7 +2003,7 @@ static void si_get_draw_start_count(struct si_context *sctx, const struct pipe_d
          return;
       }
 
-      map_size = (indirect_count - 1) * indirect->stride + 3 * sizeof(unsigned);
+      map_size = (indirect_count - 1) * indirect->stride + 3 * (unsigned)sizeof(unsigned);
       data = (unsigned*)
              pipe_buffer_map_range(&sctx->b, indirect->buffer, indirect->offset, map_size,
                                    PIPE_MAP_READ, &transfer);
-- 
GitLab


From b9e69256d26b97583ecb24a5331256e6bc19866c Mon Sep 17 00:00:00 2001
From: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
Date: Wed, 24 Sep 2025 09:31:58 +0200
Subject: [PATCH 08/13] gallium/aux: fix potential overflow warnings

The multiplication of 32 bits integers will be truncated before
being widened to the destination variable' size.
Reported by static analysis.
---
 src/gallium/auxiliary/draw/draw_gs.c           |  6 +++---
 src/gallium/auxiliary/draw/draw_private.h      |  2 +-
 src/gallium/auxiliary/gallivm/lp_bld_nir_soa.c | 15 +++++++++------
 src/gallium/auxiliary/indices/u_primconvert.c  |  2 +-
 src/gallium/auxiliary/util/u_draw.c            |  2 +-
 src/gallium/auxiliary/util/u_framebuffer.c     |  2 +-
 src/gallium/auxiliary/util/u_vbuf.c            |  2 +-
 7 files changed, 17 insertions(+), 14 deletions(-)

diff --git a/src/gallium/auxiliary/draw/draw_gs.c b/src/gallium/auxiliary/draw/draw_gs.c
index 85d38465819a8..a438791c3e868 100644
--- a/src/gallium/auxiliary/draw/draw_gs.c
+++ b/src/gallium/auxiliary/draw/draw_gs.c
@@ -324,7 +324,7 @@ llvm_fetch_gs_outputs(struct draw_geometry_shader *shader,
    output_ptr += shader->stream[stream].emitted_vertices * shader->vertex_size;
    for (int i = 0; i < shader->vector_length - 1; ++i) {
       int current_verts = shader->llvm_emitted_vertices[i + (stream * shader->vector_length)];
-      int next_verts = shader->llvm_emitted_vertices[i + 1 + (stream * shader->vector_length)];
+      size_t next_verts = shader->llvm_emitted_vertices[i + 1 + (stream * shader->vector_length)];
 #if 0
       int j;
       for (j = 0; j < current_verts; ++j) {
@@ -598,7 +598,7 @@ draw_geometry_shader_run(struct draw_geometry_shader *shader,
                                                  num_input_verts)),
             shader->vector_length);
    //Assume at least one primitive
-   const unsigned max_out_prims =
+   const size_t max_out_prims =
       MAX2(1, u_decomposed_prims_for_vertices(shader->output_primitive,
                                               shader->max_output_vertices)
            * num_in_primitives);
@@ -902,7 +902,7 @@ draw_create_geometry_shader(struct draw_context *draw,
 
 #if DRAW_LLVM_AVAILABLE
    if (use_llvm) {
-      int vector_size = gs->vector_length * sizeof(float);
+      size_t vector_size = gs->vector_length * sizeof(float);
       gs->gs_input = align_malloc(sizeof(struct draw_gs_inputs), 16);
       memset(gs->gs_input, 0, sizeof(struct draw_gs_inputs));
       gs->llvm_prim_lengths = 0;
diff --git a/src/gallium/auxiliary/draw/draw_private.h b/src/gallium/auxiliary/draw/draw_private.h
index 75fc76fea74e3..9570553626a1c 100644
--- a/src/gallium/auxiliary/draw/draw_private.h
+++ b/src/gallium/auxiliary/draw/draw_private.h
@@ -91,7 +91,7 @@ struct gallivm_state;
  * more vertex attributes than allocated.
  */
 #define DRAW_EXTRA_VERTICES_PADDING \
-   (DRAW_MAX_EXTRA_SHADER_OUTPUTS * sizeof(float[4]))
+   (DRAW_MAX_EXTRA_SHADER_OUTPUTS * (int)sizeof(float[4]))
 
 struct pipe_context;
 struct draw_vertex_shader;
diff --git a/src/gallium/auxiliary/gallivm/lp_bld_nir_soa.c b/src/gallium/auxiliary/gallivm/lp_bld_nir_soa.c
index aa3c167dd9ff3..a2ffbe67ab133 100644
--- a/src/gallium/auxiliary/gallivm/lp_bld_nir_soa.c
+++ b/src/gallium/auxiliary/gallivm/lp_bld_nir_soa.c
@@ -2642,7 +2642,7 @@ static LLVMValueRef get_scratch_thread_offsets(struct gallivm_state *gallivm,
       return LLVMConstInt(elem_type, 0, 0);
 
    for (i = 0; i < type.length; ++i)
-      elems[i] = LLVMConstInt(elem_type, scratch_size * i, 0);
+      elems[i] = LLVMConstInt(elem_type, (size_t)scratch_size * i, 0);
 
    return LLVMConstVector(elems, type.length);
 }
@@ -4678,7 +4678,8 @@ visit_load_global(struct lp_build_nir_soa_context *bld,
 
    LLVMValueRef mask = mask_vec_with_helpers(bld);
    for (unsigned c = 0; c < instr->def.num_components; c++) {
-      LLVMValueRef chan_offset = lp_build_const_int_vec(gallivm, uint_bld->type, c * (instr->def.bit_size / 8));
+      int chan = c * (instr->def.bit_size / 8);
+      LLVMValueRef chan_offset = lp_build_const_int_vec(gallivm, uint_bld->type, chan);
 
       result[c] = lp_build_masked_gather(gallivm, res_bld->type.length, instr->def.bit_size, res_bld->vec_type,
                                          lp_vec_add_offset_ptr(bld, instr->def.bit_size, addr, chan_offset),
@@ -4708,7 +4709,8 @@ visit_store_global(struct lp_build_nir_soa_context *bld,
       if (!(writemask & (1u << c)))
          continue;
       LLVMValueRef val = dst[c];
-      LLVMValueRef chan_offset = lp_build_const_int_vec(gallivm, uint_bld->type, c * (bit_size / 8));
+      int chan = c * (bit_size / 8);
+      LLVMValueRef chan_offset = lp_build_const_int_vec(gallivm, uint_bld->type, chan);
 
       struct lp_build_context *out_bld = get_int_bld(bld, false, bit_size, lp_value_is_divergent(val));
       val = LLVMBuildBitCast(builder, val, out_bld->vec_type, "");
@@ -4896,7 +4898,8 @@ visit_load_scratch(struct lp_build_nir_soa_context *bld,
    offset = lp_build_add(uint_bld, offset, thread_offsets);
 
    for (unsigned c = 0; c < instr->def.num_components; c++) {
-      LLVMValueRef chan_offset = lp_build_add(uint_bld, offset, lp_build_const_int_vec(gallivm, uint_bld->type, c * (instr->def.bit_size / 8)));
+      int chan = c * (instr->def.bit_size / 8);
+      LLVMValueRef chan_offset = lp_build_add(uint_bld, offset, lp_build_const_int_vec(gallivm, uint_bld->type, chan));
 
       result[c] = lp_build_masked_gather(gallivm, load_bld->type.length, instr->def.bit_size,
                                          load_bld->vec_type,
@@ -4937,8 +4940,8 @@ visit_store_scratch(struct lp_build_nir_soa_context *bld,
       if (!(writemask & (1u << c)))
          continue;
       LLVMValueRef val = dst[c];
-
-      LLVMValueRef chan_offset = lp_build_add(uint_bld, offset, lp_build_const_int_vec(gallivm, uint_bld->type, c * (bit_size / 8)));
+      int chan = c * (bit_size / 8);
+      LLVMValueRef chan_offset = lp_build_add(uint_bld, offset, lp_build_const_int_vec(gallivm, uint_bld->type, chan));
 
       val = LLVMBuildBitCast(builder, val, store_bld->vec_type, "");
 
diff --git a/src/gallium/auxiliary/indices/u_primconvert.c b/src/gallium/auxiliary/indices/u_primconvert.c
index 3e6afc92bc102..3d66a64a5ba9a 100644
--- a/src/gallium/auxiliary/indices/u_primconvert.c
+++ b/src/gallium/auxiliary/indices/u_primconvert.c
@@ -191,7 +191,7 @@ primconvert_init_draw(struct primconvert_context *pc,
           *         if no indices were found, this was a single incomplete restart and can be discarded
           */
          if (total_index_count)
-            rewrite_buffer = malloc(index_size * total_index_count);
+            rewrite_buffer = malloc((size_t)index_size * total_index_count);
          if (!rewrite_buffer) {
             if (src_transfer)
                pipe_buffer_unmap(pc->pipe, src_transfer);
diff --git a/src/gallium/auxiliary/util/u_draw.c b/src/gallium/auxiliary/util/u_draw.c
index 1fe85dafbb409..c5c0764548a19 100644
--- a/src/gallium/auxiliary/util/u_draw.c
+++ b/src/gallium/auxiliary/util/u_draw.c
@@ -161,7 +161,7 @@ util_draw_indirect_read(struct pipe_context *pipe,
    if (!draws)
       return NULL;
 
-   unsigned map_size = (draw_count - 1) * indirect->stride + (num_params * sizeof(uint32_t));
+   unsigned map_size = (draw_count - 1) * indirect->stride + (num_params * (unsigned)sizeof(uint32_t));
    params = pipe_buffer_map_range(pipe,
                                   indirect->buffer,
                                   indirect->offset,
diff --git a/src/gallium/auxiliary/util/u_framebuffer.c b/src/gallium/auxiliary/util/u_framebuffer.c
index ff9a1b0dfa4b5..1b7c725a28706 100644
--- a/src/gallium/auxiliary/util/u_framebuffer.c
+++ b/src/gallium/auxiliary/util/u_framebuffer.c
@@ -276,7 +276,7 @@ util_sample_locations_flip_y(struct pipe_screen *screen, unsigned fb_height,
       }
    }
 
-   memcpy(locations, new_locations, grid_width * grid_height * samples);
+   memcpy(locations, new_locations, (size_t)grid_width * grid_height * samples);
 }
 
 void
diff --git a/src/gallium/auxiliary/util/u_vbuf.c b/src/gallium/auxiliary/util/u_vbuf.c
index 882f683e2a39f..aaffecc0bb9b2 100644
--- a/src/gallium/auxiliary/util/u_vbuf.c
+++ b/src/gallium/auxiliary/util/u_vbuf.c
@@ -484,7 +484,7 @@ u_vbuf_translate_buffers(struct u_vbuf *mgr, struct translate_key *key,
          map = (uint8_t*)vb->buffer.user + offset;
       } else {
          unsigned size = stride ? num_vertices * stride
-                                    : sizeof(double)*4;
+                                    : (unsigned)sizeof(double)*4;
 
          if (!vb->buffer.resource) {
             static uint64_t dummy_buf[4] = { 0 };
-- 
GitLab


From 1d3ff844ffaad5253931442b20da0575981c7017 Mon Sep 17 00:00:00 2001
From: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
Date: Wed, 24 Sep 2025 09:32:09 +0200
Subject: [PATCH 09/13] nir: fix potential overflow warnings

The multiplication of 32 bits integers will be truncated before
being widened to the destination variable' size.
Reported by static analysis.
---
 src/compiler/nir/nir_range_analysis.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/compiler/nir/nir_range_analysis.c b/src/compiler/nir/nir_range_analysis.c
index 0d65ecab8cf63..4b4e2682cb16d 100644
--- a/src/compiler/nir/nir_range_analysis.c
+++ b/src/compiler/nir/nir_range_analysis.c
@@ -1516,7 +1516,7 @@ mul_clamp(uint32_t a, uint32_t b)
    if (a != 0 && (a * b) / a != b)
       return (uint64_t)UINT32_MAX + 1;
    else
-      return a * b;
+      return a * (uint64_t)b;
 }
 
 /* recursively gather at most "buf_size" phi/bcsel sources */
-- 
GitLab


From 0d6bb5e0898f4b36d8d88091cdc8aaaf4bb05b5b Mon Sep 17 00:00:00 2001
From: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
Date: Tue, 23 Sep 2025 17:10:41 +0200
Subject: [PATCH 10/13] radv: fix potential overflow warnings

The multiplication of 32 bits integers will be truncated before
being widened to the destination variable' size.
Reported by static analysis.
---
 src/amd/vulkan/meta/radv_meta_bufimage.c |  3 +-
 src/amd/vulkan/meta/radv_meta_clear.c    | 14 +++---
 src/amd/vulkan/nir/radv_nir_rt_common.c  | 16 +++----
 src/amd/vulkan/nir/radv_nir_rt_shader.c  |  7 +--
 src/amd/vulkan/radv_cmd_buffer.c         |  8 ++--
 src/amd/vulkan/radv_descriptor_pool.c    |  9 ++--
 src/amd/vulkan/radv_dgc.c                |  2 +-
 src/amd/vulkan/radv_host_image_copy.c    |  4 +-
 src/amd/vulkan/radv_image_view.c         |  2 +-
 src/amd/vulkan/radv_perfcounter.c        |  2 +-
 src/amd/vulkan/radv_query.c              | 56 ++++++++++++------------
 src/amd/vulkan/radv_queue.c              |  2 +-
 src/amd/vulkan/radv_sdma.c               |  8 ++--
 src/amd/vulkan/radv_shader.c             |  2 +-
 src/amd/vulkan/radv_video_enc.c          |  7 +--
 15 files changed, 74 insertions(+), 68 deletions(-)

diff --git a/src/amd/vulkan/meta/radv_meta_bufimage.c b/src/amd/vulkan/meta/radv_meta_bufimage.c
index 05c0a77248d27..9863c56f0f9db 100644
--- a/src/amd/vulkan/meta/radv_meta_bufimage.c
+++ b/src/amd/vulkan/meta/radv_meta_bufimage.c
@@ -663,7 +663,8 @@ fixup_gfx9_cs_copy(struct radv_cmd_buffer *cmd_buffer, const struct radv_meta_bl
                                        img_bsurf->layer, image->vk.image_type == VK_IMAGE_TYPE_3D);
          const uint64_t img_va = image->bindings[0].addr + img_offset;
          /* buf_bsurf->offset already includes the layer offset */
-         const uint64_t mem_va = buf_bsurf->addr + buf_bsurf->offset + y * buf_bsurf->pitch * surf->bpe + x * surf->bpe;
+         const uint64_t mem_va =
+            buf_bsurf->addr + buf_bsurf->offset + y * (uint64_t)buf_bsurf->pitch * surf->bpe + (uint64_t)x * surf->bpe;
          if (to_image) {
             radv_copy_memory(cmd_buffer, mem_va, img_va, surf->bpe, mem_copy_flags, img_copy_flags);
          } else {
diff --git a/src/amd/vulkan/meta/radv_meta_clear.c b/src/amd/vulkan/meta/radv_meta_clear.c
index e6088361e12eb..41f2c47bb7610 100644
--- a/src/amd/vulkan/meta/radv_meta_clear.c
+++ b/src/amd/vulkan/meta/radv_meta_clear.c
@@ -857,7 +857,7 @@ radv_clear_cmask(struct radv_cmd_buffer *cmd_buffer, struct radv_image *image, c
       /* TODO: clear layers. */
       size = image->planes[0].surface.cmask_size;
    } else {
-      unsigned slice_size = image->planes[0].surface.cmask_slice_size;
+      uint64_t slice_size = image->planes[0].surface.cmask_slice_size;
 
       cmask_offset += slice_size * range->baseArrayLayer;
       size = slice_size * vk_image_subresource_layer_count(&image->vk, range);
@@ -871,7 +871,7 @@ radv_clear_fmask(struct radv_cmd_buffer *cmd_buffer, struct radv_image *image, c
                  uint32_t value)
 {
    uint64_t fmask_offset = image->planes[0].surface.fmask_offset;
-   unsigned slice_size = image->planes[0].surface.fmask_slice_size;
+   uint64_t slice_size = image->planes[0].surface.fmask_slice_size;
    uint64_t size;
 
    /* MSAA images do not support mipmap levels. */
@@ -905,7 +905,7 @@ radv_clear_dcc(struct radv_cmd_buffer *cmd_buffer, struct radv_image *image, con
          /* DCC for mipmaps+layers is currently disabled. */
          dcc_offset += image->planes[0].surface.meta_slice_size * range->baseArrayLayer +
                        image->planes[0].surface.u.gfx9.meta_levels[level].offset;
-         size = image->planes[0].surface.u.gfx9.meta_levels[level].size * layer_count;
+         size = (uint64_t)image->planes[0].surface.u.gfx9.meta_levels[level].size * layer_count;
       } else if (pdev->info.gfx_level == GFX9) {
          /* Mipmap levels and layers aren't implemented. */
          assert(level == 0);
@@ -920,7 +920,7 @@ radv_clear_dcc(struct radv_cmd_buffer *cmd_buffer, struct radv_image *image, con
           * level can't be fast cleared.
           */
          dcc_offset += dcc_level->dcc_offset + dcc_level->dcc_slice_fast_clear_size * range->baseArrayLayer;
-         size = dcc_level->dcc_slice_fast_clear_size * vk_image_subresource_layer_count(&image->vk, range);
+         size = (uint64_t)dcc_level->dcc_slice_fast_clear_size * vk_image_subresource_layer_count(&image->vk, range);
       }
 
       /* Do not clear this level if it can't be compressed. */
@@ -1164,9 +1164,9 @@ radv_clear_htile(struct radv_cmd_buffer *cmd_buffer, const struct radv_image *im
       }
    } else {
       unsigned layer_count = vk_image_subresource_layer_count(&image->vk, range);
-      uint64_t size = image->planes[0].surface.meta_slice_size * layer_count;
-      uint64_t htile_offset =
-         image->planes[0].surface.meta_offset + image->planes[0].surface.meta_slice_size * range->baseArrayLayer;
+      uint64_t size = (uint64_t)image->planes[0].surface.meta_slice_size * layer_count;
+      uint64_t htile_offset = image->planes[0].surface.meta_offset +
+                              (uint64_t)image->planes[0].surface.meta_slice_size * range->baseArrayLayer;
 
       if (htile_mask == UINT_MAX) {
          /* Clear the whole HTILE buffer. */
diff --git a/src/amd/vulkan/nir/radv_nir_rt_common.c b/src/amd/vulkan/nir/radv_nir_rt_common.c
index 3f42c5c549401..3f728a04444ea 100644
--- a/src/amd/vulkan/nir/radv_nir_rt_common.c
+++ b/src/amd/vulkan/nir/radv_nir_rt_common.c
@@ -921,8 +921,8 @@ radv_build_ray_traversal(struct radv_device *device, nir_builder *b, const struc
                nir_store_deref(b, args->vars.stack,
                                nir_iadd_imm(b, nir_load_deref(b, args->vars.stack), -args->stack_stride), 1);
 
-               nir_def *stack_ptr =
-                  nir_umod_imm(b, nir_load_deref(b, args->vars.stack), args->stack_stride * args->stack_entries);
+               nir_def *stack_ptr = nir_umod_imm(b, nir_load_deref(b, args->vars.stack),
+                                                 (uint64_t)args->stack_stride * args->stack_entries);
                nir_def *bvh_node = args->stack_load_cb(b, stack_ptr, args);
                nir_store_deref(b, args->vars.current_node, bvh_node, 0x1);
             }
@@ -1062,13 +1062,13 @@ radv_build_ray_traversal(struct radv_device *device, nir_builder *b, const struc
 
                   for (unsigned i = 4; i-- > 1;) {
                      nir_def *stack = nir_load_deref(b, args->vars.stack);
-                     nir_def *stack_ptr = nir_umod_imm(b, stack, args->stack_entries * args->stack_stride);
+                     nir_def *stack_ptr = nir_umod_imm(b, stack, args->stack_entries * (uint64_t)args->stack_stride);
                      args->stack_store_cb(b, stack_ptr, new_nodes[i], args);
                      nir_store_deref(b, args->vars.stack, nir_iadd_imm(b, stack, args->stack_stride), 1);
 
                      if (i == 1) {
                         nir_def *new_watermark = nir_iadd_imm(b, nir_load_deref(b, args->vars.stack),
-                                                              -args->stack_entries * args->stack_stride);
+                                                              -args->stack_entries * (uint64_t)args->stack_stride);
                         new_watermark = nir_imax(b, nir_load_deref(b, args->vars.stack_low_watermark), new_watermark);
                         nir_store_deref(b, args->vars.stack_low_watermark, new_watermark, 0x1);
                      }
@@ -1234,8 +1234,8 @@ radv_build_ray_traversal_gfx12(struct radv_device *device, nir_builder *b, const
                nir_store_deref(b, args->vars.stack,
                                nir_iadd_imm(b, nir_load_deref(b, args->vars.stack), -args->stack_stride), 1);
 
-               nir_def *stack_ptr =
-                  nir_umod_imm(b, nir_load_deref(b, args->vars.stack), args->stack_stride * args->stack_entries);
+               nir_def *stack_ptr = nir_umod_imm(b, nir_load_deref(b, args->vars.stack),
+                                                 (uint64_t)args->stack_stride * args->stack_entries);
                nir_def *bvh_node = args->stack_load_cb(b, stack_ptr, args);
                nir_store_deref(b, args->vars.current_node, bvh_node, 0x1);
             }
@@ -1337,13 +1337,13 @@ radv_build_ray_traversal_gfx12(struct radv_device *device, nir_builder *b, const
 
                   for (unsigned i = 8; i-- > 1;) {
                      nir_def *stack = nir_load_deref(b, args->vars.stack);
-                     nir_def *stack_ptr = nir_umod_imm(b, stack, args->stack_entries * args->stack_stride);
+                     nir_def *stack_ptr = nir_umod_imm(b, stack, (uint64_t)args->stack_entries * args->stack_stride);
                      args->stack_store_cb(b, stack_ptr, new_nodes[i], args);
                      nir_store_deref(b, args->vars.stack, nir_iadd_imm(b, stack, args->stack_stride), 1);
 
                      if (i == 1) {
                         nir_def *new_watermark = nir_iadd_imm(b, nir_load_deref(b, args->vars.stack),
-                                                              -args->stack_entries * args->stack_stride);
+                                                              -args->stack_entries * (uint64_t)args->stack_stride);
                         new_watermark = nir_imax(b, nir_load_deref(b, args->vars.stack_low_watermark), new_watermark);
                         nir_store_deref(b, args->vars.stack_low_watermark, new_watermark, 0x1);
                      }
diff --git a/src/amd/vulkan/nir/radv_nir_rt_shader.c b/src/amd/vulkan/nir/radv_nir_rt_shader.c
index c438acc0d4005..b1bf7b1c6504b 100644
--- a/src/amd/vulkan/nir/radv_nir_rt_shader.c
+++ b/src/amd/vulkan/nir/radv_nir_rt_shader.c
@@ -756,9 +756,10 @@ lower_hit_attribs(nir_shader *shader, nir_variable **hit_attribs, uint32_t workg
 
          nir_def *offset;
          if (!hit_attribs)
-            offset = nir_imul_imm(
-               &b, nir_iadd_imm(&b, nir_load_local_invocation_index(&b), nir_intrinsic_base(intrin) * workgroup_size),
-               sizeof(uint32_t));
+            offset = nir_imul_imm(&b,
+                                  nir_iadd_imm(&b, nir_load_local_invocation_index(&b),
+                                               nir_intrinsic_base(intrin) * (uint64_t)workgroup_size),
+                                  sizeof(uint32_t));
 
          if (intrin->intrinsic == nir_intrinsic_load_hit_attrib_amd) {
             nir_def *ret;
diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index 111fae2fdcd4f..b9c4a903cff1f 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -10436,7 +10436,7 @@ radv_emit_draw_packets_indexed(struct radv_cmd_buffer *cmd_buffer, const struct
          radv_emit_userdata_vertex(cmd_buffer, info, *vertexOffset);
          vk_foreach_multi_draw_indexed (draw, i, minfo, drawCount, stride) {
             uint32_t remaining_indexes = MAX2(state->max_index_count, draw->firstIndex) - draw->firstIndex;
-            uint64_t index_va = state->index_va + draw->firstIndex * index_size;
+            uint64_t index_va = state->index_va + (uint64_t)draw->firstIndex * index_size;
 
             /* Handle draw calls with 0-sized index buffers if the GPU can't support them. */
             if (!remaining_indexes && pdev->info.has_zero_index_buffer_bug)
@@ -10461,7 +10461,7 @@ radv_emit_draw_packets_indexed(struct radv_cmd_buffer *cmd_buffer, const struct
       } else {
          vk_foreach_multi_draw_indexed (draw, i, minfo, drawCount, stride) {
             uint32_t remaining_indexes = MAX2(state->max_index_count, draw->firstIndex) - draw->firstIndex;
-            uint64_t index_va = state->index_va + draw->firstIndex * index_size;
+            uint64_t index_va = state->index_va + (uint64_t)draw->firstIndex * index_size;
 
             /* Handle draw calls with 0-sized index buffers if the GPU can't support them. */
             if (!remaining_indexes && pdev->info.has_zero_index_buffer_bug)
@@ -10511,7 +10511,7 @@ radv_emit_draw_packets_indexed(struct radv_cmd_buffer *cmd_buffer, const struct
          radv_emit_userdata_vertex(cmd_buffer, info, *vertexOffset);
          vk_foreach_multi_draw_indexed (draw, i, minfo, drawCount, stride) {
             uint32_t remaining_indexes = MAX2(state->max_index_count, draw->firstIndex) - draw->firstIndex;
-            uint64_t index_va = state->index_va + draw->firstIndex * index_size;
+            uint64_t index_va = state->index_va + (uint64_t)draw->firstIndex * index_size;
 
             /* Handle draw calls with 0-sized index buffers if the GPU can't support them. */
             if (!remaining_indexes && pdev->info.has_zero_index_buffer_bug)
@@ -10531,7 +10531,7 @@ radv_emit_draw_packets_indexed(struct radv_cmd_buffer *cmd_buffer, const struct
       } else {
          vk_foreach_multi_draw_indexed (draw, i, minfo, drawCount, stride) {
             uint32_t remaining_indexes = MAX2(state->max_index_count, draw->firstIndex) - draw->firstIndex;
-            uint64_t index_va = state->index_va + draw->firstIndex * index_size;
+            uint64_t index_va = state->index_va + (uint64_t)draw->firstIndex * index_size;
 
             /* Handle draw calls with 0-sized index buffers if the GPU can't support them. */
             if (!remaining_indexes && pdev->info.has_zero_index_buffer_bug)
diff --git a/src/amd/vulkan/radv_descriptor_pool.c b/src/amd/vulkan/radv_descriptor_pool.c
index 1297201d8d71e..87bdb02a52174 100644
--- a/src/amd/vulkan/radv_descriptor_pool.c
+++ b/src/amd/vulkan/radv_descriptor_pool.c
@@ -73,7 +73,7 @@ radv_create_descriptor_pool(struct radv_device *device, const VkDescriptorPoolCr
    uint64_t num_16byte_descriptors = 0;
    for (unsigned i = 0; i < pCreateInfo->poolSizeCount; ++i) {
       bo_count += radv_descriptor_type_buffer_count(pCreateInfo->pPoolSizes[i].type) *
-                  pCreateInfo->pPoolSizes[i].descriptorCount;
+                  (uint64_t)pCreateInfo->pPoolSizes[i].descriptorCount;
 
       switch (pCreateInfo->pPoolSizes[i].type) {
       case VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC:
@@ -94,7 +94,7 @@ radv_create_descriptor_pool(struct radv_device *device, const VkDescriptorPoolCr
          break;
       case VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE:
       case VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT:
-         bo_size += radv_get_sampled_image_desc_size(pdev) * pCreateInfo->pPoolSizes[i].descriptorCount;
+         bo_size += (uint64_t)radv_get_sampled_image_desc_size(pdev) * pCreateInfo->pPoolSizes[i].descriptorCount;
          break;
       case VK_DESCRIPTOR_TYPE_MUTABLE_EXT:
          /* Per spec, if a mutable descriptor type list is provided for the pool entry, we
@@ -115,11 +115,12 @@ radv_create_descriptor_pool(struct radv_device *device, const VkDescriptorPoolCr
             }
          } else {
             const uint32_t max_desc_size = pdev->use_fmask ? 64 : 32;
-            bo_size += max_desc_size * pCreateInfo->pPoolSizes[i].descriptorCount;
+            bo_size += (uint64_t)max_desc_size * pCreateInfo->pPoolSizes[i].descriptorCount;
          }
          break;
       case VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER:
-         bo_size += pCreateInfo->pPoolSizes[i].descriptorCount * radv_get_combined_image_sampler_desc_size(pdev);
+         bo_size +=
+            (uint64_t)pCreateInfo->pPoolSizes[i].descriptorCount * radv_get_combined_image_sampler_desc_size(pdev);
          break;
       case VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK:
          bo_size += pCreateInfo->pPoolSizes[i].descriptorCount;
diff --git a/src/amd/vulkan/radv_dgc.c b/src/amd/vulkan/radv_dgc.c
index d425799038134..b22885c5c4295 100644
--- a/src/amd/vulkan/radv_dgc.c
+++ b/src/amd/vulkan/radv_dgc.c
@@ -3483,7 +3483,7 @@ radv_CreateIndirectExecutionSetEXT(VkDevice _device, const VkIndirectExecutionSe
    stride += 4 /* num CS DW */;
    stride += (pdev->info.gfx_level >= GFX10 ? 19 : 16) * 4;
 
-   result = radv_bo_create(device, &set->base, num_entries * stride, 8, RADEON_DOMAIN_VRAM,
+   result = radv_bo_create(device, &set->base, num_entries * (uint64_t)stride, 8, RADEON_DOMAIN_VRAM,
                            RADEON_FLAG_NO_INTERPROCESS_SHARING | RADEON_FLAG_READ_ONLY, RADV_BO_PRIORITY_DESCRIPTOR, 0,
                            false, &set->bo);
    if (result != VK_SUCCESS) {
diff --git a/src/amd/vulkan/radv_host_image_copy.c b/src/amd/vulkan/radv_host_image_copy.c
index d8866a103ce5e..4ecdf3d82f290 100644
--- a/src/amd/vulkan/radv_host_image_copy.c
+++ b/src/amd/vulkan/radv_host_image_copy.c
@@ -25,8 +25,8 @@ radv_get_surface_copy_region(struct radv_device *device, const struct radv_image
    const uint32_t texel_scale = radv_get_texel_scale(image->vk.format);
    const VkOffset3D img_offset_el = vk_image_offset_to_elements(&image->vk, image_offset);
    const VkExtent3D img_extent_el = vk_image_extent_to_elements(&image->vk, image_extent);
-   const uint32_t mem_row_pitch = memory_row_length ? memory_row_length : img_extent_el.width;
-   const uint32_t mem_slice_pitch = (memory_image_height ? memory_image_height : img_extent_el.height) * mem_row_pitch;
+   const uint64_t mem_row_pitch = memory_row_length ? memory_row_length : img_extent_el.width;
+   const uint64_t mem_slice_pitch = (memory_image_height ? memory_image_height : img_extent_el.height) * mem_row_pitch;
 
    const struct ac_surface_copy_region surf_copy_region = {
       .surf_ptr = surf_ptr,
diff --git a/src/amd/vulkan/radv_image_view.c b/src/amd/vulkan/radv_image_view.c
index 36d1ffcbc0178..14eb479debced 100644
--- a/src/amd/vulkan/radv_image_view.c
+++ b/src/amd/vulkan/radv_image_view.c
@@ -426,7 +426,7 @@ radv_image_view_make_descriptor(struct radv_image_view *iview, struct radv_devic
 
       /* Video decode target uses custom height alignment. */
       if (image->vk.usage & VK_IMAGE_USAGE_VIDEO_DECODE_DST_BIT_KHR) {
-         offset += first_layer * image->planes[plane_id].surface.u.legacy.level[0].slice_size_dw * 4;
+         offset += first_layer * (uint64_t)image->planes[plane_id].surface.u.legacy.level[0].slice_size_dw * 4;
          first_layer = 0;
       }
    }
diff --git a/src/amd/vulkan/radv_perfcounter.c b/src/amd/vulkan/radv_perfcounter.c
index d89229d4b2389..dadff90957c09 100644
--- a/src/amd/vulkan/radv_perfcounter.c
+++ b/src/amd/vulkan/radv_perfcounter.c
@@ -657,7 +657,7 @@ radv_pc_stop_and_sample(struct radv_cmd_buffer *cmd_buffer, struct radv_pc_query
          if (offset < cnt) {
             unsigned pass_reg_cnt = MIN2(cnt - offset, ac_block->b->b->num_counters);
             radv_pc_sample_block(cmd_buffer, ac_block, pass_reg_cnt,
-                                 reg_va + offset * num_instances * sizeof(uint64_t));
+                                 reg_va + (uint64_t)offset * num_instances * sizeof(uint64_t));
          }
 
          i += cnt;
diff --git a/src/amd/vulkan/radv_query.c b/src/amd/vulkan/radv_query.c
index 5687dcbaf9b73..71a04e8c85649 100644
--- a/src/amd/vulkan/radv_query.c
+++ b/src/amd/vulkan/radv_query.c
@@ -388,7 +388,7 @@ radv_copy_occlusion_query_result(struct radv_cmd_buffer *cmd_buffer, struct radv
          uint32_t rb_avail_offset = 16 * util_last_bit64(enabled_rb_mask) - 4;
          for (unsigned i = 0; i < query_count; ++i) {
             unsigned query = first_query + i;
-            uint64_t src_va = va + query * pool->stride + rb_avail_offset;
+            uint64_t src_va = va + query * (uint64_t)pool->stride + rb_avail_offset;
 
             radeon_check_space(device->ws, cs->b, 7);
 
@@ -398,8 +398,8 @@ radv_copy_occlusion_query_result(struct radv_cmd_buffer *cmd_buffer, struct radv
       }
    }
 
-   radv_query_shader(cmd_buffer, VK_QUERY_TYPE_OCCLUSION, pool->bo, first_query * pool->stride, dst_va, pool->stride,
-                     stride, query_count, flags, 0, 0, false);
+   radv_query_shader(cmd_buffer, VK_QUERY_TYPE_OCCLUSION, pool->bo, first_query * (uint64_t)pool->stride, dst_va,
+                     pool->stride, stride, query_count, flags, 0, 0, false);
 }
 
 /**
@@ -799,7 +799,7 @@ radv_copy_pipeline_stat_query_result(struct radv_cmd_buffer *cmd_buffer, struct
          radv_cp_wait_mem(cs, cmd_buffer->qf, WAIT_REG_MEM_EQUAL, avail_va, 1, 0xffffffff);
 
          if (pool->uses_ace && pdev->emulate_mesh_shader_queries) {
-            const uint64_t src_va = va + query * pool->stride;
+            const uint64_t src_va = va + (uint64_t)query * pool->stride;
             const uint64_t start_va = src_va + task_invoc_offset + 4;
             const uint64_t stop_va = start_va + pipelinestat_block_size;
 
@@ -811,8 +811,8 @@ radv_copy_pipeline_stat_query_result(struct radv_cmd_buffer *cmd_buffer, struct
       }
    }
 
-   radv_query_shader(cmd_buffer, VK_QUERY_TYPE_PIPELINE_STATISTICS, pool->bo, first_query * pool->stride, dst_va,
-                     pool->stride, stride, query_count, flags, pool->vk.pipeline_statistics,
+   radv_query_shader(cmd_buffer, VK_QUERY_TYPE_PIPELINE_STATISTICS, pool->bo, first_query * (uint64_t)pool->stride,
+                     dst_va, pool->stride, stride, query_count, flags, pool->vk.pipeline_statistics,
                      pool->availability_offset + 4 * first_query, pool->uses_emulated_queries);
 }
 
@@ -1044,7 +1044,7 @@ radv_copy_tfb_query_result(struct radv_cmd_buffer *cmd_buffer, struct radv_query
    if (flags & VK_QUERY_RESULT_WAIT_BIT) {
       for (unsigned i = 0; i < query_count; i++) {
          unsigned query = first_query + i;
-         uint64_t src_va = va + query * pool->stride;
+         uint64_t src_va = va + query * (uint64_t)pool->stride;
 
          radeon_check_space(device->ws, cs->b, 7 * 4);
 
@@ -1055,8 +1055,9 @@ radv_copy_tfb_query_result(struct radv_cmd_buffer *cmd_buffer, struct radv_query
       }
    }
 
-   radv_query_shader(cmd_buffer, VK_QUERY_TYPE_TRANSFORM_FEEDBACK_STREAM_EXT, pool->bo, first_query * pool->stride,
-                     dst_va, pool->stride, stride, query_count, flags, 0, 0, false);
+   radv_query_shader(cmd_buffer, VK_QUERY_TYPE_TRANSFORM_FEEDBACK_STREAM_EXT, pool->bo,
+                     first_query * (uint64_t)pool->stride, dst_va, pool->stride, stride, query_count, flags, 0, 0,
+                     false);
 }
 
 /**
@@ -1177,7 +1178,7 @@ radv_copy_timestamp_query_result(struct radv_cmd_buffer *cmd_buffer, struct radv
    if (flags & VK_QUERY_RESULT_WAIT_BIT) {
       for (unsigned i = 0; i < query_count; ++i) {
          unsigned query = first_query + i;
-         uint64_t local_src_va = va + query * pool->stride;
+         uint64_t local_src_va = va + (uint64_t)query * pool->stride;
 
          radeon_check_space(device->ws, cs->b, 7);
 
@@ -1189,8 +1190,8 @@ radv_copy_timestamp_query_result(struct radv_cmd_buffer *cmd_buffer, struct radv
       }
    }
 
-   radv_query_shader(cmd_buffer, VK_QUERY_TYPE_TIMESTAMP, pool->bo, first_query * pool->stride, dst_va, pool->stride,
-                     stride, query_count, flags, 0, 0, false);
+   radv_query_shader(cmd_buffer, VK_QUERY_TYPE_TIMESTAMP, pool->bo, first_query * (uint64_t)pool->stride, dst_va,
+                     pool->stride, stride, query_count, flags, 0, 0, false);
 }
 
 /**
@@ -1456,7 +1457,7 @@ radv_copy_pg_query_result(struct radv_cmd_buffer *cmd_buffer, struct radv_query_
 
       for (unsigned i = 0; i < query_count; i++) {
          unsigned query = first_query + i;
-         uint64_t src_va = va + query * pool->stride;
+         uint64_t src_va = va + query * (uint64_t)pool->stride;
 
          radeon_check_space(device->ws, cs->b, 7 * 4);
 
@@ -1471,8 +1472,8 @@ radv_copy_pg_query_result(struct radv_cmd_buffer *cmd_buffer, struct radv_query_
       }
    }
 
-   radv_query_shader(cmd_buffer, VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT, pool->bo, first_query * pool->stride, dst_va,
-                     pool->stride, stride, query_count, flags, 0, 0,
+   radv_query_shader(cmd_buffer, VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT, pool->bo, first_query * (uint64_t)pool->stride,
+                     dst_va, pool->stride, stride, query_count, flags, 0, 0,
                      pool->uses_emulated_queries && pdev->info.gfx_level < GFX11);
 }
 
@@ -1662,6 +1663,7 @@ radv_copy_ms_prim_query_result(struct radv_cmd_buffer *cmd_buffer, struct radv_q
    const struct radv_physical_device *pdev = radv_device_physical(device);
    struct radv_cmd_stream *cs = cmd_buffer->cs;
    uint64_t va = radv_buffer_get_va(pool->bo);
+   uint64_t src_offset = first_query * (uint64_t)pool->stride;
 
    if (pdev->info.gfx_level >= GFX11) {
       if (flags & VK_QUERY_RESULT_WAIT_BIT) {
@@ -1677,14 +1679,13 @@ radv_copy_ms_prim_query_result(struct radv_cmd_buffer *cmd_buffer, struct radv_q
          }
       }
 
-      radv_query_shader(cmd_buffer, VK_QUERY_TYPE_PIPELINE_STATISTICS, pool->bo, first_query * pool->stride, dst_va,
-                        pool->stride, stride, query_count, flags, 1 << 13, pool->availability_offset + 4 * first_query,
-                        false);
+      radv_query_shader(cmd_buffer, VK_QUERY_TYPE_PIPELINE_STATISTICS, pool->bo, src_offset, dst_va, pool->stride,
+                        stride, query_count, flags, 1 << 13, pool->availability_offset + 4 * first_query, false);
    } else {
       if (flags & VK_QUERY_RESULT_WAIT_BIT) {
          for (unsigned i = 0; i < query_count; i++) {
             unsigned query = first_query + i;
-            uint64_t src_va = va + query * pool->stride;
+            uint64_t src_va = va + (uint64_t)query * pool->stride;
 
             radeon_check_space(device->ws, cs->b, 7 * 2);
 
@@ -1694,8 +1695,8 @@ radv_copy_ms_prim_query_result(struct radv_cmd_buffer *cmd_buffer, struct radv_q
          }
       }
 
-      radv_query_shader(cmd_buffer, VK_QUERY_TYPE_MESH_PRIMITIVES_GENERATED_EXT, pool->bo, first_query * pool->stride,
-                        dst_va, pool->stride, stride, query_count, flags, 0, 0, false);
+      radv_query_shader(cmd_buffer, VK_QUERY_TYPE_MESH_PRIMITIVES_GENERATED_EXT, pool->bo, src_offset, dst_va,
+                        pool->stride, stride, query_count, flags, 0, 0, false);
    }
 }
 
@@ -2551,8 +2552,9 @@ radv_CmdResetQueryPool(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uin
     */
    cmd_buffer->state.flush_bits |= cmd_buffer->active_query_flush_bits;
 
-   flush_bits |= radv_fill_buffer(cmd_buffer, pool->bo, radv_buffer_get_va(pool->bo) + firstQuery * pool->stride,
-                                  queryCount * pool->stride, value);
+   flush_bits |=
+      radv_fill_buffer(cmd_buffer, pool->bo, radv_buffer_get_va(pool->bo) + firstQuery * (uint64_t)pool->stride,
+                       queryCount * (uint64_t)pool->stride, value);
 
    if (pool->vk.query_type == VK_QUERY_TYPE_PIPELINE_STATISTICS ||
        (pool->vk.query_type == VK_QUERY_TYPE_MESH_PRIMITIVES_GENERATED_EXT && pdev->info.gfx_level >= GFX11)) {
@@ -2662,7 +2664,7 @@ radv_CmdBeginQueryIndexedEXT(VkCommandBuffer commandBuffer, VkQueryPool queryPoo
 
    emit_query_flush(cmd_buffer, pool);
 
-   va += pool->stride * query;
+   va += (uint64_t)pool->stride * query;
 
    if (pool->uses_ace) {
       if (!radv_gang_init(cmd_buffer))
@@ -2685,7 +2687,7 @@ radv_CmdEndQueryIndexedEXT(VkCommandBuffer commandBuffer, VkQueryPool queryPool,
    VK_FROM_HANDLE(radv_query_pool, pool, queryPool);
    uint64_t va = radv_buffer_get_va(pool->bo);
    uint64_t avail_va = va + pool->availability_offset + 4 * query;
-   va += pool->stride * query;
+   va += (uint64_t)pool->stride * query;
 
    /* Do not need to add the pool BO to the list because the query must
     * currently be active, which means the BO is already in the list.
@@ -2745,7 +2747,7 @@ radv_CmdWriteTimestamp2(VkCommandBuffer commandBuffer, VkPipelineStageFlags2 sta
    const unsigned num_queries = MAX2(util_bitcount(cmd_buffer->state.render.view_mask), 1);
    struct radv_cmd_stream *cs = cmd_buffer->cs;
    const uint64_t va = radv_buffer_get_va(pool->bo);
-   uint64_t query_va = va + pool->stride * query;
+   uint64_t query_va = va + (uint64_t)pool->stride * query;
 
    radv_cs_add_buffer(device->ws, cs->b, pool->bo);
 
@@ -2796,7 +2798,7 @@ radv_CmdWriteAccelerationStructuresPropertiesKHR(VkCommandBuffer commandBuffer,
    struct radv_device *device = radv_cmd_buffer_device(cmd_buffer);
    struct radv_cmd_stream *cs = cmd_buffer->cs;
    uint64_t pool_va = radv_buffer_get_va(pool->bo);
-   uint64_t query_va = pool_va + pool->stride * firstQuery;
+   uint64_t query_va = pool_va + (uint64_t)pool->stride * firstQuery;
 
    radv_cs_add_buffer(device->ws, cs->b, pool->bo);
 
diff --git a/src/amd/vulkan/radv_queue.c b/src/amd/vulkan/radv_queue.c
index 53360eb0f49f2..13d63a8e72796 100644
--- a/src/amd/vulkan/radv_queue.c
+++ b/src/amd/vulkan/radv_queue.c
@@ -164,7 +164,7 @@ radv_sparse_image_bind_memory(struct radv_device *device, const VkSparseImageMem
          uint32_t img_y_increment = pitch * bs * surface->prt_tile_depth;
          uint32_t mem_y_increment = aligned_extent_width * bs * surface->prt_tile_depth;
          uint64_t mem_z_increment = (uint64_t)aligned_extent_width * aligned_extent_height * bs;
-         uint64_t size = mem_y_increment * surface->prt_tile_height;
+         uint64_t size = mem_y_increment * (uint64_t)surface->prt_tile_height;
          for (unsigned z = 0; z < bind_extent.depth;
               z += surface->prt_tile_depth, offset += depth_pitch * surface->prt_tile_depth) {
             for (unsigned y = 0; y < bind_extent.height; y += surface->prt_tile_height) {
diff --git a/src/amd/vulkan/radv_sdma.c b/src/amd/vulkan/radv_sdma.c
index 64e25ba28c92c..506634b938ed5 100644
--- a/src/amd/vulkan/radv_sdma.c
+++ b/src/amd/vulkan/radv_sdma.c
@@ -732,8 +732,8 @@ radv_sdma_copy_buffer_image_unaligned(const struct radv_device *device, struct r
    };
 
    VkExtent3D extent = base_extent;
-   const unsigned buf_pitch_blocks = DIV_ROUND_UP(buf->pitch, img.blk_w);
-   const unsigned buf_slice_pitch_blocks = DIV_ROUND_UP(DIV_ROUND_UP(buf->slice_pitch, img.blk_w), img.blk_h);
+   const uint64_t buf_pitch_blocks = DIV_ROUND_UP(buf->pitch, img.blk_w);
+   const uint64_t buf_slice_pitch_blocks = DIV_ROUND_UP(DIV_ROUND_UP(buf->slice_pitch, img.blk_w), img.blk_h);
    assert(buf_pitch_blocks);
    assert(buf_slice_pitch_blocks);
    extent.depth = 1;
@@ -764,9 +764,9 @@ radv_sdma_copy_buffer_image_unaligned(const struct radv_device *device, struct r
          for (unsigned r = 0; r < rows; ++r) {
             const uint64_t buf_va =
                buf->va + slice * buf_slice_pitch_blocks * img.bpp + (row + r) * buf_pitch_blocks * img.bpp;
-            const uint64_t tmp_va = tmp.va + r * info.aligned_row_pitch * img.bpp;
+            const uint64_t tmp_va = tmp.va + r * (uint64_t)info.aligned_row_pitch * img.bpp;
             radv_sdma_copy_memory(device, cs, to_image ? buf_va : tmp_va, to_image ? tmp_va : buf_va,
-                                  info.extent_horizontal_blocks * img.bpp);
+                                  (uint64_t)info.extent_horizontal_blocks * img.bpp);
          }
 
          /* Wait for the copy to finish. */
diff --git a/src/amd/vulkan/radv_shader.c b/src/amd/vulkan/radv_shader.c
index 52ae64cf6ca76..6eac5a386cb9d 100644
--- a/src/amd/vulkan/radv_shader.c
+++ b/src/amd/vulkan/radv_shader.c
@@ -2729,7 +2729,7 @@ radv_get_max_waves(const struct radv_device *device, const struct ac_shader_conf
       unsigned vgprs = align(conf->num_vgprs, wave_size == 32 ? 8 : 4);
       if (gfx_level >= GFX10_3) {
          unsigned real_vgpr_gran = gpu_info->num_physical_wave64_vgprs_per_simd / 64;
-         vgprs = util_align_npot(vgprs, real_vgpr_gran * (wave_size == 32 ? 2 : 1));
+         vgprs = util_align_npot(vgprs, (size_t)real_vgpr_gran * (wave_size == 32 ? 2 : 1));
       }
       max_simd_waves = MIN2(max_simd_waves, physical_vgprs / vgprs);
    }
diff --git a/src/amd/vulkan/radv_video_enc.c b/src/amd/vulkan/radv_video_enc.c
index 6501a6f7a3e65..358cbb9c80ee6 100644
--- a/src/amd/vulkan/radv_video_enc.c
+++ b/src/amd/vulkan/radv_video_enc.c
@@ -1582,7 +1582,8 @@ radv_enc_ctx2(struct radv_cmd_buffer *cmd_buffer, const VkVideoEncodeInfoKHR *in
       }
 
       uint32_t dpb_array_idx = res->baseArrayLayer + dpb_iv->vk.base_array_layer;
-      uint64_t luma_va = dpb_img->bindings[0].addr + dpb_array_idx * (luma_size + chroma_size + metadata_size);
+      uint64_t luma_va =
+         dpb_img->bindings[0].addr + (uint64_t)dpb_array_idx * (luma_size + chroma_size + metadata_size);
       uint64_t chroma_va = luma_va + luma_size;
       uint64_t fcb_va = chroma_va + chroma_size;
 
@@ -2788,7 +2789,7 @@ radv_vcn_encode_video(struct radv_cmd_buffer *cmd_buffer, const VkVideoEncodeInf
          radv_cs_add_buffer(device->ws, cs->b, pool->bo);
 
          feedback_query_va = radv_buffer_get_va(pool->bo);
-         feedback_query_va += pool->stride * inline_queries->firstQuery;
+         feedback_query_va += (uint64_t)pool->stride * inline_queries->firstQuery;
       }
    }
 
@@ -3353,7 +3354,7 @@ radv_video_get_encode_session_memory_requirements(struct radv_device *device, st
       vk_outarray_append_typed(VkVideoSessionMemoryRequirementsKHR, &out, m)
       {
          m->memoryBindIndex = RADV_BIND_ENCODE_QP_MAP;
-         m->memoryRequirements.size = map_width * map_height * sizeof(int16_t);
+         m->memoryRequirements.size = (VkDeviceSize)map_width * map_height * sizeof(int16_t);
          m->memoryRequirements.alignment = 0;
          m->memoryRequirements.memoryTypeBits = memory_type_bits;
       }
-- 
GitLab


From 101a38086c4e643e21a133ddbfcdfab56786f445 Mon Sep 17 00:00:00 2001
From: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
Date: Tue, 23 Sep 2025 17:50:50 +0200
Subject: [PATCH 11/13] ac: fix potential overflow warnings

The multiplication of 32 bits integers will be truncated before
being widened to the destination variable' size.
Reported by static analysis.
---
 src/amd/common/ac_surface.c              | 4 ++--
 src/amd/common/nir/ac_nir_lower_ngg_gs.c | 2 +-
 src/amd/llvm/ac_llvm_build.c             | 2 +-
 src/amd/llvm/ac_nir_to_llvm.c            | 4 ++--
 4 files changed, 6 insertions(+), 6 deletions(-)

diff --git a/src/amd/common/ac_surface.c b/src/amd/common/ac_surface.c
index 3e572083774b1..aa77b93dde365 100644
--- a/src/amd/common/ac_surface.c
+++ b/src/amd/common/ac_surface.c
@@ -1312,8 +1312,8 @@ static uint64_t ac_estimate_size(const struct ac_surf_config *config,
    assert(bpp);
    unsigned num_samples = MAX2(1, config->info.samples);
    unsigned bpe = bpp / 8;
-   unsigned width = util_align_npot(in_width, align_width * blk_w);
-   unsigned height = util_align_npot(in_height , align_height * blk_h);
+   unsigned width = util_align_npot(in_width, (size_t)align_width * blk_w);
+   unsigned height = util_align_npot(in_height , (size_t)align_height * blk_h);
    unsigned depth = align(config->is_3d ? config->info.depth :
                           config->is_cube ? 6 : config->info.array_size, align_depth);
    unsigned tile_size_bytes = align_width * align_height * align_depth * num_samples * bpe;
diff --git a/src/amd/common/nir/ac_nir_lower_ngg_gs.c b/src/amd/common/nir/ac_nir_lower_ngg_gs.c
index bc2765cbeac4e..1e6809bbf209c 100644
--- a/src/amd/common/nir/ac_nir_lower_ngg_gs.c
+++ b/src/amd/common/nir/ac_nir_lower_ngg_gs.c
@@ -671,7 +671,7 @@ ngg_gs_build_streamout(nir_builder *b, lower_ngg_gs_state *s)
 
       unsigned scratch_stride = ALIGN(s->max_num_waves, 4);
       nir_def *scratch_base =
-         nir_iadd_imm(b, s->lds_addr_gs_out_vtx, stream * scratch_stride);
+         nir_iadd_imm(b, s->lds_addr_gs_out_vtx, stream * (uint64_t)scratch_stride);
 
       /* We want to export primitives to streamout buffer in sequence,
        * but not all vertices are alive or mark end of a primitive, so
diff --git a/src/amd/llvm/ac_llvm_build.c b/src/amd/llvm/ac_llvm_build.c
index d11d924b6fc49..921417f9ba3ca 100644
--- a/src/amd/llvm/ac_llvm_build.c
+++ b/src/amd/llvm/ac_llvm_build.c
@@ -1008,7 +1008,7 @@ LLVMValueRef ac_build_buffer_load(struct ac_llvm_context *ctx, LLVMValueRef rsrc
       fetch_num_channels = MIN2(4, num_channels - i);
       LLVMValueRef fetch_voffset =
             LLVMBuildAdd(ctx->builder, voffset,
-                         LLVMConstInt(ctx->i32, i * ac_get_type_size(channel_type), 0), "");
+                         LLVMConstInt(ctx->i32, i * (unsigned long long) ac_get_type_size(channel_type), 0), "");
       LLVMValueRef item =
          ac_build_buffer_load_common(ctx, rsrc, vindex, fetch_voffset, soffset, fetch_num_channels,
                                      channel_type, access, can_speculate, false);
diff --git a/src/amd/llvm/ac_nir_to_llvm.c b/src/amd/llvm/ac_nir_to_llvm.c
index b92af5be26d2f..3e6f5869c4443 100644
--- a/src/amd/llvm/ac_nir_to_llvm.c
+++ b/src/amd/llvm/ac_nir_to_llvm.c
@@ -1630,7 +1630,7 @@ static void visit_store_ssbo(struct ac_nir_context *ctx, nir_intrinsic_instr *in
       data = extract_vector_range(&ctx->ac, base_data, start, count);
 
       offset = LLVMBuildAdd(ctx->ac.builder, base_offset,
-                            LLVMConstInt(ctx->ac.i32, start * elem_size_bytes, false), "");
+                            LLVMConstInt(ctx->ac.i32, start * (unsigned long long)elem_size_bytes, false), "");
 
       if (num_bytes == 1) {
          ac_build_buffer_store_byte(&ctx->ac, rsrc, data, offset, ctx->ac.i32_0, access);
@@ -1845,7 +1845,7 @@ static LLVMValueRef visit_load_buffer(struct ac_nir_context *ctx, nir_intrinsic_
          num_elems = 16 / elem_size_bytes;
       int load_bytes = num_elems * elem_size_bytes;
 
-      LLVMValueRef immoffset = LLVMConstInt(ctx->ac.i32, i * elem_size_bytes, false);
+      LLVMValueRef immoffset = LLVMConstInt(ctx->ac.i32, i * (unsigned long long)elem_size_bytes, false);
       LLVMValueRef voffset = LLVMBuildAdd(ctx->ac.builder, offset, immoffset, "");
 
       LLVMValueRef ret;
-- 
GitLab


From cd3db57a1bf5bafd339e0dee66e19f150d9fa8c9 Mon Sep 17 00:00:00 2001
From: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
Date: Wed, 24 Sep 2025 08:47:15 +0200
Subject: [PATCH 12/13] egl: fix potential overflow warnings

The multiplication of 32 bits integers will be truncated before
being widened to the destination variable' size.
Reported by static analysis.
---
 src/egl/drivers/dri2/egl_dri2.c         | 4 ++--
 src/egl/drivers/dri2/platform_wayland.c | 2 +-
 src/egl/drivers/dri2/platform_x11.c     | 2 +-
 3 files changed, 4 insertions(+), 4 deletions(-)

diff --git a/src/egl/drivers/dri2/egl_dri2.c b/src/egl/drivers/dri2/egl_dri2.c
index 322dc3f790b9a..21bcc3351e056 100644
--- a/src/egl/drivers/dri2/egl_dri2.c
+++ b/src/egl/drivers/dri2/egl_dri2.c
@@ -139,7 +139,7 @@ dri2_put_image(struct dri_drawable *draw, int op, int x, int y, int w, int h,
    int copy_width = src_stride;
 
    if (!dri2_surf->swrast_device_buffer)
-      dri2_surf->swrast_device_buffer = malloc(height * dst_stride);
+      dri2_surf->swrast_device_buffer = malloc(height * (size_t)dst_stride);
 
    if (dri2_surf->swrast_device_buffer) {
       const char *src = data;
@@ -173,7 +173,7 @@ dri2_get_image(struct dri_drawable *read, int x, int y, int w, int h, char *data
    const int src_stride = width * bpp;
    const int dst_stride = w * bpp;
    const int x_offset = x * bpp;
-   int copy_width = dst_stride;
+   size_t copy_width = dst_stride;
    const char *src = dri2_surf->swrast_device_buffer;
    char *dst = data;
 
diff --git a/src/egl/drivers/dri2/platform_wayland.c b/src/egl/drivers/dri2/platform_wayland.c
index 41e80aef23525..68294907cc194 100644
--- a/src/egl/drivers/dri2/platform_wayland.c
+++ b/src/egl/drivers/dri2/platform_wayland.c
@@ -2951,7 +2951,7 @@ dri2_wl_swrast_get_image(struct dri_drawable *read, int x, int y, int w, int h,
                          char *data, void *loaderPrivate)
 {
    struct dri2_egl_surface *dri2_surf = loaderPrivate;
-   int copy_width = dri2_wl_swrast_get_stride_for_format(dri2_surf->format, w);
+   size_t copy_width = dri2_wl_swrast_get_stride_for_format(dri2_surf->format, w);
    int x_offset = dri2_wl_swrast_get_stride_for_format(dri2_surf->format, x);
    int src_stride = dri2_wl_swrast_get_stride_for_format(dri2_surf->format,
                                                          dri2_surf->base.Width);
diff --git a/src/egl/drivers/dri2/platform_x11.c b/src/egl/drivers/dri2/platform_x11.c
index 28acf735fa9c3..d0ed57c6290c3 100644
--- a/src/egl/drivers/dri2/platform_x11.c
+++ b/src/egl/drivers/dri2/platform_x11.c
@@ -156,7 +156,7 @@ swrastPutImage2(struct dri_drawable *draw, int op, int x, int y, int w, int h,
       dri2_egl_display(dri2_surf->base.Resource.Display);
    int stride_b = dri2_surf->bytes_per_pixel * w;
    size_t hdr_len = sizeof(xcb_put_image_request_t);
-   size_t size = (hdr_len + stride_b * h) >> 2;
+   size_t size = (hdr_len + (size_t)stride_b * h) >> 2;
    uint64_t max_req_len = xcb_get_maximum_request_length(dri2_dpy->conn);
 
    xcb_gcontext_t gc;
-- 
GitLab


From 5a93ae03105d64c4d4f81842f4aa501b6430b318 Mon Sep 17 00:00:00 2001
From: Pierre-Eric Pelloux-Prayer <pierre-eric.pelloux-prayer@amd.com>
Date: Wed, 24 Sep 2025 08:56:47 +0200
Subject: [PATCH 13/13] util/format: fix potential overflow warnings

The multiplication of 32 bits integers will be truncated before
being widened to the destination variable' size.
Reported by static analysis.
---
 src/util/format/texcompress_bptc_tmp.h |  6 +++---
 src/util/format/u_format_bptc.c        | 10 ++++-----
 src/util/format/u_format_fxt1.c        | 12 +++++------
 src/util/format/u_format_rgtc.c        | 30 +++++++++++++-------------
 src/util/format/u_format_s3tc.c        | 12 +++++------
 src/util/texcompress_astc_luts.cpp     |  2 +-
 6 files changed, 36 insertions(+), 36 deletions(-)

diff --git a/src/util/format/texcompress_bptc_tmp.h b/src/util/format/texcompress_bptc_tmp.h
index dae6a57de8486..47459f8658bc5 100644
--- a/src/util/format/texcompress_bptc_tmp.h
+++ b/src/util/format/texcompress_bptc_tmp.h
@@ -1149,7 +1149,7 @@ decompress_rgb_float(int width, int height,
                                     MIN2(height - y, BLOCK_SIZE),
                                     src,
                                     (dst + x * 4 +
-                                     (y * dst_rowstride / sizeof dst[0])),
+                                     (y * dst_rowstride / (unsigned)sizeof dst[0])),
                                     dst_rowstride, is_signed);
          src += BLOCK_BYTES;
       }
@@ -1278,7 +1278,7 @@ decompress_rgb_fp16(int width, int height,
                                    MIN2(height - y, BLOCK_SIZE),
                                    src,
                                    (dst + x * 4 +
-                                    (y * dst_rowstride / sizeof dst[0])),
+                                    (y * dst_rowstride / (unsigned)sizeof dst[0])),
                                    dst_rowstride, is_signed);
          src += BLOCK_BYTES;
       }
@@ -1848,7 +1848,7 @@ compress_rgb_float(int width, int height,
          compress_rgb_float_block(MIN2(width - x, BLOCK_SIZE),
                                   MIN2(height - y, BLOCK_SIZE),
                                   src + x * 3 +
-                                  y * src_rowstride / sizeof (float),
+                                  y * src_rowstride / (unsigned)sizeof (float),
                                   src_rowstride,
                                   dst,
                                   is_signed);
diff --git a/src/util/format/u_format_bptc.c b/src/util/format/u_format_bptc.c
index b4605e13fe3fc..8be457d3f834b 100644
--- a/src/util/format/u_format_bptc.c
+++ b/src/util/format/u_format_bptc.c
@@ -57,7 +57,7 @@ util_format_bptc_rgba_unorm_unpack_rgba_float(void *restrict dst_row, unsigned d
                                               unsigned width, unsigned height)
 {
    uint8_t *temp_block;
-   temp_block = malloc(width * height * 4 * sizeof(uint8_t));
+   temp_block = malloc((size_t)width * height * 4 * sizeof(uint8_t));
    decompress_rgba_unorm(width, height,
                          src_row, src_stride,
                          temp_block, width * 4 * sizeof(uint8_t));
@@ -78,7 +78,7 @@ util_format_bptc_rgba_unorm_pack_rgba_float(uint8_t *restrict dst_row, unsigned
                                             unsigned width, unsigned height)
 {
    uint8_t *temp_block;
-   temp_block = malloc(width * height * 4 * sizeof(uint8_t));
+   temp_block = malloc((size_t)width * height * 4 * sizeof(uint8_t));
    /* Direct call to row unpack instead of util_format_rgba_unpack_rect()
     * to avoid table lookup that would pull in all unpack symbols.
     */
@@ -135,7 +135,7 @@ util_format_bptc_srgba_unpack_rgba_float(void *restrict dst_row, unsigned dst_st
                                          unsigned width, unsigned height)
 {
    uint8_t *temp_block;
-   temp_block = malloc(width * height * 4 * sizeof(uint8_t));
+   temp_block = malloc((size_t)width * height * 4 * sizeof(uint8_t));
    decompress_rgba_unorm(width, height,
                          src_row, src_stride,
                          temp_block, width * 4 * sizeof(uint8_t));
@@ -180,7 +180,7 @@ util_format_bptc_rgb_float_unpack_rgba_8unorm(uint8_t *restrict dst_row, unsigne
                                               unsigned width, unsigned height)
 {
    float *temp_block;
-   temp_block = malloc(width * height * 4 * sizeof(float));
+   temp_block = malloc((size_t)width * height * 4 * sizeof(float));
    decompress_rgb_float(width, height,
                         src_row, src_stride,
                         temp_block, width * 4 * sizeof(float),
@@ -243,7 +243,7 @@ util_format_bptc_rgb_ufloat_unpack_rgba_8unorm(uint8_t *restrict dst_row, unsign
                                                unsigned width, unsigned height)
 {
    float *temp_block;
-   temp_block = malloc(width * height * 4 * sizeof(float));
+   temp_block = malloc((size_t)width * height * 4 * sizeof(float));
    decompress_rgb_float(width, height,
                         src_row, src_stride,
                         temp_block, width * 4 * sizeof(float),
diff --git a/src/util/format/u_format_fxt1.c b/src/util/format/u_format_fxt1.c
index d4512ebb74f91..59d2093dae01b 100644
--- a/src/util/format/u_format_fxt1.c
+++ b/src/util/format/u_format_fxt1.c
@@ -1184,7 +1184,7 @@ fxt1_encode (uint32_t width, uint32_t height, int32_t comps,
    if ((width & 7) | (height & 3)) {
       int32_t newWidth = (width + 7) & ~7;
       int32_t newHeight = (height + 3) & ~3;
-      newSource = malloc(comps * newWidth * newHeight * sizeof(uint8_t));
+      newSource = malloc((size_t)comps * newWidth * newHeight * sizeof(uint8_t));
       if (!newSource)
          return;
       upscale_teximage2d(width, height, newWidth, newHeight,
@@ -1558,7 +1558,7 @@ util_format_fxtn_rgb_unpack_rgba_8unorm(uint8_t *restrict dst_row, unsigned dst_
       for (x = 0; x < width; x += bw) {
          for (j = 0; j < bh; ++j) {
             for (i = 0; i < bw; ++i) {
-               uint8_t *dst = dst_row + (y + j) * dst_stride / sizeof(*dst_row) + (x + i) * comps;
+               uint8_t *dst = dst_row + (y + j) * dst_stride / (unsigned)sizeof(*dst_row) + (x + i) * comps;
                fxt1_decode_1(src, 0, i, j, dst);
                if (!rgba)
                   dst[3] = 0xff;
@@ -1605,7 +1605,7 @@ util_format_fxtn_rgb_unpack_rgba_float(float *dst_row, unsigned dst_stride,
       for (x = 0; x < width; x += 8) {
          for (j = 0; j < bh; ++j) {
             for (i = 0; i < bw; ++i) {
-               float *dst = dst_row + (y + j)*dst_stride/sizeof(*dst_row) + (x + i) * comps;
+               float *dst = dst_row + (y + j)*dst_stride/(unsigned)sizeof(*dst_row) + (x + i) * comps;
                uint8_t tmp[4];
                fxt1_decode_1(src, 0, i, j, tmp);
                dst[0] = ubyte_to_float(tmp[0]);
@@ -1657,7 +1657,7 @@ util_format_fxt1_rgb_pack_rgba_8unorm(uint8_t *restrict dst_row, unsigned dst_st
    /* The encoder for FXT1_RGB wants 24bpp packed rgb, so make a temporary to do that.
     */
    int temp_stride = width * 3;
-   uint8_t *temp = malloc(height * temp_stride);
+   uint8_t *temp = malloc((size_t)height * temp_stride);
    if (!temp)
       return;
 
@@ -1689,7 +1689,7 @@ util_format_fxt1_rgb_pack_rgba_float(uint8_t *restrict dst_row, unsigned dst_str
                                      unsigned width, unsigned height)
 {
    int temp_stride = width * 4;
-   uint8_t *temp = malloc(height * temp_stride);
+   uint8_t *temp = malloc((size_t)height * temp_stride);
    if (!temp)
       return;
 
@@ -1710,7 +1710,7 @@ util_format_fxt1_rgba_pack_rgba_float(uint8_t *restrict dst_row, unsigned dst_st
                                       unsigned width, unsigned height)
 {
    int temp_stride = width * 4;
-   uint8_t *temp = malloc(height * temp_stride);
+   uint8_t *temp = malloc((size_t)height * temp_stride);
    if (!temp)
       return;
 
diff --git a/src/util/format/u_format_rgtc.c b/src/util/format/u_format_rgtc.c
index 49c37b4fb9658..278021c2fbe51 100644
--- a/src/util/format/u_format_rgtc.c
+++ b/src/util/format/u_format_rgtc.c
@@ -51,7 +51,7 @@ util_format_rgtc1_unorm_unpack_r_8unorm(uint8_t *restrict dst_row, unsigned dst_
          const unsigned w = MIN2(width - x, bw);
          for(j = 0; j < h; ++j) {
             for(i = 0; i < w; ++i) {
-               uint8_t *dst = dst_row + (y + j)*dst_stride/sizeof(*dst_row) + (x + i)*comps;
+               uint8_t *dst = dst_row + (y + j)*dst_stride/(unsigned)sizeof(*dst_row) + (x + i)*comps;
                util_format_unsigned_fetch_texel_rgtc(0, src, i, j, dst, 1);
             }
          }
@@ -75,7 +75,7 @@ util_format_rgtc1_unorm_unpack_rgba_8unorm(uint8_t *restrict dst_row, unsigned d
          const unsigned w = MIN2(width - x, bw);
          for(j = 0; j < h; ++j) {
             for(i = 0; i < w; ++i) {
-               uint8_t *dst = dst_row + (y + j)*dst_stride/sizeof(*dst_row) + (x + i)*comps;
+               uint8_t *dst = dst_row + (y + j)*dst_stride/(unsigned)sizeof(*dst_row) + (x + i)*comps;
                util_format_unsigned_fetch_texel_rgtc(0, src, i, j, dst, 1);
                dst[1] = 0;
                dst[2] = 0;
@@ -101,7 +101,7 @@ util_format_rgtc1_unorm_pack_rgba_8unorm(uint8_t *restrict dst_row, unsigned dst
          uint8_t tmp[4][4];  /* [bh][bw][comps] */
          for(j = 0; j < bh; ++j) {
             for(i = 0; i < bw; ++i) {
-               tmp[j][i] = src_row[(y + j)*src_stride/sizeof(*src_row) + (x + i)*4];
+               tmp[j][i] = src_row[(y + j)*src_stride/(unsigned)sizeof(*src_row) + (x + i)*4];
             }
          }
          util_format_unsigned_encode_rgtc_ubyte(dst, tmp, 4, 4);
@@ -150,7 +150,7 @@ util_format_rgtc1_unorm_pack_rgba_float(uint8_t *restrict dst_row, unsigned dst_
          uint8_t tmp[4][4];  /* [bh][bw][comps] */
          for(j = 0; j < bh; ++j) {
             for(i = 0; i < bw; ++i) {
-               tmp[j][i] = float_to_ubyte(src_row[(y + j)*src_stride/sizeof(*src_row) + (x + i)*4]);
+               tmp[j][i] = float_to_ubyte(src_row[(y + j)*src_stride/(unsigned)sizeof(*src_row) + (x + i)*4]);
             }
          }
          util_format_unsigned_encode_rgtc_ubyte(dst, tmp, 4, 4);
@@ -203,7 +203,7 @@ util_format_rgtc1_snorm_unpack_r_8snorm(int8_t *restrict dst_row, unsigned dst_s
          const unsigned w = MIN2(width - x, bw);
          for(j = 0; j < h; ++j) {
             for(i = 0; i < w; ++i) {
-               int8_t *dst = dst_row + (y + j)*dst_stride/sizeof(*dst_row) + (x + i)*comps;
+               int8_t *dst = dst_row + (y + j)*dst_stride/(unsigned)sizeof(*dst_row) + (x + i)*comps;
                util_format_signed_fetch_texel_rgtc(0, (const int8_t *)src, i, j, dst, 1);
             }
          }
@@ -233,7 +233,7 @@ util_format_rgtc1_snorm_pack_rgba_float(uint8_t *restrict dst_row, unsigned dst_
          int8_t tmp[4][4];  /* [bh][bw][comps] */
          for(j = 0; j < bh; ++j) {
             for(i = 0; i < bw; ++i) {
-               tmp[j][i] = float_to_byte_tex(src_row[(y + j)*src_stride/sizeof(*src_row) + (x + i)*4]);
+               tmp[j][i] = float_to_byte_tex(src_row[(y + j)*src_stride/(unsigned)sizeof(*src_row) + (x + i)*4]);
             }
          }
          util_format_signed_encode_rgtc_ubyte(dst, tmp, 4, 4);
@@ -306,7 +306,7 @@ util_format_rgtc2_unorm_unpack_rg_8unorm(uint8_t *restrict dst_row, unsigned dst
          const unsigned w = MIN2(width - x, bw);
          for(j = 0; j < h; ++j) {
             for(i = 0; i < w; ++i) {
-               uint8_t *dst = dst_row + (y + j)*dst_stride/sizeof(*dst_row) + (x + i)*comps;
+               uint8_t *dst = dst_row + (y + j)*dst_stride/(unsigned)sizeof(*dst_row) + (x + i)*comps;
                util_format_unsigned_fetch_texel_rgtc(0, src, i, j, dst, 2);
                util_format_unsigned_fetch_texel_rgtc(0, src + 8, i, j, dst + 1, 2);
             }
@@ -331,7 +331,7 @@ util_format_rgtc2_unorm_unpack_rgba_8unorm(uint8_t *restrict dst_row, unsigned d
          const unsigned w = MIN2(width - x, bw);
          for(j = 0; j < h; ++j) {
             for(i = 0; i < w; ++i) {
-               uint8_t *dst = dst_row + (y + j)*dst_stride/sizeof(*dst_row) + (x + i)*comps;
+               uint8_t *dst = dst_row + (y + j)*dst_stride/(unsigned)sizeof(*dst_row) + (x + i)*comps;
                util_format_unsigned_fetch_texel_rgtc(0, src, i, j, dst, 2);
                util_format_unsigned_fetch_texel_rgtc(0, src + 8, i, j, dst + 1, 2);
                dst[2] = 0;
@@ -357,8 +357,8 @@ util_format_rgtc2_unorm_pack_rgba_8unorm(uint8_t *restrict dst_row, unsigned dst
          uint8_t tmp_g[4][4];  /* [bh][bw] */
          for(j = 0; j < bh; ++j) {
             for(i = 0; i < bw; ++i) {
-               tmp_r[j][i] = src_row[(y + j)*src_stride/sizeof(*src_row) + (x + i)*4];
-               tmp_g[j][i] = src_row[((y + j)*src_stride/sizeof(*src_row) + (x + i)*4) + 1];
+               tmp_r[j][i] = src_row[(y + j)*src_stride/(unsigned)sizeof(*src_row) + (x + i)*4];
+               tmp_g[j][i] = src_row[((y + j)*src_stride/(unsigned)sizeof(*src_row) + (x + i)*4) + 1];
             }
          }
          util_format_unsigned_encode_rgtc_ubyte(dst, tmp_r, 4, 4);
@@ -382,8 +382,8 @@ util_format_rxtc2_unorm_pack_rgba_float(uint8_t *restrict dst_row, unsigned dst_
          uint8_t tmp_g[4][4];  /* [bh][bw][comps] */
          for(j = 0; j < bh; ++j) {
             for(i = 0; i < bw; ++i) {
-               tmp_r[j][i] = float_to_ubyte(src_row[(y + j)*src_stride/sizeof(*src_row) + (x + i)*4]);
-               tmp_g[j][i] = float_to_ubyte(src_row[(y + j)*src_stride/sizeof(*src_row) + (x + i)*4 + chan2off]);
+               tmp_r[j][i] = float_to_ubyte(src_row[(y + j)*src_stride/(unsigned)sizeof(*src_row) + (x + i)*4]);
+               tmp_g[j][i] = float_to_ubyte(src_row[(y + j)*src_stride/(unsigned)sizeof(*src_row) + (x + i)*4 + chan2off]);
             }
          }
          util_format_unsigned_encode_rgtc_ubyte(dst, tmp_r, 4, 4);
@@ -473,7 +473,7 @@ util_format_rgtc2_snorm_unpack_rg_8snorm(int8_t *restrict dst_row, unsigned dst_
          const unsigned w = MIN2(width - x, bw);
          for(j = 0; j < h; ++j) {
             for(i = 0; i < w; ++i) {
-               int8_t *dst = dst_row + (y + j)*dst_stride/sizeof(*dst_row) + (x + i)*comps;
+               int8_t *dst = dst_row + (y + j)*dst_stride/(unsigned)sizeof(*dst_row) + (x + i)*comps;
                util_format_signed_fetch_texel_rgtc(0, (const int8_t *)src, i, j, (int8_t *)dst, 2);
                util_format_signed_fetch_texel_rgtc(0, (const int8_t *)src + 8, i, j, (int8_t *)dst + 1, 2);
             }
@@ -533,8 +533,8 @@ util_format_rxtc2_snorm_pack_rgba_float(uint8_t *restrict dst_row, unsigned dst_
          int8_t tmp_g[4][4];  /* [bh][bw][comps] */
          for(j = 0; j < bh; ++j) {
             for(i = 0; i < bw; ++i) {
-               tmp_r[j][i] = float_to_byte_tex(src_row[(y + j)*src_stride/sizeof(*src_row) + (x + i)*4]);
-               tmp_g[j][i] = float_to_byte_tex(src_row[(y + j)*src_stride/sizeof(*src_row) + (x + i)*4 + chan2off]);
+               tmp_r[j][i] = float_to_byte_tex(src_row[(y + j)*src_stride/(unsigned)sizeof(*src_row) + (x + i)*4]);
+               tmp_g[j][i] = float_to_byte_tex(src_row[(y + j)*src_stride/(unsigned)sizeof(*src_row) + (x + i)*4 + chan2off]);
             }
          }
          util_format_signed_encode_rgtc_ubyte(dst, tmp_r, 4, 4);
diff --git a/src/util/format/u_format_s3tc.c b/src/util/format/u_format_s3tc.c
index 02da5ffe89d88..532d89e6a05d3 100644
--- a/src/util/format/u_format_s3tc.c
+++ b/src/util/format/u_format_s3tc.c
@@ -135,7 +135,7 @@ util_format_dxtn_rgb_unpack_rgba_8unorm(uint8_t *restrict dst_row, unsigned dst_
          const unsigned w = MIN2(width - x, bw);
          for(j = 0; j < h; ++j) {
             for(i = 0; i < w; ++i) {
-               uint8_t *dst = dst_row + (y + j)*dst_stride/sizeof(*dst_row) + (x + i)*comps;
+               uint8_t *dst = dst_row + (y + j)*dst_stride/(unsigned)sizeof(*dst_row) + (x + i)*comps;
                fetch(0, src, i, j, dst);
                if (srgb) {
                   dst[0] = util_format_srgb_to_linear_8unorm(dst[0]);
@@ -211,7 +211,7 @@ util_format_dxtn_rgb_unpack_rgba_float(float *restrict dst_row, unsigned dst_str
       for(x = 0; x < width; x += 4) {
          for(j = 0; j < 4; ++j) {
             for(i = 0; i < 4; ++i) {
-               float *dst = dst_row + (y + j)*dst_stride/sizeof(*dst_row) + (x + i)*4;
+               float *dst = dst_row + (y + j)*dst_stride/(unsigned)sizeof(*dst_row) + (x + i)*4;
                uint8_t tmp[4];
                fetch(0, src, i, j, tmp);
                if (srgb) {
@@ -303,7 +303,7 @@ util_format_dxtn_pack_rgba_8unorm(uint8_t *restrict dst_row, unsigned dst_stride
             for(i = 0; i < bw; ++i) {
                uint8_t src_tmp;
                for(k = 0; k < 3; ++k) {
-                  src_tmp = src[(y + j)*src_stride/sizeof(*src) + (x+i)*comps + k];
+                  src_tmp = src[(y + j)*src_stride/(unsigned)sizeof(*src) + (x+i)*comps + k];
                   if (srgb) {
                      tmp[j][i][k] = util_format_linear_to_srgb_8unorm(src_tmp);
                   }
@@ -312,7 +312,7 @@ util_format_dxtn_pack_rgba_8unorm(uint8_t *restrict dst_row, unsigned dst_stride
                   }
                }
                /* for sake of simplicity there's an unneeded 4th component for dxt1_rgb */
-               tmp[j][i][3] = src[(y + j)*src_stride/sizeof(*src) + (x+i)*comps + 3];
+               tmp[j][i][3] = src[(y + j)*src_stride/(unsigned)sizeof(*src) + (x+i)*comps + 3];
             }
          }
          /* even for dxt1_rgb have 4 src comps */
@@ -380,7 +380,7 @@ util_format_dxtn_pack_rgba_float(uint8_t *restrict dst_row, unsigned dst_stride,
             for(i = 0; i < 4; ++i) {
                float src_tmp;
                for(k = 0; k < 3; ++k) {
-                  src_tmp = src[(y + j)*src_stride/sizeof(*src) + (x+i)*4 + k];
+                  src_tmp = src[(y + j)*src_stride/(unsigned)sizeof(*src) + (x+i)*4 + k];
                   if (srgb) {
                      tmp[j][i][k] = util_format_linear_float_to_srgb_8unorm(src_tmp);
                   }
@@ -389,7 +389,7 @@ util_format_dxtn_pack_rgba_float(uint8_t *restrict dst_row, unsigned dst_stride,
                   }
                }
                /* for sake of simplicity there's an unneeded 4th component for dxt1_rgb */
-               src_tmp = src[(y + j)*src_stride/sizeof(*src) + (x+i)*4 + 3];
+               src_tmp = src[(y + j)*src_stride/(unsigned)sizeof(*src) + (x+i)*4 + 3];
                tmp[j][i][3] = float_to_ubyte(src_tmp);
             }
          }
diff --git a/src/util/texcompress_astc_luts.cpp b/src/util/texcompress_astc_luts.cpp
index 6ffaf23ea886f..e59c3442877f9 100644
--- a/src/util/texcompress_astc_luts.cpp
+++ b/src/util/texcompress_astc_luts.cpp
@@ -325,7 +325,7 @@ ASTCLutHolder::PartitionTable::PartitionTable(unsigned block_width, unsigned blo
 
 	lut_width = block_width * 32;
 	lut_height = block_height * 32;
-	lut_buffer.resize(lut_width * lut_height);
+	lut_buffer.resize((size_t)lut_width * lut_height);
 
 	for (unsigned seed_y = 0; seed_y < 32; seed_y++)
 	{
-- 
GitLab

