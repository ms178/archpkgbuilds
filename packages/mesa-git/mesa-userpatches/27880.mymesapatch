From 1026c4f73d20fb7bf3f80505a62ee54f493422c3 Mon Sep 17 00:00:00 2001
From: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date: Thu, 29 Feb 2024 14:11:45 +0100
Subject: [PATCH 1/3] radv: disable NGG in more situations with ESO on
 GFX10/GFX10.3

NGG streamout isn't supported on GFX10/GFX10.3, so NGG GS must be
disabled when pre-rasterization stages are compiled separately because
it's not possible to know that when compiling VS/TES only.

Also GFX10/GFX10.3 needs to disable NGG when extreme geometry are used
with tessellation and we can't know the previous stage if the GS is
compiled separately.

Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
---
 src/amd/vulkan/radv_pipeline_graphics.c | 16 ++++++++++++++++
 1 file changed, 16 insertions(+)

diff --git a/src/amd/vulkan/radv_pipeline_graphics.c b/src/amd/vulkan/radv_pipeline_graphics.c
index e1dd6bfd7c9b2..6fe8da77e8cca 100644
--- a/src/amd/vulkan/radv_pipeline_graphics.c
+++ b/src/amd/vulkan/radv_pipeline_graphics.c
@@ -2045,6 +2045,22 @@ radv_fill_shader_info_ngg(struct radv_device *device, struct radv_shader_stage *
          else
             stages[MESA_SHADER_GEOMETRY].info.is_ngg = stages[MESA_SHADER_VERTEX].info.is_ngg;
       }
+
+      /* When pre-rasterization stages are compiled separately with shader objects, NGG GS needs to
+       * be disabled because if the next stage of VS/TES is GS and GS is unknown, it might use
+       * streamout but it's not possible to know that when compiling VS or TES only.
+       */
+      if (stages[MESA_SHADER_VERTEX].nir && stages[MESA_SHADER_VERTEX].info.next_stage == MESA_SHADER_GEOMETRY &&
+          !stages[MESA_SHADER_GEOMETRY].nir) {
+         stages[MESA_SHADER_VERTEX].info.is_ngg = false;
+      } else if (stages[MESA_SHADER_TESS_EVAL].nir &&
+                 stages[MESA_SHADER_TESS_EVAL].info.next_stage == MESA_SHADER_GEOMETRY &&
+                 !stages[MESA_SHADER_GEOMETRY].nir) {
+         stages[MESA_SHADER_TESS_EVAL].info.is_ngg = false;
+      } else if (stages[MESA_SHADER_GEOMETRY].nir &&
+                 (!stages[MESA_SHADER_VERTEX].nir && !stages[MESA_SHADER_TESS_EVAL].nir)) {
+         stages[MESA_SHADER_GEOMETRY].info.is_ngg = false;
+      }
    }
 }
 
-- 
GitLab


From 597fc50a690faf9cb67ba0a2490ad2f36428c8f3 Mon Sep 17 00:00:00 2001
From: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date: Thu, 29 Feb 2024 14:22:42 +0100
Subject: [PATCH 2/3] radv: implement has_vgt_flush_ngg_legacy_bug for ESO

Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
---
 src/amd/vulkan/radv_cmd_buffer.c | 9 +++++++++
 1 file changed, 9 insertions(+)

diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index ea7baffb5e797..10e73ac3d38f0 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -9371,6 +9371,15 @@ radv_bind_graphics_shaders(struct radv_cmd_buffer *cmd_buffer)
    const gl_shader_stage last_vgt_api_stage = radv_cmdbuf_get_last_vgt_api_stage(cmd_buffer);
 
    assume(last_vgt_api_stage != MESA_SHADER_NONE);
+   if (device->physical_device->rad_info.has_vgt_flush_ngg_legacy_bug &&
+       (!cmd_buffer->state.last_vgt_shader || (cmd_buffer->state.last_vgt_shader->info.is_ngg !=
+                                               cmd_buffer->state.shaders[last_vgt_api_stage]->info.is_ngg))) {
+      /* Transitioning from NGG to legacy GS requires VGT_FLUSH on GFX10 and Navi21. VGT_FLUSH is
+       * also emitted at the beginning of IBs when legacy GS ring pointers are set.
+       */
+      cmd_buffer->state.flush_bits |= RADV_CMD_FLAG_VGT_FLUSH;
+   }
+
    cmd_buffer->state.last_vgt_shader = cmd_buffer->state.shaders[last_vgt_api_stage];
 
    cmd_buffer->state.gs_copy_shader = cmd_buffer->state.shader_objs[MESA_SHADER_GEOMETRY]
-- 
GitLab


From 37a120f952db38feed8fd3d2ac2cc2b32b9e7705 Mon Sep 17 00:00:00 2001
From: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date: Thu, 29 Feb 2024 14:25:18 +0100
Subject: [PATCH 3/3] radv: allow RADV_PERFTEST=shader_object on GFX10/GFX10.3

VK_EXT_shader_object is now supported on all GPUs! It's still not
enabled by default because it needs more testing and more fixing (Renoir
still hangs for some reasons and Zink/RADV on Polaris10 still has
flakes).

Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
---
 src/amd/vulkan/radv_physical_device.c | 5 ++---
 1 file changed, 2 insertions(+), 3 deletions(-)

diff --git a/src/amd/vulkan/radv_physical_device.c b/src/amd/vulkan/radv_physical_device.c
index cf1a06168a150..97132972309f8 100644
--- a/src/amd/vulkan/radv_physical_device.c
+++ b/src/amd/vulkan/radv_physical_device.c
@@ -99,9 +99,8 @@ static bool
 radv_shader_object_enabled(const struct radv_physical_device *pdevice)
 {
    /* FIXME: Fix GPU hangs on Renoir. */
-   return (pdevice->rad_info.gfx_level < GFX9 || pdevice->rad_info.gfx_level == GFX11 ||
-           pdevice->rad_info.family == CHIP_VEGA10) &&
-          !pdevice->use_llvm && pdevice->instance->perftest_flags & RADV_PERFTEST_SHADER_OBJECT;
+   return (pdevice->rad_info.gfx_level != GFX9 || pdevice->rad_info.family == CHIP_VEGA10) && !pdevice->use_llvm &&
+          pdevice->instance->perftest_flags & RADV_PERFTEST_SHADER_OBJECT;
 }
 
 bool
-- 
GitLab

