From 79b04d677c5da320ceff504be289d312046b219e Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Fri, 10 Mar 2023 23:03:58 -0500
Subject: [PATCH 01/15] nir: fix 2 bugs in nir_create_passthrough_tcs

- VAR31 was ignored.
- Only a half of the 16-bit slot was passed through, though I'm not sure
  if nir_lower_io handles vec8. The slots are only for GLES and I don't
  think a passthrough TCS is possible with GLES.

Fixes: a8e84f50bc6c8 - nir: Add helper to create passthrough TCS shader
---
 src/compiler/nir/nir_passthrough_tcs.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/src/compiler/nir/nir_passthrough_tcs.c b/src/compiler/nir/nir_passthrough_tcs.c
index d0ddca21adcc..582e7124efc9 100644
--- a/src/compiler/nir/nir_passthrough_tcs.c
+++ b/src/compiler/nir/nir_passthrough_tcs.c
@@ -77,10 +77,10 @@ nir_create_passthrough_tcs_impl(const nir_shader_compiler_options *options,
    for (unsigned i = 0; i < num_locations; i++) {
       const struct glsl_type *type;
       unsigned semantic = locations[i];
-      if (semantic < VARYING_SLOT_VAR31 && semantic != VARYING_SLOT_EDGE)
+      if (semantic <= VARYING_SLOT_VAR31 && semantic != VARYING_SLOT_EDGE)
          type = glsl_array_type(glsl_vec4_type(), 0, 0);
       else if (semantic >= VARYING_SLOT_VAR0_16BIT)
-         type = glsl_array_type(glsl_vector_type(GLSL_TYPE_FLOAT16, 4), 0, 0);
+         type = glsl_array_type(glsl_vector_type(GLSL_TYPE_FLOAT16, 8), 0, 0);
       else
          continue;
 
-- 
GitLab


From c0b5db20b6e8b59c5fffa747c5063f0647a60824 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Tue, 28 Feb 2023 17:24:08 -0500
Subject: [PATCH 02/15] nir: lower load_barycentric_at_offset in
 lower_wpos_ytransform

so that we can run this pass on lowered IO.
---
 src/compiler/nir/nir_lower_wpos_ytransform.c | 21 ++++++++++++++++++++
 1 file changed, 21 insertions(+)

diff --git a/src/compiler/nir/nir_lower_wpos_ytransform.c b/src/compiler/nir/nir_lower_wpos_ytransform.c
index cd0d06f93658..0e0fdf1eb1c4 100644
--- a/src/compiler/nir/nir_lower_wpos_ytransform.c
+++ b/src/compiler/nir/nir_lower_wpos_ytransform.c
@@ -275,6 +275,25 @@ lower_interp_deref_at_offset(lower_wpos_ytransform_state *state,
                                                      flip_y)));
 }
 
+/* Multiply load_barycentric_at_offset's offset by transform.x to flip it. */
+static void
+lower_load_barycentric_at_offset(lower_wpos_ytransform_state *state,
+                                 nir_intrinsic_instr *baryc)
+{
+   nir_builder *b = &state->b;
+   nir_ssa_def *offset;
+   nir_ssa_def *flip_y;
+
+   b->cursor = nir_before_instr(&baryc->instr);
+
+   offset = nir_ssa_for_src(b, baryc->src[0], 2);
+   flip_y = nir_fmul(b, nir_channel(b, offset, 1),
+                        nir_channel(b, get_transform(state), 0));
+   nir_instr_rewrite_src(&baryc->instr, &baryc->src[0],
+                         nir_src_for_ssa(nir_vec2(b, nir_channel(b, offset, 0),
+                                                  flip_y)));
+}
+
 static void
 lower_load_sample_pos(lower_wpos_ytransform_state *state,
                       nir_intrinsic_instr *intr)
@@ -321,6 +340,8 @@ lower_wpos_ytransform_block(lower_wpos_ytransform_state *state, nir_block *block
             lower_load_sample_pos(state, intr);
          } else if (intr->intrinsic == nir_intrinsic_interp_deref_at_offset) {
             lower_interp_deref_at_offset(state, intr);
+         } else if (intr->intrinsic == nir_intrinsic_load_barycentric_at_offset) {
+            lower_load_barycentric_at_offset(state, intr);
          }
       } else if (instr->type == nir_instr_type_alu) {
          nir_alu_instr *alu = nir_instr_as_alu(instr);
-- 
GitLab


From fd53badc50f9ac3fdfe6a567278980ead209878d Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Tue, 28 Feb 2023 14:59:09 -0500
Subject: [PATCH 03/15] nir: assign IO bases in nir_lower_io_passes

---
 src/compiler/nir/nir_lower_io.c | 18 ++++++++++++++++++
 1 file changed, 18 insertions(+)

diff --git a/src/compiler/nir/nir_lower_io.c b/src/compiler/nir/nir_lower_io.c
index a65242e1e9c6..53b2ce3d4fbb 100644
--- a/src/compiler/nir/nir_lower_io.c
+++ b/src/compiler/nir/nir_lower_io.c
@@ -3128,6 +3128,10 @@ type_size_vec4(const struct glsl_type *type, bool bindless)
    return glsl_count_attribute_slots(type, false);
 }
 
+/**
+ * This runs all compiler passes needed to lower IO, lower indirect IO access,
+ * set transform feedback info in IO intrinsics, and clean up the IR.
+ */
 void
 nir_lower_io_passes(nir_shader *nir)
 {
@@ -3162,6 +3166,20 @@ nir_lower_io_passes(nir_shader *nir)
    NIR_PASS_V(nir, nir_lower_io, nir_var_shader_out | nir_var_shader_in,
               type_size_vec4, nir_lower_io_lower_64bit_to_32);
 
+   /* If IO is lowered before var->data.driver_location is assigned, driver
+    * locations are all 0, which means IO bases are all 0. It's not necessary
+    * to set driver_location before lowering IO because the only thing that
+    * identifies outputs is their semantic, and IO bases can always be
+    * computed from the semantics.
+    *
+    * This assigns IO bases from scratch, using IO semantics to tell which
+    * intrinsics refer to the same IO. If the bases already exist, they
+    * will be reassigned, sorted by the semantic, and all holes removed.
+    * This kind of canonicalizes all bases.
+    */
+   NIR_PASS_V(nir, nir_recompute_io_bases,
+              nir_var_shader_in | nir_var_shader_out);
+
    /* nir_io_add_const_offset_to_base needs actual constants. */
    NIR_PASS_V(nir, nir_opt_constant_folding);
    NIR_PASS_V(nir, nir_io_add_const_offset_to_base, nir_var_shader_in |
-- 
GitLab


From ae047ffaae6e5869ef2de6535b801c0cd6c487f5 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Tue, 28 Feb 2023 15:12:21 -0500
Subject: [PATCH 04/15] nir: skip nir_lower_io_passes for compute shaders

---
 src/compiler/nir/nir_lower_io.c | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/src/compiler/nir/nir_lower_io.c b/src/compiler/nir/nir_lower_io.c
index 53b2ce3d4fbb..6569f0057379 100644
--- a/src/compiler/nir/nir_lower_io.c
+++ b/src/compiler/nir/nir_lower_io.c
@@ -3135,7 +3135,8 @@ type_size_vec4(const struct glsl_type *type, bool bindless)
 void
 nir_lower_io_passes(nir_shader *nir)
 {
-   if (!nir->options->lower_io_variables)
+   if (!nir->options->lower_io_variables ||
+       nir->info.stage == MESA_SHADER_COMPUTE)
       return;
 
    bool has_indirect_inputs =
-- 
GitLab


From bbc7ef02a6b1a7ad2c9bbfa0d38a4fda69966ac8 Mon Sep 17 00:00:00 2001
From: Mihai Preda <mhpreda@gmail.com>
Date: Wed, 29 Jun 2022 15:18:41 +0300
Subject: [PATCH 05/15] nir: update nir->num_inputs, num_outputs in
 nir_recompute_io_bases()

Since nir_recompute_io_bases is going to be used instead of
nir_assign_io_var_locations, we need to update num_inputs, num_outputs.
---
 src/compiler/nir/nir_lower_mediump.c | 5 +++++
 1 file changed, 5 insertions(+)

diff --git a/src/compiler/nir/nir_lower_mediump.c b/src/compiler/nir/nir_lower_mediump.c
index 2e7a40d2359a..ecd031c832ad 100644
--- a/src/compiler/nir/nir_lower_mediump.c
+++ b/src/compiler/nir/nir_lower_mediump.c
@@ -130,6 +130,11 @@ nir_recompute_io_bases(nir_shader *nir, nir_variable_mode modes)
       nir_metadata_preserve(impl, nir_metadata_all);
    }
 
+   if (modes & nir_var_shader_in)
+      nir->num_inputs = BITSET_COUNT(inputs);
+   if (modes & nir_var_shader_out)
+      nir->num_outputs = BITSET_COUNT(outputs);
+
    return changed;
 }
 
-- 
GitLab


From 1d1f0ec025f944e1f523ed66ac3b7d7eb81e58d5 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Tue, 28 Feb 2023 23:41:59 -0500
Subject: [PATCH 06/15] nir: extend nir_opt_fragdepth to handle lowered IO

Move the existing code into a switch case and add a new one.
---
 src/compiler/nir/nir_opt_fragdepth.c | 65 ++++++++++++++++++++--------
 1 file changed, 47 insertions(+), 18 deletions(-)

diff --git a/src/compiler/nir/nir_opt_fragdepth.c b/src/compiler/nir/nir_opt_fragdepth.c
index 96da27cf94e6..28fe012aad82 100644
--- a/src/compiler/nir/nir_opt_fragdepth.c
+++ b/src/compiler/nir/nir_opt_fragdepth.c
@@ -63,30 +63,59 @@ nir_opt_fragdepth(nir_shader *shader)
             continue;
 
          nir_intrinsic_instr *intrin = nir_instr_as_intrinsic(instr);
-         if (intrin->intrinsic != nir_intrinsic_store_deref)
-            continue;
 
-         nir_deref_instr *deref = nir_src_as_deref(intrin->src[0]);
-         if (!nir_deref_mode_is(deref, nir_var_shader_out))
-            continue;
+         switch (intrin->intrinsic) {
+         case nir_intrinsic_store_deref: {
+            nir_deref_instr *deref = nir_src_as_deref(intrin->src[0]);
+            if (!nir_deref_mode_is(deref, nir_var_shader_out))
+               continue;
 
-         nir_variable *var = nir_deref_instr_get_variable(deref);
-         if (var->data.location != FRAG_RESULT_DEPTH)
-            continue;
+            nir_variable *var = nir_deref_instr_get_variable(deref);
+            if (var->data.location != FRAG_RESULT_DEPTH)
+               continue;
 
-         /* We found a write to gl_FragDepth */
-         if (store_intrin) {
-            /* This isn't the only write: give up on this optimization */
-            goto end;
-         } else {
-            if (ssa_def_is_source_depth(intrin->src[1].ssa)) {
-               /* We're writing gl_FragCoord.z in gl_FragDepth: remember
-                * intrin so we can try to remove it later. */
-               store_intrin = intrin;
+            /* We found a write to gl_FragDepth */
+            if (store_intrin) {
+               /* This isn't the only write: give up on this optimization */
+               goto end;
             } else {
-               /* We're writing something else: give up. */
+               if (ssa_def_is_source_depth(intrin->src[1].ssa)) {
+                  /* We're writing gl_FragCoord.z in gl_FragDepth: remember
+                   * intrin so we can try to remove it later. */
+                  store_intrin = intrin;
+               } else {
+                  /* We're writing something else: give up. */
+                  goto end;
+               }
+            }
+            break;
+         }
+
+         case nir_intrinsic_store_output: {
+            nir_io_semantics sem = nir_intrinsic_io_semantics(intrin);
+
+            if (sem.location != FRAG_RESULT_DEPTH)
+               continue;
+
+            /* We found a write to gl_FragDepth */
+            if (store_intrin) {
+               /* This isn't the only write: give up on this optimization */
                goto end;
+            } else {
+               if (ssa_def_is_source_depth(intrin->src[0].ssa)) {
+                  /* We're writing gl_FragCoord.z in gl_FragDepth: remember
+                   * intrin so we can try to remove it later. */
+                  store_intrin = intrin;
+               } else {
+                  /* We're writing something else: give up. */
+                  goto end;
+               }
             }
+            break;
+         }
+
+         default:
+            break;
          }
       }
    }
-- 
GitLab


From 938d95a5cf6ff9d8b53344cfecc3f5a7c28f2fe5 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Sun, 5 Mar 2023 00:21:16 -0500
Subject: [PATCH 07/15] nir: handle more opcodes in nir_lower_io_to_scalar

It just works.
---
 src/compiler/nir/nir_lower_io_to_scalar.c | 6 ++++--
 1 file changed, 4 insertions(+), 2 deletions(-)

diff --git a/src/compiler/nir/nir_lower_io_to_scalar.c b/src/compiler/nir/nir_lower_io_to_scalar.c
index 6b157926541f..cc9f738a1141 100644
--- a/src/compiler/nir/nir_lower_io_to_scalar.c
+++ b/src/compiler/nir/nir_lower_io_to_scalar.c
@@ -231,13 +231,15 @@ nir_lower_io_to_scalar_instr(nir_builder *b, nir_instr *instr, void *data)
       return false;
 
    if ((intr->intrinsic == nir_intrinsic_load_input ||
-        intr->intrinsic == nir_intrinsic_load_per_vertex_input) &&
+        intr->intrinsic == nir_intrinsic_load_per_vertex_input ||
+        intr->intrinsic == nir_intrinsic_load_interpolated_input) &&
        (mask & nir_var_shader_in)) {
       lower_load_input_to_scalar(b, intr);
       return true;
    }
 
-   if (intr->intrinsic == nir_intrinsic_load_per_vertex_output &&
+   if ((intr->intrinsic == nir_intrinsic_load_output ||
+        intr->intrinsic == nir_intrinsic_load_per_vertex_output) &&
       (mask & nir_var_shader_out)) {
       lower_load_input_to_scalar(b, intr);
       return true;
-- 
GitLab


From 8566cf92db4c885c0b518414e67e9e15ee76d0f7 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Sat, 11 Mar 2023 00:26:38 -0500
Subject: [PATCH 08/15] nir: handle all varying slots in
 gl_varying_slot_name_for_stage

---
 src/compiler/shader_enums.c | 50 ++++++++++++++++++++++++++++++++++++-
 1 file changed, 49 insertions(+), 1 deletion(-)

diff --git a/src/compiler/shader_enums.c b/src/compiler/shader_enums.c
index 15d1923562da..c7f31ccaf23f 100644
--- a/src/compiler/shader_enums.c
+++ b/src/compiler/shader_enums.c
@@ -250,8 +250,56 @@ gl_varying_slot_name_for_stage(gl_varying_slot slot, gl_shader_stage stage)
       ENUM(VARYING_SLOT_VAR29),
       ENUM(VARYING_SLOT_VAR30),
       ENUM(VARYING_SLOT_VAR31),
+      ENUM(VARYING_SLOT_PATCH0),
+      ENUM(VARYING_SLOT_PATCH1),
+      ENUM(VARYING_SLOT_PATCH2),
+      ENUM(VARYING_SLOT_PATCH3),
+      ENUM(VARYING_SLOT_PATCH4),
+      ENUM(VARYING_SLOT_PATCH5),
+      ENUM(VARYING_SLOT_PATCH6),
+      ENUM(VARYING_SLOT_PATCH7),
+      ENUM(VARYING_SLOT_PATCH8),
+      ENUM(VARYING_SLOT_PATCH9),
+      ENUM(VARYING_SLOT_PATCH10),
+      ENUM(VARYING_SLOT_PATCH11),
+      ENUM(VARYING_SLOT_PATCH12),
+      ENUM(VARYING_SLOT_PATCH13),
+      ENUM(VARYING_SLOT_PATCH14),
+      ENUM(VARYING_SLOT_PATCH15),
+      ENUM(VARYING_SLOT_PATCH16),
+      ENUM(VARYING_SLOT_PATCH17),
+      ENUM(VARYING_SLOT_PATCH18),
+      ENUM(VARYING_SLOT_PATCH19),
+      ENUM(VARYING_SLOT_PATCH20),
+      ENUM(VARYING_SLOT_PATCH21),
+      ENUM(VARYING_SLOT_PATCH22),
+      ENUM(VARYING_SLOT_PATCH23),
+      ENUM(VARYING_SLOT_PATCH24),
+      ENUM(VARYING_SLOT_PATCH25),
+      ENUM(VARYING_SLOT_PATCH26),
+      ENUM(VARYING_SLOT_PATCH27),
+      ENUM(VARYING_SLOT_PATCH28),
+      ENUM(VARYING_SLOT_PATCH29),
+      ENUM(VARYING_SLOT_PATCH30),
+      ENUM(VARYING_SLOT_PATCH31),
+      ENUM(VARYING_SLOT_VAR0_16BIT),
+      ENUM(VARYING_SLOT_VAR1_16BIT),
+      ENUM(VARYING_SLOT_VAR2_16BIT),
+      ENUM(VARYING_SLOT_VAR3_16BIT),
+      ENUM(VARYING_SLOT_VAR4_16BIT),
+      ENUM(VARYING_SLOT_VAR5_16BIT),
+      ENUM(VARYING_SLOT_VAR6_16BIT),
+      ENUM(VARYING_SLOT_VAR7_16BIT),
+      ENUM(VARYING_SLOT_VAR8_16BIT),
+      ENUM(VARYING_SLOT_VAR9_16BIT),
+      ENUM(VARYING_SLOT_VAR10_16BIT),
+      ENUM(VARYING_SLOT_VAR11_16BIT),
+      ENUM(VARYING_SLOT_VAR12_16BIT),
+      ENUM(VARYING_SLOT_VAR13_16BIT),
+      ENUM(VARYING_SLOT_VAR14_16BIT),
+      ENUM(VARYING_SLOT_VAR15_16BIT),
    };
-   STATIC_ASSERT(ARRAY_SIZE(names) == VARYING_SLOT_MAX);
+   STATIC_ASSERT(ARRAY_SIZE(names) == NUM_TOTAL_VARYING_SLOTS);
    return NAME(slot);
 }
 
-- 
GitLab


From fcccbffb920d916bd6805dae877952bfdd0d45e4 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Sun, 12 Mar 2023 03:20:14 -0400
Subject: [PATCH 09/15] nir: handle scalar math opcodes in nir_opt_undef

This is not exhaustive, but should be enough for now.
---
 src/compiler/nir/nir_opt_undef.c | 119 ++++++++++++++++++++++++++++++-
 1 file changed, 118 insertions(+), 1 deletion(-)

diff --git a/src/compiler/nir/nir_opt_undef.c b/src/compiler/nir/nir_opt_undef.c
index effd9d0057a4..f87774b358c2 100644
--- a/src/compiler/nir/nir_opt_undef.c
+++ b/src/compiler/nir/nir_opt_undef.c
@@ -189,12 +189,129 @@ opt_undef_pack(nir_builder *b, nir_alu_instr *alu)
    return true;
 }
 
+static bool
+opt_undef_scalar_math_alu(nir_builder *b, nir_alu_instr *alu)
+{
+   if (nir_dest_num_components(alu->dest.dest) != 1)
+      return false;
+
+   unsigned num_srcs = nir_op_infos[alu->op].num_inputs;
+   bool has_undef = false;
+
+   for (unsigned i = 0; i < num_srcs; i++) {
+      if (nir_src_is_undef(alu->src[i].src)) {
+         has_undef = true;
+         break;
+      }
+   }
+
+   if (!has_undef)
+      return false;
+
+   /* Only opcodes with floating-point operands and comparions are replaced
+    * because expressions with integer opcodes can have defined behavior with
+    * undef, for example: iand(0xff, iadd(ishl(undef, 16), 1)) == 1
+    * Integer multiplication has the same issue as shifts.
+    *
+    * For floating-point ops, we can assume that undef can be replaced by NaN,
+    * in which case any FP op doesn't do anything.
+    *
+    * TODO: Add these into nir_opt_algebraic because all of these handle NaN
+    *       differently in hw:
+    *          fmax(a, undef) -> a
+    *          fmin(a, undef) -> a
+    *          fsat(undef) -> 0
+    */
+   switch (alu->op) {
+   case nir_op_f2f16:
+   case nir_op_f2f16_rtne:
+   case nir_op_f2f16_rtz:
+   case nir_op_f2f32:
+   case nir_op_f2f64:
+   case nir_op_f2fmp:
+   case nir_op_f2i1:
+   case nir_op_f2i16:
+   case nir_op_f2i32:
+   case nir_op_f2i64:
+   case nir_op_f2i8:
+   case nir_op_f2imp:
+   case nir_op_f2u1:
+   case nir_op_f2u16:
+   case nir_op_f2u32:
+   case nir_op_f2u64:
+   case nir_op_f2u8:
+   case nir_op_f2ump:
+   case nir_op_fabs:
+   case nir_op_fadd:
+   case nir_op_fceil:
+   case nir_op_fcos:
+   case nir_op_fddx:
+   case nir_op_fddx_coarse:
+   case nir_op_fddx_fine:
+   case nir_op_fddy:
+   case nir_op_fddy_coarse:
+   case nir_op_fddy_fine:
+   case nir_op_fdiv:
+   case nir_op_feq:
+   case nir_op_fexp2:
+   case nir_op_ffloor:
+   case nir_op_ffma:
+   case nir_op_ffmaz:
+   case nir_op_ffract:
+   case nir_op_fge:
+   case nir_op_fisfinite:
+   case nir_op_fisnormal:
+   case nir_op_flog2:
+   case nir_op_flrp:
+   case nir_op_flt:
+   case nir_op_fmod:
+   case nir_op_fmul:
+   case nir_op_fmulz:
+   case nir_op_fneg:
+   case nir_op_fneu:
+   case nir_op_fpow:
+   case nir_op_frcp:
+   case nir_op_frem:
+   case nir_op_fround_even:
+   case nir_op_frsq:
+   case nir_op_fsign:
+   case nir_op_fsin:
+   case nir_op_fsqrt:
+   case nir_op_fsub:
+   case nir_op_ftrunc:
+   case nir_op_i2f16:
+   case nir_op_i2f32:
+   case nir_op_i2f64:
+   case nir_op_i2fmp:
+   case nir_op_ieq:
+   case nir_op_ige:
+   case nir_op_ilt:
+   case nir_op_ine:
+   case nir_op_u2f16:
+   case nir_op_u2f32:
+   case nir_op_u2f64:
+   case nir_op_u2fmp:
+   case nir_op_uge:
+   case nir_op_ult:
+      break;
+   default:
+      return false;
+   }
+
+   b->cursor = nir_before_instr(&alu->instr);
+   nir_ssa_def *def = nir_ssa_undef(b, 1, nir_dest_bit_size(alu->dest.dest));
+   nir_ssa_def_rewrite_uses_after(&alu->dest.dest.ssa, def, &alu->instr);
+   nir_instr_remove(&alu->instr);
+   return true;
+}
+
 static bool
 nir_opt_undef_instr(nir_builder *b, nir_instr *instr, void *data)
 {
    if (instr->type == nir_instr_type_alu) {
       nir_alu_instr *alu = nir_instr_as_alu(instr);
-      return opt_undef_csel(alu) || opt_undef_vecN(b, alu) || opt_undef_pack(b, alu);
+      return opt_undef_csel(alu) || opt_undef_vecN(b, alu) ||
+             opt_undef_pack(b, alu) || opt_undef_scalar_math_alu(b, alu);
    } else if (instr->type == nir_instr_type_intrinsic) {
       nir_intrinsic_instr *intrin = nir_instr_as_intrinsic(instr);
       return opt_undef_store(intrin);
-- 
GitLab


From 0a2e94f45879a0680807cd60fd3f07ebe405a77d Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Tue, 28 Feb 2023 23:12:58 -0500
Subject: [PATCH 10/15] nir: don't remove dead IO variables in
 nir_lower_io_passes for st_link_nir

We need to keep variables in the IR because a few places use them,
like nir_build_program_resource_list. This will allow us to lower IO
in the linker.
---
 src/compiler/nir/nir_lower_io.c              | 3 +--
 src/gallium/drivers/radeonsi/si_shader_nir.c | 1 +
 src/mesa/state_tracker/st_glsl_to_nir.cpp    | 5 ++++-
 3 files changed, 6 insertions(+), 3 deletions(-)

diff --git a/src/compiler/nir/nir_lower_io.c b/src/compiler/nir/nir_lower_io.c
index 6569f0057379..ec285aca3782 100644
--- a/src/compiler/nir/nir_lower_io.c
+++ b/src/compiler/nir/nir_lower_io.c
@@ -3189,8 +3189,7 @@ nir_lower_io_passes(nir_shader *nir)
    /* Lower and remove dead derefs and variables to clean up the IR. */
    NIR_PASS_V(nir, nir_lower_vars_to_ssa);
    NIR_PASS_V(nir, nir_opt_dce);
-   NIR_PASS_V(nir, nir_remove_dead_variables, nir_var_function_temp |
-              nir_var_shader_in | nir_var_shader_out, NULL);
+   NIR_PASS_V(nir, nir_remove_dead_variables, nir_var_function_temp, NULL);
 
    if (nir->xfb_info)
       NIR_PASS_V(nir, nir_io_add_intrinsic_xfb_info);
diff --git a/src/gallium/drivers/radeonsi/si_shader_nir.c b/src/gallium/drivers/radeonsi/si_shader_nir.c
index db2ac4c31dce..3906feef951b 100644
--- a/src/gallium/drivers/radeonsi/si_shader_nir.c
+++ b/src/gallium/drivers/radeonsi/si_shader_nir.c
@@ -358,6 +358,7 @@ char *si_finalize_nir(struct pipe_screen *screen, void *nirptr)
    struct nir_shader *nir = (struct nir_shader *)nirptr;
 
    nir_lower_io_passes(nir);
+   NIR_PASS_V(nir, nir_remove_dead_variables, nir_var_shader_in | nir_var_shader_out, NULL);
 
    NIR_PASS_V(nir, ac_nir_lower_subdword_loads,
               (ac_nir_lower_subdword_options) {
diff --git a/src/mesa/state_tracker/st_glsl_to_nir.cpp b/src/mesa/state_tracker/st_glsl_to_nir.cpp
index 3a7b5e012b11..35e196b3e143 100644
--- a/src/mesa/state_tracker/st_glsl_to_nir.cpp
+++ b/src/mesa/state_tracker/st_glsl_to_nir.cpp
@@ -1064,8 +1064,11 @@ st_finalize_nir(struct st_context *st, struct gl_program *prog,
    /* Lower load_deref/store_deref of inputs and outputs.
     * This depends on st_nir_assign_varying_locations.
     */
-   if (nir->options->lower_io_variables)
+   if (nir->options->lower_io_variables) {
       nir_lower_io_passes(nir);
+      NIR_PASS_V(nir, nir_remove_dead_variables,
+                 nir_var_shader_in | nir_var_shader_out, NULL);
+   }
 
    /* Set num_uniforms in number of attribute slots (vec4s) */
    nir->num_uniforms = DIV_ROUND_UP(prog->Parameters->NumParameterValues, 4);
-- 
GitLab


From 1057c6272adb53fefd6413d1b9c697fdcecc8107 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Thu, 9 Mar 2023 21:30:41 -0500
Subject: [PATCH 11/15] nir: rework nir_lower_color_inputs to work with lowered
 IO intrinsics

also only call it from radeonsi and remove the option
---
 src/compiler/nir/nir.h                       | 13 +---
 src/compiler/nir/nir_lower_io.c              | 77 ++++++++++++++------
 src/gallium/drivers/radeonsi/si_get.c        |  1 -
 src/gallium/drivers/radeonsi/si_shader_nir.c |  3 +
 4 files changed, 59 insertions(+), 35 deletions(-)

diff --git a/src/compiler/nir/nir.h b/src/compiler/nir/nir.h
index 92285137fbd4..9edfa39830b0 100644
--- a/src/compiler/nir/nir.h
+++ b/src/compiler/nir/nir.h
@@ -3795,13 +3795,6 @@ typedef struct nir_shader_compiler_options {
     */
    bool lower_io_variables;
 
-   /**
-    * Lower color inputs to load_colorN that are kind of like system values
-    * if lower_io_variables is also set. shader_info will contain
-    * the interpolation settings. This is used by nir_lower_io_passes.
-    */
-   bool lower_fs_color_inputs;
-
    /**
     * The masks of shader stages that support indirect indexing with
     * load_input and store_output intrinsics. It's used when
@@ -4796,10 +4789,8 @@ bool nir_lower_io(nir_shader *shader,
                   nir_lower_io_options);
 
 bool nir_io_add_const_offset_to_base(nir_shader *nir, nir_variable_mode modes);
-
-void
-nir_lower_io_passes(nir_shader *nir);
-
+bool nir_lower_color_inputs(nir_shader *nir);
+void nir_lower_io_passes(nir_shader *nir);
 bool nir_io_add_intrinsic_xfb_info(nir_shader *nir);
 
 bool
diff --git a/src/compiler/nir/nir_lower_io.c b/src/compiler/nir/nir_lower_io.c
index ec285aca3782..c68745aa2b36 100644
--- a/src/compiler/nir/nir_lower_io.c
+++ b/src/compiler/nir/nir_lower_io.c
@@ -2990,7 +2990,7 @@ nir_io_add_const_offset_to_base(nir_shader *nir, nir_variable_mode modes)
    return progress;
 }
 
-static bool
+bool
 nir_lower_color_inputs(nir_shader *nir)
 {
    nir_function_impl *impl = nir_shader_get_entrypoint(nir);
@@ -3006,32 +3006,67 @@ nir_lower_color_inputs(nir_shader *nir)
 
          nir_intrinsic_instr *intrin = nir_instr_as_intrinsic(instr);
 
-         if (intrin->intrinsic != nir_intrinsic_load_deref)
+         if (intrin->intrinsic != nir_intrinsic_load_input &&
+             intrin->intrinsic != nir_intrinsic_load_interpolated_input)
             continue;
 
-         nir_deref_instr *deref = nir_src_as_deref(intrin->src[0]);
-         if (!nir_deref_mode_is(deref, nir_var_shader_in))
+         nir_io_semantics sem = nir_intrinsic_io_semantics(intrin);
+
+         if (sem.location != VARYING_SLOT_COL0 &&
+             sem.location != VARYING_SLOT_COL1)
             continue;
 
+         /* Default to FLAT (for load_input) */
+         enum glsl_interp_mode interp = INTERP_MODE_FLAT;
+         bool sample = false;
+         bool centroid = false;
+
+         if (intrin->intrinsic != nir_intrinsic_load_input) {
+            nir_intrinsic_instr *baryc =
+               nir_instr_as_intrinsic(intrin->src[0].ssa->parent_instr);
+
+            switch (baryc->intrinsic) {
+            case nir_intrinsic_load_barycentric_pixel:
+               break;
+            case nir_intrinsic_load_barycentric_centroid:
+               centroid = true;
+               break;
+            case nir_intrinsic_load_barycentric_sample:
+               sample = true;
+               break;
+            default:
+               /* All other barycentric coordinates are not possible with
+                * color inputs.
+                */
+               unreachable("invalid color barycentric");
+            }
+
+            interp = nir_intrinsic_interp_mode(baryc);
+         }
+
          b.cursor = nir_before_instr(instr);
-         nir_variable *var = nir_deref_instr_get_variable(deref);
-         nir_ssa_def *def;
-
-         if (var->data.location == VARYING_SLOT_COL0) {
-            def = nir_load_color0(&b);
-            nir->info.fs.color0_interp = var->data.interpolation;
-            nir->info.fs.color0_sample = var->data.sample;
-            nir->info.fs.color0_centroid = var->data.centroid;
-         } else if (var->data.location == VARYING_SLOT_COL1) {
-            def = nir_load_color1(&b);
-            nir->info.fs.color1_interp = var->data.interpolation;
-            nir->info.fs.color1_sample = var->data.sample;
-            nir->info.fs.color1_centroid = var->data.centroid;
+         nir_ssa_def *load = NULL;
+
+         if (sem.location == VARYING_SLOT_COL0) {
+            load = nir_load_color0(&b);
+            nir->info.fs.color0_interp = interp;
+            nir->info.fs.color0_sample = sample;
+            nir->info.fs.color0_centroid = centroid;
          } else {
-            continue;
+            assert(sem.location == VARYING_SLOT_COL1);
+            load = nir_load_color1(&b);
+            nir->info.fs.color1_interp = interp;
+            nir->info.fs.color1_sample = sample;
+            nir->info.fs.color1_centroid = centroid;
          }
 
-         nir_ssa_def_rewrite_uses(&intrin->dest.ssa, def);
+         if (intrin->num_components != 4) {
+            unsigned start = nir_intrinsic_component(intrin);
+            unsigned count = intrin->num_components;
+            load = nir_channels(&b, load, BITFIELD_RANGE(start, count));
+         }
+
+         nir_ssa_def_rewrite_uses(&intrin->dest.ssa, load);
          nir_instr_remove(instr);
          progress = true;
       }
@@ -3160,10 +3195,6 @@ nir_lower_io_passes(nir_shader *nir)
       NIR_PASS_V(nir, nir_lower_global_vars_to_local);
    }
 
-   if (nir->info.stage == MESA_SHADER_FRAGMENT &&
-       nir->options->lower_fs_color_inputs)
-      NIR_PASS_V(nir, nir_lower_color_inputs);
-
    NIR_PASS_V(nir, nir_lower_io, nir_var_shader_out | nir_var_shader_in,
               type_size_vec4, nir_lower_io_lower_64bit_to_32);
 
diff --git a/src/gallium/drivers/radeonsi/si_get.c b/src/gallium/drivers/radeonsi/si_get.c
index 3ac326a4f17d..155b6e9f4861 100644
--- a/src/gallium/drivers/radeonsi/si_get.c
+++ b/src/gallium/drivers/radeonsi/si_get.c
@@ -1237,7 +1237,6 @@ void si_init_screen_get_functions(struct si_screen *sscreen)
          nir_pack_varying_interp_loc_sample |
          nir_pack_varying_interp_loc_centroid,
       .lower_io_variables = true,
-      .lower_fs_color_inputs = true,
       /* HW supports indirect indexing for: | Enabled in driver
        * -------------------------------------------------------
        * TCS inputs                         | Yes
diff --git a/src/gallium/drivers/radeonsi/si_shader_nir.c b/src/gallium/drivers/radeonsi/si_shader_nir.c
index 3906feef951b..6fff5b547a2d 100644
--- a/src/gallium/drivers/radeonsi/si_shader_nir.c
+++ b/src/gallium/drivers/radeonsi/si_shader_nir.c
@@ -360,6 +360,9 @@ char *si_finalize_nir(struct pipe_screen *screen, void *nirptr)
    nir_lower_io_passes(nir);
    NIR_PASS_V(nir, nir_remove_dead_variables, nir_var_shader_in | nir_var_shader_out, NULL);
 
+   if (nir->info.stage == MESA_SHADER_FRAGMENT)
+      NIR_PASS_V(nir, nir_lower_color_inputs);
+
    NIR_PASS_V(nir, ac_nir_lower_subdword_loads,
               (ac_nir_lower_subdword_options) {
                  .modes_1_comp = nir_var_mem_ubo,
-- 
GitLab


From 3d32e52a9de27d26b9c576be962986c2dc8cc05a Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Sun, 12 Mar 2023 03:29:18 -0400
Subject: [PATCH 12/15] nir: return a status from nir_remove_varying whether it
 removed anything

---
 src/compiler/nir/nir.c | 5 ++++-
 src/compiler/nir/nir.h | 2 +-
 2 files changed, 5 insertions(+), 2 deletions(-)

diff --git a/src/compiler/nir/nir.c b/src/compiler/nir/nir.c
index 36074afa268c..d3dfcdb02593 100644
--- a/src/compiler/nir/nir.c
+++ b/src/compiler/nir/nir.c
@@ -3494,7 +3494,8 @@ nir_slot_is_sysval_output_and_varying(gl_varying_slot slot)
  * This marks the output store instruction as not feeding the next shader
  * stage. If the instruction has no other use, it's removed.
  */
-void nir_remove_varying(nir_intrinsic_instr *intr)
+bool
+nir_remove_varying(nir_intrinsic_instr *intr)
 {
    nir_io_semantics sem = nir_intrinsic_io_semantics(intr);
 
@@ -3503,8 +3504,10 @@ void nir_remove_varying(nir_intrinsic_instr *intr)
       /* Demote the store instruction. */
       sem.no_varying = true;
       nir_intrinsic_set_io_semantics(intr, sem);
+      return false;
    } else {
       nir_instr_remove(&intr->instr);
+      return true;
    }
 }
 
diff --git a/src/compiler/nir/nir.h b/src/compiler/nir/nir.h
index 9edfa39830b0..9be6ed84fc13 100644
--- a/src/compiler/nir/nir.h
+++ b/src/compiler/nir/nir.h
@@ -4754,7 +4754,7 @@ void nir_link_varying_precision(nir_shader *producer, nir_shader *consumer);
 bool nir_slot_is_sysval_output(gl_varying_slot slot);
 bool nir_slot_is_varying(gl_varying_slot slot);
 bool nir_slot_is_sysval_output_and_varying(gl_varying_slot slot);
-void nir_remove_varying(nir_intrinsic_instr *intr);
+bool nir_remove_varying(nir_intrinsic_instr *intr);
 void nir_remove_sysval_output(nir_intrinsic_instr *intr);
 
 bool nir_lower_amul(nir_shader *shader,
-- 
GitLab


From 7ad50fe8dce1baa83fb50d054c4fd10400e7d75c Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Sun, 12 Mar 2023 03:31:16 -0400
Subject: [PATCH 13/15] nir: remove an obsolete comment from
 nir_gather_xfb_info_from_intrinsics

---
 src/compiler/nir/nir_gather_xfb_info.c | 3 ---
 1 file changed, 3 deletions(-)

diff --git a/src/compiler/nir/nir_gather_xfb_info.c b/src/compiler/nir/nir_gather_xfb_info.c
index 306cab85050c..dad009ed3f5e 100644
--- a/src/compiler/nir/nir_gather_xfb_info.c
+++ b/src/compiler/nir/nir_gather_xfb_info.c
@@ -313,9 +313,6 @@ compare_xfb_out(const void *pa, const void *pb)
 
 /**
  * Gather transform feedback info from lowered IO intrinsics.
- *
- * Optionally return slot_to_register, an optional table to translate
- * gl_varying_slot to "base" indices.
  */
 void
 nir_gather_xfb_info_from_intrinsics(nir_shader *nir)
-- 
GitLab


From dbc43ad8e2eabc305e6c3d95a03bfc53cd732d45 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Sun, 12 Mar 2023 03:16:18 -0400
Subject: [PATCH 14/15] nir: add next_stage parameter to
 nir_slot_is_sysval_output to return better info

If we know the next stage, we can tell whether an output is a sysval,
such as POS.

For example, POS is not a sysval output if the next stage is not FS.
---
 src/compiler/nir/nir.c                   | 69 +++++++++++++++---------
 src/compiler/nir/nir.h                   |  6 ++-
 src/compiler/nir/nir_validate.c          |  2 +-
 src/gallium/drivers/zink/zink_compiler.c |  2 +-
 4 files changed, 50 insertions(+), 29 deletions(-)

diff --git a/src/compiler/nir/nir.c b/src/compiler/nir/nir.c
index d3dfcdb02593..3625fda30a93 100644
--- a/src/compiler/nir/nir.c
+++ b/src/compiler/nir/nir.c
@@ -3433,28 +3433,45 @@ nir_instr_xfb_write_mask(nir_intrinsic_instr *instr)
  * Whether an output slot is consumed by fixed-function logic.
  */
 bool
-nir_slot_is_sysval_output(gl_varying_slot slot)
-{
-   return slot == VARYING_SLOT_POS ||
-          slot == VARYING_SLOT_PSIZ ||
-          slot == VARYING_SLOT_EDGE ||
-          slot == VARYING_SLOT_CLIP_VERTEX ||
-          slot == VARYING_SLOT_CLIP_DIST0 ||
-          slot == VARYING_SLOT_CLIP_DIST1 ||
-          slot == VARYING_SLOT_CULL_DIST0 ||
-          slot == VARYING_SLOT_CULL_DIST1 ||
-          slot == VARYING_SLOT_LAYER ||
-          slot == VARYING_SLOT_VIEWPORT ||
-          slot == VARYING_SLOT_TESS_LEVEL_OUTER ||
-          slot == VARYING_SLOT_TESS_LEVEL_INNER ||
-          slot == VARYING_SLOT_BOUNDING_BOX0 ||
-          slot == VARYING_SLOT_BOUNDING_BOX1 ||
-          slot == VARYING_SLOT_VIEW_INDEX ||
-          slot == VARYING_SLOT_VIEWPORT_MASK ||
-          slot == VARYING_SLOT_PRIMITIVE_SHADING_RATE ||
-          slot == VARYING_SLOT_PRIMITIVE_COUNT ||
-          slot == VARYING_SLOT_PRIMITIVE_INDICES ||
-          slot == VARYING_SLOT_TASK_COUNT;
+nir_slot_is_sysval_output(gl_varying_slot slot, gl_shader_stage next_shader)
+{
+   switch (next_shader) {
+   case MESA_SHADER_FRAGMENT:
+      return slot == VARYING_SLOT_POS ||
+             slot == VARYING_SLOT_PSIZ ||
+             slot == VARYING_SLOT_EDGE ||
+             slot == VARYING_SLOT_CLIP_VERTEX ||
+             slot == VARYING_SLOT_CLIP_DIST0 ||
+             slot == VARYING_SLOT_CLIP_DIST1 ||
+             slot == VARYING_SLOT_CULL_DIST0 ||
+             slot == VARYING_SLOT_CULL_DIST1 ||
+             slot == VARYING_SLOT_LAYER ||
+             slot == VARYING_SLOT_VIEWPORT ||
+             slot == VARYING_SLOT_VIEW_INDEX ||
+             slot == VARYING_SLOT_VIEWPORT_MASK ||
+             slot == VARYING_SLOT_PRIMITIVE_SHADING_RATE ||
+             slot == VARYING_SLOT_PRIMITIVE_COUNT ||
+             slot == VARYING_SLOT_PRIMITIVE_INDICES;
+
+   case MESA_SHADER_TESS_EVAL:
+      return slot == VARYING_SLOT_TESS_LEVEL_OUTER ||
+             slot == VARYING_SLOT_TESS_LEVEL_INNER ||
+             slot == VARYING_SLOT_BOUNDING_BOX0 ||
+             slot == VARYING_SLOT_BOUNDING_BOX1;
+
+   case MESA_SHADER_MESH:
+      return slot == VARYING_SLOT_TASK_COUNT;
+
+   case MESA_SHADER_NONE:
+      /* NONE means unknown. Check all possibilities. */
+      return nir_slot_is_sysval_output(slot, MESA_SHADER_FRAGMENT) ||
+             nir_slot_is_sysval_output(slot, MESA_SHADER_TESS_EVAL) ||
+             nir_slot_is_sysval_output(slot, MESA_SHADER_MESH);
+
+   default:
+      /* No other shaders have preceding shaders with sysval outputs. */
+      return false;
+   }
 }
 
 /**
@@ -3484,9 +3501,10 @@ nir_slot_is_varying(gl_varying_slot slot)
 }
 
 bool
-nir_slot_is_sysval_output_and_varying(gl_varying_slot slot)
+nir_slot_is_sysval_output_and_varying(gl_varying_slot slot,
+                                      gl_shader_stage next_shader)
 {
-   return nir_slot_is_sysval_output(slot) &&
+   return nir_slot_is_sysval_output(slot, next_shader) &&
           nir_slot_is_varying(slot);
 }
 
@@ -3499,7 +3517,8 @@ nir_remove_varying(nir_intrinsic_instr *intr)
 {
    nir_io_semantics sem = nir_intrinsic_io_semantics(intr);
 
-   if ((!sem.no_sysval_output && nir_slot_is_sysval_output(sem.location)) ||
+   if ((!sem.no_sysval_output &&
+        nir_slot_is_sysval_output(sem.location, MESA_SHADER_NONE)) ||
        nir_instr_xfb_write_mask(intr)) {
       /* Demote the store instruction. */
       sem.no_varying = true;
diff --git a/src/compiler/nir/nir.h b/src/compiler/nir/nir.h
index 9be6ed84fc13..f68b5dfc48c5 100644
--- a/src/compiler/nir/nir.h
+++ b/src/compiler/nir/nir.h
@@ -4751,9 +4751,11 @@ void nir_link_xfb_varyings(nir_shader *producer, nir_shader *consumer);
 bool nir_link_opt_varyings(nir_shader *producer, nir_shader *consumer);
 void nir_link_varying_precision(nir_shader *producer, nir_shader *consumer);
 
-bool nir_slot_is_sysval_output(gl_varying_slot slot);
+bool nir_slot_is_sysval_output(gl_varying_slot slot,
+                               gl_shader_stage next_shader);
 bool nir_slot_is_varying(gl_varying_slot slot);
-bool nir_slot_is_sysval_output_and_varying(gl_varying_slot slot);
+bool nir_slot_is_sysval_output_and_varying(gl_varying_slot slot,
+                                           gl_shader_stage next_shader);
 bool nir_remove_varying(nir_intrinsic_instr *intr);
 void nir_remove_sysval_output(nir_intrinsic_instr *intr);
 
diff --git a/src/compiler/nir/nir_validate.c b/src/compiler/nir/nir_validate.c
index 40d78290e544..08afe742d989 100644
--- a/src/compiler/nir/nir_validate.c
+++ b/src/compiler/nir/nir_validate.c
@@ -882,7 +882,7 @@ validate_intrinsic_instr(nir_intrinsic_instr *instr, validate_state *state)
 
       /* An output that has no effect shouldn't be present in the IR. */
       validate_assert(state,
-                      (nir_slot_is_sysval_output(sem.location) &&
+                      (nir_slot_is_sysval_output(sem.location, MESA_SHADER_NONE) &&
                        !sem.no_sysval_output) ||
                       (nir_slot_is_varying(sem.location) && !sem.no_varying) ||
                       nir_instr_xfb_write_mask(instr));
diff --git a/src/gallium/drivers/zink/zink_compiler.c b/src/gallium/drivers/zink/zink_compiler.c
index 0e9a6978e83a..d40fb60104e1 100644
--- a/src/gallium/drivers/zink/zink_compiler.c
+++ b/src/gallium/drivers/zink/zink_compiler.c
@@ -4299,7 +4299,7 @@ fixup_io_locations(nir_shader *nir)
     */
    unsigned slot = 0;
    for (unsigned i = 0; i < VARYING_SLOT_MAX; i++) {
-      if (nir_slot_is_sysval_output(i))
+      if (nir_slot_is_sysval_output(i, MESA_SHADER_NONE))
          continue;
       nir_variable *var = nir_find_variable_with_location(nir, mode, i);
       if (!var) {
-- 
GitLab


From dce6c8020c99b0d435b218ba177046d31091ac4d Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Sun, 12 Mar 2023 03:18:38 -0400
Subject: [PATCH 15/15] nir: add next_stage parameter to nir_remove_varying

so that e.g. the POS output is removed if the next stage is not FS.
---
 src/amd/common/ac_nir_opt_outputs.c      | 2 +-
 src/compiler/nir/nir.c                   | 4 ++--
 src/compiler/nir/nir.h                   | 2 +-
 src/gallium/drivers/radeonsi/si_shader.c | 2 +-
 4 files changed, 5 insertions(+), 5 deletions(-)

diff --git a/src/amd/common/ac_nir_opt_outputs.c b/src/amd/common/ac_nir_opt_outputs.c
index ea382ba989aa..eac9c9de2ae6 100644
--- a/src/amd/common/ac_nir_opt_outputs.c
+++ b/src/amd/common/ac_nir_opt_outputs.c
@@ -58,7 +58,7 @@ static void ac_remove_varying(struct ac_out_info *out)
    /* Remove the output. (all channels) */
    for (unsigned i = 0; i < ARRAY_SIZE(out->chan); i++) {
       if (out->chan[i].store_intr) {
-         nir_remove_varying(out->chan[i].store_intr);
+         nir_remove_varying(out->chan[i].store_intr, MESA_SHADER_FRAGMENT);
          out->chan[i].store_intr = NULL;
          out->chan[i].value = NULL;
       }
diff --git a/src/compiler/nir/nir.c b/src/compiler/nir/nir.c
index 3625fda30a93..d12a4d96b645 100644
--- a/src/compiler/nir/nir.c
+++ b/src/compiler/nir/nir.c
@@ -3513,12 +3513,12 @@ nir_slot_is_sysval_output_and_varying(gl_varying_slot slot,
  * stage. If the instruction has no other use, it's removed.
  */
 bool
-nir_remove_varying(nir_intrinsic_instr *intr)
+nir_remove_varying(nir_intrinsic_instr *intr, gl_shader_stage next_shader)
 {
    nir_io_semantics sem = nir_intrinsic_io_semantics(intr);
 
    if ((!sem.no_sysval_output &&
-        nir_slot_is_sysval_output(sem.location, MESA_SHADER_NONE)) ||
+        nir_slot_is_sysval_output(sem.location, next_shader)) ||
        nir_instr_xfb_write_mask(intr)) {
       /* Demote the store instruction. */
       sem.no_varying = true;
diff --git a/src/compiler/nir/nir.h b/src/compiler/nir/nir.h
index f68b5dfc48c5..497a6bd64e7e 100644
--- a/src/compiler/nir/nir.h
+++ b/src/compiler/nir/nir.h
@@ -4756,7 +4756,7 @@ bool nir_slot_is_sysval_output(gl_varying_slot slot,
 bool nir_slot_is_varying(gl_varying_slot slot);
 bool nir_slot_is_sysval_output_and_varying(gl_varying_slot slot,
                                            gl_shader_stage next_shader);
-bool nir_remove_varying(nir_intrinsic_instr *intr);
+bool nir_remove_varying(nir_intrinsic_instr *intr, gl_shader_stage next_shader);
 void nir_remove_sysval_output(nir_intrinsic_instr *intr);
 
 bool nir_lower_amul(nir_shader *shader,
diff --git a/src/gallium/drivers/radeonsi/si_shader.c b/src/gallium/drivers/radeonsi/si_shader.c
index ac97f7168109..ebac6a00b7e6 100644
--- a/src/gallium/drivers/radeonsi/si_shader.c
+++ b/src/gallium/drivers/radeonsi/si_shader.c
@@ -1460,7 +1460,7 @@ static bool si_nir_kill_outputs(nir_shader *nir, const union si_shader_key *key)
          if (nir_slot_is_varying(sem.location) &&
              key->ge.opt.kill_outputs &
              (1ull << si_shader_io_get_unique_index(sem.location, true))) {
-            nir_remove_varying(intr);
+            nir_remove_varying(intr, MESA_SHADER_FRAGMENT);
             progress = true;
          }
 
-- 
GitLab

