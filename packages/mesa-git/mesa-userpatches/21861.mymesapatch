From 58c50923ba289258eefbc27ee87b9562ec26d085 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Fri, 10 Mar 2023 23:03:58 -0500
Subject: [PATCH 01/14] nir: fix 2 bugs in nir_create_passthrough_tcs

- VAR31 was ignored.
- Only a half of the 16-bit slot was passed through, though I'm not sure
  if nir_lower_io handles vec8. The slots are only for GLES and I don't
  think a passthrough TCS is possible with GLES.

Fixes: a8e84f50bc6c8 - nir: Add helper to create passthrough TCS shader
---
 src/compiler/nir/nir_passthrough_tcs.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/src/compiler/nir/nir_passthrough_tcs.c b/src/compiler/nir/nir_passthrough_tcs.c
index d0ddca21adcc..582e7124efc9 100644
--- a/src/compiler/nir/nir_passthrough_tcs.c
+++ b/src/compiler/nir/nir_passthrough_tcs.c
@@ -77,10 +77,10 @@ nir_create_passthrough_tcs_impl(const nir_shader_compiler_options *options,
    for (unsigned i = 0; i < num_locations; i++) {
       const struct glsl_type *type;
       unsigned semantic = locations[i];
-      if (semantic < VARYING_SLOT_VAR31 && semantic != VARYING_SLOT_EDGE)
+      if (semantic <= VARYING_SLOT_VAR31 && semantic != VARYING_SLOT_EDGE)
          type = glsl_array_type(glsl_vec4_type(), 0, 0);
       else if (semantic >= VARYING_SLOT_VAR0_16BIT)
-         type = glsl_array_type(glsl_vector_type(GLSL_TYPE_FLOAT16, 4), 0, 0);
+         type = glsl_array_type(glsl_vector_type(GLSL_TYPE_FLOAT16, 8), 0, 0);
       else
          continue;
 
-- 
GitLab


From d859143aed5a5a6cec5ff47a0c09ca3ad98f1db3 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Tue, 28 Feb 2023 17:24:08 -0500
Subject: [PATCH 02/14] nir: lower load_barycentric_at_offset in
 lower_wpos_ytransform

so that we can run this pass on lowered IO.
---
 src/compiler/nir/nir_lower_wpos_ytransform.c | 21 ++++++++++++++++++++
 1 file changed, 21 insertions(+)

diff --git a/src/compiler/nir/nir_lower_wpos_ytransform.c b/src/compiler/nir/nir_lower_wpos_ytransform.c
index cd0d06f93658..0e0fdf1eb1c4 100644
--- a/src/compiler/nir/nir_lower_wpos_ytransform.c
+++ b/src/compiler/nir/nir_lower_wpos_ytransform.c
@@ -275,6 +275,25 @@ lower_interp_deref_at_offset(lower_wpos_ytransform_state *state,
                                                      flip_y)));
 }
 
+/* Multiply load_barycentric_at_offset's offset by transform.x to flip it. */
+static void
+lower_load_barycentric_at_offset(lower_wpos_ytransform_state *state,
+                                 nir_intrinsic_instr *baryc)
+{
+   nir_builder *b = &state->b;
+   nir_ssa_def *offset;
+   nir_ssa_def *flip_y;
+
+   b->cursor = nir_before_instr(&baryc->instr);
+
+   offset = nir_ssa_for_src(b, baryc->src[0], 2);
+   flip_y = nir_fmul(b, nir_channel(b, offset, 1),
+                        nir_channel(b, get_transform(state), 0));
+   nir_instr_rewrite_src(&baryc->instr, &baryc->src[0],
+                         nir_src_for_ssa(nir_vec2(b, nir_channel(b, offset, 0),
+                                                  flip_y)));
+}
+
 static void
 lower_load_sample_pos(lower_wpos_ytransform_state *state,
                       nir_intrinsic_instr *intr)
@@ -321,6 +340,8 @@ lower_wpos_ytransform_block(lower_wpos_ytransform_state *state, nir_block *block
             lower_load_sample_pos(state, intr);
          } else if (intr->intrinsic == nir_intrinsic_interp_deref_at_offset) {
             lower_interp_deref_at_offset(state, intr);
+         } else if (intr->intrinsic == nir_intrinsic_load_barycentric_at_offset) {
+            lower_load_barycentric_at_offset(state, intr);
          }
       } else if (instr->type == nir_instr_type_alu) {
          nir_alu_instr *alu = nir_instr_as_alu(instr);
-- 
GitLab


From 5ef62438ee29d01932d87c899f9e69d082609fc4 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Tue, 28 Feb 2023 14:59:09 -0500
Subject: [PATCH 03/14] nir: assign IO bases in nir_lower_io_passes

---
 src/compiler/nir/nir_lower_io.c | 18 ++++++++++++++++++
 1 file changed, 18 insertions(+)

diff --git a/src/compiler/nir/nir_lower_io.c b/src/compiler/nir/nir_lower_io.c
index a04485a7b2c9..c98159fd560b 100644
--- a/src/compiler/nir/nir_lower_io.c
+++ b/src/compiler/nir/nir_lower_io.c
@@ -3123,6 +3123,10 @@ type_size_vec4(const struct glsl_type *type, bool bindless)
    return glsl_count_attribute_slots(type, false);
 }
 
+/**
+ * This runs all compiler passes needed to lower IO, lower indirect IO access,
+ * set transform feedback info in IO intrinsics, and clean up the IR.
+ */
 void
 nir_lower_io_passes(nir_shader *nir)
 {
@@ -3157,6 +3161,20 @@ nir_lower_io_passes(nir_shader *nir)
    NIR_PASS_V(nir, nir_lower_io, nir_var_shader_out | nir_var_shader_in,
               type_size_vec4, nir_lower_io_lower_64bit_to_32);
 
+   /* If IO is lowered before var->data.driver_location is assigned, driver
+    * locations are all 0, which means IO bases are all 0. It's not necessary
+    * to set driver_location before lowering IO because the only thing that
+    * identifies outputs is their semantic, and IO bases can always be
+    * computed from the semantics.
+    *
+    * This assigns IO bases from scratch, using IO semantics to tell which
+    * intrinsics refer to the same IO. If the bases already exist, they
+    * will be reassigned, sorted by the semantic, and all holes removed.
+    * This kind of canonicalizes all bases.
+    */
+   NIR_PASS_V(nir, nir_recompute_io_bases,
+              nir_var_shader_in | nir_var_shader_out);
+
    /* nir_io_add_const_offset_to_base needs actual constants. */
    NIR_PASS_V(nir, nir_opt_constant_folding);
    NIR_PASS_V(nir, nir_io_add_const_offset_to_base, nir_var_shader_in |
-- 
GitLab


From 65b54b6e776c7ea19a76458091164e0baafb3aa6 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Tue, 28 Feb 2023 15:12:21 -0500
Subject: [PATCH 04/14] nir: skip nir_lower_io_passes for compute shaders

---
 src/compiler/nir/nir_lower_io.c | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/src/compiler/nir/nir_lower_io.c b/src/compiler/nir/nir_lower_io.c
index c98159fd560b..6cc286bff462 100644
--- a/src/compiler/nir/nir_lower_io.c
+++ b/src/compiler/nir/nir_lower_io.c
@@ -3130,7 +3130,8 @@ type_size_vec4(const struct glsl_type *type, bool bindless)
 void
 nir_lower_io_passes(nir_shader *nir)
 {
-   if (!nir->options->lower_io_variables)
+   if (!nir->options->lower_io_variables ||
+       nir->info.stage == MESA_SHADER_COMPUTE)
       return;
 
    bool has_indirect_inputs =
-- 
GitLab


From 70f599b0f5a4e011e24e3405c0c40d1f810a9b06 Mon Sep 17 00:00:00 2001
From: Mihai Preda <mhpreda@gmail.com>
Date: Wed, 29 Jun 2022 15:18:41 +0300
Subject: [PATCH 05/14] nir: update nir->num_inputs, num_outputs in
 nir_recompute_io_bases()

Since nir_recompute_io_bases is going to be used instead of
nir_assign_io_var_locations, we need to update num_inputs, num_outputs.
---
 src/compiler/nir/nir_lower_mediump.c | 5 +++++
 1 file changed, 5 insertions(+)

diff --git a/src/compiler/nir/nir_lower_mediump.c b/src/compiler/nir/nir_lower_mediump.c
index 3da34eaa0d1d..8698b0d9f928 100644
--- a/src/compiler/nir/nir_lower_mediump.c
+++ b/src/compiler/nir/nir_lower_mediump.c
@@ -130,6 +130,11 @@ nir_recompute_io_bases(nir_shader *nir, nir_variable_mode modes)
       nir_metadata_preserve(impl, nir_metadata_all);
    }
 
+   if (modes & nir_var_shader_in)
+      nir->num_inputs = BITSET_COUNT(inputs);
+   if (modes & nir_var_shader_out)
+      nir->num_outputs = BITSET_COUNT(outputs);
+
    return changed;
 }
 
-- 
GitLab


From bd9b14b5a489d143a5b616c6c9d7b2580e97247a Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Tue, 28 Feb 2023 23:41:59 -0500
Subject: [PATCH 06/14] nir: extend nir_opt_fragdepth to handle lowered IO

Move the existing code into a switch case and add a new one.
---
 src/compiler/nir/nir_opt_fragdepth.c | 65 ++++++++++++++++++++--------
 1 file changed, 47 insertions(+), 18 deletions(-)

diff --git a/src/compiler/nir/nir_opt_fragdepth.c b/src/compiler/nir/nir_opt_fragdepth.c
index 96da27cf94e6..28fe012aad82 100644
--- a/src/compiler/nir/nir_opt_fragdepth.c
+++ b/src/compiler/nir/nir_opt_fragdepth.c
@@ -63,30 +63,59 @@ nir_opt_fragdepth(nir_shader *shader)
             continue;
 
          nir_intrinsic_instr *intrin = nir_instr_as_intrinsic(instr);
-         if (intrin->intrinsic != nir_intrinsic_store_deref)
-            continue;
 
-         nir_deref_instr *deref = nir_src_as_deref(intrin->src[0]);
-         if (!nir_deref_mode_is(deref, nir_var_shader_out))
-            continue;
+         switch (intrin->intrinsic) {
+         case nir_intrinsic_store_deref: {
+            nir_deref_instr *deref = nir_src_as_deref(intrin->src[0]);
+            if (!nir_deref_mode_is(deref, nir_var_shader_out))
+               continue;
 
-         nir_variable *var = nir_deref_instr_get_variable(deref);
-         if (var->data.location != FRAG_RESULT_DEPTH)
-            continue;
+            nir_variable *var = nir_deref_instr_get_variable(deref);
+            if (var->data.location != FRAG_RESULT_DEPTH)
+               continue;
 
-         /* We found a write to gl_FragDepth */
-         if (store_intrin) {
-            /* This isn't the only write: give up on this optimization */
-            goto end;
-         } else {
-            if (ssa_def_is_source_depth(intrin->src[1].ssa)) {
-               /* We're writing gl_FragCoord.z in gl_FragDepth: remember
-                * intrin so we can try to remove it later. */
-               store_intrin = intrin;
+            /* We found a write to gl_FragDepth */
+            if (store_intrin) {
+               /* This isn't the only write: give up on this optimization */
+               goto end;
             } else {
-               /* We're writing something else: give up. */
+               if (ssa_def_is_source_depth(intrin->src[1].ssa)) {
+                  /* We're writing gl_FragCoord.z in gl_FragDepth: remember
+                   * intrin so we can try to remove it later. */
+                  store_intrin = intrin;
+               } else {
+                  /* We're writing something else: give up. */
+                  goto end;
+               }
+            }
+            break;
+         }
+
+         case nir_intrinsic_store_output: {
+            nir_io_semantics sem = nir_intrinsic_io_semantics(intrin);
+
+            if (sem.location != FRAG_RESULT_DEPTH)
+               continue;
+
+            /* We found a write to gl_FragDepth */
+            if (store_intrin) {
+               /* This isn't the only write: give up on this optimization */
                goto end;
+            } else {
+               if (ssa_def_is_source_depth(intrin->src[0].ssa)) {
+                  /* We're writing gl_FragCoord.z in gl_FragDepth: remember
+                   * intrin so we can try to remove it later. */
+                  store_intrin = intrin;
+               } else {
+                  /* We're writing something else: give up. */
+                  goto end;
+               }
             }
+            break;
+         }
+
+         default:
+            break;
          }
       }
    }
-- 
GitLab


From b0327c3909315497fe2b50fcaf60e0143c56d8c6 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Sun, 5 Mar 2023 00:21:16 -0500
Subject: [PATCH 07/14] nir: handle more opcodes in nir_lower_io_to_scalar

It just works.
---
 src/compiler/nir/nir_lower_io_to_scalar.c | 6 ++++--
 1 file changed, 4 insertions(+), 2 deletions(-)

diff --git a/src/compiler/nir/nir_lower_io_to_scalar.c b/src/compiler/nir/nir_lower_io_to_scalar.c
index 6b157926541f..cc9f738a1141 100644
--- a/src/compiler/nir/nir_lower_io_to_scalar.c
+++ b/src/compiler/nir/nir_lower_io_to_scalar.c
@@ -231,13 +231,15 @@ nir_lower_io_to_scalar_instr(nir_builder *b, nir_instr *instr, void *data)
       return false;
 
    if ((intr->intrinsic == nir_intrinsic_load_input ||
-        intr->intrinsic == nir_intrinsic_load_per_vertex_input) &&
+        intr->intrinsic == nir_intrinsic_load_per_vertex_input ||
+        intr->intrinsic == nir_intrinsic_load_interpolated_input) &&
        (mask & nir_var_shader_in)) {
       lower_load_input_to_scalar(b, intr);
       return true;
    }
 
-   if (intr->intrinsic == nir_intrinsic_load_per_vertex_output &&
+   if ((intr->intrinsic == nir_intrinsic_load_output ||
+        intr->intrinsic == nir_intrinsic_load_per_vertex_output) &&
       (mask & nir_var_shader_out)) {
       lower_load_input_to_scalar(b, intr);
       return true;
-- 
GitLab


From a34f6db80a746d6a07da6fc1815388ed07add5b8 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Sat, 11 Mar 2023 00:26:38 -0500
Subject: [PATCH 08/14] nir: handle all varying slots in
 gl_varying_slot_name_for_stage

---
 src/compiler/shader_enums.c | 50 ++++++++++++++++++++++++++++++++++++-
 1 file changed, 49 insertions(+), 1 deletion(-)

diff --git a/src/compiler/shader_enums.c b/src/compiler/shader_enums.c
index 1778d7cf56c4..e04854273f9c 100644
--- a/src/compiler/shader_enums.c
+++ b/src/compiler/shader_enums.c
@@ -250,8 +250,56 @@ gl_varying_slot_name_for_stage(gl_varying_slot slot, gl_shader_stage stage)
       ENUM(VARYING_SLOT_VAR29),
       ENUM(VARYING_SLOT_VAR30),
       ENUM(VARYING_SLOT_VAR31),
+      ENUM(VARYING_SLOT_PATCH0),
+      ENUM(VARYING_SLOT_PATCH1),
+      ENUM(VARYING_SLOT_PATCH2),
+      ENUM(VARYING_SLOT_PATCH3),
+      ENUM(VARYING_SLOT_PATCH4),
+      ENUM(VARYING_SLOT_PATCH5),
+      ENUM(VARYING_SLOT_PATCH6),
+      ENUM(VARYING_SLOT_PATCH7),
+      ENUM(VARYING_SLOT_PATCH8),
+      ENUM(VARYING_SLOT_PATCH9),
+      ENUM(VARYING_SLOT_PATCH10),
+      ENUM(VARYING_SLOT_PATCH11),
+      ENUM(VARYING_SLOT_PATCH12),
+      ENUM(VARYING_SLOT_PATCH13),
+      ENUM(VARYING_SLOT_PATCH14),
+      ENUM(VARYING_SLOT_PATCH15),
+      ENUM(VARYING_SLOT_PATCH16),
+      ENUM(VARYING_SLOT_PATCH17),
+      ENUM(VARYING_SLOT_PATCH18),
+      ENUM(VARYING_SLOT_PATCH19),
+      ENUM(VARYING_SLOT_PATCH20),
+      ENUM(VARYING_SLOT_PATCH21),
+      ENUM(VARYING_SLOT_PATCH22),
+      ENUM(VARYING_SLOT_PATCH23),
+      ENUM(VARYING_SLOT_PATCH24),
+      ENUM(VARYING_SLOT_PATCH25),
+      ENUM(VARYING_SLOT_PATCH26),
+      ENUM(VARYING_SLOT_PATCH27),
+      ENUM(VARYING_SLOT_PATCH28),
+      ENUM(VARYING_SLOT_PATCH29),
+      ENUM(VARYING_SLOT_PATCH30),
+      ENUM(VARYING_SLOT_PATCH31),
+      ENUM(VARYING_SLOT_VAR0_16BIT),
+      ENUM(VARYING_SLOT_VAR1_16BIT),
+      ENUM(VARYING_SLOT_VAR2_16BIT),
+      ENUM(VARYING_SLOT_VAR3_16BIT),
+      ENUM(VARYING_SLOT_VAR4_16BIT),
+      ENUM(VARYING_SLOT_VAR5_16BIT),
+      ENUM(VARYING_SLOT_VAR6_16BIT),
+      ENUM(VARYING_SLOT_VAR7_16BIT),
+      ENUM(VARYING_SLOT_VAR8_16BIT),
+      ENUM(VARYING_SLOT_VAR9_16BIT),
+      ENUM(VARYING_SLOT_VAR10_16BIT),
+      ENUM(VARYING_SLOT_VAR11_16BIT),
+      ENUM(VARYING_SLOT_VAR12_16BIT),
+      ENUM(VARYING_SLOT_VAR13_16BIT),
+      ENUM(VARYING_SLOT_VAR14_16BIT),
+      ENUM(VARYING_SLOT_VAR15_16BIT),
    };
-   STATIC_ASSERT(ARRAY_SIZE(names) == VARYING_SLOT_MAX);
+   STATIC_ASSERT(ARRAY_SIZE(names) == NUM_TOTAL_VARYING_SLOTS);
    return NAME(slot);
 }
 
-- 
GitLab


From 0694d572d16fe103f976fcfed8a50aba9713cb8f Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Tue, 28 Feb 2023 23:12:58 -0500
Subject: [PATCH 09/14] nir: don't remove dead IO variables in
 nir_lower_io_passes for st_link_nir

We need to keep variables in the IR because a few places use them,
like nir_build_program_resource_list. This will allow us to lower IO
in the linker.
---
 src/compiler/nir/nir_lower_io.c              | 3 +--
 src/gallium/drivers/radeonsi/si_shader_nir.c | 1 +
 src/mesa/state_tracker/st_glsl_to_nir.cpp    | 5 ++++-
 3 files changed, 6 insertions(+), 3 deletions(-)

diff --git a/src/compiler/nir/nir_lower_io.c b/src/compiler/nir/nir_lower_io.c
index 6cc286bff462..a607fb01e879 100644
--- a/src/compiler/nir/nir_lower_io.c
+++ b/src/compiler/nir/nir_lower_io.c
@@ -3184,8 +3184,7 @@ nir_lower_io_passes(nir_shader *nir)
    /* Lower and remove dead derefs and variables to clean up the IR. */
    NIR_PASS_V(nir, nir_lower_vars_to_ssa);
    NIR_PASS_V(nir, nir_opt_dce);
-   NIR_PASS_V(nir, nir_remove_dead_variables, nir_var_function_temp |
-              nir_var_shader_in | nir_var_shader_out, NULL);
+   NIR_PASS_V(nir, nir_remove_dead_variables, nir_var_function_temp, NULL);
 
    if (nir->xfb_info)
       NIR_PASS_V(nir, nir_io_add_intrinsic_xfb_info);
diff --git a/src/gallium/drivers/radeonsi/si_shader_nir.c b/src/gallium/drivers/radeonsi/si_shader_nir.c
index db2ac4c31dce..3906feef951b 100644
--- a/src/gallium/drivers/radeonsi/si_shader_nir.c
+++ b/src/gallium/drivers/radeonsi/si_shader_nir.c
@@ -358,6 +358,7 @@ char *si_finalize_nir(struct pipe_screen *screen, void *nirptr)
    struct nir_shader *nir = (struct nir_shader *)nirptr;
 
    nir_lower_io_passes(nir);
+   NIR_PASS_V(nir, nir_remove_dead_variables, nir_var_shader_in | nir_var_shader_out, NULL);
 
    NIR_PASS_V(nir, ac_nir_lower_subdword_loads,
               (ac_nir_lower_subdword_options) {
diff --git a/src/mesa/state_tracker/st_glsl_to_nir.cpp b/src/mesa/state_tracker/st_glsl_to_nir.cpp
index 8fa0ae735f20..9109007ff92f 100644
--- a/src/mesa/state_tracker/st_glsl_to_nir.cpp
+++ b/src/mesa/state_tracker/st_glsl_to_nir.cpp
@@ -1068,8 +1068,11 @@ st_finalize_nir(struct st_context *st, struct gl_program *prog,
    /* Lower load_deref/store_deref of inputs and outputs.
     * This depends on st_nir_assign_varying_locations.
     */
-   if (nir->options->lower_io_variables)
+   if (nir->options->lower_io_variables) {
       nir_lower_io_passes(nir);
+      NIR_PASS_V(nir, nir_remove_dead_variables,
+                 nir_var_shader_in | nir_var_shader_out, NULL);
+   }
 
    /* Set num_uniforms in number of attribute slots (vec4s) */
    nir->num_uniforms = DIV_ROUND_UP(prog->Parameters->NumParameterValues, 4);
-- 
GitLab


From 4679cfb8fd9e3dd32881a827e3d0279138b3fb6b Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Thu, 9 Mar 2023 21:30:41 -0500
Subject: [PATCH 10/14] nir: rework nir_lower_color_inputs to work with lowered
 IO intrinsics

also only call it from radeonsi and remove the option
---
 src/compiler/nir/nir.h                       | 13 +---
 src/compiler/nir/nir_lower_io.c              | 77 ++++++++++++++------
 src/gallium/drivers/radeonsi/si_get.c        |  1 -
 src/gallium/drivers/radeonsi/si_shader_nir.c |  3 +
 4 files changed, 59 insertions(+), 35 deletions(-)

diff --git a/src/compiler/nir/nir.h b/src/compiler/nir/nir.h
index d0c01756e574..b5a1409b82b2 100644
--- a/src/compiler/nir/nir.h
+++ b/src/compiler/nir/nir.h
@@ -3795,13 +3795,6 @@ typedef struct nir_shader_compiler_options {
     */
    bool lower_io_variables;
 
-   /**
-    * Lower color inputs to load_colorN that are kind of like system values
-    * if lower_io_variables is also set. shader_info will contain
-    * the interpolation settings. This is used by nir_lower_io_passes.
-    */
-   bool lower_fs_color_inputs;
-
    /**
     * The masks of shader stages that support indirect indexing with
     * load_input and store_output intrinsics. It's used when
@@ -4796,10 +4789,8 @@ bool nir_lower_io(nir_shader *shader,
                   nir_lower_io_options);
 
 bool nir_io_add_const_offset_to_base(nir_shader *nir, nir_variable_mode modes);
-
-void
-nir_lower_io_passes(nir_shader *nir);
-
+bool nir_lower_color_inputs(nir_shader *nir);
+void nir_lower_io_passes(nir_shader *nir);
 bool nir_io_add_intrinsic_xfb_info(nir_shader *nir);
 
 bool
diff --git a/src/compiler/nir/nir_lower_io.c b/src/compiler/nir/nir_lower_io.c
index a607fb01e879..dd13711f6128 100644
--- a/src/compiler/nir/nir_lower_io.c
+++ b/src/compiler/nir/nir_lower_io.c
@@ -2985,7 +2985,7 @@ nir_io_add_const_offset_to_base(nir_shader *nir, nir_variable_mode modes)
    return progress;
 }
 
-static bool
+bool
 nir_lower_color_inputs(nir_shader *nir)
 {
    nir_function_impl *impl = nir_shader_get_entrypoint(nir);
@@ -3001,32 +3001,67 @@ nir_lower_color_inputs(nir_shader *nir)
 
          nir_intrinsic_instr *intrin = nir_instr_as_intrinsic(instr);
 
-         if (intrin->intrinsic != nir_intrinsic_load_deref)
+         if (intrin->intrinsic != nir_intrinsic_load_input &&
+             intrin->intrinsic != nir_intrinsic_load_interpolated_input)
             continue;
 
-         nir_deref_instr *deref = nir_src_as_deref(intrin->src[0]);
-         if (!nir_deref_mode_is(deref, nir_var_shader_in))
+         nir_io_semantics sem = nir_intrinsic_io_semantics(intrin);
+
+         if (sem.location != VARYING_SLOT_COL0 &&
+             sem.location != VARYING_SLOT_COL1)
             continue;
 
+         /* Default to FLAT (for load_input) */
+         enum glsl_interp_mode interp = INTERP_MODE_FLAT;
+         bool sample = false;
+         bool centroid = false;
+
+         if (intrin->intrinsic != nir_intrinsic_load_input) {
+            nir_intrinsic_instr *baryc =
+               nir_instr_as_intrinsic(intrin->src[0].ssa->parent_instr);
+
+            switch (baryc->intrinsic) {
+            case nir_intrinsic_load_barycentric_pixel:
+               break;
+            case nir_intrinsic_load_barycentric_centroid:
+               centroid = true;
+               break;
+            case nir_intrinsic_load_barycentric_sample:
+               sample = true;
+               break;
+            default:
+               /* All other barycentric coordinates are not possible with
+                * color inputs.
+                */
+               unreachable("invalid color barycentric");
+            }
+
+            interp = nir_intrinsic_interp_mode(baryc);
+         }
+
          b.cursor = nir_before_instr(instr);
-         nir_variable *var = nir_deref_instr_get_variable(deref);
-         nir_ssa_def *def;
-
-         if (var->data.location == VARYING_SLOT_COL0) {
-            def = nir_load_color0(&b);
-            nir->info.fs.color0_interp = var->data.interpolation;
-            nir->info.fs.color0_sample = var->data.sample;
-            nir->info.fs.color0_centroid = var->data.centroid;
-         } else if (var->data.location == VARYING_SLOT_COL1) {
-            def = nir_load_color1(&b);
-            nir->info.fs.color1_interp = var->data.interpolation;
-            nir->info.fs.color1_sample = var->data.sample;
-            nir->info.fs.color1_centroid = var->data.centroid;
+         nir_ssa_def *load = NULL;
+
+         if (sem.location == VARYING_SLOT_COL0) {
+            load = nir_load_color0(&b);
+            nir->info.fs.color0_interp = interp;
+            nir->info.fs.color0_sample = sample;
+            nir->info.fs.color0_centroid = centroid;
          } else {
-            continue;
+            assert(sem.location == VARYING_SLOT_COL1);
+            load = nir_load_color1(&b);
+            nir->info.fs.color1_interp = interp;
+            nir->info.fs.color1_sample = sample;
+            nir->info.fs.color1_centroid = centroid;
          }
 
-         nir_ssa_def_rewrite_uses(&intrin->dest.ssa, def);
+         if (intrin->num_components != 4) {
+            unsigned start = nir_intrinsic_component(intrin);
+            unsigned count = intrin->num_components;
+            load = nir_channels(&b, load, BITFIELD_RANGE(start, count));
+         }
+
+         nir_ssa_def_rewrite_uses(&intrin->dest.ssa, load);
          nir_instr_remove(instr);
          progress = true;
       }
@@ -3155,10 +3190,6 @@ nir_lower_io_passes(nir_shader *nir)
       NIR_PASS_V(nir, nir_lower_global_vars_to_local);
    }
 
-   if (nir->info.stage == MESA_SHADER_FRAGMENT &&
-       nir->options->lower_fs_color_inputs)
-      NIR_PASS_V(nir, nir_lower_color_inputs);
-
    NIR_PASS_V(nir, nir_lower_io, nir_var_shader_out | nir_var_shader_in,
               type_size_vec4, nir_lower_io_lower_64bit_to_32);
 
diff --git a/src/gallium/drivers/radeonsi/si_get.c b/src/gallium/drivers/radeonsi/si_get.c
index 3ac326a4f17d..155b6e9f4861 100644
--- a/src/gallium/drivers/radeonsi/si_get.c
+++ b/src/gallium/drivers/radeonsi/si_get.c
@@ -1237,7 +1237,6 @@ void si_init_screen_get_functions(struct si_screen *sscreen)
          nir_pack_varying_interp_loc_sample |
          nir_pack_varying_interp_loc_centroid,
       .lower_io_variables = true,
-      .lower_fs_color_inputs = true,
       /* HW supports indirect indexing for: | Enabled in driver
        * -------------------------------------------------------
        * TCS inputs                         | Yes
diff --git a/src/gallium/drivers/radeonsi/si_shader_nir.c b/src/gallium/drivers/radeonsi/si_shader_nir.c
index 3906feef951b..6fff5b547a2d 100644
--- a/src/gallium/drivers/radeonsi/si_shader_nir.c
+++ b/src/gallium/drivers/radeonsi/si_shader_nir.c
@@ -360,6 +360,9 @@ char *si_finalize_nir(struct pipe_screen *screen, void *nirptr)
    nir_lower_io_passes(nir);
    NIR_PASS_V(nir, nir_remove_dead_variables, nir_var_shader_in | nir_var_shader_out, NULL);
 
+   if (nir->info.stage == MESA_SHADER_FRAGMENT)
+      NIR_PASS_V(nir, nir_lower_color_inputs);
+
    NIR_PASS_V(nir, ac_nir_lower_subdword_loads,
               (ac_nir_lower_subdword_options) {
                  .modes_1_comp = nir_var_mem_ubo,
-- 
GitLab


From fac8a31db64dd5aedb81fd7d689a87adf3a3faff Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Sun, 12 Mar 2023 03:29:18 -0400
Subject: [PATCH 11/14] nir: return a status from nir_remove_varying whether it
 removed anything

---
 src/compiler/nir/nir.c | 5 ++++-
 src/compiler/nir/nir.h | 2 +-
 2 files changed, 5 insertions(+), 2 deletions(-)

diff --git a/src/compiler/nir/nir.c b/src/compiler/nir/nir.c
index b19c54871941..f4e357528670 100644
--- a/src/compiler/nir/nir.c
+++ b/src/compiler/nir/nir.c
@@ -3498,7 +3498,8 @@ nir_slot_is_sysval_output_and_varying(gl_varying_slot slot)
  * This marks the output store instruction as not feeding the next shader
  * stage. If the instruction has no other use, it's removed.
  */
-void nir_remove_varying(nir_intrinsic_instr *intr)
+bool
+nir_remove_varying(nir_intrinsic_instr *intr)
 {
    nir_io_semantics sem = nir_intrinsic_io_semantics(intr);
 
@@ -3507,8 +3508,10 @@ void nir_remove_varying(nir_intrinsic_instr *intr)
       /* Demote the store instruction. */
       sem.no_varying = true;
       nir_intrinsic_set_io_semantics(intr, sem);
+      return false;
    } else {
       nir_instr_remove(&intr->instr);
+      return true;
    }
 }
 
diff --git a/src/compiler/nir/nir.h b/src/compiler/nir/nir.h
index b5a1409b82b2..cc987802754c 100644
--- a/src/compiler/nir/nir.h
+++ b/src/compiler/nir/nir.h
@@ -4754,7 +4754,7 @@ void nir_link_varying_precision(nir_shader *producer, nir_shader *consumer);
 bool nir_slot_is_sysval_output(gl_varying_slot slot);
 bool nir_slot_is_varying(gl_varying_slot slot);
 bool nir_slot_is_sysval_output_and_varying(gl_varying_slot slot);
-void nir_remove_varying(nir_intrinsic_instr *intr);
+bool nir_remove_varying(nir_intrinsic_instr *intr);
 void nir_remove_sysval_output(nir_intrinsic_instr *intr);
 
 bool nir_lower_amul(nir_shader *shader,
-- 
GitLab


From e384e4fa47a4f015f9be2d7fd6ccae9b75bb68b0 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Sun, 12 Mar 2023 03:31:16 -0400
Subject: [PATCH 12/14] nir: remove an obsolete comment from
 nir_gather_xfb_info_from_intrinsics

---
 src/compiler/nir/nir_gather_xfb_info.c | 3 ---
 1 file changed, 3 deletions(-)

diff --git a/src/compiler/nir/nir_gather_xfb_info.c b/src/compiler/nir/nir_gather_xfb_info.c
index 306cab85050c..dad009ed3f5e 100644
--- a/src/compiler/nir/nir_gather_xfb_info.c
+++ b/src/compiler/nir/nir_gather_xfb_info.c
@@ -313,9 +313,6 @@ compare_xfb_out(const void *pa, const void *pb)
 
 /**
  * Gather transform feedback info from lowered IO intrinsics.
- *
- * Optionally return slot_to_register, an optional table to translate
- * gl_varying_slot to "base" indices.
  */
 void
 nir_gather_xfb_info_from_intrinsics(nir_shader *nir)
-- 
GitLab


From c25f46e808b2211cf42151c8e60ec9496be62a37 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Sun, 12 Mar 2023 03:16:18 -0400
Subject: [PATCH 13/14] nir: add next_stage parameter to
 nir_slot_is_sysval_output to return better info

If we know the next stage, we can tell whether an output is a sysval,
such as POS.

For example, POS is not a sysval output if the next stage is not FS.
---
 src/compiler/nir/nir.c                   | 69 +++++++++++++++---------
 src/compiler/nir/nir.h                   |  6 ++-
 src/compiler/nir/nir_validate.c          |  2 +-
 src/gallium/drivers/zink/zink_compiler.c |  2 +-
 4 files changed, 50 insertions(+), 29 deletions(-)

diff --git a/src/compiler/nir/nir.c b/src/compiler/nir/nir.c
index f4e357528670..367da083d532 100644
--- a/src/compiler/nir/nir.c
+++ b/src/compiler/nir/nir.c
@@ -3437,28 +3437,45 @@ nir_instr_xfb_write_mask(nir_intrinsic_instr *instr)
  * Whether an output slot is consumed by fixed-function logic.
  */
 bool
-nir_slot_is_sysval_output(gl_varying_slot slot)
-{
-   return slot == VARYING_SLOT_POS ||
-          slot == VARYING_SLOT_PSIZ ||
-          slot == VARYING_SLOT_EDGE ||
-          slot == VARYING_SLOT_CLIP_VERTEX ||
-          slot == VARYING_SLOT_CLIP_DIST0 ||
-          slot == VARYING_SLOT_CLIP_DIST1 ||
-          slot == VARYING_SLOT_CULL_DIST0 ||
-          slot == VARYING_SLOT_CULL_DIST1 ||
-          slot == VARYING_SLOT_LAYER ||
-          slot == VARYING_SLOT_VIEWPORT ||
-          slot == VARYING_SLOT_TESS_LEVEL_OUTER ||
-          slot == VARYING_SLOT_TESS_LEVEL_INNER ||
-          slot == VARYING_SLOT_BOUNDING_BOX0 ||
-          slot == VARYING_SLOT_BOUNDING_BOX1 ||
-          slot == VARYING_SLOT_VIEW_INDEX ||
-          slot == VARYING_SLOT_VIEWPORT_MASK ||
-          slot == VARYING_SLOT_PRIMITIVE_SHADING_RATE ||
-          slot == VARYING_SLOT_PRIMITIVE_COUNT ||
-          slot == VARYING_SLOT_PRIMITIVE_INDICES ||
-          slot == VARYING_SLOT_TASK_COUNT;
+nir_slot_is_sysval_output(gl_varying_slot slot, gl_shader_stage next_shader)
+{
+   switch (next_shader) {
+   case MESA_SHADER_FRAGMENT:
+      return slot == VARYING_SLOT_POS ||
+             slot == VARYING_SLOT_PSIZ ||
+             slot == VARYING_SLOT_EDGE ||
+             slot == VARYING_SLOT_CLIP_VERTEX ||
+             slot == VARYING_SLOT_CLIP_DIST0 ||
+             slot == VARYING_SLOT_CLIP_DIST1 ||
+             slot == VARYING_SLOT_CULL_DIST0 ||
+             slot == VARYING_SLOT_CULL_DIST1 ||
+             slot == VARYING_SLOT_LAYER ||
+             slot == VARYING_SLOT_VIEWPORT ||
+             slot == VARYING_SLOT_VIEW_INDEX ||
+             slot == VARYING_SLOT_VIEWPORT_MASK ||
+             slot == VARYING_SLOT_PRIMITIVE_SHADING_RATE ||
+             slot == VARYING_SLOT_PRIMITIVE_COUNT ||
+             slot == VARYING_SLOT_PRIMITIVE_INDICES;
+
+   case MESA_SHADER_TESS_EVAL:
+      return slot == VARYING_SLOT_TESS_LEVEL_OUTER ||
+             slot == VARYING_SLOT_TESS_LEVEL_INNER ||
+             slot == VARYING_SLOT_BOUNDING_BOX0 ||
+             slot == VARYING_SLOT_BOUNDING_BOX1;
+
+   case MESA_SHADER_MESH:
+      return slot == VARYING_SLOT_TASK_COUNT;
+
+   case MESA_SHADER_NONE:
+      /* NONE means unknown. Check all possibilities. */
+      return nir_slot_is_sysval_output(slot, MESA_SHADER_FRAGMENT) ||
+             nir_slot_is_sysval_output(slot, MESA_SHADER_TESS_EVAL) ||
+             nir_slot_is_sysval_output(slot, MESA_SHADER_MESH);
+
+   default:
+      /* No other shaders have preceding shaders with sysval outputs. */
+      return false;
+   }
 }
 
 /**
@@ -3488,9 +3505,10 @@ nir_slot_is_varying(gl_varying_slot slot)
 }
 
 bool
-nir_slot_is_sysval_output_and_varying(gl_varying_slot slot)
+nir_slot_is_sysval_output_and_varying(gl_varying_slot slot,
+                                      gl_shader_stage next_shader)
 {
-   return nir_slot_is_sysval_output(slot) &&
+   return nir_slot_is_sysval_output(slot, next_shader) &&
           nir_slot_is_varying(slot);
 }
 
@@ -3503,7 +3521,8 @@ nir_remove_varying(nir_intrinsic_instr *intr)
 {
    nir_io_semantics sem = nir_intrinsic_io_semantics(intr);
 
-   if ((!sem.no_sysval_output && nir_slot_is_sysval_output(sem.location)) ||
+   if ((!sem.no_sysval_output &&
+        nir_slot_is_sysval_output(sem.location, MESA_SHADER_NONE)) ||
        nir_instr_xfb_write_mask(intr)) {
       /* Demote the store instruction. */
       sem.no_varying = true;
diff --git a/src/compiler/nir/nir.h b/src/compiler/nir/nir.h
index cc987802754c..6c85cb1955f1 100644
--- a/src/compiler/nir/nir.h
+++ b/src/compiler/nir/nir.h
@@ -4751,9 +4751,11 @@ void nir_link_xfb_varyings(nir_shader *producer, nir_shader *consumer);
 bool nir_link_opt_varyings(nir_shader *producer, nir_shader *consumer);
 void nir_link_varying_precision(nir_shader *producer, nir_shader *consumer);
 
-bool nir_slot_is_sysval_output(gl_varying_slot slot);
+bool nir_slot_is_sysval_output(gl_varying_slot slot,
+                               gl_shader_stage next_shader);
 bool nir_slot_is_varying(gl_varying_slot slot);
-bool nir_slot_is_sysval_output_and_varying(gl_varying_slot slot);
+bool nir_slot_is_sysval_output_and_varying(gl_varying_slot slot,
+                                           gl_shader_stage next_shader);
 bool nir_remove_varying(nir_intrinsic_instr *intr);
 void nir_remove_sysval_output(nir_intrinsic_instr *intr);
 
diff --git a/src/compiler/nir/nir_validate.c b/src/compiler/nir/nir_validate.c
index 40d78290e544..08afe742d989 100644
--- a/src/compiler/nir/nir_validate.c
+++ b/src/compiler/nir/nir_validate.c
@@ -882,7 +882,7 @@ validate_intrinsic_instr(nir_intrinsic_instr *instr, validate_state *state)
 
       /* An output that has no effect shouldn't be present in the IR. */
       validate_assert(state,
-                      (nir_slot_is_sysval_output(sem.location) &&
+                      (nir_slot_is_sysval_output(sem.location, MESA_SHADER_NONE) &&
                        !sem.no_sysval_output) ||
                       (nir_slot_is_varying(sem.location) && !sem.no_varying) ||
                       nir_instr_xfb_write_mask(instr));
diff --git a/src/gallium/drivers/zink/zink_compiler.c b/src/gallium/drivers/zink/zink_compiler.c
index 4bc175afcfff..92a7dbb366fb 100644
--- a/src/gallium/drivers/zink/zink_compiler.c
+++ b/src/gallium/drivers/zink/zink_compiler.c
@@ -4392,7 +4392,7 @@ fixup_io_locations(nir_shader *nir)
     */
    unsigned slot = 0;
    for (unsigned i = 0; i < VARYING_SLOT_MAX; i++) {
-      if (nir_slot_is_sysval_output(i))
+      if (nir_slot_is_sysval_output(i, MESA_SHADER_NONE))
          continue;
       nir_variable *var = nir_find_variable_with_location(nir, mode, i);
       if (!var) {
-- 
GitLab


From e607fbf5634766fe3e810220d5704632829e7bca Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <marek.olsak@amd.com>
Date: Sun, 12 Mar 2023 03:18:38 -0400
Subject: [PATCH 14/14] nir: add next_stage parameter to nir_remove_varying

so that e.g. the POS output is removed if the next stage is not FS.
---
 src/amd/common/ac_nir_opt_outputs.c      | 2 +-
 src/compiler/nir/nir.c                   | 4 ++--
 src/compiler/nir/nir.h                   | 2 +-
 src/gallium/drivers/radeonsi/si_shader.c | 2 +-
 4 files changed, 5 insertions(+), 5 deletions(-)

diff --git a/src/amd/common/ac_nir_opt_outputs.c b/src/amd/common/ac_nir_opt_outputs.c
index ea382ba989aa..eac9c9de2ae6 100644
--- a/src/amd/common/ac_nir_opt_outputs.c
+++ b/src/amd/common/ac_nir_opt_outputs.c
@@ -58,7 +58,7 @@ static void ac_remove_varying(struct ac_out_info *out)
    /* Remove the output. (all channels) */
    for (unsigned i = 0; i < ARRAY_SIZE(out->chan); i++) {
       if (out->chan[i].store_intr) {
-         nir_remove_varying(out->chan[i].store_intr);
+         nir_remove_varying(out->chan[i].store_intr, MESA_SHADER_FRAGMENT);
          out->chan[i].store_intr = NULL;
          out->chan[i].value = NULL;
       }
diff --git a/src/compiler/nir/nir.c b/src/compiler/nir/nir.c
index 367da083d532..ca65da92fe80 100644
--- a/src/compiler/nir/nir.c
+++ b/src/compiler/nir/nir.c
@@ -3517,12 +3517,12 @@ nir_slot_is_sysval_output_and_varying(gl_varying_slot slot,
  * stage. If the instruction has no other use, it's removed.
  */
 bool
-nir_remove_varying(nir_intrinsic_instr *intr)
+nir_remove_varying(nir_intrinsic_instr *intr, gl_shader_stage next_shader)
 {
    nir_io_semantics sem = nir_intrinsic_io_semantics(intr);
 
    if ((!sem.no_sysval_output &&
-        nir_slot_is_sysval_output(sem.location, MESA_SHADER_NONE)) ||
+        nir_slot_is_sysval_output(sem.location, next_shader)) ||
        nir_instr_xfb_write_mask(intr)) {
       /* Demote the store instruction. */
       sem.no_varying = true;
diff --git a/src/compiler/nir/nir.h b/src/compiler/nir/nir.h
index 6c85cb1955f1..846f0ffe3689 100644
--- a/src/compiler/nir/nir.h
+++ b/src/compiler/nir/nir.h
@@ -4756,7 +4756,7 @@ bool nir_slot_is_sysval_output(gl_varying_slot slot,
 bool nir_slot_is_varying(gl_varying_slot slot);
 bool nir_slot_is_sysval_output_and_varying(gl_varying_slot slot,
                                            gl_shader_stage next_shader);
-bool nir_remove_varying(nir_intrinsic_instr *intr);
+bool nir_remove_varying(nir_intrinsic_instr *intr, gl_shader_stage next_shader);
 void nir_remove_sysval_output(nir_intrinsic_instr *intr);
 
 bool nir_lower_amul(nir_shader *shader,
diff --git a/src/gallium/drivers/radeonsi/si_shader.c b/src/gallium/drivers/radeonsi/si_shader.c
index 7b5779ea306b..d4a2f5a609a7 100644
--- a/src/gallium/drivers/radeonsi/si_shader.c
+++ b/src/gallium/drivers/radeonsi/si_shader.c
@@ -1490,7 +1490,7 @@ static bool si_nir_kill_outputs(nir_shader *nir, const union si_shader_key *key)
          if (nir_slot_is_varying(sem.location) &&
              key->ge.opt.kill_outputs &
              (1ull << si_shader_io_get_unique_index(sem.location, true))) {
-            nir_remove_varying(intr);
+            nir_remove_varying(intr, MESA_SHADER_FRAGMENT);
             progress = true;
          }
 
-- 
GitLab

