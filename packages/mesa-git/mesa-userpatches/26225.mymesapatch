From c25badf3790357664eb1c808ed7840068375dad9 Mon Sep 17 00:00:00 2001
From: Rhys Perry <pendingchaos02@gmail.com>
Date: Fri, 13 Oct 2023 19:56:24 +0100
Subject: [PATCH 1/6] nir/loop_analyze: skip if basis/limit/comparison is
 vector

Replacement in try_eval_const_alu() doesn't work because the replacements
are always scalar. The callers also always give a scalar dest.

This is encountered when compiling a Redout shader under ASan.

Signed-off-by: Rhys Perry <pendingchaos02@gmail.com>
Fixes: bc170e895f38 ("nir/loop_analyze: Use try_eval_const_alu and induction variable basis info")
---
 src/compiler/nir/nir_loop_analyze.c | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/src/compiler/nir/nir_loop_analyze.c b/src/compiler/nir/nir_loop_analyze.c
index 4c39de9d949dc..f468d2316e557 100644
--- a/src/compiler/nir/nir_loop_analyze.c
+++ b/src/compiler/nir/nir_loop_analyze.c
@@ -1050,6 +1050,10 @@ calculate_iterations(nir_def *basis, nir_def *limit_basis,
              induction_base_type);
    }
 
+   if (cond.def->num_components != 1 || basis->num_components != 1 ||
+       limit_basis->num_components != 1)
+      return -1;
+
    /* do-while loops can increment the starting value before the condition is
     * checked. e.g.
     *
-- 
GitLab


From 134b7b05d9285acff1f96e4258bbc7e61ff38c98 Mon Sep 17 00:00:00 2001
From: Rhys Perry <pendingchaos02@gmail.com>
Date: Fri, 13 Oct 2023 16:39:24 +0100
Subject: [PATCH 2/6] nir/loop_analyze: scalarize try_eval_const_alu

This is simpler, and users of this function expected scalar anyway.

Signed-off-by: Rhys Perry <pendingchaos02@gmail.com>
---
 src/compiler/nir/nir_loop_analyze.c | 97 +++++++++++++----------------
 1 file changed, 44 insertions(+), 53 deletions(-)

diff --git a/src/compiler/nir/nir_loop_analyze.c b/src/compiler/nir/nir_loop_analyze.c
index f468d2316e557..e06a8f61392ec 100644
--- a/src/compiler/nir/nir_loop_analyze.c
+++ b/src/compiler/nir/nir_loop_analyze.c
@@ -717,11 +717,11 @@ eval_const_binop(nir_op op, unsigned bit_size,
 }
 
 static int
-find_replacement(const nir_def **originals, const nir_def *key,
+find_replacement(const nir_scalar *originals, nir_scalar key,
                  unsigned num_replacements)
 {
    for (int i = 0; i < num_replacements; i++) {
-      if (originals[i] == key)
+      if (nir_scalar_equal(originals[i], key))
          return i;
    }
 
@@ -750,12 +750,14 @@ find_replacement(const nir_def **originals, const nir_def *key,
  * applying the previously described substitution) or false otherwise.
  */
 static bool
-try_eval_const_alu(nir_const_value *dest, nir_alu_instr *alu,
-                   const nir_def **originals,
-                   const nir_const_value **replacements,
+try_eval_const_alu(nir_const_value *dest, nir_scalar alu_s, const nir_scalar *originals,
+                   const nir_const_value *replacements,
                    unsigned num_replacements, unsigned execution_mode)
 {
-   nir_const_value src[NIR_MAX_VEC_COMPONENTS][NIR_MAX_VEC_COMPONENTS];
+   nir_alu_instr *alu = nir_instr_as_alu(alu_s.def->parent_instr);
+
+   if (nir_op_infos[alu->op].output_size)
+      return false;
 
    /* In the case that any outputs/inputs have unsized types, then we need to
     * guess the bit-size. In this case, the validator ensures that all
@@ -767,55 +769,42 @@ try_eval_const_alu(nir_const_value *dest, nir_alu_instr *alu,
     * (although it still requires to receive a valid bit-size).
     */
    unsigned bit_size = 0;
-   if (!nir_alu_type_get_type_size(nir_op_infos[alu->op].output_type))
+   if (!nir_alu_type_get_type_size(nir_op_infos[alu->op].output_type)) {
       bit_size = alu->def.bit_size;
+   } else {
+      for (unsigned i = 0; i < nir_op_infos[alu->op].num_inputs; i++) {
+         if (!nir_alu_type_get_type_size(nir_op_infos[alu->op].input_types[i]))
+            bit_size = alu->src[i].src.ssa->bit_size;
+      }
 
-   for (unsigned i = 0; i < nir_op_infos[alu->op].num_inputs; i++) {
-      if (bit_size == 0 &&
-          !nir_alu_type_get_type_size(nir_op_infos[alu->op].input_types[i]))
-         bit_size = alu->src[i].src.ssa->bit_size;
-
-      nir_instr *src_instr = alu->src[i].src.ssa->parent_instr;
+      if (bit_size == 0)
+         bit_size = 32;
+   }
 
-      if (src_instr->type == nir_instr_type_load_const) {
-         nir_load_const_instr *load_const = nir_instr_as_load_const(src_instr);
+   nir_const_value src[NIR_MAX_VEC_COMPONENTS];
+   nir_const_value *src_ptrs[NIR_MAX_VEC_COMPONENTS];
 
-         for (unsigned j = 0; j < nir_ssa_alu_instr_src_components(alu, i);
-              j++) {
-            src[i][j] = load_const->value[alu->src[i].swizzle[j]];
-         }
-      } else {
-         int r = find_replacement(originals, alu->src[i].src.ssa,
-                                  num_replacements);
+   for (unsigned i = 0; i < nir_op_infos[alu->op].num_inputs; i++) {
+      nir_scalar src_s = nir_scalar_chase_alu_src(alu_s, i);
 
-         if (r >= 0) {
-            for (unsigned j = 0; j < nir_ssa_alu_instr_src_components(alu, i);
-                 j++) {
-               src[i][j] = replacements[r][alu->src[i].swizzle[j]];
-            }
-         } else if (src_instr->type == nir_instr_type_alu) {
-            memset(src[i], 0, sizeof(src[i]));
+      src_ptrs[i] = &src[i];
+      if (nir_scalar_is_const(src_s)) {
+         src[i] = nir_scalar_as_const_value(src_s);
+         continue;
+      }
 
-            if (!try_eval_const_alu(src[i], nir_instr_as_alu(src_instr),
-                                    originals, replacements, num_replacements,
-                                    execution_mode))
-               return false;
-         } else {
-            return false;
-         }
+      int r = find_replacement(originals, src_s, num_replacements);
+      if (r >= 0) {
+         src[i] = replacements[r];
+      } else if (!nir_scalar_is_alu(src_s) ||
+                 !try_eval_const_alu(&src[i], src_s,
+                                     originals, replacements,
+                                     num_replacements, execution_mode)) {
+         return false;
       }
    }
 
-   if (bit_size == 0)
-      bit_size = 32;
-
-   nir_const_value *srcs[NIR_MAX_VEC_COMPONENTS];
-
-   for (unsigned i = 0; i < nir_op_infos[alu->op].num_inputs; ++i)
-      srcs[i] = src[i];
-
-   nir_eval_const_opcode(alu->op, dest, alu->def.num_components,
-                         bit_size, srcs, execution_mode);
+   nir_eval_const_opcode(alu->op, dest, 1, bit_size, src_ptrs, execution_mode);
 
    return true;
 }
@@ -931,13 +920,14 @@ get_iteration_empirical(nir_alu_instr *cond_alu, nir_alu_instr *incr_alu,
    nir_const_value result;
    nir_const_value iter = initial;
 
-   const nir_def *originals[2] = { basis, NULL };
-   const nir_const_value *replacements[2] = { &iter, NULL };
+   const nir_scalar original = nir_get_scalar(basis, 0);
+   const nir_scalar cond = nir_get_scalar(&cond_alu->def, 0);
+   const nir_scalar incr = nir_get_scalar(&incr_alu->def, 0);
 
    while (iter_count <= max_unroll_iterations) {
       bool success;
 
-      success = try_eval_const_alu(&result, cond_alu, originals, replacements,
+      success = try_eval_const_alu(&result, cond, &original, &iter,
                                    1, execution_mode);
       if (!success)
          return -1;
@@ -948,7 +938,7 @@ get_iteration_empirical(nir_alu_instr *cond_alu, nir_alu_instr *incr_alu,
 
       iter_count++;
 
-      success = try_eval_const_alu(&result, incr_alu, originals, replacements,
+      success = try_eval_const_alu(&result, incr, &original, &iter,
                                    1, execution_mode);
       assert(success);
 
@@ -966,10 +956,11 @@ will_break_on_first_iteration(nir_alu_instr *cond_alu, nir_def *basis,
 {
    nir_const_value result;
 
-   const nir_def *originals[2] = { basis, limit_basis };
-   const nir_const_value *replacements[2] = { &initial, &limit };
+   const nir_scalar originals[2] = { nir_get_scalar(basis, 0), nir_get_scalar(limit_basis, 0) };
+   const nir_const_value replacements[2] = { initial, limit };
 
-   ASSERTED bool success = try_eval_const_alu(&result, cond_alu, originals,
+   const nir_scalar cond = nir_get_scalar(&cond_alu->def, 0);
+   ASSERTED bool success = try_eval_const_alu(&result, cond, originals,
                                               replacements, 2, execution_mode);
 
    assert(success);
-- 
GitLab


From a9fe9db442b9a547aab82bdc9debdf91a3bbf518 Mon Sep 17 00:00:00 2001
From: Rhys Perry <pendingchaos02@gmail.com>
Date: Fri, 13 Oct 2023 16:48:36 +0100
Subject: [PATCH 3/6] nir/loop_analyze: fix vector basis/limit/comparison

Signed-off-by: Rhys Perry <pendingchaos02@gmail.com>
---
 src/compiler/nir/nir_loop_analyze.c | 31 +++++++++++------------------
 1 file changed, 12 insertions(+), 19 deletions(-)

diff --git a/src/compiler/nir/nir_loop_analyze.c b/src/compiler/nir/nir_loop_analyze.c
index e06a8f61392ec..4996f5f5325e4 100644
--- a/src/compiler/nir/nir_loop_analyze.c
+++ b/src/compiler/nir/nir_loop_analyze.c
@@ -911,8 +911,8 @@ get_iteration(nir_op cond_op, nir_const_value initial, nir_const_value step,
 }
 
 static int32_t
-get_iteration_empirical(nir_alu_instr *cond_alu, nir_alu_instr *incr_alu,
-                        nir_def *basis, nir_const_value initial,
+get_iteration_empirical(nir_scalar cond, nir_alu_instr *incr_alu,
+                        nir_scalar basis, nir_const_value initial,
                         bool invert_cond, unsigned execution_mode,
                         unsigned max_unroll_iterations)
 {
@@ -920,14 +920,12 @@ get_iteration_empirical(nir_alu_instr *cond_alu, nir_alu_instr *incr_alu,
    nir_const_value result;
    nir_const_value iter = initial;
 
-   const nir_scalar original = nir_get_scalar(basis, 0);
-   const nir_scalar cond = nir_get_scalar(&cond_alu->def, 0);
-   const nir_scalar incr = nir_get_scalar(&incr_alu->def, 0);
+   const nir_scalar incr = nir_get_scalar(&incr_alu->def, basis.comp);
 
    while (iter_count <= max_unroll_iterations) {
       bool success;
 
-      success = try_eval_const_alu(&result, cond, &original, &iter,
+      success = try_eval_const_alu(&result, cond, &basis, &iter,
                                    1, execution_mode);
       if (!success)
          return -1;
@@ -938,7 +936,7 @@ get_iteration_empirical(nir_alu_instr *cond_alu, nir_alu_instr *incr_alu,
 
       iter_count++;
 
-      success = try_eval_const_alu(&result, incr, &original, &iter,
+      success = try_eval_const_alu(&result, incr, &basis, &iter,
                                    1, execution_mode);
       assert(success);
 
@@ -949,17 +947,16 @@ get_iteration_empirical(nir_alu_instr *cond_alu, nir_alu_instr *incr_alu,
 }
 
 static bool
-will_break_on_first_iteration(nir_alu_instr *cond_alu, nir_def *basis,
-                              nir_def *limit_basis,
+will_break_on_first_iteration(nir_scalar cond, nir_scalar basis,
+                              nir_scalar limit_basis,
                               nir_const_value initial, nir_const_value limit,
                               bool invert_cond, unsigned execution_mode)
 {
    nir_const_value result;
 
-   const nir_scalar originals[2] = { nir_get_scalar(basis, 0), nir_get_scalar(limit_basis, 0) };
+   const nir_scalar originals[2] = { basis, limit_basis };
    const nir_const_value replacements[2] = { initial, limit };
 
-   const nir_scalar cond = nir_get_scalar(&cond_alu->def, 0);
    ASSERTED bool success = try_eval_const_alu(&result, cond, originals,
                                               replacements, 2, execution_mode);
 
@@ -1018,7 +1015,7 @@ test_iterations(int32_t iter_int, nir_const_value step,
 }
 
 static int
-calculate_iterations(nir_def *basis, nir_def *limit_basis,
+calculate_iterations(nir_scalar basis, nir_scalar limit_basis,
                      nir_const_value initial, nir_const_value step,
                      nir_const_value limit, nir_alu_instr *alu,
                      nir_scalar cond, nir_op alu_op, bool limit_rhs,
@@ -1041,10 +1038,6 @@ calculate_iterations(nir_def *basis, nir_def *limit_basis,
              induction_base_type);
    }
 
-   if (cond.def->num_components != 1 || basis->num_components != 1 ||
-       limit_basis->num_components != 1)
-      return -1;
-
    /* do-while loops can increment the starting value before the condition is
     * checked. e.g.
     *
@@ -1069,7 +1062,7 @@ calculate_iterations(nir_def *basis, nir_def *limit_basis,
     * however if the loop condition is false on the first iteration
     * get_iteration's assumption is broken. Handle such loops first.
     */
-   if (will_break_on_first_iteration(cond_alu, basis, limit_basis, initial,
+   if (will_break_on_first_iteration(cond, basis, limit_basis, initial,
                                      limit, invert_cond, execution_mode)) {
       return 0;
    }
@@ -1101,7 +1094,7 @@ calculate_iterations(nir_def *basis, nir_def *limit_basis,
    case nir_op_ishl:
    case nir_op_ishr:
    case nir_op_ushr:
-      return get_iteration_empirical(cond_alu, alu, basis, initial,
+      return get_iteration_empirical(cond, alu, basis, initial,
                                      invert_cond, execution_mode,
                                      max_unroll_iterations);
    default:
@@ -1356,7 +1349,7 @@ find_trip_count(loop_info_state *state, unsigned execution_mode,
       nir_const_value initial_val = nir_scalar_as_const_value(initial_s);
       nir_const_value step_val = nir_scalar_as_const_value(alu_s);
 
-      int iterations = calculate_iterations(lv->basis, limit.def,
+      int iterations = calculate_iterations(nir_get_scalar(lv->basis, basic_ind.comp), limit,
                                             initial_val, step_val, limit_val,
                                             nir_instr_as_alu(nir_src_parent_instr(&lv->update_src->src)),
                                             cond,
-- 
GitLab


From 8de9ed0ecdd2c9b940c1867e9a64762ba0376efe Mon Sep 17 00:00:00 2001
From: Rhys Perry <pendingchaos02@gmail.com>
Date: Tue, 14 Nov 2023 20:26:44 +0000
Subject: [PATCH 4/6] nir/loop_analyze: check min compatibility with comparison

Signed-off-by: Rhys Perry <pendingchaos02@gmail.com>
---
 src/compiler/nir/nir_loop_analyze.c           |  36 ++++-
 src/compiler/nir/tests/loop_analyze_tests.cpp | 144 ++++++++++++++++++
 2 files changed, 176 insertions(+), 4 deletions(-)

diff --git a/src/compiler/nir/nir_loop_analyze.c b/src/compiler/nir/nir_loop_analyze.c
index 4996f5f5325e4..c136b4613e016 100644
--- a/src/compiler/nir/nir_loop_analyze.c
+++ b/src/compiler/nir/nir_loop_analyze.c
@@ -672,14 +672,42 @@ guess_loop_limit(loop_info_state *state, nir_const_value *limit_val,
 }
 
 static bool
-try_find_limit_of_alu(nir_scalar limit, nir_const_value *limit_val,
-                      nir_loop_terminator *terminator, loop_info_state *state)
+is_min_compatible(nir_op limit_op, nir_op alu_op, bool limit_rhs, bool invert_cond)
+{
+   switch (limit_op) {
+   case nir_op_imin:
+      switch (alu_op) {
+      case nir_op_ilt:
+         return !limit_rhs ^ invert_cond;
+      case nir_op_ige:
+         return limit_rhs ^ invert_cond;
+      default:
+         return false;
+      }
+   case nir_op_fmin:
+      switch (alu_op) {
+      case nir_op_flt:
+         return !limit_rhs ^ invert_cond;
+      case nir_op_fge:
+         return limit_rhs ^ invert_cond;
+      default:
+         return false;
+      }
+   default:
+      return false;
+   }
+}
+
+static bool
+try_find_limit_of_alu(nir_scalar limit, nir_const_value *limit_val, nir_op alu_op,
+                      bool invert_cond, nir_loop_terminator *terminator,
+                      loop_info_state *state)
 {
    if (!nir_scalar_is_alu(limit))
       return false;
 
    nir_op limit_op = nir_scalar_alu_op(limit);
-   if (limit_op == nir_op_imin || limit_op == nir_op_fmin) {
+   if (is_min_compatible(limit_op, alu_op, !terminator->induction_rhs, invert_cond)) {
       for (unsigned i = 0; i < 2; i++) {
          nir_scalar src = nir_scalar_chase_alu_src(limit, i);
          if (nir_scalar_is_const(src)) {
@@ -1308,7 +1336,7 @@ find_trip_count(loop_info_state *state, unsigned execution_mode,
       } else {
          trip_count_known = false;
 
-         if (!try_find_limit_of_alu(limit, &limit_val, terminator, state)) {
+         if (!try_find_limit_of_alu(limit, &limit_val, alu_op, invert_cond, terminator, state)) {
             /* Guess loop limit based on array access */
             if (!guess_loop_limit(state, &limit_val, basic_ind)) {
                terminator->exact_trip_count_unknown = true;
diff --git a/src/compiler/nir/tests/loop_analyze_tests.cpp b/src/compiler/nir/tests/loop_analyze_tests.cpp
index f7c3c41d75093..acd574bad545a 100644
--- a/src/compiler/nir/tests/loop_analyze_tests.cpp
+++ b/src/compiler/nir/tests/loop_analyze_tests.cpp
@@ -286,6 +286,28 @@ COMPARE_REVERSE(ishl)
 INOT_COMPARE(ilt_rev)
 INOT_COMPARE(ine)
 
+#define CMP_MIN(cmp, min)                                               \
+   static nir_def *nir_##cmp##_##min(nir_builder *b, nir_def *counter, nir_def *limit) \
+   {                                                                    \
+      nir_def *unk = nir_load_vertex_id(b);                             \
+      return nir_##cmp(b, counter, nir_##min(b, limit, unk));           \
+   }
+
+#define CMP_MIN_REV(cmp, min)                                           \
+   static nir_def *nir_##cmp##_##min##_rev(nir_builder *b, nir_def *counter, nir_def *limit) \
+   {                                                                    \
+      nir_def *unk = nir_load_vertex_id(b);                             \
+      return nir_##cmp(b, nir_##min(b, limit, unk), counter);           \
+   }
+
+CMP_MIN(ige, imin)
+CMP_MIN_REV(ige, imin)
+CMP_MIN(ige, fmin)
+CMP_MIN(uge, imin)
+CMP_MIN(ilt, imin)
+CMP_MIN_REV(ilt, imin)
+INOT_COMPARE(ilt_imin_rev)
+
 #define KNOWN_COUNT_TEST(_init_value, _cond_value, _incr_value, cond, incr, count) \
    TEST_F(nir_loop_analyze_test, incr ## _ ## cond ## _known_count_ ## count)    \
    {                                                                    \
@@ -320,6 +342,40 @@ INOT_COMPARE(ine)
       }                                                                 \
    }
 
+#define INEXACT_COUNT_TEST(_init_value, _cond_value, _incr_value, cond, incr, count) \
+   TEST_F(nir_loop_analyze_test, incr ## _ ## cond ## _inexact_count_ ## count)    \
+   {                                                                    \
+      nir_loop *loop =                                                  \
+         loop_builder(&b, {.init_value = _init_value,                   \
+                           .cond_value = _cond_value,                   \
+                           .incr_value = _incr_value,                   \
+                           .cond_instr = nir_ ## cond,                  \
+                           .incr_instr = nir_ ## incr});                \
+                                                                        \
+      nir_validate_shader(b.shader, "input");                           \
+                                                                        \
+      nir_loop_analyze_impl(b.impl, nir_var_all, false);                \
+                                                                        \
+      ASSERT_NE((void *)0, loop->info);                                 \
+      EXPECT_NE((void *)0, loop->info->limiting_terminator);            \
+      EXPECT_EQ(count, loop->info->max_trip_count);                     \
+      EXPECT_FALSE(loop->info->exact_trip_count_known);                 \
+                                                                        \
+      EXPECT_EQ(2, loop->info->num_induction_vars);                     \
+      ASSERT_NE((void *)0, loop->info->induction_vars);                 \
+                                                                        \
+      const nir_loop_induction_variable *const ivars =                  \
+         loop->info->induction_vars;                                    \
+                                                                        \
+      for (unsigned i = 0; i < loop->info->num_induction_vars; i++) {   \
+         EXPECT_NE((void *)0, ivars[i].def);                            \
+         ASSERT_NE((void *)0, ivars[i].init_src);                       \
+         EXPECT_TRUE(nir_src_is_const(*ivars[i].init_src));             \
+         ASSERT_NE((void *)0, ivars[i].update_src);                     \
+         EXPECT_TRUE(nir_src_is_const(ivars[i].update_src->src));       \
+      }                                                                 \
+   }
+
 #define UNKNOWN_COUNT_TEST(_init_value, _cond_value, _incr_value, cond, incr) \
    TEST_F(nir_loop_analyze_test, incr ## _ ## cond ## _unknown_count)   \
    {                                                                    \
@@ -567,6 +623,16 @@ KNOWN_COUNT_TEST_INVERT(0x00000000, 0x00000001, 0x00000006, ige, iadd, 5)
  */
 KNOWN_COUNT_TEST(0x0000000a, 0x00000005, 0xffffffff, inot_ilt_rev, iadd, 5)
 
+/*    int i = 10;
+ *    while (true) {
+ *       if (!(imin(vertex_id, 5) < i))
+ *          break;
+ *
+ *       i += -1;
+ *    }
+ */
+UNKNOWN_COUNT_TEST(0x0000000a, 0x00000005, 0xffffffff, inot_ilt_imin_rev, iadd)
+
 /*    uint i = 0;
  *    while (true) {
  *       if (i != 0)
@@ -1459,3 +1525,81 @@ KNOWN_COUNT_TEST_INVERT(0x0000007f, 0x00000003, 0x00000001, ilt, imul, 16)
  *    }
  */
 KNOWN_COUNT_TEST_INVERT(0xffff7fff, 0x0000000f, 0x34cce9b0, ige, imul, 4)
+
+/*    int i = 0;
+ *    while (true) {
+ *       if (i >= imin(vertex_id, 4))
+ *          break;
+ *
+ *       i++;
+ *    }
+ */
+INEXACT_COUNT_TEST(0x00000000, 0x00000004, 0x00000001, ige_imin, iadd, 4)
+
+/* This fmin is the wrong type to be useful.
+ *
+ *    int i = 0;
+ *    while (true) {
+ *       if (i >= fmin(vertex_id, 4))
+ *          break;
+ *
+ *       i++;
+ *    }
+ */
+UNKNOWN_COUNT_TEST(0x00000000, 0x00000004, 0x00000001, ige_fmin, iadd)
+
+/* The comparison is unsigned, so this isn't safe if vertex_id is negative.
+ *
+ *    uint i = 0;
+ *    while (true) {
+ *       if (i >= imin(vertex_id, 4))
+ *          break;
+ *
+ *       i++;
+ *    }
+ */
+UNKNOWN_COUNT_TEST(0x00000000, 0x00000004, 0x00000001, uge_imin, iadd)
+
+/*    int i = 8;
+ *    while (true) {
+ *       if (4 >= i)
+ *          break;
+ *
+ *       i += -1;
+ *    }
+ */
+KNOWN_COUNT_TEST(0x00000008, 0x00000004, 0xffffffff, ige_rev, iadd, 4)
+
+/*    int i = 8;
+ *    while (true) {
+ *       if (i < 4)
+ *          break;
+ *
+ *       i += -1;
+ *    }
+ */
+KNOWN_COUNT_TEST(0x00000008, 0x00000004, 0xffffffff, ilt, iadd, 5)
+
+/* This imin can increase the iteration count, not limit it.
+ *
+ *    int i = 8;
+ *    while (true) {
+ *       if (imin(vertex_id, 4) >= i)
+ *          break;
+ *
+ *       i += -1;
+ *    }
+ */
+UNKNOWN_COUNT_TEST(0x00000008, 0x00000004, 0xffffffff, ige_imin_rev, iadd)
+
+/* This imin can increase the iteration count, not limit it.
+ *
+ *    int i = 8;
+ *    while (true) {
+ *       if (i < imin(vertex_id, 4))
+ *          break;
+ *
+ *       i += -1;
+ *    }
+ */
+UNKNOWN_COUNT_TEST(0x00000008, 0x00000004, 0xffffffff, ilt_imin, iadd)
-- 
GitLab


From 11ff8ca5de8253176120c8cf3f57daf1b7698ffc Mon Sep 17 00:00:00 2001
From: Rhys Perry <pendingchaos02@gmail.com>
Date: Wed, 15 Nov 2023 17:49:53 +0000
Subject: [PATCH 5/6] nir/loop_analyze: support umin and {u,i,f}max

Signed-off-by: Rhys Perry <pendingchaos02@gmail.com>
---
 src/compiler/nir/nir_loop_analyze.c           | 24 ++++++++++++++-----
 src/compiler/nir/tests/loop_analyze_tests.cpp | 11 +++++++++
 2 files changed, 29 insertions(+), 6 deletions(-)

diff --git a/src/compiler/nir/nir_loop_analyze.c b/src/compiler/nir/nir_loop_analyze.c
index c136b4613e016..361e91f3d9c26 100644
--- a/src/compiler/nir/nir_loop_analyze.c
+++ b/src/compiler/nir/nir_loop_analyze.c
@@ -672,24 +672,36 @@ guess_loop_limit(loop_info_state *state, nir_const_value *limit_val,
 }
 
 static bool
-is_min_compatible(nir_op limit_op, nir_op alu_op, bool limit_rhs, bool invert_cond)
+is_minmax_compatible(nir_op limit_op, nir_op alu_op, bool limit_rhs, bool invert_cond)
 {
    switch (limit_op) {
    case nir_op_imin:
+   case nir_op_imax:
       switch (alu_op) {
       case nir_op_ilt:
-         return !limit_rhs ^ invert_cond;
+         return !limit_rhs ^ (limit_op == nir_op_imax) ^ invert_cond;
       case nir_op_ige:
-         return limit_rhs ^ invert_cond;
+         return limit_rhs ^ (limit_op == nir_op_imax) ^ invert_cond;
       default:
          return false;
       }
    case nir_op_fmin:
+   case nir_op_fmax:
       switch (alu_op) {
       case nir_op_flt:
-         return !limit_rhs ^ invert_cond;
+         return !limit_rhs ^ (limit_op == nir_op_fmax) ^ invert_cond;
       case nir_op_fge:
-         return limit_rhs ^ invert_cond;
+         return limit_rhs ^ (limit_op == nir_op_fmax) ^ invert_cond;
+      default:
+         return false;
+      }
+   case nir_op_umin:
+   case nir_op_umax:
+      switch (alu_op) {
+      case nir_op_ult:
+         return !limit_rhs ^ (limit_op == nir_op_umax) ^ invert_cond;
+      case nir_op_uge:
+         return limit_rhs ^ (limit_op == nir_op_umax) ^ invert_cond;
       default:
          return false;
       }
@@ -707,7 +719,7 @@ try_find_limit_of_alu(nir_scalar limit, nir_const_value *limit_val, nir_op alu_o
       return false;
 
    nir_op limit_op = nir_scalar_alu_op(limit);
-   if (is_min_compatible(limit_op, alu_op, !terminator->induction_rhs, invert_cond)) {
+   if (is_minmax_compatible(limit_op, alu_op, !terminator->induction_rhs, invert_cond)) {
       for (unsigned i = 0; i < 2; i++) {
          nir_scalar src = nir_scalar_chase_alu_src(limit, i);
          if (nir_scalar_is_const(src)) {
diff --git a/src/compiler/nir/tests/loop_analyze_tests.cpp b/src/compiler/nir/tests/loop_analyze_tests.cpp
index acd574bad545a..b9a2c5e0a678d 100644
--- a/src/compiler/nir/tests/loop_analyze_tests.cpp
+++ b/src/compiler/nir/tests/loop_analyze_tests.cpp
@@ -305,6 +305,7 @@ CMP_MIN_REV(ige, imin)
 CMP_MIN(ige, fmin)
 CMP_MIN(uge, imin)
 CMP_MIN(ilt, imin)
+CMP_MIN(ilt, imax)
 CMP_MIN_REV(ilt, imin)
 INOT_COMPARE(ilt_imin_rev)
 
@@ -1603,3 +1604,13 @@ UNKNOWN_COUNT_TEST(0x00000008, 0x00000004, 0xffffffff, ige_imin_rev, iadd)
  *    }
  */
 UNKNOWN_COUNT_TEST(0x00000008, 0x00000004, 0xffffffff, ilt_imin, iadd)
+
+/*    int i = 8;
+ *    while (true) {
+ *       if (i < imax(vertex_id, 4))
+ *          break;
+ *
+ *       i--;
+ *    }
+ */
+INEXACT_COUNT_TEST(0x00000008, 0x00000004, 0xffffffff, ilt_imax, iadd, 5)
-- 
GitLab


From baaefc2197c67512d6d5e8bf9523c44f293cbe68 Mon Sep 17 00:00:00 2001
From: Rhys Perry <pendingchaos02@gmail.com>
Date: Wed, 15 Nov 2023 19:14:50 +0000
Subject: [PATCH 6/6] nir/loop_analyze: support loops with min/max and non-add
 incrementation

Signed-off-by: Rhys Perry <pendingchaos02@gmail.com>
---
 src/compiler/nir/nir_loop_analyze.c           | 19 +++++++++++--------
 src/compiler/nir/tests/loop_analyze_tests.cpp | 11 +++++++++++
 2 files changed, 22 insertions(+), 8 deletions(-)

diff --git a/src/compiler/nir/nir_loop_analyze.c b/src/compiler/nir/nir_loop_analyze.c
index 361e91f3d9c26..a6ae26c18b344 100644
--- a/src/compiler/nir/nir_loop_analyze.c
+++ b/src/compiler/nir/nir_loop_analyze.c
@@ -953,20 +953,23 @@ get_iteration(nir_op cond_op, nir_const_value initial, nir_const_value step,
 static int32_t
 get_iteration_empirical(nir_scalar cond, nir_alu_instr *incr_alu,
                         nir_scalar basis, nir_const_value initial,
+                        nir_scalar limit_basis, nir_const_value limit,
                         bool invert_cond, unsigned execution_mode,
                         unsigned max_unroll_iterations)
 {
    int iter_count = 0;
    nir_const_value result;
-   nir_const_value iter = initial;
 
    const nir_scalar incr = nir_get_scalar(&incr_alu->def, basis.comp);
 
+   const nir_scalar original[] = {basis, limit_basis};
+   nir_const_value replacement[] = {initial, limit};
+
    while (iter_count <= max_unroll_iterations) {
       bool success;
 
-      success = try_eval_const_alu(&result, cond, &basis, &iter,
-                                   1, execution_mode);
+      success = try_eval_const_alu(&result, cond, original, replacement,
+                                   2, execution_mode);
       if (!success)
          return -1;
 
@@ -976,11 +979,11 @@ get_iteration_empirical(nir_scalar cond, nir_alu_instr *incr_alu,
 
       iter_count++;
 
-      success = try_eval_const_alu(&result, incr, &basis, &iter,
-                                   1, execution_mode);
+      success = try_eval_const_alu(&result, incr, original, replacement,
+                                   2, execution_mode);
       assert(success);
 
-      iter = result;
+      replacement[0] = result;
    }
 
    return -1;
@@ -1135,8 +1138,8 @@ calculate_iterations(nir_scalar basis, nir_scalar limit_basis,
    case nir_op_ishr:
    case nir_op_ushr:
       return get_iteration_empirical(cond, alu, basis, initial,
-                                     invert_cond, execution_mode,
-                                     max_unroll_iterations);
+                                     limit_basis, limit, invert_cond,
+                                     execution_mode, max_unroll_iterations);
    default:
       unreachable("Invalid induction variable increment operation.");
    }
diff --git a/src/compiler/nir/tests/loop_analyze_tests.cpp b/src/compiler/nir/tests/loop_analyze_tests.cpp
index b9a2c5e0a678d..24415c9b2a7e1 100644
--- a/src/compiler/nir/tests/loop_analyze_tests.cpp
+++ b/src/compiler/nir/tests/loop_analyze_tests.cpp
@@ -302,6 +302,7 @@ INOT_COMPARE(ine)
 
 CMP_MIN(ige, imin)
 CMP_MIN_REV(ige, imin)
+CMP_MIN(uge, umin)
 CMP_MIN(ige, fmin)
 CMP_MIN(uge, imin)
 CMP_MIN(ilt, imin)
@@ -1614,3 +1615,13 @@ UNKNOWN_COUNT_TEST(0x00000008, 0x00000004, 0xffffffff, ilt_imin, iadd)
  *    }
  */
 INEXACT_COUNT_TEST(0x00000008, 0x00000004, 0xffffffff, ilt_imax, iadd, 5)
+
+/*    uint i = 0x00000001;
+ *    while (true) {
+ *       if (i >= umin(vertex_id, 0x00000100))
+ *          break;
+ *
+ *       i <<= 1;
+ *    }
+ */
+INEXACT_COUNT_TEST(0x00000001, 0x00000100, 0x00000001, uge_umin, ishl, 8)
-- 
GitLab

