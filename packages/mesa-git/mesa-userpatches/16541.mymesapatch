From db37f7e81c091eb16b853771cca53404b244389b Mon Sep 17 00:00:00 2001
From: Victor Hermann Chiletto <v@hnn.net.br>
Date: Sat, 14 May 2022 17:00:21 -0300
Subject: [PATCH] radv: refactor descriptor set layout tracking

Separately track descriptor set layouts for pools with
FREE_DESCRIPTOR_SET disabled, instead of reusing
`radv_descriptor_pool::entries`. This saves 8 bytes for each entry and
also avoids some indirection.
---
 src/amd/vulkan/radv_descriptor_set.c | 50 +++++++++++++++++++---------
 src/amd/vulkan/radv_private.h        |  6 +++-
 2 files changed, 40 insertions(+), 16 deletions(-)

diff --git a/src/amd/vulkan/radv_descriptor_set.c b/src/amd/vulkan/radv_descriptor_set.c
index e4c55ce2f24e..b74fd40b9e54 100644
--- a/src/amd/vulkan/radv_descriptor_set.c
+++ b/src/amd/vulkan/radv_descriptor_set.c
@@ -674,11 +674,15 @@ radv_descriptor_set_create(struct radv_device *device, struct radv_descriptor_po
       set->header.bo = pool->bo;
       set->header.mapped_ptr = (uint32_t *)(pool->mapped_ptr + pool->current_offset);
       set->header.va = pool->bo ? (radv_buffer_get_va(set->header.bo) + pool->current_offset) : 0;
+
       if (!pool->host_memory_base) {
          pool->entries[pool->entry_count].offset = pool->current_offset;
          pool->entries[pool->entry_count].size = layout_size;
+         pool->entries[pool->entry_count].set = set;
+      } else {
+         pool->layouts[pool->entry_count] = layout;
       }
-      pool->entries[pool->entry_count].set = set;
+
       pool->current_offset += layout_size;
    } else if (!pool->host_memory_base) {
       uint64_t offset = 0;
@@ -734,10 +738,9 @@ static void
 radv_descriptor_set_destroy(struct radv_device *device, struct radv_descriptor_pool *pool,
                             struct radv_descriptor_set *set, bool free_bo)
 {
-   vk_descriptor_set_layout_unref(&device->vk, &set->header.layout->vk);
+   assert(!pool->host_memory_base);
 
-   if (pool->host_memory_base)
-      return;
+   vk_descriptor_set_layout_unref(&device->vk, &set->header.layout->vk);
 
    if (free_bo && !pool->host_memory_base) {
       for (int i = 0; i < pool->entry_count; ++i) {
@@ -757,8 +760,15 @@ static void
 radv_destroy_descriptor_pool(struct radv_device *device, const VkAllocationCallbacks *pAllocator,
                              struct radv_descriptor_pool *pool)
 {
-   for (int i = 0; i < pool->entry_count; ++i) {
-      radv_descriptor_set_destroy(device, pool, pool->entries[i].set, false);
+
+   if (!pool->host_memory_base) {
+      for (uint32_t i = 0; i < pool->entry_count; ++i) {
+         radv_descriptor_set_destroy(device, pool, pool->entries[i].set, false);
+      }
+   } else {
+      for (uint32_t i = 0; i < pool->entry_count; ++i) {
+         vk_descriptor_set_layout_unref(&device->vk, &pool->layouts[i]->vk);
+      }
    }
 
    if (pool->bo)
@@ -852,14 +862,17 @@ radv_CreateDescriptorPool(VkDevice _device, const VkDescriptorPoolCreateInfo *pC
       }
    }
 
-   uint64_t entries_size = sizeof(struct radv_descriptor_pool_entry) * pCreateInfo->maxSets;
-   size += entries_size;
+   uint64_t layouts_size = 0;
 
    if (!(pCreateInfo->flags & VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT)) {
-      uint64_t host_size = pCreateInfo->maxSets * sizeof(struct radv_descriptor_set);
-      host_size += sizeof(struct radeon_winsys_bo *) * bo_count;
-      host_size += sizeof(struct radv_descriptor_range) * range_count;
-      size += host_size;
+      size += pCreateInfo->maxSets * sizeof(struct radv_descriptor_set);
+      size += sizeof(struct radeon_winsys_bo *) * bo_count;
+      size += sizeof(struct radv_descriptor_range) * range_count;
+
+      layouts_size = sizeof(struct radv_descriptor_set_layout *) * pCreateInfo->maxSets;
+      size += layouts_size;
+   } else {
+      size += sizeof(struct radv_descriptor_pool_entry) * pCreateInfo->maxSets;
    }
 
    pool = vk_alloc2(&device->vk.alloc, pAllocator, size, 8, VK_SYSTEM_ALLOCATION_SCOPE_OBJECT);
@@ -871,7 +884,7 @@ radv_CreateDescriptorPool(VkDevice _device, const VkDescriptorPoolCreateInfo *pC
    vk_object_base_init(&device->vk, &pool->base, VK_OBJECT_TYPE_DESCRIPTOR_POOL);
 
    if (!(pCreateInfo->flags & VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT)) {
-      pool->host_memory_base = (uint8_t *)pool + sizeof(struct radv_descriptor_pool) + entries_size;
+      pool->host_memory_base = (uint8_t *)pool + sizeof(struct radv_descriptor_pool) + layouts_size;
       pool->host_memory_ptr = pool->host_memory_base;
       pool->host_memory_end = (uint8_t *)pool + size;
    }
@@ -933,9 +946,16 @@ radv_ResetDescriptorPool(VkDevice _device, VkDescriptorPool descriptorPool,
    RADV_FROM_HANDLE(radv_device, device, _device);
    RADV_FROM_HANDLE(radv_descriptor_pool, pool, descriptorPool);
 
-   for (int i = 0; i < pool->entry_count; ++i) {
-      radv_descriptor_set_destroy(device, pool, pool->entries[i].set, false);
+   if (!pool->host_memory_base) {
+      for (uint32_t i = 0; i < pool->entry_count; ++i) {
+         radv_descriptor_set_destroy(device, pool, pool->entries[i].set, false);
+      }
+   } else {
+      for (uint32_t i = 0; i < pool->entry_count; ++i) {
+         vk_descriptor_set_layout_unref(&device->vk, &pool->layouts[i]->vk);
+      }
    }
+
    pool->entry_count = 0;
 
    pool->current_offset = 0;
diff --git a/src/amd/vulkan/radv_private.h b/src/amd/vulkan/radv_private.h
index a9aac7e932e2..1d1fd352b5a8 100644
--- a/src/amd/vulkan/radv_private.h
+++ b/src/amd/vulkan/radv_private.h
@@ -1012,7 +1012,11 @@ struct radv_descriptor_pool {
 
    uint32_t entry_count;
    uint32_t max_entry_count;
-   struct radv_descriptor_pool_entry entries[0];
+
+   union {
+      struct radv_descriptor_set_layout *layouts[0];
+      struct radv_descriptor_pool_entry entries[0];
+   };
 };
 
 struct radv_descriptor_update_template_entry {
-- 
GitLab

