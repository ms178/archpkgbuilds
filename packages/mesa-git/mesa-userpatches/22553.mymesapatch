From 7bf69aca1b7e01c4d07be2815d82de1fae81f29d Mon Sep 17 00:00:00 2001
From: Rhys Perry <pendingchaos02@gmail.com>
Date: Tue, 18 Apr 2023 14:50:18 +0100
Subject: [PATCH 1/2] aco: remove SMEM_instruction::prevent_overflow

This doesn't seem useful anymore, and it seems we forgot to set it in a
few places.

This commit changes the behaviour of the optimizer so that
prevent_overflow is always true.

fossil-db (navi21):
Totals from 7421 (5.47% of 135636) affected shaders:
Instrs: 5402823 -> 5440126 (+0.69%); split: -0.00%, +0.69%
CodeSize: 28731300 -> 28974152 (+0.85%); split: -0.00%, +0.85%
VGPRs: 317528 -> 317552 (+0.01%)
SpillSGPRs: 419 -> 415 (-0.95%)
Latency: 40712478 -> 40783115 (+0.17%); split: -0.01%, +0.19%
InvThroughput: 7612708 -> 7616751 (+0.05%); split: -0.00%, +0.06%
VClause: 123824 -> 123848 (+0.02%); split: -0.09%, +0.11%
SClause: 161915 -> 172741 (+6.69%); split: -0.03%, +6.71%
Copies: 393015 -> 394429 (+0.36%); split: -0.20%, +0.56%
PreSGPRs: 288658 -> 289603 (+0.33%); split: -0.04%, +0.36%

Signed-off-by: Rhys Perry <pendingchaos02@gmail.com>
Closes: https://gitlab.freedesktop.org/mesa/mesa/-/issues/8864
Cc: mesa-stable
---
 src/amd/compiler/aco_instruction_selection.cpp | 2 +-
 src/amd/compiler/aco_ir.h                      | 3 +--
 src/amd/compiler/aco_opt_value_numbering.cpp   | 4 +---
 src/amd/compiler/aco_optimizer.cpp             | 3 +--
 4 files changed, 4 insertions(+), 8 deletions(-)

diff --git a/src/amd/compiler/aco_instruction_selection.cpp b/src/amd/compiler/aco_instruction_selection.cpp
index 7b685c3a95b8..712f7785d40a 100644
--- a/src/amd/compiler/aco_instruction_selection.cpp
+++ b/src/amd/compiler/aco_instruction_selection.cpp
@@ -5812,7 +5812,7 @@ visit_load_push_constant(isel_context* ctx, nir_intrinsic_instr* instr)
    default: unreachable("unimplemented or forbidden load_push_constant.");
    }
 
-   bld.smem(op, Definition(vec), ptr, index)->smem().prevent_overflow = true;
+   bld.smem(op, Definition(vec), ptr, index);
 
    if (!aligned) {
       Operand byte_offset = index_cv ? Operand::c32((offset + index_cv->u32) % 4) : Operand(index);
diff --git a/src/amd/compiler/aco_ir.h b/src/amd/compiler/aco_ir.h
index 3fffffde4592..db2158e4ae82 100644
--- a/src/amd/compiler/aco_ir.h
+++ b/src/amd/compiler/aco_ir.h
@@ -1384,8 +1384,7 @@ struct SMEM_instruction : public Instruction {
    bool dlc : 1; /* NAVI: device level coherent */
    bool nv : 1;  /* VEGA only: Non-volatile */
    bool disable_wqm : 1;
-   bool prevent_overflow : 1; /* avoid overflow when combining additions */
-   uint8_t padding : 3;
+   uint8_t padding : 4;
 };
 static_assert(sizeof(SMEM_instruction) == sizeof(Instruction) + 4, "Unexpected padding");
 
diff --git a/src/amd/compiler/aco_opt_value_numbering.cpp b/src/amd/compiler/aco_opt_value_numbering.cpp
index 7039eff2dcb7..1b824a87bd45 100644
--- a/src/amd/compiler/aco_opt_value_numbering.cpp
+++ b/src/amd/compiler/aco_opt_value_numbering.cpp
@@ -220,10 +220,8 @@ struct InstrPred {
       case Format::SMEM: {
          SMEM_instruction& aS = a->smem();
          SMEM_instruction& bS = b->smem();
-         /* isel shouldn't be creating situations where this assertion fails */
-         assert(aS.prevent_overflow == bS.prevent_overflow);
          return aS.sync == bS.sync && aS.glc == bS.glc && aS.dlc == bS.dlc && aS.nv == bS.nv &&
-                aS.disable_wqm == bS.disable_wqm && aS.prevent_overflow == bS.prevent_overflow;
+                aS.disable_wqm == bS.disable_wqm;
       }
       case Format::VINTRP: {
          VINTRP_instruction& aI = a->vintrp();
diff --git a/src/amd/compiler/aco_optimizer.cpp b/src/amd/compiler/aco_optimizer.cpp
index c366feeba9f9..4c4cb5faaebb 100644
--- a/src/amd/compiler/aco_optimizer.cpp
+++ b/src/amd/compiler/aco_optimizer.cpp
@@ -850,13 +850,12 @@ smem_combine(opt_ctx& ctx, aco_ptr<Instruction>& instr)
 
       Temp base;
       uint32_t offset;
-      bool prevent_overflow = smem.operands[0].size() > 2 || smem.prevent_overflow;
       if (info.is_constant_or_literal(32) &&
           ((ctx.program->gfx_level == GFX6 && info.val <= 0x3FF) ||
            (ctx.program->gfx_level == GFX7 && info.val <= 0xFFFFFFFF) ||
            (ctx.program->gfx_level >= GFX8 && info.val <= 0xFFFFF))) {
          instr->operands[1] = Operand::c32(info.val);
-      } else if (parse_base_offset(ctx, instr.get(), 1, &base, &offset, prevent_overflow) &&
+      } else if (parse_base_offset(ctx, instr.get(), 1, &base, &offset, true) &&
                  base.regClass() == s1 && offset <= 0xFFFFF && ctx.program->gfx_level >= GFX9 &&
                  offset % 4u == 0) {
          bool soe = smem.operands.size() >= (!smem.definitions.empty() ? 3 : 4);
-- 
GitLab


From 457b7dfc5c65db87420930e1fd44b0dd0cedf501 Mon Sep 17 00:00:00 2001
From: Rhys Perry <pendingchaos02@gmail.com>
Date: Tue, 18 Apr 2023 14:58:57 +0100
Subject: [PATCH 2/2] aco: use apply_nuw_to_ssa() with load_smem_amd

fossil-db (navi21):
Totals from 107 (0.08% of 135636) affected shaders:
Instrs: 389667 -> 389425 (-0.06%); split: -0.06%, +0.00%
CodeSize: 2050380 -> 2049440 (-0.05%); split: -0.05%, +0.00%
Latency: 3738053 -> 3737313 (-0.02%); split: -0.02%, +0.00%
InvThroughput: 599889 -> 599790 (-0.02%); split: -0.02%, +0.00%
SClause: 16120 -> 15920 (-1.24%)
Copies: 29823 -> 29809 (-0.05%); split: -0.07%, +0.02%
PreSGPRs: 6856 -> 6849 (-0.10%)

Signed-off-by: Rhys Perry <pendingchaos02@gmail.com>
---
 src/amd/compiler/aco_instruction_selection_setup.cpp | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/src/amd/compiler/aco_instruction_selection_setup.cpp b/src/amd/compiler/aco_instruction_selection_setup.cpp
index a87120bbdfd6..e07bb0eb7ca1 100644
--- a/src/amd/compiler/aco_instruction_selection_setup.cpp
+++ b/src/amd/compiler/aco_instruction_selection_setup.cpp
@@ -232,7 +232,8 @@ apply_nuw_to_offsets(isel_context* ctx, nir_function_impl* impl)
                apply_nuw_to_ssa(ctx, intrin->src[2].ssa);
             break;
          case nir_intrinsic_load_scratch: apply_nuw_to_ssa(ctx, intrin->src[0].ssa); break;
-         case nir_intrinsic_store_scratch: apply_nuw_to_ssa(ctx, intrin->src[1].ssa); break;
+         case nir_intrinsic_store_scratch:
+         case nir_intrinsic_load_smem_amd: apply_nuw_to_ssa(ctx, intrin->src[1].ssa); break;
          default: break;
          }
       }
-- 
GitLab

