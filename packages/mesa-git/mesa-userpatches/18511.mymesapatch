From e144ba339ddfafb0367402dbc0ae1485dd8679ad Mon Sep 17 00:00:00 2001
From: Timothy Arceri <tarceri@itsqueeze.com>
Date: Fri, 9 Sep 2022 15:07:52 +1000
Subject: [PATCH] nir: improve out of bounds array access elimination

If vars_to_ssa exited early because it didn't think it had any
work to do it would mean it didn't turn out-of-bounds array
access it detected into undefs. Here we split out the code
to replace the out-of-bounds access and make sure to always
call it.
---
 src/compiler/nir/nir_lower_vars_to_ssa.c | 86 +++++++++++++++++++-----
 1 file changed, 70 insertions(+), 16 deletions(-)

diff --git a/src/compiler/nir/nir_lower_vars_to_ssa.c b/src/compiler/nir/nir_lower_vars_to_ssa.c
index e69a92805626..b45fcbdb2613 100644
--- a/src/compiler/nir/nir_lower_vars_to_ssa.c
+++ b/src/compiler/nir/nir_lower_vars_to_ssa.c
@@ -532,16 +532,12 @@ lower_copies_to_load_store(struct deref_node *node,
    node->copies = NULL;
 }
 
-/* Performs variable renaming
- *
- * This algorithm is very similar to the one outlined in "Efficiently
- * Computing Static Single Assignment Form and the Control Dependence
- * Graph" by Cytron et al.  The primary difference is that we only put one
- * SSA def on the stack per block.
- */
+/* Replaces out-of-bounds array access with an undef */
 static bool
-rename_variables(struct lower_variables_state *state)
+remove_out_of_bounds_array_access(struct lower_variables_state *state)
 {
+   bool progress = false;
+
    nir_builder b;
    nir_builder_init(&b, state->impl);
 
@@ -578,9 +574,73 @@ rename_variables(struct lower_variables_state *state)
 
                nir_ssa_def_rewrite_uses(&intrin->dest.ssa,
                                         &undef->def);
+
+               progress = true;
+               continue;
+            }
+
+            break;
+         }
+
+         case nir_intrinsic_store_deref: {
+            nir_deref_instr *deref = nir_src_as_deref(intrin->src[0]);
+            if (!nir_deref_mode_must_be(deref, nir_var_function_temp))
+               continue;
+
+            struct deref_node *node = get_deref_node(deref, state);
+            if (node == NULL)
+               continue;
+
+            if (node == UNDEF_NODE) {
+               /* Probably an out-of-bounds array store.  That should be a
+                * no-op. */
+               nir_instr_remove(&intrin->instr);
+               progress = true;
                continue;
             }
 
+            break;
+         }
+
+         default:
+            break;
+         }
+      }
+   }
+
+   return progress;
+}
+
+/* Performs variable renaming
+ *
+ * This algorithm is very similar to the one outlined in "Efficiently
+ * Computing Static Single Assignment Form and the Control Dependence
+ * Graph" by Cytron et al.  The primary difference is that we only put one
+ * SSA def on the stack per block.
+ */
+static bool
+rename_variables(struct lower_variables_state *state)
+{
+   nir_builder b;
+   nir_builder_init(&b, state->impl);
+
+   nir_foreach_block(block, state->impl) {
+      nir_foreach_instr_safe(instr, block) {
+         if (instr->type != nir_instr_type_intrinsic)
+            continue;
+
+         nir_intrinsic_instr *intrin = nir_instr_as_intrinsic(instr);
+
+         switch (intrin->intrinsic) {
+         case nir_intrinsic_load_deref: {
+            nir_deref_instr *deref = nir_src_as_deref(intrin->src[0]);
+            if (!nir_deref_mode_must_be(deref, nir_var_function_temp))
+               continue;
+
+            struct deref_node *node = get_deref_node(deref, state);
+            if (node == NULL)
+               continue;
+
             if (!node->lower_to_ssa)
                continue;
 
@@ -618,13 +678,6 @@ rename_variables(struct lower_variables_state *state)
             assert(intrin->src[1].is_ssa);
             nir_ssa_def *value = intrin->src[1].ssa;
 
-            if (node == UNDEF_NODE) {
-               /* Probably an out-of-bounds array store.  That should be a
-                * no-op. */
-               nir_instr_remove(&intrin->instr);
-               continue;
-            }
-
             if (!node->lower_to_ssa)
                continue;
 
@@ -751,7 +804,7 @@ nir_lower_vars_to_ssa_impl(nir_function_impl *impl)
 
    if (!progress) {
       nir_metadata_preserve(impl, nir_metadata_all);
-      return false;
+      return remove_out_of_bounds_array_access(&state);
    }
 
    nir_metadata_require(impl, nir_metadata_dominance);
@@ -795,6 +848,7 @@ nir_lower_vars_to_ssa_impl(nir_function_impl *impl)
                                    store_blocks);
    }
 
+   remove_out_of_bounds_array_access(&state);
    rename_variables(&state);
 
    nir_phi_builder_finish(state.phi_builder);
-- 
GitLab

