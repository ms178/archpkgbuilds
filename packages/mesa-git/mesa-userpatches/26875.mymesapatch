From a49f27a44cbca315871f8412c012c880c3684ef4 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Daniel=20Sch=C3=BCrmann?= <daniel@schuermann.dev>
Date: Thu, 4 Jan 2024 15:50:10 +0100
Subject: [PATCH] aco: rematerialize constants in every basic block during
 optimizer

Totals from 16946 (21.36% of 79330) affected shaders: (GFX11)
MaxWaves: 444691 -> 447605 (+0.66%); split: +0.66%, -0.00%
Instrs: 26825464 -> 26774875 (-0.19%); split: -0.30%, +0.11%
CodeSize: 137832736 -> 139425108 (+1.16%); split: -0.03%, +1.18%
VGPRs: 991144 -> 983188 (-0.80%); split: -0.84%, +0.03%
SpillSGPRs: 9211 -> 7691 (-16.50%); split: -16.83%, +0.33%
SpillVGPRs: 1379 -> 1366 (-0.94%); split: -1.67%, +0.73%
Scratch: 5046016 -> 5042688 (-0.07%); split: -0.07%, +0.01%
Latency: 213743458 -> 213739275 (-0.00%); split: -0.26%, +0.26%
InvThroughput: 37776112 -> 37705741 (-0.19%); split: -0.35%, +0.16%
VClause: 462067 -> 460696 (-0.30%); split: -0.51%, +0.22%
SClause: 854113 -> 853740 (-0.04%); split: -0.19%, +0.15%
Copies: 1807354 -> 1751813 (-3.07%); split: -4.05%, +0.97%
Branches: 587341 -> 587222 (-0.02%); split: -0.03%, +0.01%
PreSGPRs: 883959 -> 825018 (-6.67%); split: -6.67%, +0.01%
PreVGPRs: 857973 -> 852148 (-0.68%); split: -0.68%, +0.00%
---
 src/amd/compiler/aco_optimizer.cpp | 95 ++++++++++++++++++++++++++++--
 1 file changed, 90 insertions(+), 5 deletions(-)

diff --git a/src/amd/compiler/aco_optimizer.cpp b/src/amd/compiler/aco_optimizer.cpp
index 2f4efa0b0aa0a..0ff991e5ef8d0 100644
--- a/src/amd/compiler/aco_optimizer.cpp
+++ b/src/amd/compiler/aco_optimizer.cpp
@@ -521,7 +521,7 @@ struct opt_ctx {
    Program* program;
    float_mode fp_mode;
    std::vector<aco_ptr<Instruction>> instructions;
-   ssa_info* info;
+   std::vector<ssa_info> info;
    std::pair<uint32_t, Temp> last_literal;
    std::vector<mad_info> mad_infos;
    std::vector<uint16_t> uses;
@@ -3101,6 +3101,7 @@ combine_add_sub_b2i(opt_ctx& ctx, aco_ptr<Instruction>& instr, aco_opcode new_op
              * uses properly initialized to 0.
              */
             ctx.uses.push_back(0);
+            ctx.info.push_back(ssa_info{});
          }
          new_instr->operands[0] = Operand::zero();
          new_instr->operands[1] = instr->operands[!i];
@@ -4598,6 +4599,88 @@ combine_instruction(opt_ctx& ctx, aco_ptr<Instruction>& instr)
    }
 }
 
+struct remat_entry {
+   Instruction* instr;
+   uint32_t block;
+};
+
+inline bool
+is_constant(Instruction* instr)
+{
+   if (instr->opcode != aco_opcode::p_parallelcopy || instr->operands.size() != 1)
+      return false;
+
+   return instr->operands[0].isConstant() && instr->definitions[0].isTemp();
+}
+
+void
+remat_constants_instr(opt_ctx& ctx, aco::map<Temp, remat_entry>& constants, Instruction* instr,
+                      uint32_t block_idx)
+{
+   for (Operand& op : instr->operands) {
+      if (!op.isTemp())
+         continue;
+
+      auto it = constants.find(op.getTemp());
+      if (it == constants.end())
+         continue;
+
+      /* Check if we already emitted the same constant in this block. */
+      if (it->second.block != block_idx) {
+         /* Rematerialize the constant. */
+         Builder bld(ctx.program, &ctx.instructions);
+         Operand const_op = it->second.instr->operands[0];
+         it->second.instr = bld.copy(bld.def(op.regClass()), const_op);
+         it->second.block = block_idx;
+         ctx.uses.push_back(0);
+         ctx.info.push_back(ctx.info[op.tempId()]);
+      }
+
+      /* Use the rematerialized constant and update information about latest use. */
+      if (op.getTemp() != it->second.instr->definitions[0].getTemp()) {
+         ctx.uses[op.tempId()]--;
+         op.setTemp(it->second.instr->definitions[0].getTemp());
+         ctx.uses[op.tempId()]++;
+      }
+   }
+}
+
+/**
+ * This pass implements a simple constant rematerialization.
+ * As common subexpression elimination (CSE) might increase the live-ranges
+ * of loaded constants over large distances, this pass splits the live-ranges
+ * again by re-emitting constants in every basic block.
+ */
+void
+rematerialize_constants(opt_ctx& ctx)
+{
+   aco::monotonic_buffer_resource memory = aco::monotonic_buffer_resource(1024);
+   aco::map<Temp, remat_entry> constants = aco::map<Temp, remat_entry>(memory);
+
+   for (Block& block : ctx.program->blocks) {
+      if (block.logical_idom == -1)
+         continue;
+
+      ctx.instructions.reserve(block.instructions.size());
+
+      for (aco_ptr<Instruction>& instr : block.instructions) {
+         if (is_dead(ctx.uses, instr.get()))
+            continue;
+
+         if (is_constant(instr.get())) {
+            Temp tmp = instr->definitions[0].getTemp();
+            constants[tmp] = {instr.get(), block.index};
+         } else if (!is_phi(instr)) {
+            remat_constants_instr(ctx, constants, instr.get(), block.index);
+         }
+
+         ctx.instructions.emplace_back(instr.release());
+      }
+
+      block.instructions = std::move(ctx.instructions);
+   }
+}
+
 bool
 to_uniform_bool_instr(opt_ctx& ctx, aco_ptr<Instruction>& instr)
 {
@@ -5283,8 +5366,7 @@ optimize(Program* program)
 {
    opt_ctx ctx;
    ctx.program = program;
-   std::vector<ssa_info> info(program->peekAllocationId());
-   ctx.info = info.data();
+   ctx.info = std::vector<ssa_info>(program->peekAllocationId());
 
    /* 1. Bottom-Up DAG pass (forward) to label all ssa-defs */
    for (Block& block : program->blocks) {
@@ -5302,7 +5384,10 @@ optimize(Program* program)
          combine_instruction(ctx, instr);
    }
 
-   /* 3. Top-Down DAG pass (backward) to select instructions (includes DCE) */
+   /* 3. Rematerialize constants in every block. */
+   rematerialize_constants(ctx);
+
+   /* 4. Top-Down DAG pass (backward) to select instructions (includes DCE) */
    for (auto block_rit = program->blocks.rbegin(); block_rit != program->blocks.rend();
         ++block_rit) {
       Block* block = &(*block_rit);
@@ -5312,7 +5397,7 @@ optimize(Program* program)
          select_instruction(ctx, *instr_rit);
    }
 
-   /* 4. Add literals to instructions */
+   /* 5. Add literals to instructions */
    for (Block& block : program->blocks) {
       ctx.instructions.reserve(block.instructions.size());
       ctx.fp_mode = block.fp_mode;
-- 
GitLab

