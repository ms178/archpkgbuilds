From a9e4f5c3cc6f497aa2cd6f2b28e4df23e8b9f812 Mon Sep 17 00:00:00 2001
From: David Rosca <nowrep@gmail.com>
Date: Sat, 23 Sep 2023 13:11:57 +0200
Subject: [PATCH 1/2] frontends/va: Process VAEncSequenceParameterBufferType
 first in vaRenderPicture

The encoder is created in handleVAEncSequenceParameterBufferType and it
also sets some default parameters, so we need to make sure to handle
this buffer first because application may have already set those
parameters from earlier buffers.

This fixes setting HRD parameters with gstreamer vah264enc/vah265enc
when PIPE_VIDEO_CAP_ENC_QUALITY_LEVEL is supported.

Cc: mesa-stable
---
 src/gallium/frontends/va/picture.c | 13 +++++++++----
 1 file changed, 9 insertions(+), 4 deletions(-)

diff --git a/src/gallium/frontends/va/picture.c b/src/gallium/frontends/va/picture.c
index 4fc6eeb7ff32..6bd799e606c8 100644
--- a/src/gallium/frontends/va/picture.c
+++ b/src/gallium/frontends/va/picture.c
@@ -824,6 +824,7 @@ vlVaRenderPicture(VADriverContextP ctx, VAContextID context_id, VABufferID *buff
 
    unsigned i;
    unsigned slice_idx = 0;
+   vlVaBuffer *seq_param_buf = NULL;
 
    if (!ctx)
       return VA_STATUS_ERROR_INVALID_CONTEXT;
@@ -849,8 +850,16 @@ vlVaRenderPicture(VADriverContextP ctx, VAContextID context_id, VABufferID *buff
 
       if (buf->type == VAProtectedSliceDataBufferType)
          handleVAProtectedSliceDataBufferType(context, buf);
+      else if (buf->type == VAEncSequenceParameterBufferType)
+         seq_param_buf = buf;
    }
 
+   /* Now process VAEncSequenceParameterBufferType where the encoder is created
+    * and some default parameters are set to make sure it won't overwrite
+    * parameters already set by application from earlier buffers. */
+   if (seq_param_buf)
+      vaStatus = handleVAEncSequenceParameterBufferType(drv, context, seq_param_buf);
+
    for (i = 0; i < num_buffers && vaStatus == VA_STATUS_SUCCESS; ++i) {
       vlVaBuffer *buf = handle_table_get(drv->htab, buffers[i]);
 
@@ -883,10 +892,6 @@ vlVaRenderPicture(VADriverContextP ctx, VAContextID context_id, VABufferID *buff
          vaStatus = vlVaHandleVAProcPipelineParameterBufferType(drv, context, buf);
          break;
 
-      case VAEncSequenceParameterBufferType:
-         vaStatus = handleVAEncSequenceParameterBufferType(drv, context, buf);
-         break;
-
       case VAEncMiscParameterBufferType:
          vaStatus = handleVAEncMiscParameterBufferType(context, buf);
          break;
-- 
GitLab


From a162bf8dd3b5453a12bfaf23eb1f2b857d1101b6 Mon Sep 17 00:00:00 2001
From: David Rosca <nowrep@gmail.com>
Date: Sat, 23 Sep 2023 15:49:55 +0200
Subject: [PATCH 2/2] frontends/va: Set default rate control values once when
 creating encoder

Move setting the default values from getEncParamPresetH264/5 as this
function is called on each frame which would result in overwriting
values set by application.

This fixes setting HRD parameters with gstreamer vah264enc/vah265enc
when PIPE_VIDEO_CAP_ENC_QUALITY_LEVEL is not supported.

Cc: mesa-stable
---
 src/gallium/frontends/va/picture_h264_enc.c | 14 +++++++-------
 src/gallium/frontends/va/picture_hevc_enc.c | 13 ++++++-------
 2 files changed, 13 insertions(+), 14 deletions(-)

diff --git a/src/gallium/frontends/va/picture_h264_enc.c b/src/gallium/frontends/va/picture_h264_enc.c
index e11895195ff2..48403b17e783 100644
--- a/src/gallium/frontends/va/picture_h264_enc.c
+++ b/src/gallium/frontends/va/picture_h264_enc.c
@@ -194,6 +194,13 @@ vlVaHandleVAEncSequenceParameterBufferTypeH264(vlVaDriver *drv, vlVaContext *con
          return VA_STATUS_ERROR_ALLOCATION_FAILED;
 
       getEncParamPresetH264(context);
+      context->desc.h264enc.rate_ctrl[0].vbv_buffer_size = 20000000;
+      context->desc.h264enc.rate_ctrl[0].vbv_buf_lv = 48;
+      context->desc.h264enc.rate_ctrl[0].fill_data_enable = 1;
+      context->desc.h264enc.rate_ctrl[0].enforce_hrd = 1;
+      context->desc.h264enc.rate_ctrl[0].max_qp = 51;
+      context->desc.h264enc.rate_ctrl[0].min_qp = 0;
+      context->desc.h264enc.enable_vui = false;
    }
 
    context->desc.h264enc.intra_idr_period =
@@ -494,13 +501,6 @@ vlVaHandleVAEncMiscParameterTypeHRDH264(vlVaContext *context, VAEncMiscParameter
 void getEncParamPresetH264(vlVaContext *context)
 {
    //rate control
-   context->desc.h264enc.rate_ctrl[0].vbv_buffer_size = 20000000;
-   context->desc.h264enc.rate_ctrl[0].vbv_buf_lv = 48;
-   context->desc.h264enc.rate_ctrl[0].fill_data_enable = 1;
-   context->desc.h264enc.rate_ctrl[0].enforce_hrd = 1;
-   context->desc.h264enc.rate_ctrl[0].max_qp = 51;
-   context->desc.h264enc.rate_ctrl[0].min_qp = 0;
-   context->desc.h264enc.enable_vui = false;
    if (context->desc.h264enc.rate_ctrl[0].frame_rate_num == 0 ||
        context->desc.h264enc.rate_ctrl[0].frame_rate_den == 0) {
          context->desc.h264enc.rate_ctrl[0].frame_rate_num = 30;
diff --git a/src/gallium/frontends/va/picture_hevc_enc.c b/src/gallium/frontends/va/picture_hevc_enc.c
index 36d31bef6c15..ae9a74715a78 100644
--- a/src/gallium/frontends/va/picture_hevc_enc.c
+++ b/src/gallium/frontends/va/picture_hevc_enc.c
@@ -167,6 +167,12 @@ vlVaHandleVAEncSequenceParameterBufferTypeHEVC(vlVaDriver *drv, vlVaContext *con
          return VA_STATUS_ERROR_ALLOCATION_FAILED;
 
       getEncParamPresetH265(context);
+      context->desc.h265enc.rc.vbv_buffer_size = 20000000;
+      context->desc.h265enc.rc.vbv_buf_lv = 48;
+      context->desc.h265enc.rc.fill_data_enable = 1;
+      context->desc.h265enc.rc.enforce_hrd = 1;
+      context->desc.h265enc.rc.max_qp = 51;
+      context->desc.h265enc.rc.min_qp = 0;
    }
 
    context->desc.h265enc.seq.general_profile_idc = h265->general_profile_idc;
@@ -503,13 +509,6 @@ vlVaHandleVAEncMiscParameterTypeHRDHEVC(vlVaContext *context, VAEncMiscParameter
 void getEncParamPresetH265(vlVaContext *context)
 {
    //rate control
-   context->desc.h265enc.rc.vbv_buffer_size = 20000000;
-   context->desc.h265enc.rc.vbv_buf_lv = 48;
-   context->desc.h265enc.rc.fill_data_enable = 1;
-   context->desc.h265enc.rc.enforce_hrd = 1;
-   context->desc.h265enc.rc.max_qp = 51;
-   context->desc.h265enc.rc.min_qp = 0;
-
    if (context->desc.h265enc.rc.frame_rate_num == 0 ||
        context->desc.h265enc.rc.frame_rate_den == 0) {
       context->desc.h265enc.rc.frame_rate_num = 30;
-- 
GitLab

