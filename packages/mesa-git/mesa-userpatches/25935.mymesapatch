From 360f8221c231d8cab7822b9a644571cf71cb9096 Mon Sep 17 00:00:00 2001
From: Bas Nieuwenhuizen <bas@basnieuwenhuizen.nl>
Date: Wed, 18 Oct 2023 12:09:08 +0200
Subject: [PATCH 1/8] radv: Add DGC preprocessing barrier support.

---
 src/amd/vulkan/radv_cmd_buffer.c | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index 7315cf12eb9a..6d8c240814a2 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -5418,6 +5418,7 @@ radv_stage_flush(struct radv_cmd_buffer *cmd_buffer, VkPipelineStageFlags2 src_s
 
    if (src_stage_mask &
        (VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT | VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT |
+        VK_PIPELINE_STAGE_2_COMMAND_PREPROCESS_BIT_NV |
         VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR |
         VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_COPY_BIT_KHR | VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_KHR |
         VK_PIPELINE_STAGE_2_BOTTOM_OF_PIPE_BIT | VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT)) {
@@ -5492,6 +5493,9 @@ radv_src_access_flush(struct radv_cmd_buffer *cmd_buffer, VkAccessFlags2 src_fla
 
    u_foreach_bit64 (b, src_flags) {
       switch ((VkAccessFlags2)BITFIELD64_BIT(b)) {
+      case VK_ACCESS_2_COMMAND_PREPROCESS_WRITE_BIT_NV:
+         flush_bits |= RADV_CMD_FLAG_INV_L2;
+         break;
       case VK_ACCESS_2_SHADER_WRITE_BIT:
       case VK_ACCESS_2_SHADER_STORAGE_WRITE_BIT:
          /* since the STORAGE bit isn't set we know that this is a meta operation.
-- 
GitLab


From 0fc73dc90b670a001779d7fd849a59e748ddcb83 Mon Sep 17 00:00:00 2001
From: Bas Nieuwenhuizen <bas@basnieuwenhuizen.nl>
Date: Wed, 18 Oct 2023 12:04:42 +0200
Subject: [PATCH 2/8] radv: Add compute DGC preprocessing support.

This should reduce the overhead due to reduced syncs.
---
 src/amd/vulkan/radv_cmd_buffer.c              |  6 ++++-
 .../vulkan/radv_device_generated_commands.c   | 22 +++++++++++++++----
 src/amd/vulkan/radv_private.h                 |  2 ++
 3 files changed, 25 insertions(+), 5 deletions(-)

diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index 6d8c240814a2..6ccfe47011f5 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -9561,7 +9561,11 @@ radv_CmdExecuteGeneratedCommandsNV(VkCommandBuffer commandBuffer, VkBool32 isPre
       cmd_buffer->state.predicating = true;
    }
 
-   radv_prepare_dgc(cmd_buffer, pGeneratedCommandsInfo);
+   if (!layout->use_preprocess) {
+      radv_prepare_dgc(cmd_buffer, pGeneratedCommandsInfo);
+
+      cmd_buffer->state.flush_bits |= RADV_CMD_FLAG_CS_PARTIAL_FLUSH | RADV_CMD_FLAG_INV_VCACHE | RADV_CMD_FLAG_INV_L2;
+   }
 
    if (compute) {
       radv_dgc_before_dispatch(cmd_buffer);
diff --git a/src/amd/vulkan/radv_device_generated_commands.c b/src/amd/vulkan/radv_device_generated_commands.c
index 6078a9794db6..138996095ece 100644
--- a/src/amd/vulkan/radv_device_generated_commands.c
+++ b/src/amd/vulkan/radv_device_generated_commands.c
@@ -1337,6 +1337,18 @@ radv_CreateIndirectCommandsLayoutNV(VkDevice _device, const VkIndirectCommandsLa
    if (!layout->indexed)
       layout->binds_index_buffer = false;
 
+   layout->use_preprocess = pCreateInfo->flags & VK_INDIRECT_COMMANDS_LAYOUT_USAGE_EXPLICIT_PREPROCESS_BIT_NV;
+
+   /* From the Vulkan spec (1.3.269, chapter 32):
+    * "The bound descriptor sets and push constants that will be used with indirect command generation for the compute
+    * piplines must already be specified at the time of preprocessing commands with vkCmdPreprocessGeneratedCommandsNV.
+    * They must not change until the execution of indirect commands is submitted with vkCmdExecuteGeneratedCommandsNV."
+    *
+    * So we can always preprocess compute layouts.
+    */
+   if (layout->pipeline_bind_point != VK_PIPELINE_BIND_POINT_COMPUTE)
+      layout->use_preprocess = false;
+
    *pIndirectCommandsLayout = radv_indirect_command_layout_to_handle(layout);
    return VK_SUCCESS;
 }
@@ -1383,8 +1395,12 @@ VKAPI_ATTR void VKAPI_CALL
 radv_CmdPreprocessGeneratedCommandsNV(VkCommandBuffer commandBuffer,
                                       const VkGeneratedCommandsInfoNV *pGeneratedCommandsInfo)
 {
-   /* Can't do anything here as we depend on some dynamic state in some cases that we only know
-    * at draw time. */
+   VK_FROM_HANDLE(radv_cmd_buffer, cmd_buffer, commandBuffer);
+   VK_FROM_HANDLE(radv_indirect_command_layout, layout, pGeneratedCommandsInfo->indirectCommandsLayout);
+
+   if (layout->use_preprocess) {
+      radv_prepare_dgc(cmd_buffer, pGeneratedCommandsInfo);
+   }
 }
 
 /* Always need to call this directly before draw due to dependence on bound state. */
@@ -1658,8 +1674,6 @@ radv_prepare_dgc(struct radv_cmd_buffer *cmd_buffer, const VkGeneratedCommandsIn
 
    radv_buffer_finish(&token_buffer);
    radv_meta_restore(&saved_state, cmd_buffer);
-
-   cmd_buffer->state.flush_bits |= RADV_CMD_FLAG_CS_PARTIAL_FLUSH | RADV_CMD_FLAG_INV_VCACHE | RADV_CMD_FLAG_INV_L2;
 }
 
 /* VK_NV_device_generated_commands_compute */
diff --git a/src/amd/vulkan/radv_private.h b/src/amd/vulkan/radv_private.h
index 5eb9102f8c06..24a788e6c473 100644
--- a/src/amd/vulkan/radv_private.h
+++ b/src/amd/vulkan/radv_private.h
@@ -3258,6 +3258,8 @@ struct radv_indirect_command_layout {
    uint32_t ibo_type_32;
    uint32_t ibo_type_8;
 
+   bool use_preprocess;
+
    VkIndirectCommandsLayoutTokenNV tokens[0];
 };
 
-- 
GitLab


From daff031d4e46c1685254e781a9d34c6604a8a14c Mon Sep 17 00:00:00 2001
From: Bas Nieuwenhuizen <bas@basnieuwenhuizen.nl>
Date: Sat, 21 Oct 2023 01:36:48 +0200
Subject: [PATCH 3/8] radv: Add some initial graphics DGC preprocessing
 support.

Just the bits that obviously need no adjustment in the DGC
preprocessing code.
---
 src/amd/vulkan/radv_device_generated_commands.c | 16 ++++++++++++++--
 1 file changed, 14 insertions(+), 2 deletions(-)

diff --git a/src/amd/vulkan/radv_device_generated_commands.c b/src/amd/vulkan/radv_device_generated_commands.c
index 138996095ece..02ce978d5f8a 100644
--- a/src/amd/vulkan/radv_device_generated_commands.c
+++ b/src/amd/vulkan/radv_device_generated_commands.c
@@ -1346,8 +1346,20 @@ radv_CreateIndirectCommandsLayoutNV(VkDevice _device, const VkIndirectCommandsLa
     *
     * So we can always preprocess compute layouts.
     */
-   if (layout->pipeline_bind_point != VK_PIPELINE_BIND_POINT_COMPUTE)
-      layout->use_preprocess = false;
+   if (layout->pipeline_bind_point != VK_PIPELINE_BIND_POINT_COMPUTE) {
+      /* We embed the index buffer extent in indirect draw packets, but that isn't available at preprocess time. */
+      if (layout->indexed && !layout->binds_index_buffer)
+         layout->use_preprocess = false;
+
+      /* VBO binding (in particular partial VBO binding) uses some draw state which we don't generate at preprocess time
+       * yet. */
+      if (layout->bind_vbo_mask)
+         layout->use_preprocess = false;
+
+      /* In preprocess we use the non-overridden push constants from the draw state for now. */
+      if (layout->push_constant_mask)
+         layout->use_preprocess = false;
+   }
 
    *pIndirectCommandsLayout = radv_indirect_command_layout_to_handle(layout);
    return VK_SUCCESS;
-- 
GitLab


From aebe1bc051a65a1e951b144b11e955f4e08f7435 Mon Sep 17 00:00:00 2001
From: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date: Thu, 26 Oct 2023 16:36:11 +0200
Subject: [PATCH 4/8] radv: add a helper to determine if it's possible to
 preprocess DGC

Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
---
 src/amd/vulkan/radv_cmd_buffer.c              |  2 +-
 .../vulkan/radv_device_generated_commands.c   | 58 +++++++++++--------
 src/amd/vulkan/radv_private.h                 |  5 +-
 3 files changed, 37 insertions(+), 28 deletions(-)

diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index 6ccfe47011f5..3af7726690ae 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -9561,7 +9561,7 @@ radv_CmdExecuteGeneratedCommandsNV(VkCommandBuffer commandBuffer, VkBool32 isPre
       cmd_buffer->state.predicating = true;
    }
 
-   if (!layout->use_preprocess) {
+   if (!radv_dgc_can_preprocess(layout)) {
       radv_prepare_dgc(cmd_buffer, pGeneratedCommandsInfo);
 
       cmd_buffer->state.flush_bits |= RADV_CMD_FLAG_CS_PARTIAL_FLUSH | RADV_CMD_FLAG_INV_VCACHE | RADV_CMD_FLAG_INV_L2;
diff --git a/src/amd/vulkan/radv_device_generated_commands.c b/src/amd/vulkan/radv_device_generated_commands.c
index 02ce978d5f8a..f499056f7a28 100644
--- a/src/amd/vulkan/radv_device_generated_commands.c
+++ b/src/amd/vulkan/radv_device_generated_commands.c
@@ -1286,6 +1286,7 @@ radv_CreateIndirectCommandsLayoutNV(VkDevice _device, const VkIndirectCommandsLa
 
    vk_object_base_init(&device->vk, &layout->base, VK_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NV);
 
+   layout->flags = pCreateInfo->flags;
    layout->pipeline_bind_point = pCreateInfo->pipelineBindPoint;
    layout->input_stride = pCreateInfo->pStreamStrides[0];
    layout->token_count = pCreateInfo->tokenCount;
@@ -1337,30 +1338,6 @@ radv_CreateIndirectCommandsLayoutNV(VkDevice _device, const VkIndirectCommandsLa
    if (!layout->indexed)
       layout->binds_index_buffer = false;
 
-   layout->use_preprocess = pCreateInfo->flags & VK_INDIRECT_COMMANDS_LAYOUT_USAGE_EXPLICIT_PREPROCESS_BIT_NV;
-
-   /* From the Vulkan spec (1.3.269, chapter 32):
-    * "The bound descriptor sets and push constants that will be used with indirect command generation for the compute
-    * piplines must already be specified at the time of preprocessing commands with vkCmdPreprocessGeneratedCommandsNV.
-    * They must not change until the execution of indirect commands is submitted with vkCmdExecuteGeneratedCommandsNV."
-    *
-    * So we can always preprocess compute layouts.
-    */
-   if (layout->pipeline_bind_point != VK_PIPELINE_BIND_POINT_COMPUTE) {
-      /* We embed the index buffer extent in indirect draw packets, but that isn't available at preprocess time. */
-      if (layout->indexed && !layout->binds_index_buffer)
-         layout->use_preprocess = false;
-
-      /* VBO binding (in particular partial VBO binding) uses some draw state which we don't generate at preprocess time
-       * yet. */
-      if (layout->bind_vbo_mask)
-         layout->use_preprocess = false;
-
-      /* In preprocess we use the non-overridden push constants from the draw state for now. */
-      if (layout->push_constant_mask)
-         layout->use_preprocess = false;
-   }
-
    *pIndirectCommandsLayout = radv_indirect_command_layout_to_handle(layout);
    return VK_SUCCESS;
 }
@@ -1403,6 +1380,37 @@ radv_GetGeneratedCommandsMemoryRequirementsNV(VkDevice _device,
       align(cmd_buf_size + upload_buf_size, pMemoryRequirements->memoryRequirements.alignment);
 }
 
+bool
+radv_dgc_can_preprocess(const struct radv_indirect_command_layout *layout)
+{
+   if (!(layout->flags & VK_INDIRECT_COMMANDS_LAYOUT_USAGE_EXPLICIT_PREPROCESS_BIT_NV))
+      return false;
+
+   /* From the Vulkan spec (1.3.269, chapter 32):
+    * "The bound descriptor sets and push constants that will be used with indirect command generation for the compute
+    * piplines must already be specified at the time of preprocessing commands with vkCmdPreprocessGeneratedCommandsNV.
+    * They must not change until the execution of indirect commands is submitted with vkCmdExecuteGeneratedCommandsNV."
+    *
+    * So we can always preprocess compute layouts.
+    */
+   if (layout->pipeline_bind_point != VK_PIPELINE_BIND_POINT_COMPUTE) {
+      /* We embed the index buffer extent in indirect draw packets, but that isn't available at preprocess time. */
+      if (layout->indexed && !layout->binds_index_buffer)
+         return false;
+
+      /* VBO binding (in particular partial VBO binding) uses some draw state which we don't generate at preprocess time
+       * yet. */
+      if (layout->bind_vbo_mask)
+         return false;
+
+      /* In preprocess we use the non-overridden push constants from the draw state for now. */
+      if (layout->push_constant_mask)
+         return false;
+   }
+
+   return true;
+}
+
 VKAPI_ATTR void VKAPI_CALL
 radv_CmdPreprocessGeneratedCommandsNV(VkCommandBuffer commandBuffer,
                                       const VkGeneratedCommandsInfoNV *pGeneratedCommandsInfo)
@@ -1410,7 +1418,7 @@ radv_CmdPreprocessGeneratedCommandsNV(VkCommandBuffer commandBuffer,
    VK_FROM_HANDLE(radv_cmd_buffer, cmd_buffer, commandBuffer);
    VK_FROM_HANDLE(radv_indirect_command_layout, layout, pGeneratedCommandsInfo->indirectCommandsLayout);
 
-   if (layout->use_preprocess) {
+   if (radv_dgc_can_preprocess(layout)) {
       radv_prepare_dgc(cmd_buffer, pGeneratedCommandsInfo);
    }
 }
diff --git a/src/amd/vulkan/radv_private.h b/src/amd/vulkan/radv_private.h
index 24a788e6c473..6b6fa4e40714 100644
--- a/src/amd/vulkan/radv_private.h
+++ b/src/amd/vulkan/radv_private.h
@@ -3234,6 +3234,7 @@ void radv_sqtt_emit_relocated_shaders(struct radv_cmd_buffer *cmd_buffer, struct
 struct radv_indirect_command_layout {
    struct vk_object_base base;
 
+   VkIndirectCommandsLayoutUsageFlagsNV flags;
    VkPipelineBindPoint pipeline_bind_point;
 
    uint32_t input_stride;
@@ -3258,8 +3259,6 @@ struct radv_indirect_command_layout {
    uint32_t ibo_type_32;
    uint32_t ibo_type_8;
 
-   bool use_preprocess;
-
    VkIndirectCommandsLayoutTokenNV tokens[0];
 };
 
@@ -3267,6 +3266,8 @@ uint32_t radv_get_indirect_cmdbuf_size(const VkGeneratedCommandsInfoNV *cmd_info
 
 void radv_prepare_dgc(struct radv_cmd_buffer *cmd_buffer, const VkGeneratedCommandsInfoNV *pGeneratedCommandsInfo);
 
+bool radv_dgc_can_preprocess(const struct radv_indirect_command_layout *layout);
+
 static inline uint32_t
 si_conv_prim_to_gs_out(uint32_t topology, bool is_ngg)
 {
-- 
GitLab


From 1f59830076f92cfea831c783e5bad58eba0a7b96 Mon Sep 17 00:00:00 2001
From: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date: Fri, 27 Oct 2023 10:12:27 +0200
Subject: [PATCH 5/8] radv: pass the raw inline push constant SGPR to the DGC
 shader

This will be used to emit individual packets for preprocess graphics
support.

Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
---
 .../vulkan/radv_device_generated_commands.c   | 29 ++++++++++---------
 1 file changed, 15 insertions(+), 14 deletions(-)

diff --git a/src/amd/vulkan/radv_device_generated_commands.c b/src/amd/vulkan/radv_device_generated_commands.c
index f499056f7a28..4917b68c1ea5 100644
--- a/src/amd/vulkan/radv_device_generated_commands.c
+++ b/src/amd/vulkan/radv_device_generated_commands.c
@@ -725,9 +725,9 @@ dgc_emit_push_constant(nir_builder *b, struct dgc_cmdbuf *cs, nir_def *stream_bu
 
    nir_def *param_buf = radv_meta_load_descriptor(b, 0, DGC_DESC_PARAMS);
    nir_def *param_offset = nir_imul_imm(b, vbo_cnt, 24);
-   nir_def *param_offset_offset = nir_iadd_imm(b, param_offset, MESA_VULKAN_SHADER_STAGES * 12);
+   nir_def *param_offset_offset = nir_iadd_imm(b, param_offset, MESA_VULKAN_SHADER_STAGES * 16);
    nir_def *param_const_offset =
-      nir_iadd_imm(b, param_offset, MAX_PUSH_CONSTANTS_SIZE + MESA_VULKAN_SHADER_STAGES * 12);
+      nir_iadd_imm(b, param_offset, MAX_PUSH_CONSTANTS_SIZE + MESA_VULKAN_SHADER_STAGES * 16);
    nir_push_loop(b);
    {
       nir_def *cur_idx = nir_load_var(b, idx);
@@ -779,10 +779,10 @@ dgc_emit_push_constant(nir_builder *b, struct dgc_cmdbuf *cs, nir_def *stream_bu
       nir_pop_if(b, NULL);
 
       nir_def *reg_info =
-         nir_load_ssbo(b, 3, 32, param_buf, nir_iadd(b, param_offset, nir_imul_imm(b, cur_shader_idx, 12)));
-      nir_def *upload_sgpr = nir_ubfe_imm(b, nir_channel(b, reg_info, 0), 0, 16);
-      nir_def *inline_sgpr = nir_ubfe_imm(b, nir_channel(b, reg_info, 0), 16, 16);
+         nir_load_ssbo(b, 4, 32, param_buf, nir_iadd(b, param_offset, nir_imul_imm(b, cur_shader_idx, 16)));
+      nir_def *upload_sgpr = nir_channel(b, reg_info, 0);
       nir_def *inline_mask = nir_pack_64_2x32(b, nir_channels(b, reg_info, 0x6));
+      nir_def *inline_sgpr = nir_channel(b, reg_info, 3);
 
       nir_push_if(b, nir_ine_imm(b, upload_sgpr, 0));
       {
@@ -798,7 +798,8 @@ dgc_emit_push_constant(nir_builder *b, struct dgc_cmdbuf *cs, nir_def *stream_bu
          nir_def *inline_len = nir_bit_count(b, inline_mask);
          nir_store_var(b, idx, nir_imm_int(b, 0), 0x1);
 
-         nir_def *pkt[2] = {nir_pkt3(b, PKT3_SET_SH_REG, inline_len), inline_sgpr};
+         nir_def *pkt[2] = {nir_pkt3(b, PKT3_SET_SH_REG, inline_len),
+                            nir_ushr_imm(b, nir_isub(b, inline_sgpr, nir_imm_int(b, SI_SH_REG_OFFSET)), 2)};
 
          dgc_emit(b, cs, nir_vec(b, pkt, 2));
 
@@ -1558,7 +1559,7 @@ radv_prepare_dgc(struct radv_cmd_buffer *cmd_buffer, const VkGeneratedCommandsIn
                                     .use_preamble = radv_dgc_use_preamble(pGeneratedCommandsInfo)};
 
    upload_size = pipeline->push_constant_size + 16 * pipeline->dynamic_offset_count +
-                 sizeof(layout->push_constant_offsets) + ARRAY_SIZE(pipeline->shaders) * 12;
+                 sizeof(layout->push_constant_offsets) + ARRAY_SIZE(pipeline->shaders) * 16;
    if (!layout->push_constant_mask)
       upload_size = 0;
 
@@ -1572,7 +1573,7 @@ radv_prepare_dgc(struct radv_cmd_buffer *cmd_buffer, const VkGeneratedCommandsIn
 
    if (layout->push_constant_mask) {
       uint32_t *desc = upload_data;
-      upload_data = (char *)upload_data + ARRAY_SIZE(pipeline->shaders) * 12;
+      upload_data = (char *)upload_data + ARRAY_SIZE(pipeline->shaders) * 16;
 
       unsigned idx = 0;
       for (unsigned i = 0; i < ARRAY_SIZE(pipeline->shaders); ++i) {
@@ -1596,13 +1597,13 @@ radv_prepare_dgc(struct radv_cmd_buffer *cmd_buffer, const VkGeneratedCommandsIn
             }
 
             if (locs->shader_data[AC_UD_INLINE_PUSH_CONSTANTS].sgpr_idx >= 0) {
-               inline_sgpr = (shader->info.user_data_0 + 4 * locs->shader_data[AC_UD_INLINE_PUSH_CONSTANTS].sgpr_idx -
-                              SI_SH_REG_OFFSET) >>
-                             2;
-               desc[idx * 3 + 1] = pipeline->shaders[i]->info.inline_push_constant_mask;
-               desc[idx * 3 + 2] = pipeline->shaders[i]->info.inline_push_constant_mask >> 32;
+               inline_sgpr = shader->info.user_data_0 + 4 * locs->shader_data[AC_UD_INLINE_PUSH_CONSTANTS].sgpr_idx;
+
+               desc[idx * 4 + 1] = pipeline->shaders[i]->info.inline_push_constant_mask;
+               desc[idx * 4 + 2] = pipeline->shaders[i]->info.inline_push_constant_mask >> 32;
+               desc[idx * 4 + 3] = inline_sgpr;
             }
-            desc[idx * 3] = upload_sgpr | (inline_sgpr << 16);
+            desc[idx * 4] = upload_sgpr;
             ++idx;
          }
       }
-- 
GitLab


From 5d6f5f81a1074010e7af8e9841c5e21bf7e36a01 Mon Sep 17 00:00:00 2001
From: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date: Fri, 27 Oct 2023 10:15:33 +0200
Subject: [PATCH 6/8] radv: emit individual SET_SH_REG for inlined push
 constants with DGC

This should allow to preprocess if everything is inlined.

Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
---
 .../vulkan/radv_device_generated_commands.c   | 19 +++++++++++++------
 1 file changed, 13 insertions(+), 6 deletions(-)

diff --git a/src/amd/vulkan/radv_device_generated_commands.c b/src/amd/vulkan/radv_device_generated_commands.c
index 4917b68c1ea5..a9dc0fbdffad 100644
--- a/src/amd/vulkan/radv_device_generated_commands.c
+++ b/src/amd/vulkan/radv_device_generated_commands.c
@@ -118,7 +118,7 @@ radv_get_sequence_size(const struct radv_indirect_command_layout *layout, struct
          }
          if (locs->shader_data[AC_UD_INLINE_PUSH_CONSTANTS].sgpr_idx >= 0)
             /* One PKT3_SET_SH_REG writing all inline push constants. */
-            *cmd_size += (2 + locs->shader_data[AC_UD_INLINE_PUSH_CONSTANTS].num_sgprs) * 4;
+            *cmd_size += (3 * locs->shader_data[AC_UD_INLINE_PUSH_CONSTANTS].num_sgprs) * 4;
       }
       if (need_copy)
          *upload_size += align(pipeline->push_constant_size + 16 * pipeline->dynamic_offset_count, 16);
@@ -798,10 +798,8 @@ dgc_emit_push_constant(nir_builder *b, struct dgc_cmdbuf *cs, nir_def *stream_bu
          nir_def *inline_len = nir_bit_count(b, inline_mask);
          nir_store_var(b, idx, nir_imm_int(b, 0), 0x1);
 
-         nir_def *pkt[2] = {nir_pkt3(b, PKT3_SET_SH_REG, inline_len),
-                            nir_ushr_imm(b, nir_isub(b, inline_sgpr, nir_imm_int(b, SI_SH_REG_OFFSET)), 2)};
-
-         dgc_emit(b, cs, nir_vec(b, pkt, 2));
+         nir_variable *pc_idx = nir_variable_create(b->shader, nir_var_shader_temp, glsl_uint_type(), "pc_idx");
+         nir_store_var(b, pc_idx, nir_imm_int(b, 0), 0x1);
 
          nir_push_loop(b);
          {
@@ -842,9 +840,18 @@ dgc_emit_push_constant(nir_builder *b, struct dgc_cmdbuf *cs, nir_def *stream_bu
             }
             nir_pop_if(b, NULL);
 
-            dgc_emit(b, cs, nir_load_var(b, data));
+            nir_def *pkt[3] = {
+               nir_imm_int(b, PKT3(PKT3_SET_SH_REG, 1, 0)),
+               nir_ushr_imm(b,
+                            nir_isub(b, nir_iadd(b, inline_sgpr, nir_imul_imm(b, nir_load_var(b, pc_idx), 4)),
+                                     nir_imm_int(b, SI_SH_REG_OFFSET)),
+                            2),
+               nir_load_var(b, data)};
+
+            dgc_emit(b, cs, nir_vec(b, pkt, 3));
 
             nir_store_var(b, idx, nir_iadd_imm(b, cur_idx, 1), 0x1);
+            nir_store_var(b, pc_idx, nir_iadd_imm(b, nir_load_var(b, pc_idx), 1), 0x1);
          }
          nir_pop_loop(b, NULL);
       }
-- 
GitLab


From b203b36da19bd718337afe15c4850580f910ad1f Mon Sep 17 00:00:00 2001
From: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date: Fri, 27 Oct 2023 10:39:28 +0200
Subject: [PATCH 7/8] radv: optimize emitting inlined push constants with DGC

With DGC, push constants can be set from the cmdbuf (CmdPushConstants())
or from the indirect layout. Instead of always emitting inlined push
constants from the DGC shader, just update the ones that come from the
indirect layout and rely on cmdbuf updates for the other ones.

With that, it should be possible to preprocess push constants with
graphics when all can be inlined in shaders.

Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
---
 .../vulkan/radv_device_generated_commands.c   | 30 +++++++------------
 1 file changed, 11 insertions(+), 19 deletions(-)

diff --git a/src/amd/vulkan/radv_device_generated_commands.c b/src/amd/vulkan/radv_device_generated_commands.c
index a9dc0fbdffad..5881fb995207 100644
--- a/src/amd/vulkan/radv_device_generated_commands.c
+++ b/src/amd/vulkan/radv_device_generated_commands.c
@@ -118,7 +118,7 @@ radv_get_sequence_size(const struct radv_indirect_command_layout *layout, struct
          }
          if (locs->shader_data[AC_UD_INLINE_PUSH_CONSTANTS].sgpr_idx >= 0)
             /* One PKT3_SET_SH_REG writing all inline push constants. */
-            *cmd_size += (3 * locs->shader_data[AC_UD_INLINE_PUSH_CONSTANTS].num_sgprs) * 4;
+            *cmd_size += (3 * util_bitcount64(layout->push_constant_mask)) * 4;
       }
       if (need_copy)
          *upload_size += align(pipeline->push_constant_size + 16 * pipeline->dynamic_offset_count, 16);
@@ -795,7 +795,6 @@ dgc_emit_push_constant(nir_builder *b, struct dgc_cmdbuf *cs, nir_def *stream_bu
 
       nir_push_if(b, nir_ine_imm(b, inline_sgpr, 0));
       {
-         nir_def *inline_len = nir_bit_count(b, inline_mask);
          nir_store_var(b, idx, nir_imm_int(b, 0), 0x1);
 
          nir_variable *pc_idx = nir_variable_create(b->shader, nir_var_shader_temp, glsl_uint_type(), "pc_idx");
@@ -830,25 +829,18 @@ dgc_emit_push_constant(nir_builder *b, struct dgc_cmdbuf *cs, nir_def *stream_bu
                   nir_load_ssbo(b, 1, 32, param_buf, nir_iadd(b, param_offset_offset, nir_ishl_imm(b, cur_idx, 2)));
                nir_def *new_data = nir_load_ssbo(b, 1, 32, stream_buf, nir_iadd(b, stream_base, stream_offset));
                nir_store_var(b, data, new_data, 0x1);
-            }
-            nir_push_else(b, NULL);
-            {
-               nir_store_var(
-                  b, data,
-                  nir_load_ssbo(b, 1, 32, param_buf, nir_iadd(b, param_const_offset, nir_ishl_imm(b, cur_idx, 2))),
-                  0x1);
-            }
-            nir_pop_if(b, NULL);
 
-            nir_def *pkt[3] = {
-               nir_imm_int(b, PKT3(PKT3_SET_SH_REG, 1, 0)),
-               nir_ushr_imm(b,
-                            nir_isub(b, nir_iadd(b, inline_sgpr, nir_imul_imm(b, nir_load_var(b, pc_idx), 4)),
-                                     nir_imm_int(b, SI_SH_REG_OFFSET)),
-                            2),
-               nir_load_var(b, data)};
+               nir_def *pkt[3] = {
+                  nir_imm_int(b, PKT3(PKT3_SET_SH_REG, 1, 0)),
+                  nir_ushr_imm(b,
+                               nir_isub(b, nir_iadd(b, inline_sgpr, nir_imul_imm(b, nir_load_var(b, pc_idx), 4)),
+                                        nir_imm_int(b, SI_SH_REG_OFFSET)),
+                               2),
+                  nir_load_var(b, data)};
 
-            dgc_emit(b, cs, nir_vec(b, pkt, 3));
+               dgc_emit(b, cs, nir_vec(b, pkt, 3));
+            }
+            nir_pop_if(b, NULL);
 
             nir_store_var(b, idx, nir_iadd_imm(b, cur_idx, 1), 0x1);
             nir_store_var(b, pc_idx, nir_iadd_imm(b, nir_load_var(b, pc_idx), 1), 0x1);
-- 
GitLab


From 23e9e458282861061410e7d63fccd6958c4fd9fe Mon Sep 17 00:00:00 2001
From: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date: Fri, 27 Oct 2023 10:54:14 +0200
Subject: [PATCH 8/8] radv: enable DGC preprocessing when all push constants
 are inlined

It's not possible when they aren't all inlined because they need to be
copied to the upload BO and the DGC shader also copies the ones that
come from the indirect layout.

Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
---
 src/amd/vulkan/radv_cmd_buffer.c              |  2 +-
 .../vulkan/radv_device_generated_commands.c   | 28 ++++++++++++++++---
 src/amd/vulkan/radv_private.h                 |  2 +-
 3 files changed, 26 insertions(+), 6 deletions(-)

diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index 3af7726690ae..731d52ca32eb 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -9561,7 +9561,7 @@ radv_CmdExecuteGeneratedCommandsNV(VkCommandBuffer commandBuffer, VkBool32 isPre
       cmd_buffer->state.predicating = true;
    }
 
-   if (!radv_dgc_can_preprocess(layout)) {
+   if (!radv_dgc_can_preprocess(layout, pipeline)) {
       radv_prepare_dgc(cmd_buffer, pGeneratedCommandsInfo);
 
       cmd_buffer->state.flush_bits |= RADV_CMD_FLAG_CS_PARTIAL_FLUSH | RADV_CMD_FLAG_INV_VCACHE | RADV_CMD_FLAG_INV_L2;
diff --git a/src/amd/vulkan/radv_device_generated_commands.c b/src/amd/vulkan/radv_device_generated_commands.c
index 5881fb995207..8d1abbda28b8 100644
--- a/src/amd/vulkan/radv_device_generated_commands.c
+++ b/src/amd/vulkan/radv_device_generated_commands.c
@@ -1380,8 +1380,25 @@ radv_GetGeneratedCommandsMemoryRequirementsNV(VkDevice _device,
       align(cmd_buf_size + upload_buf_size, pMemoryRequirements->memoryRequirements.alignment);
 }
 
+static bool
+radv_dgc_need_push_constants_copy(const struct radv_pipeline *pipeline)
+{
+   for (unsigned i = 0; i < ARRAY_SIZE(pipeline->shaders); ++i) {
+      const struct radv_shader *shader = pipeline->shaders[i];
+
+      if (!shader)
+         continue;
+
+      const struct radv_userdata_locations *locs = &shader->info.user_sgprs_locs;
+      if (locs->shader_data[AC_UD_PUSH_CONSTANTS].sgpr_idx >= 0)
+         return true;
+   }
+
+   return false;
+}
+
 bool
-radv_dgc_can_preprocess(const struct radv_indirect_command_layout *layout)
+radv_dgc_can_preprocess(const struct radv_indirect_command_layout *layout, struct radv_pipeline *pipeline)
 {
    if (!(layout->flags & VK_INDIRECT_COMMANDS_LAYOUT_USAGE_EXPLICIT_PREPROCESS_BIT_NV))
       return false;
@@ -1403,8 +1420,10 @@ radv_dgc_can_preprocess(const struct radv_indirect_command_layout *layout)
       if (layout->bind_vbo_mask)
          return false;
 
-      /* In preprocess we use the non-overridden push constants from the draw state for now. */
-      if (layout->push_constant_mask)
+      /* Do not preprocess when all push constants can't be inlined because they need to be copied
+       * to the upload BO.
+       */
+      if (layout->push_constant_mask && radv_dgc_need_push_constants_copy(pipeline))
          return false;
    }
 
@@ -1417,8 +1436,9 @@ radv_CmdPreprocessGeneratedCommandsNV(VkCommandBuffer commandBuffer,
 {
    VK_FROM_HANDLE(radv_cmd_buffer, cmd_buffer, commandBuffer);
    VK_FROM_HANDLE(radv_indirect_command_layout, layout, pGeneratedCommandsInfo->indirectCommandsLayout);
+   VK_FROM_HANDLE(radv_pipeline, pipeline, pGeneratedCommandsInfo->pipeline);
 
-   if (radv_dgc_can_preprocess(layout)) {
+   if (radv_dgc_can_preprocess(layout, pipeline)) {
       radv_prepare_dgc(cmd_buffer, pGeneratedCommandsInfo);
    }
 }
diff --git a/src/amd/vulkan/radv_private.h b/src/amd/vulkan/radv_private.h
index 6b6fa4e40714..0c1032799201 100644
--- a/src/amd/vulkan/radv_private.h
+++ b/src/amd/vulkan/radv_private.h
@@ -3266,7 +3266,7 @@ uint32_t radv_get_indirect_cmdbuf_size(const VkGeneratedCommandsInfoNV *cmd_info
 
 void radv_prepare_dgc(struct radv_cmd_buffer *cmd_buffer, const VkGeneratedCommandsInfoNV *pGeneratedCommandsInfo);
 
-bool radv_dgc_can_preprocess(const struct radv_indirect_command_layout *layout);
+bool radv_dgc_can_preprocess(const struct radv_indirect_command_layout *layout, struct radv_pipeline *pipeline);
 
 static inline uint32_t
 si_conv_prim_to_gs_out(uint32_t topology, bool is_ngg)
-- 
GitLab

