From 186e8b238c9bade0705ac4948cdb98b5f2cc94b5 Mon Sep 17 00:00:00 2001
From: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date: Thu, 26 Oct 2023 16:36:11 +0200
Subject: [PATCH 1/4] radv: add a helper to determine if it's possible to
 preprocess DGC

Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
---
 src/amd/vulkan/radv_cmd_buffer.c              |  2 +-
 .../vulkan/radv_device_generated_commands.c   | 58 +++++++++++--------
 src/amd/vulkan/radv_private.h                 |  5 +-
 3 files changed, 37 insertions(+), 28 deletions(-)

diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index 709de1256f686..d8707aac557b9 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -9550,7 +9550,7 @@ radv_CmdExecuteGeneratedCommandsNV(VkCommandBuffer commandBuffer, VkBool32 isPre
       cmd_buffer->state.predicating = true;
    }
 
-   if (!layout->use_preprocess) {
+   if (!radv_dgc_can_preprocess(layout)) {
       radv_prepare_dgc(cmd_buffer, pGeneratedCommandsInfo);
 
       cmd_buffer->state.flush_bits |= RADV_CMD_FLAG_CS_PARTIAL_FLUSH | RADV_CMD_FLAG_INV_VCACHE | RADV_CMD_FLAG_INV_L2;
diff --git a/src/amd/vulkan/radv_device_generated_commands.c b/src/amd/vulkan/radv_device_generated_commands.c
index bb8748601ba87..7405dcd74a54a 100644
--- a/src/amd/vulkan/radv_device_generated_commands.c
+++ b/src/amd/vulkan/radv_device_generated_commands.c
@@ -1286,6 +1286,7 @@ radv_CreateIndirectCommandsLayoutNV(VkDevice _device, const VkIndirectCommandsLa
 
    vk_object_base_init(&device->vk, &layout->base, VK_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NV);
 
+   layout->flags = pCreateInfo->flags;
    layout->pipeline_bind_point = pCreateInfo->pipelineBindPoint;
    layout->input_stride = pCreateInfo->pStreamStrides[0];
    layout->token_count = pCreateInfo->tokenCount;
@@ -1337,30 +1338,6 @@ radv_CreateIndirectCommandsLayoutNV(VkDevice _device, const VkIndirectCommandsLa
    if (!layout->indexed)
       layout->binds_index_buffer = false;
 
-   layout->use_preprocess = pCreateInfo->flags & VK_INDIRECT_COMMANDS_LAYOUT_USAGE_EXPLICIT_PREPROCESS_BIT_NV;
-
-   /* From the Vulkan spec (1.3.269, chapter 32):
-    * "The bound descriptor sets and push constants that will be used with indirect command generation for the compute
-    * piplines must already be specified at the time of preprocessing commands with vkCmdPreprocessGeneratedCommandsNV.
-    * They must not change until the execution of indirect commands is submitted with vkCmdExecuteGeneratedCommandsNV."
-    *
-    * So we can always preprocess compute layouts.
-    */
-   if (layout->pipeline_bind_point != VK_PIPELINE_BIND_POINT_COMPUTE) {
-      /* We embed the index buffer extent in indirect draw packets, but that isn't available at preprocess time. */
-      if (layout->indexed && !layout->binds_index_buffer)
-         layout->use_preprocess = false;
-
-      /* VBO binding (in particular partial VBO binding) uses some draw state which we don't generate at preprocess time
-       * yet. */
-      if (layout->bind_vbo_mask)
-         layout->use_preprocess = false;
-
-      /* In preprocess we use the non-overridden push constants from the draw state for now. */
-      if (layout->push_constant_mask)
-         layout->use_preprocess = false;
-   }
-
    *pIndirectCommandsLayout = radv_indirect_command_layout_to_handle(layout);
    return VK_SUCCESS;
 }
@@ -1415,6 +1392,37 @@ radv_use_dgc_predication(struct radv_cmd_buffer *cmd_buffer, const VkGeneratedCo
    return cmd_buffer->qf == RADV_QUEUE_GENERAL && seq_count_buffer && !cmd_buffer->state.predicating;
 }
 
+bool
+radv_dgc_can_preprocess(const struct radv_indirect_command_layout *layout)
+{
+   if (!(layout->flags & VK_INDIRECT_COMMANDS_LAYOUT_USAGE_EXPLICIT_PREPROCESS_BIT_NV))
+      return false;
+
+   /* From the Vulkan spec (1.3.269, chapter 32):
+    * "The bound descriptor sets and push constants that will be used with indirect command generation for the compute
+    * piplines must already be specified at the time of preprocessing commands with vkCmdPreprocessGeneratedCommandsNV.
+    * They must not change until the execution of indirect commands is submitted with vkCmdExecuteGeneratedCommandsNV."
+    *
+    * So we can always preprocess compute layouts.
+    */
+   if (layout->pipeline_bind_point != VK_PIPELINE_BIND_POINT_COMPUTE) {
+      /* We embed the index buffer extent in indirect draw packets, but that isn't available at preprocess time. */
+      if (layout->indexed && !layout->binds_index_buffer)
+         return false;
+
+      /* VBO binding (in particular partial VBO binding) uses some draw state which we don't generate at preprocess time
+       * yet. */
+      if (layout->bind_vbo_mask)
+         return false;
+
+      /* In preprocess we use the non-overridden push constants from the draw state for now. */
+      if (layout->push_constant_mask)
+         return false;
+   }
+
+   return true;
+}
+
 VKAPI_ATTR void VKAPI_CALL
 radv_CmdPreprocessGeneratedCommandsNV(VkCommandBuffer commandBuffer,
                                       const VkGeneratedCommandsInfoNV *pGeneratedCommandsInfo)
@@ -1422,7 +1430,7 @@ radv_CmdPreprocessGeneratedCommandsNV(VkCommandBuffer commandBuffer,
    VK_FROM_HANDLE(radv_cmd_buffer, cmd_buffer, commandBuffer);
    VK_FROM_HANDLE(radv_indirect_command_layout, layout, pGeneratedCommandsInfo->indirectCommandsLayout);
 
-   if (!layout->use_preprocess)
+   if (!radv_dgc_can_preprocess(layout))
       return;
 
    const bool use_predication = radv_use_dgc_predication(cmd_buffer, pGeneratedCommandsInfo);
diff --git a/src/amd/vulkan/radv_private.h b/src/amd/vulkan/radv_private.h
index 69d601c45b488..db6cea9daea02 100644
--- a/src/amd/vulkan/radv_private.h
+++ b/src/amd/vulkan/radv_private.h
@@ -3216,6 +3216,7 @@ void radv_sqtt_emit_relocated_shaders(struct radv_cmd_buffer *cmd_buffer, struct
 struct radv_indirect_command_layout {
    struct vk_object_base base;
 
+   VkIndirectCommandsLayoutUsageFlagsNV flags;
    VkPipelineBindPoint pipeline_bind_point;
 
    uint32_t input_stride;
@@ -3240,8 +3241,6 @@ struct radv_indirect_command_layout {
    uint32_t ibo_type_32;
    uint32_t ibo_type_8;
 
-   bool use_preprocess;
-
    VkIndirectCommandsLayoutTokenNV tokens[0];
 };
 
@@ -3251,6 +3250,8 @@ bool radv_use_dgc_predication(struct radv_cmd_buffer *cmd_buffer,
                               const VkGeneratedCommandsInfoNV *pGeneratedCommandsInfo);
 void radv_prepare_dgc(struct radv_cmd_buffer *cmd_buffer, const VkGeneratedCommandsInfoNV *pGeneratedCommandsInfo);
 
+bool radv_dgc_can_preprocess(const struct radv_indirect_command_layout *layout);
+
 static inline uint32_t
 si_conv_prim_to_gs_out(uint32_t topology, bool is_ngg)
 {
-- 
GitLab


From ba6bcea2e4939ed8a6094ea28bd9b88131280929 Mon Sep 17 00:00:00 2001
From: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date: Fri, 27 Oct 2023 10:15:33 +0200
Subject: [PATCH 2/4] radv: emit individual SET_SH_REG for inlined push
 constants with DGC

This should allow to preprocess if everything is inlined.

Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
---
 src/amd/vulkan/radv_device_generated_commands.c | 14 ++++++++------
 1 file changed, 8 insertions(+), 6 deletions(-)

diff --git a/src/amd/vulkan/radv_device_generated_commands.c b/src/amd/vulkan/radv_device_generated_commands.c
index 7405dcd74a54a..17af95bfad034 100644
--- a/src/amd/vulkan/radv_device_generated_commands.c
+++ b/src/amd/vulkan/radv_device_generated_commands.c
@@ -118,7 +118,7 @@ radv_get_sequence_size(const struct radv_indirect_command_layout *layout, struct
          }
          if (locs->shader_data[AC_UD_INLINE_PUSH_CONSTANTS].sgpr_idx >= 0)
             /* One PKT3_SET_SH_REG writing all inline push constants. */
-            *cmd_size += (2 + locs->shader_data[AC_UD_INLINE_PUSH_CONSTANTS].num_sgprs) * 4;
+            *cmd_size += (3 * locs->shader_data[AC_UD_INLINE_PUSH_CONSTANTS].num_sgprs) * 4;
       }
       if (need_copy)
          *upload_size += align(pipeline->push_constant_size + 16 * pipeline->dynamic_offset_count, 16);
@@ -795,12 +795,10 @@ dgc_emit_push_constant(nir_builder *b, struct dgc_cmdbuf *cs, nir_def *stream_bu
 
       nir_push_if(b, nir_ine_imm(b, inline_sgpr, 0));
       {
-         nir_def *inline_len = nir_bit_count(b, inline_mask);
          nir_store_var(b, idx, nir_imm_int(b, 0), 0x1);
 
-         nir_def *pkt[2] = {nir_pkt3(b, PKT3_SET_SH_REG, inline_len), inline_sgpr};
-
-         dgc_emit(b, cs, nir_vec(b, pkt, 2));
+         nir_variable *pc_idx = nir_variable_create(b->shader, nir_var_shader_temp, glsl_uint_type(), "pc_idx");
+         nir_store_var(b, pc_idx, nir_imm_int(b, 0), 0x1);
 
          nir_push_loop(b);
          {
@@ -841,9 +839,13 @@ dgc_emit_push_constant(nir_builder *b, struct dgc_cmdbuf *cs, nir_def *stream_bu
             }
             nir_pop_if(b, NULL);
 
-            dgc_emit(b, cs, nir_load_var(b, data));
+            nir_def *pkt[3] = {nir_pkt3(b, PKT3_SET_SH_REG, nir_imm_int(b, 1)),
+                               nir_iadd(b, inline_sgpr, nir_load_var(b, pc_idx)), nir_load_var(b, data)};
+
+            dgc_emit(b, cs, nir_vec(b, pkt, 3));
 
             nir_store_var(b, idx, nir_iadd_imm(b, cur_idx, 1), 0x1);
+            nir_store_var(b, pc_idx, nir_iadd_imm(b, nir_load_var(b, pc_idx), 1), 0x1);
          }
          nir_pop_loop(b, NULL);
       }
-- 
GitLab


From b21fcf28489e259efd71f81198e3e2ed5c5a7a9d Mon Sep 17 00:00:00 2001
From: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date: Fri, 27 Oct 2023 10:39:28 +0200
Subject: [PATCH 3/4] radv: optimize emitting inlined push constants with DGC

With DGC, push constants can be set from the cmdbuf (CmdPushConstants())
or from the indirect layout. Instead of always emitting inlined push
constants from the DGC shader, just update the ones that come from the
indirect layout and rely on cmdbuf updates for the other ones.

With that, it should be possible to preprocess push constants with
graphics when all can be inlined in shaders.

Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
---
 .../vulkan/radv_device_generated_commands.c   | 19 ++++++-------------
 1 file changed, 6 insertions(+), 13 deletions(-)

diff --git a/src/amd/vulkan/radv_device_generated_commands.c b/src/amd/vulkan/radv_device_generated_commands.c
index 17af95bfad034..a5b1f54a912ee 100644
--- a/src/amd/vulkan/radv_device_generated_commands.c
+++ b/src/amd/vulkan/radv_device_generated_commands.c
@@ -118,7 +118,7 @@ radv_get_sequence_size(const struct radv_indirect_command_layout *layout, struct
          }
          if (locs->shader_data[AC_UD_INLINE_PUSH_CONSTANTS].sgpr_idx >= 0)
             /* One PKT3_SET_SH_REG writing all inline push constants. */
-            *cmd_size += (3 * locs->shader_data[AC_UD_INLINE_PUSH_CONSTANTS].num_sgprs) * 4;
+            *cmd_size += (3 * util_bitcount64(layout->push_constant_mask)) * 4;
       }
       if (need_copy)
          *upload_size += align(pipeline->push_constant_size + 16 * pipeline->dynamic_offset_count, 16);
@@ -829,20 +829,13 @@ dgc_emit_push_constant(nir_builder *b, struct dgc_cmdbuf *cs, nir_def *stream_bu
                   nir_load_ssbo(b, 1, 32, param_buf, nir_iadd(b, param_offset_offset, nir_ishl_imm(b, cur_idx, 2)));
                nir_def *new_data = nir_load_ssbo(b, 1, 32, stream_buf, nir_iadd(b, stream_base, stream_offset));
                nir_store_var(b, data, new_data, 0x1);
-            }
-            nir_push_else(b, NULL);
-            {
-               nir_store_var(
-                  b, data,
-                  nir_load_ssbo(b, 1, 32, param_buf, nir_iadd(b, param_const_offset, nir_ishl_imm(b, cur_idx, 2))),
-                  0x1);
-            }
-            nir_pop_if(b, NULL);
 
-            nir_def *pkt[3] = {nir_pkt3(b, PKT3_SET_SH_REG, nir_imm_int(b, 1)),
-                               nir_iadd(b, inline_sgpr, nir_load_var(b, pc_idx)), nir_load_var(b, data)};
+               nir_def *pkt[3] = {nir_pkt3(b, PKT3_SET_SH_REG, nir_imm_int(b, 1)),
+                                  nir_iadd(b, inline_sgpr, nir_load_var(b, pc_idx)), nir_load_var(b, data)};
 
-            dgc_emit(b, cs, nir_vec(b, pkt, 3));
+               dgc_emit(b, cs, nir_vec(b, pkt, 3));
+            }
+            nir_pop_if(b, NULL);
 
             nir_store_var(b, idx, nir_iadd_imm(b, cur_idx, 1), 0x1);
             nir_store_var(b, pc_idx, nir_iadd_imm(b, nir_load_var(b, pc_idx), 1), 0x1);
-- 
GitLab


From 42a4de732f0eda335ba738e76598b35a28985ad9 Mon Sep 17 00:00:00 2001
From: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date: Fri, 27 Oct 2023 10:54:14 +0200
Subject: [PATCH 4/4] radv: enable DGC preprocessing when all push constants
 are inlined

It's not possible when they aren't all inlined because they need to be
copied to the upload BO and the DGC shader also copies the ones that
come from the indirect layout.

Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
---
 src/amd/vulkan/radv_cmd_buffer.c              |  2 +-
 .../vulkan/radv_device_generated_commands.c   | 28 ++++++++++++++++---
 src/amd/vulkan/radv_private.h                 |  2 +-
 3 files changed, 26 insertions(+), 6 deletions(-)

diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index d8707aac557b9..2deaa34eeb467 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -9550,7 +9550,7 @@ radv_CmdExecuteGeneratedCommandsNV(VkCommandBuffer commandBuffer, VkBool32 isPre
       cmd_buffer->state.predicating = true;
    }
 
-   if (!radv_dgc_can_preprocess(layout)) {
+   if (!radv_dgc_can_preprocess(layout, pipeline)) {
       radv_prepare_dgc(cmd_buffer, pGeneratedCommandsInfo);
 
       cmd_buffer->state.flush_bits |= RADV_CMD_FLAG_CS_PARTIAL_FLUSH | RADV_CMD_FLAG_INV_VCACHE | RADV_CMD_FLAG_INV_L2;
diff --git a/src/amd/vulkan/radv_device_generated_commands.c b/src/amd/vulkan/radv_device_generated_commands.c
index a5b1f54a912ee..729248c793138 100644
--- a/src/amd/vulkan/radv_device_generated_commands.c
+++ b/src/amd/vulkan/radv_device_generated_commands.c
@@ -1387,8 +1387,25 @@ radv_use_dgc_predication(struct radv_cmd_buffer *cmd_buffer, const VkGeneratedCo
    return cmd_buffer->qf == RADV_QUEUE_GENERAL && seq_count_buffer && !cmd_buffer->state.predicating;
 }
 
+static bool
+radv_dgc_need_push_constants_copy(const struct radv_pipeline *pipeline)
+{
+   for (unsigned i = 0; i < ARRAY_SIZE(pipeline->shaders); ++i) {
+      const struct radv_shader *shader = pipeline->shaders[i];
+
+      if (!shader)
+         continue;
+
+      const struct radv_userdata_locations *locs = &shader->info.user_sgprs_locs;
+      if (locs->shader_data[AC_UD_PUSH_CONSTANTS].sgpr_idx >= 0)
+         return true;
+   }
+
+   return false;
+}
+
 bool
-radv_dgc_can_preprocess(const struct radv_indirect_command_layout *layout)
+radv_dgc_can_preprocess(const struct radv_indirect_command_layout *layout, struct radv_pipeline *pipeline)
 {
    if (!(layout->flags & VK_INDIRECT_COMMANDS_LAYOUT_USAGE_EXPLICIT_PREPROCESS_BIT_NV))
       return false;
@@ -1410,8 +1427,10 @@ radv_dgc_can_preprocess(const struct radv_indirect_command_layout *layout)
       if (layout->bind_vbo_mask)
          return false;
 
-      /* In preprocess we use the non-overridden push constants from the draw state for now. */
-      if (layout->push_constant_mask)
+      /* Do not preprocess when all push constants can't be inlined because they need to be copied
+       * to the upload BO.
+       */
+      if (layout->push_constant_mask && radv_dgc_need_push_constants_copy(pipeline))
          return false;
    }
 
@@ -1424,8 +1443,9 @@ radv_CmdPreprocessGeneratedCommandsNV(VkCommandBuffer commandBuffer,
 {
    VK_FROM_HANDLE(radv_cmd_buffer, cmd_buffer, commandBuffer);
    VK_FROM_HANDLE(radv_indirect_command_layout, layout, pGeneratedCommandsInfo->indirectCommandsLayout);
+   VK_FROM_HANDLE(radv_pipeline, pipeline, pGeneratedCommandsInfo->pipeline);
 
-   if (!radv_dgc_can_preprocess(layout))
+   if (!radv_dgc_can_preprocess(layout, pipeline))
       return;
 
    const bool use_predication = radv_use_dgc_predication(cmd_buffer, pGeneratedCommandsInfo);
diff --git a/src/amd/vulkan/radv_private.h b/src/amd/vulkan/radv_private.h
index db6cea9daea02..e8f63614f224e 100644
--- a/src/amd/vulkan/radv_private.h
+++ b/src/amd/vulkan/radv_private.h
@@ -3250,7 +3250,7 @@ bool radv_use_dgc_predication(struct radv_cmd_buffer *cmd_buffer,
                               const VkGeneratedCommandsInfoNV *pGeneratedCommandsInfo);
 void radv_prepare_dgc(struct radv_cmd_buffer *cmd_buffer, const VkGeneratedCommandsInfoNV *pGeneratedCommandsInfo);
 
-bool radv_dgc_can_preprocess(const struct radv_indirect_command_layout *layout);
+bool radv_dgc_can_preprocess(const struct radv_indirect_command_layout *layout, struct radv_pipeline *pipeline);
 
 static inline uint32_t
 si_conv_prim_to_gs_out(uint32_t topology, bool is_ngg)
-- 
GitLab

