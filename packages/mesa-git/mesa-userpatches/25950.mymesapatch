From aeb95f44a98769bf48345e000cdaa68ed3340b05 Mon Sep 17 00:00:00 2001
From: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date: Thu, 28 Sep 2023 12:28:26 +0200
Subject: [PATCH 01/10] radv: add
 radv_physical_device::emulate_mesh_shader_queries for GFX10.3

GFX11 supports them natively but not GFX10.3.

Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
---
 src/amd/vulkan/radv_physical_device.c | 2 ++
 src/amd/vulkan/radv_private.h         | 3 +++
 2 files changed, 5 insertions(+)

diff --git a/src/amd/vulkan/radv_physical_device.c b/src/amd/vulkan/radv_physical_device.c
index 5c50552424a1e..1dc29f33d839f 100644
--- a/src/amd/vulkan/radv_physical_device.c
+++ b/src/amd/vulkan/radv_physical_device.c
@@ -1902,6 +1902,8 @@ radv_physical_device_try_create(struct radv_instance *instance, drmDevicePtr drm
 
    device->emulate_ngg_gs_query_pipeline_stat = device->use_ngg && device->rad_info.gfx_level < GFX11;
 
+   device->emulate_mesh_shader_queries = device->rad_info.gfx_level == GFX10_3;
+
    /* Determine the number of threads per wave for all stages. */
    device->cs_wave_size = 64;
    device->ps_wave_size = 64;
diff --git a/src/amd/vulkan/radv_private.h b/src/amd/vulkan/radv_private.h
index 69d601c45b488..bac56d1891cfe 100644
--- a/src/amd/vulkan/radv_private.h
+++ b/src/amd/vulkan/radv_private.h
@@ -311,6 +311,9 @@ struct radv_physical_device {
    /* Whether to emulate the number of primitives generated by GS. */
    bool emulate_ngg_gs_query_pipeline_stat;
 
+   /* Whether to emulate mesh/task shader queries. */
+   bool emulate_mesh_shader_queries;
+
    /* Number of threads per wave. */
    uint8_t ps_wave_size;
    uint8_t cs_wave_size;
-- 
GitLab


From 35135fc38ac08b4deb59416fdfb798fe3210ae88 Mon Sep 17 00:00:00 2001
From: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date: Wed, 20 Sep 2023 17:05:33 +0200
Subject: [PATCH 02/10] radv: add support for mesh primitives queries on
 GFX10.3

This query is emulated using a GDS atomic counter in shaders.

Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
---
 src/amd/vulkan/radv_private.h |   1 +
 src/amd/vulkan/radv_query.c   | 217 +++++++++++++++++++++++++++++++++-
 2 files changed, 217 insertions(+), 1 deletion(-)

diff --git a/src/amd/vulkan/radv_private.h b/src/amd/vulkan/radv_private.h
index bac56d1891cfe..8c9ebe2302aa4 100644
--- a/src/amd/vulkan/radv_private.h
+++ b/src/amd/vulkan/radv_private.h
@@ -703,6 +703,7 @@ struct radv_meta_state {
       VkPipeline tfb_query_pipeline;
       VkPipeline timestamp_query_pipeline;
       VkPipeline pg_query_pipeline;
+      VkPipeline ms_prim_gen_query_pipeline;
    } query;
 
    struct {
diff --git a/src/amd/vulkan/radv_query.c b/src/amd/vulkan/radv_query.c
index 02339b508be41..41acf8f574a03 100644
--- a/src/amd/vulkan/radv_query.c
+++ b/src/amd/vulkan/radv_query.c
@@ -729,6 +729,116 @@ build_pg_query_shader(struct radv_device *device)
    return b.shader;
 }
 
+static nir_shader *
+build_ms_prim_gen_query_shader(struct radv_device *device)
+{
+   /* the shader this builds is roughly
+    *
+    * uint32_t src_stride = 32;
+    *
+    * location(binding = 0) buffer dst_buf;
+    * location(binding = 1) buffer src_buf;
+    *
+    * void main() {
+    *	uint64_t result = {};
+    *	bool available = false;
+    *	uint64_t src_offset = src_stride * global_id.x;
+    * 	uint64_t dst_offset = dst_stride * global_id.x;
+    * 	uint64_t *src_data = src_buf[src_offset];
+    *	uint32_t avail = (src_data[0] >> 32) & (src_data[1] >> 32);
+    *	if (avail & 0x80000000) {
+    *		result = src_data[1] - src_data[0];
+    *		available = true;
+    *	}
+    * 	uint32_t result_size = flags & VK_QUERY_RESULT_64_BIT ? 8 : 4;
+    * 	if ((flags & VK_QUERY_RESULT_PARTIAL_BIT) || available) {
+    *		if (flags & VK_QUERY_RESULT_64_BIT) {
+    *			dst_buf[dst_offset] = result;
+    *		} else {
+    *			dst_buf[dst_offset] = (uint32_t)result;
+    *		}
+    *	}
+    *	if (flags & VK_QUERY_RESULT_WITH_AVAILABILITY_BIT) {
+    *		dst_buf[dst_offset + result_size] = available;
+    * 	}
+    * }
+    */
+   nir_builder b = radv_meta_init_shader(device, MESA_SHADER_COMPUTE, "ms_prim_gen_query");
+   b.shader->info.workgroup_size[0] = 64;
+
+   /* Create and initialize local variables. */
+   nir_variable *result = nir_local_variable_create(b.impl, glsl_uint64_t_type(), "result");
+   nir_variable *available = nir_local_variable_create(b.impl, glsl_bool_type(), "available");
+
+   nir_store_var(&b, result, nir_imm_int64(&b, 0), 0x1);
+   nir_store_var(&b, available, nir_imm_false(&b), 0x1);
+
+   nir_def *flags = nir_load_push_constant(&b, 1, 32, nir_imm_int(&b, 0), .range = 16);
+
+   /* Load resources. */
+   nir_def *dst_buf = radv_meta_load_descriptor(&b, 0, 0);
+   nir_def *src_buf = radv_meta_load_descriptor(&b, 0, 1);
+
+   /* Compute global ID. */
+   nir_def *global_id = get_global_ids(&b, 1);
+
+   /* Compute src/dst strides. */
+   nir_def *input_base = nir_imul_imm(&b, global_id, 16);
+   nir_def *output_stride = nir_load_push_constant(&b, 1, 32, nir_imm_int(&b, 4), .range = 16);
+   nir_def *output_base = nir_imul(&b, output_stride, global_id);
+
+   /* Load data from the query pool. */
+   nir_def *load1 = nir_load_ssbo(&b, 2, 32, src_buf, input_base, .align_mul = 32);
+   nir_def *load2 = nir_load_ssbo(&b, 2, 32, src_buf, nir_iadd_imm(&b, input_base, 8), .align_mul = 16);
+
+   /* Check if result is available. */
+   nir_def *avails[2];
+   avails[0] = nir_channel(&b, load1, 1);
+   avails[1] = nir_channel(&b, load2, 1);
+   nir_def *result_is_available = nir_i2b(&b, nir_iand_imm(&b, nir_iand(&b, avails[0], avails[1]), 0x80000000));
+
+   /* Only compute result if available. */
+   nir_push_if(&b, result_is_available);
+
+   /* Pack values. */
+   nir_def *packed64[2];
+   packed64[0] = nir_pack_64_2x32(&b, nir_trim_vector(&b, load1, 2));
+   packed64[1] = nir_pack_64_2x32(&b, nir_trim_vector(&b, load2, 2));
+
+   /* Compute result. */
+   nir_def *ms_prim_gen = nir_isub(&b, packed64[1], packed64[0]);
+
+   nir_store_var(&b, result, ms_prim_gen, 0x1);
+
+   nir_store_var(&b, available, nir_imm_true(&b), 0x1);
+
+   nir_pop_if(&b, NULL);
+
+   /* Determine if result is 64 or 32 bit. */
+   nir_def *result_is_64bit = nir_test_mask(&b, flags, VK_QUERY_RESULT_64_BIT);
+   nir_def *result_size = nir_bcsel(&b, result_is_64bit, nir_imm_int(&b, 8), nir_imm_int(&b, 4));
+
+   /* Store the result if complete or partial results have been requested. */
+   nir_push_if(&b, nir_ior(&b, nir_test_mask(&b, flags, VK_QUERY_RESULT_PARTIAL_BIT), nir_load_var(&b, available)));
+
+   /* Store result. */
+   nir_push_if(&b, result_is_64bit);
+
+   nir_store_ssbo(&b, nir_load_var(&b, result), dst_buf, output_base);
+
+   nir_push_else(&b, NULL);
+
+   nir_store_ssbo(&b, nir_u2u32(&b, nir_load_var(&b, result)), dst_buf, output_base);
+
+   nir_pop_if(&b, NULL);
+   nir_pop_if(&b, NULL);
+
+   radv_store_availability(&b, flags, dst_buf, nir_iadd(&b, result_size, output_base),
+                           nir_b2i32(&b, nir_load_var(&b, available)));
+
+   return b.shader;
+}
+
 static VkResult
 radv_device_init_meta_query_state_internal(struct radv_device *device)
 {
@@ -738,6 +848,7 @@ radv_device_init_meta_query_state_internal(struct radv_device *device)
    nir_shader *tfb_cs = NULL;
    nir_shader *timestamp_cs = NULL;
    nir_shader *pg_cs = NULL;
+   nir_shader *ms_prim_gen_cs = NULL;
 
    mtx_lock(&device->meta_state.mtx);
    if (device->meta_state.query.pipeline_statistics_query_pipeline) {
@@ -750,6 +861,9 @@ radv_device_init_meta_query_state_internal(struct radv_device *device)
    timestamp_cs = build_timestamp_query_shader(device);
    pg_cs = build_pg_query_shader(device);
 
+   if (device->physical_device->emulate_mesh_shader_queries)
+      ms_prim_gen_cs = build_ms_prim_gen_query_shader(device);
+
    VkDescriptorSetLayoutCreateInfo occlusion_ds_create_info = {
       .sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO,
       .flags = VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR,
@@ -886,11 +1000,33 @@ radv_device_init_meta_query_state_internal(struct radv_device *device)
    result = radv_compute_pipeline_create(radv_device_to_handle(device), device->meta_state.cache, &pg_pipeline_info,
                                          NULL, &device->meta_state.query.pg_query_pipeline);
 
+   if (device->physical_device->emulate_mesh_shader_queries) {
+      VkPipelineShaderStageCreateInfo ms_prim_gen_pipeline_shader_stage = {
+         .sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO,
+         .stage = VK_SHADER_STAGE_COMPUTE_BIT,
+         .module = vk_shader_module_handle_from_nir(ms_prim_gen_cs),
+         .pName = "main",
+         .pSpecializationInfo = NULL,
+      };
+
+      VkComputePipelineCreateInfo ms_prim_gen_pipeline_info = {
+         .sType = VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO,
+         .stage = ms_prim_gen_pipeline_shader_stage,
+         .flags = 0,
+         .layout = device->meta_state.query.p_layout,
+      };
+
+      result = radv_compute_pipeline_create(radv_device_to_handle(device), device->meta_state.cache,
+                                            &ms_prim_gen_pipeline_info, NULL,
+                                            &device->meta_state.query.ms_prim_gen_query_pipeline);
+   }
+
 fail:
    ralloc_free(occlusion_cs);
    ralloc_free(pipeline_statistics_cs);
    ralloc_free(tfb_cs);
    ralloc_free(pg_cs);
+   ralloc_free(ms_prim_gen_cs);
    ralloc_free(timestamp_cs);
    mtx_unlock(&device->meta_state.mtx);
    return result;
@@ -928,6 +1064,10 @@ radv_device_finish_meta_query_state(struct radv_device *device)
       radv_DestroyPipeline(radv_device_to_handle(device), device->meta_state.query.pg_query_pipeline,
                            &device->meta_state.alloc);
 
+   if (device->meta_state.query.ms_prim_gen_query_pipeline)
+      radv_DestroyPipeline(radv_device_to_handle(device), device->meta_state.query.ms_prim_gen_query_pipeline,
+                           &device->meta_state.alloc);
+
    if (device->meta_state.query.p_layout)
       radv_DestroyPipelineLayout(radv_device_to_handle(device), device->meta_state.query.p_layout,
                                  &device->meta_state.alloc);
@@ -1073,7 +1213,9 @@ radv_create_query_pool(struct radv_device *device, const VkQueryPoolCreateInfo *
       (device->physical_device->emulate_ngg_gs_query_pipeline_stat &&
        (pool->vk.pipeline_statistics & (VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT |
                                         VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT))) ||
-      (device->physical_device->use_ngg && pCreateInfo->queryType == VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT);
+      (device->physical_device->use_ngg && pCreateInfo->queryType == VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT) ||
+      (device->physical_device->emulate_mesh_shader_queries &&
+       pCreateInfo->queryType == VK_QUERY_TYPE_MESH_PRIMITIVES_GENERATED_EXT);
 
    switch (pCreateInfo->queryType) {
    case VK_QUERY_TYPE_OCCLUSION:
@@ -1111,6 +1253,9 @@ radv_create_query_pool(struct radv_device *device, const VkQueryPoolCreateInfo *
       }
       break;
    }
+   case VK_QUERY_TYPE_MESH_PRIMITIVES_GENERATED_EXT:
+      pool->stride = 16;
+      break;
    default:
       unreachable("creating unhandled query type");
    }
@@ -1386,6 +1531,34 @@ radv_GetQueryPoolResults(VkDevice _device, VkQueryPool queryPool, uint32_t first
          dest += pc_pool->num_counters * sizeof(union VkPerformanceCounterResultKHR);
          break;
       }
+      case VK_QUERY_TYPE_MESH_PRIMITIVES_GENERATED_EXT: {
+         p_atomic_uint64_t const *src64 = (p_atomic_uint64_t const *)src;
+         uint64_t ms_prim_gen;
+
+         do {
+            available = 1;
+            if (!(p_atomic_read(src64 + 0) & 0x8000000000000000UL) ||
+                !(p_atomic_read(src64 + 1) & 0x8000000000000000UL)) {
+               available = 0;
+            }
+         } while (!available && (flags & VK_QUERY_RESULT_WAIT_BIT));
+
+         if (!available && !(flags & VK_QUERY_RESULT_PARTIAL_BIT))
+            result = VK_NOT_READY;
+
+         ms_prim_gen = src64[1] - src64[0];
+
+         if (flags & VK_QUERY_RESULT_64_BIT) {
+            if (available || (flags & VK_QUERY_RESULT_PARTIAL_BIT))
+               *(uint64_t *)dest = ms_prim_gen;
+            dest += 8;
+         } else {
+            if (available || (flags & VK_QUERY_RESULT_PARTIAL_BIT))
+               *(uint32_t *)dest = ms_prim_gen;
+            dest += 4;
+         }
+         break;
+      }
       default:
          unreachable("trying to get results of unhandled query type");
       }
@@ -1428,6 +1601,7 @@ radv_query_result_size(const struct radv_query_pool *pool, VkQueryResultFlags fl
    case VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SERIALIZATION_BOTTOM_LEVEL_POINTERS_KHR:
    case VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SIZE_KHR:
    case VK_QUERY_TYPE_OCCLUSION:
+   case VK_QUERY_TYPE_MESH_PRIMITIVES_GENERATED_EXT:
       values += 1;
       break;
    case VK_QUERY_TYPE_PIPELINE_STATISTICS:
@@ -1574,6 +1748,24 @@ radv_CmdCopyQueryPoolResults(VkCommandBuffer commandBuffer, VkQueryPool queryPoo
                         queryCount, flags, 0, 0,
                         pool->uses_gds && cmd_buffer->device->physical_device->rad_info.gfx_level < GFX11);
       break;
+   case VK_QUERY_TYPE_MESH_PRIMITIVES_GENERATED_EXT:
+      if (flags & VK_QUERY_RESULT_WAIT_BIT) {
+         for (unsigned i = 0; i < queryCount; i++) {
+            unsigned query = firstQuery + i;
+            uint64_t src_va = va + query * pool->stride;
+
+            radeon_check_space(cmd_buffer->device->ws, cs, 7 * 2);
+
+            /* Wait on the upper word. */
+            radv_cp_wait_mem(cs, cmd_buffer->qf, WAIT_REG_MEM_GREATER_OR_EQUAL, src_va + 4, 0x80000000, 0xffffffff);
+            radv_cp_wait_mem(cs, cmd_buffer->qf, WAIT_REG_MEM_GREATER_OR_EQUAL, src_va + 12, 0x80000000, 0xffffffff);
+         }
+      }
+
+      radv_query_shader(cmd_buffer, &cmd_buffer->device->meta_state.query.ms_prim_gen_query_pipeline, pool->bo,
+                        dst_buffer->bo, firstQuery * pool->stride, dst_buffer->offset + dstOffset, pool->stride, stride,
+                        dst_size, queryCount, flags, 0, 0, false);
+      break;
    default:
       unreachable("trying to get results of unhandled query type");
    }
@@ -1866,6 +2058,19 @@ emit_begin_query(struct radv_cmd_buffer *cmd_buffer, struct radv_query_pool *poo
       radv_pc_begin_query(cmd_buffer, (struct radv_pc_query_pool *)pool, va);
       break;
    }
+   case VK_QUERY_TYPE_MESH_PRIMITIVES_GENERATED_EXT: {
+      gfx10_copy_gds_query(cmd_buffer, RADV_SHADER_QUERY_MS_PRIM_GEN_OFFSET, va);
+      radv_cs_write_data_imm(cs, V_370_ME, va + 4, 0x80000000);
+
+      /* Record that the command buffer needs GDS. */
+      cmd_buffer->gds_needed = true;
+
+      if (!cmd_buffer->state.active_prims_gen_gds_queries)
+         cmd_buffer->state.dirty |= RADV_CMD_DIRTY_SHADER_QUERY;
+
+      cmd_buffer->state.active_prims_gen_gds_queries++;
+      break;
+   }
    default:
       unreachable("beginning unhandled query type");
    }
@@ -2019,6 +2224,16 @@ emit_end_query(struct radv_cmd_buffer *cmd_buffer, struct radv_query_pool *pool,
       radv_pc_end_query(cmd_buffer, (struct radv_pc_query_pool *)pool, va);
       break;
    }
+   case VK_QUERY_TYPE_MESH_PRIMITIVES_GENERATED_EXT: {
+      gfx10_copy_gds_query(cmd_buffer, RADV_SHADER_QUERY_MS_PRIM_GEN_OFFSET, va + 8);
+      radv_cs_write_data_imm(cs, V_370_ME, va + 12, 0x80000000);
+
+      cmd_buffer->state.active_prims_gen_gds_queries--;
+
+      if (!cmd_buffer->state.active_prims_gen_gds_queries)
+         cmd_buffer->state.dirty |= RADV_CMD_DIRTY_SHADER_QUERY;
+      break;
+   }
    default:
       unreachable("ending unhandled query type");
    }
-- 
GitLab


From b2866a368b28de563fdf6279c2c403649e1cdaa3 Mon Sep 17 00:00:00 2001
From: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date: Wed, 20 Sep 2023 10:42:22 +0200
Subject: [PATCH 03/10] radv: define new pipeline statistics indices for
 mesh/task on GFX11

GFX11 uses pipeline statistics for mesh/task queries but on GFX10.3
they need to be emulated. Though the number of mesh/task shader
invocations would be copied to the pipeline statistics range to
simplify the implementation.

Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
---
 src/amd/vulkan/radv_query.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/amd/vulkan/radv_query.c b/src/amd/vulkan/radv_query.c
index 41acf8f574a03..ed2d735d26cea 100644
--- a/src/amd/vulkan/radv_query.c
+++ b/src/amd/vulkan/radv_query.c
@@ -41,7 +41,7 @@
 #define TIMESTAMP_NOT_READY UINT64_MAX
 
 /* TODO: Add support for mesh/task queries on GFX11 */
-static const unsigned pipeline_statistics_indices[] = {7, 6, 3, 4, 5, 2, 1, 0, 8, 9, 10};
+static const unsigned pipeline_statistics_indices[] = {7, 6, 3, 4, 5, 2, 1, 0, 8, 9, 10, 13, 11, 12};
 
 static unsigned
 radv_get_pipelinestat_query_offset(VkQueryPipelineStatisticFlagBits query)
-- 
GitLab


From f448258697f30538cfffd1d10d94aca1c6f79560 Mon Sep 17 00:00:00 2001
From: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date: Thu, 21 Sep 2023 10:26:56 +0200
Subject: [PATCH 04/10] radv: bump the pipeline state query size to 14 on
 GFX10.3

GFX10.3 doesn't natively support mesh/task shader invocations query
and they need to be emulated in shaders. In order to share more code
between GFX10.3 and GFX11, it's easier to use the same size as GFX11.

Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
---
 src/amd/vulkan/radv_query.c | 5 ++++-
 1 file changed, 4 insertions(+), 1 deletion(-)

diff --git a/src/amd/vulkan/radv_query.c b/src/amd/vulkan/radv_query.c
index ed2d735d26cea..1c000ccbef839 100644
--- a/src/amd/vulkan/radv_query.c
+++ b/src/amd/vulkan/radv_query.c
@@ -53,7 +53,10 @@ radv_get_pipelinestat_query_offset(VkQueryPipelineStatisticFlagBits query)
 static unsigned
 radv_get_pipelinestat_query_size(struct radv_device *device)
 {
-   unsigned num_results = device->physical_device->rad_info.gfx_level >= GFX11 ? 14 : 11;
+   /* GFX10_3 only has 11 valid pipeline statistics queries but in order to emulate mesh/task shader
+    * invocations, it's easier to use the same size as GFX11.
+    */
+   unsigned num_results = device->physical_device->rad_info.gfx_level >= GFX10_3 ? 14 : 11;
    return num_results * 8;
 }
 
-- 
GitLab


From b442f0af4c9bb04aa3ce2ccded48875853e3dc14 Mon Sep 17 00:00:00 2001
From: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date: Thu, 21 Sep 2023 10:28:36 +0200
Subject: [PATCH 05/10] radv: do not harcode the pipeline stats mask for query
 resolves

Otherwise, mesh/task shader invocations would be ignored.

Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
---
 src/amd/vulkan/radv_query.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/amd/vulkan/radv_query.c b/src/amd/vulkan/radv_query.c
index 1c000ccbef839..d68df27b8a946 100644
--- a/src/amd/vulkan/radv_query.c
+++ b/src/amd/vulkan/radv_query.c
@@ -1134,7 +1134,7 @@ radv_query_shader(struct radv_cmd_buffer *cmd_buffer, VkPipeline *pipeline, stru
                                                                          .range = VK_WHOLE_SIZE}}});
 
    /* Encode the number of elements for easy access by the shader. */
-   pipeline_stats_mask &= 0x7ff;
+   pipeline_stats_mask &= (1 << radv_get_pipelinestat_query_size(device)) - 1;
    pipeline_stats_mask |= util_bitcount(pipeline_stats_mask) << 16;
 
    avail_offset -= src_offset;
-- 
GitLab


From 3098a0a97e4023d53451c9177e1975004fc7ab15 Mon Sep 17 00:00:00 2001
From: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date: Thu, 21 Sep 2023 10:29:23 +0200
Subject: [PATCH 06/10] radv: add support for mesh shader invocations queries
 on GFX10.3

Also emulated with a GDS atomic counter in shaders.

Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
---
 src/amd/vulkan/radv_cmd_buffer.c |  3 ++-
 src/amd/vulkan/radv_query.c      | 17 ++++++++++++++++-
 2 files changed, 18 insertions(+), 2 deletions(-)

diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index 709de1256f686..b5aa719cb33cc 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -5169,7 +5169,8 @@ radv_flush_shader_query_state(struct radv_cmd_buffer *cmd_buffer)
     */
    if (cmd_buffer->state.active_pipeline_gds_queries || (cmd_buffer->state.inherited_pipeline_statistics &
                                                          (VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT |
-                                                          VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT)))
+                                                          VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT |
+                                                          VK_QUERY_PIPELINE_STATISTIC_MESH_SHADER_INVOCATIONS_BIT_EXT)))
       shader_query_state |= radv_shader_query_pipeline_stat;
 
    if (cmd_buffer->state.active_prims_gen_gds_queries)
diff --git a/src/amd/vulkan/radv_query.c b/src/amd/vulkan/radv_query.c
index d68df27b8a946..9013807ec0f30 100644
--- a/src/amd/vulkan/radv_query.c
+++ b/src/amd/vulkan/radv_query.c
@@ -1218,7 +1218,8 @@ radv_create_query_pool(struct radv_device *device, const VkQueryPoolCreateInfo *
                                         VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT))) ||
       (device->physical_device->use_ngg && pCreateInfo->queryType == VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT) ||
       (device->physical_device->emulate_mesh_shader_queries &&
-       pCreateInfo->queryType == VK_QUERY_TYPE_MESH_PRIMITIVES_GENERATED_EXT);
+       (pCreateInfo->queryType == VK_QUERY_TYPE_MESH_PRIMITIVES_GENERATED_EXT ||
+        pool->vk.pipeline_statistics & VK_QUERY_PIPELINE_STATISTIC_MESH_SHADER_INVOCATIONS_BIT_EXT));
 
    switch (pCreateInfo->queryType) {
    case VK_QUERY_TYPE_OCCLUSION:
@@ -1976,6 +1977,13 @@ emit_begin_query(struct radv_cmd_buffer *cmd_buffer, struct radv_query_pool *poo
             gfx10_copy_gds_query(cmd_buffer, RADV_SHADER_QUERY_GS_INVOCATION_OFFSET, va + gs_invoc_offset);
          }
 
+         if (pool->vk.pipeline_statistics & VK_QUERY_PIPELINE_STATISTIC_MESH_SHADER_INVOCATIONS_BIT_EXT) {
+            uint32_t mesh_invoc_offset =
+               radv_get_pipelinestat_query_offset(VK_QUERY_PIPELINE_STATISTIC_MESH_SHADER_INVOCATIONS_BIT_EXT);
+
+            gfx10_copy_gds_query(cmd_buffer, RADV_SHADER_QUERY_MS_INVOCATION_OFFSET, va + mesh_invoc_offset);
+         }
+
          /* Record that the command buffer needs GDS. */
          cmd_buffer->gds_needed = true;
 
@@ -2150,6 +2158,13 @@ emit_end_query(struct radv_cmd_buffer *cmd_buffer, struct radv_query_pool *pool,
             gfx10_copy_gds_query(cmd_buffer, RADV_SHADER_QUERY_GS_INVOCATION_OFFSET, va + gs_invoc_offset);
          }
 
+         if (pool->vk.pipeline_statistics & VK_QUERY_PIPELINE_STATISTIC_MESH_SHADER_INVOCATIONS_BIT_EXT) {
+            uint32_t mesh_invoc_offset =
+               radv_get_pipelinestat_query_offset(VK_QUERY_PIPELINE_STATISTIC_MESH_SHADER_INVOCATIONS_BIT_EXT);
+
+            gfx10_copy_gds_query(cmd_buffer, RADV_SHADER_QUERY_MS_INVOCATION_OFFSET, va + mesh_invoc_offset);
+         }
+
          cmd_buffer->state.active_pipeline_gds_queries--;
 
          if (!cmd_buffer->state.active_pipeline_gds_queries)
-- 
GitLab


From 48b1479a74781f9f946538bb675b40bd85b32770 Mon Sep 17 00:00:00 2001
From: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date: Fri, 27 Oct 2023 16:48:45 +0200
Subject: [PATCH 07/10] radv: rework gfx10_copy_gds_query() slightly

To prepare for the same function with ACE.

Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
---
 src/amd/vulkan/radv_query.c | 50 ++++++++++++++++++++-----------------
 1 file changed, 27 insertions(+), 23 deletions(-)

diff --git a/src/amd/vulkan/radv_query.c b/src/amd/vulkan/radv_query.c
index 9013807ec0f30..c26688f01c5c9 100644
--- a/src/amd/vulkan/radv_query.c
+++ b/src/amd/vulkan/radv_query.c
@@ -1869,14 +1869,8 @@ emit_sample_streamout(struct radv_cmd_buffer *cmd_buffer, uint64_t va, uint32_t
 }
 
 static void
-gfx10_copy_gds_query(struct radv_cmd_buffer *cmd_buffer, uint32_t gds_offset, uint64_t va)
+gfx10_copy_gds_query(struct radeon_cmdbuf *cs, uint32_t gds_offset, uint64_t va)
 {
-   struct radeon_cmdbuf *cs = cmd_buffer->cs;
-
-   /* Make sure GDS is idle before copying the value. */
-   cmd_buffer->state.flush_bits |= RADV_CMD_FLAG_PS_PARTIAL_FLUSH | RADV_CMD_FLAG_INV_L2;
-   si_emit_cache_flush(cmd_buffer);
-
    radeon_emit(cs, PKT3(PKT3_COPY_DATA, 4, 0));
    radeon_emit(cs, COPY_DATA_SRC_SEL(COPY_DATA_GDS) | COPY_DATA_DST_SEL(COPY_DATA_DST_MEM) | COPY_DATA_WR_CONFIRM);
    radeon_emit(cs, gds_offset);
@@ -1885,6 +1879,16 @@ gfx10_copy_gds_query(struct radv_cmd_buffer *cmd_buffer, uint32_t gds_offset, ui
    radeon_emit(cs, va >> 32);
 }
 
+static void
+gfx10_copy_gds_query_gfx(struct radv_cmd_buffer *cmd_buffer, uint32_t gds_offset, uint64_t va)
+{
+   /* Make sure GDS is idle before copying the value. */
+   cmd_buffer->state.flush_bits |= RADV_CMD_FLAG_PS_PARTIAL_FLUSH | RADV_CMD_FLAG_INV_L2;
+   si_emit_cache_flush(cmd_buffer);
+
+   gfx10_copy_gds_query(cmd_buffer->cs, gds_offset, va);
+}
+
 static void
 radv_update_hw_pipelinestat(struct radv_cmd_buffer *cmd_buffer)
 {
@@ -1967,21 +1971,21 @@ emit_begin_query(struct radv_cmd_buffer *cmd_buffer, struct radv_query_pool *poo
             uint32_t gs_prim_offset =
                radv_get_pipelinestat_query_offset(VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT);
 
-            gfx10_copy_gds_query(cmd_buffer, RADV_SHADER_QUERY_GS_PRIM_EMIT_OFFSET, va + gs_prim_offset);
+            gfx10_copy_gds_query_gfx(cmd_buffer, RADV_SHADER_QUERY_GS_PRIM_EMIT_OFFSET, va + gs_prim_offset);
          }
 
          if (pool->vk.pipeline_statistics & VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT) {
             uint32_t gs_invoc_offset =
                radv_get_pipelinestat_query_offset(VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT);
 
-            gfx10_copy_gds_query(cmd_buffer, RADV_SHADER_QUERY_GS_INVOCATION_OFFSET, va + gs_invoc_offset);
+            gfx10_copy_gds_query_gfx(cmd_buffer, RADV_SHADER_QUERY_GS_INVOCATION_OFFSET, va + gs_invoc_offset);
          }
 
          if (pool->vk.pipeline_statistics & VK_QUERY_PIPELINE_STATISTIC_MESH_SHADER_INVOCATIONS_BIT_EXT) {
             uint32_t mesh_invoc_offset =
                radv_get_pipelinestat_query_offset(VK_QUERY_PIPELINE_STATISTIC_MESH_SHADER_INVOCATIONS_BIT_EXT);
 
-            gfx10_copy_gds_query(cmd_buffer, RADV_SHADER_QUERY_MS_INVOCATION_OFFSET, va + mesh_invoc_offset);
+            gfx10_copy_gds_query_gfx(cmd_buffer, RADV_SHADER_QUERY_MS_INVOCATION_OFFSET, va + mesh_invoc_offset);
          }
 
          /* Record that the command buffer needs GDS. */
@@ -1997,11 +2001,11 @@ emit_begin_query(struct radv_cmd_buffer *cmd_buffer, struct radv_query_pool *poo
    case VK_QUERY_TYPE_TRANSFORM_FEEDBACK_STREAM_EXT:
       if (cmd_buffer->device->physical_device->use_ngg_streamout) {
          /* generated prim counter */
-         gfx10_copy_gds_query(cmd_buffer, RADV_SHADER_QUERY_PRIM_GEN_OFFSET(index), va);
+         gfx10_copy_gds_query_gfx(cmd_buffer, RADV_SHADER_QUERY_PRIM_GEN_OFFSET(index), va);
          radv_cs_write_data_imm(cs, V_370_ME, va + 4, 0x80000000);
 
          /* written prim counter */
-         gfx10_copy_gds_query(cmd_buffer, RADV_SHADER_QUERY_PRIM_XFB_OFFSET(index), va + 8);
+         gfx10_copy_gds_query_gfx(cmd_buffer, RADV_SHADER_QUERY_PRIM_XFB_OFFSET(index), va + 8);
          radv_cs_write_data_imm(cs, V_370_ME, va + 12, 0x80000000);
 
          /* Record that the command buffer needs GDS. */
@@ -2022,7 +2026,7 @@ emit_begin_query(struct radv_cmd_buffer *cmd_buffer, struct radv_query_pool *poo
    case VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT: {
       if (cmd_buffer->device->physical_device->rad_info.gfx_level >= GFX11) {
          /* On GFX11+, primitives generated query always use GDS. */
-         gfx10_copy_gds_query(cmd_buffer, RADV_SHADER_QUERY_PRIM_GEN_OFFSET(index), va);
+         gfx10_copy_gds_query_gfx(cmd_buffer, RADV_SHADER_QUERY_PRIM_GEN_OFFSET(index), va);
          radv_cs_write_data_imm(cs, V_370_ME, va + 4, 0x80000000);
 
          /* Record that the command buffer needs GDS. */
@@ -2049,7 +2053,7 @@ emit_begin_query(struct radv_cmd_buffer *cmd_buffer, struct radv_query_pool *poo
 
          if (pool->uses_gds) {
             /* generated prim counter */
-            gfx10_copy_gds_query(cmd_buffer, RADV_SHADER_QUERY_PRIM_GEN_OFFSET(index), va + 32);
+            gfx10_copy_gds_query_gfx(cmd_buffer, RADV_SHADER_QUERY_PRIM_GEN_OFFSET(index), va + 32);
             radv_cs_write_data_imm(cs, V_370_ME, va + 36, 0x80000000);
 
             /* Record that the command buffer needs GDS. */
@@ -2070,7 +2074,7 @@ emit_begin_query(struct radv_cmd_buffer *cmd_buffer, struct radv_query_pool *poo
       break;
    }
    case VK_QUERY_TYPE_MESH_PRIMITIVES_GENERATED_EXT: {
-      gfx10_copy_gds_query(cmd_buffer, RADV_SHADER_QUERY_MS_PRIM_GEN_OFFSET, va);
+      gfx10_copy_gds_query_gfx(cmd_buffer, RADV_SHADER_QUERY_MS_PRIM_GEN_OFFSET, va);
       radv_cs_write_data_imm(cs, V_370_ME, va + 4, 0x80000000);
 
       /* Record that the command buffer needs GDS. */
@@ -2148,21 +2152,21 @@ emit_end_query(struct radv_cmd_buffer *cmd_buffer, struct radv_query_pool *pool,
             uint32_t gs_prim_offset =
                radv_get_pipelinestat_query_offset(VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT);
 
-            gfx10_copy_gds_query(cmd_buffer, RADV_SHADER_QUERY_GS_PRIM_EMIT_OFFSET, va + gs_prim_offset);
+            gfx10_copy_gds_query_gfx(cmd_buffer, RADV_SHADER_QUERY_GS_PRIM_EMIT_OFFSET, va + gs_prim_offset);
          }
 
          if (pool->vk.pipeline_statistics & VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT) {
             uint32_t gs_invoc_offset =
                radv_get_pipelinestat_query_offset(VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT);
 
-            gfx10_copy_gds_query(cmd_buffer, RADV_SHADER_QUERY_GS_INVOCATION_OFFSET, va + gs_invoc_offset);
+            gfx10_copy_gds_query_gfx(cmd_buffer, RADV_SHADER_QUERY_GS_INVOCATION_OFFSET, va + gs_invoc_offset);
          }
 
          if (pool->vk.pipeline_statistics & VK_QUERY_PIPELINE_STATISTIC_MESH_SHADER_INVOCATIONS_BIT_EXT) {
             uint32_t mesh_invoc_offset =
                radv_get_pipelinestat_query_offset(VK_QUERY_PIPELINE_STATISTIC_MESH_SHADER_INVOCATIONS_BIT_EXT);
 
-            gfx10_copy_gds_query(cmd_buffer, RADV_SHADER_QUERY_MS_INVOCATION_OFFSET, va + mesh_invoc_offset);
+            gfx10_copy_gds_query_gfx(cmd_buffer, RADV_SHADER_QUERY_MS_INVOCATION_OFFSET, va + mesh_invoc_offset);
          }
 
          cmd_buffer->state.active_pipeline_gds_queries--;
@@ -2179,11 +2183,11 @@ emit_end_query(struct radv_cmd_buffer *cmd_buffer, struct radv_query_pool *pool,
    case VK_QUERY_TYPE_TRANSFORM_FEEDBACK_STREAM_EXT:
       if (cmd_buffer->device->physical_device->use_ngg_streamout) {
          /* generated prim counter */
-         gfx10_copy_gds_query(cmd_buffer, RADV_SHADER_QUERY_PRIM_GEN_OFFSET(index), va + 16);
+         gfx10_copy_gds_query_gfx(cmd_buffer, RADV_SHADER_QUERY_PRIM_GEN_OFFSET(index), va + 16);
          radv_cs_write_data_imm(cs, V_370_ME, va + 20, 0x80000000);
 
          /* written prim counter */
-         gfx10_copy_gds_query(cmd_buffer, RADV_SHADER_QUERY_PRIM_XFB_OFFSET(index), va + 24);
+         gfx10_copy_gds_query_gfx(cmd_buffer, RADV_SHADER_QUERY_PRIM_XFB_OFFSET(index), va + 24);
          radv_cs_write_data_imm(cs, V_370_ME, va + 28, 0x80000000);
 
          cmd_buffer->state.active_prims_xfb_gds_queries--;
@@ -2201,7 +2205,7 @@ emit_end_query(struct radv_cmd_buffer *cmd_buffer, struct radv_query_pool *pool,
    case VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT: {
       if (cmd_buffer->device->physical_device->rad_info.gfx_level >= GFX11) {
          /* On GFX11+, primitives generated query always use GDS. */
-         gfx10_copy_gds_query(cmd_buffer, RADV_SHADER_QUERY_PRIM_GEN_OFFSET(index), va + 16);
+         gfx10_copy_gds_query_gfx(cmd_buffer, RADV_SHADER_QUERY_PRIM_GEN_OFFSET(index), va + 16);
          radv_cs_write_data_imm(cs, V_370_ME, va + 20, 0x80000000);
 
          cmd_buffer->state.active_prims_gen_gds_queries--;
@@ -2225,7 +2229,7 @@ emit_end_query(struct radv_cmd_buffer *cmd_buffer, struct radv_query_pool *pool,
 
          if (pool->uses_gds) {
             /* generated prim counter */
-            gfx10_copy_gds_query(cmd_buffer, RADV_SHADER_QUERY_PRIM_GEN_OFFSET(index), va + 40);
+            gfx10_copy_gds_query_gfx(cmd_buffer, RADV_SHADER_QUERY_PRIM_GEN_OFFSET(index), va + 40);
             radv_cs_write_data_imm(cs, V_370_ME, va + 44, 0x80000000);
 
             cmd_buffer->state.active_prims_gen_gds_queries--;
@@ -2243,7 +2247,7 @@ emit_end_query(struct radv_cmd_buffer *cmd_buffer, struct radv_query_pool *pool,
       break;
    }
    case VK_QUERY_TYPE_MESH_PRIMITIVES_GENERATED_EXT: {
-      gfx10_copy_gds_query(cmd_buffer, RADV_SHADER_QUERY_MS_PRIM_GEN_OFFSET, va + 8);
+      gfx10_copy_gds_query_gfx(cmd_buffer, RADV_SHADER_QUERY_MS_PRIM_GEN_OFFSET, va + 8);
       radv_cs_write_data_imm(cs, V_370_ME, va + 12, 0x80000000);
 
       cmd_buffer->state.active_prims_gen_gds_queries--;
-- 
GitLab


From 2ef4f9d256d4ec850696175e33e2adc2d9f36632 Mon Sep 17 00:00:00 2001
From: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date: Fri, 27 Oct 2023 16:54:29 +0200
Subject: [PATCH 08/10] radv: make some gang functions non-static

They will be used to create a gang CS when beginning a query if not
already present.

Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
---
 src/amd/vulkan/radv_cmd_buffer.c | 4 ++--
 src/amd/vulkan/radv_private.h    | 3 +++
 2 files changed, 5 insertions(+), 2 deletions(-)

diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index b5aa719cb33cc..5363f35aaf77c 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -581,7 +581,7 @@ radv_gang_barrier(struct radv_cmd_buffer *cmd_buffer, VkPipelineStageFlags2 src_
       cmd_buffer->gang.sem.leader_value++;
 }
 
-static void
+void
 radv_gang_cache_flush(struct radv_cmd_buffer *cmd_buffer)
 {
    struct radeon_cmdbuf *ace_cs = cmd_buffer->gang.cs;
@@ -689,7 +689,7 @@ radv_wait_gang_follower(struct radv_cmd_buffer *cmd_buffer)
    radv_wait_gang_semaphore(cmd_buffer, cmd_buffer->cs, cmd_buffer->qf, 4, cmd_buffer->gang.sem.follower_value);
 }
 
-static bool
+bool
 radv_gang_init(struct radv_cmd_buffer *cmd_buffer)
 {
    if (cmd_buffer->gang.cs)
diff --git a/src/amd/vulkan/radv_private.h b/src/amd/vulkan/radv_private.h
index 8c9ebe2302aa4..6069e50be7103 100644
--- a/src/amd/vulkan/radv_private.h
+++ b/src/amd/vulkan/radv_private.h
@@ -3693,6 +3693,9 @@ void radv_destroy_ray_tracing_pipeline(struct radv_device *device, struct radv_r
 void radv_begin_conditional_rendering(struct radv_cmd_buffer *cmd_buffer, uint64_t va, bool draw_visible);
 void radv_end_conditional_rendering(struct radv_cmd_buffer *cmd_buffer);
 
+bool radv_gang_init(struct radv_cmd_buffer *cmd_buffer);
+void radv_gang_cache_flush(struct radv_cmd_buffer *cmd_buffer);
+
 #define RADV_FROM_HANDLE(__radv_type, __name, __handle) VK_FROM_HANDLE(__radv_type, __name, __handle)
 
 VK_DEFINE_HANDLE_CASTS(radv_cmd_buffer, vk.base, VkCommandBuffer, VK_OBJECT_TYPE_COMMAND_BUFFER)
-- 
GitLab


From 92d52225d5d8224ba2ee1efa16aa8a2d7fc41916 Mon Sep 17 00:00:00 2001
From: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date: Fri, 27 Oct 2023 16:54:55 +0200
Subject: [PATCH 09/10] radv: add support for task shader invocations queries
 on GFX10.3

Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
---
 src/amd/vulkan/radv_cmd_buffer.c |  39 +++++++++++-
 src/amd/vulkan/radv_private.h    |   2 +
 src/amd/vulkan/radv_query.c      | 104 ++++++++++++++++++++++++++++++-
 3 files changed, 140 insertions(+), 5 deletions(-)

diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index 5363f35aaf77c..b6b32e1915849 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -5149,15 +5149,13 @@ radv_flush_streamout_descriptors(struct radv_cmd_buffer *cmd_buffer)
 }
 
 static void
-radv_flush_shader_query_state(struct radv_cmd_buffer *cmd_buffer)
+radv_flush_shader_query_state_gfx(struct radv_cmd_buffer *cmd_buffer)
 {
    const struct radv_shader *last_vgt_shader = cmd_buffer->state.last_vgt_shader;
    const struct radv_userdata_info *loc = radv_get_user_sgpr(last_vgt_shader, AC_UD_SHADER_QUERY_STATE);
    enum radv_shader_query_state shader_query_state = radv_shader_query_none;
    uint32_t base_reg;
 
-   cmd_buffer->state.dirty &= ~RADV_CMD_DIRTY_SHADER_QUERY;
-
    if (loc->sgpr_idx == -1)
       return;
 
@@ -5186,6 +5184,41 @@ radv_flush_shader_query_state(struct radv_cmd_buffer *cmd_buffer)
    radeon_set_sh_reg(cmd_buffer->cs, base_reg + loc->sgpr_idx * 4, shader_query_state);
 }
 
+static void
+radv_flush_shader_query_state_ace(struct radv_cmd_buffer *cmd_buffer, struct radv_shader *task_shader)
+{
+   const struct radv_userdata_info *loc = radv_get_user_sgpr(task_shader, AC_UD_SHADER_QUERY_STATE);
+   enum radv_shader_query_state shader_query_state = radv_shader_query_none;
+   uint32_t base_reg;
+
+   if (loc->sgpr_idx == -1)
+      return;
+
+   /* By default shader queries are disabled but they are enabled if the command buffer has active ACE
+    * queries or if it's a secondary command buffer that inherits the number of task shader
+    * invocations query.
+    */
+   if (cmd_buffer->state.active_pipeline_ace_queries ||
+       (cmd_buffer->state.inherited_pipeline_statistics & VK_QUERY_PIPELINE_STATISTIC_TASK_SHADER_INVOCATIONS_BIT_EXT))
+      shader_query_state |= radv_shader_query_pipeline_stat;
+
+   base_reg = task_shader->info.user_data_0;
+   assert(loc->sgpr_idx != -1);
+
+   radeon_set_sh_reg(cmd_buffer->gang.cs, base_reg + loc->sgpr_idx * 4, shader_query_state);
+}
+
+static void
+radv_flush_shader_query_state(struct radv_cmd_buffer *cmd_buffer)
+{
+   radv_flush_shader_query_state_gfx(cmd_buffer);
+
+   if (radv_cmdbuf_has_stage(cmd_buffer, MESA_SHADER_TASK))
+      radv_flush_shader_query_state_ace(cmd_buffer, cmd_buffer->state.shaders[MESA_SHADER_TASK]);
+
+   cmd_buffer->state.dirty &= ~RADV_CMD_DIRTY_SHADER_QUERY;
+}
+
 static void
 radv_flush_force_vrs_state(struct radv_cmd_buffer *cmd_buffer)
 {
diff --git a/src/amd/vulkan/radv_private.h b/src/amd/vulkan/radv_private.h
index 6069e50be7103..f6471c8535aaa 100644
--- a/src/amd/vulkan/radv_private.h
+++ b/src/amd/vulkan/radv_private.h
@@ -1658,6 +1658,7 @@ struct radv_cmd_state {
    bool perfect_occlusion_queries_enabled;
    unsigned active_pipeline_queries;
    unsigned active_pipeline_gds_queries;
+   unsigned active_pipeline_ace_queries; /* Task shader invocations query */
    unsigned active_prims_gen_queries;
    unsigned active_prims_xfb_queries;
    unsigned active_prims_gen_gds_queries;
@@ -2985,6 +2986,7 @@ struct radv_query_pool {
    uint64_t size;
    char *ptr;
    bool uses_gds; /* For NGG GS on GFX10+ */
+   bool uses_ace; /* For task shader invocations on GFX10.3+ */
 };
 
 struct radv_perfcounter_impl;
diff --git a/src/amd/vulkan/radv_query.c b/src/amd/vulkan/radv_query.c
index c26688f01c5c9..ebb076bcc5384 100644
--- a/src/amd/vulkan/radv_query.c
+++ b/src/amd/vulkan/radv_query.c
@@ -280,6 +280,7 @@ build_pipeline_statistics_query_shader(struct radv_device *device)
 
    nir_variable *output_offset = nir_local_variable_create(b.impl, glsl_int_type(), "output_offset");
    nir_variable *result = nir_local_variable_create(b.impl, glsl_int64_t_type(), "result");
+   nir_variable *available = nir_local_variable_create(b.impl, glsl_bool_type(), "available");
 
    nir_def *flags = nir_load_push_constant(&b, 1, 32, nir_imm_int(&b, 0), .range = 4);
    nir_def *stats_mask = nir_load_push_constant(&b, 1, 32, nir_imm_int(&b, 8), .range = 12);
@@ -298,15 +299,34 @@ build_pipeline_statistics_query_shader(struct radv_device *device)
    avail_offset = nir_iadd(&b, avail_offset, nir_imul_imm(&b, global_id, 4));
 
    nir_def *available32 = nir_load_ssbo(&b, 1, 32, src_buf, avail_offset);
+   nir_store_var(&b, available, nir_i2b(&b, available32), 0x1);
+
+   nir_push_if(&b, nir_test_mask(&b, stats_mask, VK_QUERY_PIPELINE_STATISTIC_TASK_SHADER_INVOCATIONS_BIT_EXT));
+   {
+      const uint32_t idx = ffs(VK_QUERY_PIPELINE_STATISTIC_TASK_SHADER_INVOCATIONS_BIT_EXT) - 1;
+
+      nir_def *avail_start_offset = nir_iadd_imm(&b, input_base, pipeline_statistics_indices[idx] * 8 + 4);
+      nir_def *avail_start = nir_load_ssbo(&b, 1, 32, src_buf, avail_start_offset);
+
+      nir_def *avail_end_offset =
+         nir_iadd_imm(&b, input_base, pipeline_statistics_indices[idx] * 8 + pipelinestat_block_size + 4);
+      nir_def *avail_end = nir_load_ssbo(&b, 1, 32, src_buf, avail_end_offset);
+
+      nir_def *task_invoc_result_available =
+         nir_i2b(&b, nir_iand_imm(&b, nir_iand(&b, avail_start, avail_end), 0x80000000));
+
+      nir_store_var(&b, available, nir_iand(&b, nir_load_var(&b, available), task_invoc_result_available), 0x1);
+   }
+   nir_pop_if(&b, NULL);
 
    nir_def *result_is_64bit = nir_test_mask(&b, flags, VK_QUERY_RESULT_64_BIT);
    nir_def *elem_size = nir_bcsel(&b, result_is_64bit, nir_imm_int(&b, 8), nir_imm_int(&b, 4));
    nir_def *elem_count = nir_ushr_imm(&b, stats_mask, 16);
 
    radv_store_availability(&b, flags, dst_buf, nir_iadd(&b, output_base, nir_imul(&b, elem_count, elem_size)),
-                           available32);
+                           nir_b2i32(&b, nir_load_var(&b, available)));
 
-   nir_push_if(&b, nir_i2b(&b, available32));
+   nir_push_if(&b, nir_load_var(&b, available));
 
    nir_store_var(&b, output_offset, output_base, 0x1);
    for (int i = 0; i < ARRAY_SIZE(pipeline_statistics_indices); ++i) {
@@ -1221,6 +1241,10 @@ radv_create_query_pool(struct radv_device *device, const VkQueryPoolCreateInfo *
        (pCreateInfo->queryType == VK_QUERY_TYPE_MESH_PRIMITIVES_GENERATED_EXT ||
         pool->vk.pipeline_statistics & VK_QUERY_PIPELINE_STATISTIC_MESH_SHADER_INVOCATIONS_BIT_EXT));
 
+   /* The number of task shader invocations needs to be queried on ACE. */
+   pool->uses_ace = device->physical_device->emulate_mesh_shader_queries &&
+                    (pool->vk.pipeline_statistics & VK_QUERY_PIPELINE_STATISTIC_TASK_SHADER_INVOCATIONS_BIT_EXT);
+
    switch (pCreateInfo->queryType) {
    case VK_QUERY_TYPE_OCCLUSION:
       pool->stride = 16 * device->physical_device->rad_info.max_render_backends;
@@ -1399,6 +1423,17 @@ radv_GetQueryPoolResults(VkDevice _device, VkQueryPool queryPool, uint32_t first
 
          do {
             available = p_atomic_read(avail_ptr);
+
+            if (pool->uses_ace) {
+               const uint32_t task_invoc_offset =
+                  radv_get_pipelinestat_query_offset(VK_QUERY_PIPELINE_STATISTIC_TASK_SHADER_INVOCATIONS_BIT_EXT);
+               const uint32_t *avail_ptr_start = (const uint32_t *)(src + task_invoc_offset + 4);
+               const uint32_t *avail_ptr_stop =
+                  (const uint32_t *)(src + pipelinestat_block_size + task_invoc_offset + 4);
+
+               if (!(p_atomic_read(avail_ptr_start) & 0x80000000) || !(p_atomic_read(avail_ptr_stop) & 0x80000000))
+                  available = 0;
+            }
          } while (!available && (flags & VK_QUERY_RESULT_WAIT_BIT));
 
          if (!available && !(flags & VK_QUERY_RESULT_PARTIAL_BIT))
@@ -1667,6 +1702,10 @@ radv_CmdCopyQueryPoolResults(VkCommandBuffer commandBuffer, VkQueryPool queryPoo
       break;
    case VK_QUERY_TYPE_PIPELINE_STATISTICS:
       if (flags & VK_QUERY_RESULT_WAIT_BIT) {
+         const uint32_t task_invoc_offset =
+            radv_get_pipelinestat_query_offset(VK_QUERY_PIPELINE_STATISTIC_TASK_SHADER_INVOCATIONS_BIT_EXT);
+         const unsigned pipelinestat_block_size = radv_get_pipelinestat_query_size(cmd_buffer->device);
+
          for (unsigned i = 0; i < queryCount; ++i, dest_va += stride) {
             unsigned query = firstQuery + i;
 
@@ -1676,6 +1715,17 @@ radv_CmdCopyQueryPoolResults(VkCommandBuffer commandBuffer, VkQueryPool queryPoo
 
             /* This waits on the ME. All copies below are done on the ME */
             radv_cp_wait_mem(cs, cmd_buffer->qf, WAIT_REG_MEM_EQUAL, avail_va, 1, 0xffffffff);
+
+            if (pool->uses_ace) {
+               const uint64_t src_va = va + query * pool->stride;
+               const uint64_t start_va = src_va + task_invoc_offset + 4;
+               const uint64_t stop_va = start_va + pipelinestat_block_size;
+
+               radeon_check_space(cmd_buffer->device->ws, cs, 7 * 2);
+
+               radv_cp_wait_mem(cs, cmd_buffer->qf, WAIT_REG_MEM_GREATER_OR_EQUAL, start_va, 0x80000000, 0xffffffff);
+               radv_cp_wait_mem(cs, cmd_buffer->qf, WAIT_REG_MEM_GREATER_OR_EQUAL, stop_va, 0x80000000, 0xffffffff);
+            }
          }
       }
       radv_query_shader(cmd_buffer, &cmd_buffer->device->meta_state.query.pipeline_statistics_query_pipeline, pool->bo,
@@ -1889,6 +1939,16 @@ gfx10_copy_gds_query_gfx(struct radv_cmd_buffer *cmd_buffer, uint32_t gds_offset
    gfx10_copy_gds_query(cmd_buffer->cs, gds_offset, va);
 }
 
+static void
+gfx10_copy_gds_query_ace(struct radv_cmd_buffer *cmd_buffer, uint32_t gds_offset, uint64_t va)
+{
+   /* Make sure GDS is idle before copying the value. */
+   cmd_buffer->gang.flush_bits |= RADV_CMD_FLAG_CS_PARTIAL_FLUSH | RADV_CMD_FLAG_INV_L2;
+   radv_gang_cache_flush(cmd_buffer);
+
+   gfx10_copy_gds_query(cmd_buffer->gang.cs, gds_offset, va);
+}
+
 static void
 radv_update_hw_pipelinestat(struct radv_cmd_buffer *cmd_buffer)
 {
@@ -1996,6 +2056,24 @@ emit_begin_query(struct radv_cmd_buffer *cmd_buffer, struct radv_query_pool *poo
 
          cmd_buffer->state.active_pipeline_gds_queries++;
       }
+
+      if (pool->uses_ace) {
+         uint32_t task_invoc_offset =
+            radv_get_pipelinestat_query_offset(VK_QUERY_PIPELINE_STATISTIC_TASK_SHADER_INVOCATIONS_BIT_EXT);
+
+         radeon_check_space(cmd_buffer->device->ws, cmd_buffer->gang.cs, 11);
+
+         gfx10_copy_gds_query_ace(cmd_buffer, RADV_SHADER_QUERY_TS_INVOCATION_OFFSET, va + task_invoc_offset);
+         radv_cs_write_data_imm(cmd_buffer->gang.cs, V_370_ME, va + task_invoc_offset + 4, 0x80000000);
+
+         /* Record that the command buffer needs GDS. */
+         cmd_buffer->gds_needed = true;
+
+         if (!cmd_buffer->state.active_pipeline_ace_queries)
+            cmd_buffer->state.dirty |= RADV_CMD_DIRTY_SHADER_QUERY;
+
+         cmd_buffer->state.active_pipeline_ace_queries++;
+      }
       break;
    }
    case VK_QUERY_TYPE_TRANSFORM_FEEDBACK_STREAM_EXT:
@@ -2175,6 +2253,21 @@ emit_end_query(struct radv_cmd_buffer *cmd_buffer, struct radv_query_pool *pool,
             cmd_buffer->state.dirty |= RADV_CMD_DIRTY_SHADER_QUERY;
       }
 
+      if (pool->uses_ace) {
+         uint32_t task_invoc_offset =
+            radv_get_pipelinestat_query_offset(VK_QUERY_PIPELINE_STATISTIC_TASK_SHADER_INVOCATIONS_BIT_EXT);
+
+         radeon_check_space(cmd_buffer->device->ws, cmd_buffer->gang.cs, 11);
+
+         gfx10_copy_gds_query_ace(cmd_buffer, RADV_SHADER_QUERY_TS_INVOCATION_OFFSET, va + task_invoc_offset);
+         radv_cs_write_data_imm(cmd_buffer->gang.cs, V_370_ME, va + task_invoc_offset + 4, 0x80000000);
+
+         cmd_buffer->state.active_pipeline_ace_queries--;
+
+         if (!cmd_buffer->state.active_pipeline_ace_queries)
+            cmd_buffer->state.dirty |= RADV_CMD_DIRTY_SHADER_QUERY;
+      }
+
       si_cs_emit_write_event_eop(cs, cmd_buffer->device->physical_device->rad_info.gfx_level, cmd_buffer->qf,
                                  V_028A90_BOTTOM_OF_PIPE_TS, 0, EOP_DST_SEL_MEM, EOP_DATA_SEL_VALUE_32BIT, avail_va, 1,
                                  cmd_buffer->gfx9_eop_bug_va);
@@ -2282,6 +2375,13 @@ radv_CmdBeginQueryIndexedEXT(VkCommandBuffer commandBuffer, VkQueryPool queryPoo
 
    va += pool->stride * query;
 
+   if (pool->uses_ace) {
+      if (!radv_gang_init(cmd_buffer))
+         return;
+
+      radv_cs_add_buffer(cmd_buffer->device->ws, cmd_buffer->gang.cs, pool->bo);
+   }
+
    emit_begin_query(cmd_buffer, pool, va, pool->vk.query_type, flags, index);
 }
 
-- 
GitLab


From 48b5c6726de5c631bc82948020bfb0ff3b4dcaf6 Mon Sep 17 00:00:00 2001
From: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date: Wed, 20 Sep 2023 16:09:37 +0200
Subject: [PATCH 10/10] radv: enable meshShaderQueries on GFX10.3

GFX11 support will come later.

Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
---
 src/amd/ci/radv-navi21-aco-fails.txt  | 242 ++++++++++++++++++++++++++
 src/amd/vulkan/radv_physical_device.c |   2 +-
 2 files changed, 243 insertions(+), 1 deletion(-)

diff --git a/src/amd/ci/radv-navi21-aco-fails.txt b/src/amd/ci/radv-navi21-aco-fails.txt
index d94dff9ce448f..224e2795c20bb 100644
--- a/src/amd/ci/radv-navi21-aco-fails.txt
+++ b/src/amd/ci/radv-navi21-aco-fails.txt
@@ -69,3 +69,245 @@ dEQP-VK.fragment_shading_rate.renderpass2.monolithic.fragstencil_baselevel.dynam
 dEQP-VK.fragment_shading_rate.renderpass2.monolithic.fragstencil_baselevel.dynamic.attachment.shaderrate.replace.replace.4x4.samples1.vs,Crash
 dEQP-VK.query_pool.frag_invocations.frag_invs.primary,Fail
 dEQP-VK.query_pool.frag_invocations.frag_invs.secondary,Fail
+
+# Mesh shader lines bug (likely a RADV bug).
+dEQP-VK.mesh_shader.ext.query.all_queries.lines.host_reset.copy.no_wait.draw.32bit.no_availability.multiple_blocks.mesh_only.include_rp.single_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.all_queries.lines.host_reset.copy.no_wait.draw.32bit.no_availability.multiple_blocks.mesh_only.inside_rp.multi_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.all_queries.lines.host_reset.copy.no_wait.draw.32bit.no_availability.multiple_blocks.mesh_only.inside_rp.multi_view.with_secondary,Fail
+dEQP-VK.mesh_shader.ext.query.all_queries.lines.host_reset.copy.no_wait.draw.32bit.no_availability.multiple_blocks.mesh_only.inside_rp.single_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.all_queries.lines.host_reset.copy.no_wait.draw.32bit.no_availability.multiple_blocks.mesh_only.inside_rp.single_view.with_secondary,Fail
+dEQP-VK.mesh_shader.ext.query.all_queries.lines.host_reset.copy.no_wait.draw.32bit.no_availability.multiple_blocks.task_mesh.include_rp.single_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.all_queries.lines.host_reset.copy.no_wait.draw.32bit.no_availability.multiple_blocks.task_mesh.inside_rp.multi_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.all_queries.lines.host_reset.copy.no_wait.draw.32bit.no_availability.multiple_blocks.task_mesh.inside_rp.multi_view.with_secondary,Fail
+dEQP-VK.mesh_shader.ext.query.all_queries.lines.host_reset.copy.no_wait.draw.32bit.no_availability.multiple_blocks.task_mesh.inside_rp.single_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.all_queries.lines.host_reset.copy.no_wait.draw.32bit.no_availability.multiple_blocks.task_mesh.inside_rp.single_view.with_secondary,Fail
+dEQP-VK.mesh_shader.ext.query.all_queries.lines.host_reset.copy.wait.draw.32bit.no_availability.multiple_blocks.mesh_only.include_rp.single_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.all_queries.lines.host_reset.copy.wait.draw.32bit.no_availability.multiple_blocks.mesh_only.inside_rp.multi_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.all_queries.lines.host_reset.copy.wait.draw.32bit.no_availability.multiple_blocks.mesh_only.inside_rp.multi_view.with_secondary,Fail
+dEQP-VK.mesh_shader.ext.query.all_queries.lines.host_reset.copy.wait.draw.32bit.no_availability.multiple_blocks.mesh_only.inside_rp.single_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.all_queries.lines.host_reset.copy.wait.draw.32bit.no_availability.multiple_blocks.mesh_only.inside_rp.single_view.with_secondary,Fail
+dEQP-VK.mesh_shader.ext.query.all_queries.lines.host_reset.copy.wait.draw.32bit.no_availability.multiple_blocks.task_mesh.include_rp.single_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.all_queries.lines.host_reset.copy.wait.draw.32bit.no_availability.multiple_blocks.task_mesh.inside_rp.multi_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.all_queries.lines.host_reset.copy.wait.draw.32bit.no_availability.multiple_blocks.task_mesh.inside_rp.multi_view.with_secondary,Fail
+dEQP-VK.mesh_shader.ext.query.all_queries.lines.host_reset.copy.wait.draw.32bit.no_availability.multiple_blocks.task_mesh.inside_rp.single_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.all_queries.lines.host_reset.copy.wait.draw.32bit.no_availability.multiple_blocks.task_mesh.inside_rp.single_view.with_secondary,Fail
+dEQP-VK.mesh_shader.ext.query.all_queries.lines.host_reset.get.no_wait.draw.32bit.no_availability.multiple_blocks.mesh_only.include_rp.single_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.all_queries.lines.host_reset.get.no_wait.draw.32bit.no_availability.multiple_blocks.mesh_only.inside_rp.multi_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.all_queries.lines.host_reset.get.no_wait.draw.32bit.no_availability.multiple_blocks.mesh_only.inside_rp.multi_view.with_secondary,Fail
+dEQP-VK.mesh_shader.ext.query.all_queries.lines.host_reset.get.no_wait.draw.32bit.no_availability.multiple_blocks.mesh_only.inside_rp.single_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.all_queries.lines.host_reset.get.no_wait.draw.32bit.no_availability.multiple_blocks.mesh_only.inside_rp.single_view.with_secondary,Fail
+dEQP-VK.mesh_shader.ext.query.all_queries.lines.host_reset.get.no_wait.draw.32bit.no_availability.multiple_blocks.task_mesh.include_rp.single_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.all_queries.lines.host_reset.get.no_wait.draw.32bit.no_availability.multiple_blocks.task_mesh.inside_rp.multi_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.all_queries.lines.host_reset.get.no_wait.draw.32bit.no_availability.multiple_blocks.task_mesh.inside_rp.multi_view.with_secondary,Fail
+dEQP-VK.mesh_shader.ext.query.all_queries.lines.host_reset.get.no_wait.draw.32bit.no_availability.multiple_blocks.task_mesh.inside_rp.single_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.all_queries.lines.host_reset.get.no_wait.draw.32bit.no_availability.multiple_blocks.task_mesh.inside_rp.single_view.with_secondary,Fail
+dEQP-VK.mesh_shader.ext.query.all_queries.lines.host_reset.get.wait.draw.32bit.no_availability.multiple_blocks.mesh_only.include_rp.single_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.all_queries.lines.host_reset.get.wait.draw.32bit.no_availability.multiple_blocks.mesh_only.inside_rp.multi_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.all_queries.lines.host_reset.get.wait.draw.32bit.no_availability.multiple_blocks.mesh_only.inside_rp.multi_view.with_secondary,Fail
+dEQP-VK.mesh_shader.ext.query.all_queries.lines.host_reset.get.wait.draw.32bit.no_availability.multiple_blocks.mesh_only.inside_rp.single_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.all_queries.lines.host_reset.get.wait.draw.32bit.no_availability.multiple_blocks.mesh_only.inside_rp.single_view.with_secondary,Fail
+dEQP-VK.mesh_shader.ext.query.all_queries.lines.host_reset.get.wait.draw.32bit.no_availability.multiple_blocks.task_mesh.include_rp.single_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.all_queries.lines.host_reset.get.wait.draw.32bit.no_availability.multiple_blocks.task_mesh.inside_rp.multi_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.all_queries.lines.host_reset.get.wait.draw.32bit.no_availability.multiple_blocks.task_mesh.inside_rp.multi_view.with_secondary,Fail
+dEQP-VK.mesh_shader.ext.query.all_queries.lines.host_reset.get.wait.draw.32bit.no_availability.multiple_blocks.task_mesh.inside_rp.single_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.all_queries.lines.host_reset.get.wait.draw.32bit.no_availability.multiple_blocks.task_mesh.inside_rp.single_view.with_secondary,Fail
+dEQP-VK.mesh_shader.ext.query.all_queries.lines.no_reset.copy.no_wait.draw.32bit.no_availability.multiple_blocks.mesh_only.include_rp.single_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.all_queries.lines.no_reset.copy.no_wait.draw.32bit.no_availability.multiple_blocks.mesh_only.inside_rp.multi_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.all_queries.lines.no_reset.copy.no_wait.draw.32bit.no_availability.multiple_blocks.mesh_only.inside_rp.multi_view.with_secondary,Fail
+dEQP-VK.mesh_shader.ext.query.all_queries.lines.no_reset.copy.no_wait.draw.32bit.no_availability.multiple_blocks.mesh_only.inside_rp.single_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.all_queries.lines.no_reset.copy.no_wait.draw.32bit.no_availability.multiple_blocks.mesh_only.inside_rp.single_view.with_secondary,Fail
+dEQP-VK.mesh_shader.ext.query.all_queries.lines.no_reset.copy.no_wait.draw.32bit.no_availability.multiple_blocks.task_mesh.include_rp.single_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.all_queries.lines.no_reset.copy.no_wait.draw.32bit.no_availability.multiple_blocks.task_mesh.inside_rp.multi_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.all_queries.lines.no_reset.copy.no_wait.draw.32bit.no_availability.multiple_blocks.task_mesh.inside_rp.multi_view.with_secondary,Fail
+dEQP-VK.mesh_shader.ext.query.all_queries.lines.no_reset.copy.no_wait.draw.32bit.no_availability.multiple_blocks.task_mesh.inside_rp.single_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.all_queries.lines.no_reset.copy.no_wait.draw.32bit.no_availability.multiple_blocks.task_mesh.inside_rp.single_view.with_secondary,Fail
+dEQP-VK.mesh_shader.ext.query.all_queries.lines.no_reset.copy.wait.draw.32bit.no_availability.multiple_blocks.mesh_only.include_rp.single_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.all_queries.lines.no_reset.copy.wait.draw.32bit.no_availability.multiple_blocks.mesh_only.inside_rp.multi_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.all_queries.lines.no_reset.copy.wait.draw.32bit.no_availability.multiple_blocks.mesh_only.inside_rp.multi_view.with_secondary,Fail
+dEQP-VK.mesh_shader.ext.query.all_queries.lines.no_reset.copy.wait.draw.32bit.no_availability.multiple_blocks.mesh_only.inside_rp.single_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.all_queries.lines.no_reset.copy.wait.draw.32bit.no_availability.multiple_blocks.mesh_only.inside_rp.single_view.with_secondary,Fail
+dEQP-VK.mesh_shader.ext.query.all_queries.lines.no_reset.copy.wait.draw.32bit.no_availability.multiple_blocks.task_mesh.include_rp.single_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.all_queries.lines.no_reset.copy.wait.draw.32bit.no_availability.multiple_blocks.task_mesh.inside_rp.multi_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.all_queries.lines.no_reset.copy.wait.draw.32bit.no_availability.multiple_blocks.task_mesh.inside_rp.multi_view.with_secondary,Fail
+dEQP-VK.mesh_shader.ext.query.all_queries.lines.no_reset.copy.wait.draw.32bit.no_availability.multiple_blocks.task_mesh.inside_rp.single_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.all_queries.lines.no_reset.copy.wait.draw.32bit.no_availability.multiple_blocks.task_mesh.inside_rp.single_view.with_secondary,Fail
+dEQP-VK.mesh_shader.ext.query.all_queries.lines.no_reset.get.no_wait.draw.32bit.no_availability.multiple_blocks.mesh_only.include_rp.single_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.all_queries.lines.no_reset.get.no_wait.draw.32bit.no_availability.multiple_blocks.mesh_only.inside_rp.multi_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.all_queries.lines.no_reset.get.no_wait.draw.32bit.no_availability.multiple_blocks.mesh_only.inside_rp.multi_view.with_secondary,Fail
+dEQP-VK.mesh_shader.ext.query.all_queries.lines.no_reset.get.no_wait.draw.32bit.no_availability.multiple_blocks.mesh_only.inside_rp.single_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.all_queries.lines.no_reset.get.no_wait.draw.32bit.no_availability.multiple_blocks.mesh_only.inside_rp.single_view.with_secondary,Fail
+dEQP-VK.mesh_shader.ext.query.all_queries.lines.no_reset.get.no_wait.draw.32bit.no_availability.multiple_blocks.task_mesh.include_rp.single_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.all_queries.lines.no_reset.get.no_wait.draw.32bit.no_availability.multiple_blocks.task_mesh.inside_rp.multi_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.all_queries.lines.no_reset.get.no_wait.draw.32bit.no_availability.multiple_blocks.task_mesh.inside_rp.multi_view.with_secondary,Fail
+dEQP-VK.mesh_shader.ext.query.all_queries.lines.no_reset.get.no_wait.draw.32bit.no_availability.multiple_blocks.task_mesh.inside_rp.single_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.all_queries.lines.no_reset.get.no_wait.draw.32bit.no_availability.multiple_blocks.task_mesh.inside_rp.single_view.with_secondary,Fail
+dEQP-VK.mesh_shader.ext.query.all_queries.lines.no_reset.get.wait.draw.32bit.no_availability.multiple_blocks.mesh_only.include_rp.single_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.all_queries.lines.no_reset.get.wait.draw.32bit.no_availability.multiple_blocks.mesh_only.inside_rp.multi_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.all_queries.lines.no_reset.get.wait.draw.32bit.no_availability.multiple_blocks.mesh_only.inside_rp.multi_view.with_secondary,Fail
+dEQP-VK.mesh_shader.ext.query.all_queries.lines.no_reset.get.wait.draw.32bit.no_availability.multiple_blocks.mesh_only.inside_rp.single_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.all_queries.lines.no_reset.get.wait.draw.32bit.no_availability.multiple_blocks.mesh_only.inside_rp.single_view.with_secondary,Fail
+dEQP-VK.mesh_shader.ext.query.all_queries.lines.no_reset.get.wait.draw.32bit.no_availability.multiple_blocks.task_mesh.include_rp.single_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.all_queries.lines.no_reset.get.wait.draw.32bit.no_availability.multiple_blocks.task_mesh.inside_rp.multi_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.all_queries.lines.no_reset.get.wait.draw.32bit.no_availability.multiple_blocks.task_mesh.inside_rp.multi_view.with_secondary,Fail
+dEQP-VK.mesh_shader.ext.query.all_queries.lines.no_reset.get.wait.draw.32bit.no_availability.multiple_blocks.task_mesh.inside_rp.single_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.all_queries.lines.no_reset.get.wait.draw.32bit.no_availability.multiple_blocks.task_mesh.inside_rp.single_view.with_secondary,Fail
+dEQP-VK.mesh_shader.ext.query.all_queries.lines.reset_after.copy.no_wait.draw.32bit.no_availability.multiple_blocks.mesh_only.include_rp.single_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.all_queries.lines.reset_after.copy.no_wait.draw.32bit.no_availability.multiple_blocks.mesh_only.inside_rp.multi_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.all_queries.lines.reset_after.copy.no_wait.draw.32bit.no_availability.multiple_blocks.mesh_only.inside_rp.multi_view.with_secondary,Fail
+dEQP-VK.mesh_shader.ext.query.all_queries.lines.reset_after.copy.no_wait.draw.32bit.no_availability.multiple_blocks.mesh_only.inside_rp.single_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.all_queries.lines.reset_after.copy.no_wait.draw.32bit.no_availability.multiple_blocks.mesh_only.inside_rp.single_view.with_secondary,Fail
+dEQP-VK.mesh_shader.ext.query.all_queries.lines.reset_after.copy.no_wait.draw.32bit.no_availability.multiple_blocks.task_mesh.include_rp.single_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.all_queries.lines.reset_after.copy.no_wait.draw.32bit.no_availability.multiple_blocks.task_mesh.inside_rp.multi_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.all_queries.lines.reset_after.copy.no_wait.draw.32bit.no_availability.multiple_blocks.task_mesh.inside_rp.multi_view.with_secondary,Fail
+dEQP-VK.mesh_shader.ext.query.all_queries.lines.reset_after.copy.no_wait.draw.32bit.no_availability.multiple_blocks.task_mesh.inside_rp.single_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.all_queries.lines.reset_after.copy.no_wait.draw.32bit.no_availability.multiple_blocks.task_mesh.inside_rp.single_view.with_secondary,Fail
+dEQP-VK.mesh_shader.ext.query.all_queries.lines.reset_after.copy.wait.draw.32bit.no_availability.multiple_blocks.mesh_only.include_rp.single_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.all_queries.lines.reset_after.copy.wait.draw.32bit.no_availability.multiple_blocks.mesh_only.inside_rp.multi_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.all_queries.lines.reset_after.copy.wait.draw.32bit.no_availability.multiple_blocks.mesh_only.inside_rp.multi_view.with_secondary,Fail
+dEQP-VK.mesh_shader.ext.query.all_queries.lines.reset_after.copy.wait.draw.32bit.no_availability.multiple_blocks.mesh_only.inside_rp.single_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.all_queries.lines.reset_after.copy.wait.draw.32bit.no_availability.multiple_blocks.mesh_only.inside_rp.single_view.with_secondary,Fail
+dEQP-VK.mesh_shader.ext.query.all_queries.lines.reset_after.copy.wait.draw.32bit.no_availability.multiple_blocks.task_mesh.include_rp.single_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.all_queries.lines.reset_after.copy.wait.draw.32bit.no_availability.multiple_blocks.task_mesh.inside_rp.multi_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.all_queries.lines.reset_after.copy.wait.draw.32bit.no_availability.multiple_blocks.task_mesh.inside_rp.multi_view.with_secondary,Fail
+dEQP-VK.mesh_shader.ext.query.all_queries.lines.reset_after.copy.wait.draw.32bit.no_availability.multiple_blocks.task_mesh.inside_rp.single_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.all_queries.lines.reset_after.copy.wait.draw.32bit.no_availability.multiple_blocks.task_mesh.inside_rp.single_view.with_secondary,Fail
+dEQP-VK.mesh_shader.ext.query.all_queries.lines.reset_before.copy.no_wait.draw.32bit.no_availability.multiple_blocks.mesh_only.include_rp.single_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.all_queries.lines.reset_before.copy.no_wait.draw.32bit.no_availability.multiple_blocks.mesh_only.inside_rp.multi_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.all_queries.lines.reset_before.copy.no_wait.draw.32bit.no_availability.multiple_blocks.mesh_only.inside_rp.multi_view.with_secondary,Fail
+dEQP-VK.mesh_shader.ext.query.all_queries.lines.reset_before.copy.no_wait.draw.32bit.no_availability.multiple_blocks.mesh_only.inside_rp.single_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.all_queries.lines.reset_before.copy.no_wait.draw.32bit.no_availability.multiple_blocks.mesh_only.inside_rp.single_view.with_secondary,Fail
+dEQP-VK.mesh_shader.ext.query.all_queries.lines.reset_before.copy.no_wait.draw.32bit.no_availability.multiple_blocks.task_mesh.include_rp.single_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.all_queries.lines.reset_before.copy.no_wait.draw.32bit.no_availability.multiple_blocks.task_mesh.inside_rp.multi_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.all_queries.lines.reset_before.copy.no_wait.draw.32bit.no_availability.multiple_blocks.task_mesh.inside_rp.multi_view.with_secondary,Fail
+dEQP-VK.mesh_shader.ext.query.all_queries.lines.reset_before.copy.no_wait.draw.32bit.no_availability.multiple_blocks.task_mesh.inside_rp.single_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.all_queries.lines.reset_before.copy.no_wait.draw.32bit.no_availability.multiple_blocks.task_mesh.inside_rp.single_view.with_secondary,Fail
+dEQP-VK.mesh_shader.ext.query.all_queries.lines.reset_before.get.no_wait.draw.32bit.no_availability.multiple_blocks.mesh_only.include_rp.single_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.all_queries.lines.reset_before.get.no_wait.draw.32bit.no_availability.multiple_blocks.mesh_only.inside_rp.multi_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.all_queries.lines.reset_before.get.no_wait.draw.32bit.no_availability.multiple_blocks.mesh_only.inside_rp.multi_view.with_secondary,Fail
+dEQP-VK.mesh_shader.ext.query.all_queries.lines.reset_before.get.no_wait.draw.32bit.no_availability.multiple_blocks.mesh_only.inside_rp.single_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.all_queries.lines.reset_before.get.no_wait.draw.32bit.no_availability.multiple_blocks.mesh_only.inside_rp.single_view.with_secondary,Fail
+dEQP-VK.mesh_shader.ext.query.all_queries.lines.reset_before.get.no_wait.draw.32bit.no_availability.multiple_blocks.task_mesh.include_rp.single_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.all_queries.lines.reset_before.get.no_wait.draw.32bit.no_availability.multiple_blocks.task_mesh.inside_rp.multi_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.all_queries.lines.reset_before.get.no_wait.draw.32bit.no_availability.multiple_blocks.task_mesh.inside_rp.multi_view.with_secondary,Fail
+dEQP-VK.mesh_shader.ext.query.all_queries.lines.reset_before.get.no_wait.draw.32bit.no_availability.multiple_blocks.task_mesh.inside_rp.single_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.all_queries.lines.reset_before.get.no_wait.draw.32bit.no_availability.multiple_blocks.task_mesh.inside_rp.single_view.with_secondary,Fail
+dEQP-VK.mesh_shader.ext.query.prim_query.lines.host_reset.copy.no_wait.draw.32bit.no_availability.multiple_blocks.mesh_only.include_rp.single_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.prim_query.lines.host_reset.copy.no_wait.draw.32bit.no_availability.multiple_blocks.mesh_only.inside_rp.multi_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.prim_query.lines.host_reset.copy.no_wait.draw.32bit.no_availability.multiple_blocks.mesh_only.inside_rp.multi_view.with_secondary,Fail
+dEQP-VK.mesh_shader.ext.query.prim_query.lines.host_reset.copy.no_wait.draw.32bit.no_availability.multiple_blocks.mesh_only.inside_rp.single_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.prim_query.lines.host_reset.copy.no_wait.draw.32bit.no_availability.multiple_blocks.mesh_only.inside_rp.single_view.with_secondary,Fail
+dEQP-VK.mesh_shader.ext.query.prim_query.lines.host_reset.copy.no_wait.draw.32bit.no_availability.multiple_blocks.task_mesh.include_rp.single_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.prim_query.lines.host_reset.copy.no_wait.draw.32bit.no_availability.multiple_blocks.task_mesh.inside_rp.multi_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.prim_query.lines.host_reset.copy.no_wait.draw.32bit.no_availability.multiple_blocks.task_mesh.inside_rp.multi_view.with_secondary,Fail
+dEQP-VK.mesh_shader.ext.query.prim_query.lines.host_reset.copy.no_wait.draw.32bit.no_availability.multiple_blocks.task_mesh.inside_rp.single_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.prim_query.lines.host_reset.copy.no_wait.draw.32bit.no_availability.multiple_blocks.task_mesh.inside_rp.single_view.with_secondary,Fail
+dEQP-VK.mesh_shader.ext.query.prim_query.lines.host_reset.copy.wait.draw.32bit.no_availability.multiple_blocks.mesh_only.include_rp.single_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.prim_query.lines.host_reset.copy.wait.draw.32bit.no_availability.multiple_blocks.mesh_only.inside_rp.multi_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.prim_query.lines.host_reset.copy.wait.draw.32bit.no_availability.multiple_blocks.mesh_only.inside_rp.multi_view.with_secondary,Fail
+dEQP-VK.mesh_shader.ext.query.prim_query.lines.host_reset.copy.wait.draw.32bit.no_availability.multiple_blocks.mesh_only.inside_rp.single_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.prim_query.lines.host_reset.copy.wait.draw.32bit.no_availability.multiple_blocks.mesh_only.inside_rp.single_view.with_secondary,Fail
+dEQP-VK.mesh_shader.ext.query.prim_query.lines.host_reset.copy.wait.draw.32bit.no_availability.multiple_blocks.task_mesh.include_rp.single_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.prim_query.lines.host_reset.copy.wait.draw.32bit.no_availability.multiple_blocks.task_mesh.inside_rp.multi_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.prim_query.lines.host_reset.copy.wait.draw.32bit.no_availability.multiple_blocks.task_mesh.inside_rp.multi_view.with_secondary,Fail
+dEQP-VK.mesh_shader.ext.query.prim_query.lines.host_reset.copy.wait.draw.32bit.no_availability.multiple_blocks.task_mesh.inside_rp.single_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.prim_query.lines.host_reset.copy.wait.draw.32bit.no_availability.multiple_blocks.task_mesh.inside_rp.single_view.with_secondary,Fail
+dEQP-VK.mesh_shader.ext.query.prim_query.lines.host_reset.get.no_wait.draw.32bit.no_availability.multiple_blocks.mesh_only.include_rp.single_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.prim_query.lines.host_reset.get.no_wait.draw.32bit.no_availability.multiple_blocks.mesh_only.inside_rp.multi_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.prim_query.lines.host_reset.get.no_wait.draw.32bit.no_availability.multiple_blocks.mesh_only.inside_rp.multi_view.with_secondary,Fail
+dEQP-VK.mesh_shader.ext.query.prim_query.lines.host_reset.get.no_wait.draw.32bit.no_availability.multiple_blocks.mesh_only.inside_rp.single_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.prim_query.lines.host_reset.get.no_wait.draw.32bit.no_availability.multiple_blocks.mesh_only.inside_rp.single_view.with_secondary,Fail
+dEQP-VK.mesh_shader.ext.query.prim_query.lines.host_reset.get.no_wait.draw.32bit.no_availability.multiple_blocks.task_mesh.include_rp.single_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.prim_query.lines.host_reset.get.no_wait.draw.32bit.no_availability.multiple_blocks.task_mesh.inside_rp.multi_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.prim_query.lines.host_reset.get.no_wait.draw.32bit.no_availability.multiple_blocks.task_mesh.inside_rp.multi_view.with_secondary,Fail
+dEQP-VK.mesh_shader.ext.query.prim_query.lines.host_reset.get.no_wait.draw.32bit.no_availability.multiple_blocks.task_mesh.inside_rp.single_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.prim_query.lines.host_reset.get.no_wait.draw.32bit.no_availability.multiple_blocks.task_mesh.inside_rp.single_view.with_secondary,Fail
+dEQP-VK.mesh_shader.ext.query.prim_query.lines.host_reset.get.wait.draw.32bit.no_availability.multiple_blocks.mesh_only.include_rp.single_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.prim_query.lines.host_reset.get.wait.draw.32bit.no_availability.multiple_blocks.mesh_only.inside_rp.multi_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.prim_query.lines.host_reset.get.wait.draw.32bit.no_availability.multiple_blocks.mesh_only.inside_rp.multi_view.with_secondary,Fail
+dEQP-VK.mesh_shader.ext.query.prim_query.lines.host_reset.get.wait.draw.32bit.no_availability.multiple_blocks.mesh_only.inside_rp.single_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.prim_query.lines.host_reset.get.wait.draw.32bit.no_availability.multiple_blocks.mesh_only.inside_rp.single_view.with_secondary,Fail
+dEQP-VK.mesh_shader.ext.query.prim_query.lines.host_reset.get.wait.draw.32bit.no_availability.multiple_blocks.task_mesh.include_rp.single_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.prim_query.lines.host_reset.get.wait.draw.32bit.no_availability.multiple_blocks.task_mesh.inside_rp.multi_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.prim_query.lines.host_reset.get.wait.draw.32bit.no_availability.multiple_blocks.task_mesh.inside_rp.multi_view.with_secondary,Fail
+dEQP-VK.mesh_shader.ext.query.prim_query.lines.host_reset.get.wait.draw.32bit.no_availability.multiple_blocks.task_mesh.inside_rp.single_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.prim_query.lines.host_reset.get.wait.draw.32bit.no_availability.multiple_blocks.task_mesh.inside_rp.single_view.with_secondary,Fail
+dEQP-VK.mesh_shader.ext.query.prim_query.lines.no_reset.copy.no_wait.draw.32bit.no_availability.multiple_blocks.mesh_only.include_rp.single_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.prim_query.lines.no_reset.copy.no_wait.draw.32bit.no_availability.multiple_blocks.mesh_only.inside_rp.multi_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.prim_query.lines.no_reset.copy.no_wait.draw.32bit.no_availability.multiple_blocks.mesh_only.inside_rp.multi_view.with_secondary,Fail
+dEQP-VK.mesh_shader.ext.query.prim_query.lines.no_reset.copy.no_wait.draw.32bit.no_availability.multiple_blocks.mesh_only.inside_rp.single_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.prim_query.lines.no_reset.copy.no_wait.draw.32bit.no_availability.multiple_blocks.mesh_only.inside_rp.single_view.with_secondary,Fail
+dEQP-VK.mesh_shader.ext.query.prim_query.lines.no_reset.copy.no_wait.draw.32bit.no_availability.multiple_blocks.task_mesh.include_rp.single_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.prim_query.lines.no_reset.copy.no_wait.draw.32bit.no_availability.multiple_blocks.task_mesh.inside_rp.multi_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.prim_query.lines.no_reset.copy.no_wait.draw.32bit.no_availability.multiple_blocks.task_mesh.inside_rp.multi_view.with_secondary,Fail
+dEQP-VK.mesh_shader.ext.query.prim_query.lines.no_reset.copy.no_wait.draw.32bit.no_availability.multiple_blocks.task_mesh.inside_rp.single_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.prim_query.lines.no_reset.copy.no_wait.draw.32bit.no_availability.multiple_blocks.task_mesh.inside_rp.single_view.with_secondary,Fail
+dEQP-VK.mesh_shader.ext.query.prim_query.lines.no_reset.copy.wait.draw.32bit.no_availability.multiple_blocks.mesh_only.include_rp.single_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.prim_query.lines.no_reset.copy.wait.draw.32bit.no_availability.multiple_blocks.mesh_only.inside_rp.multi_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.prim_query.lines.no_reset.copy.wait.draw.32bit.no_availability.multiple_blocks.mesh_only.inside_rp.multi_view.with_secondary,Fail
+dEQP-VK.mesh_shader.ext.query.prim_query.lines.no_reset.copy.wait.draw.32bit.no_availability.multiple_blocks.mesh_only.inside_rp.single_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.prim_query.lines.no_reset.copy.wait.draw.32bit.no_availability.multiple_blocks.mesh_only.inside_rp.single_view.with_secondary,Fail
+dEQP-VK.mesh_shader.ext.query.prim_query.lines.no_reset.copy.wait.draw.32bit.no_availability.multiple_blocks.task_mesh.include_rp.single_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.prim_query.lines.no_reset.copy.wait.draw.32bit.no_availability.multiple_blocks.task_mesh.inside_rp.multi_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.prim_query.lines.no_reset.copy.wait.draw.32bit.no_availability.multiple_blocks.task_mesh.inside_rp.multi_view.with_secondary,Fail
+dEQP-VK.mesh_shader.ext.query.prim_query.lines.no_reset.copy.wait.draw.32bit.no_availability.multiple_blocks.task_mesh.inside_rp.single_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.prim_query.lines.no_reset.copy.wait.draw.32bit.no_availability.multiple_blocks.task_mesh.inside_rp.single_view.with_secondary,Fail
+dEQP-VK.mesh_shader.ext.query.prim_query.lines.no_reset.get.no_wait.draw.32bit.no_availability.multiple_blocks.mesh_only.include_rp.single_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.prim_query.lines.no_reset.get.no_wait.draw.32bit.no_availability.multiple_blocks.mesh_only.inside_rp.multi_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.prim_query.lines.no_reset.get.no_wait.draw.32bit.no_availability.multiple_blocks.mesh_only.inside_rp.multi_view.with_secondary,Fail
+dEQP-VK.mesh_shader.ext.query.prim_query.lines.no_reset.get.no_wait.draw.32bit.no_availability.multiple_blocks.mesh_only.inside_rp.single_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.prim_query.lines.no_reset.get.no_wait.draw.32bit.no_availability.multiple_blocks.mesh_only.inside_rp.single_view.with_secondary,Fail
+dEQP-VK.mesh_shader.ext.query.prim_query.lines.no_reset.get.no_wait.draw.32bit.no_availability.multiple_blocks.task_mesh.include_rp.single_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.prim_query.lines.no_reset.get.no_wait.draw.32bit.no_availability.multiple_blocks.task_mesh.inside_rp.multi_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.prim_query.lines.no_reset.get.no_wait.draw.32bit.no_availability.multiple_blocks.task_mesh.inside_rp.multi_view.with_secondary,Fail
+dEQP-VK.mesh_shader.ext.query.prim_query.lines.no_reset.get.no_wait.draw.32bit.no_availability.multiple_blocks.task_mesh.inside_rp.single_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.prim_query.lines.no_reset.get.no_wait.draw.32bit.no_availability.multiple_blocks.task_mesh.inside_rp.single_view.with_secondary,Fail
+dEQP-VK.mesh_shader.ext.query.prim_query.lines.no_reset.get.wait.draw.32bit.no_availability.multiple_blocks.mesh_only.include_rp.single_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.prim_query.lines.no_reset.get.wait.draw.32bit.no_availability.multiple_blocks.mesh_only.inside_rp.multi_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.prim_query.lines.no_reset.get.wait.draw.32bit.no_availability.multiple_blocks.mesh_only.inside_rp.multi_view.with_secondary,Fail
+dEQP-VK.mesh_shader.ext.query.prim_query.lines.no_reset.get.wait.draw.32bit.no_availability.multiple_blocks.mesh_only.inside_rp.single_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.prim_query.lines.no_reset.get.wait.draw.32bit.no_availability.multiple_blocks.mesh_only.inside_rp.single_view.with_secondary,Fail
+dEQP-VK.mesh_shader.ext.query.prim_query.lines.no_reset.get.wait.draw.32bit.no_availability.multiple_blocks.task_mesh.include_rp.single_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.prim_query.lines.no_reset.get.wait.draw.32bit.no_availability.multiple_blocks.task_mesh.inside_rp.multi_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.prim_query.lines.no_reset.get.wait.draw.32bit.no_availability.multiple_blocks.task_mesh.inside_rp.multi_view.with_secondary,Fail
+dEQP-VK.mesh_shader.ext.query.prim_query.lines.no_reset.get.wait.draw.32bit.no_availability.multiple_blocks.task_mesh.inside_rp.single_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.prim_query.lines.no_reset.get.wait.draw.32bit.no_availability.multiple_blocks.task_mesh.inside_rp.single_view.with_secondary,Fail
+dEQP-VK.mesh_shader.ext.query.prim_query.lines.reset_after.copy.no_wait.draw.32bit.no_availability.multiple_blocks.mesh_only.include_rp.single_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.prim_query.lines.reset_after.copy.no_wait.draw.32bit.no_availability.multiple_blocks.mesh_only.inside_rp.multi_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.prim_query.lines.reset_after.copy.no_wait.draw.32bit.no_availability.multiple_blocks.mesh_only.inside_rp.multi_view.with_secondary,Fail
+dEQP-VK.mesh_shader.ext.query.prim_query.lines.reset_after.copy.no_wait.draw.32bit.no_availability.multiple_blocks.mesh_only.inside_rp.single_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.prim_query.lines.reset_after.copy.no_wait.draw.32bit.no_availability.multiple_blocks.mesh_only.inside_rp.single_view.with_secondary,Fail
+dEQP-VK.mesh_shader.ext.query.prim_query.lines.reset_after.copy.no_wait.draw.32bit.no_availability.multiple_blocks.task_mesh.include_rp.single_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.prim_query.lines.reset_after.copy.no_wait.draw.32bit.no_availability.multiple_blocks.task_mesh.inside_rp.multi_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.prim_query.lines.reset_after.copy.no_wait.draw.32bit.no_availability.multiple_blocks.task_mesh.inside_rp.multi_view.with_secondary,Fail
+dEQP-VK.mesh_shader.ext.query.prim_query.lines.reset_after.copy.no_wait.draw.32bit.no_availability.multiple_blocks.task_mesh.inside_rp.single_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.prim_query.lines.reset_after.copy.no_wait.draw.32bit.no_availability.multiple_blocks.task_mesh.inside_rp.single_view.with_secondary,Fail
+dEQP-VK.mesh_shader.ext.query.prim_query.lines.reset_after.copy.wait.draw.32bit.no_availability.multiple_blocks.mesh_only.include_rp.single_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.prim_query.lines.reset_after.copy.wait.draw.32bit.no_availability.multiple_blocks.mesh_only.inside_rp.multi_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.prim_query.lines.reset_after.copy.wait.draw.32bit.no_availability.multiple_blocks.mesh_only.inside_rp.multi_view.with_secondary,Fail
+dEQP-VK.mesh_shader.ext.query.prim_query.lines.reset_after.copy.wait.draw.32bit.no_availability.multiple_blocks.mesh_only.inside_rp.single_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.prim_query.lines.reset_after.copy.wait.draw.32bit.no_availability.multiple_blocks.mesh_only.inside_rp.single_view.with_secondary,Fail
+dEQP-VK.mesh_shader.ext.query.prim_query.lines.reset_after.copy.wait.draw.32bit.no_availability.multiple_blocks.task_mesh.include_rp.single_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.prim_query.lines.reset_after.copy.wait.draw.32bit.no_availability.multiple_blocks.task_mesh.inside_rp.multi_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.prim_query.lines.reset_after.copy.wait.draw.32bit.no_availability.multiple_blocks.task_mesh.inside_rp.multi_view.with_secondary,Fail
+dEQP-VK.mesh_shader.ext.query.prim_query.lines.reset_after.copy.wait.draw.32bit.no_availability.multiple_blocks.task_mesh.inside_rp.single_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.prim_query.lines.reset_after.copy.wait.draw.32bit.no_availability.multiple_blocks.task_mesh.inside_rp.single_view.with_secondary,Fail
+dEQP-VK.mesh_shader.ext.query.prim_query.lines.reset_before.copy.no_wait.draw.32bit.no_availability.multiple_blocks.mesh_only.include_rp.single_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.prim_query.lines.reset_before.copy.no_wait.draw.32bit.no_availability.multiple_blocks.mesh_only.inside_rp.multi_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.prim_query.lines.reset_before.copy.no_wait.draw.32bit.no_availability.multiple_blocks.mesh_only.inside_rp.multi_view.with_secondary,Fail
+dEQP-VK.mesh_shader.ext.query.prim_query.lines.reset_before.copy.no_wait.draw.32bit.no_availability.multiple_blocks.mesh_only.inside_rp.single_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.prim_query.lines.reset_before.copy.no_wait.draw.32bit.no_availability.multiple_blocks.mesh_only.inside_rp.single_view.with_secondary,Fail
+dEQP-VK.mesh_shader.ext.query.prim_query.lines.reset_before.copy.no_wait.draw.32bit.no_availability.multiple_blocks.task_mesh.include_rp.single_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.prim_query.lines.reset_before.copy.no_wait.draw.32bit.no_availability.multiple_blocks.task_mesh.inside_rp.multi_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.prim_query.lines.reset_before.copy.no_wait.draw.32bit.no_availability.multiple_blocks.task_mesh.inside_rp.multi_view.with_secondary,Fail
+dEQP-VK.mesh_shader.ext.query.prim_query.lines.reset_before.copy.no_wait.draw.32bit.no_availability.multiple_blocks.task_mesh.inside_rp.single_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.prim_query.lines.reset_before.copy.no_wait.draw.32bit.no_availability.multiple_blocks.task_mesh.inside_rp.single_view.with_secondary,Fail
+dEQP-VK.mesh_shader.ext.query.prim_query.lines.reset_before.get.no_wait.draw.32bit.no_availability.multiple_blocks.mesh_only.include_rp.single_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.prim_query.lines.reset_before.get.no_wait.draw.32bit.no_availability.multiple_blocks.mesh_only.inside_rp.multi_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.prim_query.lines.reset_before.get.no_wait.draw.32bit.no_availability.multiple_blocks.mesh_only.inside_rp.multi_view.with_secondary,Fail
+dEQP-VK.mesh_shader.ext.query.prim_query.lines.reset_before.get.no_wait.draw.32bit.no_availability.multiple_blocks.mesh_only.inside_rp.single_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.prim_query.lines.reset_before.get.no_wait.draw.32bit.no_availability.multiple_blocks.mesh_only.inside_rp.single_view.with_secondary,Fail
+dEQP-VK.mesh_shader.ext.query.prim_query.lines.reset_before.get.no_wait.draw.32bit.no_availability.multiple_blocks.task_mesh.include_rp.single_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.prim_query.lines.reset_before.get.no_wait.draw.32bit.no_availability.multiple_blocks.task_mesh.inside_rp.multi_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.prim_query.lines.reset_before.get.no_wait.draw.32bit.no_availability.multiple_blocks.task_mesh.inside_rp.multi_view.with_secondary,Fail
+dEQP-VK.mesh_shader.ext.query.prim_query.lines.reset_before.get.no_wait.draw.32bit.no_availability.multiple_blocks.task_mesh.inside_rp.single_view.only_primary,Fail
+dEQP-VK.mesh_shader.ext.query.prim_query.lines.reset_before.get.no_wait.draw.32bit.no_availability.multiple_blocks.task_mesh.inside_rp.single_view.with_secondary,Fail
diff --git a/src/amd/vulkan/radv_physical_device.c b/src/amd/vulkan/radv_physical_device.c
index 1dc29f33d839f..0869b532adc05 100644
--- a/src/amd/vulkan/radv_physical_device.c
+++ b/src/amd/vulkan/radv_physical_device.c
@@ -929,7 +929,7 @@ radv_physical_device_get_features(const struct radv_physical_device *pdevice, st
       .taskShader = taskmesh_en,
       .multiviewMeshShader = taskmesh_en,
       .primitiveFragmentShadingRateMeshShader = taskmesh_en,
-      .meshShaderQueries = false,
+      .meshShaderQueries = pdevice->rad_info.gfx_level == GFX10_3,
 
       /* VK_VALVE_descriptor_set_host_mapping */
       .descriptorSetHostMapping = true,
-- 
GitLab

