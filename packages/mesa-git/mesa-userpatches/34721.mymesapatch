From d1c7d937a0e89803a86f4b59e5272430ee993798 Mon Sep 17 00:00:00 2001
From: Georg Lehmann <dadschoorse@gmail.com>
Date: Wed, 19 Nov 2025 13:04:58 +0100
Subject: [PATCH 01/29] aco/optimizer: parse pseudo alu instructions

For combining, it's easier to handle these like their respective alu.
---
 src/amd/compiler/aco_optimizer.cpp | 37 ++++++++++++++++++++++++++++++
 1 file changed, 37 insertions(+)

diff --git a/src/amd/compiler/aco_optimizer.cpp b/src/amd/compiler/aco_optimizer.cpp
index c2d914111acd3..8a083779e18d2 100644
--- a/src/amd/compiler/aco_optimizer.cpp
+++ b/src/amd/compiler/aco_optimizer.cpp
@@ -1172,6 +1172,43 @@ alu_opt_info_is_valid(opt_ctx& ctx, alu_opt_info& info)
 bool
 alu_opt_gather_info(opt_ctx& ctx, Instruction* instr, alu_opt_info& info)
 {
+   if (instr->opcode == aco_opcode::p_insert &&
+       (instr->operands[1].constantValue() + 1) * instr->operands[2].constantValue() == 32) {
+      info = {};
+      info.pass_flags = instr->pass_flags;
+      info.defs.push_back(instr->definitions[0]);
+      info.operands.push_back({Operand::c32(32 - instr->operands[2].constantValue())});
+      info.operands.push_back({instr->operands[0]});
+      if (instr->definitions[0].regClass() == s1) {
+         info.defs.push_back(instr->definitions[1]);
+         info.opcode = aco_opcode::v_lshl_b32;
+         info.format = Format::SOP2;
+         std::swap(info.operands[0], info.operands[1]);
+      } else {
+         info.opcode = aco_opcode::v_lshlrev_b32;
+         info.format = Format::VOP2;
+      }
+      return true;
+   } else if ((instr->opcode == aco_opcode::p_insert ||
+               (instr->opcode == aco_opcode::p_extract && instr->operands[3].constantEquals(0))) &&
+              instr->operands[1].constantEquals(0)) {
+      info = {};
+      info.pass_flags = instr->pass_flags;
+      info.defs.push_back(instr->definitions[0]);
+      info.operands.push_back(
+         {Operand::c32(instr->operands[2].constantEquals(8) ? 0xffu : 0xffffu)});
+      info.operands.push_back({instr->operands[0]});
+      if (instr->definitions[0].regClass() == s1) {
+         info.defs.push_back(instr->definitions[1]);
+         info.opcode = aco_opcode::s_and_b32;
+         info.format = Format::SOP2;
+      } else {
+         info.opcode = aco_opcode::v_and_b32;
+         info.format = Format::VOP2;
+      }
+      return true;
+   }
+
    if (!instr->isVALU() && !instr->isSALU())
       return false;
 
-- 
GitLab


From 296e83d1412ea0de541b00c5300ffb1e406a757a Mon Sep 17 00:00:00 2001
From: Georg Lehmann <dadschoorse@gmail.com>
Date: Sat, 14 Dec 2024 17:53:20 +0100
Subject: [PATCH 02/29] aco/optimizer: use new helpers for v_or opts

Foz-DB Navi21:
Totals from 1862 (2.33% of 79789) affected shaders:
MaxWaves: 39237 -> 39239 (+0.01%)
Instrs: 5199803 -> 5199351 (-0.01%); split: -0.02%, +0.01%
CodeSize: 28046248 -> 28053620 (+0.03%); split: -0.01%, +0.03%
VGPRs: 123552 -> 123544 (-0.01%)
SpillSGPRs: 1407 -> 1412 (+0.36%)
Latency: 52063433 -> 52054229 (-0.02%); split: -0.04%, +0.02%
InvThroughput: 14948561 -> 14945567 (-0.02%); split: -0.04%, +0.02%
VClause: 133491 -> 133506 (+0.01%); split: -0.01%, +0.02%
SClause: 114108 -> 114109 (+0.00%); split: -0.01%, +0.01%
Copies: 459845 -> 460033 (+0.04%); split: -0.04%, +0.08%
Branches: 148086 -> 148056 (-0.02%); split: -0.02%, +0.00%
PreSGPRs: 91147 -> 91125 (-0.02%)
PreVGPRs: 98446 -> 98433 (-0.01%)
VALU: 3564354 -> 3563785 (-0.02%); split: -0.03%, +0.01%
SALU: 697575 -> 697706 (+0.02%); split: -0.01%, +0.02%
---
 src/amd/compiler/aco_optimizer.cpp | 28 ++++++++++++++++++++--------
 1 file changed, 20 insertions(+), 8 deletions(-)

diff --git a/src/amd/compiler/aco_optimizer.cpp b/src/amd/compiler/aco_optimizer.cpp
index 8a083779e18d2..789e91a916505 100644
--- a/src/amd/compiler/aco_optimizer.cpp
+++ b/src/amd/compiler/aco_optimizer.cpp
@@ -4583,6 +4583,15 @@ remove_const_cb(opt_ctx& ctx, alu_opt_info& info)
    return true;
 }
 
+template <unsigned idx, uint32_t constant>
+bool
+insert_const_cb(opt_ctx& ctx, alu_opt_info& info)
+{
+   assert(idx <= info.operands.size());
+   info.operands.insert(info.operands.begin() + idx, {Operand::c32(constant)});
+   return true;
+}
+
 template <combine_instr_callback func1, combine_instr_callback func2>
 bool
 and_cb(opt_ctx& ctx, alu_opt_info& info)
@@ -4703,14 +4712,6 @@ combine_instruction(opt_ctx& ctx, aco_ptr<Instruction>& instr)
    }
 
    if (instr->isSDWA()) {
-   } else if (instr->opcode == aco_opcode::v_or_b32 && ctx.program->gfx_level >= GFX9) {
-      if (combine_three_valu_op(ctx, instr, aco_opcode::s_or_b32, aco_opcode::v_or3_b32, "012",
-                                1 | 2)) {
-      } else if (combine_three_valu_op(ctx, instr, aco_opcode::v_or_b32, aco_opcode::v_or3_b32,
-                                       "012", 1 | 2)) {
-      } else if (combine_add_or_then_and_lshl(ctx, instr)) {
-      } else if (combine_v_andor_not(ctx, instr)) {
-      }
    } else if (instr->opcode == aco_opcode::v_xor_b32 && ctx.program->gfx_level >= GFX10) {
       if (combine_three_valu_op(ctx, instr, aco_opcode::v_xor_b32, aco_opcode::v_xor3_b32, "012",
                                 1 | 2)) {
@@ -4955,6 +4956,17 @@ combine_instruction(opt_ctx& ctx, aco_ptr<Instruction>& instr)
          add_opt(v_mul_lo_u16, v_pk_mad_u16, 0x3, "120");
       else
          add_opt(v_mul_lo_u16_e64, v_pk_mad_u16, 0x3, "120");
+   } else if (info.opcode == aco_opcode::v_or_b32) {
+      add_opt(v_not_b32, v_bfi_b32, 0x3, "10", insert_const_cb<2, UINT32_MAX>, true);
+      add_opt(s_not_b32, v_bfi_b32, 0x3, "10", insert_const_cb<2, UINT32_MAX>, true);
+      if (ctx.program->gfx_level >= GFX9) {
+         add_opt(v_or_b32, v_or3_b32, 0x3, "012", nullptr, true);
+         add_opt(s_or_b32, v_or3_b32, 0x3, "012", nullptr, true);
+         add_opt(v_lshlrev_b32, v_lshl_or_b32, 0x3, "210", nullptr, true);
+         add_opt(s_lshl_b32, v_lshl_or_b32, 0x3, "120", nullptr, true);
+         add_opt(v_and_b32, v_and_or_b32, 0x3, "120", nullptr, true);
+         add_opt(s_and_b32, v_and_or_b32, 0x3, "120", nullptr, true);
+      }
    }
 
    if (match_and_apply_patterns(ctx, info, patterns)) {
-- 
GitLab


From 69bec40ca7e2619b8e03bd9c4e224df50672d894 Mon Sep 17 00:00:00 2001
From: Georg Lehmann <dadschoorse@gmail.com>
Date: Sat, 14 Dec 2024 18:07:39 +0100
Subject: [PATCH 03/29] aco/optimizer: use new helpers for xor opts

Foz-DB Navi21:
Totals from 16 (0.02% of 79206) affected shaders:
Instrs: 47261 -> 47256 (-0.01%)
CodeSize: 246640 -> 246652 (+0.00%)
Latency: 295665 -> 295636 (-0.01%)
InvThroughput: 84468 -> 84462 (-0.01%)
PreVGPRs: 713 -> 714 (+0.14%)
VALU: 29089 -> 29085 (-0.01%)
---
 src/amd/compiler/aco_optimizer.cpp | 43 ++++--------------------------
 1 file changed, 5 insertions(+), 38 deletions(-)

diff --git a/src/amd/compiler/aco_optimizer.cpp b/src/amd/compiler/aco_optimizer.cpp
index 789e91a916505..bc50e9e40bc7d 100644
--- a/src/amd/compiler/aco_optimizer.cpp
+++ b/src/amd/compiler/aco_optimizer.cpp
@@ -3654,37 +3654,6 @@ combine_add_or_then_and_lshl(opt_ctx& ctx, aco_ptr<Instruction>& instr)
    return false;
 }
 
-/* v_xor(a, s_not(b)) -> v_xnor(a, b)
- * v_xor(a, v_not(b)) -> v_xnor(a, b)
- */
-bool
-combine_xor_not(opt_ctx& ctx, aco_ptr<Instruction>& instr)
-{
-   if (instr->usesModifiers())
-      return false;
-
-   for (unsigned i = 0; i < 2; i++) {
-      Instruction* op_instr = follow_operand(ctx, instr->operands[i], true);
-      if (!op_instr ||
-          (op_instr->opcode != aco_opcode::v_not_b32 &&
-           op_instr->opcode != aco_opcode::s_not_b32) ||
-          op_instr->usesModifiers() || op_instr->operands[0].isLiteral())
-         continue;
-
-      instr->opcode = aco_opcode::v_xnor_b32;
-      instr->operands[i] = copy_operand(ctx, op_instr->operands[0]);
-      decrease_and_dce(ctx, op_instr->definitions[0].getTemp());
-      if (instr->operands[0].isOfType(RegType::vgpr))
-         std::swap(instr->operands[0], instr->operands[1]);
-      if (!instr->operands[1].isOfType(RegType::vgpr))
-         instr->format = asVOP3(instr->format);
-
-      return true;
-   }
-
-   return false;
-}
-
 /* v_not(v_xor(a, b)) -> v_xnor(a, b) */
 bool
 combine_not_xor(opt_ctx& ctx, aco_ptr<Instruction>& instr)
@@ -4712,13 +4681,6 @@ combine_instruction(opt_ctx& ctx, aco_ptr<Instruction>& instr)
    }
 
    if (instr->isSDWA()) {
-   } else if (instr->opcode == aco_opcode::v_xor_b32 && ctx.program->gfx_level >= GFX10) {
-      if (combine_three_valu_op(ctx, instr, aco_opcode::v_xor_b32, aco_opcode::v_xor3_b32, "012",
-                                1 | 2)) {
-      } else if (combine_three_valu_op(ctx, instr, aco_opcode::s_xor_b32, aco_opcode::v_xor3_b32,
-                                       "012", 1 | 2)) {
-      } else if (combine_xor_not(ctx, instr)) {
-      }
    } else if (instr->opcode == aco_opcode::v_not_b32 && ctx.program->gfx_level >= GFX10) {
       combine_not_xor(ctx, instr);
    } else if (instr->opcode == aco_opcode::v_add_u32 && !instr->usesModifiers()) {
@@ -4967,6 +4929,11 @@ combine_instruction(opt_ctx& ctx, aco_ptr<Instruction>& instr)
          add_opt(v_and_b32, v_and_or_b32, 0x3, "120", nullptr, true);
          add_opt(s_and_b32, v_and_or_b32, 0x3, "120", nullptr, true);
       }
+   } else if (info.opcode == aco_opcode::v_xor_b32 && ctx.program->gfx_level >= GFX10) {
+      add_opt(v_xor_b32, v_xor3_b32, 0x3, "012", nullptr, true);
+      add_opt(s_xor_b32, v_xor3_b32, 0x3, "012", nullptr, true);
+      add_opt(v_not_b32, v_xnor_b32, 0x3, "01", nullptr, true);
+      add_opt(s_not_b32, v_xnor_b32, 0x3, "01", nullptr, true);
    }
 
    if (match_and_apply_patterns(ctx, info, patterns)) {
-- 
GitLab


From 61eb621ed5e0844c265c5d9eb826f7e18cf2f4f6 Mon Sep 17 00:00:00 2001
From: Georg Lehmann <dadschoorse@gmail.com>
Date: Sat, 14 Dec 2024 18:56:57 +0100
Subject: [PATCH 04/29] aco/optimizer: use new helpers for v_add_u32 opts

Foz-DB Navi21:
Totals from 1765 (2.21% of 79789) affected shaders:
MaxWaves: 39665 -> 39661 (-0.01%); split: +0.01%, -0.02%
Instrs: 4521115 -> 4517111 (-0.09%); split: -0.10%, +0.01%
CodeSize: 24259088 -> 24286592 (+0.11%); split: -0.01%, +0.12%
VGPRs: 90736 -> 90752 (+0.02%); split: -0.02%, +0.04%
SpillSGPRs: 1241 -> 1242 (+0.08%)
SpillVGPRs: 2317 -> 2315 (-0.09%); split: -0.26%, +0.17%
Latency: 41363759 -> 41365368 (+0.00%); split: -0.06%, +0.06%
InvThroughput: 10699196 -> 10693315 (-0.05%); split: -0.08%, +0.02%
VClause: 126156 -> 126024 (-0.10%); split: -0.17%, +0.07%
SClause: 101429 -> 101505 (+0.07%); split: -0.01%, +0.08%
Copies: 394246 -> 394357 (+0.03%); split: -0.13%, +0.16%
Branches: 137971 -> 137962 (-0.01%); split: -0.01%, +0.01%
PreSGPRs: 82179 -> 82167 (-0.01%)
PreVGPRs: 74270 -> 74222 (-0.06%); split: -0.07%, +0.00%
VALU: 2981449 -> 2977527 (-0.13%); split: -0.15%, +0.02%
SALU: 646230 -> 646624 (+0.06%); split: -0.07%, +0.13%
VMEM: 229643 -> 229627 (-0.01%)
---
 src/amd/compiler/aco_optimizer.cpp        | 101 +++-------------------
 src/amd/compiler/tests/test_optimizer.cpp |   4 +-
 2 files changed, 14 insertions(+), 91 deletions(-)

diff --git a/src/amd/compiler/aco_optimizer.cpp b/src/amd/compiler/aco_optimizer.cpp
index bc50e9e40bc7d..bf969634bff23 100644
--- a/src/amd/compiler/aco_optimizer.cpp
+++ b/src/amd/compiler/aco_optimizer.cpp
@@ -3585,75 +3585,6 @@ combine_three_valu_op(opt_ctx& ctx, aco_ptr<Instruction>& instr, aco_opcode op2,
    return false;
 }
 
-/* creates v_lshl_add_u32, v_lshl_or_b32 or v_and_or_b32 */
-bool
-combine_add_or_then_and_lshl(opt_ctx& ctx, aco_ptr<Instruction>& instr)
-{
-   bool is_or = instr->opcode == aco_opcode::v_or_b32;
-   aco_opcode new_op_lshl = is_or ? aco_opcode::v_lshl_or_b32 : aco_opcode::v_lshl_add_u32;
-
-   if (is_or && combine_three_valu_op(ctx, instr, aco_opcode::s_and_b32, aco_opcode::v_and_or_b32,
-                                      "120", 1 | 2))
-      return true;
-   if (is_or && combine_three_valu_op(ctx, instr, aco_opcode::v_and_b32, aco_opcode::v_and_or_b32,
-                                      "120", 1 | 2))
-      return true;
-   if (combine_three_valu_op(ctx, instr, aco_opcode::s_lshl_b32, new_op_lshl, "120", 1 | 2))
-      return true;
-   if (combine_three_valu_op(ctx, instr, aco_opcode::v_lshlrev_b32, new_op_lshl, "210", 1 | 2))
-      return true;
-
-   if (instr->isSDWA() || instr->isDPP())
-      return false;
-
-   /* v_or_b32(p_extract(a, 0, 8/16, 0), b) -> v_and_or_b32(a, 0xff/0xffff, b)
-    * v_or_b32(p_insert(a, 0, 8/16), b) -> v_and_or_b32(a, 0xff/0xffff, b)
-    * v_or_b32(p_insert(a, 24/16, 8/16), b) -> v_lshl_or_b32(a, 24/16, b)
-    * v_add_u32(p_insert(a, 24/16, 8/16), b) -> v_lshl_add_b32(a, 24/16, b)
-    */
-   for (unsigned i = 0; i < 2; i++) {
-      Instruction* extins = follow_operand(ctx, instr->operands[i]);
-      if (!extins)
-         continue;
-
-      aco_opcode op;
-      Operand operands[3];
-
-      if (extins->opcode == aco_opcode::p_insert &&
-          (extins->operands[1].constantValue() + 1) * extins->operands[2].constantValue() == 32) {
-         op = new_op_lshl;
-         operands[1] =
-            Operand::c32(extins->operands[1].constantValue() * extins->operands[2].constantValue());
-      } else if (is_or &&
-                 (extins->opcode == aco_opcode::p_insert ||
-                  (extins->opcode == aco_opcode::p_extract &&
-                   extins->operands[3].constantEquals(0))) &&
-                 extins->operands[1].constantEquals(0)) {
-         op = aco_opcode::v_and_or_b32;
-         operands[1] = Operand::c32(extins->operands[2].constantEquals(8) ? 0xffu : 0xffffu);
-      } else {
-         continue;
-      }
-
-      operands[0] = extins->operands[0];
-      operands[2] = instr->operands[!i];
-
-      if (!check_vop3_operands(ctx, 3, operands))
-         continue;
-
-      uint8_t neg = 0, abs = 0, opsel = 0, omod = 0;
-      bool clamp = false;
-      if (instr->isVOP3())
-         clamp = instr->valu().clamp;
-
-      ctx.uses[instr->operands[i].tempId()]--;
-      create_vop3_for_op3(ctx, op, instr, operands, neg, abs, opsel, clamp, omod);
-      return true;
-   }
-
-   return false;
-}
-
 /* v_not(v_xor(a, b)) -> v_xnor(a, b) */
 bool
 combine_not_xor(opt_ctx& ctx, aco_ptr<Instruction>& instr)
@@ -4684,26 +4615,7 @@ combine_instruction(opt_ctx& ctx, aco_ptr<Instruction>& instr)
    } else if (instr->opcode == aco_opcode::v_not_b32 && ctx.program->gfx_level >= GFX10) {
       combine_not_xor(ctx, instr);
    } else if (instr->opcode == aco_opcode::v_add_u32 && !instr->usesModifiers()) {
-      if (combine_add_sub_b2i(ctx, instr, aco_opcode::v_addc_co_u32, 1 | 2)) {
-      } else if (combine_add_bcnt(ctx, instr)) {
-      } else if (combine_three_valu_op(ctx, instr, aco_opcode::v_mul_u32_u24,
-                                       aco_opcode::v_mad_u32_u24, "120", 1 | 2)) {
-      } else if (combine_three_valu_op(ctx, instr, aco_opcode::v_mul_i32_i24,
-                                       aco_opcode::v_mad_i32_i24, "120", 1 | 2)) {
-      } else if (ctx.program->gfx_level >= GFX9) {
-         if (combine_three_valu_op(ctx, instr, aco_opcode::s_xor_b32, aco_opcode::v_xad_u32, "120",
-                                   1 | 2)) {
-         } else if (combine_three_valu_op(ctx, instr, aco_opcode::v_xor_b32, aco_opcode::v_xad_u32,
-                                          "120", 1 | 2)) {
-         } else if (combine_three_valu_op(ctx, instr, aco_opcode::s_add_i32, aco_opcode::v_add3_u32,
-                                          "012", 1 | 2)) {
-         } else if (combine_three_valu_op(ctx, instr, aco_opcode::s_add_u32, aco_opcode::v_add3_u32,
-                                          "012", 1 | 2)) {
-         } else if (combine_three_valu_op(ctx, instr, aco_opcode::v_add_u32, aco_opcode::v_add3_u32,
-                                          "012", 1 | 2)) {
-         } else if (combine_add_or_then_and_lshl(ctx, instr)) {
-         }
-      }
+      combine_add_sub_b2i(ctx, instr, aco_opcode::v_addc_co_u32, 1 | 2);
    } else if ((instr->opcode == aco_opcode::v_add_co_u32 ||
                instr->opcode == aco_opcode::v_add_co_u32_e64) &&
               !instr->usesModifiers()) {
@@ -4934,6 +4846,17 @@ combine_instruction(opt_ctx& ctx, aco_ptr<Instruction>& instr)
       add_opt(s_xor_b32, v_xor3_b32, 0x3, "012", nullptr, true);
       add_opt(v_not_b32, v_xnor_b32, 0x3, "01", nullptr, true);
       add_opt(s_not_b32, v_xnor_b32, 0x3, "01", nullptr, true);
+   } else if (info.opcode == aco_opcode::v_add_u32 && !info.clamp) {
+      add_opt(v_bcnt_u32_b32, v_bcnt_u32_b32, 0x3, "102", remove_const_cb<0>, true);
+      add_opt(v_mul_u32_u24, v_mad_u32_u24, 0x3, "120", nullptr, true);
+      add_opt(v_mul_i32_i24, v_mad_i32_i24, 0x3, "120", nullptr, true);
+      add_opt(v_xor_b32, v_xad_u32, 0x3, "120", nullptr, true);
+      add_opt(s_xor_b32, v_xad_u32, 0x3, "120", nullptr, true);
+      add_opt(v_add_u32, v_add3_u32, 0x3, "012", nullptr, true);
+      add_opt(s_add_u32, v_add3_u32, 0x3, "012", nullptr, true);
+      add_opt(s_add_i32, v_add3_u32, 0x3, "012", nullptr, true);
+      add_opt(v_lshlrev_b32, v_lshl_add_u32, 0x3, "210", nullptr, true);
+      add_opt(s_lshl_b32, v_lshl_add_u32, 0x3, "120", nullptr, true);
    }
 
    if (match_and_apply_patterns(ctx, info, patterns)) {
diff --git a/src/amd/compiler/tests/test_optimizer.cpp b/src/amd/compiler/tests/test_optimizer.cpp
index 6e41b067ab268..861bf6ce9fca9 100644
--- a/src/amd/compiler/tests/test_optimizer.cpp
+++ b/src/amd/compiler/tests/test_optimizer.cpp
@@ -363,9 +363,9 @@ BEGIN_TEST(optimize.bcnt)
       bcnt = bld.vop3(aco_opcode::v_bcnt_u32_b32, bld.def(v1), Operand(inputs[0]), Operand::zero());
       writeout(2, bld.vadd32(bld.def(v1), bcnt, Operand::c32(42u)));
 
-      //! v1: %bnct3 = v_bcnt_u32_b32 %b, 0
+      //~gfx8! v1: %bnct3 = v_bcnt_u32_b32 %b, 0
       //~gfx8! v1: %res3, s2: %_ = v_add_co_u32 %bcnt3, %a
-      //~gfx(9|10)! v1: %res3 = v_add_u32 %bcnt3, %a
+      //~gfx(9|10)! v1: %res3 = v_bcnt_u32_b32 %b, %a
       //! p_unit_test 3, %res3
       bcnt = bld.vop3(aco_opcode::v_bcnt_u32_b32, bld.def(v1), Operand(inputs[1]), Operand::zero());
       writeout(3, bld.vadd32(bld.def(v1), bcnt, Operand(inputs[0])));
-- 
GitLab


From bf7148e8f206a6fa92c8923d5dd38dc47ca0cfa1 Mon Sep 17 00:00:00 2001
From: Georg Lehmann <dadschoorse@gmail.com>
Date: Sat, 14 Dec 2024 19:25:22 +0100
Subject: [PATCH 05/29] aco/optimizer: optimize add(mad_u32_u16(a, b, 0), c)

Foz-DB Navi21:
Totals from 205 (0.26% of 79789) affected shaders:
Instrs: 2813633 -> 2812322 (-0.05%); split: -0.05%, +0.00%
CodeSize: 15211544 -> 15205688 (-0.04%)
Latency: 20323387 -> 20342633 (+0.09%); split: -0.02%, +0.12%
InvThroughput: 4736580 -> 4739199 (+0.06%); split: -0.07%, +0.13%
VClause: 88260 -> 88266 (+0.01%); split: -0.04%, +0.05%
SClause: 62072 -> 62069 (-0.00%)
Copies: 242848 -> 242788 (-0.02%); split: -0.04%, +0.02%
Branches: 93990 -> 93986 (-0.00%)
VALU: 1843442 -> 1842136 (-0.07%)
SALU: 404305 -> 404307 (+0.00%); split: -0.00%, +0.00%
---
 src/amd/compiler/aco_optimizer.cpp | 1 +
 1 file changed, 1 insertion(+)

diff --git a/src/amd/compiler/aco_optimizer.cpp b/src/amd/compiler/aco_optimizer.cpp
index bf969634bff23..29a5ba7490c5a 100644
--- a/src/amd/compiler/aco_optimizer.cpp
+++ b/src/amd/compiler/aco_optimizer.cpp
@@ -4848,6 +4848,7 @@ combine_instruction(opt_ctx& ctx, aco_ptr<Instruction>& instr)
       add_opt(s_not_b32, v_xnor_b32, 0x3, "01", nullptr, true);
    } else if (info.opcode == aco_opcode::v_add_u32 && !info.clamp) {
       add_opt(v_bcnt_u32_b32, v_bcnt_u32_b32, 0x3, "102", remove_const_cb<0>, true);
+      add_opt(v_mad_u32_u16, v_mad_u32_u16, 0x3, "1203", remove_const_cb<0>, true);
       add_opt(v_mul_u32_u24, v_mad_u32_u24, 0x3, "120", nullptr, true);
       add_opt(v_mul_i32_i24, v_mad_i32_i24, 0x3, "120", nullptr, true);
       add_opt(v_xor_b32, v_xad_u32, 0x3, "120", nullptr, true);
-- 
GitLab


From 40744a456bb080042ea97c3e89e85c9f87cf13aa Mon Sep 17 00:00:00 2001
From: Georg Lehmann <dadschoorse@gmail.com>
Date: Sat, 14 Dec 2024 19:40:51 +0100
Subject: [PATCH 06/29] aco/optimizer: use new helpers for s_lshl<n>_add_u32

Foz-DB Navi21:
Totals from 7357 (9.22% of 79789) affected shaders:
Instrs: 5854176 -> 5853320 (-0.01%); split: -0.05%, +0.03%
CodeSize: 31302704 -> 31279256 (-0.07%); split: -0.10%, +0.03%
SpillSGPRs: 2777 -> 2770 (-0.25%)
Latency: 63978905 -> 63996322 (+0.03%); split: -0.01%, +0.04%
InvThroughput: 14484362 -> 14484239 (-0.00%); split: -0.01%, +0.01%
VClause: 127875 -> 127910 (+0.03%); split: -0.01%, +0.03%
SClause: 190608 -> 191114 (+0.27%); split: -0.94%, +1.20%
Copies: 483352 -> 483079 (-0.06%); split: -0.40%, +0.34%
Branches: 146689 -> 146680 (-0.01%); split: -0.02%, +0.01%
PreSGPRs: 326925 -> 326187 (-0.23%); split: -0.37%, +0.15%
VALU: 3704630 -> 3704846 (+0.01%); split: -0.00%, +0.01%
SALU: 895392 -> 894852 (-0.06%); split: -0.21%, +0.15%
---
 src/amd/compiler/aco_optimizer.cpp | 55 ++++--------------------------
 1 file changed, 7 insertions(+), 48 deletions(-)

diff --git a/src/amd/compiler/aco_optimizer.cpp b/src/amd/compiler/aco_optimizer.cpp
index 29a5ba7490c5a..d213cb375b063 100644
--- a/src/amd/compiler/aco_optimizer.cpp
+++ b/src/amd/compiler/aco_optimizer.cpp
@@ -3038,14 +3038,6 @@ original_temp_id(opt_ctx& ctx, Temp tmp)
       return tmp.id();
 }
 
-Operand
-copy_operand(opt_ctx& ctx, Operand op)
-{
-   if (op.isTemp())
-      ctx.uses[op.tempId()]++;
-   return op;
-}
-
 Instruction*
 follow_operand(opt_ctx& ctx, Operand op, bool ignore_uses = false)
 {
@@ -3697,43 +3689,6 @@ combine_salu_n2(opt_ctx& ctx, aco_ptr<Instruction>& instr)
    return false;
 }
 
-/* s_add_{i32,u32}(a, s_lshl_b32(b, <n>)) -> s_lshl<n>_add_u32(a, b) */
-bool
-combine_salu_lshl_add(opt_ctx& ctx, aco_ptr<Instruction>& instr)
-{
-   if (instr->opcode == aco_opcode::s_add_i32 && ctx.uses[instr->definitions[1].tempId()])
-      return false;
-
-   for (unsigned i = 0; i < 2; i++) {
-      Instruction* op2_instr = follow_operand(ctx, instr->operands[i], true);
-      if (!op2_instr || op2_instr->opcode != aco_opcode::s_lshl_b32 ||
-          ctx.uses[op2_instr->definitions[1].tempId()])
-         continue;
-      if (!op2_instr->operands[1].isConstant())
-         continue;
-
-      uint32_t shift = op2_instr->operands[1].constantValue();
-      if (shift < 1 || shift > 4)
-         continue;
-
-      if (instr->operands[!i].isLiteral() && op2_instr->operands[0].isLiteral() &&
-          instr->operands[!i].constantValue() != op2_instr->operands[0].constantValue())
-         continue;
-
-      instr->operands[1] = instr->operands[!i];
-      instr->operands[0] = copy_operand(ctx, op2_instr->operands[0]);
-      decrease_and_dce(ctx, op2_instr->definitions[0].getTemp());
-      ctx.info[instr->definitions[0].tempId()].label = 0;
-
-      instr->opcode = std::array<aco_opcode, 4>{
-         aco_opcode::s_lshl1_add_u32, aco_opcode::s_lshl2_add_u32, aco_opcode::s_lshl3_add_u32,
-         aco_opcode::s_lshl4_add_u32}[shift - 1];
-
-      return true;
-   }
-   return false;
-}
-
 /* s_abs_i32(s_sub_[iu]32(a, b)) -> s_absdiff_i32(a, b)
  * s_abs_i32(s_add_[iu]32(a, #b)) -> s_absdiff_i32(a, -b)
  */
@@ -4642,9 +4597,6 @@ combine_instruction(opt_ctx& ctx, aco_ptr<Instruction>& instr)
    } else if (instr->opcode == aco_opcode::v_lshlrev_b32 && ctx.program->gfx_level >= GFX9) {
       combine_three_valu_op(ctx, instr, aco_opcode::v_add_u32, aco_opcode::v_add_lshl_u32, "120",
                             2);
-   } else if ((instr->opcode == aco_opcode::s_add_u32 || instr->opcode == aco_opcode::s_add_i32) &&
-              ctx.program->gfx_level >= GFX9) {
-      combine_salu_lshl_add(ctx, instr);
    } else if (instr->opcode == aco_opcode::s_not_b32 || instr->opcode == aco_opcode::s_not_b64) {
       if (!combine_salu_not_bitwise(ctx, instr))
          combine_inverse_comparison(ctx, instr);
@@ -4858,6 +4810,13 @@ combine_instruction(opt_ctx& ctx, aco_ptr<Instruction>& instr)
       add_opt(s_add_i32, v_add3_u32, 0x3, "012", nullptr, true);
       add_opt(v_lshlrev_b32, v_lshl_add_u32, 0x3, "210", nullptr, true);
       add_opt(s_lshl_b32, v_lshl_add_u32, 0x3, "120", nullptr, true);
+   } else if ((info.opcode == aco_opcode::s_add_u32 ||
+               (info.opcode == aco_opcode::s_add_i32 && !ctx.uses[info.defs[1].tempId()])) &&
+              ctx.program->gfx_level >= GFX9) {
+      add_opt(s_lshl_b32, s_lshl1_add_u32, 0x3, "102", remove_const_cb<1>);
+      add_opt(s_lshl_b32, s_lshl2_add_u32, 0x3, "102", remove_const_cb<2>);
+      add_opt(s_lshl_b32, s_lshl3_add_u32, 0x3, "102", remove_const_cb<3>);
+      add_opt(s_lshl_b32, s_lshl4_add_u32, 0x3, "102", remove_const_cb<4>);
    }
 
    if (match_and_apply_patterns(ctx, info, patterns)) {
-- 
GitLab


From 78e12bbf88cdda1ae6723076dffed63ef222b6e6 Mon Sep 17 00:00:00 2001
From: Georg Lehmann <dadschoorse@gmail.com>
Date: Sat, 14 Dec 2024 19:52:25 +0100
Subject: [PATCH 07/29] aco/optimizer: use new helpers for v_add_lshl_u32

Foz-DB Navi21:
Totals from 1323 (1.66% of 79789) affected shaders:
MaxWaves: 24845 -> 24835 (-0.04%)
Instrs: 4350561 -> 4350193 (-0.01%); split: -0.04%, +0.03%
CodeSize: 23300360 -> 23311248 (+0.05%); split: -0.00%, +0.05%
Latency: 41854489 -> 41848059 (-0.02%); split: -0.04%, +0.02%
InvThroughput: 10037597 -> 10037436 (-0.00%); split: -0.03%, +0.03%
VClause: 116652 -> 116568 (-0.07%); split: -0.12%, +0.05%
SClause: 106380 -> 106354 (-0.02%); split: -0.04%, +0.02%
Copies: 363612 -> 363557 (-0.02%); split: -0.09%, +0.07%
PreSGPRs: 73153 -> 73200 (+0.06%)
PreVGPRs: 73478 -> 73437 (-0.06%); split: -0.16%, +0.10%
VALU: 2885740 -> 2885231 (-0.02%); split: -0.06%, +0.04%
SALU: 603722 -> 603649 (-0.01%); split: -0.02%, +0.01%
---
 src/amd/compiler/aco_optimizer.cpp | 5 ++---
 1 file changed, 2 insertions(+), 3 deletions(-)

diff --git a/src/amd/compiler/aco_optimizer.cpp b/src/amd/compiler/aco_optimizer.cpp
index d213cb375b063..a3d277cfa13e6 100644
--- a/src/amd/compiler/aco_optimizer.cpp
+++ b/src/amd/compiler/aco_optimizer.cpp
@@ -4594,9 +4594,6 @@ combine_instruction(opt_ctx& ctx, aco_ptr<Instruction>& instr)
               instr->opcode == aco_opcode::v_subrev_co_u32 ||
               instr->opcode == aco_opcode::v_subrev_co_u32_e64) {
       combine_add_sub_b2i(ctx, instr, aco_opcode::v_subbrev_co_u32, 1);
-   } else if (instr->opcode == aco_opcode::v_lshlrev_b32 && ctx.program->gfx_level >= GFX9) {
-      combine_three_valu_op(ctx, instr, aco_opcode::v_add_u32, aco_opcode::v_add_lshl_u32, "120",
-                            2);
    } else if (instr->opcode == aco_opcode::s_not_b32 || instr->opcode == aco_opcode::s_not_b64) {
       if (!combine_salu_not_bitwise(ctx, instr))
          combine_inverse_comparison(ctx, instr);
@@ -4817,6 +4814,8 @@ combine_instruction(opt_ctx& ctx, aco_ptr<Instruction>& instr)
       add_opt(s_lshl_b32, s_lshl2_add_u32, 0x3, "102", remove_const_cb<2>);
       add_opt(s_lshl_b32, s_lshl3_add_u32, 0x3, "102", remove_const_cb<3>);
       add_opt(s_lshl_b32, s_lshl4_add_u32, 0x3, "102", remove_const_cb<4>);
+   } else if (info.opcode == aco_opcode::v_lshlrev_b32 && ctx.program->gfx_level >= GFX9) {
+      add_opt(v_add_u32, v_add_lshl_u32, 0x2, "120", nullptr, true);
    }
 
    if (match_and_apply_patterns(ctx, info, patterns)) {
-- 
GitLab


From 2801e6794658e8f2e4bf27252ec8d86a89d1993d Mon Sep 17 00:00:00 2001
From: Georg Lehmann <dadschoorse@gmail.com>
Date: Sat, 14 Dec 2024 19:57:31 +0100
Subject: [PATCH 08/29] aco/optimizer: add more v_add_lshl_u32 opts

No Foz-DB changes on Navi21.
---
 src/amd/compiler/aco_optimizer.cpp | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/src/amd/compiler/aco_optimizer.cpp b/src/amd/compiler/aco_optimizer.cpp
index a3d277cfa13e6..2805985d8a7e7 100644
--- a/src/amd/compiler/aco_optimizer.cpp
+++ b/src/amd/compiler/aco_optimizer.cpp
@@ -4816,6 +4816,8 @@ combine_instruction(opt_ctx& ctx, aco_ptr<Instruction>& instr)
       add_opt(s_lshl_b32, s_lshl4_add_u32, 0x3, "102", remove_const_cb<4>);
    } else if (info.opcode == aco_opcode::v_lshlrev_b32 && ctx.program->gfx_level >= GFX9) {
       add_opt(v_add_u32, v_add_lshl_u32, 0x2, "120", nullptr, true);
+      add_opt(s_add_u32, v_add_lshl_u32, 0x2, "120", nullptr, true);
+      add_opt(s_add_i32, v_add_lshl_u32, 0x2, "120", nullptr, true);
    }
 
    if (match_and_apply_patterns(ctx, info, patterns)) {
-- 
GitLab


From b8a33da986dd3f52d49a8f5b4d865508db2cf3a8 Mon Sep 17 00:00:00 2001
From: Georg Lehmann <dadschoorse@gmail.com>
Date: Thu, 27 Mar 2025 15:51:41 +0100
Subject: [PATCH 09/29] aco/optimizer: use new helpers for v_and opt

No Foz-DB changes on Navi21.
---
 src/amd/compiler/aco_optimizer.cpp | 51 ++----------------------------
 1 file changed, 3 insertions(+), 48 deletions(-)

diff --git a/src/amd/compiler/aco_optimizer.cpp b/src/amd/compiler/aco_optimizer.cpp
index 2805985d8a7e7..f71482d990870 100644
--- a/src/amd/compiler/aco_optimizer.cpp
+++ b/src/amd/compiler/aco_optimizer.cpp
@@ -4078,52 +4078,6 @@ apply_load_extract(opt_ctx& ctx, aco_ptr<Instruction>& extract)
    return true;
 }
 
-/* v_and(a, not(b)) -> v_bfi_b32(b, 0, a)
- * v_or(a, not(b)) -> v_bfi_b32(b, a, -1)
- */
-bool
-combine_v_andor_not(opt_ctx& ctx, aco_ptr<Instruction>& instr)
-{
-   if (instr->usesModifiers())
-      return false;
-
-   for (unsigned i = 0; i < 2; i++) {
-      Instruction* op_instr = follow_operand(ctx, instr->operands[i], true);
-      if (op_instr && !op_instr->usesModifiers() &&
-          (op_instr->opcode == aco_opcode::v_not_b32 ||
-           op_instr->opcode == aco_opcode::s_not_b32)) {
-
-         Operand ops[3] = {
-            op_instr->operands[0],
-            Operand::zero(),
-            instr->operands[!i],
-         };
-         if (instr->opcode == aco_opcode::v_or_b32) {
-            ops[1] = instr->operands[!i];
-            ops[2] = Operand::c32(-1);
-         }
-         if (!check_vop3_operands(ctx, 3, ops))
-            continue;
-
-         Instruction* new_instr = create_instruction(aco_opcode::v_bfi_b32, Format::VOP3, 3, 1);
-
-         if (op_instr->operands[0].isTemp())
-            ctx.uses[op_instr->operands[0].tempId()]++;
-         for (unsigned j = 0; j < 3; j++)
-            new_instr->operands[j] = ops[j];
-         new_instr->definitions[0] = instr->definitions[0];
-         new_instr->pass_flags = instr->pass_flags;
-         instr.reset(new_instr);
-         decrease_and_dce(ctx, op_instr->definitions[0].getTemp());
-         ctx.info[instr->definitions[0].tempId()].label = 0;
-         ctx.info[instr->definitions[0].tempId()].parent_instr = instr.get();
-         return true;
-      }
-   }
-
-   return false;
-}
-
 /* v_add_co(c, s_lshl(a, b)) -> v_mad_u32_u24(a, 1<<b, c)
  * v_add_co(c, v_lshlrev(a, b)) -> v_mad_u32_u24(b, 1<<a, c)
  * v_sub(c, s_lshl(a, b)) -> v_mad_i32_i24(a, -(1<<b), c)
@@ -4602,8 +4556,6 @@ combine_instruction(opt_ctx& ctx, aco_ptr<Instruction>& instr)
       combine_salu_n2(ctx, instr);
    } else if (instr->opcode == aco_opcode::s_abs_i32) {
       combine_sabsdiff(ctx, instr);
-   } else if (instr->opcode == aco_opcode::v_and_b32) {
-      combine_v_andor_not(ctx, instr);
    }
 
    alu_opt_info info;
@@ -4818,6 +4770,9 @@ combine_instruction(opt_ctx& ctx, aco_ptr<Instruction>& instr)
       add_opt(v_add_u32, v_add_lshl_u32, 0x2, "120", nullptr, true);
       add_opt(s_add_u32, v_add_lshl_u32, 0x2, "120", nullptr, true);
       add_opt(s_add_i32, v_add_lshl_u32, 0x2, "120", nullptr, true);
+   } else if (info.opcode == aco_opcode::v_and_b32) {
+      add_opt(v_not_b32, v_bfi_b32, 0x3, "10", insert_const_cb<1, 0>, true);
+      add_opt(s_not_b32, v_bfi_b32, 0x3, "10", insert_const_cb<1, 0>, true);
    }
 
    if (match_and_apply_patterns(ctx, info, patterns)) {
-- 
GitLab


From 0ac93b6e0bd04ae59ae85783363618348487302a Mon Sep 17 00:00:00 2001
From: Georg Lehmann <dadschoorse@gmail.com>
Date: Sun, 15 Dec 2024 16:55:58 +0100
Subject: [PATCH 10/29] aco/optimizer: use new helpers for remaining add opts

Foz-DB Navi21:
Totals from 412 (0.52% of 79789) affected shaders:
Instrs: 473694 -> 473579 (-0.02%); split: -0.03%, +0.00%
CodeSize: 2560664 -> 2562800 (+0.08%); split: -0.03%, +0.11%
Latency: 3170475 -> 3170675 (+0.01%); split: -0.01%, +0.01%
InvThroughput: 975312 -> 975178 (-0.01%); split: -0.02%, +0.00%
Copies: 55646 -> 55533 (-0.20%); split: -0.23%, +0.03%
VALU: 289347 -> 289232 (-0.04%); split: -0.05%, +0.01%

Foz-DB Polaris10:
Totals from 812 (1.31% of 61894) affected shaders:
Instrs: 610178 -> 609219 (-0.16%); split: -0.21%, +0.05%
CodeSize: 3142404 -> 3147304 (+0.16%); split: -0.02%, +0.17%
VGPRs: 38380 -> 38376 (-0.01%)
Latency: 8312085 -> 8307755 (-0.05%); split: -0.12%, +0.07%
InvThroughput: 3929970 -> 3924631 (-0.14%); split: -0.15%, +0.01%
VClause: 15714 -> 15632 (-0.52%); split: -0.67%, +0.15%
SClause: 14509 -> 14510 (+0.01%); split: -0.02%, +0.03%
Copies: 70197 -> 70388 (+0.27%); split: -0.61%, +0.89%
PreSGPRs: 26409 -> 26404 (-0.02%); split: -0.02%, +0.00%
PreVGPRs: 30448 -> 30436 (-0.04%)
VALU: 408184 -> 407068 (-0.27%); split: -0.29%, +0.01%
SALU: 95726 -> 95959 (+0.24%); split: -0.30%, +0.54%
---
 src/amd/compiler/aco_optimizer.cpp        | 231 +++++++---------------
 src/amd/compiler/tests/test_optimizer.cpp |   4 +-
 2 files changed, 71 insertions(+), 164 deletions(-)

diff --git a/src/amd/compiler/aco_optimizer.cpp b/src/amd/compiler/aco_optimizer.cpp
index f71482d990870..ccd5bd40bdc75 100644
--- a/src/amd/compiler/aco_optimizer.cpp
+++ b/src/amd/compiler/aco_optimizer.cpp
@@ -3460,123 +3460,6 @@ combine_inverse_comparison(opt_ctx& ctx, aco_ptr<Instruction>& instr)
    return true;
 }
 
-/* op1(op2(1, 2), 0) if swap = false
- * op1(0, op2(1, 2)) if swap = true */
-bool
-match_op3_for_vop3(opt_ctx& ctx, aco_opcode op1, aco_opcode op2, Instruction* op1_instr, bool swap,
-                   const char* shuffle_str, Operand operands[3], bitarray8& neg, bitarray8& abs,
-                   bitarray8& opsel, bool* op1_clamp, uint8_t* op1_omod, bool* inbetween_neg,
-                   bool* inbetween_abs, bool* inbetween_opsel, bool* precise)
-{
-   /* checks */
-   if (op1_instr->opcode != op1)
-      return false;
-
-   Instruction* op2_instr = follow_operand(ctx, op1_instr->operands[swap]);
-   if (!op2_instr || op2_instr->opcode != op2)
-      return false;
-
-   VALU_instruction* op1_valu = op1_instr->isVALU() ? &op1_instr->valu() : NULL;
-   VALU_instruction* op2_valu = op2_instr->isVALU() ? &op2_instr->valu() : NULL;
-
-   if (op1_instr->isSDWA() || op2_instr->isSDWA())
-      return false;
-   if (op1_instr->isDPP() || op2_instr->isDPP())
-      return false;
-
-   /* don't support inbetween clamp/omod */
-   if (op2_valu && (op2_valu->clamp || op2_valu->omod))
-      return false;
-
-   /* get operands and modifiers and check inbetween modifiers */
-   *op1_clamp = op1_valu ? (bool)op1_valu->clamp : false;
-   *op1_omod = op1_valu ? (unsigned)op1_valu->omod : 0u;
-
-   if (inbetween_neg)
-      *inbetween_neg = op1_valu ? op1_valu->neg[swap] : false;
-   else if (op1_valu && op1_valu->neg[swap])
-      return false;
-
-   if (inbetween_abs)
-      *inbetween_abs = op1_valu ? op1_valu->abs[swap] : false;
-   else if (op1_valu && op1_valu->abs[swap])
-      return false;
-
-   if (inbetween_opsel)
-      *inbetween_opsel = op1_valu ? op1_valu->opsel[swap] : false;
-   else if (op1_valu && op1_valu->opsel[swap])
-      return false;
-
-   *precise = op1_instr->definitions[0].isPrecise() || op2_instr->definitions[0].isPrecise();
-
-   int shuffle[3];
-   shuffle[shuffle_str[0] - '0'] = 0;
-   shuffle[shuffle_str[1] - '0'] = 1;
-   shuffle[shuffle_str[2] - '0'] = 2;
-
-   operands[shuffle[0]] = op1_instr->operands[!swap];
-   neg[shuffle[0]] = op1_valu ? op1_valu->neg[!swap] : false;
-   abs[shuffle[0]] = op1_valu ? op1_valu->abs[!swap] : false;
-   opsel[shuffle[0]] = op1_valu ? op1_valu->opsel[!swap] : false;
-
-   for (unsigned i = 0; i < 2; i++) {
-      operands[shuffle[i + 1]] = op2_instr->operands[i];
-      neg[shuffle[i + 1]] = op2_valu ? op2_valu->neg[i] : false;
-      abs[shuffle[i + 1]] = op2_valu ? op2_valu->abs[i] : false;
-      opsel[shuffle[i + 1]] = op2_valu ? op2_valu->opsel[i] : false;
-   }
-
-   /* check operands */
-   if (!check_vop3_operands(ctx, 3, operands))
-      return false;
-
-   return true;
-}
-
-void
-create_vop3_for_op3(opt_ctx& ctx, aco_opcode opcode, aco_ptr<Instruction>& instr,
-                    Operand operands[3], uint8_t neg, uint8_t abs, uint8_t opsel, bool clamp,
-                    unsigned omod)
-{
-   Instruction* new_instr = create_instruction(opcode, Format::VOP3, 3, 1);
-   new_instr->valu().neg = neg;
-   new_instr->valu().abs = abs;
-   new_instr->valu().clamp = clamp;
-   new_instr->valu().omod = omod;
-   new_instr->valu().opsel = opsel;
-   new_instr->operands[0] = operands[0];
-   new_instr->operands[1] = operands[1];
-   new_instr->operands[2] = operands[2];
-   new_instr->definitions[0] = instr->definitions[0];
-   new_instr->pass_flags = instr->pass_flags;
-   ctx.info[instr->definitions[0].tempId()].label = 0;
-   ctx.info[instr->definitions[0].tempId()].parent_instr = new_instr;
-
-   instr.reset(new_instr);
-}
-
-bool
-combine_three_valu_op(opt_ctx& ctx, aco_ptr<Instruction>& instr, aco_opcode op2, aco_opcode new_op,
-                      const char* shuffle, uint8_t ops)
-{
-   for (unsigned swap = 0; swap < 2; swap++) {
-      if (!((1 << swap) & ops))
-         continue;
-
-      Operand operands[3];
-      bool clamp, precise;
-      bitarray8 neg = 0, abs = 0, opsel = 0;
-      uint8_t omod = 0;
-      if (match_op3_for_vop3(ctx, instr->opcode, op2, instr.get(), swap, shuffle, operands, neg,
-                             abs, opsel, &clamp, &omod, NULL, NULL, NULL, &precise)) {
-         ctx.uses[instr->operands[swap].tempId()]--;
-         create_vop3_for_op3(ctx, new_op, instr, operands, neg, abs, opsel, clamp, omod);
-         return true;
-      }
-   }
-   return false;
-}
-
 /* v_not(v_xor(a, b)) -> v_xnor(a, b) */
 bool
 combine_not_xor(opt_ctx& ctx, aco_ptr<Instruction>& instr)
@@ -3781,36 +3664,6 @@ combine_add_sub_b2i(opt_ctx& ctx, aco_ptr<Instruction>& instr, aco_opcode new_op
    return false;
 }
 
-bool
-combine_add_bcnt(opt_ctx& ctx, aco_ptr<Instruction>& instr)
-{
-   if (instr->usesModifiers())
-      return false;
-
-   for (unsigned i = 0; i < 2; i++) {
-      Instruction* op_instr = follow_operand(ctx, instr->operands[i]);
-      if (op_instr && op_instr->opcode == aco_opcode::v_bcnt_u32_b32 &&
-          !op_instr->usesModifiers() && op_instr->operands[0].isTemp() &&
-          op_instr->operands[0].getTemp().type() == RegType::vgpr &&
-          op_instr->operands[1].constantEquals(0)) {
-         aco_ptr<Instruction> new_instr{
-            create_instruction(aco_opcode::v_bcnt_u32_b32, Format::VOP3, 2, 1)};
-         ctx.uses[instr->operands[i].tempId()]--;
-         new_instr->operands[0] = op_instr->operands[0];
-         new_instr->operands[1] = instr->operands[!i];
-         new_instr->definitions[0] = instr->definitions[0];
-         new_instr->pass_flags = instr->pass_flags;
-         instr = std::move(new_instr);
-         ctx.info[instr->definitions[0].tempId()].label = 0;
-         ctx.info[instr->definitions[0].tempId()].parent_instr = instr.get();
-
-         return true;
-      }
-   }
-
-   return false;
-}
-
 bool
 interp_can_become_fma(opt_ctx& ctx, aco_ptr<Instruction>& instr)
 {
@@ -4366,6 +4219,57 @@ create_med3_cb(opt_ctx& ctx, alu_opt_info& info)
    return false;
 }
 
+template <unsigned bits>
+bool
+shift_to_mad_cb(opt_ctx& ctx, alu_opt_info& info)
+{
+   aco_type type = {aco_base_type_uint, 1, 32};
+   uint64_t constant = 0;
+   if (!op_info_get_constant(ctx, info.operands[1], type, &constant))
+      return false;
+
+   info.operands[1] = {Operand::c32(1u << (constant % bits))};
+   return true;
+}
+
+bool
+check_mul_u24_cb(opt_ctx& ctx, alu_opt_info& info)
+{
+   aco_type type = {aco_base_type_uint, 1, 32};
+   for (unsigned i = 0; i < 2; i++) {
+      uint64_t constant = 0;
+      if (op_info_get_constant(ctx, info.operands[i], type, &constant)) {
+         if (constant > 0xff'ffffu)
+            return false;
+      } else if (!info.operands[i].op.is24bit() && !info.operands[i].op.is16bit()) {
+         return false;
+      }
+   }
+
+   return true;
+}
+
+bool
+add_lm_def_cb(opt_ctx& ctx, alu_opt_info& info)
+{
+   info.defs.push_back(Definition(ctx.program->allocateTmp(ctx.program->lane_mask)));
+   /* Make sure the uses vector is large enough and the number of
+    * uses properly initialized to 0.
+    */
+   ctx.uses.push_back(0);
+   ctx.info.push_back(ssa_info{});
+   return true;
+}
+
+bool
+pop_def_cb(opt_ctx& ctx, alu_opt_info& info)
+{
+   assert(ctx.uses[info.defs.back().tempId()] == 0);
+   assert(info.defs.size() >= 2);
+   info.defs.pop_back();
+   return true;
+}
+
 bool
 check_constant(opt_ctx& ctx, alu_opt_info& info, unsigned idx, uint32_t expected)
 {
@@ -4523,20 +4427,6 @@ combine_instruction(opt_ctx& ctx, aco_ptr<Instruction>& instr)
    if (instr->isSDWA()) {
    } else if (instr->opcode == aco_opcode::v_not_b32 && ctx.program->gfx_level >= GFX10) {
       combine_not_xor(ctx, instr);
-   } else if (instr->opcode == aco_opcode::v_add_u32 && !instr->usesModifiers()) {
-      combine_add_sub_b2i(ctx, instr, aco_opcode::v_addc_co_u32, 1 | 2);
-   } else if ((instr->opcode == aco_opcode::v_add_co_u32 ||
-               instr->opcode == aco_opcode::v_add_co_u32_e64) &&
-              !instr->usesModifiers()) {
-      bool carry_out = ctx.uses[instr->definitions[1].tempId()] > 0;
-      if (combine_add_sub_b2i(ctx, instr, aco_opcode::v_addc_co_u32, 1 | 2)) {
-      } else if (!carry_out && combine_add_bcnt(ctx, instr)) {
-      } else if (!carry_out && combine_three_valu_op(ctx, instr, aco_opcode::v_mul_u32_u24,
-                                                     aco_opcode::v_mad_u32_u24, "120", 1 | 2)) {
-      } else if (!carry_out && combine_three_valu_op(ctx, instr, aco_opcode::v_mul_i32_i24,
-                                                     aco_opcode::v_mad_i32_i24, "120", 1 | 2)) {
-      } else if (!carry_out && combine_add_lshl(ctx, instr, false)) {
-      }
    } else if (instr->opcode == aco_opcode::v_sub_u32 || instr->opcode == aco_opcode::v_sub_co_u32 ||
               instr->opcode == aco_opcode::v_sub_co_u32_e64) {
       bool carry_out =
@@ -4759,6 +4649,25 @@ combine_instruction(opt_ctx& ctx, aco_ptr<Instruction>& instr)
       add_opt(s_add_i32, v_add3_u32, 0x3, "012", nullptr, true);
       add_opt(v_lshlrev_b32, v_lshl_add_u32, 0x3, "210", nullptr, true);
       add_opt(s_lshl_b32, v_lshl_add_u32, 0x3, "120", nullptr, true);
+      /* v_add_u32(a, v_cndmask_b32(0, 1, cond)) -> v_addc_co_u32(a, 0, cond) */
+      add_opt(v_cndmask_b32, v_addc_co_u32, 0x3, "0132",
+              and_cb<and_cb<check_const_cb<1, 0>, remove_const_cb<1>>, add_lm_def_cb>, true);
+   } else if ((info.opcode == aco_opcode::v_add_co_u32 ||
+               info.opcode == aco_opcode::v_add_co_u32_e64) &&
+              !info.clamp) {
+      /* v_add_co_u32(a, v_cndmask_b32(0, 1, cond)) -> v_addc_co_u32(a, 0, cond) */
+      add_opt(v_cndmask_b32, v_addc_co_u32, 0x3, "0132",
+              and_cb<check_const_cb<1, 0>, remove_const_cb<1>>);
+      if (ctx.uses[info.defs[1].tempId()] == 0) {
+         add_opt(v_bcnt_u32_b32, v_bcnt_u32_b32, 0x3, "102",
+                 and_cb<remove_const_cb<0>, pop_def_cb>);
+         add_opt(v_mul_u32_u24, v_mad_u32_u24, 0x3, "120", pop_def_cb);
+         add_opt(v_mul_i32_i24, v_mad_i32_i24, 0x3, "120", pop_def_cb);
+         add_opt(v_lshlrev_b32, v_mad_u32_u24, 0x3, "210",
+                 and_cb<and_cb<shift_to_mad_cb<32>, check_mul_u24_cb>, pop_def_cb>);
+         add_opt(s_lshl_b32, v_mad_u32_u24, 0x3, "120",
+                 and_cb<and_cb<shift_to_mad_cb<32>, check_mul_u24_cb>, pop_def_cb>);
+      }
    } else if ((info.opcode == aco_opcode::s_add_u32 ||
                (info.opcode == aco_opcode::s_add_i32 && !ctx.uses[info.defs[1].tempId()])) &&
               ctx.program->gfx_level >= GFX9) {
diff --git a/src/amd/compiler/tests/test_optimizer.cpp b/src/amd/compiler/tests/test_optimizer.cpp
index 861bf6ce9fca9..58a08961a83f9 100644
--- a/src/amd/compiler/tests/test_optimizer.cpp
+++ b/src/amd/compiler/tests/test_optimizer.cpp
@@ -363,9 +363,7 @@ BEGIN_TEST(optimize.bcnt)
       bcnt = bld.vop3(aco_opcode::v_bcnt_u32_b32, bld.def(v1), Operand(inputs[0]), Operand::zero());
       writeout(2, bld.vadd32(bld.def(v1), bcnt, Operand::c32(42u)));
 
-      //~gfx8! v1: %bnct3 = v_bcnt_u32_b32 %b, 0
-      //~gfx8! v1: %res3, s2: %_ = v_add_co_u32 %bcnt3, %a
-      //~gfx(9|10)! v1: %res3 = v_bcnt_u32_b32 %b, %a
+      //! v1: %res3 = v_bcnt_u32_b32 %b, %a
       //! p_unit_test 3, %res3
       bcnt = bld.vop3(aco_opcode::v_bcnt_u32_b32, bld.def(v1), Operand(inputs[1]), Operand::zero());
       writeout(3, bld.vadd32(bld.def(v1), bcnt, Operand(inputs[0])));
-- 
GitLab


From 8922ce69c47d52cf0dc79d735d70a4d9d17f1b84 Mon Sep 17 00:00:00 2001
From: Georg Lehmann <dadschoorse@gmail.com>
Date: Mon, 16 Dec 2024 12:22:23 +0100
Subject: [PATCH 11/29] aco/optimizer: use new helpers for v_sub opts

Foz-DB Navi21:
Totals from 314 (0.39% of 79789) affected shaders:
Instrs: 589826 -> 589811 (-0.00%)
CodeSize: 3200704 -> 3200716 (+0.00%); split: -0.00%, +0.00%
Latency: 7141427 -> 7141383 (-0.00%)
InvThroughput: 2238627 -> 2238606 (-0.00%)
Copies: 46038 -> 46037 (-0.00%)
VALU: 421179 -> 421167 (-0.00%)
SALU: 67355 -> 67353 (-0.00%)
---
 src/amd/compiler/aco_optimizer.cpp | 234 ++++++-----------------------
 1 file changed, 43 insertions(+), 191 deletions(-)

diff --git a/src/amd/compiler/aco_optimizer.cpp b/src/amd/compiler/aco_optimizer.cpp
index ccd5bd40bdc75..632cd87f5e33d 100644
--- a/src/amd/compiler/aco_optimizer.cpp
+++ b/src/amd/compiler/aco_optimizer.cpp
@@ -72,7 +72,6 @@ enum Label {
    label_clamp = 1ull << 36,
    label_insert = 1ull << 38,
    label_f2f16 = 1ull << 39,
-   label_b2i = 1ull << 41,
 };
 
 static constexpr uint64_t instr_mod_labels =
@@ -82,7 +81,7 @@ static constexpr uint64_t input_mod_labels =
    label_abs_fp16 | label_abs_fp32_64 | label_neg_fp16 | label_neg_fp32_64;
 
 static constexpr uint64_t temp_labels = label_temp | label_uniform_bool | label_scc_invert |
-                                        label_b2i | input_mod_labels | label_fcanonicalize_fp32_64 |
+                                        input_mod_labels | label_fcanonicalize_fp32_64 |
                                         label_fcanonicalize_fp16;
 
 static constexpr uint64_t val_labels = label_constant | label_combined_instr;
@@ -272,14 +271,6 @@ struct ssa_info {
 
    bool is_uniform_bool() { return label & label_uniform_bool; }
 
-   void set_b2i(Temp b2i_val)
-   {
-      add_label(label_b2i);
-      temp = b2i_val;
-   }
-
-   bool is_b2i() { return label & label_b2i; }
-
    void set_fcanonicalize(Temp tmp, unsigned bit_size)
    {
       assert(bit_size == 16 || bit_size == 32 || bit_size == 64);
@@ -1742,55 +1733,6 @@ pseudo_can_accept_constant(const aco_ptr<Instruction>& instr, unsigned operand)
    }
 }
 
-/* check constant bus and literal limitations */
-bool
-check_vop3_operands(opt_ctx& ctx, unsigned num_operands, Operand* operands)
-{
-   int limit = ctx.program->gfx_level >= GFX10 ? 2 : 1;
-   Operand literal32(s1);
-   Operand literal64(s2);
-   unsigned num_sgprs = 0;
-   unsigned sgpr[] = {0, 0};
-
-   for (unsigned i = 0; i < num_operands; i++) {
-      Operand op = operands[i];
-
-      if (op.hasRegClass() && op.regClass().type() == RegType::sgpr) {
-         /* two reads of the same SGPR count as 1 to the limit */
-         if (op.tempId() != sgpr[0] && op.tempId() != sgpr[1]) {
-            if (num_sgprs < 2)
-               sgpr[num_sgprs++] = op.tempId();
-            limit--;
-            if (limit < 0)
-               return false;
-         }
-      } else if (op.isLiteral()) {
-         if (ctx.program->gfx_level < GFX10)
-            return false;
-
-         if (!literal32.isUndefined() && literal32.constantValue() != op.constantValue())
-            return false;
-         if (!literal64.isUndefined() && literal64.constantValue() != op.constantValue())
-            return false;
-
-         /* Any number of 32-bit literals counts as only 1 to the limit. Same
-          * (but separately) for 64-bit literals. */
-         if (op.size() == 1 && literal32.isUndefined()) {
-            limit--;
-            literal32 = op;
-         } else if (op.size() == 2 && literal64.isUndefined()) {
-            limit--;
-            literal64 = op;
-         }
-
-         if (limit < 0)
-            return false;
-      }
-   }
-
-   return true;
-}
-
 bool
 parse_base_offset(opt_ctx& ctx, Instruction* instr, unsigned op_index, Temp* base, uint32_t* offset,
                   bool prevent_overflow)
@@ -2929,11 +2871,6 @@ label_instruction(opt_ctx& ctx, aco_ptr<Instruction>& instr)
          ctx.info[instr->operands[idx].tempId()].set_clamp(instr.get());
       break;
    }
-   case aco_opcode::v_cndmask_b32:
-      if (instr->operands[0].constantEquals(0) && instr->operands[1].constantEquals(1))
-         ctx.info[instr->definitions[0].tempId()].set_b2i(instr->operands[2].getTemp());
-
-      break;
    case aco_opcode::s_not_b32:
    case aco_opcode::s_not_b64:
       if (!instr->operands[0].isTemp()) {
@@ -3615,55 +3552,6 @@ use_absdiff:
    return true;
 }
 
-bool
-combine_add_sub_b2i(opt_ctx& ctx, aco_ptr<Instruction>& instr, aco_opcode new_op, uint8_t ops)
-{
-   if (instr->usesModifiers())
-      return false;
-
-   for (unsigned i = 0; i < 2; i++) {
-      if (!((1 << i) & ops))
-         continue;
-      if (instr->operands[i].isTemp() && ctx.info[instr->operands[i].tempId()].is_b2i() &&
-          ctx.uses[instr->operands[i].tempId()] == 1) {
-
-         aco_ptr<Instruction> new_instr;
-         if (instr->operands[!i].isTemp() &&
-             instr->operands[!i].getTemp().type() == RegType::vgpr) {
-            new_instr.reset(create_instruction(new_op, Format::VOP2, 3, 2));
-         } else if (ctx.program->gfx_level >= GFX10 ||
-                    (instr->operands[!i].isConstant() && !instr->operands[!i].isLiteral())) {
-            new_instr.reset(create_instruction(new_op, asVOP3(Format::VOP2), 3, 2));
-         } else {
-            return false;
-         }
-         ctx.uses[instr->operands[i].tempId()]--;
-         new_instr->definitions[0] = instr->definitions[0];
-         if (instr->definitions.size() == 2) {
-            new_instr->definitions[1] = instr->definitions[1];
-         } else {
-            new_instr->definitions[1] =
-               Definition(ctx.program->allocateTmp(ctx.program->lane_mask));
-            /* Make sure the uses vector is large enough and the number of
-             * uses properly initialized to 0.
-             */
-            ctx.uses.push_back(0);
-            ctx.info.push_back(ssa_info{});
-         }
-         new_instr->operands[0] = Operand::zero();
-         new_instr->operands[1] = instr->operands[!i];
-         new_instr->operands[2] = Operand(ctx.info[instr->operands[i].tempId()].temp);
-         new_instr->pass_flags = instr->pass_flags;
-         instr = std::move(new_instr);
-         ctx.info[instr->definitions[0].tempId()].parent_instr = instr.get();
-         ctx.info[instr->definitions[1].tempId()].parent_instr = instr.get();
-         return true;
-      }
-   }
-
-   return false;
-}
-
 bool
 interp_can_become_fma(opt_ctx& ctx, aco_ptr<Instruction>& instr)
 {
@@ -3931,73 +3819,6 @@ apply_load_extract(opt_ctx& ctx, aco_ptr<Instruction>& extract)
    return true;
 }
 
-/* v_add_co(c, s_lshl(a, b)) -> v_mad_u32_u24(a, 1<<b, c)
- * v_add_co(c, v_lshlrev(a, b)) -> v_mad_u32_u24(b, 1<<a, c)
- * v_sub(c, s_lshl(a, b)) -> v_mad_i32_i24(a, -(1<<b), c)
- * v_sub(c, v_lshlrev(a, b)) -> v_mad_i32_i24(b, -(1<<a), c)
- */
-bool
-combine_add_lshl(opt_ctx& ctx, aco_ptr<Instruction>& instr, bool is_sub)
-{
-   if (instr->usesModifiers())
-      return false;
-
-   /* Substractions: start at operand 1 to avoid mixup such as
-    * turning v_sub(v_lshlrev(a, b), c) into v_mad_i32_i24(b, -(1<<a), c)
-    */
-   unsigned start_op_idx = is_sub ? 1 : 0;
-
-   /* Don't allow 24-bit operands on subtraction because
-    * v_mad_i32_i24 applies a sign extension.
-    */
-   bool allow_24bit = !is_sub;
-
-   for (unsigned i = start_op_idx; i < 2; i++) {
-      Instruction* op_instr = follow_operand(ctx, instr->operands[i]);
-      if (!op_instr)
-         continue;
-
-      if (op_instr->opcode != aco_opcode::s_lshl_b32 &&
-          op_instr->opcode != aco_opcode::v_lshlrev_b32)
-         continue;
-
-      int shift_op_idx = op_instr->opcode == aco_opcode::s_lshl_b32 ? 1 : 0;
-
-      if (op_instr->operands[shift_op_idx].isConstant() &&
-          ((allow_24bit && op_instr->operands[!shift_op_idx].is24bit()) ||
-           op_instr->operands[!shift_op_idx].is16bit())) {
-         uint32_t multiplier = 1 << (op_instr->operands[shift_op_idx].constantValue() % 32u);
-         if (is_sub)
-            multiplier = -multiplier;
-         if (is_sub ? (multiplier < 0xff800000) : (multiplier > 0xffffff))
-            continue;
-
-         Operand ops[3] = {
-            op_instr->operands[!shift_op_idx],
-            Operand::c32(multiplier),
-            instr->operands[!i],
-         };
-         if (!check_vop3_operands(ctx, 3, ops))
-            return false;
-
-         ctx.uses[instr->operands[i].tempId()]--;
-
-         aco_opcode mad_op = is_sub ? aco_opcode::v_mad_i32_i24 : aco_opcode::v_mad_u32_u24;
-         aco_ptr<Instruction> new_instr{create_instruction(mad_op, Format::VOP3, 3, 1)};
-         for (unsigned op_idx = 0; op_idx < 3; ++op_idx)
-            new_instr->operands[op_idx] = ops[op_idx];
-         new_instr->definitions[0] = instr->definitions[0];
-         new_instr->pass_flags = instr->pass_flags;
-         instr = std::move(new_instr);
-         ctx.info[instr->definitions[0].tempId()].label = 0;
-         ctx.info[instr->definitions[0].tempId()].parent_instr = instr.get();
-         return true;
-      }
-   }
-
-   return false;
-}
-
 void
 propagate_swizzles(VALU_instruction* instr, bool opsel_lo, bool opsel_hi)
 {
@@ -4249,6 +4070,28 @@ check_mul_u24_cb(opt_ctx& ctx, alu_opt_info& info)
    return true;
 }
 
+bool
+neg_mul_to_i24_cb(opt_ctx& ctx, alu_opt_info& info)
+{
+   aco_type type = {aco_base_type_uint, 1, 32};
+   for (unsigned i = 0; i < 2; i++) {
+      /* v_mad_i32_i24 sign extends, so is16bit is the best thing we have. */
+      if (!info.operands[!i].op.is16bit())
+         continue;
+      uint64_t constant = 0;
+      if (!op_info_get_constant(ctx, info.operands[i], type, &constant))
+         continue;
+
+      int32_t multiplier = -constant;
+      if (multiplier < int32_t(0xff80'0000) || multiplier > 0x007f'ffff)
+         return false;
+      info.operands[i] = {Operand::c32(multiplier)};
+      return true;
+   }
+
+   return false;
+}
+
 bool
 add_lm_def_cb(opt_ctx& ctx, alu_opt_info& info)
 {
@@ -4427,17 +4270,6 @@ combine_instruction(opt_ctx& ctx, aco_ptr<Instruction>& instr)
    if (instr->isSDWA()) {
    } else if (instr->opcode == aco_opcode::v_not_b32 && ctx.program->gfx_level >= GFX10) {
       combine_not_xor(ctx, instr);
-   } else if (instr->opcode == aco_opcode::v_sub_u32 || instr->opcode == aco_opcode::v_sub_co_u32 ||
-              instr->opcode == aco_opcode::v_sub_co_u32_e64) {
-      bool carry_out =
-         instr->opcode != aco_opcode::v_sub_u32 && ctx.uses[instr->definitions[1].tempId()] > 0;
-      if (combine_add_sub_b2i(ctx, instr, aco_opcode::v_subbrev_co_u32, 2)) {
-      } else if (!carry_out && combine_add_lshl(ctx, instr, true)) {
-      }
-   } else if (instr->opcode == aco_opcode::v_subrev_u32 ||
-              instr->opcode == aco_opcode::v_subrev_co_u32 ||
-              instr->opcode == aco_opcode::v_subrev_co_u32_e64) {
-      combine_add_sub_b2i(ctx, instr, aco_opcode::v_subbrev_co_u32, 1);
    } else if (instr->opcode == aco_opcode::s_not_b32 || instr->opcode == aco_opcode::s_not_b64) {
       if (!combine_salu_not_bitwise(ctx, instr))
          combine_inverse_comparison(ctx, instr);
@@ -4668,6 +4500,26 @@ combine_instruction(opt_ctx& ctx, aco_ptr<Instruction>& instr)
          add_opt(s_lshl_b32, v_mad_u32_u24, 0x3, "120",
                  and_cb<and_cb<shift_to_mad_cb<32>, check_mul_u24_cb>, pop_def_cb>);
       }
+   } else if (info.opcode == aco_opcode::v_sub_u32 && !info.clamp) {
+      /* v_sub_u32(a, v_cndmask_b32(0, 1, cond)) -> v_subb_co_u32(a, 0, cond) */
+      add_opt(v_cndmask_b32, v_subb_co_u32, 0x2, "0132",
+              and_cb<and_cb<check_const_cb<1, 0>, remove_const_cb<1>>, add_lm_def_cb>);
+      add_opt(v_lshlrev_b32, v_mad_i32_i24, 0x2, "210",
+              and_cb<shift_to_mad_cb<32>, neg_mul_to_i24_cb>);
+      add_opt(s_lshl_b32, v_mad_i32_i24, 0x2, "120",
+              and_cb<shift_to_mad_cb<32>, neg_mul_to_i24_cb>);
+   } else if ((info.opcode == aco_opcode::v_sub_co_u32 ||
+               info.opcode == aco_opcode::v_sub_co_u32_e64) &&
+              !info.clamp) {
+      /* v_sub_co_u32(a, v_cndmask_b32(0, 1, cond)) -> v_subb_co_u32(a, 0, cond) */
+      add_opt(v_cndmask_b32, v_subb_co_u32, 0x2, "0132",
+              and_cb<check_const_cb<1, 0>, remove_const_cb<1>>);
+      if (ctx.uses[info.defs[1].tempId()] == 0) {
+         add_opt(v_lshlrev_b32, v_mad_i32_i24, 0x2, "210",
+                 and_cb<and_cb<shift_to_mad_cb<32>, neg_mul_to_i24_cb>, pop_def_cb>);
+         add_opt(s_lshl_b32, v_mad_i32_i24, 0x2, "120",
+                 and_cb<and_cb<shift_to_mad_cb<32>, neg_mul_to_i24_cb>, pop_def_cb>);
+      }
    } else if ((info.opcode == aco_opcode::s_add_u32 ||
                (info.opcode == aco_opcode::s_add_i32 && !ctx.uses[info.defs[1].tempId()])) &&
               ctx.program->gfx_level >= GFX9) {
-- 
GitLab


From c5bce18d6f22cb36f4c641827b61617697786de3 Mon Sep 17 00:00:00 2001
From: Georg Lehmann <dadschoorse@gmail.com>
Date: Mon, 16 Dec 2024 12:27:10 +0100
Subject: [PATCH 12/29] aco/optimizer: use new helpers for bitwise n2 opts

Foz-DB Navi21:
Totals from 541 (0.68% of 79789) affected shaders:
Instrs: 1874265 -> 1873275 (-0.05%); split: -0.05%, +0.00%
CodeSize: 10213380 -> 10211436 (-0.02%); split: -0.03%, +0.01%
SpillSGPRs: 117 -> 115 (-1.71%)
Latency: 12086897 -> 12087885 (+0.01%); split: -0.00%, +0.01%
InvThroughput: 5308443 -> 5308437 (-0.00%); split: -0.00%, +0.00%
VClause: 44195 -> 44196 (+0.00%)
SClause: 61633 -> 61635 (+0.00%)
Copies: 169676 -> 169681 (+0.00%); split: -0.00%, +0.01%
PreSGPRs: 32316 -> 32262 (-0.17%)
VALU: 1209375 -> 1209369 (-0.00%)
SALU: 288800 -> 287817 (-0.34%); split: -0.34%, +0.00%
---
 src/amd/compiler/aco_optimizer.cpp | 58 +++++++-----------------------
 1 file changed, 13 insertions(+), 45 deletions(-)

diff --git a/src/amd/compiler/aco_optimizer.cpp b/src/amd/compiler/aco_optimizer.cpp
index 632cd87f5e33d..ca13d7c35b7e4 100644
--- a/src/amd/compiler/aco_optimizer.cpp
+++ b/src/amd/compiler/aco_optimizer.cpp
@@ -3469,46 +3469,6 @@ combine_salu_not_bitwise(opt_ctx& ctx, aco_ptr<Instruction>& instr)
    return true;
 }
 
-/* s_and_b32(a, s_not_b32(b)) -> s_andn2_b32(a, b)
- * s_or_b32(a, s_not_b32(b)) -> s_orn2_b32(a, b)
- * s_and_b64(a, s_not_b64(b)) -> s_andn2_b64(a, b)
- * s_or_b64(a, s_not_b64(b)) -> s_orn2_b64(a, b) */
-bool
-combine_salu_n2(opt_ctx& ctx, aco_ptr<Instruction>& instr)
-{
-   if (instr->definitions[0].isTemp() && ctx.info[instr->definitions[0].tempId()].is_uniform_bool())
-      return false;
-
-   for (unsigned i = 0; i < 2; i++) {
-      Instruction* op2_instr = follow_operand(ctx, instr->operands[i]);
-      if (!op2_instr || (op2_instr->opcode != aco_opcode::s_not_b32 &&
-                         op2_instr->opcode != aco_opcode::s_not_b64))
-         continue;
-      if (ctx.uses[op2_instr->definitions[1].tempId()])
-         continue;
-
-      if (instr->operands[!i].isLiteral() && op2_instr->operands[0].isLiteral() &&
-          instr->operands[!i].constantValue() != op2_instr->operands[0].constantValue())
-         continue;
-
-      ctx.uses[instr->operands[i].tempId()]--;
-      instr->operands[0] = instr->operands[!i];
-      instr->operands[1] = op2_instr->operands[0];
-      ctx.info[instr->definitions[0].tempId()].label = 0;
-
-      switch (instr->opcode) {
-      case aco_opcode::s_and_b32: instr->opcode = aco_opcode::s_andn2_b32; break;
-      case aco_opcode::s_or_b32: instr->opcode = aco_opcode::s_orn2_b32; break;
-      case aco_opcode::s_and_b64: instr->opcode = aco_opcode::s_andn2_b64; break;
-      case aco_opcode::s_or_b64: instr->opcode = aco_opcode::s_orn2_b64; break;
-      default: break;
-      }
-
-      return true;
-   }
-   return false;
-}
-
 /* s_abs_i32(s_sub_[iu]32(a, b)) -> s_absdiff_i32(a, b)
  * s_abs_i32(s_add_[iu]32(a, #b)) -> s_absdiff_i32(a, -b)
  */
@@ -4267,15 +4227,11 @@ combine_instruction(opt_ctx& ctx, aco_ptr<Instruction>& instr)
       return;
    }
 
-   if (instr->isSDWA()) {
-   } else if (instr->opcode == aco_opcode::v_not_b32 && ctx.program->gfx_level >= GFX10) {
+   if (instr->opcode == aco_opcode::v_not_b32 && ctx.program->gfx_level >= GFX10) {
       combine_not_xor(ctx, instr);
    } else if (instr->opcode == aco_opcode::s_not_b32 || instr->opcode == aco_opcode::s_not_b64) {
       if (!combine_salu_not_bitwise(ctx, instr))
          combine_inverse_comparison(ctx, instr);
-   } else if (instr->opcode == aco_opcode::s_and_b32 || instr->opcode == aco_opcode::s_or_b32 ||
-              instr->opcode == aco_opcode::s_and_b64 || instr->opcode == aco_opcode::s_or_b64) {
-      combine_salu_n2(ctx, instr);
    } else if (instr->opcode == aco_opcode::s_abs_i32) {
       combine_sabsdiff(ctx, instr);
    }
@@ -4534,6 +4490,18 @@ combine_instruction(opt_ctx& ctx, aco_ptr<Instruction>& instr)
    } else if (info.opcode == aco_opcode::v_and_b32) {
       add_opt(v_not_b32, v_bfi_b32, 0x3, "10", insert_const_cb<1, 0>, true);
       add_opt(s_not_b32, v_bfi_b32, 0x3, "10", insert_const_cb<1, 0>, true);
+   } else if (info.opcode == aco_opcode::s_and_b32) {
+      add_opt(s_not_b32, s_andn2_b32, 0x3, "01");
+   } else if (info.opcode == aco_opcode::s_and_b64) {
+      add_opt(s_not_b64, s_andn2_b64, 0x3, "01");
+   } else if (info.opcode == aco_opcode::s_or_b32) {
+      add_opt(s_not_b32, s_orn2_b32, 0x3, "01");
+   } else if (info.opcode == aco_opcode::s_or_b64) {
+      add_opt(s_not_b64, s_orn2_b64, 0x3, "01");
+   } else if (info.opcode == aco_opcode::s_xor_b32) {
+      add_opt(s_not_b32, s_xnor_b32, 0x3, "01");
+   } else if (info.opcode == aco_opcode::s_xor_b64) {
+      add_opt(s_not_b64, s_xnor_b64, 0x3, "01");
    }
 
    if (match_and_apply_patterns(ctx, info, patterns)) {
-- 
GitLab


From 48b7337edb19f294524b36fb82aae42ea40ddd5d Mon Sep 17 00:00:00 2001
From: Georg Lehmann <dadschoorse@gmail.com>
Date: Sat, 1 Mar 2025 11:26:02 +0100
Subject: [PATCH 13/29] aco/optimizer: add some bitop combining

Foz-DB Navi21:
Totals from 26 (0.03% of 79789) affected shaders:
Instrs: 927018 -> 926921 (-0.01%)
CodeSize: 5002896 -> 5002436 (-0.01%)
Latency: 5107955 -> 5107769 (-0.00%)
InvThroughput: 1280992 -> 1280935 (-0.00%)
PreSGPRs: 1397 -> 1399 (+0.14%)
PreVGPRs: 2511 -> 2512 (+0.04%)
VALU: 609021 -> 608926 (-0.02%)
SALU: 135743 -> 135741 (-0.00%)
---
 src/amd/compiler/aco_optimizer.cpp | 10 ++++++++++
 1 file changed, 10 insertions(+)

diff --git a/src/amd/compiler/aco_optimizer.cpp b/src/amd/compiler/aco_optimizer.cpp
index ca13d7c35b7e4..84715e6afdc4f 100644
--- a/src/amd/compiler/aco_optimizer.cpp
+++ b/src/amd/compiler/aco_optimizer.cpp
@@ -4427,6 +4427,9 @@ combine_instruction(opt_ctx& ctx, aco_ptr<Instruction>& instr)
       add_opt(s_not_b32, v_xnor_b32, 0x3, "01", nullptr, true);
    } else if (info.opcode == aco_opcode::v_add_u32 && !info.clamp) {
       add_opt(v_bcnt_u32_b32, v_bcnt_u32_b32, 0x3, "102", remove_const_cb<0>, true);
+      add_opt(s_bcnt1_i32_b32, v_bcnt_u32_b32, 0x3, "10", nullptr, true);
+      add_opt(v_mbcnt_lo_u32_b32, v_mbcnt_lo_u32_b32, 0x3, "102", remove_const_cb<0>, true);
+      add_opt(v_mbcnt_hi_u32_b32_e64, v_mbcnt_hi_u32_b32_e64, 0x3, "102", remove_const_cb<0>, true);
       add_opt(v_mad_u32_u16, v_mad_u32_u16, 0x3, "1203", remove_const_cb<0>, true);
       add_opt(v_mul_u32_u24, v_mad_u32_u24, 0x3, "120", nullptr, true);
       add_opt(v_mul_i32_i24, v_mad_i32_i24, 0x3, "120", nullptr, true);
@@ -4449,6 +4452,13 @@ combine_instruction(opt_ctx& ctx, aco_ptr<Instruction>& instr)
       if (ctx.uses[info.defs[1].tempId()] == 0) {
          add_opt(v_bcnt_u32_b32, v_bcnt_u32_b32, 0x3, "102",
                  and_cb<remove_const_cb<0>, pop_def_cb>);
+         add_opt(s_bcnt1_i32_b32, v_bcnt_u32_b32, 0x3, "10", pop_def_cb);
+         add_opt(v_mbcnt_lo_u32_b32, v_mbcnt_lo_u32_b32, 0x3, "102",
+                 and_cb<remove_const_cb<0>, pop_def_cb>);
+         add_opt(v_mbcnt_hi_u32_b32, v_mbcnt_hi_u32_b32, 0x3, "102",
+                 and_cb<remove_const_cb<0>, pop_def_cb>);
+         add_opt(v_mbcnt_hi_u32_b32_e64, v_mbcnt_hi_u32_b32_e64, 0x3, "102",
+                 and_cb<remove_const_cb<0>, pop_def_cb>);
          add_opt(v_mul_u32_u24, v_mad_u32_u24, 0x3, "120", pop_def_cb);
          add_opt(v_mul_i32_i24, v_mad_i32_i24, 0x3, "120", pop_def_cb);
          add_opt(v_lshlrev_b32, v_mad_u32_u24, 0x3, "210",
-- 
GitLab


From 1b52d2fa4f8fbde4f09a6f6bf7a4b47308e6aff0 Mon Sep 17 00:00:00 2001
From: Georg Lehmann <dadschoorse@gmail.com>
Date: Sat, 1 Mar 2025 11:26:25 +0100
Subject: [PATCH 14/29] aco/optimizer: use cndmask for neg(b2i)

Foz-DB Navi21:
Totals from 306 (0.38% of 79789) affected shaders:
Instrs: 585438 -> 585434 (-0.00%)
CodeSize: 3175520 -> 3175504 (-0.00%)
Latency: 7125792 -> 7125796 (+0.00%); split: -0.00%, +0.00%
InvThroughput: 2235206 -> 2235217 (+0.00%); split: -0.00%, +0.00%
Branches: 13439 -> 13435 (-0.03%)
---
 src/amd/compiler/aco_optimizer.cpp | 11 +++++++++++
 1 file changed, 11 insertions(+)

diff --git a/src/amd/compiler/aco_optimizer.cpp b/src/amd/compiler/aco_optimizer.cpp
index 84715e6afdc4f..01829c16bccbf 100644
--- a/src/amd/compiler/aco_optimizer.cpp
+++ b/src/amd/compiler/aco_optimizer.cpp
@@ -4467,6 +4467,10 @@ combine_instruction(opt_ctx& ctx, aco_ptr<Instruction>& instr)
                  and_cb<and_cb<shift_to_mad_cb<32>, check_mul_u24_cb>, pop_def_cb>);
       }
    } else if (info.opcode == aco_opcode::v_sub_u32 && !info.clamp) {
+      /* v_sub_u32(0, v_cndmask_b32(0, 1, cond)) -> v_cndmask_b32(0, -1, cond) */
+      add_opt(v_cndmask_b32, v_cndmask_b32, 0x2, "0312",
+              and_cb<and_cb<and_cb<check_const_cb<0, 0>, remove_const_cb<1>>, remove_const_cb<0>>,
+                     insert_const_cb<1, UINT32_MAX>>);
       /* v_sub_u32(a, v_cndmask_b32(0, 1, cond)) -> v_subb_co_u32(a, 0, cond) */
       add_opt(v_cndmask_b32, v_subb_co_u32, 0x2, "0132",
               and_cb<and_cb<check_const_cb<1, 0>, remove_const_cb<1>>, add_lm_def_cb>);
@@ -4477,6 +4481,13 @@ combine_instruction(opt_ctx& ctx, aco_ptr<Instruction>& instr)
    } else if ((info.opcode == aco_opcode::v_sub_co_u32 ||
                info.opcode == aco_opcode::v_sub_co_u32_e64) &&
               !info.clamp) {
+      /* v_sub_co_u32(0, v_cndmask_b32(0, 1, cond)) -> v_cndmask_b32(0, -1, cond) */
+      if (ctx.uses[info.defs[1].tempId()] == 0) {
+         add_opt(
+            v_cndmask_b32, v_cndmask_b32, 0x2, "0312",
+            and_cb<and_cb<and_cb<check_const_cb<0, 0>, remove_const_cb<1>>, remove_const_cb<0>>,
+                   and_cb<insert_const_cb<1, UINT32_MAX>, pop_def_cb>>);
+      }
       /* v_sub_co_u32(a, v_cndmask_b32(0, 1, cond)) -> v_subb_co_u32(a, 0, cond) */
       add_opt(v_cndmask_b32, v_subb_co_u32, 0x2, "0132",
               and_cb<check_const_cb<1, 0>, remove_const_cb<1>>);
-- 
GitLab


From f2d87c6a5726898c4436585173af83444e8f73e6 Mon Sep 17 00:00:00 2001
From: Georg Lehmann <dadschoorse@gmail.com>
Date: Mon, 10 Feb 2025 17:13:08 +0100
Subject: [PATCH 15/29] aco/optimizer: some more mul opts

Foz-DB Navi21:
Totals from 2025 (2.54% of 79789) affected shaders:
Instrs: 1248109 -> 1238187 (-0.79%); split: -0.80%, +0.00%
CodeSize: 6378116 -> 6382472 (+0.07%); split: -0.00%, +0.07%
Latency: 4504801 -> 4502311 (-0.06%); split: -0.06%, +0.01%
InvThroughput: 1159127 -> 1159154 (+0.00%); split: -0.00%, +0.00%
VClause: 26799 -> 26804 (+0.02%); split: -0.01%, +0.03%
SClause: 16639 -> 16649 (+0.06%); split: -0.01%, +0.07%
Copies: 74211 -> 74217 (+0.01%); split: -0.00%, +0.01%
VALU: 821872 -> 821893 (+0.00%); split: -0.00%, +0.00%
SALU: 136550 -> 126717 (-7.20%); split: -7.20%, +0.00%
---
 src/amd/compiler/aco_optimizer.cpp                          | 6 ++++++
 .../compiler/instruction_selection/aco_select_nir_alu.cpp   | 4 ++--
 2 files changed, 8 insertions(+), 2 deletions(-)

diff --git a/src/amd/compiler/aco_optimizer.cpp b/src/amd/compiler/aco_optimizer.cpp
index 01829c16bccbf..f75a4fb70a14b 100644
--- a/src/amd/compiler/aco_optimizer.cpp
+++ b/src/amd/compiler/aco_optimizer.cpp
@@ -4440,6 +4440,7 @@ combine_instruction(opt_ctx& ctx, aco_ptr<Instruction>& instr)
       add_opt(s_add_i32, v_add3_u32, 0x3, "012", nullptr, true);
       add_opt(v_lshlrev_b32, v_lshl_add_u32, 0x3, "210", nullptr, true);
       add_opt(s_lshl_b32, v_lshl_add_u32, 0x3, "120", nullptr, true);
+      add_opt(s_mul_i32, v_mad_u32_u24, 0x3, "120", check_mul_u24_cb, true);
       /* v_add_u32(a, v_cndmask_b32(0, 1, cond)) -> v_addc_co_u32(a, 0, cond) */
       add_opt(v_cndmask_b32, v_addc_co_u32, 0x3, "0132",
               and_cb<and_cb<check_const_cb<1, 0>, remove_const_cb<1>>, add_lm_def_cb>, true);
@@ -4465,6 +4466,7 @@ combine_instruction(opt_ctx& ctx, aco_ptr<Instruction>& instr)
                  and_cb<and_cb<shift_to_mad_cb<32>, check_mul_u24_cb>, pop_def_cb>);
          add_opt(s_lshl_b32, v_mad_u32_u24, 0x3, "120",
                  and_cb<and_cb<shift_to_mad_cb<32>, check_mul_u24_cb>, pop_def_cb>);
+         add_opt(s_mul_i32, v_mad_u32_u24, 0x3, "120", and_cb<check_mul_u24_cb, pop_def_cb>);
       }
    } else if (info.opcode == aco_opcode::v_sub_u32 && !info.clamp) {
       /* v_sub_u32(0, v_cndmask_b32(0, 1, cond)) -> v_cndmask_b32(0, -1, cond) */
@@ -4478,6 +4480,8 @@ combine_instruction(opt_ctx& ctx, aco_ptr<Instruction>& instr)
               and_cb<shift_to_mad_cb<32>, neg_mul_to_i24_cb>);
       add_opt(s_lshl_b32, v_mad_i32_i24, 0x2, "120",
               and_cb<shift_to_mad_cb<32>, neg_mul_to_i24_cb>);
+      add_opt(v_mul_u32_u24, v_mad_i32_i24, 0x2, "120", neg_mul_to_i24_cb);
+      add_opt(s_mul_i32, v_mad_i32_i24, 0x2, "120", neg_mul_to_i24_cb);
    } else if ((info.opcode == aco_opcode::v_sub_co_u32 ||
                info.opcode == aco_opcode::v_sub_co_u32_e64) &&
               !info.clamp) {
@@ -4496,6 +4500,8 @@ combine_instruction(opt_ctx& ctx, aco_ptr<Instruction>& instr)
                  and_cb<and_cb<shift_to_mad_cb<32>, neg_mul_to_i24_cb>, pop_def_cb>);
          add_opt(s_lshl_b32, v_mad_i32_i24, 0x2, "120",
                  and_cb<and_cb<shift_to_mad_cb<32>, neg_mul_to_i24_cb>, pop_def_cb>);
+         add_opt(v_mul_u32_u24, v_mad_i32_i24, 0x2, "120", and_cb<neg_mul_to_i24_cb, pop_def_cb>);
+         add_opt(s_mul_i32, v_mad_i32_i24, 0x2, "120", and_cb<neg_mul_to_i24_cb, pop_def_cb>);
       }
    } else if ((info.opcode == aco_opcode::s_add_u32 ||
                (info.opcode == aco_opcode::s_add_i32 && !ctx.uses[info.defs[1].tempId()])) &&
diff --git a/src/amd/compiler/instruction_selection/aco_select_nir_alu.cpp b/src/amd/compiler/instruction_selection/aco_select_nir_alu.cpp
index be45fe24e844b..43bc6f16dd6a4 100644
--- a/src/amd/compiler/instruction_selection/aco_select_nir_alu.cpp
+++ b/src/amd/compiler/instruction_selection/aco_select_nir_alu.cpp
@@ -1765,7 +1765,7 @@ visit_alu_instr(isel_context* ctx, nir_alu_instr* instr)
             emit_vop3a_instruction(ctx, instr, aco_opcode::v_mul_lo_u32, dst);
          }
       } else if (dst.regClass() == s1) {
-         emit_sop2_instruction(ctx, instr, aco_opcode::s_mul_i32, dst, false);
+         emit_sop2_instruction(ctx, instr, aco_opcode::s_mul_i32, dst, false, 0x3);
       } else {
          isel_err(&instr->instr, "Unimplemented NIR instr bit size");
       }
@@ -1773,7 +1773,7 @@ visit_alu_instr(isel_context* ctx, nir_alu_instr* instr)
    }
    case nir_op_imul24_relaxed: {
       if (dst.regClass() == s1) {
-         emit_sop2_instruction(ctx, instr, aco_opcode::s_mul_i32, dst, false);
+         emit_sop2_instruction(ctx, instr, aco_opcode::s_mul_i32, dst, false, 0x3);
       } else if (dst.regClass() == v1) {
          emit_vop2_instruction(ctx, instr, aco_opcode::v_mul_i32_i24, dst, true);
       } else {
-- 
GitLab


From 46f9901f8abdb1ac43d66e5258d3c65b2e3d43de Mon Sep 17 00:00:00 2001
From: Georg Lehmann <dadschoorse@gmail.com>
Date: Sat, 8 Mar 2025 11:35:19 +0100
Subject: [PATCH 16/29] aco/optimizer: create ff0/bcnt0

Foz-DB Navi21:
Totals from 1 (0.00% of 79789) affected shaders:
Instrs: 351 -> 348 (-0.85%)
CodeSize: 1800 -> 1788 (-0.67%)
Latency: 2585 -> 2576 (-0.35%)
SALU: 80 -> 77 (-3.75%)
---
 src/amd/compiler/aco_optimizer.cpp | 12 ++++++++++++
 1 file changed, 12 insertions(+)

diff --git a/src/amd/compiler/aco_optimizer.cpp b/src/amd/compiler/aco_optimizer.cpp
index f75a4fb70a14b..db4a75c5800cc 100644
--- a/src/amd/compiler/aco_optimizer.cpp
+++ b/src/amd/compiler/aco_optimizer.cpp
@@ -4529,6 +4529,18 @@ combine_instruction(opt_ctx& ctx, aco_ptr<Instruction>& instr)
       add_opt(s_not_b32, s_xnor_b32, 0x3, "01");
    } else if (info.opcode == aco_opcode::s_xor_b64) {
       add_opt(s_not_b64, s_xnor_b64, 0x3, "01");
+   } else if ((info.opcode == aco_opcode::s_sub_u32 || info.opcode == aco_opcode::s_sub_i32) &&
+              !ctx.uses[info.defs[1].tempId()]) {
+      add_opt(s_bcnt1_i32_b32, s_bcnt0_i32_b32, 0x2, "10", remove_const_cb<32>);
+      add_opt(s_bcnt1_i32_b64, s_bcnt0_i32_b64, 0x2, "10", remove_const_cb<64>);
+   } else if (info.opcode == aco_opcode::s_bcnt1_i32_b32) {
+      add_opt(s_not_b32, s_bcnt0_i32_b32, 0x1, "0");
+   } else if (info.opcode == aco_opcode::s_bcnt1_i32_b64) {
+      add_opt(s_not_b64, s_bcnt0_i32_b64, 0x1, "0");
+   } else if (info.opcode == aco_opcode::s_ff1_i32_b32 && ctx.program->gfx_level < GFX11) {
+      add_opt(s_not_b32, s_ff0_i32_b32, 0x1, "0");
+   } else if (info.opcode == aco_opcode::s_ff1_i32_b64 && ctx.program->gfx_level < GFX11) {
+      add_opt(s_not_b64, s_ff0_i32_b64, 0x1, "0");
    }
 
    if (match_and_apply_patterns(ctx, info, patterns)) {
-- 
GitLab


From bfd826795ede091f9b1541e9169f8fa1abc6aa91 Mon Sep 17 00:00:00 2001
From: Georg Lehmann <dadschoorse@gmail.com>
Date: Fri, 21 Mar 2025 16:12:51 +0100
Subject: [PATCH 17/29] aco/optimizer: extend existing patterns to handle
 b2f/b2i(not(a))

---
 src/amd/compiler/aco_optimizer.cpp | 20 ++++++++++++++++++++
 1 file changed, 20 insertions(+)

diff --git a/src/amd/compiler/aco_optimizer.cpp b/src/amd/compiler/aco_optimizer.cpp
index db4a75c5800cc..545e4059c8937 100644
--- a/src/amd/compiler/aco_optimizer.cpp
+++ b/src/amd/compiler/aco_optimizer.cpp
@@ -4393,6 +4393,9 @@ combine_instruction(opt_ctx& ctx, aco_ptr<Instruction>& instr)
       /* v_mul_f32(a, v_cndmask_b32(0, 1.0, cond)) -> v_cndmask_b32(0, a, cond) */
       add_opt(v_cndmask_b32, v_cndmask_b32, 0x3, "1032",
               and_cb<check_const_cb<0, 0>, remove_const_cb<0x3f800000>>, true);
+      /* v_mul_f32(a, v_cndmask_b32(1.0, 0, cond)) -> v_cndmask_b32(a, 0, cond) */
+      add_opt(v_cndmask_b32, v_cndmask_b32, 0x3, "0231",
+              and_cb<check_const_cb<1, 0>, remove_const_cb<0x3f800000>>, true);
    } else if (info.opcode == aco_opcode::v_add_u16 && !info.clamp) {
       if (ctx.program->gfx_level < GFX9) {
          add_opt(v_mul_lo_u16, v_mad_legacy_u16, 0x3, "120");
@@ -4444,6 +4447,11 @@ combine_instruction(opt_ctx& ctx, aco_ptr<Instruction>& instr)
       /* v_add_u32(a, v_cndmask_b32(0, 1, cond)) -> v_addc_co_u32(a, 0, cond) */
       add_opt(v_cndmask_b32, v_addc_co_u32, 0x3, "0132",
               and_cb<and_cb<check_const_cb<1, 0>, remove_const_cb<1>>, add_lm_def_cb>, true);
+      /* v_add_u32(a, v_cndmask_b32(1, 0, cond)) -> v_subb_co_u32(a, -1, cond) */
+      add_opt(v_cndmask_b32, v_subb_co_u32, 0x3, "0321",
+              and_cb<and_cb<remove_const_cb<1>, remove_const_cb<0>>,
+                     and_cb<insert_const_cb<1, UINT32_MAX>, add_lm_def_cb>>,
+              true);
    } else if ((info.opcode == aco_opcode::v_add_co_u32 ||
                info.opcode == aco_opcode::v_add_co_u32_e64) &&
               !info.clamp) {
@@ -4451,6 +4459,10 @@ combine_instruction(opt_ctx& ctx, aco_ptr<Instruction>& instr)
       add_opt(v_cndmask_b32, v_addc_co_u32, 0x3, "0132",
               and_cb<check_const_cb<1, 0>, remove_const_cb<1>>);
       if (ctx.uses[info.defs[1].tempId()] == 0) {
+         /* v_add_co_u32(a, v_cndmask_b32(1, 0, cond)) -> v_subb_co_u32(a, -1, cond) */
+         add_opt(
+            v_cndmask_b32, v_subb_co_u32, 0x3, "0321",
+            and_cb<and_cb<remove_const_cb<1>, remove_const_cb<0>>, insert_const_cb<1, UINT32_MAX>>);
          add_opt(v_bcnt_u32_b32, v_bcnt_u32_b32, 0x3, "102",
                  and_cb<remove_const_cb<0>, pop_def_cb>);
          add_opt(s_bcnt1_i32_b32, v_bcnt_u32_b32, 0x3, "10", pop_def_cb);
@@ -4476,6 +4488,10 @@ combine_instruction(opt_ctx& ctx, aco_ptr<Instruction>& instr)
       /* v_sub_u32(a, v_cndmask_b32(0, 1, cond)) -> v_subb_co_u32(a, 0, cond) */
       add_opt(v_cndmask_b32, v_subb_co_u32, 0x2, "0132",
               and_cb<and_cb<check_const_cb<1, 0>, remove_const_cb<1>>, add_lm_def_cb>);
+      /* v_sub_u32(a, v_cndmask_b32(1, 0, cond)) -> v_addc_co_u32(a, -1, cond) */
+      add_opt(v_cndmask_b32, v_addc_co_u32, 0x2, "0321",
+              and_cb<and_cb<remove_const_cb<1>, remove_const_cb<0>>,
+                     and_cb<insert_const_cb<1, UINT32_MAX>, add_lm_def_cb>>);
       add_opt(v_lshlrev_b32, v_mad_i32_i24, 0x2, "210",
               and_cb<shift_to_mad_cb<32>, neg_mul_to_i24_cb>);
       add_opt(s_lshl_b32, v_mad_i32_i24, 0x2, "120",
@@ -4496,6 +4512,10 @@ combine_instruction(opt_ctx& ctx, aco_ptr<Instruction>& instr)
       add_opt(v_cndmask_b32, v_subb_co_u32, 0x2, "0132",
               and_cb<check_const_cb<1, 0>, remove_const_cb<1>>);
       if (ctx.uses[info.defs[1].tempId()] == 0) {
+         /* v_sub_co_u32(a, v_cndmask_b32(1, 0, cond)) -> v_addc_co_u32(a, -1, cond) */
+         add_opt(
+            v_cndmask_b32, v_addc_co_u32, 0x2, "0321",
+            and_cb<and_cb<remove_const_cb<1>, remove_const_cb<0>>, insert_const_cb<1, UINT32_MAX>>);
          add_opt(v_lshlrev_b32, v_mad_i32_i24, 0x2, "210",
                  and_cb<and_cb<shift_to_mad_cb<32>, neg_mul_to_i24_cb>, pop_def_cb>);
          add_opt(s_lshl_b32, v_mad_i32_i24, 0x2, "120",
-- 
GitLab


From 8ee6b614e9912125f40db47facb3495e62a19066 Mon Sep 17 00:00:00 2001
From: Georg Lehmann <dadschoorse@gmail.com>
Date: Fri, 21 Mar 2025 15:40:59 +0100
Subject: [PATCH 18/29] aco/optimizer: optimze cndmask(a, b, not(c)) to
 cndmask(b, a, c)

Can happen with nir_op_bitz/b2f/b2i.

Foz-DB Navi21:
Totals from 3175 (3.98% of 79789) affected shaders:
MaxWaves: 60043 -> 60011 (-0.05%)
Instrs: 6097812 -> 6092945 (-0.08%); split: -0.08%, +0.00%
CodeSize: 33029560 -> 33011168 (-0.06%); split: -0.06%, +0.00%
VGPRs: 189408 -> 189440 (+0.02%)
Latency: 39437305 -> 39430859 (-0.02%); split: -0.02%, +0.00%
InvThroughput: 12290950 -> 12290230 (-0.01%); split: -0.01%, +0.00%
VClause: 141846 -> 141714 (-0.09%)
SClause: 150344 -> 150330 (-0.01%); split: -0.01%, +0.00%
Copies: 594434 -> 594342 (-0.02%); split: -0.03%, +0.01%
Branches: 169586 -> 169587 (+0.00%)
PreSGPRs: 160077 -> 160043 (-0.02%)
VALU: 4192082 -> 4192074 (-0.00%); split: -0.00%, +0.00%
SALU: 770940 -> 766118 (-0.63%); split: -0.63%, +0.00%
---
 src/amd/compiler/aco_optimizer.cpp | 8 +++++++-
 1 file changed, 7 insertions(+), 1 deletion(-)

diff --git a/src/amd/compiler/aco_optimizer.cpp b/src/amd/compiler/aco_optimizer.cpp
index 545e4059c8937..e997d96fab2da 100644
--- a/src/amd/compiler/aco_optimizer.cpp
+++ b/src/amd/compiler/aco_optimizer.cpp
@@ -3044,8 +3044,11 @@ backpropagate_input_modifiers(opt_ctx& ctx, alu_opt_info& info, const alu_opt_op
    if (info.uses_insert())
       return false;
 
+   assert(type.num_components != 0);
+
    /* Resolve swizzles first. */
-   if (op_info.op.size() > 1) {
+   if (type.bit_size == 1 || op_info.op.size() > 1) {
+      /* no swizzle */
       assert(type.num_components == 1);
    } else {
       bitarray8 swizzle = 0;
@@ -4561,6 +4564,9 @@ combine_instruction(opt_ctx& ctx, aco_ptr<Instruction>& instr)
       add_opt(s_not_b32, s_ff0_i32_b32, 0x1, "0");
    } else if (info.opcode == aco_opcode::s_ff1_i32_b64 && ctx.program->gfx_level < GFX11) {
       add_opt(s_not_b64, s_ff0_i32_b64, 0x1, "0");
+   } else if (info.opcode == aco_opcode::v_cndmask_b32) {
+      add_opt(s_not_b64, v_cndmask_b32, 0x4, "102");
+      add_opt(s_not_b32, v_cndmask_b32, 0x4, "102");
    }
 
    if (match_and_apply_patterns(ctx, info, patterns)) {
-- 
GitLab


From 0378aeef21c53bb535c0eb69be88dddeb9355035 Mon Sep 17 00:00:00 2001
From: Georg Lehmann <dadschoorse@gmail.com>
Date: Sat, 4 Jan 2025 16:59:41 +0100
Subject: [PATCH 19/29] aco/optimizer: new helpers for applying output
 modifiers

Foz-DB Navi21:
Totals from 339 (0.42% of 79789) affected shaders:
Instrs: 1181754 -> 1181475 (-0.02%)
CodeSize: 6435964 -> 6434752 (-0.02%)
SpillSGPRs: 435 -> 434 (-0.23%)
Latency: 8861149 -> 8861047 (-0.00%); split: -0.00%, +0.00%
InvThroughput: 2529292 -> 2529276 (-0.00%); split: -0.00%, +0.00%
Copies: 118392 -> 118384 (-0.01%); split: -0.01%, +0.00%
VALU: 757334 -> 757332 (-0.00%)
SALU: 188164 -> 187887 (-0.15%)

Changes are caused by optimizing not(salu) without killed scc.
---
 src/amd/compiler/aco_optimizer.cpp | 367 +++++++++++++++--------------
 1 file changed, 184 insertions(+), 183 deletions(-)

diff --git a/src/amd/compiler/aco_optimizer.cpp b/src/amd/compiler/aco_optimizer.cpp
index e997d96fab2da..6a0e9819408c1 100644
--- a/src/amd/compiler/aco_optimizer.cpp
+++ b/src/amd/compiler/aco_optimizer.cpp
@@ -311,6 +311,7 @@ struct opt_ctx {
    std::vector<ssa_info> info;
    std::vector<aco_ptr<Instruction>> pre_combine_instrs;
    std::vector<uint16_t> uses;
+   std::unordered_map<Instruction*, aco_ptr<Instruction>> replacement_instr;
 };
 
 aco_type
@@ -2975,35 +2976,6 @@ original_temp_id(opt_ctx& ctx, Temp tmp)
       return tmp.id();
 }
 
-Instruction*
-follow_operand(opt_ctx& ctx, Operand op, bool ignore_uses = false)
-{
-   if (!op.isTemp())
-      return nullptr;
-   if (!ignore_uses && ctx.uses[op.tempId()] > 1)
-      return nullptr;
-
-   Instruction* instr = ctx.info[op.tempId()].parent_instr;
-
-   if (instr->definitions[0].getTemp() != op.getTemp())
-      return nullptr;
-
-   if (instr->definitions.size() == 2) {
-      unsigned idx =
-         instr->definitions[1].isTemp() && instr->definitions[1].tempId() == op.tempId();
-      assert(instr->definitions[idx].isTemp() && instr->definitions[idx].tempId() == op.tempId());
-      if (instr->definitions[!idx].isTemp() && ctx.uses[instr->definitions[!idx].tempId()])
-         return nullptr;
-   }
-
-   for (Operand& operand : instr->operands) {
-      if (fixed_to_exec(operand))
-         return nullptr;
-   }
-
-   return instr;
-}
-
 bool
 is_operand_constant(opt_ctx& ctx, Operand op, unsigned bit_size, uint64_t* value)
 {
@@ -3112,6 +3084,11 @@ backpropagate_input_modifiers(opt_ctx& ctx, alu_opt_info& info, const alu_opt_op
    case aco_opcode::s_mul_f32:
    case aco_opcode::s_mul_f16:
    case aco_opcode::v_pk_mul_f16:
+   case aco_opcode::v_rcp_f64:
+   case aco_opcode::v_rcp_f32:
+   case aco_opcode::v_rcp_f16:
+   case aco_opcode::v_s_rcp_f32:
+   case aco_opcode::v_s_rcp_f16:
    case aco_opcode::v_cvt_f32_f64:
    case aco_opcode::v_cvt_f64_f32:
    case aco_opcode::v_cvt_f16_f32:
@@ -3372,53 +3349,16 @@ match_and_apply_patterns(opt_ctx& ctx, alu_opt_info& info,
    return false;
 }
 
-/* s_not(cmp(a, b)) -> get_vcmp_inverse(cmp)(a, b) */
-bool
-combine_inverse_comparison(opt_ctx& ctx, aco_ptr<Instruction>& instr)
-{
-   if (ctx.uses[instr->definitions[1].tempId()])
-      return false;
-   if (!instr->operands[0].isTemp() || ctx.uses[instr->operands[0].tempId()] != 1)
-      return false;
-
-   Instruction* cmp = follow_operand(ctx, instr->operands[0]);
-   if (!cmp)
-      return false;
-
-   aco_opcode new_opcode = get_vcmp_inverse(cmp->opcode);
-   if (new_opcode == aco_opcode::num_opcodes)
-      return false;
-
-   /* Invert compare instruction and assign this instruction's definition */
-   cmp->opcode = new_opcode;
-   ctx.info[instr->definitions[0].tempId()] = ctx.info[cmp->definitions[0].tempId()];
-   std::swap(instr->definitions[0], cmp->definitions[0]);
-   ctx.info[instr->definitions[0].tempId()].parent_instr = instr.get();
-   ctx.info[cmp->definitions[0].tempId()].parent_instr = cmp;
-
-   ctx.uses[instr->operands[0].tempId()]--;
-   return true;
-}
-
 /* v_not(v_xor(a, b)) -> v_xnor(a, b) */
-bool
-combine_not_xor(opt_ctx& ctx, aco_ptr<Instruction>& instr)
+Instruction*
+apply_v_not(opt_ctx& ctx, aco_ptr<Instruction>& instr, Instruction* op_instr)
 {
-   if (instr->usesModifiers())
-      return false;
-
-   Instruction* op_instr = follow_operand(ctx, instr->operands[0]);
-   if (!op_instr || op_instr->opcode != aco_opcode::v_xor_b32 || op_instr->isSDWA())
-      return false;
+   if (instr->usesModifiers() || op_instr->opcode != aco_opcode::v_xor_b32 || op_instr->isSDWA())
+      return nullptr;
 
-   ctx.uses[instr->operands[0].tempId()]--;
-   std::swap(instr->definitions[0], op_instr->definitions[0]);
+   op_instr->definitions[0] = instr->definitions[0];
    op_instr->opcode = aco_opcode::v_xnor_b32;
-   ctx.info[op_instr->definitions[0].tempId()].label = 0;
-   ctx.info[op_instr->definitions[0].tempId()].parent_instr = op_instr;
-   ctx.info[instr->definitions[0].tempId()].parent_instr = instr.get();
-
-   return true;
+   return op_instr;
 }
 
 /* s_not_b32(s_and_b32(a, b)) -> s_nand_b32(a, b)
@@ -3426,61 +3366,47 @@ combine_not_xor(opt_ctx& ctx, aco_ptr<Instruction>& instr)
  * s_not_b32(s_xor_b32(a, b)) -> s_xnor_b32(a, b)
  * s_not_b64(s_and_b64(a, b)) -> s_nand_b64(a, b)
  * s_not_b64(s_or_b64(a, b)) -> s_nor_b64(a, b)
- * s_not_b64(s_xor_b64(a, b)) -> s_xnor_b64(a, b) */
-bool
-combine_salu_not_bitwise(opt_ctx& ctx, aco_ptr<Instruction>& instr)
+ * s_not_b64(s_xor_b64(a, b)) -> s_xnor_b64(a, b)
+ * s_not(cmp(a, b)) -> get_vcmp_inverse(cmp)(a, b) */
+Instruction*
+apply_s_not(opt_ctx& ctx, aco_ptr<Instruction>& instr, Instruction* op_instr)
 {
-   /* checks */
-   if (!instr->operands[0].isTemp())
-      return false;
-   if (instr->definitions[1].isTemp() && ctx.uses[instr->definitions[1].tempId()])
-      return false;
+   if (op_instr->definitions.size() == 1 && ctx.uses[instr->definitions[1].tempId()])
+      return nullptr;
+   else if (op_instr->definitions.size() == 2 && ctx.uses[op_instr->definitions[1].tempId()])
+      return nullptr;
 
-   Instruction* op2_instr = follow_operand(ctx, instr->operands[0]);
-   if (!op2_instr)
-      return false;
-   switch (op2_instr->opcode) {
-   case aco_opcode::s_and_b32:
-   case aco_opcode::s_or_b32:
-   case aco_opcode::s_xor_b32:
-   case aco_opcode::s_and_b64:
-   case aco_opcode::s_or_b64:
-   case aco_opcode::s_xor_b64: break;
-   default: return false;
+   switch (op_instr->opcode) {
+   case aco_opcode::s_and_b32: op_instr->opcode = aco_opcode::s_nand_b32; break;
+   case aco_opcode::s_or_b32: op_instr->opcode = aco_opcode::s_nor_b32; break;
+   case aco_opcode::s_xor_b32: op_instr->opcode = aco_opcode::s_xnor_b32; break;
+   case aco_opcode::s_and_b64: op_instr->opcode = aco_opcode::s_nand_b64; break;
+   case aco_opcode::s_or_b64: op_instr->opcode = aco_opcode::s_nor_b64; break;
+   case aco_opcode::s_xor_b64: op_instr->opcode = aco_opcode::s_xnor_b64; break;
+   default: {
+      if (!op_instr->isVOPC())
+         return nullptr;
+      aco_opcode new_opcode = get_vcmp_inverse(op_instr->opcode);
+      if (new_opcode == aco_opcode::num_opcodes)
+         return nullptr;
+      op_instr->opcode = new_opcode;
    }
-
-   /* create instruction */
-   std::swap(instr->definitions[0], op2_instr->definitions[0]);
-   std::swap(instr->definitions[1], op2_instr->definitions[1]);
-   ctx.uses[instr->operands[0].tempId()]--;
-   ctx.info[op2_instr->definitions[0].tempId()].label = 0;
-   ctx.info[op2_instr->definitions[0].tempId()].parent_instr = op2_instr;
-   ctx.info[op2_instr->definitions[1].tempId()].parent_instr = op2_instr;
-   ctx.info[instr->definitions[0].tempId()].parent_instr = instr.get();
-   ctx.info[instr->definitions[1].tempId()].parent_instr = instr.get();
-
-   switch (op2_instr->opcode) {
-   case aco_opcode::s_and_b32: op2_instr->opcode = aco_opcode::s_nand_b32; break;
-   case aco_opcode::s_or_b32: op2_instr->opcode = aco_opcode::s_nor_b32; break;
-   case aco_opcode::s_xor_b32: op2_instr->opcode = aco_opcode::s_xnor_b32; break;
-   case aco_opcode::s_and_b64: op2_instr->opcode = aco_opcode::s_nand_b64; break;
-   case aco_opcode::s_or_b64: op2_instr->opcode = aco_opcode::s_nor_b64; break;
-   case aco_opcode::s_xor_b64: op2_instr->opcode = aco_opcode::s_xnor_b64; break;
-   default: break;
    }
 
-   return true;
+   for (unsigned i = 0; i < op_instr->definitions.size(); i++)
+      op_instr->definitions[i] = instr->definitions[i];
+
+   return op_instr;
 }
 
 /* s_abs_i32(s_sub_[iu]32(a, b)) -> s_absdiff_i32(a, b)
  * s_abs_i32(s_add_[iu]32(a, #b)) -> s_absdiff_i32(a, -b)
  */
-bool
-combine_sabsdiff(opt_ctx& ctx, aco_ptr<Instruction>& instr)
+Instruction*
+apply_s_abs(opt_ctx& ctx, aco_ptr<Instruction>& instr, Instruction* op_instr)
 {
-   Instruction* op_instr = follow_operand(ctx, instr->operands[0], false);
-   if (!op_instr)
-      return false;
+   if (op_instr->definitions.size() != 2 || ctx.uses[op_instr->definitions[1].tempId()])
+      return nullptr;
 
    if (op_instr->opcode == aco_opcode::s_add_i32 || op_instr->opcode == aco_opcode::s_add_u32) {
       for (unsigned i = 0; i < 2; i++) {
@@ -3489,30 +3415,21 @@ combine_sabsdiff(opt_ctx& ctx, aco_ptr<Instruction>& instr)
              !is_operand_constant(ctx, op_instr->operands[i], 32, &constant))
             continue;
 
-         if (op_instr->operands[i].isTemp())
-            ctx.uses[op_instr->operands[i].tempId()]--;
          op_instr->operands[0] = op_instr->operands[!i];
          op_instr->operands[1] = Operand::c32(-int32_t(constant));
          goto use_absdiff;
       }
-      return false;
+      return nullptr;
    } else if (op_instr->opcode != aco_opcode::s_sub_i32 &&
               op_instr->opcode != aco_opcode::s_sub_u32) {
-      return false;
+      return nullptr;
    }
 
 use_absdiff:
    op_instr->opcode = aco_opcode::s_absdiff_i32;
-   std::swap(instr->definitions[0], op_instr->definitions[0]);
-   std::swap(instr->definitions[1], op_instr->definitions[1]);
-   ctx.uses[instr->operands[0].tempId()]--;
-   ctx.info[op_instr->definitions[0].tempId()].label = 0;
-   ctx.info[op_instr->definitions[0].tempId()].parent_instr = op_instr;
-   ctx.info[op_instr->definitions[1].tempId()].parent_instr = op_instr;
-   ctx.info[instr->definitions[0].tempId()].parent_instr = instr.get();
-   ctx.info[instr->definitions[1].tempId()].parent_instr = instr.get();
-
-   return true;
+   op_instr->definitions[0] = instr->definitions[0];
+   op_instr->definitions[1] = instr->definitions[1];
+   return op_instr;
 }
 
 bool
@@ -3654,18 +3571,9 @@ apply_insert(opt_ctx& ctx, aco_ptr<Instruction>& instr)
 /* Remove superfluous extract after ds_read like so:
  * p_extract(ds_read_uN(), 0, N, 0) -> ds_read_uN()
  */
-bool
-apply_load_extract(opt_ctx& ctx, aco_ptr<Instruction>& extract)
+Instruction*
+apply_load_extract(opt_ctx& ctx, aco_ptr<Instruction>& extract, Instruction* load)
 {
-   /* Check if p_extract has a usedef operand and is the only user. */
-   if (ctx.uses[extract->operands[0].tempId()] > 1)
-      return false;
-
-   /* Check if the usedef is the right format. */
-   Instruction* load = ctx.info[extract->operands[0].tempId()].parent_instr;
-   if (!load->isDS() && !load->isSMEM() && !load->isMUBUF() && !load->isFlatLike())
-      return false;
-
    unsigned extract_idx = extract->operands[1].constantValue();
    unsigned bits_extracted = extract->operands[2].constantValue();
    bool sign_ext = extract->operands[3].constantValue();
@@ -3698,17 +3606,17 @@ apply_load_extract(opt_ctx& ctx, aco_ptr<Instruction>& extract)
    case aco_opcode::s_buffer_load_ushort:
    case aco_opcode::buffer_load_ushort:
    case aco_opcode::buffer_load_short_d16: bits_loaded = 16; break;
-   default: return false;
+   default: return nullptr;
    }
 
    /* TODO: These are doable, but probably don't occur too often. */
    if (extract_idx || bits_extracted > bits_loaded || dst_bitsize > 32 ||
        (load->definitions[0].regClass().type() != extract->definitions[0].regClass().type()))
-      return false;
+      return nullptr;
 
    /* We can't shrink some loads because that would remove zeroing of the offset/address LSBs. */
    if (!can_shrink && bits_extracted < bits_loaded)
-      return false;
+      return nullptr;
 
    /* Shrink the load if the extracted bit size is smaller. */
    bits_loaded = MIN2(bits_loaded, bits_extracted);
@@ -3774,12 +3682,8 @@ apply_load_extract(opt_ctx& ctx, aco_ptr<Instruction>& extract)
    }
 
    /* The load now produces the exact same thing as the extract, remove the extract. */
-   std::swap(load->definitions[0], extract->definitions[0]);
-   ctx.uses[extract->definitions[0].tempId()] = 0;
-   ctx.info[load->definitions[0].tempId()].label = 0;
-   ctx.info[extract->definitions[0].tempId()].parent_instr = extract.get();
-   ctx.info[load->definitions[0].tempId()].parent_instr = load;
-   return true;
+   load->definitions[0] = extract->definitions[0];
+   return load;
 }
 
 void
@@ -3940,6 +3844,89 @@ op_info_get_constant(opt_ctx& ctx, alu_opt_op op_info, aco_type type, uint64_t*
    return true;
 }
 
+Instruction*
+apply_output_impl(opt_ctx& ctx, aco_ptr<Instruction>& instr, Instruction* parent)
+{
+   if (instr->opcode == aco_opcode::p_extract &&
+       (parent->isDS() || parent->isSMEM() || parent->isMUBUF() || parent->isFlatLike()))
+      return apply_load_extract(ctx, instr, parent);
+   else if (instr->opcode == aco_opcode::v_not_b32 && ctx.program->gfx_level >= GFX10)
+      return apply_v_not(ctx, instr, parent);
+   else if (instr->opcode == aco_opcode::s_not_b32 || instr->opcode == aco_opcode::s_not_b64)
+      return apply_s_not(ctx, instr, parent);
+   else if (instr->opcode == aco_opcode::s_abs_i32)
+      return apply_s_abs(ctx, instr, parent);
+
+   return nullptr;
+}
+
+bool
+apply_output(opt_ctx& ctx, aco_ptr<Instruction>& instr)
+{
+   int temp_idx = -1;
+   for (unsigned i = 0; i < instr->operands.size(); i++) {
+      if (temp_idx < 0 && instr->operands[i].isTemp())
+         temp_idx = i;
+      else if (instr->operands[i].isConstant())
+         continue;
+      else
+         return false;
+   }
+
+   if (temp_idx < 0)
+      return false;
+
+   unsigned tmpid = instr->operands[temp_idx].tempId();
+   Instruction* parent = ctx.info[tmpid].parent_instr;
+   if (ctx.uses[tmpid] != 1 || parent->definitions[0].tempId() != tmpid)
+      return false;
+
+   int64_t alt_idx = ctx.info[tmpid].is_combined() ? ctx.info[tmpid].val : -1;
+   aco::small_vec<Operand, 4> pre_opt_ops;
+   for (const Operand& op : parent->operands)
+      pre_opt_ops.push_back(op);
+
+   Instruction* new_instr = apply_output_impl(ctx, instr, parent);
+
+   if (new_instr == nullptr)
+      return false;
+
+   for (const Operand& op : parent->operands) {
+      if (op.isTemp())
+         ctx.uses[op.tempId()]++;
+   }
+   for (const Operand& op : pre_opt_ops) {
+      if (op.isTemp())
+         decrease_and_dce(ctx, op.getTemp());
+   }
+
+   ctx.uses[tmpid] = 0;
+   ctx.info[tmpid].parent_instr = nullptr;
+
+   if (new_instr != parent)
+      ctx.replacement_instr.emplace(parent, new_instr);
+
+   if (alt_idx >= 0) {
+      Instruction* new_pre_combine =
+         apply_output_impl(ctx, instr, ctx.pre_combine_instrs[alt_idx].get());
+
+      if (new_pre_combine != ctx.pre_combine_instrs[alt_idx].get())
+         ctx.pre_combine_instrs[alt_idx].reset(new_pre_combine);
+
+      if (new_pre_combine)
+         ctx.info[new_instr->definitions[0].tempId()].set_combined(alt_idx);
+   }
+
+   for (Definition& def : new_instr->definitions) {
+      ctx.info[def.tempId()].parent_instr = new_instr;
+      ctx.info[def.tempId()].label &=
+         instr_mod_labels | canonicalized_labels | label_combined_instr;
+   }
+
+   instr.reset();
+   return true;
+}
+
 bool
 create_fma_cb(opt_ctx& ctx, alu_opt_info& info)
 {
@@ -4165,9 +4152,8 @@ combine_instruction(opt_ctx& ctx, aco_ptr<Instruction>& instr)
    if (instr->isDPP())
       return;
 
-   if (instr->opcode == aco_opcode::p_extract) {
-      apply_load_extract(ctx, instr);
-   }
+   if (apply_output(ctx, instr))
+      return;
 
    /* TODO: There are still some peephole optimizations that could be done:
     * - abs(a - b) -> s_absdiff_i32
@@ -4230,15 +4216,6 @@ combine_instruction(opt_ctx& ctx, aco_ptr<Instruction>& instr)
       return;
    }
 
-   if (instr->opcode == aco_opcode::v_not_b32 && ctx.program->gfx_level >= GFX10) {
-      combine_not_xor(ctx, instr);
-   } else if (instr->opcode == aco_opcode::s_not_b32 || instr->opcode == aco_opcode::s_not_b64) {
-      if (!combine_salu_not_bitwise(ctx, instr))
-         combine_inverse_comparison(ctx, instr);
-   } else if (instr->opcode == aco_opcode::s_abs_i32) {
-      combine_sabsdiff(ctx, instr);
-   }
-
    alu_opt_info info;
    if (!alu_opt_gather_info(ctx, instr.get(), info))
       return;
@@ -4582,25 +4559,8 @@ combine_instruction(opt_ctx& ctx, aco_ptr<Instruction>& instr)
       instr.reset(alu_opt_info_to_instr(ctx, info, nullptr));
       ctx.info[instr->definitions[0].tempId()].set_combined(ctx.pre_combine_instrs.size() - 1);
    }
-#undef add_opt
 
-   if (instr->opcode == aco_opcode::v_med3_f32 || instr->opcode == aco_opcode::v_med3_f16) {
-      /* Optimize v_med3 to v_add so that it can be dual issued on GFX11. We start with v_med3 in
-       * case omod can be applied.
-       */
-      unsigned idx;
-      if (detect_clamp(instr.get(), &idx)) {
-         instr->format = asVOP3(Format::VOP2);
-         instr->operands[0] = instr->operands[idx];
-         instr->operands[1] = Operand::zero();
-         instr->opcode =
-            instr->opcode == aco_opcode::v_med3_f32 ? aco_opcode::v_add_f32 : aco_opcode::v_add_f16;
-         instr->valu().clamp = true;
-         instr->valu().abs = (uint8_t)instr->valu().abs[idx];
-         instr->valu().neg = (uint8_t)instr->valu().neg[idx];
-         instr->operands.pop_back();
-      }
-   }
+#undef add_opt
 }
 
 struct remat_entry {
@@ -4760,16 +4720,47 @@ to_uniform_bool_instr(opt_ctx& ctx, aco_ptr<Instruction>& instr)
    return true;
 }
 
+void
+insert_replacement_instr(opt_ctx& ctx, aco_ptr<Instruction>& instr)
+{
+   while (true) {
+      auto it = ctx.replacement_instr.find(instr.get());
+      if (it == ctx.replacement_instr.end())
+         return;
+
+      instr = std::move(it->second);
+      ctx.replacement_instr.erase(it);
+   }
+}
+
 void
 select_instruction(opt_ctx& ctx, aco_ptr<Instruction>& instr)
 {
    const uint32_t threshold = 4;
 
-   if (is_dead(ctx.uses, instr.get())) {
+   if (!instr.get() || is_dead(ctx.uses, instr.get())) {
       instr.reset();
       return;
    }
 
+   if (instr->opcode == aco_opcode::v_med3_f32 || instr->opcode == aco_opcode::v_med3_f16) {
+      /* Optimize v_med3 to v_add so that it can be dual issued on GFX11. We start with v_med3 in
+       * case omod can be applied.
+       */
+      unsigned idx;
+      if (detect_clamp(instr.get(), &idx)) {
+         instr->format = asVOP3(Format::VOP2);
+         instr->operands[0] = instr->operands[idx];
+         instr->operands[1] = Operand::zero();
+         instr->opcode =
+            instr->opcode == aco_opcode::v_med3_f32 ? aco_opcode::v_add_f32 : aco_opcode::v_add_f16;
+         instr->valu().clamp = true;
+         instr->valu().abs = (uint8_t)instr->valu().abs[idx];
+         instr->valu().neg = (uint8_t)instr->valu().neg[idx];
+         instr->operands.pop_back();
+      }
+   }
+
    /* convert split_vector into a copy or extract_vector if only one definition is ever used */
    if (instr->opcode == aco_opcode::p_split_vector) {
       unsigned num_used = 0;
@@ -4838,8 +4829,12 @@ select_instruction(opt_ctx& ctx, aco_ptr<Instruction>& instr)
        * no operand instruction was eliminated.
        */
       bool use_prev = std::all_of(
-         prev_instr->operands.begin(), prev_instr->operands.end(), [&](Operand op)
-         { return !op.isTemp() || !is_dead(ctx.uses, ctx.info[op.tempId()].parent_instr); });
+         prev_instr->operands.begin(), prev_instr->operands.end(),
+         [&](Operand op)
+         {
+            return !op.isTemp() || (ctx.info[op.tempId()].parent_instr &&
+                                    !is_dead(ctx.uses, ctx.info[op.tempId()].parent_instr));
+         });
 
       if (use_prev) {
          for (const Operand& op : prev_instr->operands) {
@@ -5454,6 +5449,12 @@ optimize(Program* program)
          combine_instruction(ctx, instr);
    }
 
+   for (Block& block : program->blocks) {
+      ctx.fp_mode = block.fp_mode;
+      for (aco_ptr<Instruction>& instr : block.instructions)
+         insert_replacement_instr(ctx, instr);
+   }
+
    validate_opt_ctx(ctx);
 
    /* 4. Top-Down DAG pass (backward) to select instructions (includes DCE) */
-- 
GitLab


From e513292ccdad6faceaaccaf9643c27c9829892b0 Mon Sep 17 00:00:00 2001
From: Georg Lehmann <dadschoorse@gmail.com>
Date: Mon, 28 Jul 2025 14:16:40 +0200
Subject: [PATCH 20/29] aco/optimizer: handle gfx11+ vinterp as fma special
 case

---
 src/amd/compiler/aco_optimizer.cpp | 93 ++++++++++++++++++++++++++++--
 1 file changed, 87 insertions(+), 6 deletions(-)

diff --git a/src/amd/compiler/aco_optimizer.cpp b/src/amd/compiler/aco_optimizer.cpp
index 6a0e9819408c1..428a17c7eedcb 100644
--- a/src/amd/compiler/aco_optimizer.cpp
+++ b/src/amd/compiler/aco_optimizer.cpp
@@ -652,6 +652,60 @@ format_is(Format f1, Format f2)
    return ((Format)((uint32_t)f1 & (uint32_t)f2)) == f2;
 }
 
+bool
+try_vinterp_inreg(opt_ctx& ctx, alu_opt_info& info)
+{
+   if (ctx.program->gfx_level < GFX11 || info.opcode != aco_opcode::v_fma_f32 || info.omod)
+      return false;
+
+   bool fp16 = info.f32_to_f16;
+   for (auto& op_info : info.operands) {
+      if (op_info.abs[0] || op_info.dpp8 || (op_info.dpp16 && !op_info.fi))
+         return false;
+      fp16 |= op_info.f16_to_f32;
+      if (!op_info.op.isOfType(RegType::vgpr))
+         return false;
+   }
+
+   if (info.operands[0].dpp16 == info.operands[1].dpp16)
+      return false;
+
+   bool swap = info.operands[1].dpp16;
+   bool p2 = !info.operands[2].dpp16;
+
+   if (fp16) {
+      if (info.f32_to_f16 != p2 || !info.operands[swap].f16_to_f32 ||
+          info.operands[!swap].f16_to_f32 || info.operands[2].f16_to_f32 == p2)
+         return false;
+   }
+
+   if (p2) {
+      if (info.operands[swap].dpp_ctrl != dpp_quad_perm(2, 2, 2, 2))
+         return false;
+      info.opcode =
+         fp16 ? aco_opcode::v_interp_p2_f16_f32_inreg : aco_opcode::v_interp_p2_f32_inreg;
+   } else {
+      if (info.operands[2].dpp_ctrl != dpp_quad_perm(0, 0, 0, 0))
+         return false;
+      if (info.operands[swap].dpp_ctrl != dpp_quad_perm(1, 1, 1, 1))
+         return false;
+      info.opcode =
+         fp16 ? aco_opcode::v_interp_p10_f16_f32_inreg : aco_opcode::v_interp_p10_f32_inreg;
+   }
+
+   info.f32_to_f16 = false;
+   for (auto& op_info : info.operands) {
+      op_info.dpp16 = false;
+      op_info.f16_to_f32 = false;
+   }
+
+   if (swap)
+      std::swap(info.operands[0], info.operands[1]);
+
+   info.format = Format::VINTERP_INREG;
+   return true;
+}
+
 /* Determine if this alu_opt_info can be represented by a valid ACO IR instruction.
  * info is modified to not duplicate work when it's converted to an ACO IR instruction.
  * If false is returned, info must no longer be used.
@@ -835,6 +889,9 @@ alu_opt_info_is_valid(opt_ctx& ctx, alu_opt_info& info)
       }
    }
 
+   /* convert to VINTERP_INREG */
+   try_vinterp_inreg(ctx, info);
+
    /* convert to v_fma_mix */
    bool uses_f2f32 = false;
    for (auto& op_info : info.operands)
@@ -1209,10 +1266,6 @@ alu_opt_gather_info(opt_ctx& ctx, Instruction* instr, alu_opt_info& info)
        instr->opcode == aco_opcode::v_mqsad_u32_u8)
       return false;
 
-   /* TODO handle when this is used for output modifiers. */
-   if (instr->isVINTERP_INREG())
-      return false;
-
    switch (instr->opcode) {
    case aco_opcode::s_addk_i32:
    case aco_opcode::s_cmovk_i32:
@@ -1296,7 +1349,33 @@ alu_opt_gather_info(opt_ctx& ctx, Instruction* instr, alu_opt_info& info)
       info.operands.push_back(op_info);
    }
 
-   if (instr->isDPP16()) {
+   if (instr->isVINTERP_INREG()) {
+      switch (instr->opcode) {
+      case aco_opcode::v_interp_p10_f16_f32_inreg:
+         info.operands[0].f16_to_f32 = true;
+         info.operands[2].f16_to_f32 = true;
+         FALLTHROUGH;
+      case aco_opcode::v_interp_p10_f32_inreg:
+         info.operands[0].dpp_ctrl = dpp_quad_perm(1, 1, 1, 1);
+         info.operands[2].dpp_ctrl = dpp_quad_perm(0, 0, 0, 0);
+         info.operands[2].dpp16 = true;
+         info.operands[2].fi = true;
+         break;
+      case aco_opcode::v_interp_p2_f16_f32_inreg:
+         info.operands[0].f16_to_f32 = true;
+         info.f32_to_f16 = true;
+         FALLTHROUGH;
+      case aco_opcode::v_interp_p2_f32_inreg:
+         info.operands[0].dpp_ctrl = dpp_quad_perm(2, 2, 2, 2);
+         break;
+      default: return false;
+      }
+      info.opcode = aco_opcode::v_fma_f32;
+      info.operands[0].dpp16 = true;
+      info.operands[0].fi = true;
+      /* Anything else doesn't make sense before scheduling. */
+      assert(instr->vinterp_inreg().wait_exp == 7);
+   } else if (instr->isDPP16()) {
       info.operands[0].dpp16 = true;
       info.operands[0].dpp_ctrl = instr->dpp16().dpp_ctrl;
       info.operands[0].fi = instr->dpp16().fetch_inactive;
@@ -1489,7 +1568,9 @@ alu_opt_info_to_instr(opt_ctx& ctx, alu_opt_info& info, Instruction* old_instr)
       instr->valu().clamp = info.clamp;
    }
 
-   if (instr->isDPP16()) {
+   if (instr->isVINTERP_INREG()) {
+      instr->vinterp_inreg().wait_exp = 7;
+   } else if (instr->isDPP16()) {
       instr->dpp16().dpp_ctrl = info.operands[0].dpp_ctrl;
       instr->dpp16().fetch_inactive = info.operands[0].fi;
       instr->dpp16().bound_ctrl = info.operands[0].bc;
-- 
GitLab


From 08590ab65bf53b1e2cca37d4de044940df366d25 Mon Sep 17 00:00:00 2001
From: Georg Lehmann <dadschoorse@gmail.com>
Date: Thu, 9 Jan 2025 19:48:47 +0100
Subject: [PATCH 21/29] aco/optimizer: use new helpers to apply neg/abs to
 output of instructions

Foz-DB Navi21:
Totals from 4674 (5.86% of 79789) affected shaders:
MaxWaves: 107664 -> 107670 (+0.01%)
Instrs: 4972227 -> 4967493 (-0.10%); split: -0.11%, +0.01%
CodeSize: 26884144 -> 26886032 (+0.01%); split: -0.01%, +0.02%
VGPRs: 222392 -> 222360 (-0.01%)
Latency: 40345648 -> 40349355 (+0.01%); split: -0.03%, +0.04%
InvThroughput: 7568916 -> 7561841 (-0.09%); split: -0.10%, +0.01%
VClause: 107189 -> 107177 (-0.01%); split: -0.04%, +0.03%
SClause: 132301 -> 132305 (+0.00%); split: -0.01%, +0.01%
Copies: 471773 -> 471989 (+0.05%); split: -0.08%, +0.13%
Branches: 158041 -> 158005 (-0.02%); split: -0.03%, +0.01%
PreSGPRs: 219754 -> 219746 (-0.00%)
PreVGPRs: 181672 -> 181543 (-0.07%); split: -0.08%, +0.01%
VALU: 3008253 -> 3003356 (-0.16%); split: -0.17%, +0.01%
SALU: 856503 -> 856500 (-0.00%); split: -0.00%, +0.00%
---
 src/amd/compiler/aco_optimizer.cpp | 130 ++++++++++++++---------------
 1 file changed, 64 insertions(+), 66 deletions(-)

diff --git a/src/amd/compiler/aco_optimizer.cpp b/src/amd/compiler/aco_optimizer.cpp
index 428a17c7eedcb..427c5f425eebb 100644
--- a/src/amd/compiler/aco_optimizer.cpp
+++ b/src/amd/compiler/aco_optimizer.cpp
@@ -3925,6 +3925,67 @@ op_info_get_constant(opt_ctx& ctx, alu_opt_op op_info, aco_type type, uint64_t*
    return true;
 }
 
+/* neg(mul(a, b)) -> mul(neg(a), b), abs(mul(a, b)) -> mul(abs(a), abs(b)) */
+Instruction*
+apply_output_mul(opt_ctx& ctx, aco_ptr<Instruction>& instr, Instruction* parent)
+{
+   alu_opt_info info;
+   if (!alu_opt_gather_info(ctx, instr.get(), info))
+      return nullptr;
+   aco_type type = instr_info.alu_opcode_infos[(int)instr->opcode].def_types[0];
+
+   unsigned denorm_mode = type.bit_size == 32 ? ctx.fp_mode.denorm32 : ctx.fp_mode.denorm16_64;
+   if (!ctx.info[parent->definitions[0].tempId()].is_canonicalized(type.bit_size) &&
+       denorm_mode != fp_denorm_keep)
+      return nullptr;
+
+   aco_type parent_type = instr_info.alu_opcode_infos[(int)parent->opcode].def_types[0];
+
+   if (type.num_components != parent_type.num_components || type.bit_size != parent_type.bit_size ||
+       instr->definitions[0].regClass().type() != parent->definitions[0].regClass().type())
+      return nullptr;
+
+   unsigned cidx = !info.operands[0].op.isConstant();
+
+   uint64_t constant = 0;
+   if (!op_info_get_constant(ctx, info.operands[cidx], type, &constant))
+      return nullptr;
+
+   for (unsigned i = 0; i < type.num_components; i++) {
+      double val = extract_float(constant, type.bit_size, i);
+      if (val < 0.0) {
+         val = fabs(val);
+         info.operands[!cidx].neg[i] ^= true;
+      }
+
+      if (val != 1.0)
+         return nullptr;
+   }
+
+   if ((info.omod || info.clamp) &&
+       !instr_info.alu_opcode_infos[(int)parent->opcode].output_modifiers)
+      return nullptr;
+
+   alu_opt_info parent_info;
+   if (!alu_opt_gather_info(ctx, parent, parent_info))
+      return nullptr;
+
+   if (parent_info.uses_insert() ||
+       (info.omod && (parent_info.omod || parent_info.clamp)))
+      return nullptr;
+
+   if (!backpropagate_input_modifiers(ctx, parent_info, info.operands[!cidx], type))
+      return nullptr;
+
+   parent_info.clamp |= info.clamp;
+   parent_info.omod |= info.omod;
+   parent_info.insert = info.insert;
+   parent_info.defs[0].setTemp(info.defs[0].getTemp());
+   if (!alu_opt_info_is_valid(ctx, parent_info))
+      return nullptr;
+   return alu_opt_info_to_instr(ctx, parent_info, parent);
+}
+
 Instruction*
 apply_output_impl(opt_ctx& ctx, aco_ptr<Instruction>& instr, Instruction* parent)
 {
@@ -3937,6 +3998,9 @@ apply_output_impl(opt_ctx& ctx, aco_ptr<Instruction>& instr, Instruction* parent
       return apply_s_not(ctx, instr, parent);
    else if (instr->opcode == aco_opcode::s_abs_i32)
       return apply_s_abs(ctx, instr, parent);
+   else if (instr->opcode == aco_opcode::v_mul_f64 || instr->opcode == aco_opcode::v_mul_f64_e64 ||
+            instr->opcode == aco_opcode::v_mul_f32 || instr->opcode == aco_opcode::v_mul_f16)
+      return apply_output_mul(ctx, instr, parent);
 
    return nullptr;
 }
@@ -4186,21 +4250,6 @@ and_cb(opt_ctx& ctx, alu_opt_info& info)
    return func1(ctx, info) && func2(ctx, info);
 }
 
-bool
-is_mul(Instruction* instr)
-{
-   switch (instr->opcode) {
-   case aco_opcode::v_mul_f64_e64:
-   case aco_opcode::v_mul_f64:
-   case aco_opcode::v_mul_f32:
-   case aco_opcode::v_mul_legacy_f32:
-   case aco_opcode::v_mul_f16: return true;
-   case aco_opcode::v_fma_mix_f32:
-      return instr->operands[2].constantEquals(0) && instr->valu().neg[2];
-   default: return false;
-   }
-}
-
 void
 combine_instruction(opt_ctx& ctx, aco_ptr<Instruction>& instr)
 {
@@ -4246,57 +4295,6 @@ combine_instruction(opt_ctx& ctx, aco_ptr<Instruction>& instr)
     * The various comparison optimizations also currently only work with 32-bit
     * floats. */
 
-   /* neg(mul(a, b)) -> mul(neg(a), b), abs(mul(a, b)) -> mul(abs(a), abs(b)) */
-   if ((ctx.info[instr->definitions[0].tempId()].label & input_mod_labels) &&
-       ctx.uses[ctx.info[instr->definitions[0].tempId()].temp.id()] == 1) {
-      Temp val = ctx.info[instr->definitions[0].tempId()].temp;
-      Instruction* mul_instr = ctx.info[val.id()].parent_instr;
-
-      if (!is_mul(mul_instr))
-         return;
-
-      if (mul_instr->operands[0].isLiteral())
-         return;
-      if (mul_instr->valu().clamp)
-         return;
-      if (mul_instr->isSDWA() || mul_instr->isDPP())
-         return;
-      if (mul_instr->opcode == aco_opcode::v_mul_legacy_f32 &&
-          mul_instr->definitions[0].isSZPreserve())
-         return;
-      if (mul_instr->definitions[0].bytes() != instr->definitions[0].bytes())
-         return;
-
-      /* convert to mul(neg(a), b), mul(abs(a), abs(b)) or mul(neg(abs(a)), abs(b)) */
-      ctx.uses[mul_instr->definitions[0].tempId()]--;
-      Definition def = instr->definitions[0];
-      bool is_neg = ctx.info[instr->definitions[0].tempId()].is_neg(def.bytes() * 8);
-      bool is_abs = ctx.info[instr->definitions[0].tempId()].is_abs(def.bytes() * 8);
-      uint32_t pass_flags = instr->pass_flags;
-      Format format = mul_instr->format == Format::VOP2 ? asVOP3(Format::VOP2) : mul_instr->format;
-      instr.reset(create_instruction(mul_instr->opcode, format, mul_instr->operands.size(), 1));
-      std::copy(mul_instr->operands.cbegin(), mul_instr->operands.cend(), instr->operands.begin());
-      instr->pass_flags = pass_flags;
-      instr->definitions[0] = def;
-      VALU_instruction& new_mul = instr->valu();
-      VALU_instruction& mul = mul_instr->valu();
-      new_mul.neg = mul.neg;
-      new_mul.abs = mul.abs;
-      new_mul.omod = mul.omod;
-      new_mul.opsel = mul.opsel;
-      new_mul.opsel_lo = mul.opsel_lo;
-      new_mul.opsel_hi = mul.opsel_hi;
-      if (is_abs) {
-         new_mul.neg[0] = new_mul.neg[1] = false;
-         new_mul.abs[0] = new_mul.abs[1] = true;
-      }
-      new_mul.neg[0] ^= is_neg;
-      new_mul.clamp = false;
-
-      ctx.info[instr->definitions[0].tempId()].parent_instr = instr.get();
-      return;
-   }
-
    alu_opt_info info;
    if (!alu_opt_gather_info(ctx, instr.get(), info))
       return;
-- 
GitLab


From 365ef4609791b566bdeaab4bc1342d62015eac74 Mon Sep 17 00:00:00 2001
From: Georg Lehmann <dadschoorse@gmail.com>
Date: Thu, 9 Jan 2025 20:39:59 +0100
Subject: [PATCH 22/29] aco/optimizer: use new helpers to apply packed fsat

No Foz-DB changes.
---
 src/amd/compiler/aco_optimizer.cpp        | 54 +----------------------
 src/amd/compiler/tests/test_optimizer.cpp | 54 +++++++++++++++++++++++
 2 files changed, 56 insertions(+), 52 deletions(-)

diff --git a/src/amd/compiler/aco_optimizer.cpp b/src/amd/compiler/aco_optimizer.cpp
index 427c5f425eebb..7886ec8aa4bd1 100644
--- a/src/amd/compiler/aco_optimizer.cpp
+++ b/src/amd/compiler/aco_optimizer.cpp
@@ -3767,52 +3767,6 @@ apply_load_extract(opt_ctx& ctx, aco_ptr<Instruction>& extract, Instruction* loa
    return load;
 }
 
-void
-propagate_swizzles(VALU_instruction* instr, bool opsel_lo, bool opsel_hi)
-{
-   /* propagate swizzles which apply to a result down to the instruction's operands:
-    * result = a.xy + b.xx -> result.yx = a.yx + b.xx */
-   uint8_t tmp_lo = instr->opsel_lo;
-   uint8_t tmp_hi = instr->opsel_hi;
-   uint8_t neg_lo = instr->neg_lo;
-   uint8_t neg_hi = instr->neg_hi;
-   if (opsel_lo == 1) {
-      instr->opsel_lo = tmp_hi;
-      instr->neg_lo = neg_hi;
-   }
-   if (opsel_hi == 0) {
-      instr->opsel_hi = tmp_lo;
-      instr->neg_hi = neg_lo;
-   }
-}
-
-void
-combine_vop3p(opt_ctx& ctx, aco_ptr<Instruction>& instr)
-{
-   VALU_instruction* vop3p = &instr->valu();
-
-   /* apply clamp */
-   if (instr->opcode == aco_opcode::v_pk_mul_f16 && instr->operands[1].constantEquals(0x3C00) &&
-       vop3p->clamp && instr->operands[0].isTemp() && ctx.uses[instr->operands[0].tempId()] == 1 &&
-       !vop3p->opsel_lo[1] && !vop3p->opsel_hi[1]) {
-
-      Instruction* op_instr = ctx.info[instr->operands[0].tempId()].parent_instr;
-      const aco_alu_opcode_info& opcode_info = instr_info.alu_opcode_infos[(int)op_instr->opcode];
-      aco_type op_type = opcode_info.def_types[0];
-      if (op_instr->isVOP3P() && op_type.num_components == 2 &&
-          op_type.base_type == aco_base_type_float && op_type.bit_size == 16 &&
-          opcode_info.output_modifiers) {
-         op_instr->valu().clamp = true;
-         propagate_swizzles(&op_instr->valu(), vop3p->opsel_lo[0], vop3p->opsel_hi[0]);
-         instr->definitions[0].swapTemp(op_instr->definitions[0]);
-         ctx.info[op_instr->definitions[0].tempId()].parent_instr = op_instr;
-         ctx.info[instr->definitions[0].tempId()].parent_instr = instr.get();
-         ctx.uses[instr->definitions[0].tempId()]--;
-         return;
-      }
-   }
-}
-
 bool
 can_use_mad_mix(opt_ctx& ctx, aco_ptr<Instruction>& instr)
 {
@@ -3999,7 +3953,8 @@ apply_output_impl(opt_ctx& ctx, aco_ptr<Instruction>& instr, Instruction* parent
    else if (instr->opcode == aco_opcode::s_abs_i32)
       return apply_s_abs(ctx, instr, parent);
    else if (instr->opcode == aco_opcode::v_mul_f64 || instr->opcode == aco_opcode::v_mul_f64_e64 ||
-            instr->opcode == aco_opcode::v_mul_f32 || instr->opcode == aco_opcode::v_mul_f16)
+            instr->opcode == aco_opcode::v_mul_f32 || instr->opcode == aco_opcode::v_mul_f16 ||
+            instr->opcode == aco_opcode::v_pk_mul_f16)
       return apply_output_mul(ctx, instr, parent);
 
    return nullptr;
@@ -4274,11 +4229,6 @@ combine_instruction(opt_ctx& ctx, aco_ptr<Instruction>& instr)
       apply_insert(ctx, instr);
    }
 
-   if (instr->isVOP3P() && instr->opcode != aco_opcode::v_fma_mix_f32 &&
-       instr->opcode != aco_opcode::v_fma_mixlo_f16) {
-      combine_vop3p(ctx, instr);
-   }
-
    if (instr->isDPP())
       return;
 
diff --git a/src/amd/compiler/tests/test_optimizer.cpp b/src/amd/compiler/tests/test_optimizer.cpp
index 58a08961a83f9..67a7e48dd007d 100644
--- a/src/amd/compiler/tests/test_optimizer.cpp
+++ b/src/amd/compiler/tests/test_optimizer.cpp
@@ -2317,3 +2317,57 @@ BEGIN_TEST(optimizer.pk_fma)
       finish_opt_test();
    }
 END_TEST
+
+static Builder::Result
+cvt_pk_rtz(Definition def, Builder::Op op1, Builder::Op op2)
+{
+   if (bld.program->gfx_level >= GFX8 && bld.program->gfx_level < GFX10)
+      return bld.vop3(aco_opcode::v_cvt_pkrtz_f16_f32_e64, def, op1, op2);
+   else
+      return bld.vop2(aco_opcode::v_cvt_pkrtz_f16_f32, def, op1, op2);
+}
+
+BEGIN_TEST(optimizer.pk_mul_pk_cvt)
+   for (unsigned i = GFX9; i <= GFX10; i++) {
+      //>> v1: %a:v[0],  v1: %b:v[1] = p_startpgm
+      if (!setup_cs("v1 v1", (amd_gfx_level)i))
+         continue;
+
+      Temp a = inputs[0];
+      Temp b = inputs[1];
+
+      //~gfx9! v1: %res0 = v_cvt_pkrtz_f16_f32_e64 %a, %b
+      //~gfx10! v1: %res0 = v_cvt_pkrtz_f16_f32 %a, %b
+      //! p_unit_test 0, %res0
+      Builder::Result cvt = cvt_pk_rtz(bld.def(v1), a, b);
+      Builder::Result mul =
+         bld.vop3p(aco_opcode::v_pk_mul_f16, bld.def(v1), cvt, Operand::c16(0x3c00), 0x0, 0x1);
+      writeout(0, mul);
+
+      //~gfx9! v1: %res1 = v_cvt_pkrtz_f16_f32_e64 -%b, %b
+      //~gfx10! v1: %res1 = v_cvt_pkrtz_f16_f32 -%b, %b
+      //! p_unit_test 1, %res1
+      cvt = cvt_pk_rtz(bld.def(v1), a, b);
+      mul = bld.vop3p(aco_opcode::v_pk_mul_f16, bld.def(v1), cvt, Operand::c16(0x3c00), 0x1, 0x1);
+      mul->valu().neg_lo[1] = true;
+      writeout(1, mul);
+
+      //~gfx9! v1: %tmp = v_cvt_pkrtz_f16_f32_e64 %a, %b
+      //~gfx10! v1: %tmp = v_cvt_pkrtz_f16_f32 %a, %b
+      //! v1: %res2 = v_pk_mul_f16 %tmp, 1.0.xx clamp
+      //! p_unit_test 2, %res2
+      cvt = cvt_pk_rtz(bld.def(v1), a, b);
+      mul = bld.vop3p(aco_opcode::v_pk_mul_f16, bld.def(v1), cvt, Operand::c16(0x3c00), 0x0, 0x1);
+      mul->valu().clamp = true;
+      writeout(2, mul);
+
+      //~gfx9! v1: %res3 = v_cvt_pkrtz_f16_f32_e64 %b, %a
+      //~gfx10! v1: %res3 = v_cvt_pkrtz_f16_f32 %b, %a
+      //! p_unit_test 3, %res3
+      cvt = cvt_pk_rtz(bld.def(v1), a, b);
+      mul = bld.vop3p(aco_opcode::v_pk_mul_f16, bld.def(v1), cvt, Operand::c16(0x3c00), 0x1, 0x0);
+      writeout(3, mul);
+
+      finish_opt_test();
+   }
+END_TEST
-- 
GitLab


From 9a26a19e0ecdece5c3303d1489600fc3b83c7e27 Mon Sep 17 00:00:00 2001
From: Georg Lehmann <dadschoorse@gmail.com>
Date: Thu, 9 Jan 2025 22:04:42 +0100
Subject: [PATCH 23/29] aco/optimizer: use new helpers to apply insert

Foz-DB Navi21:
Totals from 433 (0.54% of 79789) affected shaders:
Instrs: 672264 -> 670828 (-0.21%); split: -0.23%, +0.01%
CodeSize: 3751532 -> 3742276 (-0.25%); split: -0.26%, +0.01%
Latency: 11553567 -> 11542979 (-0.09%); split: -0.13%, +0.04%
InvThroughput: 3248604 -> 3245833 (-0.09%); split: -0.09%, +0.00%
VClause: 15748 -> 15728 (-0.13%); split: -0.18%, +0.06%
Copies: 84483 -> 84959 (+0.56%); split: -0.17%, +0.73%
Branches: 21901 -> 21897 (-0.02%)
VALU: 446009 -> 444051 (-0.44%); split: -0.44%, +0.00%
SALU: 102873 -> 103394 (+0.51%); split: -0.01%, +0.52%
---
 src/amd/compiler/aco_optimizer.cpp | 81 +++++++++---------------------
 1 file changed, 25 insertions(+), 56 deletions(-)

diff --git a/src/amd/compiler/aco_optimizer.cpp b/src/amd/compiler/aco_optimizer.cpp
index 7886ec8aa4bd1..b1a03ffae54e0 100644
--- a/src/amd/compiler/aco_optimizer.cpp
+++ b/src/amd/compiler/aco_optimizer.cpp
@@ -70,12 +70,11 @@ enum Label {
    label_omod4 = 1ull << 34,
    label_omod5 = 1ull << 35,
    label_clamp = 1ull << 36,
-   label_insert = 1ull << 38,
    label_f2f16 = 1ull << 39,
 };
 
 static constexpr uint64_t instr_mod_labels =
-   label_omod2 | label_omod4 | label_omod5 | label_clamp | label_insert | label_f2f16;
+   label_omod2 | label_omod4 | label_omod5 | label_clamp | label_f2f16;
 
 static constexpr uint64_t input_mod_labels =
    label_abs_fp16 | label_abs_fp32_64 | label_neg_fp16 | label_neg_fp32_64;
@@ -292,16 +291,6 @@ struct ssa_info {
    void set_extract() { add_label(label_extract); }
 
    bool is_extract() { return label & label_extract; }
-
-   void set_insert(Instruction* insert)
-   {
-      if (label & temp_labels)
-         return;
-      add_label(label_insert);
-      mod_instr = insert;
-   }
-
-   bool is_insert() { return label & label_insert; }
 };
 
 struct opt_ctx {
@@ -986,7 +975,8 @@ alu_opt_info_is_valid(opt_ctx& ctx, alu_opt_info& info)
       if (!info.uses_insert()) {
          info.insert = SubdwordSel::dword;
       } else if (info.defs[0].bytes() != 4 ||
-                 (!format_is(info.format, Format::VOP1) && !format_is(info.format, Format::VOP2))) {
+                 (!format_is(info.format, Format::VOP1) && !format_is(info.format, Format::VOP2)) ||
+                 ctx.program->gfx_level < GFX8 || ctx.program->gfx_level >= GFX11) {
          return false;
       } else {
          info.format = format_combine(info.format, Format::SDWA);
@@ -3018,19 +3008,12 @@ label_instruction(opt_ctx& ctx, aco_ptr<Instruction>& instr)
    case aco_opcode::p_extract: {
       if (instr->operands[0].isTemp()) {
          ctx.info[instr->definitions[0].tempId()].set_extract();
-         if (instr->definitions[0].bytes() == 4 && instr->operands[0].regClass() == v1 &&
-             parse_insert(instr.get()))
-            ctx.info[instr->operands[0].tempId()].set_insert(instr.get());
       }
       break;
    }
    case aco_opcode::p_insert: {
-      if (instr->operands[0].isTemp()) {
-         if (instr->operands[0].regClass() == v1)
-            ctx.info[instr->operands[0].tempId()].set_insert(instr.get());
-         if (parse_extract(instr.get()))
-            ctx.info[instr->definitions[0].tempId()].set_extract();
-      }
+      if (instr->operands[0].isTemp() && parse_extract(instr.get()))
+         ctx.info[instr->definitions[0].tempId()].set_extract();
       break;
    }
    case aco_opcode::v_cvt_f16_f32: {
@@ -3599,7 +3582,7 @@ apply_omod_clamp(opt_ctx& ctx, aco_ptr<Instruction>& instr)
       instr->valu().clamp = true;
 
    instr->definitions[0].swapTemp(def_info.mod_instr->definitions[0]);
-   ctx.info[instr->definitions[0].tempId()].label &= label_clamp | label_insert | label_f2f16;
+   ctx.info[instr->definitions[0].tempId()].label &= label_clamp | label_f2f16;
    ctx.uses[def_info.mod_instr->definitions[0].tempId()]--;
    ctx.info[instr->definitions[0].tempId()].parent_instr = instr.get();
    ctx.info[def_info.mod_instr->definitions[0].tempId()].parent_instr = def_info.mod_instr;
@@ -3608,45 +3591,30 @@ apply_omod_clamp(opt_ctx& ctx, aco_ptr<Instruction>& instr)
 }
 
 /* Combine an p_insert (or p_extract, in some cases) instruction with instr.
- * p_insert(instr(...)) -> instr_insert().
+ * p_insert(parent(...)) -> instr_insert().
  */
-bool
-apply_insert(opt_ctx& ctx, aco_ptr<Instruction>& instr)
+Instruction*
+apply_insert(opt_ctx& ctx, aco_ptr<Instruction>& instr, Instruction* parent)
 {
-   if (instr->definitions.empty() || ctx.uses[instr->definitions[0].tempId()] != 1)
-      return false;
-
-   ssa_info& def_info = ctx.info[instr->definitions[0].tempId()];
-   if (!def_info.is_insert())
-      return false;
-   /* if the insert instruction is dead, then the single user of this
-    * instruction is a different instruction */
-   if (!ctx.uses[def_info.mod_instr->definitions[0].tempId()])
-      return false;
-
-   /* MADs/FMAs are created later, so we don't have to update the original add */
-   assert(!ctx.info[instr->definitions[0].tempId()].is_combined());
-
-   SubdwordSel sel = parse_insert(def_info.mod_instr);
+   SubdwordSel sel = parse_insert(instr.get());
    assert(sel);
 
-   if (!can_use_SDWA(ctx.program->gfx_level, instr, true))
-      return false;
+   if (ctx.info[instr->operands[0].tempId()].label & temp_labels)
+      return nullptr;
 
-   convert_to_SDWA(ctx.program->gfx_level, instr);
-   if (instr->sdwa().dst_sel.size() != 4)
-      return false;
-   instr->sdwa().dst_sel = sel;
+   alu_opt_info parent_info;
+   if (!alu_opt_gather_info(ctx, parent, parent_info))
+      return nullptr;
 
-   instr->definitions[0].swapTemp(def_info.mod_instr->definitions[0]);
-   ctx.info[instr->definitions[0].tempId()].label = 0;
-   ctx.uses[def_info.mod_instr->definitions[0].tempId()]--;
-   ctx.info[instr->definitions[0].tempId()].label = 0;
-   ctx.info[def_info.mod_instr->definitions[0].tempId()].parent_instr = def_info.mod_instr;
-   for (const Definition& def : instr->definitions)
-      ctx.info[def.tempId()].parent_instr = instr.get();
+   if (parent_info.uses_insert())
+      return nullptr;
 
-   return true;
+   parent_info.insert = sel;
+
+   parent_info.defs[0].setTemp(instr->definitions[0].getTemp());
+   if (!alu_opt_info_is_valid(ctx, parent_info))
+      return nullptr;
+   return alu_opt_info_to_instr(ctx, parent_info, parent);
 }
 
 /* Remove superfluous extract after ds_read like so:
@@ -3946,6 +3914,8 @@ apply_output_impl(opt_ctx& ctx, aco_ptr<Instruction>& instr, Instruction* parent
    if (instr->opcode == aco_opcode::p_extract &&
        (parent->isDS() || parent->isSMEM() || parent->isMUBUF() || parent->isFlatLike()))
       return apply_load_extract(ctx, instr, parent);
+   else if (parse_insert(instr.get()) && instr->definitions[0].regClass() == v1)
+      return apply_insert(ctx, instr, parent);
    else if (instr->opcode == aco_opcode::v_not_b32 && ctx.program->gfx_level >= GFX10)
       return apply_v_not(ctx, instr, parent);
    else if (instr->opcode == aco_opcode::s_not_b32 || instr->opcode == aco_opcode::s_not_b64)
@@ -4226,7 +4196,6 @@ combine_instruction(opt_ctx& ctx, aco_ptr<Instruction>& instr)
    if (instr->isVALU()) {
       while (apply_omod_clamp(ctx, instr) || combine_output_conversion(ctx, instr))
          ;
-      apply_insert(ctx, instr);
    }
 
    if (instr->isDPP())
-- 
GitLab


From 283caabd5c8b46df4d7912483e1db64bc5330f6d Mon Sep 17 00:00:00 2001
From: Georg Lehmann <dadschoorse@gmail.com>
Date: Thu, 9 Jan 2025 22:38:41 +0100
Subject: [PATCH 24/29] aco/optimizer: use new helpers to create
 v_fma_mixlo_f16

Foz-DB Navi21:
Totals from 62 (0.08% of 79789) affected shaders:
CodeSize: 22460 -> 22624 (+0.73%); split: -0.20%, +0.93%
VGPRs: 1240 -> 1112 (-10.32%)
Latency: 32090 -> 32116 (+0.08%); split: -0.05%, +0.13%
---
 src/amd/compiler/aco_optimizer.cpp        | 133 ++++------------------
 src/amd/compiler/tests/test_optimizer.cpp |   3 +-
 2 files changed, 26 insertions(+), 110 deletions(-)

diff --git a/src/amd/compiler/aco_optimizer.cpp b/src/amd/compiler/aco_optimizer.cpp
index b1a03ffae54e0..9dc10743ecdc2 100644
--- a/src/amd/compiler/aco_optimizer.cpp
+++ b/src/amd/compiler/aco_optimizer.cpp
@@ -70,11 +70,9 @@ enum Label {
    label_omod4 = 1ull << 34,
    label_omod5 = 1ull << 35,
    label_clamp = 1ull << 36,
-   label_f2f16 = 1ull << 39,
 };
 
-static constexpr uint64_t instr_mod_labels =
-   label_omod2 | label_omod4 | label_omod5 | label_clamp | label_f2f16;
+static constexpr uint64_t instr_mod_labels = label_omod2 | label_omod4 | label_omod5 | label_clamp;
 
 static constexpr uint64_t input_mod_labels =
    label_abs_fp16 | label_abs_fp32_64 | label_neg_fp16 | label_neg_fp32_64;
@@ -236,16 +234,6 @@ struct ssa_info {
 
    bool is_clamp() { return label & label_clamp; }
 
-   void set_f2f16(Instruction* conv)
-   {
-      if (label & temp_labels)
-         return;
-      add_label(label_f2f16);
-      mod_instr = conv;
-   }
-
-   bool is_f2f16() { return label & label_f2f16; }
-
    void set_uniform_bitwise() { add_label(label_uniform_bitwise); }
 
    bool is_uniform_bitwise() { return label & label_uniform_bitwise; }
@@ -3016,11 +3004,6 @@ label_instruction(opt_ctx& ctx, aco_ptr<Instruction>& instr)
          ctx.info[instr->definitions[0].tempId()].set_extract();
       break;
    }
-   case aco_opcode::v_cvt_f16_f32: {
-      if (instr->operands[0].isTemp())
-         ctx.info[instr->operands[0].tempId()].set_f2f16(instr.get());
-      break;
-   }
    default: break;
    }
 
@@ -3582,7 +3565,7 @@ apply_omod_clamp(opt_ctx& ctx, aco_ptr<Instruction>& instr)
       instr->valu().clamp = true;
 
    instr->definitions[0].swapTemp(def_info.mod_instr->definitions[0]);
-   ctx.info[instr->definitions[0].tempId()].label &= label_clamp | label_f2f16;
+   ctx.info[instr->definitions[0].tempId()].label &= label_clamp;
    ctx.uses[def_info.mod_instr->definitions[0].tempId()]--;
    ctx.info[instr->definitions[0].tempId()].parent_instr = instr.get();
    ctx.info[def_info.mod_instr->definitions[0].tempId()].parent_instr = def_info.mod_instr;
@@ -3735,102 +3718,34 @@ apply_load_extract(opt_ctx& ctx, aco_ptr<Instruction>& extract, Instruction* loa
    return load;
 }
 
-bool
-can_use_mad_mix(opt_ctx& ctx, aco_ptr<Instruction>& instr)
+Instruction*
+apply_f2f16(opt_ctx& ctx, aco_ptr<Instruction>& instr, Instruction* parent)
 {
-   if (ctx.program->gfx_level < GFX9)
-      return false;
-
-   /* unfused v_mad_mix* always flushes 16/32-bit denormal inputs/outputs */
-   if (!ctx.program->dev.fused_mad_mix && ctx.fp_mode.denorm)
-      return false;
-
    if (instr->valu().omod)
-      return false;
-
-   switch (instr->opcode) {
-   case aco_opcode::v_add_f32:
-   case aco_opcode::v_sub_f32:
-   case aco_opcode::v_subrev_f32:
-   case aco_opcode::v_mul_f32: return !instr->isSDWA() && !instr->isDPP();
-   case aco_opcode::v_fma_f32:
-      return ctx.program->dev.fused_mad_mix;
-   case aco_opcode::v_fma_mix_f32:
-   case aco_opcode::v_fma_mixlo_f16: return true;
-   default: return false;
-   }
-}
-
-void
-to_mad_mix(opt_ctx& ctx, aco_ptr<Instruction>& instr)
-{
-   ctx.info[instr->definitions[0].tempId()].label &= label_f2f16 | label_clamp;
-
-   if (instr->opcode == aco_opcode::v_fma_f32) {
-      instr->format = (Format)((uint32_t)withoutVOP3(instr->format) | (uint32_t)(Format::VOP3P));
-      instr->opcode = aco_opcode::v_fma_mix_f32;
-      return;
-   }
-
-   bool is_add = instr->opcode != aco_opcode::v_mul_f32;
-
-   aco_ptr<Instruction> vop3p{create_instruction(aco_opcode::v_fma_mix_f32, Format::VOP3P, 3, 1)};
-
-   for (unsigned i = 0; i < instr->operands.size(); i++) {
-      vop3p->operands[is_add + i] = instr->operands[i];
-      vop3p->valu().neg_lo[is_add + i] = instr->valu().neg[i];
-      vop3p->valu().neg_hi[is_add + i] = instr->valu().abs[i];
-   }
-   if (instr->opcode == aco_opcode::v_mul_f32) {
-      vop3p->operands[2] = Operand::zero();
-      vop3p->valu().neg_lo[2] = true;
-   } else if (is_add) {
-      vop3p->operands[0] = Operand::c32(0x3f800000);
-      if (instr->opcode == aco_opcode::v_sub_f32)
-         vop3p->valu().neg_lo[2] ^= true;
-      else if (instr->opcode == aco_opcode::v_subrev_f32)
-         vop3p->valu().neg_lo[1] ^= true;
-   }
-   vop3p->definitions[0] = instr->definitions[0];
-   vop3p->valu().clamp = instr->valu().clamp;
-   vop3p->pass_flags = instr->pass_flags;
-   instr = std::move(vop3p);
-   ctx.info[instr->definitions[0].tempId()].parent_instr = instr.get();
-}
-
-bool
-combine_output_conversion(opt_ctx& ctx, aco_ptr<Instruction>& instr)
-{
-   ssa_info& def_info = ctx.info[instr->definitions[0].tempId()];
-   if (!def_info.is_f2f16())
-      return false;
-   Instruction* conv = def_info.mod_instr;
-
-   if (!ctx.uses[conv->definitions[0].tempId()] || ctx.uses[instr->definitions[0].tempId()] != 1)
-      return false;
+      return nullptr;
 
-   if (conv->usesModifiers())
-      return false;
+   alu_opt_info info;
+   if (!alu_opt_gather_info(ctx, instr.get(), info))
+      return nullptr;
+   aco_type type = {aco_base_type_float, 1, 32};
 
-   if (interp_can_become_fma(ctx, instr))
-      interp_p2_f32_inreg_to_fma_dpp(instr);
+   alu_opt_info parent_info;
+   if (!alu_opt_gather_info(ctx, parent, parent_info))
+      return nullptr;
 
-   if (!can_use_mad_mix(ctx, instr))
-      return false;
+   if (parent_info.uses_insert() || parent_info.f32_to_f16)
+      return nullptr;
 
-   if (!instr->isVOP3P())
-      to_mad_mix(ctx, instr);
+   if (!backpropagate_input_modifiers(ctx, parent_info, info.operands[0], type))
+      return nullptr;
 
-   instr->opcode = aco_opcode::v_fma_mixlo_f16;
-   instr->definitions[0].swapTemp(conv->definitions[0]);
-   if (conv->definitions[0].isPrecise())
-      instr->definitions[0].setPrecise(true);
-   ctx.info[instr->definitions[0].tempId()].label &= label_clamp;
-   ctx.uses[conv->definitions[0].tempId()]--;
-   ctx.info[instr->definitions[0].tempId()].parent_instr = instr.get();
-   ctx.info[conv->definitions[0].tempId()].parent_instr = conv;
+   parent_info.f32_to_f16 = true;
+   parent_info.clamp |= info.clamp;
 
-   return true;
+   parent_info.defs[0].setTemp(info.defs[0].getTemp());
+   if (!alu_opt_info_is_valid(ctx, parent_info))
+      return nullptr;
+   return alu_opt_info_to_instr(ctx, parent_info, parent);
 }
 
 bool
@@ -3926,6 +3841,8 @@ apply_output_impl(opt_ctx& ctx, aco_ptr<Instruction>& instr, Instruction* parent
             instr->opcode == aco_opcode::v_mul_f32 || instr->opcode == aco_opcode::v_mul_f16 ||
             instr->opcode == aco_opcode::v_pk_mul_f16)
       return apply_output_mul(ctx, instr, parent);
+   else if (instr->opcode == aco_opcode::v_cvt_f16_f32)
+      return apply_f2f16(ctx, instr, parent);
 
    return nullptr;
 }
@@ -4194,7 +4111,7 @@ combine_instruction(opt_ctx& ctx, aco_ptr<Instruction>& instr)
    }
 
    if (instr->isVALU()) {
-      while (apply_omod_clamp(ctx, instr) || combine_output_conversion(ctx, instr))
+      while (apply_omod_clamp(ctx, instr))
          ;
    }
 
diff --git a/src/amd/compiler/tests/test_optimizer.cpp b/src/amd/compiler/tests/test_optimizer.cpp
index 67a7e48dd007d..579da33336154 100644
--- a/src/amd/compiler/tests/test_optimizer.cpp
+++ b/src/amd/compiler/tests/test_optimizer.cpp
@@ -1308,8 +1308,7 @@ BEGIN_TEST(optimize.mad_mix.output_conv.modifiers)
       //! p_unit_test 0, %res0
       writeout(0, f2f16(fabs(fadd(a, b))));
 
-      //! v1: %res1_add = v_add_f32 %1, %2
-      //! v2b: %res1 = v_cvt_f16_f32 -%res1_add
+      //! v2b: %res1 = v_fma_mixlo_f16 1.0, -%a, -%b
       //! p_unit_test 1, %res1
       writeout(1, f2f16(fneg(fadd(a, b))));
 
-- 
GitLab


From 387f49c38c74def87cf42d609c11d267236bd5ea Mon Sep 17 00:00:00 2001
From: Georg Lehmann <dadschoorse@gmail.com>
Date: Fri, 10 Jan 2025 08:32:30 +0100
Subject: [PATCH 25/29] aco/optimizer: use new helpers for omod/clamp

Foz-DB Navi21:
Totals from 4760 (5.97% of 79789) affected shaders:
Instrs: 8492296 -> 8484659 (-0.09%); split: -0.09%, +0.00%
CodeSize: 46913096 -> 46904748 (-0.02%); split: -0.04%, +0.02%
VGPRs: 263416 -> 263400 (-0.01%)
Latency: 77466712 -> 77451156 (-0.02%); split: -0.03%, +0.01%
InvThroughput: 17787393 -> 17776604 (-0.06%); split: -0.06%, +0.00%
SClause: 257489 -> 257478 (-0.00%); split: -0.02%, +0.01%
Copies: 670488 -> 670460 (-0.00%); split: -0.02%, +0.01%
Branches: 258877 -> 258868 (-0.00%)
PreVGPRs: 228743 -> 228787 (+0.02%)
VALU: 5743591 -> 5736004 (-0.13%); split: -0.13%, +0.00%
SALU: 1061545 -> 1061544 (-0.00%); split: -0.00%, +0.00%
---
 src/amd/compiler/aco_optimizer.cpp        | 282 +++++-----------------
 src/amd/compiler/tests/test_optimizer.cpp |   4 +-
 2 files changed, 66 insertions(+), 220 deletions(-)

diff --git a/src/amd/compiler/aco_optimizer.cpp b/src/amd/compiler/aco_optimizer.cpp
index 9dc10743ecdc2..488907e59ded3 100644
--- a/src/amd/compiler/aco_optimizer.cpp
+++ b/src/amd/compiler/aco_optimizer.cpp
@@ -61,19 +61,8 @@ enum Label {
    label_canonicalized_fp16 = 1ull << 22,
    label_canonicalized_fp32 = 1ull << 23,
    label_canonicalized_fp64 = 1ull << 24,
-
-   /* label_{omod2,omod4,omod5,clamp} are used for both 16 and
-    * 32-bit operations but this doesn't cause any issues because
-    * we check the definition register class.
-    */
-   label_omod2 = 1ull << 33,
-   label_omod4 = 1ull << 34,
-   label_omod5 = 1ull << 35,
-   label_clamp = 1ull << 36,
 };
 
-static constexpr uint64_t instr_mod_labels = label_omod2 | label_omod4 | label_omod5 | label_clamp;
-
 static constexpr uint64_t input_mod_labels =
    label_abs_fp16 | label_abs_fp32_64 | label_neg_fp16 | label_neg_fp32_64;
 
@@ -99,8 +88,6 @@ canonicalized_label(unsigned bit_size)
       UNREACHABLE("unknown canonicalized size");
 }
 
-static_assert((instr_mod_labels & temp_labels) == 0, "labels cannot intersect");
-static_assert((instr_mod_labels & val_labels) == 0, "labels cannot intersect");
 static_assert((temp_labels & val_labels) == 0, "labels cannot intersect");
 
 struct ssa_info {
@@ -108,7 +95,6 @@ struct ssa_info {
    union {
       uint64_t val;
       Temp temp;
-      Instruction* mod_instr;
    };
    Instruction* parent_instr;
 
@@ -116,19 +102,14 @@ struct ssa_info {
 
    void add_label(Label new_label)
    {
-      if (new_label & instr_mod_labels) {
-         label &= ~instr_mod_labels;
-         label &= ~(temp_labels | val_labels); /* instr, temp and val alias */
-      }
-
       if (new_label & temp_labels) {
          label &= ~temp_labels;
-         label &= ~(instr_mod_labels | val_labels); /* instr, temp and val alias */
+         label &= ~val_labels; /* temp and val alias */
       }
 
       if (new_label & val_labels) {
          label &= ~val_labels;
-         label &= ~(instr_mod_labels | temp_labels); /* instr, temp and val alias */
+         label &= ~temp_labels; /* temp and val alias */
       }
 
       label |= new_label;
@@ -194,46 +175,6 @@ struct ssa_info {
 
    bool is_combined() { return label & label_combined_instr; }
 
-   void set_omod2(Instruction* mul)
-   {
-      if (label & temp_labels)
-         return;
-      add_label(label_omod2);
-      mod_instr = mul;
-   }
-
-   bool is_omod2() { return label & label_omod2; }
-
-   void set_omod4(Instruction* mul)
-   {
-      if (label & temp_labels)
-         return;
-      add_label(label_omod4);
-      mod_instr = mul;
-   }
-
-   bool is_omod4() { return label & label_omod4; }
-
-   void set_omod5(Instruction* mul)
-   {
-      if (label & temp_labels)
-         return;
-      add_label(label_omod5);
-      mod_instr = mul;
-   }
-
-   bool is_omod5() { return label & label_omod5; }
-
-   void set_clamp(Instruction* med3)
-   {
-      if (label & temp_labels)
-         return;
-      add_label(label_clamp);
-      mod_instr = med3;
-   }
-
-   bool is_clamp() { return label & label_clamp; }
-
    void set_uniform_bitwise() { add_label(label_uniform_bitwise); }
 
    bool is_uniform_bitwise() { return label & label_uniform_bitwise; }
@@ -1675,34 +1616,6 @@ gather_canonicalized(opt_ctx& ctx, aco_ptr<Instruction>& instr)
    }
 }
 
-bool
-can_use_VOP3(opt_ctx& ctx, const aco_ptr<Instruction>& instr)
-{
-   if (instr->isVOP3())
-      return true;
-
-   if (instr->isVOP3P() || instr->isVINTERP_INREG())
-      return false;
-
-   if (instr->operands.size() && instr->operands[0].isLiteral() && ctx.program->gfx_level < GFX10)
-      return false;
-
-   if (instr->isSDWA())
-      return false;
-
-   if (instr->isDPP() && ctx.program->gfx_level < GFX11)
-      return false;
-
-   return instr->opcode != aco_opcode::v_madmk_f32 && instr->opcode != aco_opcode::v_madak_f32 &&
-          instr->opcode != aco_opcode::v_madmk_f16 && instr->opcode != aco_opcode::v_madak_f16 &&
-          instr->opcode != aco_opcode::v_fmamk_f32 && instr->opcode != aco_opcode::v_fmaak_f32 &&
-          instr->opcode != aco_opcode::v_fmamk_f16 && instr->opcode != aco_opcode::v_fmaak_f16 &&
-          instr->opcode != aco_opcode::v_permlane64_b32 &&
-          instr->opcode != aco_opcode::v_readlane_b32 &&
-          instr->opcode != aco_opcode::v_writelane_b32 &&
-          instr->opcode != aco_opcode::v_readfirstlane_b32;
-}
-
 bool
 pseudo_propagate_temp(opt_ctx& ctx, aco_ptr<Instruction>& instr, Temp temp, unsigned index)
 {
@@ -2417,7 +2330,7 @@ alu_propagate_temp_const(opt_ctx& ctx, aco_ptr<Instruction>& instr, bool uses_va
 
    instr.reset(alu_opt_info_to_instr(ctx, result_info, instr.release()));
    for (const Definition& def : instr->definitions)
-      ctx.info[def.tempId()].label &= instr_mod_labels | canonicalized_labels;
+      ctx.info[def.tempId()].label &= canonicalized_labels;
 }
 
 void
@@ -2856,8 +2769,7 @@ label_instruction(opt_ctx& ctx, aco_ptr<Instruction>& instr)
    case aco_opcode::v_mul_f32:
    case aco_opcode::v_mul_legacy_f32:
    case aco_opcode::v_mul_f64:
-   case aco_opcode::v_mul_f64_e64: { /* omod */
-      /* TODO: try to move the negate/abs modifier to the consumer instead */
+   case aco_opcode::v_mul_f64_e64: {
       bool uses_mods = instr->usesModifiers();
       bool fp16 = instr->opcode == aco_opcode::v_mul_f16;
       bool fp64 =
@@ -2875,19 +2787,13 @@ label_instruction(opt_ctx& ctx, aco_ptr<Instruction>& instr)
             bool neg1 = constant == -1.0;
 
             VALU_instruction* valu = &instr->valu();
-            if (valu->abs[!i] || valu->neg[!i] || valu->omod)
+            if (valu->abs[!i] || valu->neg[!i] || valu->omod || valu->clamp)
                continue;
 
             bool abs = valu->abs[i];
             bool neg = neg1 ^ valu->neg[i];
             Temp other = instr->operands[i].getTemp();
 
-            if (valu->clamp) {
-               if (!abs && !neg && other.type() == RegType::vgpr)
-                  ctx.info[other.id()].set_clamp(instr.get());
-               continue;
-            }
-
             if (abs && neg && other.type() == RegType::vgpr)
                ctx.info[instr->definitions[0].tempId()].set_neg_abs(other, bit_size);
             else if (abs && !neg && other.type() == RegType::vgpr)
@@ -2900,37 +2806,17 @@ label_instruction(opt_ctx& ctx, aco_ptr<Instruction>& instr)
                else
                   ctx.info[instr->definitions[0].tempId()].set_fcanonicalize(other, bit_size);
             }
-         } else if (uses_mods || (instr->definitions[0].isSZPreserve() &&
-                                  instr->opcode != aco_opcode::v_mul_legacy_f32)) {
-            continue; /* omod uses a legacy multiplication. */
-         } else if (instr->operands[!i].constantValue64() == 0u &&
+         } else if (!uses_mods && instr->operands[!i].constantValue64() == 0u &&
                     ((!instr->definitions[0].isNaNPreserve() &&
-                      !instr->definitions[0].isInfPreserve()) ||
+                      !instr->definitions[0].isInfPreserve() &&
+                      !instr->definitions[0].isSZPreserve()) ||
                      instr->opcode == aco_opcode::v_mul_legacy_f32)) {
             ctx.info[instr->definitions[0].tempId()].set_constant(0u);
-         } else if (denorm_mode != fp_denorm_flush) {
-            /* omod has no effect if denormals are enabled. */
-            continue;
-         } else if (constant == 2.0) {
-            ctx.info[instr->operands[i].tempId()].set_omod2(instr.get());
-         } else if (constant == 4.0) {
-            ctx.info[instr->operands[i].tempId()].set_omod4(instr.get());
-         } else if (constant == 0.5) {
-            ctx.info[instr->operands[i].tempId()].set_omod5(instr.get());
-         } else {
-            continue;
          }
          break;
       }
       break;
    }
-   case aco_opcode::v_med3_f16:
-   case aco_opcode::v_med3_f32: { /* clamp */
-      unsigned idx;
-      if (detect_clamp(instr.get(), &idx) && !instr->valu().abs && !instr->valu().neg)
-         ctx.info[instr->operands[idx].tempId()].set_clamp(instr.get());
-      break;
-   }
    case aco_opcode::s_not_b32:
    case aco_opcode::s_not_b64:
       if (!instr->operands[0].isTemp()) {
@@ -3479,98 +3365,44 @@ use_absdiff:
    return op_instr;
 }
 
-bool
-interp_can_become_fma(opt_ctx& ctx, aco_ptr<Instruction>& instr)
-{
-   if (instr->opcode != aco_opcode::v_interp_p2_f32_inreg)
-      return false;
-
-   instr->opcode = aco_opcode::v_fma_f32;
-   instr->format = Format::VOP3;
-   bool dpp_allowed = can_use_DPP(ctx.program->gfx_level, instr, false);
-   instr->opcode = aco_opcode::v_interp_p2_f32_inreg;
-   instr->format = Format::VINTERP_INREG;
-
-   return dpp_allowed;
-}
-
-void
-interp_p2_f32_inreg_to_fma_dpp(aco_ptr<Instruction>& instr)
-{
-   static_assert(sizeof(DPP16_instruction) == sizeof(VINTERP_inreg_instruction),
-                 "Invalid instr cast.");
-   instr->format = asVOP3(Format::DPP16);
-   instr->opcode = aco_opcode::v_fma_f32;
-   instr->dpp16().dpp_ctrl = dpp_quad_perm(2, 2, 2, 2);
-   instr->dpp16().row_mask = 0xf;
-   instr->dpp16().bank_mask = 0xf;
-   instr->dpp16().bound_ctrl = 0;
-   instr->dpp16().fetch_inactive = 1;
-}
-
-/* apply omod / clamp modifiers if the def is used only once and the instruction can have modifiers */
-bool
-apply_omod_clamp(opt_ctx& ctx, aco_ptr<Instruction>& instr)
+Instruction*
+apply_clamp(opt_ctx& ctx, aco_ptr<Instruction>& instr, Instruction* parent)
 {
-   if (instr->definitions.empty() || ctx.uses[instr->definitions[0].tempId()] != 1 ||
-       !instr_info.alu_opcode_infos[(int)instr->opcode].output_modifiers)
-      return false;
-
-   bool can_vop3 = can_use_VOP3(ctx, instr);
-   bool is_mad_mix =
-      instr->opcode == aco_opcode::v_fma_mix_f32 || instr->opcode == aco_opcode::v_fma_mixlo_f16;
-   bool needs_vop3 = !instr->isSDWA() && !instr->isVINTERP_INREG() && !is_mad_mix;
-   if (needs_vop3 && !can_vop3)
-      return false;
-
-   if (instr_info.classes[(int)instr->opcode] == instr_class::valu_pseudo_scalar_trans)
-      return false;
-
-   /* SDWA omod is GFX9+. */
-   bool can_use_omod = (can_vop3 || ctx.program->gfx_level >= GFX9) && !instr->isVOP3P() &&
-                       (!instr->isVINTERP_INREG() || interp_can_become_fma(ctx, instr));
-
-   ssa_info& def_info = ctx.info[instr->definitions[0].tempId()];
+   unsigned idx;
+   if (!detect_clamp(instr.get(), &idx))
+      return nullptr;
 
-   uint64_t omod_labels = label_omod2 | label_omod4 | label_omod5;
-   if (!def_info.is_clamp() && !(can_use_omod && (def_info.label & omod_labels)))
-      return false;
-   /* if the omod/clamp instruction is dead, then the single user of this
-    * instruction is a different instruction */
-   if (!ctx.uses[def_info.mod_instr->definitions[0].tempId()])
-      return false;
+   aco_type type = instr_info.alu_opcode_infos[(int)instr->opcode].def_types[0];
 
-   if (def_info.mod_instr->definitions[0].bytes() != instr->definitions[0].bytes())
-      return false;
+   if (!ctx.info[parent->definitions[0].tempId()].is_canonicalized(type.bit_size) &&
+       ctx.fp_mode.denorm32 != fp_denorm_keep)
+      return nullptr;
 
-   /* MADs/FMAs are created later, so we don't have to update the original add */
-   assert(!ctx.info[instr->definitions[0].tempId()].is_combined());
+   aco_type parent_type = instr_info.alu_opcode_infos[(int)parent->opcode].def_types[0];
 
-   if (!def_info.is_clamp() && (instr->valu().clamp || instr->valu().omod))
-      return false;
+   if (!instr_info.alu_opcode_infos[(int)parent->opcode].output_modifiers ||
+       type.bit_size != parent_type.bit_size || parent_type.num_components != 1)
+      return nullptr;
 
-   if (needs_vop3)
-      instr->format = asVOP3(instr->format);
+   alu_opt_info parent_info;
+   if (!alu_opt_gather_info(ctx, parent, parent_info))
+      return nullptr;
 
-   if (!def_info.is_clamp() && instr->opcode == aco_opcode::v_interp_p2_f32_inreg)
-      interp_p2_f32_inreg_to_fma_dpp(instr);
+   if (parent_info.uses_insert())
+      return nullptr;
 
-   if (def_info.is_omod2())
-      instr->valu().omod = 1;
-   else if (def_info.is_omod4())
-      instr->valu().omod = 2;
-   else if (def_info.is_omod5())
-      instr->valu().omod = 3;
-   else if (def_info.is_clamp())
-      instr->valu().clamp = true;
+   alu_opt_info info;
+   if (!alu_opt_gather_info(ctx, instr.get(), info))
+      return nullptr;
 
-   instr->definitions[0].swapTemp(def_info.mod_instr->definitions[0]);
-   ctx.info[instr->definitions[0].tempId()].label &= label_clamp;
-   ctx.uses[def_info.mod_instr->definitions[0].tempId()]--;
-   ctx.info[instr->definitions[0].tempId()].parent_instr = instr.get();
-   ctx.info[def_info.mod_instr->definitions[0].tempId()].parent_instr = def_info.mod_instr;
+   if (!backpropagate_input_modifiers(ctx, parent_info, info.operands[idx], type))
+      return nullptr;
 
-   return true;
+   parent_info.clamp = true;
+   parent_info.defs[0].setTemp(info.defs[0].getTemp());
+   if (!alu_opt_info_is_valid(ctx, parent_info))
+      return nullptr;
+   return alu_opt_info_to_instr(ctx, parent_info, parent);
 }
 
 /* Combine an p_insert (or p_extract, in some cases) instruction with instr.
@@ -3788,6 +3620,8 @@ apply_output_mul(opt_ctx& ctx, aco_ptr<Instruction>& instr, Instruction* parent)
    if (!op_info_get_constant(ctx, info.operands[cidx], type, &constant))
       return nullptr;
 
+   unsigned omod = 0;
+
    for (unsigned i = 0; i < type.num_components; i++) {
       double val = extract_float(constant, type.bit_size, i);
       if (val < 0.0) {
@@ -3795,27 +3629,42 @@ apply_output_mul(opt_ctx& ctx, aco_ptr<Instruction>& instr, Instruction* parent)
          info.operands[!cidx].neg[i] ^= true;
       }
 
-      if (val != 1.0)
+      if (val == 1.0)
+         omod = 0;
+      else if (val == 2.0)
+         omod = 1;
+      else if (val == 4.0)
+         omod = 2;
+      else if (val == 0.5)
+         omod = 3;
+      else
+         return nullptr;
+
+      if (omod && type.num_components != 1)
          return nullptr;
    }
 
-   if ((info.omod || info.clamp) &&
-       !instr_info.alu_opcode_infos[(int)parent->opcode].output_modifiers)
+   if (omod && (info.omod || denorm_mode != fp_denorm_flush ||
+                (info.opcode != aco_opcode::v_mul_legacy_f32 && info.defs[0].isSZPreserve())))
+      return nullptr;
+
+   omod |= info.omod;
+
+   if ((omod || info.clamp) && !instr_info.alu_opcode_infos[(int)parent->opcode].output_modifiers)
       return nullptr;
 
    alu_opt_info parent_info;
    if (!alu_opt_gather_info(ctx, parent, parent_info))
       return nullptr;
 
-   if (parent_info.uses_insert() ||
-       (info.omod && (parent_info.omod || parent_info.clamp)))
+   if (parent_info.uses_insert() || (omod && (parent_info.omod || parent_info.clamp)))
       return nullptr;
 
    if (!backpropagate_input_modifiers(ctx, parent_info, info.operands[!cidx], type))
       return nullptr;
 
    parent_info.clamp |= info.clamp;
-   parent_info.omod |= info.omod;
+   parent_info.omod |= omod;
    parent_info.insert = info.insert;
    parent_info.defs[0].setTemp(info.defs[0].getTemp());
    if (!alu_opt_info_is_valid(ctx, parent_info))
@@ -3839,10 +3688,13 @@ apply_output_impl(opt_ctx& ctx, aco_ptr<Instruction>& instr, Instruction* parent
       return apply_s_abs(ctx, instr, parent);
    else if (instr->opcode == aco_opcode::v_mul_f64 || instr->opcode == aco_opcode::v_mul_f64_e64 ||
             instr->opcode == aco_opcode::v_mul_f32 || instr->opcode == aco_opcode::v_mul_f16 ||
-            instr->opcode == aco_opcode::v_pk_mul_f16)
+            instr->opcode == aco_opcode::v_pk_mul_f16 ||
+            instr->opcode == aco_opcode::v_mul_legacy_f32)
       return apply_output_mul(ctx, instr, parent);
    else if (instr->opcode == aco_opcode::v_cvt_f16_f32)
       return apply_f2f16(ctx, instr, parent);
+   else if (instr->opcode == aco_opcode::v_med3_f32 || instr->opcode == aco_opcode::v_med3_f16)
+      return apply_clamp(ctx, instr, parent);
 
    return nullptr;
 }
@@ -3906,8 +3758,7 @@ apply_output(opt_ctx& ctx, aco_ptr<Instruction>& instr)
 
    for (Definition& def : new_instr->definitions) {
       ctx.info[def.tempId()].parent_instr = new_instr;
-      ctx.info[def.tempId()].label &=
-         instr_mod_labels | canonicalized_labels | label_combined_instr;
+      ctx.info[def.tempId()].label &= canonicalized_labels | label_combined_instr;
    }
 
    instr.reset();
@@ -4110,11 +3961,6 @@ combine_instruction(opt_ctx& ctx, aco_ptr<Instruction>& instr)
       alu_propagate_temp_const(ctx, instr, true);
    }
 
-   if (instr->isVALU()) {
-      while (apply_omod_clamp(ctx, instr))
-         ;
-   }
-
    if (instr->isDPP())
       return;
 
diff --git a/src/amd/compiler/tests/test_optimizer.cpp b/src/amd/compiler/tests/test_optimizer.cpp
index 579da33336154..8abea38fc6805 100644
--- a/src/amd/compiler/tests/test_optimizer.cpp
+++ b/src/amd/compiler/tests/test_optimizer.cpp
@@ -1360,8 +1360,8 @@ BEGIN_TEST(optimize.mad_mix.fma.basic)
       writeout(1, fadd(fmul(a, b), f2f32(c16)));
 
       /* omod/clamp check */
-      //! v1: %res2_mul = v_fma_mix_f32 lo(%a16), %b, neg(0)
-      //! v1: %res2 = v_add_f32 %res2_mul, %c *2
+      //! v1: %res2_fma = v_fma_mix_f32 lo(%a16), %b, %c
+      //! v1: %res2 = v_mul_f32 2.0, %res2_fma
       //! p_unit_test 2, %res2
       writeout(2, bld.vop2(aco_opcode::v_mul_f32, bld.def(v1), Operand::c32(0x40000000),
                            fadd(fmul(f2f32(a16), b), c)));
-- 
GitLab


From a4a4b343de6de2c7bfcad2f7d2e380498aee6f5e Mon Sep 17 00:00:00 2001
From: Georg Lehmann <dadschoorse@gmail.com>
Date: Thu, 13 Mar 2025 20:27:54 +0100
Subject: [PATCH 26/29] aco/optimizer: apply omod to pseudo scalar trans
 instructions

---
 src/amd/compiler/aco_optimizer.cpp        | 3 ++-
 src/amd/compiler/tests/test_optimizer.cpp | 8 +++++++-
 2 files changed, 9 insertions(+), 2 deletions(-)

diff --git a/src/amd/compiler/aco_optimizer.cpp b/src/amd/compiler/aco_optimizer.cpp
index 488907e59ded3..3a378ded4518d 100644
--- a/src/amd/compiler/aco_optimizer.cpp
+++ b/src/amd/compiler/aco_optimizer.cpp
@@ -3689,7 +3689,8 @@ apply_output_impl(opt_ctx& ctx, aco_ptr<Instruction>& instr, Instruction* parent
    else if (instr->opcode == aco_opcode::v_mul_f64 || instr->opcode == aco_opcode::v_mul_f64_e64 ||
             instr->opcode == aco_opcode::v_mul_f32 || instr->opcode == aco_opcode::v_mul_f16 ||
             instr->opcode == aco_opcode::v_pk_mul_f16 ||
-            instr->opcode == aco_opcode::v_mul_legacy_f32)
+            instr->opcode == aco_opcode::v_mul_legacy_f32 ||
+            instr->opcode == aco_opcode::s_mul_f32 || instr->opcode == aco_opcode::s_mul_f16)
       return apply_output_mul(ctx, instr, parent);
    else if (instr->opcode == aco_opcode::v_cvt_f16_f32)
       return apply_f2f16(ctx, instr, parent);
diff --git a/src/amd/compiler/tests/test_optimizer.cpp b/src/amd/compiler/tests/test_optimizer.cpp
index 8abea38fc6805..2906547f708cf 100644
--- a/src/amd/compiler/tests/test_optimizer.cpp
+++ b/src/amd/compiler/tests/test_optimizer.cpp
@@ -2040,7 +2040,7 @@ BEGIN_TEST(optimizer.trans_inline_constant)
    finish_opt_test();
 END_TEST
 
-BEGIN_TEST(optimizer.trans_no_omod)
+BEGIN_TEST(optimizer.trans_omod)
    //>> s1: %a:s[0] = p_startpgm
    if (!setup_cs("s1", GFX12))
       return;
@@ -2052,6 +2052,12 @@ BEGIN_TEST(optimizer.trans_no_omod)
    writeout(0, bld.vop2(aco_opcode::v_mul_legacy_f32, bld.def(v1), dst,
                         bld.copy(bld.def(v1), Operand::c32(0x3f000000))));
 
+   //! s1: %res1 = v_s_rcp_f32 -%a *0.5
+   //! p_unit_test 1, %res1
+   dst = bld.vop3(aco_opcode::v_s_rcp_f32, bld.def(s1), inputs[0]);
+   writeout(1, bld.sop2(aco_opcode::s_mul_f32, bld.def(s1), dst,
+                        bld.copy(bld.def(s1), Operand::c32(0xbf000000))));
+
    finish_opt_test();
 END_TEST
 
-- 
GitLab


From 4d83b3704befdaa9ac18f5ff1625dc3006884cd7 Mon Sep 17 00:00:00 2001
From: Georg Lehmann <dadschoorse@gmail.com>
Date: Thu, 13 Mar 2025 20:04:40 +0100
Subject: [PATCH 27/29] aco/optimize: propagate salu neg/abs

---
 src/amd/compiler/aco_optimizer.cpp | 53 +++++++++++++++++++++++-------
 1 file changed, 42 insertions(+), 11 deletions(-)

diff --git a/src/amd/compiler/aco_optimizer.cpp b/src/amd/compiler/aco_optimizer.cpp
index 3a378ded4518d..b247f26469714 100644
--- a/src/amd/compiler/aco_optimizer.cpp
+++ b/src/amd/compiler/aco_optimizer.cpp
@@ -2765,13 +2765,15 @@ label_instruction(opt_ctx& ctx, aco_ptr<Instruction>& instr)
       if (!ctx.program->needs_wqm)
          ctx.info[instr->definitions[0].tempId()].set_constant(0u);
       break;
+   case aco_opcode::s_mul_f16:
+   case aco_opcode::s_mul_f32:
    case aco_opcode::v_mul_f16:
    case aco_opcode::v_mul_f32:
    case aco_opcode::v_mul_legacy_f32:
    case aco_opcode::v_mul_f64:
    case aco_opcode::v_mul_f64_e64: {
       bool uses_mods = instr->usesModifiers();
-      bool fp16 = instr->opcode == aco_opcode::v_mul_f16;
+      bool fp16 = instr->opcode == aco_opcode::v_mul_f16 || instr->opcode == aco_opcode::s_mul_f16;
       bool fp64 =
          instr->opcode == aco_opcode::v_mul_f64 || instr->opcode == aco_opcode::v_mul_f64_e64;
       unsigned bit_size = fp16 ? 16 : (fp64 ? 64 : 32);
@@ -2783,22 +2785,27 @@ label_instruction(opt_ctx& ctx, aco_ptr<Instruction>& instr)
 
          double constant = extract_float(instr->operands[!i].constantValue64(), bit_size);
 
-         if (!instr->isDPP() && !instr->isSDWA() && !instr->valu().opsel && fabs(constant) == 1.0) {
-            bool neg1 = constant == -1.0;
+         if (!instr->isDPP() && !instr->isSDWA() && (!instr->isVALU() || !instr->valu().opsel) &&
+             fabs(constant) == 1.0) {
+            bool neg = constant == -1.0;
+            bool abs = false;
 
-            VALU_instruction* valu = &instr->valu();
-            if (valu->abs[!i] || valu->neg[!i] || valu->omod || valu->clamp)
-               continue;
+            if (instr->isVALU()) {
+               VALU_instruction* valu = &instr->valu();
+               if (valu->abs[!i] || valu->neg[!i] || valu->omod || valu->clamp)
+                  continue;
+
+               abs = valu->abs[i];
+               neg ^= valu->neg[i];
+            }
 
-            bool abs = valu->abs[i];
-            bool neg = neg1 ^ valu->neg[i];
             Temp other = instr->operands[i].getTemp();
 
-            if (abs && neg && other.type() == RegType::vgpr)
+            if (abs && neg && other.type() == instr->definitions[0].getTemp().type())
                ctx.info[instr->definitions[0].tempId()].set_neg_abs(other, bit_size);
-            else if (abs && !neg && other.type() == RegType::vgpr)
+            else if (abs && !neg && other.type() == instr->definitions[0].getTemp().type())
                ctx.info[instr->definitions[0].tempId()].set_abs(other, bit_size);
-            else if (!abs && neg && other.type() == RegType::vgpr)
+            else if (!abs && neg && other.type() == instr->definitions[0].getTemp().type())
                ctx.info[instr->definitions[0].tempId()].set_neg(other, bit_size);
             else if (!abs && !neg) {
                if (denorm_mode == fp_denorm_keep || ctx.info[other.id()].is_canonicalized(bit_size))
@@ -2831,6 +2838,30 @@ label_instruction(opt_ctx& ctx, aco_ptr<Instruction>& instr)
       }
       break;
    case aco_opcode::s_and_b32:
+      for (unsigned i = 0; i < 2; i++) {
+         if (!instr->operands[!i].isTemp())
+            continue;
+         Temp tmp = instr->operands[!i].getTemp();
+         const Operand& op = instr->operands[i];
+         uint32_t constant;
+         if (op.isConstant())
+            constant = op.constantValue();
+         else if (op.isTemp() && ctx.info[op.tempId()].is_constant())
+            constant = ctx.info[op.tempId()].val;
+         else
+            continue;
+
+         if (constant == 0x7fffffff) {
+            if (ctx.info[tmp.id()].is_canonicalized(32))
+               ctx.info[instr->definitions[0].tempId()].set_canonicalized(32);
+            ctx.info[instr->definitions[0].tempId()].set_abs(tmp, 32);
+         } else if (constant == 0x7fff) {
+            if (ctx.info[tmp.id()].is_canonicalized(16))
+               ctx.info[instr->definitions[0].tempId()].set_canonicalized(16);
+            ctx.info[instr->definitions[0].tempId()].set_abs(tmp, 16);
+         }
+      }
+      FALLTHROUGH;
    case aco_opcode::s_and_b64:
       if (fixed_to_exec(instr->operands[1]) && instr->operands[0].isTemp()) {
          if (ctx.info[instr->operands[0].tempId()].is_uniform_bool()) {
-- 
GitLab


From 3df5663c6822c2924ec6efbc069dadb6a7149057 Mon Sep 17 00:00:00 2001
From: Georg Lehmann <dadschoorse@gmail.com>
Date: Wed, 19 Mar 2025 14:19:50 +0100
Subject: [PATCH 28/29] aco/optimizer: fix uses in to_uniform_bool_instr

---
 src/amd/compiler/aco_optimizer.cpp | 5 ++++-
 1 file changed, 4 insertions(+), 1 deletion(-)

diff --git a/src/amd/compiler/aco_optimizer.cpp b/src/amd/compiler/aco_optimizer.cpp
index b247f26469714..712b7689d19a5 100644
--- a/src/amd/compiler/aco_optimizer.cpp
+++ b/src/amd/compiler/aco_optimizer.cpp
@@ -4484,6 +4484,7 @@ to_uniform_bool_instr(opt_ctx& ctx, aco_ptr<Instruction>& instr)
          continue;
 
       ctx.uses[op.tempId()]--;
+      bool increase_uses = ctx.uses[op.tempId()];
 
       if (ctx.info[op.tempId()].is_uniform_bool()) {
          /* Just use the uniform boolean temp. */
@@ -4499,11 +4500,13 @@ to_uniform_bool_instr(opt_ctx& ctx, aco_ptr<Instruction>& instr)
          assert(pred_instr->definitions[1].isFixed() &&
                 pred_instr->definitions[1].physReg() == scc);
          op.setTemp(pred_instr->definitions[1].getTemp());
+         increase_uses = true;
       } else {
          UNREACHABLE("Invalid operand on uniform bitwise instruction.");
       }
 
-      ctx.uses[op.tempId()]++;
+      if (increase_uses)
+         ctx.uses[op.tempId()]++;
    }
 
    instr->definitions[0].setTemp(Temp(instr->definitions[0].tempId(), s1));
-- 
GitLab


From 20be198fca7079298914a5f7b8e3b53d0ab7ea0e Mon Sep 17 00:00:00 2001
From: Georg Lehmann <dadschoorse@gmail.com>
Date: Fri, 9 Aug 2024 16:32:01 +0200
Subject: [PATCH 29/29] aco/optimizer: validate uses

---
 src/amd/compiler/aco_dead_code_analysis.cpp |  2 ++
 src/amd/compiler/aco_optimizer.cpp          | 36 ++++++++++++++-------
 2 files changed, 27 insertions(+), 11 deletions(-)

diff --git a/src/amd/compiler/aco_dead_code_analysis.cpp b/src/amd/compiler/aco_dead_code_analysis.cpp
index 2fdddace4fadb..6a620efcaf585 100644
--- a/src/amd/compiler/aco_dead_code_analysis.cpp
+++ b/src/amd/compiler/aco_dead_code_analysis.cpp
@@ -37,6 +37,8 @@ process_block(std::vector<uint16_t>& uses, Block& block)
 {
    for (auto it = block.instructions.rbegin(); it != block.instructions.rend(); it++) {
       aco_ptr<Instruction>& instr = *it;
+      if (!instr.get())
+         continue;
       if ((block.kind & block_kind_loop_header) && is_phi(instr))
          break;
 
diff --git a/src/amd/compiler/aco_optimizer.cpp b/src/amd/compiler/aco_optimizer.cpp
index 712b7689d19a5..7e2906255fd23 100644
--- a/src/amd/compiler/aco_optimizer.cpp
+++ b/src/amd/compiler/aco_optimizer.cpp
@@ -5142,7 +5142,7 @@ apply_literals(opt_ctx& ctx, aco_ptr<Instruction>& instr)
 }
 
 void
-validate_opt_ctx(opt_ctx& ctx)
+validate_opt_ctx(opt_ctx& ctx, bool incorrect_uses_lits)
 {
    if (!(debug_flags & DEBUG_VALIDATE_OPT))
       return;
@@ -5161,7 +5161,8 @@ validate_opt_ctx(opt_ctx& ctx)
          FILE* const memf = u_memstream_get(&mem);
 
          fprintf(memf, "Optimizer: %s: ", msg);
-         aco_print_instr(program->gfx_level, instr, memf);
+         if (instr)
+            aco_print_instr(program->gfx_level, instr, memf);
          u_memstream_close(&mem);
 
          aco_err(program, "%s", out);
@@ -5181,9 +5182,24 @@ validate_opt_ctx(opt_ctx& ctx)
          }
       }
    }
-   if (!is_valid) {
+
+   std::vector<uint16_t> actual_uses = dead_code_analysis(program);
+   check(ctx.uses.size() == actual_uses.size(), "ctx.uses has wrong size", nullptr);
+   check(ctx.info.size() == actual_uses.size(), "ctx.info has wrong size", nullptr);
+
+   if (!is_valid)
       abort();
+
+   for (unsigned i = 0; i < ctx.uses.size(); i++) {
+      if (incorrect_uses_lits && (ctx.info[i].label & label_constant))
+         check(ctx.uses[i] <= actual_uses[i], "ctx.uses[i] is too high for a literal",
+               ctx.info[i].parent_instr);
+      else
+         check(ctx.uses[i] == actual_uses[i], "ctx.uses[i] is incorrect", ctx.info[i].parent_instr);
    }
+
+   if (!is_valid)
+      abort();
 }
 
 void rename_loop_header_phis(opt_ctx& ctx) {
@@ -5225,18 +5241,16 @@ optimize(Program* program)
          label_instruction(ctx, instr);
    }
 
-   validate_opt_ctx(ctx);
-
    rename_loop_header_phis(ctx);
 
-   validate_opt_ctx(ctx);
-
    ctx.uses = dead_code_analysis(program);
 
+   validate_opt_ctx(ctx, false);
+
    /* 2. Rematerialize constants in every block. */
    rematerialize_constants(ctx);
 
-   validate_opt_ctx(ctx);
+   validate_opt_ctx(ctx, false);
 
    /* 3. Combine v_mad, omod, clamp and propagate sgpr on VALU instructions */
    for (Block& block : program->blocks) {
@@ -5251,7 +5265,7 @@ optimize(Program* program)
          insert_replacement_instr(ctx, instr);
    }
 
-   validate_opt_ctx(ctx);
+   validate_opt_ctx(ctx, false);
 
    /* 4. Top-Down DAG pass (backward) to select instructions (includes DCE) */
    for (auto block_rit = program->blocks.rbegin(); block_rit != program->blocks.rend();
@@ -5263,7 +5277,7 @@ optimize(Program* program)
          select_instruction(ctx, *instr_rit);
    }
 
-   validate_opt_ctx(ctx);
+   validate_opt_ctx(ctx, true);
 
    /* 5. Add literals to instructions */
    for (Block& block : program->blocks) {
@@ -5274,7 +5288,7 @@ optimize(Program* program)
       block.instructions = std::move(ctx.instructions);
    }
 
-   validate_opt_ctx(ctx);
+   validate_opt_ctx(ctx, true);
 }
 
 } // namespace aco
-- 
GitLab

