From 423e427c05be1541be246830658d34d44ca9ce0b Mon Sep 17 00:00:00 2001
From: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date: Thu, 25 Aug 2022 08:41:05 +0200
Subject: [PATCH 1/2] radv: store binning settings into the physical device

To avoid re-computing this every time.

Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
---
 src/amd/vulkan/radv_cmd_buffer.c |  7 +++----
 src/amd/vulkan/radv_device.c     | 26 ++++++++++++++++++++++++
 src/amd/vulkan/radv_pipeline.c   | 35 ++++----------------------------
 src/amd/vulkan/radv_private.h    | 16 +++++++--------
 4 files changed, 41 insertions(+), 43 deletions(-)

diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index ee0993231a86..df3051725e67 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -1397,16 +1397,15 @@ radv_emit_batch_break_on_new_ps(struct radv_cmd_buffer *cmd_buffer)
    if (!cmd_buffer->device->pbb_allowed)
       return;
 
-   struct radv_binning_settings settings =
-      radv_get_binning_settings(cmd_buffer->device->physical_device);
+   struct radv_binning_settings *settings = &cmd_buffer->device->physical_device->binning_settings;
    bool break_for_new_ps =
       (!cmd_buffer->state.emitted_graphics_pipeline ||
        cmd_buffer->state.emitted_graphics_pipeline->base.shaders[MESA_SHADER_FRAGMENT] !=
           cmd_buffer->state.graphics_pipeline->base.shaders[MESA_SHADER_FRAGMENT]) &&
-      (settings.context_states_per_bin > 1 || settings.persistent_states_per_bin > 1);
+      (settings->context_states_per_bin > 1 || settings->persistent_states_per_bin > 1);
    bool break_for_new_cb_target_mask =
       (cmd_buffer->state.dirty & RADV_CMD_DIRTY_DYNAMIC_COLOR_WRITE_ENABLE) &&
-      settings.context_states_per_bin > 1;
+      settings->context_states_per_bin > 1;
 
    if (!break_for_new_ps && !break_for_new_cb_target_mask)
       return;
diff --git a/src/amd/vulkan/radv_device.c b/src/amd/vulkan/radv_device.c
index a311e65a573f..7ad0053da899 100644
--- a/src/amd/vulkan/radv_device.c
+++ b/src/amd/vulkan/radv_device.c
@@ -657,6 +657,31 @@ radv_physical_device_init_queue_table(struct radv_physical_device *pdevice)
    pdevice->num_queues = idx;
 }
 
+static void
+radv_get_binning_settings(const struct radv_physical_device *pdevice,
+                          struct radv_binning_settings *settings)
+{
+   if (pdevice->rad_info.has_dedicated_vram) {
+      if (pdevice->rad_info.max_render_backends > 4) {
+         settings->context_states_per_bin = 1;
+         settings->persistent_states_per_bin = 1;
+      } else {
+         settings->context_states_per_bin = 3;
+         settings->persistent_states_per_bin = 8;
+      }
+      settings->fpovs_per_batch = 63;
+   } else {
+      /* The context states are affected by the scissor bug. */
+      settings->context_states_per_bin = 6;
+      /* 32 causes hangs for RAVEN. */
+      settings->persistent_states_per_bin = 16;
+      settings->fpovs_per_batch = 63;
+   }
+
+   if (pdevice->rad_info.has_gfx9_scissor_bug)
+      settings->context_states_per_bin = 1;
+}
+
 static VkResult
 radv_physical_device_try_create(struct radv_instance *instance, drmDevicePtr drm_device,
                                 struct radv_physical_device **device_out)
@@ -901,6 +926,7 @@ radv_physical_device_try_create(struct radv_instance *instance, drmDevicePtr drm
 
    ac_get_hs_info(&device->rad_info, &device->hs);
    ac_get_task_info(&device->rad_info, &device->task_info);
+   radv_get_binning_settings(device, &device->binning_settings);
 
    *device_out = device;
 
diff --git a/src/amd/vulkan/radv_pipeline.c b/src/amd/vulkan/radv_pipeline.c
index e153aaadc200..48ed5125143d 100644
--- a/src/amd/vulkan/radv_pipeline.c
+++ b/src/amd/vulkan/radv_pipeline.c
@@ -5288,33 +5288,6 @@ radv_pipeline_init_disabled_binning_state(struct radv_graphics_pipeline *pipelin
    pipeline->binning.pa_sc_binner_cntl_0 = pa_sc_binner_cntl_0;
 }
 
-struct radv_binning_settings
-radv_get_binning_settings(const struct radv_physical_device *pdev)
-{
-   struct radv_binning_settings settings;
-   if (pdev->rad_info.has_dedicated_vram) {
-      if (pdev->rad_info.max_render_backends > 4) {
-         settings.context_states_per_bin = 1;
-         settings.persistent_states_per_bin = 1;
-      } else {
-         settings.context_states_per_bin = 3;
-         settings.persistent_states_per_bin = 8;
-      }
-      settings.fpovs_per_batch = 63;
-   } else {
-      /* The context states are affected by the scissor bug. */
-      settings.context_states_per_bin = 6;
-      /* 32 causes hangs for RAVEN. */
-      settings.persistent_states_per_bin = 16;
-      settings.fpovs_per_batch = 63;
-   }
-
-   if (pdev->rad_info.has_gfx9_scissor_bug)
-      settings.context_states_per_bin = 1;
-
-   return settings;
-}
-
 static void
 radv_pipeline_init_binning_state(struct radv_graphics_pipeline *pipeline,
                                  const struct radv_blend_state *blend,
@@ -5334,17 +5307,17 @@ radv_pipeline_init_binning_state(struct radv_graphics_pipeline *pipeline,
       unreachable("Unhandled generation for binning bin size calculation");
 
    if (device->pbb_allowed && bin_size.width && bin_size.height) {
-      struct radv_binning_settings settings = radv_get_binning_settings(device->physical_device);
+      struct radv_binning_settings *settings = &device->physical_device->binning_settings;
 
       const uint32_t pa_sc_binner_cntl_0 =
          S_028C44_BINNING_MODE(V_028C44_BINNING_ALLOWED) |
          S_028C44_BIN_SIZE_X(bin_size.width == 16) | S_028C44_BIN_SIZE_Y(bin_size.height == 16) |
          S_028C44_BIN_SIZE_X_EXTEND(util_logbase2(MAX2(bin_size.width, 32)) - 5) |
          S_028C44_BIN_SIZE_Y_EXTEND(util_logbase2(MAX2(bin_size.height, 32)) - 5) |
-         S_028C44_CONTEXT_STATES_PER_BIN(settings.context_states_per_bin - 1) |
-         S_028C44_PERSISTENT_STATES_PER_BIN(settings.persistent_states_per_bin - 1) |
+         S_028C44_CONTEXT_STATES_PER_BIN(settings->context_states_per_bin - 1) |
+         S_028C44_PERSISTENT_STATES_PER_BIN(settings->persistent_states_per_bin - 1) |
          S_028C44_DISABLE_START_OF_PRIM(1) |
-         S_028C44_FPOVS_PER_BATCH(settings.fpovs_per_batch) | S_028C44_OPTIMAL_BIN_SELECTION(1);
+         S_028C44_FPOVS_PER_BATCH(settings->fpovs_per_batch) | S_028C44_OPTIMAL_BIN_SELECTION(1);
 
       pipeline->binning.pa_sc_binner_cntl_0 = pa_sc_binner_cntl_0;
    } else
diff --git a/src/amd/vulkan/radv_private.h b/src/amd/vulkan/radv_private.h
index d54d67a28355..b1b7f095ac0a 100644
--- a/src/amd/vulkan/radv_private.h
+++ b/src/amd/vulkan/radv_private.h
@@ -262,6 +262,12 @@ enum radv_queue_family {
 
 struct radv_perfcounter_desc;
 
+struct radv_binning_settings {
+   unsigned context_states_per_bin;    /* allowed range: [1, 6] */
+   unsigned persistent_states_per_bin; /* allowed range: [1, 32] */
+   unsigned fpovs_per_batch;           /* allowed range: [0, 255], 0 = unlimited */
+};
+
 struct radv_physical_device {
    struct vk_physical_device vk;
 
@@ -339,6 +345,8 @@ struct radv_physical_device {
    struct ac_hs_info hs;
    struct ac_task_info task_info;
 
+   struct radv_binning_settings binning_settings;
+
    /* Performance counters. */
    struct ac_perfcounters ac_perfcounters;
 
@@ -2174,14 +2182,6 @@ VkResult radv_compute_pipeline_create(VkDevice _device, VkPipelineCache _cache,
 void radv_pipeline_destroy(struct radv_device *device, struct radv_pipeline *pipeline,
                            const VkAllocationCallbacks *allocator);
 
-struct radv_binning_settings {
-   unsigned context_states_per_bin;    /* allowed range: [1, 6] */
-   unsigned persistent_states_per_bin; /* allowed range: [1, 32] */
-   unsigned fpovs_per_batch;           /* allowed range: [0, 255], 0 = unlimited */
-};
-
-struct radv_binning_settings radv_get_binning_settings(const struct radv_physical_device *pdev);
-
 struct vk_format_description;
 uint32_t radv_translate_buffer_dataformat(const struct util_format_description *desc,
                                           int first_non_void);
-- 
GitLab


From 3661d127dad89170ecb06d3642ed2ad7eb3f69a0 Mon Sep 17 00:00:00 2001
From: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date: Thu, 25 Aug 2022 08:50:37 +0200
Subject: [PATCH 2/2] radv: make sure to emit BREAK_BATCH when color write
 enable is dynamic

Color write enable can change CB_TARGET_MASK and emitting a BREAK_BATCH
seems needed for binning. Though, this was broken if this enable bit
changed dynamically for the same pipeline. Split the function to not
increase CPU overhead.

Found by inspection.

Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
---
 src/amd/vulkan/radv_cmd_buffer.c | 49 ++++++++++++++++----------------
 1 file changed, 25 insertions(+), 24 deletions(-)

diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index df3051725e67..2a79c6f295b6 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -1391,33 +1391,11 @@ radv_emit_rbplus_state(struct radv_cmd_buffer *cmd_buffer)
    cmd_buffer->state.last_sx_blend_opt_control = sx_blend_opt_control;
 }
 
-static void
-radv_emit_batch_break_on_new_ps(struct radv_cmd_buffer *cmd_buffer)
-{
-   if (!cmd_buffer->device->pbb_allowed)
-      return;
-
-   struct radv_binning_settings *settings = &cmd_buffer->device->physical_device->binning_settings;
-   bool break_for_new_ps =
-      (!cmd_buffer->state.emitted_graphics_pipeline ||
-       cmd_buffer->state.emitted_graphics_pipeline->base.shaders[MESA_SHADER_FRAGMENT] !=
-          cmd_buffer->state.graphics_pipeline->base.shaders[MESA_SHADER_FRAGMENT]) &&
-      (settings->context_states_per_bin > 1 || settings->persistent_states_per_bin > 1);
-   bool break_for_new_cb_target_mask =
-      (cmd_buffer->state.dirty & RADV_CMD_DIRTY_DYNAMIC_COLOR_WRITE_ENABLE) &&
-      settings->context_states_per_bin > 1;
-
-   if (!break_for_new_ps && !break_for_new_cb_target_mask)
-      return;
-
-   radeon_emit(cmd_buffer->cs, PKT3(PKT3_EVENT_WRITE, 0, 0));
-   radeon_emit(cmd_buffer->cs, EVENT_TYPE(V_028A90_BREAK_BATCH) | EVENT_INDEX(0));
-}
-
 static void
 radv_emit_graphics_pipeline(struct radv_cmd_buffer *cmd_buffer)
 {
    struct radv_graphics_pipeline *pipeline = cmd_buffer->state.graphics_pipeline;
+   const struct radv_device *device = cmd_buffer->device;
 
    if (cmd_buffer->state.emitted_graphics_pipeline == pipeline)
       return;
@@ -1492,7 +1470,18 @@ radv_emit_graphics_pipeline(struct radv_cmd_buffer *cmd_buffer)
       cmd_buffer->state.context_roll_without_scissor_emitted = true;
    }
 
-   radv_emit_batch_break_on_new_ps(cmd_buffer);
+   if (device->pbb_allowed) {
+      struct radv_binning_settings *settings = &device->physical_device->binning_settings;
+
+      if ((!cmd_buffer->state.emitted_graphics_pipeline ||
+           cmd_buffer->state.emitted_graphics_pipeline->base.shaders[MESA_SHADER_FRAGMENT] !=
+           cmd_buffer->state.graphics_pipeline->base.shaders[MESA_SHADER_FRAGMENT]) &&
+          (settings->context_states_per_bin > 1 || settings->persistent_states_per_bin > 1)) {
+         /* Break the batch on PS changes. */
+         radeon_emit(cmd_buffer->cs, PKT3(PKT3_EVENT_WRITE, 0, 0));
+         radeon_emit(cmd_buffer->cs, EVENT_TYPE(V_028A90_BREAK_BATCH) | EVENT_INDEX(0));
+      }
+   }
 
    radv_cs_add_buffer(cmd_buffer->device->ws, cmd_buffer->cs, pipeline->base.slab_bo);
 
@@ -7454,6 +7443,7 @@ static void
 radv_emit_all_graphics_states(struct radv_cmd_buffer *cmd_buffer, const struct radv_draw_info *info,
                               bool pipeline_is_dirty)
 {
+   const struct radv_device *device = cmd_buffer->device;
    bool late_scissor_emission;
 
    if ((cmd_buffer->state.dirty & RADV_CMD_DIRTY_FRAMEBUFFER) ||
@@ -7506,6 +7496,17 @@ radv_emit_all_graphics_states(struct radv_cmd_buffer *cmd_buffer, const struct r
       }
    }
 
+   if (device->pbb_allowed) {
+      struct radv_binning_settings *settings = &device->physical_device->binning_settings;
+
+      if ((cmd_buffer->state.dirty & RADV_CMD_DIRTY_DYNAMIC_COLOR_WRITE_ENABLE) &&
+          settings->context_states_per_bin > 1) {
+         /* Break the batch on CB_TARGET_MASK changes. */
+         radeon_emit(cmd_buffer->cs, PKT3(PKT3_EVENT_WRITE, 0, 0));
+         radeon_emit(cmd_buffer->cs, EVENT_TYPE(V_028A90_BREAK_BATCH) | EVENT_INDEX(0));
+      }
+   }
+
    radv_cmd_buffer_flush_dynamic_state(cmd_buffer, pipeline_is_dirty);
 
    radv_emit_draw_registers(cmd_buffer, info);
-- 
GitLab

