From fc76be17517f94af77ae7cbae40674aedfe66856 Mon Sep 17 00:00:00 2001
From: Timothy Arceri <tarceri@itsqueeze.com>
Date: Fri, 6 Oct 2023 12:49:54 +1100
Subject: [PATCH 1/3] glsl: add nir based lower_named_interface_blocks()
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

This will be used in the following patch to replace the GLSL IR
version of this pass.

Acked-by: Marek Olšák <marek.olsak@amd.com>
Part-of: <https://gitlab.freedesktop.org/mesa/mesa/-/merge_requests/26001>
---
 src/compiler/glsl/gl_nir.h                    |   2 +
 .../gl_nir_lower_named_interface_blocks.c     | 335 ++++++++++++++++++
 src/compiler/glsl/meson.build                 |   1 +
 3 files changed, 338 insertions(+)
 create mode 100644 src/compiler/glsl/gl_nir_lower_named_interface_blocks.c

diff --git a/src/compiler/glsl/gl_nir.h b/src/compiler/glsl/gl_nir.h
index 245c2a0a09cf0..81159845aff5d 100644
--- a/src/compiler/glsl/gl_nir.h
+++ b/src/compiler/glsl/gl_nir.h
@@ -50,6 +50,8 @@ bool gl_nir_lower_blend_equation_advanced(nir_shader *sh, bool coherent);
 bool gl_nir_lower_buffers(nir_shader *shader,
                           const struct gl_shader_program *shader_program);
 
+void gl_nir_lower_named_interface_blocks(struct gl_shader_program *prog);
+
 void gl_nir_lower_packed_varyings(const struct gl_constants *consts,
                                   struct gl_shader_program *prog,
                                   void *mem_ctx, unsigned locations_used,
diff --git a/src/compiler/glsl/gl_nir_lower_named_interface_blocks.c b/src/compiler/glsl/gl_nir_lower_named_interface_blocks.c
new file mode 100644
index 0000000000000..18bac021a1675
--- /dev/null
+++ b/src/compiler/glsl/gl_nir_lower_named_interface_blocks.c
@@ -0,0 +1,335 @@
+/*
+ * Copyright © 2013 Intel Corporation
+ * Copyright © 2023 Valve Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+/**
+ *
+ * This lowering pass converts all interface blocks with instance names
+ * into interface blocks without an instance name.
+ *
+ * For example, the following shader:
+ *
+ *   out block {
+ *     float block_var;
+ *   } inst_name;
+ *
+ *   main()
+ *   {
+ *     inst_name.block_var = 0.0;
+ *   }
+ *
+ * Is rewritten to:
+ *
+ *   out block {
+ *     float block_var;
+ *   };
+ *
+ *   main()
+ *   {
+ *     block_var = 0.0;
+ *   }
+ *
+ * This takes place after the shader code has already been verified with
+ * the interface name in place.
+ *
+ * The linking phase will use the interface block name rather than the
+ * interface's instance name when linking interfaces.
+ *
+ * This modification to the ir allows our currently existing dead code
+ * elimination to work with interface blocks without changes.
+ */
+
+#include "nir.h"
+#include "nir_builder.h"
+#include "nir_deref.h"
+#include "nir_types.h"
+#include "gl_nir.h"
+
+#include "main/shader_types.h"
+
+struct lower_named_block_state {
+   void *mem_ctx;
+   struct hash_table *interface_namespace;
+};
+
+static const struct glsl_type *
+process_array_type(const struct glsl_type *type, unsigned idx)
+{
+   const struct glsl_type *element_type = glsl_get_array_element(type);
+   unsigned length = glsl_get_length(type);
+   if (glsl_type_is_array(element_type)) {
+      const struct glsl_type *new_array_type =
+         process_array_type(element_type, idx);
+      return  glsl_array_type(new_array_type, length, 0);
+   } else {
+      return glsl_array_type(glsl_get_struct_field(element_type, idx),
+                             length, 0);
+   }
+}
+
+static nir_deref_instr *
+process_derefs(nir_builder *b, nir_deref_instr **p, nir_deref_instr *parent)
+{
+   bool found_ifc = false;
+   for (; *p; p++) {
+      if ((*p)->deref_type == nir_deref_type_array) {
+         parent = nir_build_deref_array(b, parent, (*p)->arr.index.ssa);
+      } else if ((*p)->deref_type == nir_deref_type_struct) {
+         if (!found_ifc) {
+            /* We found the interface block so just skip it */
+            found_ifc = true;
+            continue;
+         } else {
+            parent = nir_build_deref_struct(b, parent, (*p)->strct.index);
+         }
+      }
+   }
+
+   return parent;
+}
+
+/* Disable packing on varyings used by interpolate functions. This must be
+ * called after lowering blocks to avoid disabling packing on the entire
+ * block.
+ */
+static void
+disable_varying_packing_when_used_by_interpolate_functions(nir_intrinsic_instr *intr,
+                                                           nir_variable *var)
+{
+   if (intr->intrinsic == nir_intrinsic_interp_deref_at_centroid ||
+       intr->intrinsic == nir_intrinsic_interp_deref_at_sample ||
+       intr->intrinsic == nir_intrinsic_interp_deref_at_offset) {
+
+      /* This disables varying packing for this input. */
+      var->data.must_be_shader_input = 1;
+   }
+}
+
+static char *
+create_ifc_field_name_str(void *mem_ctx, nir_variable *var,
+                          const struct glsl_type *iface_t, unsigned f_idx)
+{
+   char *iface_field_name =
+      ralloc_asprintf(mem_ctx, "%s %s.%s.%s",
+                      var->data.mode == nir_var_shader_in ? "in" : "out",
+                      glsl_get_type_name(iface_t), var->name,
+                      glsl_get_struct_elem_name(iface_t, f_idx));
+
+   return iface_field_name;
+}
+
+static bool
+flatten_named_interface_deref(void *mem_ctx, nir_builder *b,
+                              nir_deref_instr *deref,
+                              nir_intrinsic_instr *intr,
+                              struct hash_table *interface_namespace,
+                              bool is_src0)
+{
+   nir_variable_mode mask = nir_var_shader_in | nir_var_shader_out;
+
+   if (!nir_deref_mode_is_one_of(deref, mask))
+      return false;
+
+   nir_variable *var = nir_deref_instr_get_variable(deref);
+
+   const struct glsl_type * iface_t = glsl_without_array(var->type);
+   if (iface_t != var->interface_type)
+      return false;
+
+   nir_deref_path path;
+   nir_deref_path_init(&path, deref, NULL);
+
+   assert(path.path[0]->deref_type == nir_deref_type_var);
+   nir_deref_instr **p = &path.path[1];
+
+   char *iface_field_name = NULL;
+   for (; *p; p++) {
+      if ((*p)->deref_type == nir_deref_type_struct) {
+         iface_field_name =
+            create_ifc_field_name_str(mem_ctx, var, iface_t,
+                                      (*p)->strct.index);
+         break;
+      }
+   }
+   assert(iface_field_name);
+
+   /* Find the variable in the set of flattened interface blocks */
+   struct hash_entry *entry =
+      _mesa_hash_table_search(interface_namespace, iface_field_name);
+   assert(entry);
+
+   nir_variable *found_var = (nir_variable *) entry->data;
+
+   if (intr->intrinsic == nir_intrinsic_store_deref ||
+       (intr->intrinsic == nir_intrinsic_copy_deref && is_src0))
+      found_var->data.assigned = 1;
+
+   b->cursor = nir_before_instr(&intr->instr);
+   nir_deref_instr *deref_var = nir_build_deref_var(b, found_var);
+   if (glsl_type_is_array(found_var->type) ||
+       glsl_type_is_struct(found_var->type) ||
+       glsl_type_is_matrix(found_var->type)) {
+      p = &path.path[1];
+      deref_var = process_derefs(b, p, deref_var);
+   }
+
+   disable_varying_packing_when_used_by_interpolate_functions(intr,
+                                                              found_var);
+
+   nir_deref_path_finish(&path);
+
+   nir_def_rewrite_uses(&deref->def, &deref_var->def);
+
+   return true;
+}
+
+static bool
+flatten_named_interface_derefs(nir_builder *b, nir_intrinsic_instr *intr,
+                               void *cb_data)
+{
+   struct lower_named_block_state *state =
+      (struct lower_named_block_state *) cb_data;
+
+   if (intr->intrinsic != nir_intrinsic_copy_deref &&
+       intr->intrinsic != nir_intrinsic_load_deref &&
+       intr->intrinsic != nir_intrinsic_store_deref &&
+       intr->intrinsic != nir_intrinsic_interp_deref_at_centroid &&
+       intr->intrinsic != nir_intrinsic_interp_deref_at_sample &&
+       intr->intrinsic != nir_intrinsic_interp_deref_at_offset &&
+       intr->intrinsic != nir_intrinsic_interp_deref_at_vertex)
+      return false;
+
+   nir_deref_instr *deref = nir_src_as_deref(intr->src[0]);
+   bool progress =
+      flatten_named_interface_deref(state->mem_ctx, b, deref, intr,
+                                    state->interface_namespace, true);
+
+   if (intr->intrinsic == nir_intrinsic_copy_deref) {
+      deref = nir_src_as_deref(intr->src[1]);
+      progress |=
+         flatten_named_interface_deref(state->mem_ctx, b, deref, intr,
+                                       state->interface_namespace, false);
+   }
+
+   return progress;
+}
+
+static void
+lower_named_interface_blocks(struct gl_linked_shader *sh)
+{
+   void *mem_ctx = ralloc_context(NULL);
+
+   struct hash_table *interface_namespace =
+      _mesa_hash_table_create(mem_ctx, _mesa_hash_string,
+                              _mesa_key_string_equal);
+
+   /* First pass: adjust instance block variables with an instance name
+    * to not have an instance name.
+    *
+    * The interface block variables are stored in the interface_namespace
+    * hash table so they can be used in the second pass.
+    */
+   nir_foreach_variable_with_modes_safe(var, sh->Program->nir,
+                                        nir_var_shader_in | nir_var_shader_out) {
+      const struct glsl_type * iface_t = glsl_without_array(var->type);
+      if (iface_t != var->interface_type)
+         continue;
+
+      for (unsigned i = 0; i < iface_t->length; i++) {
+         const char *field_name = glsl_get_struct_elem_name(iface_t, i);
+         char *iface_field_name =
+            create_ifc_field_name_str(mem_ctx, var, iface_t, i);
+
+         struct hash_entry *entry = _mesa_hash_table_search(interface_namespace,
+                                                            iface_field_name);
+         nir_variable *found_var = entry ? (nir_variable *) entry->data : NULL;
+         if (!found_var) {
+            const struct glsl_struct_field *field_data =
+               glsl_get_struct_field_data(iface_t, i);
+
+            nir_variable *new_var = rzalloc(sh->Program->nir, nir_variable);
+            new_var->name = ralloc_strdup(new_var, field_name);
+            if (!glsl_type_is_array(var->type)) {
+               new_var->type =  glsl_get_struct_field(iface_t, i);
+            } else {
+               new_var->type = process_array_type(var->type, i);
+            }
+            new_var->data.mode = var->data.mode;
+            new_var->data.location = field_data->location;
+            new_var->data.location_frac = field_data->component >= 0 ?
+               field_data->component : 0;
+            new_var->data.explicit_location = (new_var->data.location >= 0);
+            new_var->data.offset = field_data->offset;
+            new_var->data.explicit_offset = (field_data->offset >= 0);
+            new_var->data.xfb.buffer = field_data->xfb_buffer;
+            new_var->data.explicit_xfb_buffer = field_data->explicit_xfb_buffer;
+            new_var->data.interpolation = field_data->interpolation;
+            new_var->data.centroid = field_data->centroid;
+            new_var->data.sample = field_data->sample;
+            new_var->data.patch = field_data->patch;
+            new_var->data.stream = var->data.stream;
+            new_var->data.how_declared = var->data.how_declared;
+            new_var->data.from_named_ifc_block = 1;
+
+            new_var->interface_type = var->type;
+            _mesa_hash_table_insert(interface_namespace, iface_field_name,
+                                    new_var);
+
+            nir_shader_add_variable(sh->Program->nir, new_var);
+         }
+      }
+   }
+
+   /* Second pass: redirect dereferences to the new vars. */
+   struct lower_named_block_state state;
+   state.mem_ctx = mem_ctx;
+   state.interface_namespace = interface_namespace;
+   nir_shader_intrinsics_pass(sh->Program->nir, flatten_named_interface_derefs,
+                              nir_metadata_block_index |
+                              nir_metadata_dominance, &state);
+
+   /* Third pass: Mark now lowered blks as ordinary globals to be dead code
+    * eliminated.
+    */
+   nir_foreach_variable_with_modes(var, sh->Program->nir,
+                                   nir_var_shader_in | nir_var_shader_out) {
+      const struct glsl_type * iface_t = glsl_without_array(var->type);
+      if (!(iface_t == var->interface_type))
+         continue;
+
+      var->data.mode = nir_var_shader_temp;
+   }
+   nir_fixup_deref_modes(sh->Program->nir);
+
+   ralloc_free(mem_ctx);
+}
+
+void
+gl_nir_lower_named_interface_blocks(struct gl_shader_program *prog)
+{
+   for (unsigned int i = 0; i < MESA_SHADER_STAGES; i++) {
+      if (prog->_LinkedShaders[i] != NULL)
+         lower_named_interface_blocks(prog->_LinkedShaders[i]);
+   }
+}
+
diff --git a/src/compiler/glsl/meson.build b/src/compiler/glsl/meson.build
index 3c95126834f7a..ee83c000be468 100644
--- a/src/compiler/glsl/meson.build
+++ b/src/compiler/glsl/meson.build
@@ -129,6 +129,7 @@ files_libglsl = files(
   'gl_nir_lower_images.c',
   'gl_nir_lower_blend_equation_advanced.c',
   'gl_nir_lower_buffers.c',
+  'gl_nir_lower_named_interface_blocks.c',
   'gl_nir_lower_packed_varyings.c',
   'gl_nir_lower_samplers.c',
   'gl_nir_lower_samplers_as_deref.c',
-- 
GitLab


From 8b5ec039b25de1b0045f25c9cf23b4ce79eccdbb Mon Sep 17 00:00:00 2001
From: Timothy Arceri <tarceri@itsqueeze.com>
Date: Fri, 6 Oct 2023 12:53:22 +1100
Subject: [PATCH 2/3] glsl: use the nir based lower_named_interface_blocks()
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Because we are now doing the lowering in NIR we need to move the code
that sets the compact flag on some builtin vars out of the glsl to nir
pass.

Acked-by: Marek Olšák <marek.olsak@amd.com>
Part-of: <https://gitlab.freedesktop.org/mesa/mesa/-/merge_requests/26001>
---
 src/compiler/glsl/gl_nir_linker.c             |  2 ++
 .../gl_nir_lower_named_interface_blocks.c     | 36 ++++++++++++++++++-
 src/compiler/glsl/glsl_to_nir.cpp             | 23 ------------
 src/compiler/glsl/linker.cpp                  |  5 ---
 4 files changed, 37 insertions(+), 29 deletions(-)

diff --git a/src/compiler/glsl/gl_nir_linker.c b/src/compiler/glsl/gl_nir_linker.c
index 33e3258d4331b..dddfdc2b5cb3e 100644
--- a/src/compiler/glsl/gl_nir_linker.c
+++ b/src/compiler/glsl/gl_nir_linker.c
@@ -1344,6 +1344,8 @@ gl_nir_link_glsl(const struct gl_constants *consts,
       last = i;
    }
 
+   gl_nir_lower_named_interface_blocks(prog);
+
    /* Validate the inputs of each stage with the output of the preceding
     * stage.
     */
diff --git a/src/compiler/glsl/gl_nir_lower_named_interface_blocks.c b/src/compiler/glsl/gl_nir_lower_named_interface_blocks.c
index 18bac021a1675..6249b4c1186df 100644
--- a/src/compiler/glsl/gl_nir_lower_named_interface_blocks.c
+++ b/src/compiler/glsl/gl_nir_lower_named_interface_blocks.c
@@ -309,10 +309,44 @@ lower_named_interface_blocks(struct gl_linked_shader *sh)
                               nir_metadata_dominance, &state);
 
    /* Third pass: Mark now lowered blks as ordinary globals to be dead code
-    * eliminated.
+    * eliminated. Also use this oppotunity to set the compact flag where
+    * needed now that the default interface block has been lowered away.
     */
    nir_foreach_variable_with_modes(var, sh->Program->nir,
                                    nir_var_shader_in | nir_var_shader_out) {
+
+      if (var->data.mode == nir_var_shader_in) {
+         if (sh->Program->nir->info.stage == MESA_SHADER_TESS_EVAL &&
+             (var->data.location == VARYING_SLOT_TESS_LEVEL_INNER ||
+              var->data.location == VARYING_SLOT_TESS_LEVEL_OUTER)) {
+            var->data.compact =
+               glsl_type_is_scalar(glsl_without_array(var->type));
+         }
+
+         if (sh->Program->nir->info.stage > MESA_SHADER_VERTEX &&
+             var->data.location >= VARYING_SLOT_CLIP_DIST0 &&
+             var->data.location <= VARYING_SLOT_CULL_DIST1) {
+            var->data.compact =
+               glsl_type_is_scalar(glsl_without_array(var->type));
+         }
+      } else {
+         assert(var->data.mode == nir_var_shader_out);
+
+         if (sh->Program->nir->info.stage == MESA_SHADER_TESS_CTRL &&
+             (var->data.location == VARYING_SLOT_TESS_LEVEL_INNER ||
+              var->data.location == VARYING_SLOT_TESS_LEVEL_OUTER)) {
+            var->data.compact =
+               glsl_type_is_scalar(glsl_without_array(var->type));
+         }
+
+         if (sh->Program->nir->info.stage <= MESA_SHADER_GEOMETRY &&
+             var->data.location >= VARYING_SLOT_CLIP_DIST0 &&
+             var->data.location <= VARYING_SLOT_CULL_DIST1) {
+            var->data.compact =
+               glsl_type_is_scalar(glsl_without_array(var->type));
+         }
+      }
+
       const struct glsl_type * iface_t = glsl_without_array(var->type);
       if (!(iface_t == var->interface_type))
          continue;
diff --git a/src/compiler/glsl/glsl_to_nir.cpp b/src/compiler/glsl/glsl_to_nir.cpp
index 51712f3c05830..5109530b4fd37 100644
--- a/src/compiler/glsl/glsl_to_nir.cpp
+++ b/src/compiler/glsl/glsl_to_nir.cpp
@@ -585,34 +585,11 @@ nir_visitor::visit(ir_variable *ir)
          var->data.mode = nir_var_system_value;
       } else {
          var->data.mode = nir_var_shader_in;
-
-         if (shader->info.stage == MESA_SHADER_TESS_EVAL &&
-             (ir->data.location == VARYING_SLOT_TESS_LEVEL_INNER ||
-              ir->data.location == VARYING_SLOT_TESS_LEVEL_OUTER)) {
-            var->data.compact = ir->type->without_array()->is_scalar();
-         }
-
-         if (shader->info.stage > MESA_SHADER_VERTEX &&
-             ir->data.location >= VARYING_SLOT_CLIP_DIST0 &&
-             ir->data.location <= VARYING_SLOT_CULL_DIST1) {
-            var->data.compact = ir->type->without_array()->is_scalar();
-         }
       }
       break;
 
    case ir_var_shader_out:
       var->data.mode = nir_var_shader_out;
-      if (shader->info.stage == MESA_SHADER_TESS_CTRL &&
-          (ir->data.location == VARYING_SLOT_TESS_LEVEL_INNER ||
-           ir->data.location == VARYING_SLOT_TESS_LEVEL_OUTER)) {
-         var->data.compact = ir->type->without_array()->is_scalar();
-      }
-
-      if (shader->info.stage <= MESA_SHADER_GEOMETRY &&
-          ir->data.location >= VARYING_SLOT_CLIP_DIST0 &&
-          ir->data.location <= VARYING_SLOT_CULL_DIST1) {
-         var->data.compact = ir->type->without_array()->is_scalar();
-      }
       break;
 
    case ir_var_uniform:
diff --git a/src/compiler/glsl/linker.cpp b/src/compiler/glsl/linker.cpp
index 262a53ea181f2..a0a7336613c00 100644
--- a/src/compiler/glsl/linker.cpp
+++ b/src/compiler/glsl/linker.cpp
@@ -3116,11 +3116,6 @@ link_shaders(struct gl_context *ctx, struct gl_shader_program *prog)
    if (!prog->data->LinkStatus)
       goto done;
 
-   for (unsigned int i = 0; i < MESA_SHADER_STAGES; i++) {
-      if (prog->_LinkedShaders[i] != NULL)
-         lower_named_interface_blocks(mem_ctx, prog->_LinkedShaders[i]);
-   }
-
    if (prog->IsES && prog->GLSL_Version == 100)
       if (!validate_invariant_builtins(prog,
             prog->_LinkedShaders[MESA_SHADER_VERTEX],
-- 
GitLab


From b0d06fc241e7f9e5594f5266fa542a6236e98160 Mon Sep 17 00:00:00 2001
From: Timothy Arceri <tarceri@itsqueeze.com>
Date: Fri, 6 Oct 2023 12:57:19 +1100
Subject: [PATCH 3/3] glsl: remove GLSL IR lower_named_interface_blocks()
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

We now use a NIR based lowering pass instead.

Acked-by: Marek Olšák <marek.olsak@amd.com>
Part-of: <https://gitlab.freedesktop.org/mesa/mesa/-/merge_requests/26001>
---
 src/compiler/glsl/ir_optimization.h           |   1 -
 .../glsl/lower_named_interface_blocks.cpp     | 323 ------------------
 src/compiler/glsl/meson.build                 |   1 -
 3 files changed, 325 deletions(-)
 delete mode 100644 src/compiler/glsl/lower_named_interface_blocks.cpp

diff --git a/src/compiler/glsl/ir_optimization.h b/src/compiler/glsl/ir_optimization.h
index d768ac0a3d22e..b2ced464a2233 100644
--- a/src/compiler/glsl/ir_optimization.h
+++ b/src/compiler/glsl/ir_optimization.h
@@ -61,7 +61,6 @@ bool lower_packing_builtins(exec_list *instructions,
                             bool has_gpu_shader5,
                             bool has_half_float_packing);
 bool lower_vector_derefs(gl_linked_shader *shader);
-void lower_named_interface_blocks(void *mem_ctx, gl_linked_shader *shader);
 void optimize_dead_builtin_variables(exec_list *instructions,
                                      enum ir_variable_mode other);
 
diff --git a/src/compiler/glsl/lower_named_interface_blocks.cpp b/src/compiler/glsl/lower_named_interface_blocks.cpp
deleted file mode 100644
index 5da389357675d..0000000000000
--- a/src/compiler/glsl/lower_named_interface_blocks.cpp
+++ /dev/null
@@ -1,323 +0,0 @@
-/*
- * Copyright (c) 2013 Intel Corporation
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice (including the next
- * paragraph) shall be included in all copies or substantial portions of the
- * Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- */
-
-/**
- * \file lower_named_interface_blocks.cpp
- *
- * This lowering pass converts all interface blocks with instance names
- * into interface blocks without an instance name.
- *
- * For example, the following shader:
- *
- *   out block {
- *     float block_var;
- *   } inst_name;
- *
- *   main()
- *   {
- *     inst_name.block_var = 0.0;
- *   }
- *
- * Is rewritten to:
- *
- *   out block {
- *     float block_var;
- *   };
- *
- *   main()
- *   {
- *     block_var = 0.0;
- *   }
- *
- * This takes place after the shader code has already been verified with
- * the interface name in place.
- *
- * The linking phase will use the interface block name rather than the
- * interface's instance name when linking interfaces.
- *
- * This modification to the ir allows our currently existing dead code
- * elimination to work with interface blocks without changes.
- */
-
-#include "glsl_symbol_table.h"
-#include "ir.h"
-#include "ir_optimization.h"
-#include "ir_rvalue_visitor.h"
-#include "util/hash_table.h"
-#include "main/shader_types.h"
-
-static const glsl_type *
-process_array_type(const glsl_type *type, unsigned idx)
-{
-   const glsl_type *element_type = type->fields.array;
-   if (element_type->is_array()) {
-      const glsl_type *new_array_type = process_array_type(element_type, idx);
-      return glsl_type::get_array_instance(new_array_type, type->length);
-   } else {
-      return glsl_type::get_array_instance(
-         element_type->fields.structure[idx].type, type->length);
-   }
-}
-
-static ir_rvalue *
-process_array_ir(void * const mem_ctx,
-                 ir_dereference_array *deref_array_prev,
-                 ir_rvalue *deref_var)
-{
-   ir_dereference_array *deref_array =
-      deref_array_prev->array->as_dereference_array();
-
-   if (deref_array == NULL) {
-      return new(mem_ctx) ir_dereference_array(deref_var,
-                                               deref_array_prev->array_index);
-   } else {
-      deref_array = (ir_dereference_array *) process_array_ir(mem_ctx,
-                                                              deref_array,
-                                                              deref_var);
-      return new(mem_ctx) ir_dereference_array(deref_array,
-                                               deref_array_prev->array_index);
-   }
-}
-
-namespace {
-
-class flatten_named_interface_blocks_declarations : public ir_rvalue_visitor
-{
-public:
-   void * const mem_ctx;
-   hash_table *interface_namespace;
-
-   flatten_named_interface_blocks_declarations(void *mem_ctx)
-      : mem_ctx(mem_ctx),
-        interface_namespace(NULL)
-   {
-   }
-
-   void run(exec_list *instructions);
-
-   virtual ir_visitor_status visit_leave(ir_assignment *);
-   virtual ir_visitor_status visit_leave(ir_expression *);
-   virtual void handle_rvalue(ir_rvalue **rvalue);
-};
-
-} /* anonymous namespace */
-
-void
-flatten_named_interface_blocks_declarations::run(exec_list *instructions)
-{
-   interface_namespace = _mesa_hash_table_create(NULL, _mesa_hash_string,
-                                                 _mesa_key_string_equal);
-
-   /* First pass: adjust instance block variables with an instance name
-    * to not have an instance name.
-    *
-    * The interface block variables are stored in the interface_namespace
-    * hash table so they can be used in the second pass.
-    */
-   foreach_in_list_safe(ir_instruction, node, instructions) {
-      ir_variable *var = node->as_variable();
-      if (!var || !var->is_interface_instance())
-         continue;
-
-      /* It should be possible to handle uniforms during this pass,
-       * but, this will require changes to the other uniform block
-       * support code.
-       */
-      if (var->data.mode == ir_var_uniform ||
-          var->data.mode == ir_var_shader_storage)
-         continue;
-
-      const glsl_type * iface_t = var->type->without_array();
-      exec_node *insert_pos = var;
-
-      assert (iface_t->is_interface());
-
-      for (unsigned i = 0; i < iface_t->length; i++) {
-         const char * field_name = iface_t->fields.structure[i].name;
-         char *iface_field_name =
-            ralloc_asprintf(mem_ctx, "%s %s.%s.%s",
-                            var->data.mode == ir_var_shader_in ? "in" : "out",
-                            glsl_get_type_name(iface_t), var->name, field_name);
-
-         hash_entry *entry = _mesa_hash_table_search(interface_namespace,
-                                                     iface_field_name);
-         ir_variable *found_var = entry ? (ir_variable *) entry->data : NULL;
-         if (!found_var) {
-            ir_variable *new_var;
-            char *var_name =
-               ralloc_strdup(mem_ctx, iface_t->fields.structure[i].name);
-            if (!var->type->is_array()) {
-               new_var =
-                  new(mem_ctx) ir_variable(iface_t->fields.structure[i].type,
-                                           var_name,
-                                           (ir_variable_mode) var->data.mode);
-            } else {
-               const glsl_type *new_array_type =
-                  process_array_type(var->type, i);
-               new_var =
-                  new(mem_ctx) ir_variable(new_array_type,
-                                           var_name,
-                                           (ir_variable_mode) var->data.mode);
-            }
-            new_var->data.location = iface_t->fields.structure[i].location;
-            new_var->data.location_frac =
-               iface_t->fields.structure[i].component >= 0 ?
-                  iface_t->fields.structure[i].component : 0;
-            new_var->data.explicit_location = (new_var->data.location >= 0);
-            new_var->data.explicit_component =
-               (iface_t->fields.structure[i].component >= 0);
-            new_var->data.offset = iface_t->fields.structure[i].offset;
-            new_var->data.explicit_xfb_offset =
-               (iface_t->fields.structure[i].offset >= 0);
-            new_var->data.xfb_buffer =
-               iface_t->fields.structure[i].xfb_buffer;
-            new_var->data.explicit_xfb_buffer =
-               iface_t->fields.structure[i].explicit_xfb_buffer;
-            new_var->data.interpolation =
-               iface_t->fields.structure[i].interpolation;
-            new_var->data.centroid = iface_t->fields.structure[i].centroid;
-            new_var->data.sample = iface_t->fields.structure[i].sample;
-            new_var->data.patch = iface_t->fields.structure[i].patch;
-            new_var->data.stream = var->data.stream;
-            new_var->data.how_declared = var->data.how_declared;
-            new_var->data.from_named_ifc_block = 1;
-
-            new_var->init_interface_type(var->type);
-            _mesa_hash_table_insert(interface_namespace, iface_field_name,
-                                    new_var);
-            insert_pos->insert_after(new_var);
-            insert_pos = new_var;
-         }
-      }
-      var->remove();
-   }
-
-   /* Second pass: visit all ir_dereference_record instances, and if they
-    * reference an interface block, then flatten the refererence out.
-    */
-   visit_list_elements(this, instructions);
-   _mesa_hash_table_destroy(interface_namespace, NULL);
-   interface_namespace = NULL;
-}
-
-ir_visitor_status
-flatten_named_interface_blocks_declarations::visit_leave(ir_assignment *ir)
-{
-   ir_dereference_record *lhs_rec = ir->lhs->as_dereference_record();
-
-   ir_variable *lhs_var =  ir->lhs->variable_referenced();
-   if (lhs_var && lhs_var->get_interface_type()) {
-      lhs_var->data.assigned = 1;
-   }
-
-   if (lhs_rec) {
-      ir_rvalue *lhs_rec_tmp = lhs_rec;
-      handle_rvalue(&lhs_rec_tmp);
-      if (lhs_rec_tmp != lhs_rec) {
-         ir->set_lhs(lhs_rec_tmp);
-      }
-
-      ir_variable *lhs_var =  lhs_rec_tmp->variable_referenced();
-      if (lhs_var) {
-         lhs_var->data.assigned = 1;
-      }
-   }
-   return rvalue_visit(ir);
-}
-
-ir_visitor_status
-flatten_named_interface_blocks_declarations::visit_leave(ir_expression *ir)
-{
-   ir_visitor_status status = rvalue_visit(ir);
-
-   if (ir->operation == ir_unop_interpolate_at_centroid ||
-       ir->operation == ir_binop_interpolate_at_offset ||
-       ir->operation == ir_binop_interpolate_at_sample) {
-      const ir_rvalue *val = ir->operands[0];
-
-      /* This disables varying packing for this input. */
-      val->variable_referenced()->data.must_be_shader_input = 1;
-   }
-
-   return status;
-}
-
-void
-flatten_named_interface_blocks_declarations::handle_rvalue(ir_rvalue **rvalue)
-{
-   if (*rvalue == NULL)
-      return;
-
-   ir_dereference_record *ir = (*rvalue)->as_dereference_record();
-   if (ir == NULL)
-      return;
-
-   ir_variable *var = ir->variable_referenced();
-   if (var == NULL)
-      return;
-
-   if (!var->is_interface_instance())
-      return;
-
-   /* It should be possible to handle uniforms during this pass,
-    * but, this will require changes to the other uniform block
-    * support code.
-    */
-   if (var->data.mode == ir_var_uniform || var->data.mode == ir_var_shader_storage)
-      return;
-
-   if (var->get_interface_type() != NULL) {
-      char *iface_field_name =
-         ralloc_asprintf(mem_ctx, "%s %s.%s.%s",
-                         var->data.mode == ir_var_shader_in ? "in" : "out",
-                         glsl_get_type_name(var->get_interface_type()),
-                         var->name,
-                         ir->record->type->fields.structure[ir->field_idx].name);
-
-      /* Find the variable in the set of flattened interface blocks */
-      hash_entry *entry = _mesa_hash_table_search(interface_namespace,
-                                                  iface_field_name);
-      assert(entry);
-      ir_variable *found_var = (ir_variable *) entry->data;
-
-      ir_dereference_variable *deref_var =
-         new(mem_ctx) ir_dereference_variable(found_var);
-
-      ir_dereference_array *deref_array =
-         ir->record->as_dereference_array();
-      if (deref_array != NULL) {
-         *rvalue = process_array_ir(mem_ctx, deref_array,
-                                    (ir_rvalue *)deref_var);
-      } else {
-         *rvalue = deref_var;
-      }
-   }
-}
-
-void
-lower_named_interface_blocks(void *mem_ctx, gl_linked_shader *shader)
-{
-   flatten_named_interface_blocks_declarations v_decl(mem_ctx);
-   v_decl.run(shader->ir);
-}
-
diff --git a/src/compiler/glsl/meson.build b/src/compiler/glsl/meson.build
index ee83c000be468..cdb79ae134e94 100644
--- a/src/compiler/glsl/meson.build
+++ b/src/compiler/glsl/meson.build
@@ -200,7 +200,6 @@ files_libglsl = files(
   'lower_instructions.cpp',
   'lower_jumps.cpp',
   'lower_mat_op_to_vec.cpp',
-  'lower_named_interface_blocks.cpp',
   'lower_packing_builtins.cpp',
   'lower_precision.cpp',
   'lower_subroutine.cpp',
-- 
GitLab

