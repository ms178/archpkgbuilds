From a7f8d97a0adbf8cb68baee2074e6087643522553 Mon Sep 17 00:00:00 2001
From: Timothy Arceri <tarceri@itsqueeze.com>
Date: Tue, 24 Oct 2023 12:34:43 +1100
Subject: [PATCH 1/8] nir: move build_write_masked_stores() to nir builder

We will reused this in the following patch.
---
 src/compiler/nir/nir_builder.h                | 34 ++++++++++++++++
 .../nir/nir_lower_array_deref_of_vec.c        | 40 ++-----------------
 2 files changed, 37 insertions(+), 37 deletions(-)

diff --git a/src/compiler/nir/nir_builder.h b/src/compiler/nir/nir_builder.h
index c9f3465406c10..34603b76bf858 100644
--- a/src/compiler/nir/nir_builder.h
+++ b/src/compiler/nir/nir_builder.h
@@ -1609,6 +1609,40 @@ nir_store_deref(nir_builder *build, nir_deref_instr *deref,
                                (enum gl_access_qualifier)0);
 }
 
+static void
+nir_build_write_masked_store(nir_builder *b, nir_deref_instr *vec_deref,
+                             nir_def *value, unsigned component)
+{
+   assert(value->num_components == 1);
+   unsigned num_components = glsl_get_components(vec_deref->type);
+   assert(num_components > 1 && num_components <= NIR_MAX_VEC_COMPONENTS);
+
+   nir_def *u = nir_undef(b, 1, value->bit_size);
+   nir_def *comps[NIR_MAX_VEC_COMPONENTS];
+   for (unsigned i = 0; i < num_components; i++)
+      comps[i] = (i == component) ? value : u;
+
+   nir_def *vec = nir_vec(b, comps, num_components);
+   nir_store_deref(b, vec_deref, vec, (1u << component));
+}
+
+static void
+nir_build_write_masked_stores(nir_builder *b, nir_deref_instr *vec_deref,
+                              nir_def *value, nir_def *index,
+                              unsigned start, unsigned end)
+{
+   if (start == end - 1) {
+      nir_build_write_masked_store(b, vec_deref, value, start);
+   } else {
+      unsigned mid = start + (end - start) / 2;
+      nir_push_if(b, nir_ilt_imm(b, index, mid));
+      nir_build_write_masked_stores(b, vec_deref, value, index, start, mid);
+      nir_push_else(b, NULL);
+      nir_build_write_masked_stores(b, vec_deref, value, index, mid, end);
+      nir_pop_if(b, NULL);
+   }
+}
+
 static inline void
 nir_copy_deref_with_access(nir_builder *build, nir_deref_instr *dest,
                            nir_deref_instr *src,
diff --git a/src/compiler/nir/nir_lower_array_deref_of_vec.c b/src/compiler/nir/nir_lower_array_deref_of_vec.c
index c5da05798c9e8..2a8549eb8c234 100644
--- a/src/compiler/nir/nir_lower_array_deref_of_vec.c
+++ b/src/compiler/nir/nir_lower_array_deref_of_vec.c
@@ -24,40 +24,6 @@
 #include "nir.h"
 #include "nir_builder.h"
 
-static void
-build_write_masked_store(nir_builder *b, nir_deref_instr *vec_deref,
-                         nir_def *value, unsigned component)
-{
-   assert(value->num_components == 1);
-   unsigned num_components = glsl_get_components(vec_deref->type);
-   assert(num_components > 1 && num_components <= NIR_MAX_VEC_COMPONENTS);
-
-   nir_def *u = nir_undef(b, 1, value->bit_size);
-   nir_def *comps[NIR_MAX_VEC_COMPONENTS];
-   for (unsigned i = 0; i < num_components; i++)
-      comps[i] = (i == component) ? value : u;
-
-   nir_def *vec = nir_vec(b, comps, num_components);
-   nir_store_deref(b, vec_deref, vec, (1u << component));
-}
-
-static void
-build_write_masked_stores(nir_builder *b, nir_deref_instr *vec_deref,
-                          nir_def *value, nir_def *index,
-                          unsigned start, unsigned end)
-{
-   if (start == end - 1) {
-      build_write_masked_store(b, vec_deref, value, start);
-   } else {
-      unsigned mid = start + (end - start) / 2;
-      nir_push_if(b, nir_ilt_imm(b, index, mid));
-      build_write_masked_stores(b, vec_deref, value, index, start, mid);
-      nir_push_else(b, NULL);
-      build_write_masked_stores(b, vec_deref, value, index, mid, end);
-      nir_pop_if(b, NULL);
-   }
-}
-
 static bool
 nir_lower_array_deref_of_vec_impl(nir_function_impl *impl,
                                   nir_variable_mode modes,
@@ -117,14 +83,14 @@ nir_lower_array_deref_of_vec_impl(nir_function_impl *impl,
                 * replace it with anything.
                 */
                if (index < num_components)
-                  build_write_masked_store(&b, vec_deref, value, index);
+                  nir_build_write_masked_store(&b, vec_deref, value, index);
             } else {
                if (!(options & nir_lower_indirect_array_deref_of_vec_store))
                   continue;
 
                nir_def *index = deref->arr.index.ssa;
-               build_write_masked_stores(&b, vec_deref, value, index,
-                                         0, num_components);
+               nir_build_write_masked_stores(&b, vec_deref, value, index,
+                                             0, num_components);
             }
             nir_instr_remove(&intrin->instr);
 
-- 
GitLab


From f4967c007539275980ac41b5fc02f58d937ff9be Mon Sep 17 00:00:00 2001
From: Timothy Arceri <tarceri@itsqueeze.com>
Date: Tue, 17 Oct 2023 09:42:27 +1100
Subject: [PATCH 2/8] glsl/nir: implement a nir based lower distance pass

This is based off the original GLSL IR pass but it is much much
simpler as it doesn't need to do all of the hackery required in
GLSL IR to achieve the lowering.
---
 src/compiler/nir/nir.h                        |   2 +
 .../nir/nir_lower_clip_cull_distance_arrays.c | 365 +++++++++++++++++-
 2 files changed, 362 insertions(+), 5 deletions(-)

diff --git a/src/compiler/nir/nir.h b/src/compiler/nir/nir.h
index 16be72b7376d9..5c95b22c168ea 100644
--- a/src/compiler/nir/nir.h
+++ b/src/compiler/nir/nir.h
@@ -5869,6 +5869,8 @@ bool nir_lower_clip_gs(nir_shader *shader, unsigned ucp_enables,
                        const gl_state_index16 clipplane_state_tokens[][STATE_LENGTH]);
 bool nir_lower_clip_fs(nir_shader *shader, unsigned ucp_enables,
                        bool use_clipdist_array);
+
+void nir_lower_clip_cull_distance_to_vec4s(nir_shader *shader);
 bool nir_lower_clip_cull_distance_arrays(nir_shader *nir);
 bool nir_lower_clip_disable(nir_shader *shader, unsigned clip_plane_enable);
 
diff --git a/src/compiler/nir/nir_lower_clip_cull_distance_arrays.c b/src/compiler/nir/nir_lower_clip_cull_distance_arrays.c
index 4d7b669cdd613..cc2f723f87f4c 100644
--- a/src/compiler/nir/nir_lower_clip_cull_distance_arrays.c
+++ b/src/compiler/nir/nir_lower_clip_cull_distance_arrays.c
@@ -23,16 +23,70 @@
 
 #include "nir.h"
 #include "nir_builder.h"
+#include "nir_deref.h"
 
 /**
- * @file
+ * This file contains two different lowering passes.
  *
- * This pass combines clip and cull distance arrays in separate locations and
- * colocates them both in VARYING_SLOT_CLIP_DIST0.  It does so by maintaining
- * two arrays but making them compact and using location_frac to stack them on
- * top of each other.
+ * 1. nir_lower_clip_cull_distance_arrays()
+ *
+ *    This pass combines clip and cull distance arrays in separate locations
+ *    and colocates them both in VARYING_SLOT_CLIP_DIST0.  It does so by
+ *    maintaining two arrays but making them compact and using location_frac
+ *    to stack them on top of each other.
+ *
+ * 2. nir_lower_clip_cull_distance_to_vec4s()
+ *
+ *    This pass accounts for the difference between the way
+ *    gl_ClipDistance is declared in standard GLSL (as an array of
+ *    floats), and the way it is frequently implemented in hardware (as
+ *    a pair of vec4s, with four clip distances packed into each).
+ *
+ *    The declaration of gl_ClipDistance is replaced with a declaration
+ *    of gl_ClipDistanceMESA, and any references to gl_ClipDistance are
+ *    translated to refer to gl_ClipDistanceMESA with the appropriate
+ *    swizzling of array indices.  For instance:
+ *
+ *      gl_ClipDistance[i]
+ *
+ *    is translated into:
+ *
+ *      gl_ClipDistanceMESA[i>>2][i&3]
  */
 
+#define GLSL_CLIP_VAR_NAME "gl_ClipDistanceMESA"
+
+struct lower_distance_state {
+   /**
+    * Pointer to the declaration of gl_ClipDistance, if found.
+    *
+    * Note:
+    *
+    * - the in_var is for geometry and both tessellation shader inputs only.
+    *
+    * - since gl_ClipDistance is available in tessellation control,
+    *   tessellation evaluation and geometry shaders as both an input
+    *   and an output, it's possible for both old_distance_out_var
+    *   and old_distance_in_var to be non-null.
+    */
+   nir_variable *old_distance_out_var;
+   nir_variable *old_distance_in_var;
+
+   /**
+    * Pointer to the newly-created gl_ClipDistanceMESA variable.
+    */
+   nir_variable *new_distance_out_var;
+   nir_variable *new_distance_in_var;
+
+   /**
+    * Type of shader we are compiling (e.g. MESA_SHADER_VERTEX)
+    */
+   gl_shader_stage shader_stage;
+   const char *in_name;
+   int total_size;
+   int offset;
+};
+
 /**
  * Get the length of the clip/cull distance array, looking past
  * any interface block arrays.
@@ -61,6 +115,307 @@ get_unwrapped_array_length(nir_shader *nir, nir_variable *var)
    return glsl_get_length(type);
 }
 
+/**
+ * Replace any declaration of 'in_name' as an array of floats with a
+ * declaration of gl_ClipDistanceMESA as an array of vec4's.
+ */
+static void
+replace_var_declaration(struct lower_distance_state *state, nir_shader *sh,
+                        nir_variable *var, const char *in_name)
+{
+   nir_variable **old_var;
+   nir_variable **new_var;
+
+   if (!var->name || strcmp(var->name, in_name) != 0)
+      return;
+
+   assert(glsl_type_is_array(var->type));
+   if (var->data.mode == nir_var_shader_out) {
+      if (state->old_distance_out_var)
+         return;
+
+      old_var = &state->old_distance_out_var;
+      new_var = &state->new_distance_out_var;
+   } else if (var->data.mode == nir_var_shader_in) {
+      if (state->old_distance_in_var)
+         return;
+
+      old_var = &state->old_distance_in_var;
+      new_var = &state->new_distance_in_var;
+   } else {
+      unreachable("not reached");
+   }
+
+   *old_var = var;
+
+   if (!(*new_var)) {
+      unsigned new_size = (state->total_size + 3) / 4;
+
+      *new_var = rzalloc(sh, nir_variable);
+      (*new_var)->name = ralloc_strdup(*new_var, GLSL_CLIP_VAR_NAME);
+      (*new_var)->data.mode = var->data.mode;
+      (*new_var)->data.location = VARYING_SLOT_CLIP_DIST0;
+      (*new_var)->data.assigned = true;
+      (*new_var)->data.how_declared = var->data.how_declared;
+
+      nir_shader_add_variable(sh, *new_var);
+
+      if (!glsl_type_is_array(glsl_get_array_element(var->type))) {
+         /* gl_ClipDistance (used for vertex, tessellation evaluation and
+          * geometry output, and fragment input).
+          */
+         assert((var->data.mode == nir_var_shader_in &&
+                 sh->info.stage == MESA_SHADER_FRAGMENT) ||
+                (var->data.mode == nir_var_shader_out &&
+                 (sh->info.stage == MESA_SHADER_VERTEX ||
+                  sh->info.stage == MESA_SHADER_TESS_EVAL ||
+                  sh->info.stage == MESA_SHADER_GEOMETRY)));
+
+         assert(glsl_get_base_type(glsl_get_array_element(var->type)) ==
+                GLSL_TYPE_FLOAT);
+
+         /* And change the properties that we need to change */
+         (*new_var)->type = glsl_array_type(glsl_vec4_type(), new_size, 0);
+      } else {
+         /* 2D gl_ClipDistance (used for tessellation control, tessellation
+          * evaluation and geometry input, and tessellation control output).
+          */
+         assert((var->data.mode == nir_var_shader_in &&
+                 (sh->info.stage == MESA_SHADER_GEOMETRY ||
+                  sh->info.stage == MESA_SHADER_TESS_EVAL)) ||
+                sh->info.stage == MESA_SHADER_TESS_CTRL);
+
+         assert (glsl_get_base_type(glsl_get_array_element(glsl_get_array_element(var->type))) ==
+                 GLSL_TYPE_FLOAT);
+
+         /* And change the properties that we need to change */
+         (*new_var)->type =
+            glsl_array_type(glsl_array_type(glsl_vec4_type(), new_size, 0),
+                            glsl_array_size(var->type), 0);
+      }
+   }
+}
+
+static nir_def *
+interp_deref(nir_builder *b, nir_intrinsic_instr *old_intrin,
+             nir_deref_instr *deref)
+{
+   nir_intrinsic_instr *intrin =
+      nir_intrinsic_instr_create(b->shader, old_intrin->intrinsic);
+   intrin->num_components = 4;
+   intrin->src[0] = nir_src_for_ssa(&deref->def);
+
+   if (intrin->intrinsic == nir_intrinsic_interp_deref_at_offset ||
+       intrin->intrinsic == nir_intrinsic_interp_deref_at_sample)
+      intrin->src[1] = nir_src_for_ssa(old_intrin->src[1].ssa);
+
+   nir_def_init(&intrin->instr, &intrin->def, 4, 32);
+   nir_builder_instr_insert(b, &intrin->instr);
+
+   return &intrin->def;
+}
+
+/* Replace any expression that indexes one of the floats in gl_ClipDistance
+ * with an expression that indexes into one of the vec4's in
+ * gl_ClipDistanceMESA and accesses the appropriate component.
+ */
+static void
+lower_distance_deref(struct lower_distance_state *state, nir_builder *b,
+                     nir_intrinsic_instr *intrin, nir_deref_instr *deref,
+                     nir_variable *new_var)
+{
+   nir_deref_path path;
+   nir_deref_path_init(&path, deref, NULL);
+
+   assert(path.path[0]->deref_type == nir_deref_type_var);
+   nir_deref_instr **p = &path.path[1];
+
+   b->cursor = nir_before_instr(&intrin->instr);
+   nir_deref_instr *deref_var = nir_build_deref_var(b, new_var);
+
+   /* Handle 2D arrays such as Geom shader inputs */
+   if (glsl_type_is_array(glsl_get_array_element(new_var->type))) {
+      assert((*p)->deref_type == nir_deref_type_array);
+      deref_var = nir_build_deref_array(b, deref_var, (*p)->arr.index.ssa);
+      p++;
+   }
+
+   assert((*p)->deref_type == nir_deref_type_array);
+
+   /**
+    * Create the necessary values to index into gl_ClipDistanceMESA based
+    * on the value previously used to index into gl_ClipDistance.
+    *
+    * An array index selects one of the vec4's in gl_ClipDistanceMESA
+    * a swizzle then selects a component within the selected vec4.
+    */
+   nir_src old_index = (*p)->arr.index;
+   if (nir_src_is_const(old_index)) {
+      unsigned const_val = nir_src_as_uint(old_index) + state->offset;
+      unsigned swizzle = const_val % 4;
+
+      nir_deref_instr *def_arr_instr =
+         nir_build_deref_array_imm(b, deref_var, const_val / 4);
+
+      if (intrin->intrinsic == nir_intrinsic_store_deref) {
+         nir_def *value = intrin->src[1].ssa;
+         nir_build_write_masked_store(b, def_arr_instr, value, swizzle);
+      } else {
+         assert(intrin->intrinsic == nir_intrinsic_load_deref ||
+                intrin->intrinsic == nir_intrinsic_interp_deref_at_centroid ||
+                intrin->intrinsic == nir_intrinsic_interp_deref_at_sample ||
+                intrin->intrinsic == nir_intrinsic_interp_deref_at_offset);
+
+         nir_def *load_def;
+         if (intrin->intrinsic == nir_intrinsic_load_deref)
+            load_def = nir_load_deref(b, def_arr_instr);
+         else
+            load_def = interp_deref(b, intrin, def_arr_instr);
+
+         nir_def *swz = nir_channel(b, load_def, swizzle);
+         nir_def_rewrite_uses(&intrin->def, swz);
+      }
+   } else {
+      nir_def *index = nir_iadd_imm(b, old_index.ssa, state->offset);
+      nir_def *swizzle = nir_umod_imm(b, index, 4);
+      index = nir_ishr_imm(b, index, 2); /* index / 4 */
+
+      nir_deref_instr *def_arr_instr =
+         nir_build_deref_array(b, deref_var, index);
+
+      if (intrin->intrinsic == nir_intrinsic_store_deref) {
+         nir_def *value = intrin->src[1].ssa;
+         nir_build_write_masked_stores(b, def_arr_instr, value, swizzle, 0, 4);
+      } else {
+         assert(intrin->intrinsic == nir_intrinsic_load_deref ||
+                intrin->intrinsic == nir_intrinsic_interp_deref_at_centroid ||
+                intrin->intrinsic == nir_intrinsic_interp_deref_at_sample ||
+                intrin->intrinsic == nir_intrinsic_interp_deref_at_offset);
+
+         nir_def *load_def;
+         if (intrin->intrinsic == nir_intrinsic_load_deref)
+            load_def = nir_load_deref(b, def_arr_instr);
+         else
+            load_def = interp_deref(b, intrin, def_arr_instr);
+
+         nir_def *swz = nir_vector_extract(b, load_def, swizzle);
+         nir_def_rewrite_uses(&intrin->def, swz);
+      }
+   }
+
+   nir_deref_path_finish(&path);
+}
+
+static bool
+replace_with_derefs_to_vec4(nir_builder *b, nir_intrinsic_instr *intr,
+                            void *cb_data)
+{
+   struct lower_distance_state *state =
+      (struct lower_distance_state *) cb_data;
+   nir_variable_mode mask = nir_var_shader_in | nir_var_shader_out;
+
+   /* Copy deref lowering is expected to happen before we get here */
+   assert(intr->intrinsic != nir_intrinsic_copy_deref);
+   assert(intr->intrinsic != nir_intrinsic_interp_deref_at_vertex);
+
+   if (intr->intrinsic != nir_intrinsic_load_deref &&
+       intr->intrinsic != nir_intrinsic_store_deref &&
+       intr->intrinsic != nir_intrinsic_interp_deref_at_centroid &&
+       intr->intrinsic != nir_intrinsic_interp_deref_at_sample &&
+       intr->intrinsic != nir_intrinsic_interp_deref_at_offset)
+      return false;
+
+   nir_deref_instr *deref = nir_src_as_deref(intr->src[0]);
+   if (!nir_deref_mode_is_one_of(deref, mask))
+      return false;
+
+   nir_variable *var = nir_deref_instr_get_variable(deref);
+
+   if (var->data.mode == nir_var_shader_out &&
+      var != state->old_distance_out_var)
+      return false;
+
+   if (var->data.mode == nir_var_shader_in &&
+       var != state->old_distance_in_var)
+      return false;
+
+   nir_variable *new_var = var->data.mode == nir_var_shader_in ?
+      state->new_distance_in_var : state->new_distance_out_var;
+
+   lower_distance_deref(state, b, intr, deref, new_var);
+
+   return true;
+}
+
+static void
+lower_distance_to_vec4(nir_shader *shader, struct lower_distance_state *state)
+{
+   /* Replace declarations */
+   nir_foreach_variable_with_modes_safe(var, shader,
+                                        nir_var_shader_in | nir_var_shader_out) {
+      replace_var_declaration(state, shader, var, state->in_name);
+   }
+
+   if (!state->old_distance_in_var && !state->old_distance_out_var)
+      return;
+
+   /* Replace derefs */
+   nir_shader_intrinsics_pass(shader, replace_with_derefs_to_vec4,
+                              nir_metadata_block_index |
+                              nir_metadata_dominance, state);
+
+   /* Mark now lowered vars as ordinary globals to be dead code eliminated.
+    * Also clear the compact flag to avoid issues with validation.
+    */
+   if (state->old_distance_out_var) {
+      state->old_distance_out_var->data.mode = nir_var_shader_temp;
+      state->old_distance_out_var->data.compact = false;
+   }
+
+   if (state->old_distance_in_var) {
+      state->old_distance_in_var->data.mode = nir_var_shader_temp;
+      state->old_distance_in_var->data.compact = false;
+   }
+}
+
+void
+nir_lower_clip_cull_distance_to_vec4s(nir_shader *shader)
+{
+   int clip_size = 0;
+   int cull_size = 0;
+
+   nir_variable_mode mode = nir_var_shader_in | nir_var_shader_out;
+   nir_foreach_variable_with_modes(var, shader, mode) {
+      if (var->data.location == VARYING_SLOT_CLIP_DIST0)
+         clip_size = MAX2(clip_size, get_unwrapped_array_length(shader, var));
+
+      if (var->data.location == VARYING_SLOT_CULL_DIST0)
+         cull_size = MAX2(cull_size, get_unwrapped_array_length(shader, var));
+   }
+
+   if (clip_size == 0 && cull_size == 0)
+      return;
+
+   struct lower_distance_state state;
+   state.old_distance_out_var = NULL;
+   state.old_distance_in_var = NULL;
+   state.new_distance_out_var = NULL;
+   state.new_distance_in_var = NULL;
+   state.shader_stage = shader->info.stage;
+   state.in_name = "gl_ClipDistance";
+   state.total_size = clip_size + cull_size;
+   state.offset = 0;
+   lower_distance_to_vec4(shader, &state);
+
+   state.old_distance_out_var = NULL;
+   state.old_distance_in_var = NULL;
+   state.in_name ="gl_CullDistance";
+   state.offset = clip_size;
+   lower_distance_to_vec4(shader, &state);
+
+   nir_fixup_deref_modes(shader);
+}
+
 static bool
 combine_clip_cull(nir_shader *nir,
                   nir_variable_mode mode,
-- 
GitLab


From 3054d99d3ab59b692016236d1c90797911c82068 Mon Sep 17 00:00:00 2001
From: Timothy Arceri <tarceri@itsqueeze.com>
Date: Wed, 18 Oct 2023 14:22:57 +1100
Subject: [PATCH 3/8] glsl: switch to NIR distance lowering pass

---
 src/compiler/glsl/gl_nir_linker.c | 4 ++++
 src/compiler/glsl/linker.cpp      | 4 ----
 2 files changed, 4 insertions(+), 4 deletions(-)

diff --git a/src/compiler/glsl/gl_nir_linker.c b/src/compiler/glsl/gl_nir_linker.c
index e6a1e882d70d1..33e3258d4331b 100644
--- a/src/compiler/glsl/gl_nir_linker.c
+++ b/src/compiler/glsl/gl_nir_linker.c
@@ -1125,6 +1125,10 @@ prelink_lowering(const struct gl_constants *consts,
       opt_access_options.is_vulkan = false;
       NIR_PASS_V(nir, nir_opt_access, &opt_access_options);
 
+      if (consts->ShaderCompilerOptions[i].LowerCombinedClipCullDistance) {
+         NIR_PASS_V(nir, nir_lower_clip_cull_distance_to_vec4s);
+      }
+
       /* Combine clip and cull outputs into one array and set:
        * - shader_info::clip_distance_array_size
        * - shader_info::cull_distance_array_size
diff --git a/src/compiler/glsl/linker.cpp b/src/compiler/glsl/linker.cpp
index 148aab0be40f3..262a53ea181f2 100644
--- a/src/compiler/glsl/linker.cpp
+++ b/src/compiler/glsl/linker.cpp
@@ -3155,10 +3155,6 @@ link_shaders(struct gl_context *ctx, struct gl_shader_program *prog)
       detect_recursion_linked(prog, prog->_LinkedShaders[i]->ir);
       if (!prog->data->LinkStatus)
          goto done;
-
-      if (consts->ShaderCompilerOptions[i].LowerCombinedClipCullDistance) {
-         lower_clip_cull_distance(prog, prog->_LinkedShaders[i]);
-      }
    }
 
    /* Check and validate stream emissions in geometry shaders */
-- 
GitLab


From a034ca4b6372179e31ae4f08b172cc4668c0a627 Mon Sep 17 00:00:00 2001
From: Timothy Arceri <tarceri@itsqueeze.com>
Date: Tue, 24 Oct 2023 10:41:38 +1100
Subject: [PATCH 4/8] glsl: remove now unused lower distance pass

This has been replaced with a NIR based pass.
---
 src/compiler/glsl/ir_optimization.h  |   2 -
 src/compiler/glsl/lower_distance.cpp | 686 ---------------------------
 src/compiler/glsl/meson.build        |   1 -
 3 files changed, 689 deletions(-)
 delete mode 100644 src/compiler/glsl/lower_distance.cpp

diff --git a/src/compiler/glsl/ir_optimization.h b/src/compiler/glsl/ir_optimization.h
index 56370a7b41258..d768ac0a3d22e 100644
--- a/src/compiler/glsl/ir_optimization.h
+++ b/src/compiler/glsl/ir_optimization.h
@@ -56,8 +56,6 @@ bool do_vec_index_to_cond_assign(exec_list *instructions);
 void lower_discard_flow(exec_list *instructions);
 bool lower_instructions(exec_list *instructions,
                         bool have_gpu_shader5);
-bool lower_clip_cull_distance(struct gl_shader_program *prog,
-                              gl_linked_shader *shader);
 bool lower_packing_builtins(exec_list *instructions,
                             bool has_shading_language_packing,
                             bool has_gpu_shader5,
diff --git a/src/compiler/glsl/lower_distance.cpp b/src/compiler/glsl/lower_distance.cpp
deleted file mode 100644
index a91c58cf5d5f1..0000000000000
--- a/src/compiler/glsl/lower_distance.cpp
+++ /dev/null
@@ -1,686 +0,0 @@
-/*
- * Copyright Â© 2011 Intel Corporation
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice (including the next
- * paragraph) shall be included in all copies or substantial portions of the
- * Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- */
-
-/**
- * \file lower_distance.cpp
- *
- * This pass accounts for the difference between the way
- * gl_ClipDistance is declared in standard GLSL (as an array of
- * floats), and the way it is frequently implemented in hardware (as
- * a pair of vec4s, with four clip distances packed into each).
- *
- * The declaration of gl_ClipDistance is replaced with a declaration
- * of gl_ClipDistanceMESA, and any references to gl_ClipDistance are
- * translated to refer to gl_ClipDistanceMESA with the appropriate
- * swizzling of array indices.  For instance:
- *
- *   gl_ClipDistance[i]
- *
- * is translated into:
- *
- *   gl_ClipDistanceMESA[i>>2][i&3]
- *
- * Since some hardware may not internally represent gl_ClipDistance as a pair
- * of vec4's, this lowering pass is optional.  To enable it, set the
- * LowerCombinedClipCullDistance flag in gl_shader_compiler_options to true.
- */
-
-#include "main/macros.h"
-#include "glsl_symbol_table.h"
-#include "ir_rvalue_visitor.h"
-#include "ir.h"
-#include "program/prog_instruction.h" /* For WRITEMASK_* */
-#include "main/shader_types.h"
-
-#define GLSL_CLIP_VAR_NAME "gl_ClipDistanceMESA"
-
-namespace {
-
-class lower_distance_visitor : public ir_rvalue_visitor {
-public:
-   explicit lower_distance_visitor(gl_shader_stage shader_stage,
-                                   const char *in_name, int total_size,
-                                   int offset)
-      : progress(false), old_distance_out_var(NULL),
-        old_distance_in_var(NULL), new_distance_out_var(NULL),
-        new_distance_in_var(NULL), shader_stage(shader_stage),
-        in_name(in_name), total_size(total_size), offset(offset)
-   {
-   }
-
-   explicit lower_distance_visitor(gl_shader_stage shader_stage,
-                                   const char *in_name,
-                                   const lower_distance_visitor *orig,
-                                   int offset)
-      : progress(false),
-        old_distance_out_var(NULL),
-        old_distance_in_var(NULL),
-        new_distance_out_var(orig->new_distance_out_var),
-        new_distance_in_var(orig->new_distance_in_var),
-        shader_stage(shader_stage),
-        in_name(in_name),
-        total_size(orig->total_size),
-        offset(offset)
-   {
-   }
-
-   virtual ir_visitor_status visit(ir_variable *);
-   void create_indices(ir_rvalue*, ir_rvalue *&, ir_rvalue *&);
-   bool is_distance_vec8(ir_rvalue *ir);
-   ir_rvalue *lower_distance_vec8(ir_rvalue *ir);
-   virtual ir_visitor_status visit_leave(ir_assignment *);
-   void visit_new_assignment(ir_assignment *ir);
-   virtual ir_visitor_status visit_leave(ir_call *);
-
-   virtual void handle_rvalue(ir_rvalue **rvalue);
-
-   void fix_lhs(ir_assignment *);
-
-   bool progress;
-
-   /**
-    * Pointer to the declaration of gl_ClipDistance, if found.
-    *
-    * Note:
-    *
-    * - the in_var is for geometry and both tessellation shader inputs only.
-    *
-    * - since gl_ClipDistance is available in tessellation control,
-    *   tessellation evaluation and geometry shaders as both an input
-    *   and an output, it's possible for both old_distance_out_var
-    *   and old_distance_in_var to be non-null.
-    */
-   ir_variable *old_distance_out_var;
-   ir_variable *old_distance_in_var;
-
-   /**
-    * Pointer to the newly-created gl_ClipDistanceMESA variable.
-    */
-   ir_variable *new_distance_out_var;
-   ir_variable *new_distance_in_var;
-
-   /**
-    * Type of shader we are compiling (e.g. MESA_SHADER_VERTEX)
-    */
-   const gl_shader_stage shader_stage;
-   const char *in_name;
-   int total_size;
-   int offset;
-};
-
-} /* anonymous namespace */
-
-/**
- * Replace any declaration of 'in_name' as an array of floats with a
- * declaration of gl_ClipDistanceMESA as an array of vec4's.
- */
-ir_visitor_status
-lower_distance_visitor::visit(ir_variable *ir)
-{
-   ir_variable **old_var;
-   ir_variable **new_var;
-
-   if (!ir->name || strcmp(ir->name, in_name) != 0)
-      return visit_continue;
-   assert (ir->type->is_array());
-
-   if (ir->data.mode == ir_var_shader_out) {
-      if (this->old_distance_out_var)
-         return visit_continue;
-      old_var = &old_distance_out_var;
-      new_var = &new_distance_out_var;
-   } else if (ir->data.mode == ir_var_shader_in) {
-      if (this->old_distance_in_var)
-         return visit_continue;
-      old_var = &old_distance_in_var;
-      new_var = &new_distance_in_var;
-   } else {
-      unreachable("not reached");
-   }
-
-   this->progress = true;
-
-   *old_var = ir;
-
-   if (!(*new_var)) {
-      unsigned new_size = (total_size + 3) / 4;
-
-      /* Clone the old var so that we inherit all of its properties */
-      *new_var = ir->clone(ralloc_parent(ir), NULL);
-      (*new_var)->name = ralloc_strdup(*new_var, GLSL_CLIP_VAR_NAME);
-      (*new_var)->data.location = VARYING_SLOT_CLIP_DIST0;
-      (*new_var)->data.assigned = true;
-
-      if (!ir->type->fields.array->is_array()) {
-         /* gl_ClipDistance (used for vertex, tessellation evaluation and
-          * geometry output, and fragment input).
-          */
-         assert((ir->data.mode == ir_var_shader_in &&
-                 this->shader_stage == MESA_SHADER_FRAGMENT) ||
-                (ir->data.mode == ir_var_shader_out &&
-                 (this->shader_stage == MESA_SHADER_VERTEX ||
-                  this->shader_stage == MESA_SHADER_TESS_EVAL ||
-                  this->shader_stage == MESA_SHADER_GEOMETRY)));
-
-         assert (ir->type->fields.array == glsl_type::float_type);
-         (*new_var)->data.max_array_access = new_size - 1;
-
-         /* And change the properties that we need to change */
-         (*new_var)->type = glsl_type::get_array_instance(glsl_type::vec4_type,
-                                                          new_size);
-      } else {
-         /* 2D gl_ClipDistance (used for tessellation control, tessellation
-          * evaluation and geometry input, and tessellation control output).
-          */
-         assert((ir->data.mode == ir_var_shader_in &&
-                 (this->shader_stage == MESA_SHADER_GEOMETRY ||
-                  this->shader_stage == MESA_SHADER_TESS_EVAL)) ||
-                this->shader_stage == MESA_SHADER_TESS_CTRL);
-
-         assert (ir->type->fields.array->fields.array == glsl_type::float_type);
-
-         /* And change the properties that we need to change */
-         (*new_var)->type = glsl_type::get_array_instance(
-                            glsl_type::get_array_instance(glsl_type::vec4_type,
-                                                          new_size),
-                            ir->type->array_size());
-      }
-      ir->replace_with(*new_var);
-   } else {
-      ir->remove();
-   }
-
-   return visit_continue;
-}
-
-
-/**
- * Create the necessary GLSL rvalues to index into gl_ClipDistanceMESA based
- * on the rvalue previously used to index into gl_ClipDistance.
- *
- * \param array_index Selects one of the vec4's in gl_ClipDistanceMESA
- * \param swizzle_index Selects a component within the vec4 selected by
- *        array_index.
- */
-void
-lower_distance_visitor::create_indices(ir_rvalue *old_index,
-                                            ir_rvalue *&array_index,
-                                            ir_rvalue *&swizzle_index)
-{
-   void *ctx = ralloc_parent(old_index);
-
-   /* Make sure old_index is a signed int so that the bitwise "shift" and
-    * "and" operations below type check properly.
-    */
-   if (old_index->type != glsl_type::int_type) {
-      assert (old_index->type == glsl_type::uint_type);
-      old_index = new(ctx) ir_expression(ir_unop_u2i, old_index);
-   }
-
-   ir_constant *old_index_constant =
-      old_index->constant_expression_value(ctx);
-   if (old_index_constant) {
-      /* gl_ClipDistance is being accessed via a constant index.  Don't bother
-       * creating expressions to calculate the lowered indices.  Just create
-       * constants.
-       */
-      int const_val = old_index_constant->get_int_component(0) + offset;
-      array_index = new(ctx) ir_constant(const_val / 4);
-      swizzle_index = new(ctx) ir_constant(const_val % 4);
-   } else {
-      /* Create a variable to hold the value of old_index (so that we
-       * don't compute it twice).
-       */
-      ir_variable *old_index_var = new(ctx) ir_variable(
-         glsl_type::int_type, "distance_index", ir_var_temporary);
-      this->base_ir->insert_before(old_index_var);
-      this->base_ir->insert_before(new(ctx) ir_assignment(
-         new(ctx) ir_dereference_variable(old_index_var), old_index));
-
-      /* Create the expression distance_index / 4.  Do this as a bit
-       * shift because that's likely to be more efficient.
-       */
-      array_index = new(ctx) ir_expression(
-         ir_binop_rshift,
-         new(ctx) ir_expression(ir_binop_add,
-                                new(ctx) ir_dereference_variable(old_index_var),
-                                new(ctx) ir_constant(offset)),
-         new(ctx) ir_constant(2));
-
-      /* Create the expression distance_index % 4.  Do this as a bitwise
-       * AND because that's likely to be more efficient.
-       */
-      swizzle_index = new(ctx) ir_expression(
-         ir_binop_bit_and,
-         new(ctx) ir_expression(ir_binop_add,
-                                new(ctx) ir_dereference_variable(old_index_var),
-                                new(ctx) ir_constant(offset)),
-         new(ctx) ir_constant(3));
-   }
-}
-
-
-/**
- * Determine whether the given rvalue describes an array of 8 floats that
- * needs to be lowered to an array of 2 vec4's; that is, determine whether it
- * matches one of the following patterns:
- *
- * - gl_ClipDistance (if gl_ClipDistance is 1D)
- * - gl_ClipDistance[i] (if gl_ClipDistance is 2D)
- */
-bool
-lower_distance_visitor::is_distance_vec8(ir_rvalue *ir)
-{
-   /* Note that geometry shaders contain gl_ClipDistance both as an input
-    * (which is a 2D array) and an output (which is a 1D array), so it's
-    * possible for both this->old_distance_out_var and
-    * this->old_distance_in_var to be non-NULL in the same shader.
-    */
-
-   if (!ir->type->is_array())
-      return false;
-   if (ir->type->fields.array != glsl_type::float_type)
-      return false;
-
-   if (this->old_distance_out_var) {
-      if (ir->variable_referenced() == this->old_distance_out_var)
-         return true;
-   }
-   if (this->old_distance_in_var) {
-      assert(this->shader_stage == MESA_SHADER_TESS_CTRL ||
-             this->shader_stage == MESA_SHADER_TESS_EVAL ||
-             this->shader_stage == MESA_SHADER_GEOMETRY ||
-             this->shader_stage == MESA_SHADER_FRAGMENT);
-
-      if (ir->variable_referenced() == this->old_distance_in_var)
-         return true;
-   }
-   return false;
-}
-
-
-/**
- * If the given ir satisfies is_distance_vec8(), return new ir
- * representing its lowered equivalent.  That is, map:
- *
- * - gl_ClipDistance    => gl_ClipDistanceMESA    (if gl_ClipDistance is 1D)
- * - gl_ClipDistance[i] => gl_ClipDistanceMESA[i] (if gl_ClipDistance is 2D)
- *
- * Otherwise return NULL.
- */
-ir_rvalue *
-lower_distance_visitor::lower_distance_vec8(ir_rvalue *ir)
-{
-   if (!ir->type->is_array())
-      return NULL;
-   if (ir->type->fields.array != glsl_type::float_type)
-      return NULL;
-
-   ir_variable **new_var = NULL;
-   if (this->old_distance_out_var) {
-      if (ir->variable_referenced() == this->old_distance_out_var)
-         new_var = &this->new_distance_out_var;
-   }
-   if (this->old_distance_in_var) {
-      if (ir->variable_referenced() == this->old_distance_in_var)
-         new_var = &this->new_distance_in_var;
-   }
-   if (new_var == NULL)
-      return NULL;
-
-   if (ir->as_dereference_variable()) {
-      return new(ralloc_parent(ir)) ir_dereference_variable(*new_var);
-   } else {
-      ir_dereference_array *array_ref = ir->as_dereference_array();
-      assert(array_ref);
-      assert(array_ref->array->as_dereference_variable());
-
-      return new(ralloc_parent(ir))
-         ir_dereference_array(*new_var, array_ref->array_index);
-   }
-}
-
-
-void
-lower_distance_visitor::handle_rvalue(ir_rvalue **rv)
-{
-   if (*rv == NULL)
-      return;
-
-   ir_dereference_array *const array_deref = (*rv)->as_dereference_array();
-   if (array_deref == NULL)
-      return;
-
-   /* Replace any expression that indexes one of the floats in gl_ClipDistance
-    * with an expression that indexes into one of the vec4's in
-    * gl_ClipDistanceMESA and accesses the appropriate component.
-    */
-   ir_rvalue *lowered_vec8 =
-      this->lower_distance_vec8(array_deref->array);
-   if (lowered_vec8 != NULL) {
-      this->progress = true;
-      ir_rvalue *array_index;
-      ir_rvalue *swizzle_index;
-      this->create_indices(array_deref->array_index, array_index, swizzle_index);
-      void *mem_ctx = ralloc_parent(array_deref);
-
-      ir_dereference_array *const new_array_deref =
-         new(mem_ctx) ir_dereference_array(lowered_vec8, array_index);
-
-      ir_expression *const expr =
-         new(mem_ctx) ir_expression(ir_binop_vector_extract,
-                                    new_array_deref,
-                                    swizzle_index);
-
-      *rv = expr;
-   }
-}
-
-void
-lower_distance_visitor::fix_lhs(ir_assignment *ir)
-{
-   if (ir->lhs->ir_type == ir_type_expression) {
-      void *mem_ctx = ralloc_parent(ir);
-      ir_expression *const expr = (ir_expression *) ir->lhs;
-
-      /* The expression must be of the form:
-       *
-       *     (vector_extract gl_ClipDistanceMESA[i], j).
-       */
-      assert(expr->operation == ir_binop_vector_extract);
-      assert(expr->operands[0]->ir_type == ir_type_dereference_array);
-      assert(expr->operands[0]->type == glsl_type::vec4_type);
-
-      ir_dereference *const new_lhs = (ir_dereference *) expr->operands[0];
-      ir->rhs = new(mem_ctx) ir_expression(ir_triop_vector_insert,
-                                           glsl_type::vec4_type,
-                                           new_lhs->clone(mem_ctx, NULL),
-                                           ir->rhs,
-                                           expr->operands[1]);
-      ir->set_lhs(new_lhs);
-      ir->write_mask = WRITEMASK_XYZW;
-   }
-}
-
-/**
- * Replace any assignment having the 1D gl_ClipDistance (undereferenced) as
- * its LHS or RHS with a sequence of assignments, one for each component of
- * the array.  Each of these assignments is lowered to refer to
- * gl_ClipDistanceMESA as appropriate.
- *
- * We need to do a similar replacement for 2D gl_ClipDistance, however since
- * it's an input, the only case we need to address is where a 1D slice of it
- * is the entire RHS of an assignment, e.g.:
- *
- *     foo = gl_in[i].gl_ClipDistance
- */
-ir_visitor_status
-lower_distance_visitor::visit_leave(ir_assignment *ir)
-{
-   /* First invoke the base class visitor.  This causes handle_rvalue() to be
-    * called on ir->rhs and ir->condition.
-    */
-   ir_rvalue_visitor::visit_leave(ir);
-
-   if (this->is_distance_vec8(ir->lhs) ||
-       this->is_distance_vec8(ir->rhs)) {
-      /* LHS or RHS of the assignment is the entire 1D gl_ClipDistance array
-       * (or a 1D slice of a 2D gl_ClipDistance input array).  Since we are
-       * reshaping gl_ClipDistance from an array of floats to an array of
-       * vec4's, this isn't going to work as a bulk assignment anymore, so
-       * unroll it to element-by-element assignments and lower each of them.
-       *
-       * Note: to unroll into element-by-element assignments, we need to make
-       * clones of the LHS and RHS.  This is safe because expressions and
-       * l-values are side-effect free.
-       */
-      void *ctx = ralloc_parent(ir);
-      int array_size = ir->lhs->type->array_size();
-      for (int i = 0; i < array_size; ++i) {
-         ir_dereference_array *new_lhs = new(ctx) ir_dereference_array(
-            ir->lhs->clone(ctx, NULL), new(ctx) ir_constant(i));
-         ir_dereference_array *new_rhs = new(ctx) ir_dereference_array(
-            ir->rhs->clone(ctx, NULL), new(ctx) ir_constant(i));
-         this->handle_rvalue((ir_rvalue **) &new_rhs);
-
-         /* Handle the LHS after creating the new assignment.  This must
-          * happen in this order because handle_rvalue may replace the old LHS
-          * with an ir_expression of ir_binop_vector_extract.  Since this is
-          * not a valide l-value, this will cause an assertion in the
-          * ir_assignment constructor to fail.
-          *
-          * If this occurs, replace the mangled LHS with a dereference of the
-          * vector, and replace the RHS with an ir_triop_vector_insert.
-          */
-         ir_assignment *const assign = new(ctx) ir_assignment(new_lhs, new_rhs);
-         this->handle_rvalue((ir_rvalue **) &assign->lhs);
-         this->fix_lhs(assign);
-
-         this->base_ir->insert_before(assign);
-      }
-      ir->remove();
-
-      return visit_continue;
-   }
-
-   /* Handle the LHS as if it were an r-value.  Normally
-    * rvalue_visit(ir_assignment *) only visits the RHS, but we need to lower
-    * expressions in the LHS as well.
-    *
-    * This may cause the LHS to get replaced with an ir_expression of
-    * ir_binop_vector_extract.  If this occurs, replace it with a dereference
-    * of the vector, and replace the RHS with an ir_triop_vector_insert.
-    */
-   handle_rvalue((ir_rvalue **)&ir->lhs);
-   this->fix_lhs(ir);
-
-   return rvalue_visit(ir);
-}
-
-
-/**
- * Set up base_ir properly and call visit_leave() on a newly created
- * ir_assignment node.  This is used in cases where we have to insert an
- * ir_assignment in a place where we know the hierarchical visitor won't see
- * it.
- */
-void
-lower_distance_visitor::visit_new_assignment(ir_assignment *ir)
-{
-   ir_instruction *old_base_ir = this->base_ir;
-   this->base_ir = ir;
-   ir->accept(this);
-   this->base_ir = old_base_ir;
-}
-
-
-/**
- * If a 1D gl_ClipDistance variable appears as an argument in an ir_call
- * expression, replace it with a temporary variable, and make sure the ir_call
- * is preceded and/or followed by assignments that copy the contents of the
- * temporary variable to and/or from gl_ClipDistance.  Each of these
- * assignments is then lowered to refer to gl_ClipDistanceMESA.
- *
- * We need to do a similar replacement for 2D gl_ClipDistance, however since
- * it's an input, the only case we need to address is where a 1D slice of it
- * is passed as an "in" parameter to an ir_call, e.g.:
- *
- *     foo(gl_in[i].gl_ClipDistance)
- */
-ir_visitor_status
-lower_distance_visitor::visit_leave(ir_call *ir)
-{
-   void *ctx = ralloc_parent(ir);
-
-   const exec_node *formal_param_node = ir->callee->parameters.get_head_raw();
-   const exec_node *actual_param_node = ir->actual_parameters.get_head_raw();
-   while (!actual_param_node->is_tail_sentinel()) {
-      ir_variable *formal_param = (ir_variable *) formal_param_node;
-      ir_rvalue *actual_param = (ir_rvalue *) actual_param_node;
-
-      /* Advance formal_param_node and actual_param_node now so that we can
-       * safely replace actual_param with another node, if necessary, below.
-       */
-      formal_param_node = formal_param_node->next;
-      actual_param_node = actual_param_node->next;
-
-      if (this->is_distance_vec8(actual_param)) {
-         /* User is trying to pass the whole 1D gl_ClipDistance array (or a 1D
-          * slice of a 2D gl_ClipDistance array) to a function call.  Since we
-          * are reshaping gl_ClipDistance from an array of floats to an array
-          * of vec4's, this isn't going to work anymore, so use a temporary
-          * array instead.
-          */
-         ir_variable *temp_clip_distance = new(ctx) ir_variable(
-            actual_param->type, "temp_clip_distance", ir_var_temporary);
-         this->base_ir->insert_before(temp_clip_distance);
-         actual_param->replace_with(
-            new(ctx) ir_dereference_variable(temp_clip_distance));
-         if (formal_param->data.mode == ir_var_function_in
-             || formal_param->data.mode == ir_var_function_inout) {
-            /* Copy from gl_ClipDistance to the temporary before the call.
-             * Since we are going to insert this copy before the current
-             * instruction, we need to visit it afterwards to make sure it
-             * gets lowered.
-             */
-            ir_assignment *new_assignment = new(ctx) ir_assignment(
-               new(ctx) ir_dereference_variable(temp_clip_distance),
-               actual_param->clone(ctx, NULL));
-            this->base_ir->insert_before(new_assignment);
-            this->visit_new_assignment(new_assignment);
-         }
-         if (formal_param->data.mode == ir_var_function_out
-             || formal_param->data.mode == ir_var_function_inout) {
-            /* Copy from the temporary to gl_ClipDistance after the call.
-             * Since visit_list_elements() has already decided which
-             * instruction it's going to visit next, we need to visit
-             * afterwards to make sure it gets lowered.
-             */
-            ir_assignment *new_assignment = new(ctx) ir_assignment(
-               actual_param->clone(ctx, NULL),
-               new(ctx) ir_dereference_variable(temp_clip_distance));
-            this->base_ir->insert_after(new_assignment);
-            this->visit_new_assignment(new_assignment);
-         }
-      }
-   }
-
-   return rvalue_visit(ir);
-}
-
-namespace {
-class lower_distance_visitor_counter : public ir_rvalue_visitor {
-public:
-   explicit lower_distance_visitor_counter(void)
-      : in_clip_size(0), in_cull_size(0),
-        out_clip_size(0), out_cull_size(0)
-   {
-   }
-
-   virtual ir_visitor_status visit(ir_variable *);
-   virtual void handle_rvalue(ir_rvalue **rvalue);
-
-   int in_clip_size;
-   int in_cull_size;
-   int out_clip_size;
-   int out_cull_size;
-};
-
-}
-/**
- * Count gl_ClipDistance and gl_CullDistance sizes.
- */
-ir_visitor_status
-lower_distance_visitor_counter::visit(ir_variable *ir)
-{
-   int *clip_size, *cull_size;
-
-   if (!ir->name)
-      return visit_continue;
-
-   if (ir->data.mode == ir_var_shader_out) {
-      clip_size = &out_clip_size;
-      cull_size = &out_cull_size;
-   } else if (ir->data.mode == ir_var_shader_in) {
-      clip_size = &in_clip_size;
-      cull_size = &in_cull_size;
-   } else
-      return visit_continue;
-
-   if (ir->type->is_unsized_array())
-      return visit_continue;
-
-   if (*clip_size == 0) {
-      if (!strcmp(ir->name, "gl_ClipDistance")) {
-         if (!ir->type->fields.array->is_array())
-            *clip_size = ir->type->array_size();
-         else
-            *clip_size = ir->type->fields.array->array_size();
-      }
-   }
-
-   if (*cull_size == 0) {
-      if (!strcmp(ir->name, "gl_CullDistance")) {
-         if (!ir->type->fields.array->is_array())
-            *cull_size = ir->type->array_size();
-         else
-            *cull_size = ir->type->fields.array->array_size();
-      }
-   }
-   return visit_continue;
-}
-
-void
-lower_distance_visitor_counter::handle_rvalue(ir_rvalue **)
-{
-   return;
-}
-
-bool
-lower_clip_cull_distance(struct gl_shader_program *prog,
-                         struct gl_linked_shader *shader)
-{
-   int clip_size, cull_size;
-
-   lower_distance_visitor_counter count;
-   visit_list_elements(&count, shader->ir);
-
-   clip_size = MAX2(count.in_clip_size, count.out_clip_size);
-   cull_size = MAX2(count.in_cull_size, count.out_cull_size);
-
-   if (clip_size == 0 && cull_size == 0)
-      return false;
-
-   lower_distance_visitor v(shader->Stage, "gl_ClipDistance", clip_size + cull_size, 0);
-   visit_list_elements(&v, shader->ir);
-
-   lower_distance_visitor v2(shader->Stage, "gl_CullDistance", &v, clip_size);
-   visit_list_elements(&v2, shader->ir);
-
-   if (v2.new_distance_out_var)
-      shader->symbols->add_variable(v2.new_distance_out_var);
-   if (v2.new_distance_in_var)
-      shader->symbols->add_variable(v2.new_distance_in_var);
-
-   return v2.progress;
-}
diff --git a/src/compiler/glsl/meson.build b/src/compiler/glsl/meson.build
index faded36a0aaa7..3c95126834f7a 100644
--- a/src/compiler/glsl/meson.build
+++ b/src/compiler/glsl/meson.build
@@ -196,7 +196,6 @@ files_libglsl = files(
   'list.h',
   'lower_builtins.cpp',
   'lower_discard_flow.cpp',
-  'lower_distance.cpp',
   'lower_instructions.cpp',
   'lower_jumps.cpp',
   'lower_mat_op_to_vec.cpp',
-- 
GitLab


From b059a25a55a5bab66b72183020c1609e2a65e1c7 Mon Sep 17 00:00:00 2001
From: Timothy Arceri <tarceri@itsqueeze.com>
Date: Wed, 25 Oct 2023 10:58:09 +1100
Subject: [PATCH 5/8] nir: simplify nir_build_write_masked_store()

Suggested-by: Alyssa Rosenzweig <alyssa@rosenzweig.io>
---
 src/compiler/nir/nir_builder.h | 9 +++------
 1 file changed, 3 insertions(+), 6 deletions(-)

diff --git a/src/compiler/nir/nir_builder.h b/src/compiler/nir/nir_builder.h
index 34603b76bf858..6a29d2fe642e3 100644
--- a/src/compiler/nir/nir_builder.h
+++ b/src/compiler/nir/nir_builder.h
@@ -1617,12 +1617,9 @@ nir_build_write_masked_store(nir_builder *b, nir_deref_instr *vec_deref,
    unsigned num_components = glsl_get_components(vec_deref->type);
    assert(num_components > 1 && num_components <= NIR_MAX_VEC_COMPONENTS);
 
-   nir_def *u = nir_undef(b, 1, value->bit_size);
-   nir_def *comps[NIR_MAX_VEC_COMPONENTS];
-   for (unsigned i = 0; i < num_components; i++)
-      comps[i] = (i == component) ? value : u;
-
-   nir_def *vec = nir_vec(b, comps, num_components);
+   nir_def *vec =
+      nir_vector_insert_imm(b, nir_undef(b, num_components, value->bit_size),
+                            value, component);
    nir_store_deref(b, vec_deref, vec, (1u << component));
 }
 
-- 
GitLab


From 73df6d4fdebe9decae29fe3406f9479bb8c0ba5c Mon Sep 17 00:00:00 2001
From: Timothy Arceri <tarceri@itsqueeze.com>
Date: Fri, 6 Oct 2023 12:49:54 +1100
Subject: [PATCH 6/8] glsl: add nir based lower_named_interface_blocks()

This will be used in the following patch to replace the GLSL IR
version of this pass.
---
 src/compiler/glsl/gl_nir.h                    |   2 +
 .../gl_nir_lower_named_interface_blocks.c     | 331 ++++++++++++++++++
 src/compiler/glsl/meson.build                 |   1 +
 3 files changed, 334 insertions(+)
 create mode 100644 src/compiler/glsl/gl_nir_lower_named_interface_blocks.c

diff --git a/src/compiler/glsl/gl_nir.h b/src/compiler/glsl/gl_nir.h
index 245c2a0a09cf0..81159845aff5d 100644
--- a/src/compiler/glsl/gl_nir.h
+++ b/src/compiler/glsl/gl_nir.h
@@ -50,6 +50,8 @@ bool gl_nir_lower_blend_equation_advanced(nir_shader *sh, bool coherent);
 bool gl_nir_lower_buffers(nir_shader *shader,
                           const struct gl_shader_program *shader_program);
 
+void gl_nir_lower_named_interface_blocks(struct gl_shader_program *prog);
+
 void gl_nir_lower_packed_varyings(const struct gl_constants *consts,
                                   struct gl_shader_program *prog,
                                   void *mem_ctx, unsigned locations_used,
diff --git a/src/compiler/glsl/gl_nir_lower_named_interface_blocks.c b/src/compiler/glsl/gl_nir_lower_named_interface_blocks.c
new file mode 100644
index 0000000000000..2afc98980adb2
--- /dev/null
+++ b/src/compiler/glsl/gl_nir_lower_named_interface_blocks.c
@@ -0,0 +1,331 @@
+/*
+ * Copyright Â© 2013 Intel Corporation
+ * Copyright Â© 2023 Valve Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+/**
+ *
+ * This lowering pass converts all interface blocks with instance names
+ * into interface blocks without an instance name.
+ *
+ * For example, the following shader:
+ *
+ *   out block {
+ *     float block_var;
+ *   } inst_name;
+ *
+ *   main()
+ *   {
+ *     inst_name.block_var = 0.0;
+ *   }
+ *
+ * Is rewritten to:
+ *
+ *   out block {
+ *     float block_var;
+ *   };
+ *
+ *   main()
+ *   {
+ *     block_var = 0.0;
+ *   }
+ *
+ * This takes place after the shader code has already been verified with
+ * the interface name in place.
+ *
+ * The linking phase will use the interface block name rather than the
+ * interface's instance name when linking interfaces.
+ *
+ * This modification to the ir allows our currently existing dead code
+ * elimination to work with interface blocks without changes.
+ */
+
+#include "nir.h"
+#include "nir_builder.h"
+#include "nir_deref.h"
+#include "nir_types.h"
+#include "gl_nir.h"
+
+#include "main/shader_types.h"
+
+struct lower_named_block_state {
+   void *mem_ctx;
+   struct hash_table *interface_namespace;
+};
+
+static const struct glsl_type *
+process_array_type(const struct glsl_type *type, unsigned idx)
+{
+   const struct glsl_type *element_type = glsl_get_array_element(type);
+   unsigned length = glsl_get_length(type);
+   if (glsl_type_is_array(element_type)) {
+      const struct glsl_type *new_array_type =
+         process_array_type(element_type, idx);
+      return  glsl_array_type(new_array_type, length, 0);
+   } else {
+      return glsl_array_type(glsl_get_struct_field(element_type, idx),
+                             length, 0);
+   }
+}
+
+static nir_deref_instr *
+process_derefs(nir_builder *b, nir_deref_instr **p, nir_deref_instr *parent)
+{
+   bool found_ifc = false;
+   for (; *p; p++) {
+      if ((*p)->deref_type == nir_deref_type_array) {
+         parent = nir_build_deref_array(b, parent, (*p)->arr.index.ssa);
+      } else if ((*p)->deref_type == nir_deref_type_struct) {
+         if (!found_ifc) {
+            /* We found the interface block so just skip it */
+            found_ifc = true;
+            continue;
+         } else {
+            parent = nir_build_deref_struct(b, parent, (*p)->strct.index);
+         }
+      }
+   }
+
+   return parent;
+}
+
+/* Disable packing on varyings used by interpolate functions. This must be
+ * called after lowering blocks to avoid disabling packing on the entire
+ * block.
+ */
+static void
+disable_varying_packing_when_used_by_interpolate_functions(nir_intrinsic_instr *intr,
+                                                           nir_variable *var)
+{
+   if (intr->intrinsic == nir_intrinsic_interp_deref_at_centroid ||
+       intr->intrinsic == nir_intrinsic_interp_deref_at_sample ||
+       intr->intrinsic == nir_intrinsic_interp_deref_at_offset) {
+
+      /* This disables varying packing for this input. */
+      var->data.must_be_shader_input = 1;
+   }
+}
+
+static char *
+create_ifc_field_name_str(void *mem_ctx, nir_variable *var,
+                          const struct glsl_type *iface_t, unsigned f_idx)
+{
+   char *iface_field_name =
+      ralloc_asprintf(mem_ctx, "%s %s.%s.%s",
+                      var->data.mode == nir_var_shader_in ? "in" : "out",
+                      glsl_get_type_name(iface_t), var->name,
+                      glsl_get_struct_elem_name(iface_t, f_idx));
+
+   return iface_field_name;
+}
+
+static void
+flatten_named_interface_deref(void *mem_ctx, nir_builder *b,
+                              nir_deref_instr *deref,
+                              nir_intrinsic_instr *intr,
+                              struct hash_table *interface_namespace,
+                              bool is_src0)
+{
+   nir_variable_mode mask = nir_var_shader_in | nir_var_shader_out;
+
+   if (!nir_deref_mode_is_one_of(deref, mask))
+      return;
+
+   nir_variable *var = nir_deref_instr_get_variable(deref);
+
+   const struct glsl_type * iface_t = glsl_without_array(var->type);
+   if (iface_t != var->interface_type)
+      return;
+
+   nir_deref_path path;
+   nir_deref_path_init(&path, deref, NULL);
+
+   assert(path.path[0]->deref_type == nir_deref_type_var);
+   nir_deref_instr **p = &path.path[1];
+
+   char *iface_field_name = NULL;
+   for (; *p; p++) {
+      if ((*p)->deref_type == nir_deref_type_struct) {
+         iface_field_name =
+            create_ifc_field_name_str(mem_ctx, var, iface_t,
+                                      (*p)->strct.index);
+         break;
+      }
+   }
+   assert(iface_field_name);
+
+   /* Find the variable in the set of flattened interface blocks */
+   struct hash_entry *entry =
+      _mesa_hash_table_search(interface_namespace, iface_field_name);
+   assert(entry);
+
+   nir_variable *found_var = (nir_variable *) entry->data;
+
+   if (intr->intrinsic == nir_intrinsic_store_deref ||
+       (intr->intrinsic == nir_intrinsic_copy_deref && is_src0))
+      found_var->data.assigned = 1;
+
+   b->cursor = nir_before_instr(&intr->instr);
+   nir_deref_instr *deref_var = nir_build_deref_var(b, found_var);
+   if (glsl_type_is_array(found_var->type) ||
+       glsl_type_is_struct(found_var->type) ||
+       glsl_type_is_matrix(found_var->type)) {
+      p = &path.path[1];
+      deref_var = process_derefs(b, p, deref_var);
+   }
+
+   disable_varying_packing_when_used_by_interpolate_functions(intr,
+                                                              found_var);
+
+   nir_deref_path_finish(&path);
+
+   nir_def_rewrite_uses(&deref->def, &deref_var->def);
+}
+
+static bool
+flatten_named_interface_derefs(nir_builder *b, nir_intrinsic_instr *intr,
+                               void *cb_data)
+{
+   struct lower_named_block_state *state =
+      (struct lower_named_block_state *) cb_data;
+
+   if (intr->intrinsic != nir_intrinsic_copy_deref &&
+       intr->intrinsic != nir_intrinsic_load_deref &&
+       intr->intrinsic != nir_intrinsic_store_deref &&
+       intr->intrinsic != nir_intrinsic_interp_deref_at_centroid &&
+       intr->intrinsic != nir_intrinsic_interp_deref_at_sample &&
+       intr->intrinsic != nir_intrinsic_interp_deref_at_offset &&
+       intr->intrinsic != nir_intrinsic_interp_deref_at_vertex)
+      return false;
+
+   nir_deref_instr *deref = nir_src_as_deref(intr->src[0]);
+   flatten_named_interface_deref(state->mem_ctx, b, deref, intr,
+                                 state->interface_namespace, true);
+
+   if (intr->intrinsic == nir_intrinsic_copy_deref) {
+      deref = nir_src_as_deref(intr->src[1]);
+      flatten_named_interface_deref(state->mem_ctx, b, deref, intr,
+                                    state->interface_namespace, false);
+   }
+
+   return true;
+}
+
+static void
+lower_named_interface_blocks(struct gl_linked_shader *sh)
+{
+   void *mem_ctx = ralloc_context(NULL);
+
+   struct hash_table *interface_namespace =
+      _mesa_hash_table_create(mem_ctx, _mesa_hash_string,
+                              _mesa_key_string_equal);
+
+   /* First pass: adjust instance block variables with an instance name
+    * to not have an instance name.
+    *
+    * The interface block variables are stored in the interface_namespace
+    * hash table so they can be used in the second pass.
+    */
+   nir_foreach_variable_with_modes_safe(var, sh->Program->nir,
+                                        nir_var_shader_in | nir_var_shader_out) {
+      const struct glsl_type * iface_t = glsl_without_array(var->type);
+      if (iface_t != var->interface_type)
+         continue;
+
+      for (unsigned i = 0; i < iface_t->length; i++) {
+         const char *field_name = glsl_get_struct_elem_name(iface_t, i);
+         char *iface_field_name =
+            create_ifc_field_name_str(mem_ctx, var, iface_t, i);
+
+         struct hash_entry *entry = _mesa_hash_table_search(interface_namespace,
+                                                            iface_field_name);
+         nir_variable *found_var = entry ? (nir_variable *) entry->data : NULL;
+         if (!found_var) {
+            const struct glsl_struct_field *field_data =
+               glsl_get_struct_field_data(iface_t, i);
+
+            nir_variable *new_var = rzalloc(sh->Program->nir, nir_variable);
+            new_var->name = ralloc_strdup(new_var, field_name);
+            if (!glsl_type_is_array(var->type)) {
+               new_var->type =  glsl_get_struct_field(iface_t, i);
+            } else {
+               new_var->type = process_array_type(var->type, i);
+            }
+            new_var->data.mode = var->data.mode;
+            new_var->data.location = field_data->location;
+            new_var->data.location_frac = field_data->component >= 0 ?
+               field_data->component : 0;
+            new_var->data.explicit_location = (new_var->data.location >= 0);
+            new_var->data.offset = field_data->offset;
+            new_var->data.explicit_offset = (field_data->offset >= 0);
+            new_var->data.xfb.buffer = field_data->xfb_buffer;
+            new_var->data.explicit_xfb_buffer = field_data->explicit_xfb_buffer;
+            new_var->data.interpolation = field_data->interpolation;
+            new_var->data.centroid = field_data->centroid;
+            new_var->data.sample = field_data->sample;
+            new_var->data.patch = field_data->patch;
+            new_var->data.stream = var->data.stream;
+            new_var->data.how_declared = var->data.how_declared;
+            new_var->data.from_named_ifc_block = 1;
+
+            new_var->interface_type = var->type;
+            _mesa_hash_table_insert(interface_namespace, iface_field_name,
+                                    new_var);
+
+            nir_shader_add_variable(sh->Program->nir, new_var);
+         }
+      }
+   }
+
+   /* Second pass: redirect dereferences to the new vars. */
+   struct lower_named_block_state state;
+   state.mem_ctx = mem_ctx;
+   state.interface_namespace = interface_namespace;
+   nir_shader_intrinsics_pass(sh->Program->nir, flatten_named_interface_derefs,
+                              nir_metadata_block_index |
+                              nir_metadata_dominance, &state);
+
+   /* Third pass: Mark now lowered blks as ordinary globals to be dead code
+    * eliminated.
+    */
+   nir_foreach_variable_with_modes(var, sh->Program->nir,
+                                   nir_var_shader_in | nir_var_shader_out) {
+      const struct glsl_type * iface_t = glsl_without_array(var->type);
+      if (!(iface_t == var->interface_type))
+         continue;
+
+      var->data.mode = nir_var_shader_temp;
+   }
+   nir_fixup_deref_modes(sh->Program->nir);
+
+   ralloc_free(mem_ctx);
+}
+
+void
+gl_nir_lower_named_interface_blocks(struct gl_shader_program *prog)
+{
+   for (unsigned int i = 0; i < MESA_SHADER_STAGES; i++) {
+      if (prog->_LinkedShaders[i] != NULL)
+         lower_named_interface_blocks(prog->_LinkedShaders[i]);
+   }
+}
+
diff --git a/src/compiler/glsl/meson.build b/src/compiler/glsl/meson.build
index 3c95126834f7a..ee83c000be468 100644
--- a/src/compiler/glsl/meson.build
+++ b/src/compiler/glsl/meson.build
@@ -129,6 +129,7 @@ files_libglsl = files(
   'gl_nir_lower_images.c',
   'gl_nir_lower_blend_equation_advanced.c',
   'gl_nir_lower_buffers.c',
+  'gl_nir_lower_named_interface_blocks.c',
   'gl_nir_lower_packed_varyings.c',
   'gl_nir_lower_samplers.c',
   'gl_nir_lower_samplers_as_deref.c',
-- 
GitLab


From e804f936ff209216310a1586ab8f890b3a534ed9 Mon Sep 17 00:00:00 2001
From: Timothy Arceri <tarceri@itsqueeze.com>
Date: Fri, 6 Oct 2023 12:53:22 +1100
Subject: [PATCH 7/8] glsl: use the nir based lower_named_interface_blocks()

Because we are now doing the lowering in NIR we need to move the code
that sets the compact flag on some builtin vars out of the glsl to nir
pass.
---
 src/compiler/glsl/gl_nir_linker.c             |  2 ++
 .../gl_nir_lower_named_interface_blocks.c     | 36 ++++++++++++++++++-
 src/compiler/glsl/glsl_to_nir.cpp             | 23 ------------
 src/compiler/glsl/linker.cpp                  |  5 ---
 4 files changed, 37 insertions(+), 29 deletions(-)

diff --git a/src/compiler/glsl/gl_nir_linker.c b/src/compiler/glsl/gl_nir_linker.c
index 33e3258d4331b..dddfdc2b5cb3e 100644
--- a/src/compiler/glsl/gl_nir_linker.c
+++ b/src/compiler/glsl/gl_nir_linker.c
@@ -1344,6 +1344,8 @@ gl_nir_link_glsl(const struct gl_constants *consts,
       last = i;
    }
 
+   gl_nir_lower_named_interface_blocks(prog);
+
    /* Validate the inputs of each stage with the output of the preceding
     * stage.
     */
diff --git a/src/compiler/glsl/gl_nir_lower_named_interface_blocks.c b/src/compiler/glsl/gl_nir_lower_named_interface_blocks.c
index 2afc98980adb2..d6f0d980d89d1 100644
--- a/src/compiler/glsl/gl_nir_lower_named_interface_blocks.c
+++ b/src/compiler/glsl/gl_nir_lower_named_interface_blocks.c
@@ -305,10 +305,44 @@ lower_named_interface_blocks(struct gl_linked_shader *sh)
                               nir_metadata_dominance, &state);
 
    /* Third pass: Mark now lowered blks as ordinary globals to be dead code
-    * eliminated.
+    * eliminated. Also use this oppotunity to set the compact flag where
+    * needed now that the default interface block has been lowered away.
     */
    nir_foreach_variable_with_modes(var, sh->Program->nir,
                                    nir_var_shader_in | nir_var_shader_out) {
+
+      if (var->data.mode == nir_var_shader_in) {
+         if (sh->Program->nir->info.stage == MESA_SHADER_TESS_EVAL &&
+             (var->data.location == VARYING_SLOT_TESS_LEVEL_INNER ||
+              var->data.location == VARYING_SLOT_TESS_LEVEL_OUTER)) {
+            var->data.compact =
+               glsl_type_is_scalar(glsl_without_array(var->type));
+         }
+
+         if (sh->Program->nir->info.stage > MESA_SHADER_VERTEX &&
+             var->data.location >= VARYING_SLOT_CLIP_DIST0 &&
+             var->data.location <= VARYING_SLOT_CULL_DIST1) {
+            var->data.compact =
+               glsl_type_is_scalar(glsl_without_array(var->type));
+         }
+      } else {
+         assert(var->data.mode == nir_var_shader_out);
+
+         if (sh->Program->nir->info.stage == MESA_SHADER_TESS_CTRL &&
+             (var->data.location == VARYING_SLOT_TESS_LEVEL_INNER ||
+              var->data.location == VARYING_SLOT_TESS_LEVEL_OUTER)) {
+            var->data.compact =
+               glsl_type_is_scalar(glsl_without_array(var->type));
+         }
+
+         if (sh->Program->nir->info.stage <= MESA_SHADER_GEOMETRY &&
+             var->data.location >= VARYING_SLOT_CLIP_DIST0 &&
+             var->data.location <= VARYING_SLOT_CULL_DIST1) {
+            var->data.compact =
+               glsl_type_is_scalar(glsl_without_array(var->type));
+         }
+      }
+
       const struct glsl_type * iface_t = glsl_without_array(var->type);
       if (!(iface_t == var->interface_type))
          continue;
diff --git a/src/compiler/glsl/glsl_to_nir.cpp b/src/compiler/glsl/glsl_to_nir.cpp
index 51712f3c05830..5109530b4fd37 100644
--- a/src/compiler/glsl/glsl_to_nir.cpp
+++ b/src/compiler/glsl/glsl_to_nir.cpp
@@ -585,34 +585,11 @@ nir_visitor::visit(ir_variable *ir)
          var->data.mode = nir_var_system_value;
       } else {
          var->data.mode = nir_var_shader_in;
-
-         if (shader->info.stage == MESA_SHADER_TESS_EVAL &&
-             (ir->data.location == VARYING_SLOT_TESS_LEVEL_INNER ||
-              ir->data.location == VARYING_SLOT_TESS_LEVEL_OUTER)) {
-            var->data.compact = ir->type->without_array()->is_scalar();
-         }
-
-         if (shader->info.stage > MESA_SHADER_VERTEX &&
-             ir->data.location >= VARYING_SLOT_CLIP_DIST0 &&
-             ir->data.location <= VARYING_SLOT_CULL_DIST1) {
-            var->data.compact = ir->type->without_array()->is_scalar();
-         }
       }
       break;
 
    case ir_var_shader_out:
       var->data.mode = nir_var_shader_out;
-      if (shader->info.stage == MESA_SHADER_TESS_CTRL &&
-          (ir->data.location == VARYING_SLOT_TESS_LEVEL_INNER ||
-           ir->data.location == VARYING_SLOT_TESS_LEVEL_OUTER)) {
-         var->data.compact = ir->type->without_array()->is_scalar();
-      }
-
-      if (shader->info.stage <= MESA_SHADER_GEOMETRY &&
-          ir->data.location >= VARYING_SLOT_CLIP_DIST0 &&
-          ir->data.location <= VARYING_SLOT_CULL_DIST1) {
-         var->data.compact = ir->type->without_array()->is_scalar();
-      }
       break;
 
    case ir_var_uniform:
diff --git a/src/compiler/glsl/linker.cpp b/src/compiler/glsl/linker.cpp
index 262a53ea181f2..a0a7336613c00 100644
--- a/src/compiler/glsl/linker.cpp
+++ b/src/compiler/glsl/linker.cpp
@@ -3116,11 +3116,6 @@ link_shaders(struct gl_context *ctx, struct gl_shader_program *prog)
    if (!prog->data->LinkStatus)
       goto done;
 
-   for (unsigned int i = 0; i < MESA_SHADER_STAGES; i++) {
-      if (prog->_LinkedShaders[i] != NULL)
-         lower_named_interface_blocks(mem_ctx, prog->_LinkedShaders[i]);
-   }
-
    if (prog->IsES && prog->GLSL_Version == 100)
       if (!validate_invariant_builtins(prog,
             prog->_LinkedShaders[MESA_SHADER_VERTEX],
-- 
GitLab


From a0215bc05e837df291c5c5cb1c1666477162c1f7 Mon Sep 17 00:00:00 2001
From: Timothy Arceri <tarceri@itsqueeze.com>
Date: Fri, 6 Oct 2023 12:57:19 +1100
Subject: [PATCH 8/8] glsl: remove GLSL IR lower_named_interface_blocks()

We now use a NIR based lowering pass instead.
---
 src/compiler/glsl/ir_optimization.h           |   1 -
 .../glsl/lower_named_interface_blocks.cpp     | 323 ------------------
 src/compiler/glsl/meson.build                 |   1 -
 3 files changed, 325 deletions(-)
 delete mode 100644 src/compiler/glsl/lower_named_interface_blocks.cpp

diff --git a/src/compiler/glsl/ir_optimization.h b/src/compiler/glsl/ir_optimization.h
index d768ac0a3d22e..b2ced464a2233 100644
--- a/src/compiler/glsl/ir_optimization.h
+++ b/src/compiler/glsl/ir_optimization.h
@@ -61,7 +61,6 @@ bool lower_packing_builtins(exec_list *instructions,
                             bool has_gpu_shader5,
                             bool has_half_float_packing);
 bool lower_vector_derefs(gl_linked_shader *shader);
-void lower_named_interface_blocks(void *mem_ctx, gl_linked_shader *shader);
 void optimize_dead_builtin_variables(exec_list *instructions,
                                      enum ir_variable_mode other);
 
diff --git a/src/compiler/glsl/lower_named_interface_blocks.cpp b/src/compiler/glsl/lower_named_interface_blocks.cpp
deleted file mode 100644
index 5da389357675d..0000000000000
--- a/src/compiler/glsl/lower_named_interface_blocks.cpp
+++ /dev/null
@@ -1,323 +0,0 @@
-/*
- * Copyright (c) 2013 Intel Corporation
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice (including the next
- * paragraph) shall be included in all copies or substantial portions of the
- * Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- */
-
-/**
- * \file lower_named_interface_blocks.cpp
- *
- * This lowering pass converts all interface blocks with instance names
- * into interface blocks without an instance name.
- *
- * For example, the following shader:
- *
- *   out block {
- *     float block_var;
- *   } inst_name;
- *
- *   main()
- *   {
- *     inst_name.block_var = 0.0;
- *   }
- *
- * Is rewritten to:
- *
- *   out block {
- *     float block_var;
- *   };
- *
- *   main()
- *   {
- *     block_var = 0.0;
- *   }
- *
- * This takes place after the shader code has already been verified with
- * the interface name in place.
- *
- * The linking phase will use the interface block name rather than the
- * interface's instance name when linking interfaces.
- *
- * This modification to the ir allows our currently existing dead code
- * elimination to work with interface blocks without changes.
- */
-
-#include "glsl_symbol_table.h"
-#include "ir.h"
-#include "ir_optimization.h"
-#include "ir_rvalue_visitor.h"
-#include "util/hash_table.h"
-#include "main/shader_types.h"
-
-static const glsl_type *
-process_array_type(const glsl_type *type, unsigned idx)
-{
-   const glsl_type *element_type = type->fields.array;
-   if (element_type->is_array()) {
-      const glsl_type *new_array_type = process_array_type(element_type, idx);
-      return glsl_type::get_array_instance(new_array_type, type->length);
-   } else {
-      return glsl_type::get_array_instance(
-         element_type->fields.structure[idx].type, type->length);
-   }
-}
-
-static ir_rvalue *
-process_array_ir(void * const mem_ctx,
-                 ir_dereference_array *deref_array_prev,
-                 ir_rvalue *deref_var)
-{
-   ir_dereference_array *deref_array =
-      deref_array_prev->array->as_dereference_array();
-
-   if (deref_array == NULL) {
-      return new(mem_ctx) ir_dereference_array(deref_var,
-                                               deref_array_prev->array_index);
-   } else {
-      deref_array = (ir_dereference_array *) process_array_ir(mem_ctx,
-                                                              deref_array,
-                                                              deref_var);
-      return new(mem_ctx) ir_dereference_array(deref_array,
-                                               deref_array_prev->array_index);
-   }
-}
-
-namespace {
-
-class flatten_named_interface_blocks_declarations : public ir_rvalue_visitor
-{
-public:
-   void * const mem_ctx;
-   hash_table *interface_namespace;
-
-   flatten_named_interface_blocks_declarations(void *mem_ctx)
-      : mem_ctx(mem_ctx),
-        interface_namespace(NULL)
-   {
-   }
-
-   void run(exec_list *instructions);
-
-   virtual ir_visitor_status visit_leave(ir_assignment *);
-   virtual ir_visitor_status visit_leave(ir_expression *);
-   virtual void handle_rvalue(ir_rvalue **rvalue);
-};
-
-} /* anonymous namespace */
-
-void
-flatten_named_interface_blocks_declarations::run(exec_list *instructions)
-{
-   interface_namespace = _mesa_hash_table_create(NULL, _mesa_hash_string,
-                                                 _mesa_key_string_equal);
-
-   /* First pass: adjust instance block variables with an instance name
-    * to not have an instance name.
-    *
-    * The interface block variables are stored in the interface_namespace
-    * hash table so they can be used in the second pass.
-    */
-   foreach_in_list_safe(ir_instruction, node, instructions) {
-      ir_variable *var = node->as_variable();
-      if (!var || !var->is_interface_instance())
-         continue;
-
-      /* It should be possible to handle uniforms during this pass,
-       * but, this will require changes to the other uniform block
-       * support code.
-       */
-      if (var->data.mode == ir_var_uniform ||
-          var->data.mode == ir_var_shader_storage)
-         continue;
-
-      const glsl_type * iface_t = var->type->without_array();
-      exec_node *insert_pos = var;
-
-      assert (iface_t->is_interface());
-
-      for (unsigned i = 0; i < iface_t->length; i++) {
-         const char * field_name = iface_t->fields.structure[i].name;
-         char *iface_field_name =
-            ralloc_asprintf(mem_ctx, "%s %s.%s.%s",
-                            var->data.mode == ir_var_shader_in ? "in" : "out",
-                            glsl_get_type_name(iface_t), var->name, field_name);
-
-         hash_entry *entry = _mesa_hash_table_search(interface_namespace,
-                                                     iface_field_name);
-         ir_variable *found_var = entry ? (ir_variable *) entry->data : NULL;
-         if (!found_var) {
-            ir_variable *new_var;
-            char *var_name =
-               ralloc_strdup(mem_ctx, iface_t->fields.structure[i].name);
-            if (!var->type->is_array()) {
-               new_var =
-                  new(mem_ctx) ir_variable(iface_t->fields.structure[i].type,
-                                           var_name,
-                                           (ir_variable_mode) var->data.mode);
-            } else {
-               const glsl_type *new_array_type =
-                  process_array_type(var->type, i);
-               new_var =
-                  new(mem_ctx) ir_variable(new_array_type,
-                                           var_name,
-                                           (ir_variable_mode) var->data.mode);
-            }
-            new_var->data.location = iface_t->fields.structure[i].location;
-            new_var->data.location_frac =
-               iface_t->fields.structure[i].component >= 0 ?
-                  iface_t->fields.structure[i].component : 0;
-            new_var->data.explicit_location = (new_var->data.location >= 0);
-            new_var->data.explicit_component =
-               (iface_t->fields.structure[i].component >= 0);
-            new_var->data.offset = iface_t->fields.structure[i].offset;
-            new_var->data.explicit_xfb_offset =
-               (iface_t->fields.structure[i].offset >= 0);
-            new_var->data.xfb_buffer =
-               iface_t->fields.structure[i].xfb_buffer;
-            new_var->data.explicit_xfb_buffer =
-               iface_t->fields.structure[i].explicit_xfb_buffer;
-            new_var->data.interpolation =
-               iface_t->fields.structure[i].interpolation;
-            new_var->data.centroid = iface_t->fields.structure[i].centroid;
-            new_var->data.sample = iface_t->fields.structure[i].sample;
-            new_var->data.patch = iface_t->fields.structure[i].patch;
-            new_var->data.stream = var->data.stream;
-            new_var->data.how_declared = var->data.how_declared;
-            new_var->data.from_named_ifc_block = 1;
-
-            new_var->init_interface_type(var->type);
-            _mesa_hash_table_insert(interface_namespace, iface_field_name,
-                                    new_var);
-            insert_pos->insert_after(new_var);
-            insert_pos = new_var;
-         }
-      }
-      var->remove();
-   }
-
-   /* Second pass: visit all ir_dereference_record instances, and if they
-    * reference an interface block, then flatten the refererence out.
-    */
-   visit_list_elements(this, instructions);
-   _mesa_hash_table_destroy(interface_namespace, NULL);
-   interface_namespace = NULL;
-}
-
-ir_visitor_status
-flatten_named_interface_blocks_declarations::visit_leave(ir_assignment *ir)
-{
-   ir_dereference_record *lhs_rec = ir->lhs->as_dereference_record();
-
-   ir_variable *lhs_var =  ir->lhs->variable_referenced();
-   if (lhs_var && lhs_var->get_interface_type()) {
-      lhs_var->data.assigned = 1;
-   }
-
-   if (lhs_rec) {
-      ir_rvalue *lhs_rec_tmp = lhs_rec;
-      handle_rvalue(&lhs_rec_tmp);
-      if (lhs_rec_tmp != lhs_rec) {
-         ir->set_lhs(lhs_rec_tmp);
-      }
-
-      ir_variable *lhs_var =  lhs_rec_tmp->variable_referenced();
-      if (lhs_var) {
-         lhs_var->data.assigned = 1;
-      }
-   }
-   return rvalue_visit(ir);
-}
-
-ir_visitor_status
-flatten_named_interface_blocks_declarations::visit_leave(ir_expression *ir)
-{
-   ir_visitor_status status = rvalue_visit(ir);
-
-   if (ir->operation == ir_unop_interpolate_at_centroid ||
-       ir->operation == ir_binop_interpolate_at_offset ||
-       ir->operation == ir_binop_interpolate_at_sample) {
-      const ir_rvalue *val = ir->operands[0];
-
-      /* This disables varying packing for this input. */
-      val->variable_referenced()->data.must_be_shader_input = 1;
-   }
-
-   return status;
-}
-
-void
-flatten_named_interface_blocks_declarations::handle_rvalue(ir_rvalue **rvalue)
-{
-   if (*rvalue == NULL)
-      return;
-
-   ir_dereference_record *ir = (*rvalue)->as_dereference_record();
-   if (ir == NULL)
-      return;
-
-   ir_variable *var = ir->variable_referenced();
-   if (var == NULL)
-      return;
-
-   if (!var->is_interface_instance())
-      return;
-
-   /* It should be possible to handle uniforms during this pass,
-    * but, this will require changes to the other uniform block
-    * support code.
-    */
-   if (var->data.mode == ir_var_uniform || var->data.mode == ir_var_shader_storage)
-      return;
-
-   if (var->get_interface_type() != NULL) {
-      char *iface_field_name =
-         ralloc_asprintf(mem_ctx, "%s %s.%s.%s",
-                         var->data.mode == ir_var_shader_in ? "in" : "out",
-                         glsl_get_type_name(var->get_interface_type()),
-                         var->name,
-                         ir->record->type->fields.structure[ir->field_idx].name);
-
-      /* Find the variable in the set of flattened interface blocks */
-      hash_entry *entry = _mesa_hash_table_search(interface_namespace,
-                                                  iface_field_name);
-      assert(entry);
-      ir_variable *found_var = (ir_variable *) entry->data;
-
-      ir_dereference_variable *deref_var =
-         new(mem_ctx) ir_dereference_variable(found_var);
-
-      ir_dereference_array *deref_array =
-         ir->record->as_dereference_array();
-      if (deref_array != NULL) {
-         *rvalue = process_array_ir(mem_ctx, deref_array,
-                                    (ir_rvalue *)deref_var);
-      } else {
-         *rvalue = deref_var;
-      }
-   }
-}
-
-void
-lower_named_interface_blocks(void *mem_ctx, gl_linked_shader *shader)
-{
-   flatten_named_interface_blocks_declarations v_decl(mem_ctx);
-   v_decl.run(shader->ir);
-}
-
diff --git a/src/compiler/glsl/meson.build b/src/compiler/glsl/meson.build
index ee83c000be468..cdb79ae134e94 100644
--- a/src/compiler/glsl/meson.build
+++ b/src/compiler/glsl/meson.build
@@ -200,7 +200,6 @@ files_libglsl = files(
   'lower_instructions.cpp',
   'lower_jumps.cpp',
   'lower_mat_op_to_vec.cpp',
-  'lower_named_interface_blocks.cpp',
   'lower_packing_builtins.cpp',
   'lower_precision.cpp',
   'lower_subroutine.cpp',
-- 
GitLab

