From 5a4c82fe4d4cd66ee2f38023de197ad5c8dfee76 Mon Sep 17 00:00:00 2001
From: Illia Polishchuk <illia.a.polishchuk@globallogic.com>
Date: Thu, 6 Oct 2022 10:55:45 +0300
Subject: [PATCH] egl/wayland: Update buffer after resizing

When we make the surface current, we implicitly create a backbuffer.
Calling wl_egl_window_resize then effectively no-ops within
update_buffers_if_needed as a back buffer exists without recreating it.

KDE on Wayland resizes the window to its current size after initial
resizing and making the surface current.
As a result, the window stays unresized forever

An example of the issue was found inside QT
https://bugreports.qt.io/browse/QTBUG-106273

GNOME on Wayland continually reconfigures size so it appears to fix itself
but the first frame is still wrong.

Other DRI2 implementations, like X11 or Android, always recreate buffers
inside the getBuffers DRI API interface implementation,
because it's more about buffer allocation than buffer extraction,
according to DRI2 docs and comments

It's better to not break this behavior for Wayland
and not break numerous existing codebases which rely on this.

Signed-off-by: Illia Polishchuk <illia.a.polishchuk@globallogic.com>
Closes: https://gitlab.freedesktop.org/mesa/mesa/-/issues/7217
Closes: https://bugreports.qt.io/browse/QTBUG-106273
Fixes: b56194649704bd0da2d8dd3044fff2e80d07f3f9
---
 src/egl/drivers/dri2/platform_wayland.c | 13 +++++++++++--
 1 file changed, 11 insertions(+), 2 deletions(-)

diff --git a/src/egl/drivers/dri2/platform_wayland.c b/src/egl/drivers/dri2/platform_wayland.c
index 93bb97c54e06..ab20ee45027b 100644
--- a/src/egl/drivers/dri2/platform_wayland.c
+++ b/src/egl/drivers/dri2/platform_wayland.c
@@ -1175,6 +1175,15 @@ update_buffers_if_needed(struct dri2_egl_surface *dri2_surf)
    return update_buffers(dri2_surf);
 }
 
+static int
+update_buffers_if_resized(struct dri2_egl_surface *dri2_surf)
+{
+   if (dri2_surf->back != NULL && !dri2_surf->resized)
+      return 0;
+
+   return update_buffers(dri2_surf);
+}
+
 static __DRIbuffer *
 dri2_wl_get_buffers_with_format(__DRIdrawable * driDrawable,
                                 int *width, int *height,
@@ -1184,7 +1193,7 @@ dri2_wl_get_buffers_with_format(__DRIdrawable * driDrawable,
    struct dri2_egl_surface *dri2_surf = loaderPrivate;
    int i, j;
 
-   if (update_buffers_if_needed(dri2_surf) < 0)
+   if (update_buffers_if_resized(dri2_surf) < 0)
       return NULL;
 
    for (i = 0, j = 0; i < 2 * count; i += 2, j++) {
@@ -1263,7 +1272,7 @@ image_get_buffers(__DRIdrawable *driDrawable,
 {
    struct dri2_egl_surface *dri2_surf = loaderPrivate;
 
-   if (update_buffers_if_needed(dri2_surf) < 0)
+   if (update_buffers_if_resized(dri2_surf) < 0)
       return 0;
 
    buffers->image_mask = __DRI_IMAGE_BUFFER_BACK;
-- 
GitLab

