From 1a90c4865a3a49aa48241911ea1f51f2155b8f58 Mon Sep 17 00:00:00 2001
From: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date: Tue, 6 Dec 2022 15:23:30 +0100
Subject: [PATCH 01/10] radv: add support for a PS epilogs cache in the device

Similar to VS prologs.

Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
---
 src/amd/vulkan/radv_cmd_buffer.c | 15 ++++++++++++++
 src/amd/vulkan/radv_device.c     | 34 ++++++++++++++++++++++++++++++++
 src/amd/vulkan/radv_private.h    |  7 +++++++
 3 files changed, 56 insertions(+)

diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index 97f386bfad33..7b5dc02ab55c 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -4055,6 +4055,21 @@ radv_emit_color_blend_enable(struct radv_cmd_buffer *cmd_buffer)
    }
 }
 
+uint32_t
+radv_hash_ps_epilog(const void *key_)
+{
+   const struct radv_ps_epilog_key *key = key_;
+   return _mesa_hash_data(key, sizeof(*key));
+}
+
+bool
+radv_cmp_ps_epilog(const void *a_, const void *b_)
+{
+   const struct radv_ps_epilog_key *a = a_;
+   const struct radv_ps_epilog_key *b = b_;
+   return memcmp(a, b, sizeof(*a)) == 0;
+}
+
 static void
 radv_emit_msaa_state(struct radv_cmd_buffer *cmd_buffer)
 {
diff --git a/src/amd/vulkan/radv_device.c b/src/amd/vulkan/radv_device.c
index ac94bec89f28..c94bbc57eb48 100644
--- a/src/amd/vulkan/radv_device.c
+++ b/src/amd/vulkan/radv_device.c
@@ -3298,6 +3298,31 @@ radv_device_finish_vs_prologs(struct radv_device *device)
    }
 }
 
+static VkResult
+radv_device_init_ps_epilogs(struct radv_device *device)
+{
+   u_rwlock_init(&device->ps_epilogs_lock);
+
+   device->ps_epilogs = _mesa_hash_table_create(NULL, &radv_hash_ps_epilog, &radv_cmp_ps_epilog);
+   if (!device->ps_epilogs)
+      return vk_error(device->physical_device->instance, VK_ERROR_OUT_OF_HOST_MEMORY);
+
+   return VK_SUCCESS;
+}
+
+static void
+radv_device_finish_ps_epilogs(struct radv_device *device)
+{
+   if (device->ps_epilogs) {
+      hash_table_foreach(device->ps_epilogs, entry)
+      {
+         free((void *)entry->key);
+         radv_shader_part_unref(device, entry->data);
+      }
+      _mesa_hash_table_destroy(device->ps_epilogs, NULL);
+   }
+}
+
 VkResult
 radv_device_init_vrs_state(struct radv_device *device)
 {
@@ -3570,6 +3595,7 @@ radv_CreateDevice(VkPhysicalDevice physicalDevice, const VkDeviceCreateInfo *pCr
    bool attachment_vrs_enabled = false;
    bool image_float32_atomics = false;
    bool vs_prologs = false;
+   bool ps_epilogs = false;
    bool global_bo_list = false;
    bool image_2d_view_of_3d = false;
    bool primitives_generated_query = false;
@@ -3946,6 +3972,12 @@ radv_CreateDevice(VkPhysicalDevice physicalDevice, const VkDeviceCreateInfo *pCr
          goto fail;
    }
 
+   if (ps_epilogs) {
+      result = radv_device_init_ps_epilogs(device);
+      if (result != VK_SUCCESS)
+         goto fail;
+   }
+
    if (device->physical_device->rad_info.gfx_level >= GFX7)
       cik_create_gfx_config(device);
 
@@ -4017,6 +4049,7 @@ fail:
 
    radv_device_finish_notifier(device);
    radv_device_finish_vs_prologs(device);
+   radv_device_finish_ps_epilogs(device);
    radv_device_finish_border_color(device);
 
    for (unsigned i = 0; i < RADV_MAX_QUEUE_FAMILIES; i++) {
@@ -4057,6 +4090,7 @@ radv_DestroyDevice(VkDevice _device, const VkAllocationCallbacks *pAllocator)
 
    radv_device_finish_notifier(device);
    radv_device_finish_vs_prologs(device);
+   radv_device_finish_ps_epilogs(device);
    radv_device_finish_border_color(device);
    radv_device_finish_vrs_image(device);
 
diff --git a/src/amd/vulkan/radv_private.h b/src/amd/vulkan/radv_private.h
index 795eb5d62846..1368744662ea 100644
--- a/src/amd/vulkan/radv_private.h
+++ b/src/amd/vulkan/radv_private.h
@@ -944,6 +944,10 @@ struct radv_device {
    struct radv_shader_part *simple_vs_prologs[MAX_VERTEX_ATTRIBS];
    struct radv_shader_part *instance_rate_vs_prologs[816];
 
+   /* PS epilogs */
+   struct u_rwlock ps_epilogs_lock;
+   struct hash_table *ps_epilogs;
+
    simple_mtx_t trace_mtx;
 
    /* Whether per-vertex VRS is forced. */
@@ -1807,6 +1811,9 @@ unsigned radv_instance_rate_prolog_index(unsigned num_attributes, uint32_t insta
 uint32_t radv_hash_vs_prolog(const void *key_);
 bool radv_cmp_vs_prolog(const void *a_, const void *b_);
 
+uint32_t radv_hash_ps_epilog(const void *key_);
+bool radv_cmp_ps_epilog(const void *a_, const void *b_);
+
 void radv_cmd_buffer_reset_rendering(struct radv_cmd_buffer *cmd_buffer);
 bool radv_cmd_buffer_upload_alloc(struct radv_cmd_buffer *cmd_buffer, unsigned size,
                                   unsigned *out_offset, void **ptr);
-- 
GitLab


From 5bde119f0c68566599ec38b71a67078dff90f09e Mon Sep 17 00:00:00 2001
From: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date: Wed, 7 Dec 2022 09:22:48 +0100
Subject: [PATCH 02/10] radv: enable the PS epilogs cache when some ds3 states
 are enabled

These dynamic states need to compile PS epilogs on-demand.

Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
---
 src/amd/vulkan/radv_device.c | 8 ++++++++
 1 file changed, 8 insertions(+)

diff --git a/src/amd/vulkan/radv_device.c b/src/amd/vulkan/radv_device.c
index c94bbc57eb48..86a838b04204 100644
--- a/src/amd/vulkan/radv_device.c
+++ b/src/amd/vulkan/radv_device.c
@@ -3699,6 +3699,14 @@ radv_CreateDevice(VkPhysicalDevice physicalDevice, const VkDeviceCreateInfo *pCr
             vs_prologs = true;
          break;
       }
+      case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_FEATURES_EXT: {
+         const VkPhysicalDeviceExtendedDynamicState3FeaturesEXT *features = (const void *)ext;
+         if (features->extendedDynamicState3ColorBlendEnable ||
+             features->extendedDynamicState3ColorWriteMask ||
+             features->extendedDynamicState3AlphaToCoverageEnable)
+            ps_epilogs = true;
+         break;
+      }
       default:
          break;
       }
-- 
GitLab


From add91c2d1b67eb55d72b881ad9bb1e19af926283 Mon Sep 17 00:00:00 2001
From: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date: Tue, 6 Dec 2022 15:21:56 +0100
Subject: [PATCH 03/10] radv: rework PS epilog emission

With PS epilogs compiled on-demand (for some dynamic states), they need
to be emitted outside of the graphics pipeline path. Also keep track
of the last emitted PS epilog to avoid redundant emission.

Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
---
 src/amd/vulkan/radv_cmd_buffer.c | 14 +++++++++-----
 src/amd/vulkan/radv_private.h    |  2 ++
 2 files changed, 11 insertions(+), 5 deletions(-)

diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index 7b5dc02ab55c..062cc6fb12de 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -1859,13 +1859,13 @@ radv_emit_rbplus_state(struct radv_cmd_buffer *cmd_buffer)
 }
 
 static void
-radv_emit_ps_epilog(struct radv_cmd_buffer *cmd_buffer)
+radv_emit_ps_epilog_state(struct radv_cmd_buffer *cmd_buffer, struct radv_shader_part *ps_epilog,
+                          bool pipeline_is_dirty)
 {
    struct radv_graphics_pipeline *pipeline = cmd_buffer->state.graphics_pipeline;
    struct radv_shader *ps_shader = pipeline->base.shaders[MESA_SHADER_FRAGMENT];
-   struct radv_shader_part *ps_epilog = pipeline->ps_epilog;
 
-   if (!ps_epilog)
+   if (cmd_buffer->state.emitted_ps_epilog == ps_epilog && !pipeline_is_dirty)
       return;
 
    /* The main shader must not use less VGPRs than the epilog, otherwise shared vgprs might not
@@ -1884,6 +1884,8 @@ radv_emit_ps_epilog(struct radv_cmd_buffer *cmd_buffer)
    assert(loc->num_sgprs == 1);
    radv_emit_shader_pointer(cmd_buffer->device, cmd_buffer->cs, base_reg + loc->sgpr_idx * 4,
                             ps_epilog->va, false);
+
+   cmd_buffer->state.emitted_ps_epilog = ps_epilog;
 }
 
 static void
@@ -1992,8 +1994,6 @@ radv_emit_graphics_pipeline(struct radv_cmd_buffer *cmd_buffer)
       }
    }
 
-   radv_emit_ps_epilog(cmd_buffer);
-
    radv_cs_add_buffer(cmd_buffer->device->ws, cmd_buffer->cs, pipeline->base.slab_bo);
 
    /* With graphics pipeline library, binaries are uploaded from a library and they hold a pointer
@@ -8465,6 +8465,10 @@ radv_emit_all_graphics_states(struct radv_cmd_buffer *cmd_buffer, const struct r
        cmd_buffer->state.emitted_graphics_pipeline != cmd_buffer->state.graphics_pipeline)
       radv_emit_binning_state(cmd_buffer, cmd_buffer->state.graphics_pipeline);
 
+   if (cmd_buffer->state.graphics_pipeline->ps_epilog)
+      radv_emit_ps_epilog_state(cmd_buffer, cmd_buffer->state.graphics_pipeline->ps_epilog,
+                                pipeline_is_dirty);
+
    if (cmd_buffer->state.dirty & RADV_CMD_DIRTY_PIPELINE)
       radv_emit_graphics_pipeline(cmd_buffer);
 
diff --git a/src/amd/vulkan/radv_private.h b/src/amd/vulkan/radv_private.h
index 1368744662ea..49309167ed6c 100644
--- a/src/amd/vulkan/radv_private.h
+++ b/src/amd/vulkan/radv_private.h
@@ -1649,6 +1649,8 @@ struct radv_cmd_state {
    uint32_t vbo_misaligned_mask_invalid;
    uint32_t vbo_bound_mask;
 
+   struct radv_shader_part *emitted_ps_epilog;
+
    /* Per-vertex VRS state. */
    uint32_t last_vrs_rates;
    int8_t last_vrs_rates_sgpr_idx;
-- 
GitLab


From 57bee5d26a79ea2277450b715479c93ca2eebd2e Mon Sep 17 00:00:00 2001
From: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date: Tue, 6 Dec 2022 15:21:02 +0100
Subject: [PATCH 04/10] radv: move some color format helpers to radv_private.h

These will be used from the cmdbuf to compile PS epilogs on-demand.

Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
---
 src/amd/vulkan/radv_pipeline.c | 45 +++++-----------------------------
 src/amd/vulkan/radv_private.h  | 36 +++++++++++++++++++++++++++
 2 files changed, 42 insertions(+), 39 deletions(-)

diff --git a/src/amd/vulkan/radv_pipeline.c b/src/amd/vulkan/radv_pipeline.c
index 2de3f2376d80..628266a5657a 100644
--- a/src/amd/vulkan/radv_pipeline.c
+++ b/src/amd/vulkan/radv_pipeline.c
@@ -468,7 +468,7 @@ is_dual_src(VkBlendFactor factor)
    }
 }
 
-static unsigned
+unsigned
 radv_choose_spi_color_format(const struct radv_device *device, VkFormat vk_format,
                              bool blend_enable, bool blend_need_alpha)
 {
@@ -494,39 +494,6 @@ radv_choose_spi_color_format(const struct radv_device *device, VkFormat vk_forma
       return formats.normal;
 }
 
-static bool
-format_is_int8(VkFormat format)
-{
-   const struct util_format_description *desc = vk_format_description(format);
-   int channel = vk_format_get_first_non_void_channel(format);
-
-   return channel >= 0 && desc->channel[channel].pure_integer && desc->channel[channel].size == 8;
-}
-
-static bool
-format_is_int10(VkFormat format)
-{
-   const struct util_format_description *desc = vk_format_description(format);
-
-   if (desc->nr_channels != 4)
-      return false;
-   for (unsigned i = 0; i < 4; i++) {
-      if (desc->channel[i].pure_integer && desc->channel[i].size == 10)
-         return true;
-   }
-   return false;
-}
-
-static bool
-format_is_float32(VkFormat format)
-{
-   const struct util_format_description *desc = vk_format_description(format);
-   int channel = vk_format_get_first_non_void_channel(format);
-
-   return channel >= 0 &&
-          desc->channel[channel].type == UTIL_FORMAT_TYPE_FLOAT && desc->channel[channel].size == 32;
-}
-
 static unsigned
 radv_compact_spi_shader_col_format(const struct radv_shader *ps,
                                    const struct radv_blend_state *blend)
@@ -582,11 +549,11 @@ radv_pipeline_compute_spi_color_formats(const struct radv_graphics_pipeline *pip
          cf = radv_choose_spi_color_format(pipeline->base.device, fmt, blend_enable,
                                            blend->need_src_alpha & (1 << i));
 
-         if (format_is_int8(fmt))
+         if (radv_format_is_int8(fmt))
             is_int8 |= 1 << i;
-         if (format_is_int10(fmt))
+         if (radv_format_is_int10(fmt))
             is_int10 |= 1 << i;
-         if (format_is_float32(fmt))
+         if (radv_format_is_float32(fmt))
             is_float32 |= 1 << i;
       }
 
@@ -654,8 +621,8 @@ radv_format_meta_fs_key(struct radv_device *device, VkFormat format)
    unsigned col_format = radv_choose_spi_color_format(device, format, false, false);
    assert(col_format != V_028714_SPI_SHADER_32_AR);
 
-   bool is_int8 = format_is_int8(format);
-   bool is_int10 = format_is_int10(format);
+   bool is_int8 = radv_format_is_int8(format);
+   bool is_int10 = radv_format_is_int10(format);
 
    if (col_format == V_028714_SPI_SHADER_UINT16_ABGR && is_int8)
       return 8;
diff --git a/src/amd/vulkan/radv_private.h b/src/amd/vulkan/radv_private.h
index 49309167ed6c..29b437c72d28 100644
--- a/src/amd/vulkan/radv_private.h
+++ b/src/amd/vulkan/radv_private.h
@@ -3255,6 +3255,42 @@ bool radv_spm_init(struct radv_device *device);
 void radv_spm_finish(struct radv_device *device);
 void radv_emit_spm_setup(struct radv_device *device, struct radeon_cmdbuf *cs);
 
+static inline bool
+radv_format_is_int8(VkFormat format)
+{
+   const struct util_format_description *desc = vk_format_description(format);
+   int channel = vk_format_get_first_non_void_channel(format);
+
+   return channel >= 0 && desc->channel[channel].pure_integer && desc->channel[channel].size == 8;
+}
+
+static inline bool
+radv_format_is_int10(VkFormat format)
+{
+   const struct util_format_description *desc = vk_format_description(format);
+
+   if (desc->nr_channels != 4)
+      return false;
+   for (unsigned i = 0; i < 4; i++) {
+      if (desc->channel[i].pure_integer && desc->channel[i].size == 10)
+         return true;
+   }
+   return false;
+}
+
+static inline bool
+radv_format_is_float32(VkFormat format)
+{
+   const struct util_format_description *desc = vk_format_description(format);
+   int channel = vk_format_get_first_non_void_channel(format);
+
+   return channel >= 0 &&
+          desc->channel[channel].type == UTIL_FORMAT_TYPE_FLOAT && desc->channel[channel].size == 32;
+}
+
+unsigned radv_choose_spi_color_format(const struct radv_device *device, VkFormat vk_format,
+                                      bool blend_enable, bool blend_need_alpha);
+
 #define RADV_FROM_HANDLE(__radv_type, __name, __handle) \
    VK_FROM_HANDLE(__radv_type, __name, __handle)
 
-- 
GitLab


From c52e0e731de2a59672bad5a72fe8da7ad6537e49 Mon Sep 17 00:00:00 2001
From: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date: Tue, 6 Dec 2022 16:00:29 +0100
Subject: [PATCH 05/10] radv: add support for compiling PS epilogs on-demand

Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
---
 src/amd/vulkan/radv_cmd_buffer.c | 127 ++++++++++++++++++++++++++++++-
 src/amd/vulkan/radv_pipeline.c   |   3 +
 src/amd/vulkan/radv_private.h    |   3 +
 3 files changed, 130 insertions(+), 3 deletions(-)

diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index 062cc6fb12de..6f78326aac03 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -4070,6 +4070,111 @@ radv_cmp_ps_epilog(const void *a_, const void *b_)
    return memcmp(a, b, sizeof(*a)) == 0;
 }
 
+static struct radv_shader_part *
+lookup_ps_epilog(struct radv_cmd_buffer *cmd_buffer)
+{
+   const struct radv_graphics_pipeline *pipeline = cmd_buffer->state.graphics_pipeline;
+   const struct radv_rendering_state *render = &cmd_buffer->state.render;
+   const struct radv_dynamic_state *d = &cmd_buffer->state.dynamic;
+   uint32_t need_src_alpha = pipeline->need_src_alpha;
+   struct radv_device *device = cmd_buffer->device;
+   struct radv_shader_part *epilog = NULL;
+
+   if (d->alpha_to_coverage_enable) {
+      /* Select a color export format with alpha when alpha to coverage is enabled. */
+      need_src_alpha |= 0x1;
+   }
+
+   unsigned col_format = 0, is_int8 = 0, is_int10 = 0, is_float32 = 0;
+   for (unsigned i = 0; i < render->color_att_count; ++i) {
+      struct radv_image_view *iview = render->color_att[i].iview;
+      VkFormat format = render->color_att[i].format;
+      unsigned cf;
+
+      if (!iview)
+         continue;
+
+      assert(format != VK_FORMAT_UNDEFINED);
+
+      if (!((d->color_write_mask >> (i * 4)) & 0xf)) {
+         cf = V_028714_SPI_SHADER_ZERO;
+      } else {
+         bool blend_enable = (d->color_blend_enable >> (i * 4)) & 0xf;
+
+         cf = radv_choose_spi_color_format(cmd_buffer->device, format, blend_enable,
+                                           need_src_alpha & (1 << i));
+
+         if (radv_format_is_int8(format))
+            is_int8 |= 1 << i;
+         if (radv_format_is_int10(format))
+            is_int10 |= 1 << i;
+         if (radv_format_is_float32(format))
+            is_float32 |= 1 << i;
+      }
+
+      col_format |= cf << (4 * i);
+   }
+
+   if (!(col_format & 0xf) && need_src_alpha & (1 << 0)) {
+      /* When a subpass doesn't have any color attachments, write the alpha channel of MRT0 when
+       * alpha coverage is enabled because the depth attachment needs it.
+       */
+      col_format |= V_028714_SPI_SHADER_32_AR;
+   }
+
+   unsigned num_targets = (util_last_bit(col_format) + 3) / 4;
+   for (unsigned i = 0; i < num_targets; i++) {
+      if (!(col_format & (0xfu << (i * 4)))) {
+         col_format |= V_028714_SPI_SHADER_32_R << (i * 4);
+      }
+   }
+
+   /* The output for dual source blending should have the same format as the first output. */
+   if (pipeline->mrt0_is_dual_src) {
+      assert(!(col_format >> 4));
+      col_format |= (col_format & 0xf) << 4;
+   }
+
+   struct radv_ps_epilog_key key;
+   key.spi_shader_col_format = col_format;
+   key.color_is_int8 = device->physical_device->rad_info.gfx_level < GFX8 ? is_int8 : 0;
+   key.color_is_int10 = device->physical_device->rad_info.gfx_level < GFX8 ? is_int10 : 0;
+   key.enable_mrt_output_nan_fixup = device->instance->enable_mrt_output_nan_fixup ? is_float32 : 0;
+   key.mrt0_is_dual_src = pipeline->mrt0_is_dual_src;
+
+   uint32_t hash = radv_hash_ps_epilog(&key);
+
+   u_rwlock_rdlock(&device->ps_epilogs_lock);
+   struct hash_entry *epilog_entry =
+      _mesa_hash_table_search_pre_hashed(device->ps_epilogs, hash, &key);
+   u_rwlock_rdunlock(&device->ps_epilogs_lock);
+
+   if (!epilog_entry) {
+      u_rwlock_wrlock(&device->ps_epilogs_lock);
+      epilog_entry = _mesa_hash_table_search_pre_hashed(device->ps_epilogs, hash, &key);
+      if (epilog_entry) {
+         u_rwlock_wrunlock(&device->ps_epilogs_lock);
+         return epilog_entry->data;
+      }
+
+      epilog = radv_create_ps_epilog(device, &key);
+      struct radv_ps_epilog_key *key2 = malloc(sizeof(*key2));
+      if (!epilog || !key2) {
+         radv_shader_part_unref(device, epilog);
+         free(key2);
+         u_rwlock_wrunlock(&device->ps_epilogs_lock);
+         return NULL;
+      }
+      memcpy(key2, &key, sizeof(*key2));
+      _mesa_hash_table_insert_pre_hashed(device->ps_epilogs, hash, key2, epilog);
+
+      u_rwlock_wrunlock(&device->ps_epilogs_lock);
+      return epilog;
+   }
+
+   return epilog_entry->data;
+}
+
 static void
 radv_emit_msaa_state(struct radv_cmd_buffer *cmd_buffer)
 {
@@ -8465,9 +8570,25 @@ radv_emit_all_graphics_states(struct radv_cmd_buffer *cmd_buffer, const struct r
        cmd_buffer->state.emitted_graphics_pipeline != cmd_buffer->state.graphics_pipeline)
       radv_emit_binning_state(cmd_buffer, cmd_buffer->state.graphics_pipeline);
 
-   if (cmd_buffer->state.graphics_pipeline->ps_epilog)
-      radv_emit_ps_epilog_state(cmd_buffer, cmd_buffer->state.graphics_pipeline->ps_epilog,
-                                pipeline_is_dirty);
+   if (cmd_buffer->state.graphics_pipeline->base.shaders[MESA_SHADER_FRAGMENT]->info.ps.has_epilog) {
+      struct radv_shader_part *ps_epilog = NULL;
+
+      if (cmd_buffer->state.graphics_pipeline->ps_epilog) {
+         ps_epilog = cmd_buffer->state.graphics_pipeline->ps_epilog;
+      } else if ((cmd_buffer->state.emitted_graphics_pipeline != cmd_buffer->state.graphics_pipeline ||
+                 (cmd_buffer->state.dirty & (RADV_CMD_DIRTY_DYNAMIC_COLOR_WRITE_MASK |
+                                             RADV_CMD_DIRTY_DYNAMIC_COLOR_BLEND_ENABLE |
+                                             RADV_CMD_DIRTY_DYNAMIC_ALPHA_TO_COVERAGE_ENABLE)))) {
+         ps_epilog = lookup_ps_epilog(cmd_buffer);
+         if (!ps_epilog) {
+            vk_command_buffer_set_error(&cmd_buffer->vk, VK_ERROR_OUT_OF_HOST_MEMORY);
+            return;
+         }
+      }
+
+      if (ps_epilog)
+         radv_emit_ps_epilog_state(cmd_buffer, ps_epilog, pipeline_is_dirty);
+   }
 
    if (cmd_buffer->state.dirty & RADV_CMD_DIRTY_PIPELINE)
       radv_emit_graphics_pipeline(cmd_buffer);
diff --git a/src/amd/vulkan/radv_pipeline.c b/src/amd/vulkan/radv_pipeline.c
index 628266a5657a..502525aaebd8 100644
--- a/src/amd/vulkan/radv_pipeline.c
+++ b/src/amd/vulkan/radv_pipeline.c
@@ -5391,6 +5391,9 @@ radv_graphics_pipeline_init(struct radv_graphics_pipeline *pipeline, struct radv
    /* Copy the non-compacted SPI_SHADER_COL_FORMAT which is used to emit RBPLUS state. */
    pipeline->col_format_non_compacted = blend.spi_shader_col_format;
 
+   pipeline->mrt0_is_dual_src = blend.mrt0_is_dual_src;
+   pipeline->need_src_alpha = blend.need_src_alpha;
+
    struct radv_shader *ps = pipeline->base.shaders[MESA_SHADER_FRAGMENT];
    bool enable_mrt_compaction = !blend.mrt0_is_dual_src && !ps->info.ps.has_epilog;
    if (enable_mrt_compaction) {
diff --git a/src/amd/vulkan/radv_private.h b/src/amd/vulkan/radv_private.h
index 29b437c72d28..aca963f86202 100644
--- a/src/amd/vulkan/radv_private.h
+++ b/src/amd/vulkan/radv_private.h
@@ -2140,6 +2140,9 @@ struct radv_graphics_pipeline {
    /* Used for rbplus */
    uint32_t col_format_non_compacted;
 
+   bool mrt0_is_dual_src;
+   uint32_t need_src_alpha;
+
    bool disable_out_of_order_rast_for_occlusion;
    bool uses_drawid;
    bool uses_baseinstance;
-- 
GitLab


From d9462d5f408cfb9fa2ef7897b8e415112ddab929 Mon Sep 17 00:00:00 2001
From: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date: Tue, 6 Dec 2022 16:00:44 +0100
Subject: [PATCH 06/10] radv: compile PS epilogs on-demand for some dynamic
 states

These dynamic states need to compile a PS epilog on-demand for optimal
performance.

Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
---
 src/amd/vulkan/radv_pipeline.c | 26 +++++++++++++++++---------
 src/amd/vulkan/radv_shader.h   |  1 +
 2 files changed, 18 insertions(+), 9 deletions(-)

diff --git a/src/amd/vulkan/radv_pipeline.c b/src/amd/vulkan/radv_pipeline.c
index 502525aaebd8..65ef6be1a4e7 100644
--- a/src/amd/vulkan/radv_pipeline.c
+++ b/src/amd/vulkan/radv_pipeline.c
@@ -540,10 +540,7 @@ radv_pipeline_compute_spi_color_formats(const struct radv_graphics_pipeline *pip
            !(blend->cb_target_mask & (0xfu << (i * 4))))) {
          cf = V_028714_SPI_SHADER_ZERO;
       } else {
-         /* Assume blend is enabled when the state is dynamic. This might select a suboptimal format
-          * in some situations but changing color export formats dynamically is hard.
-          */
-         bool blend_enable = (pipeline->dynamic_states & RADV_DYNAMIC_COLOR_BLEND_ENABLE) ||
+         bool blend_enable = !(pipeline->dynamic_states & RADV_DYNAMIC_COLOR_BLEND_ENABLE) &&
                              blend->blend_enable_4bit & (0xfu << (i * 4));
 
          cf = radv_choose_spi_color_format(pipeline->base.device, fmt, blend_enable,
@@ -697,11 +694,10 @@ radv_pipeline_init_blend_state(struct radv_graphics_pipeline *pipeline,
    const enum amd_gfx_level gfx_level = device->physical_device->rad_info.gfx_level;
    int i;
 
-   if (state->ms && ((pipeline->dynamic_states & RADV_DYNAMIC_ALPHA_TO_COVERAGE_ENABLE) ||
-                     state->ms->alpha_to_coverage_enable)) {
+   if (state->ms && !(pipeline->dynamic_states & RADV_DYNAMIC_ALPHA_TO_COVERAGE_ENABLE) &&
+        state->ms->alpha_to_coverage_enable) {
       /* When alpha to coverage is enabled, the driver needs to select a color export format with
-       * alpha. When this state is dynamic, always select a format with alpha because it's hard to
-       * change color export formats dynamically (note that it's suboptimal).
+       * alpha.
        */
       blend.need_src_alpha |= 0x1;
    }
@@ -2762,8 +2758,16 @@ radv_generate_graphics_pipeline_key(const struct radv_graphics_pipeline *pipelin
    if (device->primitives_generated_query)
       key.primitives_generated_query = true;
 
+   if (pipeline->dynamic_states & (RADV_DYNAMIC_COLOR_BLEND_ENABLE |
+                                   RADV_DYNAMIC_COLOR_WRITE_MASK |
+                                   RADV_DYNAMIC_ALPHA_TO_COVERAGE_ENABLE)) {
+      /* These dynamic states need to compile PS epilogs on-demand. */
+      key.ps.dynamic_ps_epilog = true;
+   }
+
    key.ps.has_epilog =
-      !!(pipeline->active_stages & VK_SHADER_STAGE_FRAGMENT_BIT) && !!pipeline->ps_epilog;
+      (!!(pipeline->active_stages & VK_SHADER_STAGE_FRAGMENT_BIT) && !!pipeline->ps_epilog) ||
+      key.ps.dynamic_ps_epilog;
 
    key.dynamic_patch_control_points =
       !!(pipeline->dynamic_states & RADV_DYNAMIC_PATCH_CONTROL_POINTS);
@@ -3716,6 +3720,10 @@ radv_pipeline_create_ps_epilog(struct radv_graphics_pipeline *pipeline,
 {
    struct radv_device *device = pipeline->base.device;
 
+   /* Do not compile a PS epilog as part of the pipeline when it needs to be dynamic. */
+   if (pipeline_key->ps.dynamic_ps_epilog)
+      return true;
+
    if (pipeline->base.shaders[MESA_SHADER_FRAGMENT] &&
        pipeline->base.shaders[MESA_SHADER_FRAGMENT]->info.ps.has_epilog && !pipeline->ps_epilog) {
       pipeline->ps_epilog = radv_create_ps_epilog(device, &pipeline_key->ps.epilog);
diff --git a/src/amd/vulkan/radv_shader.h b/src/amd/vulkan/radv_shader.h
index 1723ba4bd36d..6ce0562f95be 100644
--- a/src/amd/vulkan/radv_shader.h
+++ b/src/amd/vulkan/radv_shader.h
@@ -108,6 +108,7 @@ struct radv_pipeline_key {
       /* Used to export alpha through MRTZ for alpha-to-coverage (GFX11+). */
       bool alpha_to_coverage_via_mrtz;
 
+      bool dynamic_ps_epilog;
       bool has_epilog;
    } ps;
 
-- 
GitLab


From a2569655d9736990b88a2849a80ee90ca10c50ca Mon Sep 17 00:00:00 2001
From: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date: Fri, 25 Nov 2022 09:08:08 +0100
Subject: [PATCH 07/10] radv: move some color blend helpers to radv_private.h

Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
---
 src/amd/vulkan/radv_pipeline.c | 148 +--------------------------------
 src/amd/vulkan/radv_private.h  | 144 ++++++++++++++++++++++++++++++++
 2 files changed, 148 insertions(+), 144 deletions(-)

diff --git a/src/amd/vulkan/radv_pipeline.c b/src/amd/vulkan/radv_pipeline.c
index 65ef6be1a4e7..c71ee25e9392 100644
--- a/src/amd/vulkan/radv_pipeline.c
+++ b/src/amd/vulkan/radv_pipeline.c
@@ -308,128 +308,11 @@ radv_pipeline_init_scratch(const struct radv_device *device, struct radv_pipelin
    pipeline->max_waves = max_waves;
 }
 
-static uint32_t
-si_translate_blend_function(VkBlendOp op)
-{
-   switch (op) {
-   case VK_BLEND_OP_ADD:
-      return V_028780_COMB_DST_PLUS_SRC;
-   case VK_BLEND_OP_SUBTRACT:
-      return V_028780_COMB_SRC_MINUS_DST;
-   case VK_BLEND_OP_REVERSE_SUBTRACT:
-      return V_028780_COMB_DST_MINUS_SRC;
-   case VK_BLEND_OP_MIN:
-      return V_028780_COMB_MIN_DST_SRC;
-   case VK_BLEND_OP_MAX:
-      return V_028780_COMB_MAX_DST_SRC;
-   default:
-      return 0;
-   }
-}
-
-static uint32_t
-si_translate_blend_factor(enum amd_gfx_level gfx_level, VkBlendFactor factor)
-{
-   switch (factor) {
-   case VK_BLEND_FACTOR_ZERO:
-      return V_028780_BLEND_ZERO;
-   case VK_BLEND_FACTOR_ONE:
-      return V_028780_BLEND_ONE;
-   case VK_BLEND_FACTOR_SRC_COLOR:
-      return V_028780_BLEND_SRC_COLOR;
-   case VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR:
-      return V_028780_BLEND_ONE_MINUS_SRC_COLOR;
-   case VK_BLEND_FACTOR_DST_COLOR:
-      return V_028780_BLEND_DST_COLOR;
-   case VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR:
-      return V_028780_BLEND_ONE_MINUS_DST_COLOR;
-   case VK_BLEND_FACTOR_SRC_ALPHA:
-      return V_028780_BLEND_SRC_ALPHA;
-   case VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA:
-      return V_028780_BLEND_ONE_MINUS_SRC_ALPHA;
-   case VK_BLEND_FACTOR_DST_ALPHA:
-      return V_028780_BLEND_DST_ALPHA;
-   case VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA:
-      return V_028780_BLEND_ONE_MINUS_DST_ALPHA;
-   case VK_BLEND_FACTOR_CONSTANT_COLOR:
-      return gfx_level >= GFX11 ? V_028780_BLEND_CONSTANT_COLOR_GFX11
-                                : V_028780_BLEND_CONSTANT_COLOR_GFX6;
-   case VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR:
-      return gfx_level >= GFX11 ? V_028780_BLEND_ONE_MINUS_CONSTANT_COLOR_GFX11
-                                 : V_028780_BLEND_ONE_MINUS_CONSTANT_COLOR_GFX6;
-   case VK_BLEND_FACTOR_CONSTANT_ALPHA:
-      return gfx_level >= GFX11 ? V_028780_BLEND_CONSTANT_ALPHA_GFX11
-                                 : V_028780_BLEND_CONSTANT_ALPHA_GFX6;
-   case VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA:
-      return gfx_level >= GFX11 ? V_028780_BLEND_ONE_MINUS_CONSTANT_ALPHA_GFX11
-                                 : V_028780_BLEND_ONE_MINUS_CONSTANT_ALPHA_GFX6;
-   case VK_BLEND_FACTOR_SRC_ALPHA_SATURATE:
-      return V_028780_BLEND_SRC_ALPHA_SATURATE;
-   case VK_BLEND_FACTOR_SRC1_COLOR:
-      return gfx_level >= GFX11 ? V_028780_BLEND_SRC1_COLOR_GFX11 : V_028780_BLEND_SRC1_COLOR_GFX6;
-   case VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR:
-      return gfx_level >= GFX11 ? V_028780_BLEND_INV_SRC1_COLOR_GFX11
-                                 : V_028780_BLEND_INV_SRC1_COLOR_GFX6;
-   case VK_BLEND_FACTOR_SRC1_ALPHA:
-      return gfx_level >= GFX11 ? V_028780_BLEND_SRC1_ALPHA_GFX11 : V_028780_BLEND_SRC1_ALPHA_GFX6;
-   case VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA:
-      return gfx_level >= GFX11 ? V_028780_BLEND_INV_SRC1_ALPHA_GFX11
-                                 : V_028780_BLEND_INV_SRC1_ALPHA_GFX6;
-   default:
-      return 0;
-   }
-}
-
-static uint32_t
-si_translate_blend_opt_function(VkBlendOp op)
-{
-   switch (op) {
-   case VK_BLEND_OP_ADD:
-      return V_028760_OPT_COMB_ADD;
-   case VK_BLEND_OP_SUBTRACT:
-      return V_028760_OPT_COMB_SUBTRACT;
-   case VK_BLEND_OP_REVERSE_SUBTRACT:
-      return V_028760_OPT_COMB_REVSUBTRACT;
-   case VK_BLEND_OP_MIN:
-      return V_028760_OPT_COMB_MIN;
-   case VK_BLEND_OP_MAX:
-      return V_028760_OPT_COMB_MAX;
-   default:
-      return V_028760_OPT_COMB_BLEND_DISABLED;
-   }
-}
-
-static uint32_t
-si_translate_blend_opt_factor(VkBlendFactor factor, bool is_alpha)
-{
-   switch (factor) {
-   case VK_BLEND_FACTOR_ZERO:
-      return V_028760_BLEND_OPT_PRESERVE_NONE_IGNORE_ALL;
-   case VK_BLEND_FACTOR_ONE:
-      return V_028760_BLEND_OPT_PRESERVE_ALL_IGNORE_NONE;
-   case VK_BLEND_FACTOR_SRC_COLOR:
-      return is_alpha ? V_028760_BLEND_OPT_PRESERVE_A1_IGNORE_A0
-                      : V_028760_BLEND_OPT_PRESERVE_C1_IGNORE_C0;
-   case VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR:
-      return is_alpha ? V_028760_BLEND_OPT_PRESERVE_A0_IGNORE_A1
-                      : V_028760_BLEND_OPT_PRESERVE_C0_IGNORE_C1;
-   case VK_BLEND_FACTOR_SRC_ALPHA:
-      return V_028760_BLEND_OPT_PRESERVE_A1_IGNORE_A0;
-   case VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA:
-      return V_028760_BLEND_OPT_PRESERVE_A0_IGNORE_A1;
-   case VK_BLEND_FACTOR_SRC_ALPHA_SATURATE:
-      return is_alpha ? V_028760_BLEND_OPT_PRESERVE_ALL_IGNORE_NONE
-                      : V_028760_BLEND_OPT_PRESERVE_NONE_IGNORE_A0;
-   default:
-      return V_028760_BLEND_OPT_PRESERVE_NONE_IGNORE_NONE;
-   }
-}
-
 /**
  * Get rid of DST in the blend factors by commuting the operands:
  *    func(src * DST, dst * 0) ---> func(src * 0, dst * SRC)
  */
-static void
+void
 si_blend_remove_dst(VkBlendOp *func, VkBlendFactor *src_factor, VkBlendFactor *dst_factor,
                     VkBlendFactor expected_dst, VkBlendFactor replacement_src)
 {
@@ -445,29 +328,6 @@ si_blend_remove_dst(VkBlendOp *func, VkBlendFactor *src_factor, VkBlendFactor *d
    }
 }
 
-static bool
-si_blend_factor_uses_dst(VkBlendFactor factor)
-{
-   return factor == VK_BLEND_FACTOR_DST_COLOR || factor == VK_BLEND_FACTOR_DST_ALPHA ||
-          factor == VK_BLEND_FACTOR_SRC_ALPHA_SATURATE ||
-          factor == VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA ||
-          factor == VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR;
-}
-
-static bool
-is_dual_src(VkBlendFactor factor)
-{
-   switch (factor) {
-   case VK_BLEND_FACTOR_SRC1_COLOR:
-   case VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR:
-   case VK_BLEND_FACTOR_SRC1_ALPHA:
-   case VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA:
-      return true;
-   default:
-      return false;
-   }
-}
-
 unsigned
 radv_choose_spi_color_format(const struct radv_device *device, VkFormat vk_format,
                              bool blend_enable, bool blend_need_alpha)
@@ -664,7 +524,7 @@ radv_blend_check_commutativity(struct radv_blend_state *blend, VkBlendOp op, VkB
    }
 }
 
-static bool
+bool
 radv_can_enable_dual_src(const struct vk_color_blend_attachment_state *att)
 {
    VkBlendOp eqRGB = att->color_blend_op;
@@ -676,9 +536,9 @@ radv_can_enable_dual_src(const struct vk_color_blend_attachment_state *att)
    bool eqRGB_minmax = eqRGB == VK_BLEND_OP_MIN || eqRGB == VK_BLEND_OP_MAX;
    bool eqA_minmax = eqA == VK_BLEND_OP_MIN || eqA == VK_BLEND_OP_MAX;
 
-   if (!eqRGB_minmax && (is_dual_src(srcRGB) || is_dual_src(dstRGB)))
+   if (!eqRGB_minmax && (radv_is_dual_src(srcRGB) || radv_is_dual_src(dstRGB)))
       return true;
-   if (!eqA_minmax && (is_dual_src(srcA) || is_dual_src(dstA)))
+   if (!eqA_minmax && (radv_is_dual_src(srcA) || radv_is_dual_src(dstA)))
       return true;
    return false;
 }
diff --git a/src/amd/vulkan/radv_private.h b/src/amd/vulkan/radv_private.h
index aca963f86202..7f6901e6921c 100644
--- a/src/amd/vulkan/radv_private.h
+++ b/src/amd/vulkan/radv_private.h
@@ -3204,6 +3204,148 @@ si_translate_blend_logic_op(VkLogicOp op)
    }
 }
 
+static inline uint32_t
+si_translate_blend_function(VkBlendOp op)
+{
+   switch (op) {
+   case VK_BLEND_OP_ADD:
+      return V_028780_COMB_DST_PLUS_SRC;
+   case VK_BLEND_OP_SUBTRACT:
+      return V_028780_COMB_SRC_MINUS_DST;
+   case VK_BLEND_OP_REVERSE_SUBTRACT:
+      return V_028780_COMB_DST_MINUS_SRC;
+   case VK_BLEND_OP_MIN:
+      return V_028780_COMB_MIN_DST_SRC;
+   case VK_BLEND_OP_MAX:
+      return V_028780_COMB_MAX_DST_SRC;
+   default:
+      return 0;
+   }
+}
+
+static inline uint32_t
+si_translate_blend_factor(enum amd_gfx_level gfx_level, VkBlendFactor factor)
+{
+   switch (factor) {
+   case VK_BLEND_FACTOR_ZERO:
+      return V_028780_BLEND_ZERO;
+   case VK_BLEND_FACTOR_ONE:
+      return V_028780_BLEND_ONE;
+   case VK_BLEND_FACTOR_SRC_COLOR:
+      return V_028780_BLEND_SRC_COLOR;
+   case VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR:
+      return V_028780_BLEND_ONE_MINUS_SRC_COLOR;
+   case VK_BLEND_FACTOR_DST_COLOR:
+      return V_028780_BLEND_DST_COLOR;
+   case VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR:
+      return V_028780_BLEND_ONE_MINUS_DST_COLOR;
+   case VK_BLEND_FACTOR_SRC_ALPHA:
+      return V_028780_BLEND_SRC_ALPHA;
+   case VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA:
+      return V_028780_BLEND_ONE_MINUS_SRC_ALPHA;
+   case VK_BLEND_FACTOR_DST_ALPHA:
+      return V_028780_BLEND_DST_ALPHA;
+   case VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA:
+      return V_028780_BLEND_ONE_MINUS_DST_ALPHA;
+   case VK_BLEND_FACTOR_CONSTANT_COLOR:
+      return gfx_level >= GFX11 ? V_028780_BLEND_CONSTANT_COLOR_GFX11
+                                : V_028780_BLEND_CONSTANT_COLOR_GFX6;
+   case VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR:
+      return gfx_level >= GFX11 ? V_028780_BLEND_ONE_MINUS_CONSTANT_COLOR_GFX11
+                                 : V_028780_BLEND_ONE_MINUS_CONSTANT_COLOR_GFX6;
+   case VK_BLEND_FACTOR_CONSTANT_ALPHA:
+      return gfx_level >= GFX11 ? V_028780_BLEND_CONSTANT_ALPHA_GFX11
+                                 : V_028780_BLEND_CONSTANT_ALPHA_GFX6;
+   case VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA:
+      return gfx_level >= GFX11 ? V_028780_BLEND_ONE_MINUS_CONSTANT_ALPHA_GFX11
+                                 : V_028780_BLEND_ONE_MINUS_CONSTANT_ALPHA_GFX6;
+   case VK_BLEND_FACTOR_SRC_ALPHA_SATURATE:
+      return V_028780_BLEND_SRC_ALPHA_SATURATE;
+   case VK_BLEND_FACTOR_SRC1_COLOR:
+      return gfx_level >= GFX11 ? V_028780_BLEND_SRC1_COLOR_GFX11 : V_028780_BLEND_SRC1_COLOR_GFX6;
+   case VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR:
+      return gfx_level >= GFX11 ? V_028780_BLEND_INV_SRC1_COLOR_GFX11
+                                 : V_028780_BLEND_INV_SRC1_COLOR_GFX6;
+   case VK_BLEND_FACTOR_SRC1_ALPHA:
+      return gfx_level >= GFX11 ? V_028780_BLEND_SRC1_ALPHA_GFX11 : V_028780_BLEND_SRC1_ALPHA_GFX6;
+   case VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA:
+      return gfx_level >= GFX11 ? V_028780_BLEND_INV_SRC1_ALPHA_GFX11
+                                 : V_028780_BLEND_INV_SRC1_ALPHA_GFX6;
+   default:
+      return 0;
+   }
+}
+
+static inline uint32_t
+si_translate_blend_opt_factor(VkBlendFactor factor, bool is_alpha)
+{
+   switch (factor) {
+   case VK_BLEND_FACTOR_ZERO:
+      return V_028760_BLEND_OPT_PRESERVE_NONE_IGNORE_ALL;
+   case VK_BLEND_FACTOR_ONE:
+      return V_028760_BLEND_OPT_PRESERVE_ALL_IGNORE_NONE;
+   case VK_BLEND_FACTOR_SRC_COLOR:
+      return is_alpha ? V_028760_BLEND_OPT_PRESERVE_A1_IGNORE_A0
+                      : V_028760_BLEND_OPT_PRESERVE_C1_IGNORE_C0;
+   case VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR:
+      return is_alpha ? V_028760_BLEND_OPT_PRESERVE_A0_IGNORE_A1
+                      : V_028760_BLEND_OPT_PRESERVE_C0_IGNORE_C1;
+   case VK_BLEND_FACTOR_SRC_ALPHA:
+      return V_028760_BLEND_OPT_PRESERVE_A1_IGNORE_A0;
+   case VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA:
+      return V_028760_BLEND_OPT_PRESERVE_A0_IGNORE_A1;
+   case VK_BLEND_FACTOR_SRC_ALPHA_SATURATE:
+      return is_alpha ? V_028760_BLEND_OPT_PRESERVE_ALL_IGNORE_NONE
+                      : V_028760_BLEND_OPT_PRESERVE_NONE_IGNORE_A0;
+   default:
+      return V_028760_BLEND_OPT_PRESERVE_NONE_IGNORE_NONE;
+   }
+}
+
+static inline uint32_t
+si_translate_blend_opt_function(VkBlendOp op)
+{
+   switch (op) {
+   case VK_BLEND_OP_ADD:
+      return V_028760_OPT_COMB_ADD;
+   case VK_BLEND_OP_SUBTRACT:
+      return V_028760_OPT_COMB_SUBTRACT;
+   case VK_BLEND_OP_REVERSE_SUBTRACT:
+      return V_028760_OPT_COMB_REVSUBTRACT;
+   case VK_BLEND_OP_MIN:
+      return V_028760_OPT_COMB_MIN;
+   case VK_BLEND_OP_MAX:
+      return V_028760_OPT_COMB_MAX;
+   default:
+      return V_028760_OPT_COMB_BLEND_DISABLED;
+   }
+}
+
+static inline bool
+si_blend_factor_uses_dst(VkBlendFactor factor)
+{
+   return factor == VK_BLEND_FACTOR_DST_COLOR || factor == VK_BLEND_FACTOR_DST_ALPHA ||
+          factor == VK_BLEND_FACTOR_SRC_ALPHA_SATURATE ||
+          factor == VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA ||
+          factor == VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR;
+}
+
+static inline bool
+radv_is_dual_src(VkBlendFactor factor)
+{
+   switch (factor) {
+   case VK_BLEND_FACTOR_SRC1_COLOR:
+   case VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR:
+   case VK_BLEND_FACTOR_SRC1_ALPHA:
+   case VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA:
+      return true;
+   default:
+      return false;
+   }
+}
+void si_blend_remove_dst(VkBlendOp *func, VkBlendFactor *src_factor, VkBlendFactor *dst_factor,
+                         VkBlendFactor expected_dst, VkBlendFactor replacement_src);
+
 uint32_t radv_get_tess_output_topology(const struct radv_graphics_pipeline *pipeline,
                                        VkTessellationDomainOrigin domain_origin);
 
@@ -3294,6 +3436,8 @@ radv_format_is_float32(VkFormat format)
 unsigned radv_choose_spi_color_format(const struct radv_device *device, VkFormat vk_format,
                                       bool blend_enable, bool blend_need_alpha);
 
+bool radv_can_enable_dual_src(const struct vk_color_blend_attachment_state *att);
+
 #define RADV_FROM_HANDLE(__radv_type, __name, __handle) \
    VK_FROM_HANDLE(__radv_type, __name, __handle)
 
-- 
GitLab


From 24a3fb5aaa90baa0a0a047cf3d8d2fd215663e58 Mon Sep 17 00:00:00 2001
From: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date: Fri, 25 Nov 2022 09:09:32 +0100
Subject: [PATCH 08/10] radv: add support for dynamic blend equation

Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
---
 src/amd/vulkan/radv_cmd_buffer.c | 221 ++++++++++++++++++++++++++-----
 src/amd/vulkan/radv_pipeline.c   |  69 +++-------
 src/amd/vulkan/radv_private.h    |  32 +++--
 3 files changed, 228 insertions(+), 94 deletions(-)

diff --git a/src/amd/vulkan/radv_cmd_buffer.c b/src/amd/vulkan/radv_cmd_buffer.c
index 6f78326aac03..ecc3cd084461 100644
--- a/src/amd/vulkan/radv_cmd_buffer.c
+++ b/src/amd/vulkan/radv_cmd_buffer.c
@@ -206,6 +206,14 @@ radv_bind_dynamic_state(struct radv_cmd_buffer *cmd_buffer, const struct radv_dy
       }
    }
 
+   if (copy_mask & RADV_DYNAMIC_COLOR_BLEND_EQUATION) {
+      if (memcmp(&dest->color_blend_equation, &src->color_blend_equation,
+                 sizeof(src->color_blend_equation))) {
+         typed_memcpy(dest->color_blend_equation, src->color_blend_equation, MAX_RTS);
+         dest_mask |= RADV_DYNAMIC_COLOR_BLEND_EQUATION;
+      }
+   }
+
 #define RADV_CMP_COPY(field, flag)                                \
    if (copy_mask & flag) {                                        \
       if (dest->field != src->field) {                            \
@@ -1926,7 +1934,8 @@ radv_emit_graphics_pipeline(struct radv_cmd_buffer *cmd_buffer)
                                  RADV_CMD_DIRTY_DYNAMIC_DEPTH_CLAMP_ENABLE |
                                  RADV_CMD_DIRTY_DYNAMIC_COLOR_WRITE_ENABLE |
                                  RADV_CMD_DIRTY_DYNAMIC_LINE_STIPPLE_ENABLE |
-                                 RADV_CMD_DIRTY_DYNAMIC_CONSERVATIVE_RAST_MODE;
+                                 RADV_CMD_DIRTY_DYNAMIC_CONSERVATIVE_RAST_MODE |
+                                 RADV_CMD_DIRTY_DYNAMIC_COLOR_BLEND_ENABLE;
 
    if (!cmd_buffer->state.emitted_graphics_pipeline ||
        radv_rast_prim_is_points_or_lines(cmd_buffer->state.emitted_graphics_pipeline->rast_prim) != radv_rast_prim_is_points_or_lines(pipeline->rast_prim))
@@ -1942,13 +1951,6 @@ radv_emit_graphics_pipeline(struct radv_cmd_buffer *cmd_buffer)
        cmd_buffer->state.emitted_graphics_pipeline->vgt_tf_param != pipeline->vgt_tf_param)
       cmd_buffer->state.dirty |= RADV_CMD_DIRTY_DYNAMIC_TESS_DOMAIN_ORIGIN;
 
-   if (!cmd_buffer->state.emitted_graphics_pipeline ||
-       memcmp(cmd_buffer->state.emitted_graphics_pipeline->cb_blend_control,
-              pipeline->cb_blend_control, sizeof(pipeline->cb_blend_control)) ||
-       memcmp(cmd_buffer->state.emitted_graphics_pipeline->sx_mrt_blend_opt,
-              pipeline->sx_mrt_blend_opt, sizeof(pipeline->sx_mrt_blend_opt)))
-      cmd_buffer->state.dirty |= RADV_CMD_DIRTY_DYNAMIC_COLOR_BLEND_ENABLE;
-
    if (!cmd_buffer->state.emitted_graphics_pipeline ||
        cmd_buffer->state.emitted_graphics_pipeline->ms.sample_shading_enable != pipeline->ms.sample_shading_enable ||
        cmd_buffer->state.emitted_graphics_pipeline->ms.min_sample_shading != pipeline->ms.min_sample_shading ||
@@ -4019,29 +4021,115 @@ radv_emit_sample_mask(struct radv_cmd_buffer *cmd_buffer)
 }
 
 static void
-radv_emit_color_blend_enable(struct radv_cmd_buffer *cmd_buffer)
+radv_emit_color_blend(struct radv_cmd_buffer *cmd_buffer)
 {
    const struct radv_physical_device *pdevice = cmd_buffer->device->physical_device;
-   const struct radv_graphics_pipeline *pipeline = cmd_buffer->state.graphics_pipeline;
+   const enum amd_gfx_level gfx_level = pdevice->rad_info.gfx_level;
    const struct radv_dynamic_state *d = &cmd_buffer->state.dynamic;
    unsigned cb_blend_control[MAX_RTS], sx_mrt_blend_opt[MAX_RTS];
+   bool mrt0_is_dual_src = false;
 
    for (unsigned i = 0; i < MAX_RTS; i++) {
-      bool blend_enable = (d->color_blend_enable >> (i * 4)) & 0xf;
-
-      cb_blend_control[i] = pipeline->cb_blend_control[i];
-      sx_mrt_blend_opt[i] = pipeline->sx_mrt_blend_opt[i];
-
-      if (blend_enable) {
-         cb_blend_control[i] |= S_028780_ENABLE(1);
-      } else if (pdevice->rad_info.has_rbplus) {
-         /* Make sure to keep RB+ blend optimizations disabled for dual source blending. */
-         if (G_028760_COLOR_COMB_FCN(sx_mrt_blend_opt[i]) != V_028760_OPT_COMB_NONE &&
-             G_028760_ALPHA_COMB_FCN(sx_mrt_blend_opt[i]) != V_028760_OPT_COMB_NONE) {
-            sx_mrt_blend_opt[i] &= C_028760_COLOR_COMB_FCN;
-            sx_mrt_blend_opt[i] &= C_028760_ALPHA_COMB_FCN;
-            sx_mrt_blend_opt[i] |= S_028760_COLOR_COMB_FCN(V_028760_OPT_COMB_BLEND_DISABLED) |
-                                   S_028760_ALPHA_COMB_FCN(V_028760_OPT_COMB_BLEND_DISABLED);
+      VkBlendOp eqRGB = d->color_blend_equation[i].color_blend_op;
+      VkBlendFactor srcRGB = d->color_blend_equation[i].src_color_blend_factor;
+      VkBlendFactor dstRGB = d->color_blend_equation[i].dst_color_blend_factor;
+      VkBlendOp eqA = d->color_blend_equation[i].alpha_blend_op;
+      VkBlendFactor srcA = d->color_blend_equation[i].src_alpha_blend_factor;
+      VkBlendFactor dstA = d->color_blend_equation[i].dst_alpha_blend_factor;
+      unsigned srcRGB_opt, dstRGB_opt, srcA_opt, dstA_opt;
+
+      cb_blend_control[i] = sx_mrt_blend_opt[i] = 0;
+
+      /* Ignore other targets if dual-source blending is enabled to prevent wrong behaviour. */
+      if (mrt0_is_dual_src)
+         continue;
+
+      if (!((d->color_blend_enable >> (i * 4)) & 0xf)) {
+         sx_mrt_blend_opt[i] |= S_028760_COLOR_COMB_FCN(V_028760_OPT_COMB_BLEND_DISABLED) |
+                                S_028760_ALPHA_COMB_FCN(V_028760_OPT_COMB_BLEND_DISABLED);
+         continue;
+      }
+
+      const struct vk_color_blend_attachment_state att = {
+         .color_blend_op = d->color_blend_equation[i].color_blend_op,
+         .src_color_blend_factor = d->color_blend_equation[i].src_color_blend_factor,
+         .dst_color_blend_factor = d->color_blend_equation[i].dst_color_blend_factor,
+         .alpha_blend_op = d->color_blend_equation[i].alpha_blend_op,
+         .src_alpha_blend_factor = d->color_blend_equation[i].src_alpha_blend_factor,
+         .dst_alpha_blend_factor = d->color_blend_equation[i].dst_alpha_blend_factor,
+      };
+
+      if (i == 0 && radv_can_enable_dual_src(&att)) {
+         mrt0_is_dual_src = true;
+      }
+
+      if (eqRGB == VK_BLEND_OP_MIN || eqRGB == VK_BLEND_OP_MAX) {
+         srcRGB = VK_BLEND_FACTOR_ONE;
+         dstRGB = VK_BLEND_FACTOR_ONE;
+      }
+
+      if (eqA == VK_BLEND_OP_MIN || eqA == VK_BLEND_OP_MAX) {
+         srcA = VK_BLEND_FACTOR_ONE;
+         dstA = VK_BLEND_FACTOR_ONE;
+      }
+
+      /* Blending optimizations for RB+.
+       * These transformations don't change the behavior.
+       *
+       * First, get rid of DST in the blend factors:
+       *    func(src * DST, dst * 0) ---> func(src * 0, dst * SRC)
+       */
+      si_blend_remove_dst(&eqRGB, &srcRGB, &dstRGB, VK_BLEND_FACTOR_DST_COLOR,
+                          VK_BLEND_FACTOR_SRC_COLOR);
+
+      si_blend_remove_dst(&eqA, &srcA, &dstA, VK_BLEND_FACTOR_DST_COLOR,
+                          VK_BLEND_FACTOR_SRC_COLOR);
+
+      si_blend_remove_dst(&eqA, &srcA, &dstA, VK_BLEND_FACTOR_DST_ALPHA,
+                          VK_BLEND_FACTOR_SRC_ALPHA);
+
+      /* Look up the ideal settings from tables. */
+      srcRGB_opt = si_translate_blend_opt_factor(srcRGB, false);
+      dstRGB_opt = si_translate_blend_opt_factor(dstRGB, false);
+      srcA_opt = si_translate_blend_opt_factor(srcA, true);
+      dstA_opt = si_translate_blend_opt_factor(dstA, true);
+
+      /* Handle interdependencies. */
+      if (si_blend_factor_uses_dst(srcRGB))
+         dstRGB_opt = V_028760_BLEND_OPT_PRESERVE_NONE_IGNORE_NONE;
+      if (si_blend_factor_uses_dst(srcA))
+         dstA_opt = V_028760_BLEND_OPT_PRESERVE_NONE_IGNORE_NONE;
+
+      if (srcRGB == VK_BLEND_FACTOR_SRC_ALPHA_SATURATE &&
+          (dstRGB == VK_BLEND_FACTOR_ZERO || dstRGB == VK_BLEND_FACTOR_SRC_ALPHA ||
+           dstRGB == VK_BLEND_FACTOR_SRC_ALPHA_SATURATE))
+         dstRGB_opt = V_028760_BLEND_OPT_PRESERVE_NONE_IGNORE_A0;
+
+      /* Set the final value. */
+      sx_mrt_blend_opt[i] = S_028760_COLOR_SRC_OPT(srcRGB_opt) | S_028760_COLOR_DST_OPT(dstRGB_opt) |
+                            S_028760_COLOR_COMB_FCN(si_translate_blend_opt_function(eqRGB)) |
+                            S_028760_ALPHA_SRC_OPT(srcA_opt) | S_028760_ALPHA_DST_OPT(dstA_opt) |
+                            S_028760_ALPHA_COMB_FCN(si_translate_blend_opt_function(eqA));
+
+      cb_blend_control[i] = S_028780_ENABLE(1) |
+                            S_028780_COLOR_COMB_FCN(si_translate_blend_function(eqRGB)) |
+                            S_028780_COLOR_SRCBLEND(si_translate_blend_factor(gfx_level, srcRGB)) |
+                            S_028780_COLOR_DESTBLEND(si_translate_blend_factor(gfx_level, dstRGB));
+
+      if (srcA != srcRGB || dstA != dstRGB || eqA != eqRGB) {
+         cb_blend_control[i] |= S_028780_SEPARATE_ALPHA_BLEND(1);
+         cb_blend_control[i] |= S_028780_ALPHA_COMB_FCN(si_translate_blend_function(eqA));
+         cb_blend_control[i] |= S_028780_ALPHA_SRCBLEND(si_translate_blend_factor(gfx_level, srcA));
+         cb_blend_control[i] |= S_028780_ALPHA_DESTBLEND(si_translate_blend_factor(gfx_level, dstA));
+      }
+   }
+
+   if (pdevice->rad_info.has_rbplus) {
+      /* Disable RB+ blend optimizations for dual source blending. */
+      if (mrt0_is_dual_src) {
+         for (unsigned i = 0; i < 8; i++) {
+            sx_mrt_blend_opt[i] = S_028760_COLOR_COMB_FCN(V_028760_OPT_COMB_NONE) |
+                                  S_028760_ALPHA_COMB_FCN(V_028760_OPT_COMB_NONE);
          }
       }
    }
@@ -4073,18 +4161,58 @@ radv_cmp_ps_epilog(const void *a_, const void *b_)
 static struct radv_shader_part *
 lookup_ps_epilog(struct radv_cmd_buffer *cmd_buffer)
 {
-   const struct radv_graphics_pipeline *pipeline = cmd_buffer->state.graphics_pipeline;
    const struct radv_rendering_state *render = &cmd_buffer->state.render;
    const struct radv_dynamic_state *d = &cmd_buffer->state.dynamic;
-   uint32_t need_src_alpha = pipeline->need_src_alpha;
    struct radv_device *device = cmd_buffer->device;
    struct radv_shader_part *epilog = NULL;
+   bool mrt0_is_dual_src = false;
+   uint8_t need_src_alpha = 0;
 
    if (d->alpha_to_coverage_enable) {
       /* Select a color export format with alpha when alpha to coverage is enabled. */
       need_src_alpha |= 0x1;
    }
 
+   for (unsigned i = 0; i < MAX_RTS; i++) {
+      VkBlendOp eqRGB = d->color_blend_equation[i].color_blend_op;
+      VkBlendFactor srcRGB = d->color_blend_equation[i].src_color_blend_factor;
+      VkBlendFactor dstRGB = d->color_blend_equation[i].dst_color_blend_factor;
+
+      /* Ignore other targets if dual-source blending is enabled to prevent wrong behaviour. */
+      if (mrt0_is_dual_src)
+         continue;
+
+      if (!((d->color_blend_enable >> (i * 4)) & 0xf))
+         continue;
+
+      const struct vk_color_blend_attachment_state att = {
+         .color_blend_op = d->color_blend_equation[i].color_blend_op,
+         .src_color_blend_factor = d->color_blend_equation[i].src_color_blend_factor,
+         .dst_color_blend_factor = d->color_blend_equation[i].dst_color_blend_factor,
+         .alpha_blend_op = d->color_blend_equation[i].alpha_blend_op,
+         .src_alpha_blend_factor = d->color_blend_equation[i].src_alpha_blend_factor,
+         .dst_alpha_blend_factor = d->color_blend_equation[i].dst_alpha_blend_factor,
+      };
+
+      if (i == 0 && radv_can_enable_dual_src(&att)) {
+         mrt0_is_dual_src = true;
+      }
+
+      if (eqRGB == VK_BLEND_OP_MIN || eqRGB == VK_BLEND_OP_MAX) {
+         srcRGB = VK_BLEND_FACTOR_ONE;
+         dstRGB = VK_BLEND_FACTOR_ONE;
+      }
+
+      if (srcRGB == VK_BLEND_FACTOR_SRC_ALPHA ||
+          dstRGB == VK_BLEND_FACTOR_SRC_ALPHA ||
+          srcRGB == VK_BLEND_FACTOR_SRC_ALPHA_SATURATE ||
+          dstRGB == VK_BLEND_FACTOR_SRC_ALPHA_SATURATE ||
+          srcRGB == VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA ||
+          dstRGB == VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA) {
+         need_src_alpha |= 1 << i;
+      }
+   }
+
    unsigned col_format = 0, is_int8 = 0, is_int10 = 0, is_float32 = 0;
    for (unsigned i = 0; i < render->color_att_count; ++i) {
       struct radv_image_view *iview = render->color_att[i].iview;
@@ -4130,7 +4258,7 @@ lookup_ps_epilog(struct radv_cmd_buffer *cmd_buffer)
    }
 
    /* The output for dual source blending should have the same format as the first output. */
-   if (pipeline->mrt0_is_dual_src) {
+   if (mrt0_is_dual_src) {
       assert(!(col_format >> 4));
       col_format |= (col_format & 0xf) << 4;
    }
@@ -4140,7 +4268,7 @@ lookup_ps_epilog(struct radv_cmd_buffer *cmd_buffer)
    key.color_is_int8 = device->physical_device->rad_info.gfx_level < GFX8 ? is_int8 : 0;
    key.color_is_int10 = device->physical_device->rad_info.gfx_level < GFX8 ? is_int10 : 0;
    key.enable_mrt_output_nan_fixup = device->instance->enable_mrt_output_nan_fixup ? is_float32 : 0;
-   key.mrt0_is_dual_src = pipeline->mrt0_is_dual_src;
+   key.mrt0_is_dual_src = mrt0_is_dual_src;
 
    uint32_t hash = radv_hash_ps_epilog(&key);
 
@@ -4348,8 +4476,9 @@ radv_cmd_buffer_flush_dynamic_state(struct radv_cmd_buffer *cmd_buffer, bool pip
                  RADV_CMD_DIRTY_DYNAMIC_DEPTH_CLIP_ENABLE))
       radv_emit_depth_clamp_enable(cmd_buffer);
 
-   if (states & RADV_CMD_DIRTY_DYNAMIC_COLOR_BLEND_ENABLE)
-      radv_emit_color_blend_enable(cmd_buffer);
+   if (states & (RADV_CMD_DIRTY_DYNAMIC_COLOR_BLEND_ENABLE |
+                 RADV_CMD_DIRTY_DYNAMIC_COLOR_BLEND_EQUATION))
+      radv_emit_color_blend(cmd_buffer);
 
    if (states & (RADV_CMD_DIRTY_DYNAMIC_RASTERIZATION_SAMPLES |
                  RADV_CMD_DIRTY_DYNAMIC_LINE_RASTERIZATION_MODE))
@@ -7015,6 +7144,35 @@ radv_CmdSetLineRasterizationModeEXT(VkCommandBuffer commandBuffer,
    state->dirty |= RADV_CMD_DIRTY_DYNAMIC_LINE_RASTERIZATION_MODE;
 }
 
+VKAPI_ATTR void VKAPI_CALL
+radv_CmdSetColorBlendEquationEXT(VkCommandBuffer commandBuffer, uint32_t firstAttachment,
+                                 uint32_t attachmentCount,
+                                 const VkColorBlendEquationEXT *pColorBlendEquations)
+{
+   RADV_FROM_HANDLE(radv_cmd_buffer, cmd_buffer, commandBuffer);
+   struct radv_cmd_state *state = &cmd_buffer->state;
+
+   assert(firstAttachment + attachmentCount <= MAX_RTS);
+   for (uint32_t i = 0; i < attachmentCount; i++) {
+      unsigned idx = firstAttachment + i;
+
+      state->dynamic.color_blend_equation[idx].src_color_blend_factor =
+         pColorBlendEquations[i].srcColorBlendFactor;
+      state->dynamic.color_blend_equation[idx].dst_color_blend_factor =
+         pColorBlendEquations[i].dstColorBlendFactor;
+      state->dynamic.color_blend_equation[idx].color_blend_op =
+         pColorBlendEquations[i].colorBlendOp;
+      state->dynamic.color_blend_equation[idx].src_alpha_blend_factor =
+         pColorBlendEquations[i].srcAlphaBlendFactor;
+      state->dynamic.color_blend_equation[idx].dst_alpha_blend_factor =
+         pColorBlendEquations[i].dstAlphaBlendFactor;
+      state->dynamic.color_blend_equation[idx].alpha_blend_op =
+         pColorBlendEquations[i].alphaBlendOp;
+   }
+
+   state->dirty |= RADV_CMD_DIRTY_DYNAMIC_COLOR_BLEND_EQUATION;
+}
+
 VKAPI_ATTR void VKAPI_CALL
 radv_CmdExecuteCommands(VkCommandBuffer commandBuffer, uint32_t commandBufferCount,
                         const VkCommandBuffer *pCmdBuffers)
@@ -8578,6 +8736,7 @@ radv_emit_all_graphics_states(struct radv_cmd_buffer *cmd_buffer, const struct r
       } else if ((cmd_buffer->state.emitted_graphics_pipeline != cmd_buffer->state.graphics_pipeline ||
                  (cmd_buffer->state.dirty & (RADV_CMD_DIRTY_DYNAMIC_COLOR_WRITE_MASK |
                                              RADV_CMD_DIRTY_DYNAMIC_COLOR_BLEND_ENABLE |
+                                             RADV_CMD_DIRTY_DYNAMIC_COLOR_BLEND_EQUATION |
                                              RADV_CMD_DIRTY_DYNAMIC_ALPHA_TO_COVERAGE_ENABLE)))) {
          ps_epilog = lookup_ps_epilog(cmd_buffer);
          if (!ps_epilog) {
diff --git a/src/amd/vulkan/radv_pipeline.c b/src/amd/vulkan/radv_pipeline.c
index c71ee25e9392..aef3eaaecc7c 100644
--- a/src/amd/vulkan/radv_pipeline.c
+++ b/src/amd/vulkan/radv_pipeline.c
@@ -551,7 +551,6 @@ radv_pipeline_init_blend_state(struct radv_graphics_pipeline *pipeline,
    const struct radv_device *device = pipeline->base.device;
    struct radv_blend_state blend = {0};
    bool disable_dual_quad = false;
-   const enum amd_gfx_level gfx_level = device->physical_device->rad_info.gfx_level;
    int i;
 
    if (state->ms && !(pipeline->dynamic_states & RADV_DYNAMIC_ALPHA_TO_COVERAGE_ENABLE) &&
@@ -565,8 +564,6 @@ radv_pipeline_init_blend_state(struct radv_graphics_pipeline *pipeline,
    blend.cb_target_mask = 0;
    if (state->cb) {
       for (i = 0; i < state->cb->attachment_count; i++) {
-         unsigned blend_cntl = 0;
-         unsigned srcRGB_opt, dstRGB_opt, srcA_opt, dstA_opt;
          VkBlendOp eqRGB = state->cb->attachments[i].color_blend_op;
          VkBlendFactor srcRGB = state->cb->attachments[i].src_color_blend_factor;
          VkBlendFactor dstRGB = state->cb->attachments[i].dst_color_blend_factor;
@@ -588,10 +585,12 @@ radv_pipeline_init_blend_state(struct radv_graphics_pipeline *pipeline,
          blend.cb_target_enabled_4bit |= 0xfu << (4 * i);
          if (!(pipeline->dynamic_states & RADV_DYNAMIC_COLOR_BLEND_ENABLE) &&
              !state->cb->attachments[i].blend_enable) {
-            pipeline->cb_blend_control[i] = blend_cntl;
             continue;
          }
 
+         if (pipeline->dynamic_states & RADV_DYNAMIC_COLOR_BLEND_EQUATION)
+            continue;
+
          if (i == 0 && radv_can_enable_dual_src(&state->cb->attachments[i])) {
             blend.mrt0_is_dual_src = true;
          }
@@ -623,41 +622,6 @@ radv_pipeline_init_blend_state(struct radv_graphics_pipeline *pipeline,
          si_blend_remove_dst(&eqA, &srcA, &dstA, VK_BLEND_FACTOR_DST_ALPHA,
                              VK_BLEND_FACTOR_SRC_ALPHA);
 
-         /* Look up the ideal settings from tables. */
-         srcRGB_opt = si_translate_blend_opt_factor(srcRGB, false);
-         dstRGB_opt = si_translate_blend_opt_factor(dstRGB, false);
-         srcA_opt = si_translate_blend_opt_factor(srcA, true);
-         dstA_opt = si_translate_blend_opt_factor(dstA, true);
-
-         /* Handle interdependencies. */
-         if (si_blend_factor_uses_dst(srcRGB))
-            dstRGB_opt = V_028760_BLEND_OPT_PRESERVE_NONE_IGNORE_NONE;
-         if (si_blend_factor_uses_dst(srcA))
-            dstA_opt = V_028760_BLEND_OPT_PRESERVE_NONE_IGNORE_NONE;
-
-         if (srcRGB == VK_BLEND_FACTOR_SRC_ALPHA_SATURATE &&
-             (dstRGB == VK_BLEND_FACTOR_ZERO || dstRGB == VK_BLEND_FACTOR_SRC_ALPHA ||
-              dstRGB == VK_BLEND_FACTOR_SRC_ALPHA_SATURATE))
-            dstRGB_opt = V_028760_BLEND_OPT_PRESERVE_NONE_IGNORE_A0;
-
-         /* Set the final value. */
-         pipeline->sx_mrt_blend_opt[i] =
-            S_028760_COLOR_SRC_OPT(srcRGB_opt) | S_028760_COLOR_DST_OPT(dstRGB_opt) |
-            S_028760_COLOR_COMB_FCN(si_translate_blend_opt_function(eqRGB)) |
-            S_028760_ALPHA_SRC_OPT(srcA_opt) | S_028760_ALPHA_DST_OPT(dstA_opt) |
-            S_028760_ALPHA_COMB_FCN(si_translate_blend_opt_function(eqA));
-
-         blend_cntl |= S_028780_COLOR_COMB_FCN(si_translate_blend_function(eqRGB));
-         blend_cntl |= S_028780_COLOR_SRCBLEND(si_translate_blend_factor(gfx_level, srcRGB));
-         blend_cntl |= S_028780_COLOR_DESTBLEND(si_translate_blend_factor(gfx_level, dstRGB));
-         if (srcA != srcRGB || dstA != dstRGB || eqA != eqRGB) {
-            blend_cntl |= S_028780_SEPARATE_ALPHA_BLEND(1);
-            blend_cntl |= S_028780_ALPHA_COMB_FCN(si_translate_blend_function(eqA));
-            blend_cntl |= S_028780_ALPHA_SRCBLEND(si_translate_blend_factor(gfx_level, srcA));
-            blend_cntl |= S_028780_ALPHA_DESTBLEND(si_translate_blend_factor(gfx_level, dstA));
-         }
-         pipeline->cb_blend_control[i] = blend_cntl;
-
          blend.blend_enable_4bit |= 0xfu << (i * 4);
 
          if (srcRGB == VK_BLEND_FACTOR_SRC_ALPHA || dstRGB == VK_BLEND_FACTOR_SRC_ALPHA ||
@@ -670,14 +634,6 @@ radv_pipeline_init_blend_state(struct radv_graphics_pipeline *pipeline,
    }
 
    if (device->physical_device->rad_info.has_rbplus) {
-      /* Disable RB+ blend optimizations for dual source blending. */
-      if (blend.mrt0_is_dual_src) {
-         for (i = 0; i < 8; i++) {
-            pipeline->sx_mrt_blend_opt[i] = S_028760_COLOR_COMB_FCN(V_028760_OPT_COMB_NONE) |
-                                            S_028760_ALPHA_COMB_FCN(V_028760_OPT_COMB_NONE);
-         }
-      }
-
       /* RB+ doesn't work with dual source blending, logic op and
        * RESOLVE.
        */
@@ -1078,6 +1034,8 @@ radv_dynamic_state_mask(VkDynamicState state)
       return RADV_DYNAMIC_RASTERIZATION_SAMPLES;
    case VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT:
       return RADV_DYNAMIC_LINE_RASTERIZATION_MODE;
+   case VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT:
+      return RADV_DYNAMIC_COLOR_BLEND_EQUATION;
    default:
       unreachable("Unhandled dynamic state");
    }
@@ -1683,6 +1641,19 @@ radv_pipeline_init_dynamic_state(struct radv_graphics_pipeline *pipeline,
       dynamic->line_rasterization_mode = state->rs->line.mode;
    }
 
+   if (radv_pipeline_has_color_attachments(state->rp) && states & RADV_DYNAMIC_COLOR_BLEND_EQUATION) {
+      for (unsigned i = 0; i < state->cb->attachment_count; i++) {
+         const struct vk_color_blend_attachment_state *att = &state->cb->attachments[i];
+
+         dynamic->color_blend_equation[i].src_color_blend_factor = att->src_color_blend_factor;
+         dynamic->color_blend_equation[i].dst_color_blend_factor = att->dst_color_blend_factor;
+         dynamic->color_blend_equation[i].color_blend_op = att->color_blend_op;
+         dynamic->color_blend_equation[i].src_alpha_blend_factor = att->src_alpha_blend_factor;
+         dynamic->color_blend_equation[i].dst_alpha_blend_factor = att->dst_alpha_blend_factor;
+         dynamic->color_blend_equation[i].alpha_blend_op = att->alpha_blend_op;
+      }
+   }
+
    pipeline->dynamic_state.mask = states;
 }
 
@@ -2620,6 +2591,7 @@ radv_generate_graphics_pipeline_key(const struct radv_graphics_pipeline *pipelin
 
    if (pipeline->dynamic_states & (RADV_DYNAMIC_COLOR_BLEND_ENABLE |
                                    RADV_DYNAMIC_COLOR_WRITE_MASK |
+                                   RADV_DYNAMIC_COLOR_BLEND_EQUATION |
                                    RADV_DYNAMIC_ALPHA_TO_COVERAGE_ENABLE)) {
       /* These dynamic states need to compile PS epilogs on-demand. */
       key.ps.dynamic_ps_epilog = true;
@@ -5259,9 +5231,6 @@ radv_graphics_pipeline_init(struct radv_graphics_pipeline *pipeline, struct radv
    /* Copy the non-compacted SPI_SHADER_COL_FORMAT which is used to emit RBPLUS state. */
    pipeline->col_format_non_compacted = blend.spi_shader_col_format;
 
-   pipeline->mrt0_is_dual_src = blend.mrt0_is_dual_src;
-   pipeline->need_src_alpha = blend.need_src_alpha;
-
    struct radv_shader *ps = pipeline->base.shaders[MESA_SHADER_FRAGMENT];
    bool enable_mrt_compaction = !blend.mrt0_is_dual_src && !ps->info.ps.has_epilog;
    if (enable_mrt_compaction) {
diff --git a/src/amd/vulkan/radv_private.h b/src/amd/vulkan/radv_private.h
index 7f6901e6921c..c07e0cb216fb 100644
--- a/src/amd/vulkan/radv_private.h
+++ b/src/amd/vulkan/radv_private.h
@@ -1142,7 +1142,8 @@ enum radv_dynamic_state_bits {
    RADV_DYNAMIC_COLOR_BLEND_ENABLE = 1ull << 42,
    RADV_DYNAMIC_RASTERIZATION_SAMPLES = 1ull << 43,
    RADV_DYNAMIC_LINE_RASTERIZATION_MODE = 1ull << 44,
-   RADV_DYNAMIC_ALL = (1ull << 45) - 1,
+   RADV_DYNAMIC_COLOR_BLEND_EQUATION = 1ull << 45,
+   RADV_DYNAMIC_ALL = (1ull << 46) - 1,
 };
 
 enum radv_cmd_dirty_bits {
@@ -1193,13 +1194,14 @@ enum radv_cmd_dirty_bits {
    RADV_CMD_DIRTY_DYNAMIC_COLOR_BLEND_ENABLE = 1ull << 42,
    RADV_CMD_DIRTY_DYNAMIC_RASTERIZATION_SAMPLES = 1ull << 43,
    RADV_CMD_DIRTY_DYNAMIC_LINE_RASTERIZATION_MODE = 1ull << 44,
-   RADV_CMD_DIRTY_DYNAMIC_ALL = (1ull << 45) - 1,
-   RADV_CMD_DIRTY_PIPELINE = 1ull << 45,
-   RADV_CMD_DIRTY_INDEX_BUFFER = 1ull << 46,
-   RADV_CMD_DIRTY_FRAMEBUFFER = 1ull << 47,
-   RADV_CMD_DIRTY_VERTEX_BUFFER = 1ull << 48,
-   RADV_CMD_DIRTY_STREAMOUT_BUFFER = 1ull << 49,
-   RADV_CMD_DIRTY_GUARDBAND = 1ull << 50,
+   RADV_CMD_DIRTY_DYNAMIC_COLOR_BLEND_EQUATION = 1ull << 45,
+   RADV_CMD_DIRTY_DYNAMIC_ALL = (1ull << 46) - 1,
+   RADV_CMD_DIRTY_PIPELINE = 1ull << 46,
+   RADV_CMD_DIRTY_INDEX_BUFFER = 1ull << 47,
+   RADV_CMD_DIRTY_FRAMEBUFFER = 1ull << 48,
+   RADV_CMD_DIRTY_VERTEX_BUFFER = 1ull << 49,
+   RADV_CMD_DIRTY_STREAMOUT_BUFFER = 1ull << 50,
+   RADV_CMD_DIRTY_GUARDBAND = 1ull << 51,
 };
 
 enum radv_cmd_flush_bits {
@@ -1427,6 +1429,15 @@ struct radv_dynamic_state {
    VkSampleCountFlagBits rasterization_samples;
 
    VkLineRasterizationModeEXT line_rasterization_mode;
+
+   struct {
+      uint8_t src_color_blend_factor;
+      uint8_t dst_color_blend_factor;
+      VkBlendOp color_blend_op;
+      uint8_t src_alpha_blend_factor;
+      uint8_t dst_alpha_blend_factor;
+      VkBlendOp alpha_blend_op;
+   } color_blend_equation[MAX_RTS];
 };
 
 extern const struct radv_dynamic_state default_dynamic_state;
@@ -2119,8 +2130,6 @@ struct radv_graphics_pipeline {
    uint8_t vtx_emit_num;
    uint64_t needed_dynamic_state;
    bool disable_dual_quad;
-   unsigned cb_blend_control[MAX_RTS];
-   unsigned sx_mrt_blend_opt[MAX_RTS];
    uint32_t binding_stride[MAX_VBS];
    uint8_t attrib_bindings[MAX_VERTEX_ATTRIBS];
    uint32_t attrib_ends[MAX_VERTEX_ATTRIBS];
@@ -2140,9 +2149,6 @@ struct radv_graphics_pipeline {
    /* Used for rbplus */
    uint32_t col_format_non_compacted;
 
-   bool mrt0_is_dual_src;
-   uint32_t need_src_alpha;
-
    bool disable_out_of_order_rast_for_occlusion;
    bool uses_drawid;
    bool uses_baseinstance;
-- 
GitLab


From 5b4bb4b887cd3abb02ecd3cca10ce1bb0623c7c0 Mon Sep 17 00:00:00 2001
From: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date: Fri, 9 Dec 2022 11:16:53 +0100
Subject: [PATCH 09/10] radv: fix detecting that blend is enabled when all CB
 states are dynamic

It's allowed to be NULL.

Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
---
 src/amd/vulkan/radv_pipeline.c | 9 +++++++++
 1 file changed, 9 insertions(+)

diff --git a/src/amd/vulkan/radv_pipeline.c b/src/amd/vulkan/radv_pipeline.c
index aef3eaaecc7c..d7398fab2107 100644
--- a/src/amd/vulkan/radv_pipeline.c
+++ b/src/amd/vulkan/radv_pipeline.c
@@ -1054,6 +1054,15 @@ radv_pipeline_is_blend_enabled(const struct radv_graphics_pipeline *pipeline,
          if (cb->attachments[i].write_mask && cb->attachments[i].blend_enable)
             return true;
       }
+   } else {
+      const uint64_t cb_dynamic_states =
+         RADV_DYNAMIC_LOGIC_OP_ENABLE | RADV_DYNAMIC_LOGIC_OP | RADV_DYNAMIC_COLOR_WRITE_ENABLE |
+         RADV_DYNAMIC_COLOR_WRITE_MASK | RADV_DYNAMIC_COLOR_BLEND_ENABLE |
+         RADV_DYNAMIC_COLOR_BLEND_EQUATION | RADV_DYNAMIC_BLEND_CONSTANTS;
+
+      /* When all color blend states are dynamic, it's allowed to be NULL. */
+      if ((pipeline->dynamic_states & cb_dynamic_states) == cb_dynamic_states)
+         return true;
    }
 
    return false;
-- 
GitLab


From c2143f7b7d956fe582248e66e68bfaf281ba3ca3 Mon Sep 17 00:00:00 2001
From: Samuel Pitoiset <samuel.pitoiset@gmail.com>
Date: Thu, 24 Nov 2022 16:01:45 +0100
Subject: [PATCH 10/10] radv: advertise extendedDynamicState3ColorBlendEquation

This enables full ds3 support with Zink!

Signed-off-by: Samuel Pitoiset <samuel.pitoiset@gmail.com>
---
 src/amd/vulkan/radv_device.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/amd/vulkan/radv_device.c b/src/amd/vulkan/radv_device.c
index 86a838b04204..03e832b2a3f7 100644
--- a/src/amd/vulkan/radv_device.c
+++ b/src/amd/vulkan/radv_device.c
@@ -1945,7 +1945,7 @@ radv_GetPhysicalDeviceFeatures2(VkPhysicalDevice physicalDevice,
          features->extendedDynamicState3DepthClampEnable = true;
          features->extendedDynamicState3ColorWriteMask = true;
          features->extendedDynamicState3RasterizationSamples = true;
-         features->extendedDynamicState3ColorBlendEquation = false; /* TODO: Zink */
+         features->extendedDynamicState3ColorBlendEquation = true;
          features->extendedDynamicState3SampleLocationsEnable = false; /* TODO */
          features->extendedDynamicState3LineRasterizationMode = true;
          features->extendedDynamicState3ExtraPrimitiveOverestimationSize = false;
-- 
GitLab

