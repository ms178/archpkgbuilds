From 227ad9fed56ac2c1e11228db64755d15e7bebad3 Mon Sep 17 00:00:00 2001
From: Georg Lehmann <dadschoorse@gmail.com>
Date: Thu, 11 Aug 2022 12:11:04 +0200
Subject: [PATCH 1/4] nir/fold_16bit_tex_image: Add an option to fold image
 sources.

Signed-off-by: Georg Lehmann <dadschoorse@gmail.com>
Reviewed-by: Rhys Perry <pendingchaos02@gmail.com>
Part-of: <https://gitlab.freedesktop.org/mesa/mesa/-/merge_requests/18106>
---
 src/compiler/nir/nir.h               |  1 +
 src/compiler/nir/nir_lower_mediump.c | 82 ++++++++++++++++++++++++++++
 2 files changed, 83 insertions(+)

diff --git a/src/compiler/nir/nir.h b/src/compiler/nir/nir.h
index fb1de764bef8..762f509899ef 100644
--- a/src/compiler/nir/nir.h
+++ b/src/compiler/nir/nir.h
@@ -5354,6 +5354,7 @@ struct nir_fold_16bit_tex_image_options {
    nir_rounding_mode rounding_mode;
    bool fold_tex_dest;
    bool fold_image_load_store_data;
+   bool fold_image_srcs;
    unsigned fold_srcs_options_count;
    struct nir_fold_tex_srcs_options *fold_srcs_options;
 };
diff --git a/src/compiler/nir/nir_lower_mediump.c b/src/compiler/nir/nir_lower_mediump.c
index cd6ca19ee01a..2367dfda0d12 100644
--- a/src/compiler/nir/nir_lower_mediump.c
+++ b/src/compiler/nir/nir_lower_mediump.c
@@ -722,6 +722,30 @@ fold_16bit_tex_srcs(nir_builder *b, nir_tex_instr *tex,
    return !!fold_srcs;
 }
 
+static bool
+fold_16bit_image_srcs(nir_builder *b, nir_intrinsic_instr *instr, int lod_idx)
+{
+   enum glsl_sampler_dim dim = nir_intrinsic_image_dim(instr);
+   bool is_ms = (dim == GLSL_SAMPLER_DIM_MS || dim == GLSL_SAMPLER_DIM_SUBPASS_MS);
+   nir_src *coords = &instr->src[1];
+   nir_src *sample = is_ms ? &instr->src[2] : NULL;
+   nir_src *lod = lod_idx >= 0 ? &instr->src[lod_idx] : NULL;
+
+   if (dim == GLSL_SAMPLER_DIM_BUF ||
+       !can_fold_16bit_src(coords->ssa, nir_type_int32, false) ||
+       (sample && !can_fold_16bit_src(sample->ssa, nir_type_int32, false)) ||
+       (lod && !can_fold_16bit_src(lod->ssa, nir_type_int32, false)))
+      return false;
+
+   fold_16bit_src(b, &instr->instr, coords, nir_type_int32);
+   if (sample)
+      fold_16bit_src(b, &instr->instr, sample, nir_type_int32);
+   if (lod)
+      fold_16bit_src(b, &instr->instr, lod, nir_type_int32);
+
+   return true;
+}
+
 static bool
 fold_16bit_tex_image(nir_builder *b, nir_instr *instr, void *params)
 {
@@ -738,12 +762,70 @@ fold_16bit_tex_image(nir_builder *b, nir_instr *instr, void *params)
       case nir_intrinsic_image_store:
          if (options->fold_image_load_store_data)
             progress |= fold_16bit_store_data(b, intrinsic);
+         if (options->fold_image_srcs)
+            progress |= fold_16bit_image_srcs(b, intrinsic, 4);
          break;
       case nir_intrinsic_bindless_image_load:
       case nir_intrinsic_image_deref_load:
       case nir_intrinsic_image_load:
          if (options->fold_image_load_store_data)
             progress |= fold_16bit_load_data(b, intrinsic, exec_mode, options->rounding_mode);
+         if (options->fold_image_srcs)
+            progress |= fold_16bit_image_srcs(b, intrinsic, 3);
+         break;
+      case nir_intrinsic_bindless_image_sparse_load:
+      case nir_intrinsic_image_deref_sparse_load:
+      case nir_intrinsic_image_sparse_load:
+         if (options->fold_image_srcs)
+            progress |= fold_16bit_image_srcs(b, intrinsic, 3);
+         break;
+      case nir_intrinsic_bindless_image_atomic_add:
+      case nir_intrinsic_bindless_image_atomic_imin:
+      case nir_intrinsic_bindless_image_atomic_umin:
+      case nir_intrinsic_bindless_image_atomic_imax:
+      case nir_intrinsic_bindless_image_atomic_umax:
+      case nir_intrinsic_bindless_image_atomic_and:
+      case nir_intrinsic_bindless_image_atomic_or:
+      case nir_intrinsic_bindless_image_atomic_xor:
+      case nir_intrinsic_bindless_image_atomic_exchange:
+      case nir_intrinsic_bindless_image_atomic_comp_swap:
+      case nir_intrinsic_bindless_image_atomic_fadd:
+      case nir_intrinsic_bindless_image_atomic_fmin:
+      case nir_intrinsic_bindless_image_atomic_fmax:
+      case nir_intrinsic_bindless_image_atomic_inc_wrap:
+      case nir_intrinsic_bindless_image_atomic_dec_wrap:
+      case nir_intrinsic_image_deref_atomic_add:
+      case nir_intrinsic_image_deref_atomic_umin:
+      case nir_intrinsic_image_deref_atomic_imin:
+      case nir_intrinsic_image_deref_atomic_umax:
+      case nir_intrinsic_image_deref_atomic_imax:
+      case nir_intrinsic_image_deref_atomic_and:
+      case nir_intrinsic_image_deref_atomic_or:
+      case nir_intrinsic_image_deref_atomic_xor:
+      case nir_intrinsic_image_deref_atomic_exchange:
+      case nir_intrinsic_image_deref_atomic_comp_swap:
+      case nir_intrinsic_image_deref_atomic_fadd:
+      case nir_intrinsic_image_deref_atomic_fmin:
+      case nir_intrinsic_image_deref_atomic_fmax:
+      case nir_intrinsic_image_deref_atomic_inc_wrap:
+      case nir_intrinsic_image_deref_atomic_dec_wrap:
+      case nir_intrinsic_image_atomic_add:
+      case nir_intrinsic_image_atomic_imin:
+      case nir_intrinsic_image_atomic_umin:
+      case nir_intrinsic_image_atomic_imax:
+      case nir_intrinsic_image_atomic_umax:
+      case nir_intrinsic_image_atomic_and:
+      case nir_intrinsic_image_atomic_or:
+      case nir_intrinsic_image_atomic_xor:
+      case nir_intrinsic_image_atomic_exchange:
+      case nir_intrinsic_image_atomic_comp_swap:
+      case nir_intrinsic_image_atomic_fadd:
+      case nir_intrinsic_image_atomic_fmin:
+      case nir_intrinsic_image_atomic_fmax:
+      case nir_intrinsic_image_atomic_inc_wrap:
+      case nir_intrinsic_image_atomic_dec_wrap:
+         if (options->fold_image_srcs)
+            progress |= fold_16bit_image_srcs(b, intrinsic, -1);
          break;
       default:
          break;
-- 
GitLab


From 8cd55f2a02dd1b943e3a454c0e4d6cf1656c75fe Mon Sep 17 00:00:00 2001
From: Georg Lehmann <dadschoorse@gmail.com>
Date: Thu, 11 Aug 2022 12:11:25 +0200
Subject: [PATCH 2/4] aco: Implement storage image A16.

Signed-off-by: Georg Lehmann <dadschoorse@gmail.com>
Reviewed-by: Rhys Perry <pendingchaos02@gmail.com>
Part-of: <https://gitlab.freedesktop.org/mesa/mesa/-/merge_requests/18106>
---
 .../compiler/aco_instruction_selection.cpp    | 38 ++++++++++++-------
 1 file changed, 24 insertions(+), 14 deletions(-)

diff --git a/src/amd/compiler/aco_instruction_selection.cpp b/src/amd/compiler/aco_instruction_selection.cpp
index 88f833812eb4..d1980934b01b 100644
--- a/src/amd/compiler/aco_instruction_selection.cpp
+++ b/src/amd/compiler/aco_instruction_selection.cpp
@@ -6016,12 +6016,12 @@ image_type_to_components_count(enum glsl_sampler_dim dim, bool array)
    case GLSL_SAMPLER_DIM_BUF: return 1;
    case GLSL_SAMPLER_DIM_1D: return array ? 2 : 1;
    case GLSL_SAMPLER_DIM_2D: return array ? 3 : 2;
-   case GLSL_SAMPLER_DIM_MS: return array ? 4 : 3;
+   case GLSL_SAMPLER_DIM_MS: return array ? 3 : 2;
    case GLSL_SAMPLER_DIM_3D:
    case GLSL_SAMPLER_DIM_CUBE: return 3;
    case GLSL_SAMPLER_DIM_RECT:
    case GLSL_SAMPLER_DIM_SUBPASS: return 2;
-   case GLSL_SAMPLER_DIM_SUBPASS_MS: return 3;
+   case GLSL_SAMPLER_DIM_SUBPASS_MS: return 2;
    default: break;
    }
    return 0;
@@ -6125,6 +6125,8 @@ get_image_coords(isel_context* ctx, const nir_intrinsic_instr* instr)
 {
 
    Temp src0 = get_ssa_temp(ctx, instr->src[1].ssa);
+   bool a16 = instr->src[1].ssa->bit_size == 16;
+   RegClass rc = a16 ? v2b : v1;
    enum glsl_sampler_dim dim = nir_intrinsic_image_dim(instr);
    bool is_array = nir_intrinsic_image_array(instr);
    ASSERTED bool add_frag_pos =
@@ -6133,21 +6135,17 @@ get_image_coords(isel_context* ctx, const nir_intrinsic_instr* instr)
    bool is_ms = (dim == GLSL_SAMPLER_DIM_MS || dim == GLSL_SAMPLER_DIM_SUBPASS_MS);
    bool gfx9_1d = ctx->options->gfx_level == GFX9 && dim == GLSL_SAMPLER_DIM_1D;
    int count = image_type_to_components_count(dim, is_array);
-   std::vector<Temp> coords(count);
+   std::vector<Temp> coords;
    Builder bld(ctx->program, ctx->block);
 
-   if (is_ms)
-      coords[--count] = emit_extract_vector(ctx, get_ssa_temp(ctx, instr->src[2].ssa), 0, v1);
-
    if (gfx9_1d) {
-      coords[0] = emit_extract_vector(ctx, src0, 0, v1);
-      coords.resize(coords.size() + 1);
-      coords[1] = bld.copy(bld.def(v1), Operand::zero());
+      coords.emplace_back(emit_extract_vector(ctx, src0, 0, rc));
+      coords.emplace_back(bld.copy(bld.def(rc), Operand::zero(a16 ? 16 : 32)));
       if (is_array)
-         coords[2] = emit_extract_vector(ctx, src0, 1, v1);
+         coords.emplace_back(emit_extract_vector(ctx, src0, 1, rc));
    } else {
       for (int i = 0; i < count; i++)
-         coords[i] = emit_extract_vector(ctx, src0, i, v1);
+         coords.emplace_back(emit_extract_vector(ctx, src0, i, rc));
    }
 
    if (ctx->options->key.image_2d_view_of_3d &&
@@ -6163,21 +6161,30 @@ get_image_coords(isel_context* ctx, const nir_intrinsic_instr* instr)
       Temp first_layer =
          bld.vop3(aco_opcode::v_bfe_u32, bld.def(v1), rsrc_word5,
                   Operand::c32(0u), Operand::c32(13u));
-      coords.emplace_back(first_layer);
+      if (a16)
+         coords.emplace_back(emit_extract_vector(ctx, first_layer, 0, v2b));
+      else
+         coords.emplace_back(first_layer);
+   }
+
+   if (is_ms) {
+      assert(instr->src[2].ssa->bit_size == (a16 ? 16 : 32));
+      coords.emplace_back(get_ssa_temp_tex(ctx, instr->src[2].ssa, a16));
    }
 
    if (instr->intrinsic == nir_intrinsic_bindless_image_load ||
        instr->intrinsic == nir_intrinsic_bindless_image_sparse_load ||
        instr->intrinsic == nir_intrinsic_bindless_image_store) {
       int lod_index = instr->intrinsic == nir_intrinsic_bindless_image_store ? 4 : 3;
+      assert(instr->src[lod_index].ssa->bit_size == (a16 ? 16 : 32));
       bool level_zero =
          nir_src_is_const(instr->src[lod_index]) && nir_src_as_uint(instr->src[lod_index]) == 0;
 
       if (!level_zero)
-         coords.emplace_back(get_ssa_temp(ctx, instr->src[lod_index].ssa));
+         coords.emplace_back(get_ssa_temp_tex(ctx, instr->src[lod_index].ssa, a16));
    }
 
-   return coords;
+   return emit_pack_v1(ctx, coords);
 }
 
 memory_sync_info
@@ -6306,6 +6313,7 @@ visit_image_load(isel_context* ctx, nir_intrinsic_instr* instr)
       load->dlc =
          load->glc && (ctx->options->gfx_level == GFX10 || ctx->options->gfx_level == GFX10_3);
       load->dim = ac_get_image_dim(ctx->options->gfx_level, dim, is_array);
+      load->a16 = instr->src[1].ssa->bit_size == 16;
       load->d16 = d16;
       load->dmask = dmask;
       load->unrm = true;
@@ -6432,6 +6440,7 @@ visit_image_store(isel_context* ctx, nir_intrinsic_instr* instr)
    store->glc = glc;
    store->dlc = false;
    store->dim = ac_get_image_dim(ctx->options->gfx_level, dim, is_array);
+   store->a16 = instr->src[1].ssa->bit_size == 16;
    store->d16 = d16;
    store->dmask = dmask;
    store->unrm = true;
@@ -6567,6 +6576,7 @@ visit_image_atomic(isel_context* ctx, nir_intrinsic_instr* instr)
    mimg->dlc = false; /* Not needed for atomics */
    mimg->dim = ac_get_image_dim(ctx->options->gfx_level, dim, is_array);
    mimg->dmask = (1 << data.size()) - 1;
+   mimg->a16 = instr->src[1].ssa->bit_size == 16;
    mimg->unrm = true;
    mimg->da = should_declare_array(ctx, dim, is_array);
    mimg->disable_wqm = true;
-- 
GitLab


From 9bc7b4c269ac15719470fdea4156881fd411c67d Mon Sep 17 00:00:00 2001
From: Georg Lehmann <dadschoorse@gmail.com>
Date: Thu, 11 Aug 2022 14:12:33 +0200
Subject: [PATCH 3/4] aco: Combine 16bit undef and constants instead of using
 s_pack.

Signed-off-by: Georg Lehmann <dadschoorse@gmail.com>
Reviewed-by: Rhys Perry <pendingchaos02@gmail.com>
Part-of: <https://gitlab.freedesktop.org/mesa/mesa/-/merge_requests/18106>
---
 src/amd/compiler/aco_instruction_selection.cpp | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/src/amd/compiler/aco_instruction_selection.cpp b/src/amd/compiler/aco_instruction_selection.cpp
index d1980934b01b..e19ff68c98e7 100644
--- a/src/amd/compiler/aco_instruction_selection.cpp
+++ b/src/amd/compiler/aco_instruction_selection.cpp
@@ -1420,6 +1420,8 @@ visit_alu_instr(isel_context* ctx, nir_alu_instr* instr)
                const_vals[idx] |= nir_src_as_uint(instr->src[i].src) << offset;
                continue;
             }
+            if (nir_src_is_undef(instr->src[i].src))
+               continue;
 
             if (offset != packed_size - instr->dest.dest.ssa.bit_size)
                elems[i] =
-- 
GitLab


From a3f645ea8c0619e49e2259a02979930c32a84087 Mon Sep 17 00:00:00 2001
From: Georg Lehmann <dadschoorse@gmail.com>
Date: Mon, 22 Aug 2022 16:45:00 +0200
Subject: [PATCH 4/4] radv: Fold 16bit image sources.

Signed-off-by: Georg Lehmann <dadschoorse@gmail.com>
Reviewed-by: Rhys Perry <pendingchaos02@gmail.com>
Part-of: <https://gitlab.freedesktop.org/mesa/mesa/-/merge_requests/18106>
---
 src/amd/vulkan/radv_pipeline.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/src/amd/vulkan/radv_pipeline.c b/src/amd/vulkan/radv_pipeline.c
index 63e4d7c2ec0a..e153aaadc200 100644
--- a/src/amd/vulkan/radv_pipeline.c
+++ b/src/amd/vulkan/radv_pipeline.c
@@ -4529,6 +4529,7 @@ radv_postprocess_nir(struct radv_pipeline *pipeline,
          .rounding_mode = nir_rounding_mode_rtne,
          .fold_tex_dest = true,
          .fold_image_load_store_data = true,
+         .fold_image_srcs = !radv_use_llvm_for_stage(device, stage->stage),
          .fold_srcs_options_count = separate_g16 ? 2 : 1,
          .fold_srcs_options = fold_srcs_options,
       };
-- 
GitLab

