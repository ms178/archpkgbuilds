From aa585487f061994947891e44608ed40294be45ea Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Michel=20D=C3=A4nzer?= <mdaenzer@redhat.com>
Date: Mon, 19 Dec 2022 12:33:24 +0100
Subject: [PATCH 1/3] loader/dri3: Move NULL handling into
 dri3_free_render_buffer

Both checking for draw->buffers[buf_id] being non-NULL, and setting
draw->buffers[buf_id] = NULL.
---
 src/loader/loader_dri3_helper.c | 33 +++++++++++++++------------------
 1 file changed, 15 insertions(+), 18 deletions(-)

diff --git a/src/loader/loader_dri3_helper.c b/src/loader/loader_dri3_helper.c
index 0caaa148179e..d46572d9fe1e 100644
--- a/src/loader/loader_dri3_helper.c
+++ b/src/loader/loader_dri3_helper.c
@@ -335,8 +335,13 @@ loader_dri3_set_swap_interval(struct loader_dri3_drawable *draw, int interval)
  */
 static void
 dri3_free_render_buffer(struct loader_dri3_drawable *draw,
-                        struct loader_dri3_buffer *buffer)
+                        int buf_id)
 {
+   struct loader_dri3_buffer *buffer = draw->buffers[buf_id];
+
+   if (!buffer)
+      return;
+
    if (buffer->own_pixmap)
       xcb_free_pixmap(draw->conn, buffer->pixmap);
    xcb_sync_destroy_fence(draw->conn, buffer->sync_fence);
@@ -345,6 +350,8 @@ dri3_free_render_buffer(struct loader_dri3_drawable *draw,
    if (buffer->linear_buffer)
       draw->ext->image->destroyImage(buffer->linear_buffer);
    free(buffer);
+
+   draw->buffers[buf_id] = NULL;
 }
 
 void
@@ -354,10 +361,8 @@ loader_dri3_drawable_fini(struct loader_dri3_drawable *draw)
 
    draw->ext->core->destroyDrawable(draw->dri_drawable);
 
-   for (i = 0; i < ARRAY_SIZE(draw->buffers); i++) {
-      if (draw->buffers[i])
-         dri3_free_render_buffer(draw, draw->buffers[i]);
-   }
+   for (i = 0; i < ARRAY_SIZE(draw->buffers); i++)
+      dri3_free_render_buffer(draw, i);
 
    if (draw->special_event) {
       xcb_void_cookie_t cookie =
@@ -2133,7 +2138,7 @@ dri3_get_buffer(__DRIdrawable *driDrawable,
             dri3_fence_trigger(draw->conn, new_buffer);
             fence_await = true;
          }
-         dri3_free_render_buffer(draw, buffer);
+         dri3_free_render_buffer(draw, buf_id);
       } else if (buffer_type == loader_dri3_buffer_front) {
          /* Fill the new fake front with data from a real front */
          loader_dri3_swapbuffer_barrier(draw);
@@ -2202,7 +2207,6 @@ dri3_free_buffers(__DRIdrawable *driDrawable,
                   enum loader_dri3_buffer_type buffer_type,
                   struct loader_dri3_drawable *draw)
 {
-   struct loader_dri3_buffer *buffer;
    int first_id;
    int n_id;
    int buf_id;
@@ -2222,13 +2226,8 @@ dri3_free_buffers(__DRIdrawable *driDrawable,
       unreachable("unhandled buffer_type");
    }
 
-   for (buf_id = first_id; buf_id < first_id + n_id; buf_id++) {
-      buffer = draw->buffers[buf_id];
-      if (buffer) {
-         dri3_free_render_buffer(draw, buffer);
-         draw->buffers[buf_id] = NULL;
-      }
-   }
+   for (buf_id = first_id; buf_id < first_id + n_id; buf_id++)
+      dri3_free_render_buffer(draw, buf_id);
 }
 
 /** loader_dri3_get_buffers
@@ -2263,10 +2262,8 @@ loader_dri3_get_buffers(__DRIdrawable *driDrawable,
 
    /* Free no longer needed back buffers */
    for (buf_id = draw->cur_num_back; buf_id < LOADER_DRI3_MAX_BACK; buf_id++) {
-      if (draw->cur_blit_source != buf_id && draw->buffers[buf_id]) {
-         dri3_free_render_buffer(draw, draw->buffers[buf_id]);
-         draw->buffers[buf_id] = NULL;
-      }
+      if (draw->cur_blit_source != buf_id)
+         dri3_free_render_buffer(draw, buf_id);
    }
 
    /* pixmaps always have front buffers.
-- 
GitLab


From f21fc40d33c1cc86f99f5e2bf7d2079ce67ad1b7 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Michel=20D=C3=A4nzer?= <mdaenzer@redhat.com>
Date: Mon, 19 Dec 2022 18:06:13 +0100
Subject: [PATCH 2/3] loader/dri3: Add dri3_set_render_buffer helper

Preparation for next commit, no functional change intended.
---
 src/loader/loader_dri3_helper.c | 13 ++++++++++---
 1 file changed, 10 insertions(+), 3 deletions(-)

diff --git a/src/loader/loader_dri3_helper.c b/src/loader/loader_dri3_helper.c
index d46572d9fe1e..cc241d4cf627 100644
--- a/src/loader/loader_dri3_helper.c
+++ b/src/loader/loader_dri3_helper.c
@@ -328,6 +328,13 @@ loader_dri3_set_swap_interval(struct loader_dri3_drawable *draw, int interval)
    draw->swap_interval = interval;
 }
 
+static void
+dri3_set_render_buffer(struct loader_dri3_drawable *draw, int buf_id,
+                       struct loader_dri3_buffer *buffer)
+{
+   draw->buffers[buf_id] = buffer;
+}
+
 /** dri3_free_render_buffer
  *
  * Free everything associated with one render buffer including pixmap, fence
@@ -2054,7 +2061,7 @@ dri3_get_pixmap_buffer(__DRIdrawable *driDrawable, unsigned int format,
    buffer->shm_fence = shm_fence;
    buffer->sync_fence = sync_fence;
 
-   draw->buffers[buf_id] = buffer;
+   dri3_set_render_buffer(draw, buf_id, buffer);
 
    return buffer;
 
@@ -2162,7 +2169,7 @@ dri3_get_buffer(__DRIdrawable *driDrawable,
             fence_await = true;
       }
       buffer = new_buffer;
-      draw->buffers[buf_id] = buffer;
+      dri3_set_render_buffer(draw, buf_id, buffer);
    }
 
    if (fence_await)
@@ -2418,7 +2425,7 @@ dri3_find_back_alloc(struct loader_dri3_drawable *draw)
    if (!back)
       return NULL;
 
-   draw->buffers[id] = back;
+   dri3_set_render_buffer(draw, id, back);
 
    /* If necessary, prefill the back with data according to swap_method mode. */
    if (draw->cur_blit_source != -1 &&
-- 
GitLab


From 21fa768f06e03f1a91e9b0d152800eac41dda32e Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Michel=20D=C3=A4nzer?= <mdaenzer@redhat.com>
Date: Mon, 19 Dec 2022 12:25:46 +0100
Subject: [PATCH 3/3] loader/dri3: Overhaul draw->cur_num_back handling

draw->cur_num_back is no longer used for immediately reducing the number
of allocated back buffers. It just reflects how many of them are
currently allocated, and is used to prevent allocating more if the
current maximum is already reached.

This fixes an issue where the current in-progress back buffer could get
freed, which would result in visible artifacts.

Unused buffers are freed once they reach buffer age 1000. This ensures
we do not keep around more buffers than necessary in the long run.
---
 src/loader/loader_dri3_helper.c | 63 +++++++++++++++------------------
 1 file changed, 28 insertions(+), 35 deletions(-)

diff --git a/src/loader/loader_dri3_helper.c b/src/loader/loader_dri3_helper.c
index cc241d4cf627..f01728ef2d85 100644
--- a/src/loader/loader_dri3_helper.c
+++ b/src/loader/loader_dri3_helper.c
@@ -271,26 +271,12 @@ dri3_update_max_num_back(struct loader_dri3_drawable *draw)
 {
    switch (draw->last_present_mode) {
    case XCB_PRESENT_COMPLETE_MODE_FLIP: {
-      int new_max;
-
       if (draw->swap_interval == 0)
-         new_max = 4;
+         draw->max_num_back = 4;
       else
-         new_max = 3;
-
-      assert(new_max <= LOADER_DRI3_MAX_BACK);
-
-      if (new_max != draw->max_num_back) {
-         /* On transition from swap interval == 0 to != 0, start with two
-          * buffers again. Otherwise keep the current number of buffers. Either
-          * way, more will be allocated if needed.
-          */
-         if (new_max < draw->max_num_back)
-            draw->cur_num_back = 2;
-
-         draw->max_num_back = new_max;
-      }
+         draw->max_num_back = 3;
 
+      assert(draw->max_num_back <= LOADER_DRI3_MAX_BACK);
       break;
    }
 
@@ -298,12 +284,6 @@ dri3_update_max_num_back(struct loader_dri3_drawable *draw)
       break;
 
    default:
-      /* On transition from flips to copies, start with a single buffer again,
-       * a second one will be allocated if needed
-       */
-      if (draw->max_num_back != 2)
-         draw->cur_num_back = 1;
-
       draw->max_num_back = 2;
    }
 }
@@ -332,6 +312,9 @@ static void
 dri3_set_render_buffer(struct loader_dri3_drawable *draw, int buf_id,
                        struct loader_dri3_buffer *buffer)
 {
+   if (buf_id < LOADER_DRI3_FRONT_ID && !draw->buffers[buf_id])
+      draw->cur_num_back++;
+
    draw->buffers[buf_id] = buffer;
 }
 
@@ -359,6 +342,9 @@ dri3_free_render_buffer(struct loader_dri3_drawable *draw,
    free(buffer);
 
    draw->buffers[buf_id] = NULL;
+
+   if (buf_id < LOADER_DRI3_FRONT_ID)
+      draw->cur_num_back--;
 }
 
 void
@@ -724,7 +710,7 @@ dri3_find_back(struct loader_dri3_drawable *draw, bool prefer_a_different)
       max_num = 1;
       draw->cur_blit_source = -1;
    } else {
-      max_num = draw->max_num_back;
+      max_num = LOADER_DRI3_MAX_BACK;
    }
 
    /* In a DRI_PRIME situation, if prefer_a_different is true, we first try
@@ -740,7 +726,7 @@ dri3_find_back(struct loader_dri3_drawable *draw, bool prefer_a_different)
    do {
       /* Find idle buffer with lowest buffer age, or first unallocated slot */
       for (b = 0; b < max_num; b++) {
-         int id = LOADER_DRI3_BACK_ID((b + draw->cur_back) % draw->max_num_back);
+         int id = LOADER_DRI3_BACK_ID((b + current_back_id) % LOADER_DRI3_MAX_BACK);
 
          buffer = draw->buffers[id];
          if (buffer) {
@@ -750,7 +736,8 @@ dri3_find_back(struct loader_dri3_drawable *draw, bool prefer_a_different)
                best_id = id;
                best_swap = buffer->last_swap;
             }
-         } else if (best_id == -1 || (!best_swap && id < best_id)) {
+         } else if (draw->cur_num_back < draw->max_num_back &&
+                    (best_id == -1 || (!best_swap && id < best_id))) {
             best_id = id;
          }
       }
@@ -761,10 +748,8 @@ dri3_find_back(struct loader_dri3_drawable *draw, bool prefer_a_different)
          best_id = current_back_id;
    } while (best_id == -1 && dri3_wait_for_event_locked(draw, NULL));
 
-   if (best_id != -1) {
+   if (best_id != -1)
       draw->cur_back = best_id;
-      draw->cur_num_back = MAX2(draw->cur_num_back, best_id + 1);
-   }
 
 unlock:
    mtx_unlock(&draw->mtx);
@@ -2259,18 +2244,24 @@ loader_dri3_get_buffers(__DRIdrawable *driDrawable,
    buffers->front = NULL;
    buffers->back = NULL;
 
-   front = NULL;
-   back = NULL;
-
    if (!dri3_update_drawable(draw))
       return false;
 
    dri3_update_max_num_back(draw);
 
    /* Free no longer needed back buffers */
-   for (buf_id = draw->cur_num_back; buf_id < LOADER_DRI3_MAX_BACK; buf_id++) {
-      if (draw->cur_blit_source != buf_id)
-         dri3_free_render_buffer(draw, buf_id);
+   for (buf_id = 0; buf_id < LOADER_DRI3_MAX_BACK; buf_id++) {
+      int buffer_age;
+
+      back = draw->buffers[buf_id];
+      if (!back || !back->last_swap || draw->cur_blit_source == buf_id)
+         continue;
+
+      buffer_age = draw->send_sbc - back->last_swap + 1;
+      if (buffer_age < 1000)
+         continue;
+
+      dri3_free_render_buffer(draw, buf_id);
    }
 
    /* pixmaps always have front buffers.
@@ -2305,6 +2296,7 @@ loader_dri3_get_buffers(__DRIdrawable *driDrawable,
    } else {
       dri3_free_buffers(driDrawable, loader_dri3_buffer_front, draw);
       draw->have_fake_front = 0;
+      front = NULL;
    }
 
    if (buffer_mask & __DRI_IMAGE_BUFFER_BACK) {
@@ -2318,6 +2310,7 @@ loader_dri3_get_buffers(__DRIdrawable *driDrawable,
    } else {
       dri3_free_buffers(driDrawable, loader_dri3_buffer_back, draw);
       draw->have_back = 0;
+      back = NULL;
    }
 
    if (front) {
-- 
GitLab

