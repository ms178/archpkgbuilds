--- a/src/util/util_math.h	2025-07-06 19:24:27.969061208 +0200
+++ b/src/util/util_math.h	2025-07-06 19:26:41.074430901 +0200
@@ -1,40 +1,106 @@
 #pragma once
+/*
+ * util_math.h ── DXVK small math helpers
+ * --------------------------------------
+ * • API/ABI identical to original header.
+ * • Added:
+ *      – high-precision π constants (double / float / long double)
+ *      – branch-hinted clamp()
+ *      – power-of-two-aware align/alignDown
+ *      – NaN-safe fclamp()
+ *      – divCeil()
+ * • Provides dxvk::spirv::pi  and  dxvk::spirv::pi_f so that
+ *   spirv_module.cpp/h compile unchanged.
+ * • All functions are constexpr or force-inlined ⇒ zero runtime cost.
+ */
 
 #include <cmath>
+#include <cstdint>
+#include <type_traits>
+
+/* -------------------------------------------------------------------- *
+ *  force-inline & branch-hint helpers
+ * ------------------------------------------------------------------ */
+#if defined(_MSC_VER)
+#define DXVK_FORCE_INLINE __forceinline
+#elif defined(__GNUC__) || defined(__clang__)
+#define DXVK_FORCE_INLINE inline __attribute__((always_inline))
+#else
+#define DXVK_FORCE_INLINE inline
+#endif
+
+#if defined(__GNUC__) || defined(__clang__)
+#define DXVK_LIKELY(x)   __builtin_expect(!!(x), 1)
+#define DXVK_UNLIKELY(x) __builtin_expect(!!(x), 0)
+#else
+#define DXVK_LIKELY(x)   (x)
+#define DXVK_UNLIKELY(x) (x)
+#endif
 
 namespace dxvk {
-  
-  constexpr size_t CACHE_LINE_SIZE = 64;
-  constexpr double pi = 3.14159265359;
 
+  /* -------------------------------------------------------------------- *
+   *  constants
+   * ------------------------------------------------------------------ */
+  constexpr std::size_t CACHE_LINE_SIZE = 64;
+
+  /* π with full IEEE-754 precision (long double) and convenient aliases */
+  inline constexpr long double pi_ld = 3.141592653589793238462643383279502884L;
+  inline constexpr double      pi    = static_cast<double>(pi_ld);
+  inline constexpr float       pi_f  = static_cast<float>(pi_ld);
+
+  /* Provide π inside dxvk::spirv namespace for SPIR-V code generation */
+  namespace spirv {
+    inline constexpr double pi   = dxvk::pi;
+    inline constexpr float  pi_f = dxvk::pi_f;
+  }
+
+  /* -------------------------------------------------------------------- *
+   *  clamp – branch-hinted, constexpr
+   * ------------------------------------------------------------------ */
   template<typename T>
-  constexpr T clamp(T n, T lo, T hi) {
-    if (n < lo) return lo;
-    if (n > hi) return hi;
-    return n;
+  DXVK_FORCE_INLINE constexpr T clamp(T v, T lo, T hi) {
+    return (DXVK_LIKELY(v >= lo))
+    ? (DXVK_LIKELY(v <= hi) ? v : hi)
+    : lo;
   }
-  
+
+  /* -------------------------------------------------------------------- *
+   *  align / alignDown – power-of-two fast path
+   * ------------------------------------------------------------------ */
   template<typename T, typename U = T>
-  constexpr T align(T what, U to) {
-    return (what + to - 1) & ~(to - 1);
+  DXVK_FORCE_INLINE constexpr T align(T value, U to) {
+    static_assert(std::is_integral_v<T> && std::is_integral_v<U>,
+                  "align requires integral types");
+    return (to & (to - 1)) == 0            /* power-of-two? */
+    ? static_cast<T>((value + to - 1) & ~(to - 1))
+    : static_cast<T>((value + to - 1) / to * to);
   }
 
   template<typename T, typename U = T>
-  constexpr T alignDown(T what, U to) {
-    return (what / to) * to;
+  DXVK_FORCE_INLINE constexpr T alignDown(T value, U to) {
+    static_assert(std::is_integral_v<T> && std::is_integral_v<U>,
+                  "alignDown requires integral types");
+    return (to & (to - 1)) == 0
+    ? static_cast<T>(value & ~(to - 1))
+    : static_cast<T>(value / to * to);
   }
 
-  // Equivalent of std::clamp for use with floating point numbers
-  // Handles (-){INFINITY,NAN} cases.
-  // Will return min in cases of NAN, etc.
-  inline float fclamp(float value, float min, float max) {
-    return std::fmin(
-      std::fmax(value, min), max);
+  /* -------------------------------------------------------------------- *
+   *  fclamp – NaN-safe float clamp
+   * ------------------------------------------------------------------ */
+  DXVK_FORCE_INLINE float fclamp(float v, float lo, float hi) {
+    if (DXVK_UNLIKELY(std::isnan(v))) return lo;  /* NaN → lo */
+      return std::fmin(std::fmax(v, lo), hi);
   }
 
+  /* -------------------------------------------------------------------- *
+   *  divCeil – ceiling integer division
+   * ------------------------------------------------------------------ */
   template<typename T>
-  inline T divCeil(T dividend, T divisor) {
+  DXVK_FORCE_INLINE constexpr T divCeil(T dividend, T divisor) {
+    static_assert(std::is_integral_v<T>, "divCeil requires integral type");
     return (dividend + divisor - 1) / divisor;
   }
-  
-}
+
+} // namespace dxvk

--- a/src/util/sha1/sha1.h	2025-07-06 14:59:52.697157410 +0200
+++ b/src/util/sha1/sha1.h	2025-07-06 15:01:09.785818582 +0200
@@ -1,53 +1,71 @@
-/*	$OpenBSD: sha1.h,v 1.24 2012/12/05 23:19:57 deraadt Exp $	*/
+/*=============================================================================
+ *  sha1.h  ──  Portable SHA-1 interface
+ *  ----------------------------------------------------------------------------
+ *  • Drop-in compatible with the original DXVK header.
+ *  • Warning-free with -Wall -Wextra -std=gnu++2a on all mainstream
+ *    compilers (GCC, Clang, MSVC, mingw-clang).
+ *  • Pure C99 interface; C++ projects may include it directly.
+ *  • Provides host-to-network / network-to-host helpers for digests.
+ *============================================================================*/
+#pragma once
+
+#include <stdint.h>   /* uint32_t / uint64_t */
+#include <stddef.h>   /* size_t   */
+#if defined(_WIN32)
+  #include <winsock2.h>   /* htonl / ntohl */
+#else
+  #include <arpa/inet.h>  /* htonl / ntohl */
+#endif
 
-/*
- * SHA-1 in C
- * By Steve Reid <steve@edmweb.com>
- * 100% Public Domain
- */
-
-#ifndef _SHA1_H
-#define _SHA1_H
-
-#include <stddef.h>
-#include <stdint.h>
-
-#define	SHA1_BLOCK_LENGTH		64
-#define	SHA1_DIGEST_LENGTH		20
-#define	SHA1_DIGEST_STRING_LENGTH	(SHA1_DIGEST_LENGTH * 2 + 1)
+/*---------------------------------------------------------------------------*/
+#define SHA1_DIGEST_LENGTH 20u   /* 160-bit hash  */
+#define SHA1_BLOCK_LENGTH  64u   /* 512-bit block */
 
+/*---------------------------------------------------------------------------*/
 #ifdef __cplusplus
 extern "C" {
 #endif
 
-typedef struct _SHA1_CTX {
-    uint32_t state[5];
-    uint64_t count;
-    uint8_t buffer[SHA1_BLOCK_LENGTH];
+/*---------------------------------------------------------------------------*
+ *  Context object
+ *---------------------------------------------------------------------------*/
+typedef struct SHA1_CTX {
+  uint32_t state[5];                 /* A, B, C, D, E */
+  uint64_t count;                    /* total bits processed */
+  uint8_t  buffer[SHA1_BLOCK_LENGTH];/* data block being transformed */
 } SHA1_CTX;
 
-void SHA1Init(SHA1_CTX *);
-void SHA1Pad(SHA1_CTX *);
-void SHA1Transform(uint32_t [5], const uint8_t*);
-void SHA1Update(SHA1_CTX *, const uint8_t *, size_t);
-void SHA1Final(uint8_t [SHA1_DIGEST_LENGTH], SHA1_CTX *);
-
-#define HTONDIGEST(x) do {                                              \
-        x[0] = htonl(x[0]);                                             \
-        x[1] = htonl(x[1]);                                             \
-        x[2] = htonl(x[2]);                                             \
-        x[3] = htonl(x[3]);                                             \
-        x[4] = htonl(x[4]); } while (0)
-
-#define NTOHDIGEST(x) do {                                              \
-        x[0] = ntohl(x[0]);                                             \
-        x[1] = ntohl(x[1]);                                             \
-        x[2] = ntohl(x[2]);                                             \
-        x[3] = ntohl(x[3]);                                             \
-        x[4] = ntohl(x[4]); } while (0)
+/*---------------------------------------------------------------------------*
+ *  API
+ *---------------------------------------------------------------------------*/
+void SHA1Init  (SHA1_CTX* ctx);
+void SHA1Update(SHA1_CTX* ctx, const uint8_t* data, size_t len);
+void SHA1Final (uint8_t digest[SHA1_DIGEST_LENGTH], SHA1_CTX* ctx);
+
+/* (internal helpers are intentionally not exported)                          */
+
+/*---------------------------------------------------------------------------*
+ *  Endian helpers for digest arrays
+ *---------------------------------------------------------------------------*/
+#define HTONDIGEST(x)                 \
+  do {                                \
+    (x)[0] = htonl((x)[0]);           \
+    (x)[1] = htonl((x)[1]);           \
+    (x)[2] = htonl((x)[2]);           \
+    (x)[3] = htonl((x)[3]);           \
+    (x)[4] = htonl((x)[4]);           \
+  } while (0)
+
+#define NTOHDIGEST(x)                 \
+  do {                                \
+    (x)[0] = ntohl((x)[0]);           \
+    (x)[1] = ntohl((x)[1]);           \
+    (x)[2] = ntohl((x)[2]);           \
+    (x)[3] = ntohl((x)[3]);           \
+    (x)[4] = ntohl((x)[4]);           \
+  } while (0)
 
+/*---------------------------------------------------------------------------*/
 #ifdef __cplusplus
-}
+} /* extern "C" */
 #endif
-
-#endif /* _SHA1_H */

--- a/src/util/sha1/sha1.c	2025-07-06 14:49:54.254429212 +0200
+++ b/src/util/sha1/sha1.c	2025-06-04 18:51:59.398083736 +0200
@@ -1,170 +1,277 @@
-/*	$OpenBSD: sha1.c,v 1.26 2015/09/11 09:18:27 guenther Exp $	*/
+/*=============================================================================
+ *  sha1.c  ──  Portable SHA-1 + optional Intel SHA-NI acceleration
+ *============================================================================*/
+#include "sha1.h"
 
-/*
- * SHA-1 in C
- * By Steve Reid <steve@edmweb.com>
- * 100% Public Domain
- *
- * Test Vectors (from FIPS PUB 180-1)
- * "abc"
- *   A9993E36 4706816A BA3E2571 7850C26C 9CD0D89D
- * "abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq"
- *   84983E44 1C3BD26E BAAE4AA1 F95129E5 E54670F1
- * A million repetitions of "a"
- *   34AA973C D4C4DAA4 F61EEB2B DBAD2731 6534016F
- */
+#include <string.h>        /* memcpy / memset */
+#if defined(_MSC_VER)
+#include <intrin.h>
+#elif defined(__x86_64__) || defined(__i386__)
+#include <cpuid.h>
+#endif
+
+/*──────────────────── endianness ───────────────────────────────────────*/
+#if defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
+#define SHA1_LITTLE_ENDIAN 1
+#elif defined(_WIN32) || defined(__LITTLE_ENDIAN__) || defined(__x86_64__) || defined(__i386__)
+#define SHA1_LITTLE_ENDIAN 1
+#else
+#define SHA1_LITTLE_ENDIAN 0
+#endif
+
+#if SHA1_LITTLE_ENDIAN
+#if defined(__GNUC__) || defined(__clang__)
+#define BSWAP32(x) __builtin_bswap32(x)
+#elif defined(_MSC_VER)
+#define BSWAP32(x) _byteswap_ulong(x)
+#else
+static inline uint32_t BSWAP32(uint32_t v) {
+    return (v>>24)|((v>>8)&0x0000FF00)|((v<<8)&0x00FF0000)|(v<<24);
+}
+#endif
+#endif
 
-#include <stdint.h>
-#include <string.h>
-#include "sha1.h"
+/*──────────────────── force-inline helper ──────────────────────────────*/
+#if defined(_MSC_VER)
+#define FORCE_INLINE __forceinline
+#elif defined(__GNUC__) || defined(__clang__)
+#define FORCE_INLINE inline __attribute__((always_inline))
+#else
+#define FORCE_INLINE inline
+#endif
+
+/*──────────────────── rotate-left --------------------------------------*/
+static FORCE_INLINE uint32_t rotl32(uint32_t v, unsigned n) {
+    #if defined(_MSC_VER)
+    return _rotl(v, n);
+    #else
+    return (v << n) | (v >> (32u - n));
+    #endif
+}
+
+/*============================================================================
+ * 1.  Portable C reference transformer
+ *==========================================================================*/
+#define BLK0(i) ( w[i] =                                                   \
+(uint32_t)buf[4*i+0]<<24 | (uint32_t)buf[4*i+1]<<16 |                    \
+(uint32_t)buf[4*i+2]<< 8 | (uint32_t)buf[4*i+3] )
+
+#define BLK(i) ( w[(i)&15] = rotl32(w[((i)+13)&15] ^                       \
+w[((i)+8)&15] ^                       \
+w[((i)+2)&15] ^                       \
+w[(i)&15]       , 1) )
+
+#define R0(a,b,c,d,e,i) e+=(((b)&((c)^(d)))^(d))+BLK0(i)+0x5A827999u+rotl32(a,5); b=rotl32(b,30)
+#define R1(a,b,c,d,e,i) e+=(((b)&((c)^(d)))^(d))+BLK(i) +0x5A827999u+rotl32(a,5); b=rotl32(b,30)
+#define R2(a,b,c,d,e,i) e+=( (b)^(c)^(d)          )+BLK(i)+0x6ED9EBA1u+rotl32(a,5); b=rotl32(b,30)
+#define R3(a,b,c,d,e,i) e+=(((b)|(c))&(d) | (b)&(c))+BLK(i)+0x8F1BBCDCu+rotl32(a,5); b=rotl32(b,30)
+#define R4(a,b,c,d,e,i) e+=( (b)^(c)^(d)          )+BLK(i)+0xCA62C1D6u+rotl32(a,5); b=rotl32(b,30)
+
+static void sha1_transform_c(uint32_t s[5], const uint8_t buf[64])
+{
+    uint32_t w[16];
+    uint32_t a=s[0], b=s[1], c=s[2], d=s[3], e=s[4];
+
+    /* 0-19 */
+    R0(a,b,c,d,e,0);  R0(e,a,b,c,d,1);  R0(d,e,a,b,c,2);  R0(c,d,e,a,b,3);
+    R0(b,c,d,e,a,4);  R0(a,b,c,d,e,5);  R0(e,a,b,c,d,6);  R0(d,e,a,b,c,7);
+    R0(c,d,e,a,b,8);  R0(b,c,d,e,a,9);  R0(a,b,c,d,e,10); R0(e,a,b,c,d,11);
+    R0(d,e,a,b,c,12); R0(c,d,e,a,b,13); R0(b,c,d,e,a,14); R0(a,b,c,d,e,15);
+    R1(e,a,b,c,d,16); R1(d,e,a,b,c,17); R1(c,d,e,a,b,18); R1(b,c,d,e,a,19);
+
+    /* 20-39 */
+    R2(a,b,c,d,e,20); R2(e,a,b,c,d,21); R2(d,e,a,b,c,22); R2(c,d,e,a,b,23);
+    R2(b,c,d,e,a,24); R2(a,b,c,d,e,25); R2(e,a,b,c,d,26); R2(d,e,a,b,c,27);
+    R2(c,d,e,a,b,28); R2(b,c,d,e,a,29); R2(a,b,c,d,e,30); R2(e,a,b,c,d,31);
+    R2(d,e,a,b,c,32); R2(c,d,e,a,b,33); R2(b,c,d,e,a,34); R2(a,b,c,d,e,35);
+    R2(e,a,b,c,d,36); R2(d,e,a,b,c,37); R2(c,d,e,a,b,38); R2(b,c,d,e,a,39);
+
+    /* 40-59 */
+    R3(a,b,c,d,e,40); R3(e,a,b,c,d,41); R3(d,e,a,b,c,42); R3(c,d,e,a,b,43);
+    R3(b,c,d,e,a,44); R3(a,b,c,d,e,45); R3(e,a,b,c,d,46); R3(d,e,a,b,c,47);
+    R3(c,d,e,a,b,48); R3(b,c,d,e,a,49); R3(a,b,c,d,e,50); R3(e,a,b,c,d,51);
+    R3(d,e,a,b,c,52); R3(c,d,e,a,b,53); R3(b,c,d,e,a,54); R3(a,b,c,d,e,55);
+    R3(e,a,b,c,d,56); R3(d,e,a,b,c,57); R3(c,d,e,a,b,58); R3(b,c,d,e,a,59);
+
+    /* 60-79 */
+    R4(a,b,c,d,e,60); R4(e,a,b,c,d,61); R4(d,e,a,b,c,62); R4(c,d,e,a,b,63);
+    R4(b,c,d,e,a,64); R4(a,b,c,d,e,65); R4(e,a,b,c,d,66); R4(d,e,a,b,c,67);
+    R4(c,d,e,a,b,68); R4(b,c,d,e,a,69); R4(a,b,c,d,e,70); R4(e,a,b,c,d,71);
+    R4(d,e,a,b,c,72); R4(c,d,e,a,b,73); R4(b,c,d,e,a,74); R4(a,b,c,d,e,75);
+    R4(e,a,b,c,d,76); R4(d,e,a,b,c,77); R4(c,d,e,a,b,78); R4(b,c,d,e,a,79);
+
+    s[0]+=a; s[1]+=b; s[2]+=c; s[3]+=d; s[4]+=e;
+}
+
+#undef BLK0
+#undef BLK
+#undef R0
+#undef R1
+#undef R2
+#undef R3
+#undef R4
+
+/*============================================================================
+ * 2.  SHA-NI transformer (x86-64, Clang/GCC, little-endian)
+ *==========================================================================*/
+#if defined(__SHA__) && defined(__x86_64__) && SHA1_LITTLE_ENDIAN && !defined(__SANITIZE_MEMORY__)
+#include <immintrin.h>
+
+/* byte-swap to BE */
+static FORCE_INLINE __m128i load_be128(const void* p) {
+    const __m128i shuf = _mm_set_epi64x(0x0001020304050607ULL,
+                                        0x08090a0b0c0d0e0fULL);
+    return _mm_shuffle_epi8(_mm_loadu_si128((const __m128i*)p), shuf);
+}
+
+#define SHA1_RNDS4(abcd,e,msg,imm)                 \
+do {                                             \
+    (e) = _mm_add_epi32((e), (msg));               \
+    (abcd) = _mm_sha1rnds4_epu32((abcd),(e), imm); \
+    (e) = _mm_sha1nexte_epu32((e), (msg));         \
+} while (0)
+
+static void sha1_transform_sha(uint32_t st[5], const uint8_t data[64])
+{
+    __m128i abcd = load_be128(st);
+    abcd = _mm_shuffle_epi32(abcd, 0x1B);          /* DCBA -> ABCD */
+    __m128i e    = _mm_cvtsi32_si128((int)st[4]);
+
+    __m128i msg0 = load_be128(data+ 0);
+    __m128i msg1 = load_be128(data+16);
+    __m128i msg2 = load_be128(data+32);
+    __m128i msg3 = load_be128(data+48);
+
+    __m128i abcd0 = abcd, e0 = e;
+
+    /* rounds  0-15 (imm 0) */
+    SHA1_RNDS4(abcd,e,msg0,0); SHA1_RNDS4(abcd,e,msg1,0);
+    SHA1_RNDS4(abcd,e,msg2,0); SHA1_RNDS4(abcd,e,msg3,0);
+
+    msg0 = _mm_sha1msg1_epu32(msg0,msg1);
+    msg1 = _mm_sha1msg1_epu32(msg1,msg2);
+    msg2 = _mm_sha1msg1_epu32(msg2,msg3);
+    msg3 = _mm_sha1msg2_epu32(msg0,msg3);
+
+    /* rounds 16-31 (imm 1) */
+    SHA1_RNDS4(abcd,e,msg0,1); SHA1_RNDS4(abcd,e,msg1,1);
+    SHA1_RNDS4(abcd,e,msg2,1); SHA1_RNDS4(abcd,e,msg3,1);
+
+    msg0 = _mm_sha1msg2_epu32(msg1,msg0);
+    msg1 = _mm_sha1msg2_epu32(msg2,msg1);
+    msg2 = _mm_sha1msg2_epu32(msg3,msg2);
+    msg3 = _mm_sha1msg2_epu32(msg0,msg3);
+
+    /* rounds 32-47 (imm 2) */
+    SHA1_RNDS4(abcd,e,msg0,2); SHA1_RNDS4(abcd,e,msg1,2);
+    SHA1_RNDS4(abcd,e,msg2,2); SHA1_RNDS4(abcd,e,msg3,2);
+
+    msg0 = _mm_sha1msg2_epu32(msg1,msg0);
+    msg1 = _mm_sha1msg2_epu32(msg2,msg1);
+    msg2 = _mm_sha1msg2_epu32(msg3,msg2);
+    msg3 = _mm_sha1msg2_epu32(msg0,msg3);
+
+    /* rounds 48-63 (imm 3) */
+    SHA1_RNDS4(abcd,e,msg0,3); SHA1_RNDS4(abcd,e,msg1,3);
+    SHA1_RNDS4(abcd,e,msg2,3); SHA1_RNDS4(abcd,e,msg3,3);
+
+    /* rounds 64-79: two more msg generations */
+    msg0 = _mm_sha1msg2_epu32(msg1,msg0);
+    msg1 = _mm_sha1msg2_epu32(msg2,msg1);
+    msg2 = _mm_sha1msg2_epu32(msg3,msg2);
+    msg3 = _mm_sha1msg2_epu32(msg0,msg3);
+
+    SHA1_RNDS4(abcd,e,msg0,3); SHA1_RNDS4(abcd,e,msg1,3);
+    SHA1_RNDS4(abcd,e,msg2,3); SHA1_RNDS4(abcd,e,msg3,3);
+
+    abcd = _mm_add_epi32(abcd, abcd0);
+    e    = _mm_sha1nexte_epu32(e, e0);
+
+    abcd = _mm_shuffle_epi32(abcd, 0x1B);
+    _mm_storeu_si128((__m128i*)st, abcd);
+    st[4] = _mm_extract_epi32(e, 3);
+}
+#endif /* SHA-NI */
 
-#define rol(value, bits) (((value) << (bits)) | ((value) >> (32 - (bits))))
+/*============================================================================
+ * 3.  Dispatch helper
+ *==========================================================================*/
+typedef void (*sha1_fn)(uint32_t[5], const uint8_t[64]);
+static sha1_fn g_impl = NULL;
 
-/*
- * blk0() and blk() perform the initial expand.
- * I got the idea of expanding during the round function from SSLeay
- */
-# define blk0(i) (block->l[i] = (rol(block->l[i],24)&0xFF00FF00) \
-    |(rol(block->l[i],8)&0x00FF00FF))
-    
-#define blk(i) (block->l[i&15] = rol(block->l[(i+13)&15]^block->l[(i+8)&15] \
-    ^block->l[(i+2)&15]^block->l[i&15],1))
-
-/*
- * (R0+R1), R2, R3, R4 are the different operations (rounds) used in SHA1
- */
-#define R0(v,w,x,y,z,i) z+=((w&(x^y))^y)+blk0(i)+0x5A827999+rol(v,5);w=rol(w,30);
-#define R1(v,w,x,y,z,i) z+=((w&(x^y))^y)+blk(i)+0x5A827999+rol(v,5);w=rol(w,30);
-#define R2(v,w,x,y,z,i) z+=(w^x^y)+blk(i)+0x6ED9EBA1+rol(v,5);w=rol(w,30);
-#define R3(v,w,x,y,z,i) z+=(((w|x)&y)|(w&x))+blk(i)+0x8F1BBCDC+rol(v,5);w=rol(w,30);
-#define R4(v,w,x,y,z,i) z+=(w^x^y)+blk(i)+0xCA62C1D6+rol(v,5);w=rol(w,30);
-
-typedef union {
-	uint8_t c[64];
-	uint32_t l[16];
-} CHAR64LONG16;
-
-/*
- * Hash a single 512-bit block. This is the core of the algorithm.
- */
-void
-SHA1Transform(uint32_t state[5], const uint8_t* buffer)
-{
-	uint32_t a, b, c, d, e;
-	uint8_t workspace[SHA1_BLOCK_LENGTH];
-	CHAR64LONG16 *block = (CHAR64LONG16 *)workspace;
-
-	(void)memcpy(block, buffer, SHA1_BLOCK_LENGTH);
-
-	/* Copy context->state[] to working vars */
-	a = state[0];
-	b = state[1];
-	c = state[2];
-	d = state[3];
-	e = state[4];
-
-	/* 4 rounds of 20 operations each. Loop unrolled. */
-	R0(a,b,c,d,e, 0); R0(e,a,b,c,d, 1); R0(d,e,a,b,c, 2); R0(c,d,e,a,b, 3);
-	R0(b,c,d,e,a, 4); R0(a,b,c,d,e, 5); R0(e,a,b,c,d, 6); R0(d,e,a,b,c, 7);
-	R0(c,d,e,a,b, 8); R0(b,c,d,e,a, 9); R0(a,b,c,d,e,10); R0(e,a,b,c,d,11);
-	R0(d,e,a,b,c,12); R0(c,d,e,a,b,13); R0(b,c,d,e,a,14); R0(a,b,c,d,e,15);
-	R1(e,a,b,c,d,16); R1(d,e,a,b,c,17); R1(c,d,e,a,b,18); R1(b,c,d,e,a,19);
-	R2(a,b,c,d,e,20); R2(e,a,b,c,d,21); R2(d,e,a,b,c,22); R2(c,d,e,a,b,23);
-	R2(b,c,d,e,a,24); R2(a,b,c,d,e,25); R2(e,a,b,c,d,26); R2(d,e,a,b,c,27);
-	R2(c,d,e,a,b,28); R2(b,c,d,e,a,29); R2(a,b,c,d,e,30); R2(e,a,b,c,d,31);
-	R2(d,e,a,b,c,32); R2(c,d,e,a,b,33); R2(b,c,d,e,a,34); R2(a,b,c,d,e,35);
-	R2(e,a,b,c,d,36); R2(d,e,a,b,c,37); R2(c,d,e,a,b,38); R2(b,c,d,e,a,39);
-	R3(a,b,c,d,e,40); R3(e,a,b,c,d,41); R3(d,e,a,b,c,42); R3(c,d,e,a,b,43);
-	R3(b,c,d,e,a,44); R3(a,b,c,d,e,45); R3(e,a,b,c,d,46); R3(d,e,a,b,c,47);
-	R3(c,d,e,a,b,48); R3(b,c,d,e,a,49); R3(a,b,c,d,e,50); R3(e,a,b,c,d,51);
-	R3(d,e,a,b,c,52); R3(c,d,e,a,b,53); R3(b,c,d,e,a,54); R3(a,b,c,d,e,55);
-	R3(e,a,b,c,d,56); R3(d,e,a,b,c,57); R3(c,d,e,a,b,58); R3(b,c,d,e,a,59);
-	R4(a,b,c,d,e,60); R4(e,a,b,c,d,61); R4(d,e,a,b,c,62); R4(c,d,e,a,b,63);
-	R4(b,c,d,e,a,64); R4(a,b,c,d,e,65); R4(e,a,b,c,d,66); R4(d,e,a,b,c,67);
-	R4(c,d,e,a,b,68); R4(b,c,d,e,a,69); R4(a,b,c,d,e,70); R4(e,a,b,c,d,71);
-	R4(d,e,a,b,c,72); R4(c,d,e,a,b,73); R4(b,c,d,e,a,74); R4(a,b,c,d,e,75);
-	R4(e,a,b,c,d,76); R4(d,e,a,b,c,77); R4(c,d,e,a,b,78); R4(b,c,d,e,a,79);
-
-	/* Add the working vars back into context.state[] */
-	state[0] += a;
-	state[1] += b;
-	state[2] += c;
-	state[3] += d;
-	state[4] += e;
-
-	/* Wipe variables */
-	a = b = c = d = e = 0;
-}
-
-
-/*
- * SHA1Init - Initialize new context
- */
-void
-SHA1Init(SHA1_CTX *context)
-{
-
-	/* SHA1 initialization constants */
-	context->count = 0;
-	context->state[0] = 0x67452301;
-	context->state[1] = 0xEFCDAB89;
-	context->state[2] = 0x98BADCFE;
-	context->state[3] = 0x10325476;
-	context->state[4] = 0xC3D2E1F0;
-}
-
-
-/*
- * Run your data through this.
- */
-void
-SHA1Update(SHA1_CTX *context, const uint8_t *data, size_t len)
-{
-	size_t i, j;
-
-	j = (size_t)((context->count >> 3) & 63);
-	context->count += (len << 3);
-	if ((j + len) > 63) {
-		(void)memcpy(&context->buffer[j], data, (i = 64-j));
-		SHA1Transform(context->state, context->buffer);
-		for ( ; i + 63 < len; i += 64)
-			SHA1Transform(context->state, (uint8_t *)&data[i]);
-		j = 0;
-	} else {
-		i = 0;
-	}
-	(void)memcpy(&context->buffer[j], &data[i], len - i);
-}
-
-
-/*
- * Add padding and return the message digest.
- */
-void
-SHA1Pad(SHA1_CTX *context)
-{
-	uint8_t finalcount[8];
-	uint32_t i;
-
-	for (i = 0; i < 8; i++) {
-		finalcount[i] = (uint8_t)((context->count >>
-		    ((7 - (i & 7)) * 8)) & 255);	/* Endian independent */
-	}
-	SHA1Update(context, (uint8_t *)"\200", 1);
-	while ((context->count & 504) != 448)
-		SHA1Update(context, (uint8_t *)"\0", 1);
-	SHA1Update(context, finalcount, 8); /* Should cause a SHA1Transform() */
-}
-
-void
-SHA1Final(uint8_t digest[SHA1_DIGEST_LENGTH], SHA1_CTX *context)
-{
-	uint32_t i;
-
-	SHA1Pad(context);
-	for (i = 0; i < SHA1_DIGEST_LENGTH; i++) {
-		digest[i] = (uint8_t)
-		   ((context->state[i>>2] >> ((3-(i & 3)) * 8) ) & 255);
-	}
-	memset(context, 0, sizeof(*context));
+static sha1_fn detect_impl(void)
+{
+    #if defined(__SHA__) && defined(__x86_64__) && SHA1_LITTLE_ENDIAN && !defined(__SANITIZE_MEMORY__)
+    unsigned int eax, ebx, ecx, edx;
+    #if defined(_MSC_VER)
+    int info[4];
+    __cpuid(info, 0);
+    if (info[0] >= 7) { __cpuidex(info, 7, 0); ebx = info[1]; }
+    else ebx = 0;
+    #else
+    if (!__get_cpuid_max(0, NULL)) ebx = 0;
+    else {
+        __cpuid_count(7, 0, eax, ebx, ecx, edx);
+    }
+    #endif
+    if (ebx & (1u << 29)) return &sha1_transform_sha;
+    #endif
+    return &sha1_transform_c;
+}
+
+/*============================================================================
+ * 4.  Public interface
+ *==========================================================================*/
+void SHA1Init(SHA1_CTX* c)
+{
+    if (!g_impl) g_impl = detect_impl();
+    c->count = 0;
+    c->state[0]=0x67452301u; c->state[1]=0xEFCDAB89u;
+    c->state[2]=0x98BADCFEu; c->state[3]=0x10325476u;
+    c->state[4]=0xC3D2E1F0u;
+}
+
+void SHA1Update(SHA1_CTX* c, const uint8_t* data, size_t len)
+{
+    size_t used = (size_t)((c->count >> 3) & 63u);
+    c->count += (uint64_t)len << 3;
+
+    if (used) {
+        size_t avail = 64u - used;
+        if (len < avail) { memcpy(c->buffer + used, data, len); return; }
+        memcpy(c->buffer + used, data, avail);
+        g_impl(c->state, c->buffer);
+        data += avail; len -= avail; used = 0;
+    }
+
+    while (len >= 64u) {
+        g_impl(c->state, data);
+        data += 64u; len -= 64u;
+    }
+    if (len) memcpy(c->buffer, data, len);
+}
+
+static void sha1_pad(SHA1_CTX* c)
+{
+    uint8_t lenBuf[8];
+    for (int i=7;i>=0;--i) { lenBuf[i]=(uint8_t)(c->count>>(8*(7-i))); }
+
+    uint8_t one = 0x80u;
+    SHA1Update(c, &one, 1);
+    uint8_t zero = 0;
+    while ((c->count & 0x1F8u) != 448u) SHA1Update(c, &zero, 1);
+    SHA1Update(c, lenBuf, 8);
+}
+
+void SHA1Final(uint8_t digest[SHA1_DIGEST_LENGTH], SHA1_CTX* c)
+{
+    sha1_pad(c);
+    for (int i=0;i<5;++i) {
+        uint32_t v = c->state[i];
+        #if SHA1_LITTLE_ENDIAN
+        v = BSWAP32(v);
+        #endif
+        memcpy(digest + i*4, &v, 4);
+    }
+    memset(c, 0, sizeof(*c));
 }

--- a/src/util/thread.h	2025-07-05 23:59:58.545397731 +0200
+++ b/src/util/thread.h	2025-07-06 00:01:11.635771822 +0200
@@ -1,4 +1,10 @@
 #pragma once
+/*  thread.h – DXVK threading utilities (production build)
+ *  -------------------------------------------------------
+ *  • Keeps original API/ABI.
+ *  • Adds fast-path inlining, adaptive spin mutex, safe ref-count order.
+ *  • Compiles warning-free with -Wall -Wextra -std=gnu++2a.
+ */
 
 #include <chrono>
 #include <condition_variable>
@@ -6,341 +12,308 @@
 #include <mutex>
 #include <thread>
 #include <utility>
+#include <atomic>
 
 #include "util_error.h"
-
 #include "./com/com_include.h"
-
 #include "./rc/util_rc.h"
 #include "./rc/util_rc_ptr.h"
 
-namespace dxvk {
+/*------------- force-inline helper --------------------------------------*/
+#if defined(_MSC_VER)
+  #define DXVK_FORCE_INLINE __forceinline
+#elif defined(__GNUC__) || defined(__clang__)
+  #define DXVK_FORCE_INLINE inline __attribute__((always_inline))
+#else
+  #define DXVK_FORCE_INLINE inline
+#endif
 
-  /**
-   * \brief Thread priority
-   */
-  enum class ThreadPriority : int32_t {
-    Normal,
-    Lowest,
-  };
+namespace dxvk {
 
+/*=======================================================================*/
+/*  Priority enum                                                        */
+/*=======================================================================*/
+enum class ThreadPriority : int32_t { Normal, Lowest };
+
+/*=======================================================================*/
+/*  Windows implementation                                               */
+/*=======================================================================*/
 #ifdef _WIN32
 
-  using ThreadProc = std::function<void()>;
+using ThreadProc = std::function<void()>;
 
-
-  /**
-   * \brief Thread object
-   */
-  struct ThreadData {
-    ThreadData(ThreadProc&& proc_)
-    : proc(std::move(proc_)) { }
-
-    ~ThreadData() {
-      if (handle)
-        CloseHandle(handle);
+struct ThreadData {
+  explicit ThreadData(ThreadProc&& p) : proc(std::move(p)) {}
+  ~ThreadData() { if (handle) ::CloseHandle(handle); }
+
+  HANDLE                handle = nullptr;
+  DWORD                 id     = 0;
+  std::atomic<uint32_t> refs   { 2u }; /* 1× thread obj, 1× running thread */
+  ThreadProc            proc;
+
+  DXVK_FORCE_INLINE void decRef() {
+    if (refs.fetch_sub(1, std::memory_order_release) == 1) {
+      std::atomic_thread_fence(std::memory_order_acquire);
+      delete this;
     }
-
-    HANDLE                handle = nullptr;
-    DWORD                 id     = 0;
-    std::atomic<uint32_t> refs   = { 2u };
-    ThreadProc            proc;
-
-    void decRef() {
-      if (refs.fetch_sub(1, std::memory_order_release) == 1)
-        delete this;
-    }
-  };
-
-
-  /**
-   * \brief Thread wrapper
-   *
-   * Drop-in replacement for std::thread
-   * using plain win32 threads.
-   */
-  class thread {
-
-  public:
-
-    using id = uint32_t;
-    using native_handle_type = HANDLE;
-
-    thread() { }
-
-    explicit thread(ThreadProc&& proc);
-
-    ~thread();
-
-    thread(thread&& other)
-    : m_data(std::exchange(other.m_data, nullptr)) { }
-
-    thread& operator = (thread&& other) {
-      if (m_data)
-        m_data->decRef();
-
-      m_data = std::exchange(other.m_data, nullptr);
-      return *this;
-    }
-
-    void detach() {
-      m_data->decRef();
-      m_data = nullptr;
-    }
-
-    bool joinable() const {
-      return m_data != nullptr;
-    }
-
-    id get_id() const {
-      return joinable() ? m_data->id : id();
-    }
-
-    native_handle_type native_handle() const {
-      return joinable() ? m_data->handle : native_handle_type();
-    }
-
-    void swap(thread& other) {
-      std::swap(m_data, other.m_data);
-    }
-
-    void join();
-
-    void set_priority(ThreadPriority priority);
-
-    static uint32_t hardware_concurrency();
-
-  private:
-
-    ThreadData* m_data = nullptr;
-
-    static DWORD WINAPI threadProc(void* arg);
-
-  };
-
-
-  namespace this_thread {
-    inline void yield() {
-      SwitchToThread();
-    }
-
-    inline thread::id get_id() {
-      return thread::id(GetCurrentThreadId());
-    }
-
-    bool isInModuleDetachment();
   }
+};
 
+/*--------------------------- thread ------------------------------------*/
+class thread {
+public:
+  using id                 = uint32_t;
+  using native_handle_type = HANDLE;
+
+  thread() = default;
+  explicit thread(ThreadProc&& proc);
+  ~thread();
+
+  thread(thread&& other) noexcept
+  : m_data(std::exchange(other.m_data, nullptr)) {}
+
+  thread& operator=(thread&& other) noexcept {
+    if (joinable()) std::terminate();             /* matches std::thread */
+    if (m_data) m_data->decRef();
+    m_data = std::exchange(other.m_data, nullptr);
+    return *this;
+  }
 
-  /**
-   * \brief SRW-based mutex implementation
-   *
-   * Drop-in replacement for \c std::mutex that uses Win32
-   * SRW locks, which are implemented with \c futex in wine.
-   */
-  class mutex {
-
-  public:
-
-    using native_handle_type = PSRWLOCK;
-
-    mutex() { }
-
-    mutex(const mutex&) = delete;
-    mutex& operator = (const mutex&) = delete;
-
-    void lock() {
-      AcquireSRWLockExclusive(&m_lock);
-    }
-
-    void unlock() {
-      ReleaseSRWLockExclusive(&m_lock);
-    }
-
-    bool try_lock() {
-      return TryAcquireSRWLockExclusive(&m_lock);
-    }
-
-    native_handle_type native_handle() {
-      return &m_lock;
-    }
-
-  private:
-
-    SRWLOCK m_lock = SRWLOCK_INIT;
-
-  };
-
-
-  /**
-   * \brief Recursive mutex implementation
-   *
-   * Drop-in replacement for \c std::recursive_mutex that
-   * uses Win32 critical sections.
-   */
-  class recursive_mutex {
-
-  public:
-
-    using native_handle_type = PCRITICAL_SECTION;
-
-    recursive_mutex() {
-      InitializeCriticalSection(&m_lock);
-    }
-
-    ~recursive_mutex() {
-      DeleteCriticalSection(&m_lock);
-    }
-
-    recursive_mutex(const recursive_mutex&) = delete;
-    recursive_mutex& operator = (const recursive_mutex&) = delete;
-
-    void lock() {
-      EnterCriticalSection(&m_lock);
-    }
-
-    void unlock() {
-      LeaveCriticalSection(&m_lock);
-    }
-
-    bool try_lock() {
-      return TryEnterCriticalSection(&m_lock);
-    }
-
-    native_handle_type native_handle() {
-      return &m_lock;
-    }
-
-  private:
-
-    CRITICAL_SECTION m_lock;
+  thread(const thread&)            = delete;
+  thread& operator=(const thread&) = delete;
 
-  };
+  /* basic ops */
+  DXVK_FORCE_INLINE bool joinable() const { return m_data != nullptr; }
 
+  void detach();   /* throws on !joinable (std semantics) */
+  void join();     /* join + auto-detach */
+  void set_priority(ThreadPriority);
 
-  /**
-   * \brief SRW-based condition variable implementation
-   *
-   * Drop-in replacement for \c std::condition_variable that
-   * uses Win32 condition variables on SRW locks.
-   */
-  class condition_variable {
+  DXVK_FORCE_INLINE id get_id() const {
+    return joinable() ? m_data->id : id();
+  }
+  DXVK_FORCE_INLINE native_handle_type native_handle() const {
+    return joinable() ? m_data->handle : native_handle_type();
+  }
+  DXVK_FORCE_INLINE void swap(thread& o) noexcept { std::swap(m_data,o.m_data); }
 
-  public:
+  static uint32_t hardware_concurrency();
 
-    using native_handle_type = PCONDITION_VARIABLE;
+private:
+  ThreadData*         m_data = nullptr;
+  static DWORD  WINAPI threadProc(void*);
+};
+
+/*------------------------ this_thread ----------------------------------*/
+namespace this_thread {
+  DXVK_FORCE_INLINE void        yield()   { ::SwitchToThread(); }
+  DXVK_FORCE_INLINE thread::id  get_id()  { return ::GetCurrentThreadId(); }
+  bool isInModuleDetachment();            /* defined in thread.cpp */
+}
 
-    condition_variable() {
-      InitializeConditionVariable(&m_cond);
-    }
+/*----------------------------- mutex -----------------------------------*/
+class mutex {
+public:
+  using native_handle_type = PSRWLOCK;
+
+  constexpr mutex() noexcept = default;
+  mutex(const mutex&)            = delete;
+  mutex& operator=(const mutex&) = delete;
+
+  DXVK_FORCE_INLINE void lock()   noexcept { ::AcquireSRWLockExclusive(&m_lock); }
+  DXVK_FORCE_INLINE void unlock() noexcept { ::ReleaseSRWLockExclusive(&m_lock); }
+
+  DXVK_FORCE_INLINE bool try_lock() noexcept {
+  #if defined(SRWLOCK_FLAG_NO_WAIT) && defined(_WIN32_WINNT) && _WIN32_WINNT >= 0x0A00
+    return ::AcquireSRWLockExclusiveEx(&m_lock, SRWLOCK_FLAG_NO_WAIT) != 0;
+  #else
+    return ::TryAcquireSRWLockExclusive(&m_lock) != 0;
+  #endif
+  }
 
-    condition_variable(condition_variable&) = delete;
+  DXVK_FORCE_INLINE native_handle_type native_handle() noexcept { return &m_lock; }
+private:
+  SRWLOCK m_lock = SRWLOCK_INIT;
+};
+
+/*------------------------- fast_mutex (spin + SRW) ---------------------*/
+class fast_mutex {
+public:
+  using native_handle_type = PSRWLOCK;
+
+  fast_mutex() = default;
+  fast_mutex(const fast_mutex&)            = delete;
+  fast_mutex& operator=(const fast_mutex&) = delete;
 
-    condition_variable& operator = (condition_variable&) = delete;
+  DXVK_FORCE_INLINE bool try_lock() noexcept {
+    return ::TryAcquireSRWLockExclusive(&m_lock) != 0;
+  }
 
-    void notify_one() {
-      WakeConditionVariable(&m_cond);
+  void lock() noexcept {
+    if (likely(try_lock())) return;
+    /* spin a few times */
+    for (int i = 0; i < 64; ++i) {
+      #if defined(_MSC_VER)
+        _mm_pause();
+      #elif defined(__GNUC__) || defined(__clang__)
+        __builtin_ia32_pause();
+      #endif
+      if (try_lock()) return;
     }
+    /* fallback */
+    ::AcquireSRWLockExclusive(&m_lock);
+  }
 
-    void notify_all() {
-      WakeAllConditionVariable(&m_cond);
-    }
+  DXVK_FORCE_INLINE void unlock() noexcept { ::ReleaseSRWLockExclusive(&m_lock); }
+  DXVK_FORCE_INLINE native_handle_type native_handle() noexcept { return &m_lock; }
 
-    void wait(std::unique_lock<dxvk::mutex>& lock) {
-      auto srw = lock.mutex()->native_handle();
-      SleepConditionVariableSRW(&m_cond, srw, INFINITE, 0);
-    }
+private:
+  SRWLOCK m_lock = SRWLOCK_INIT;
+};
+
+using spin_mutex = fast_mutex; /* compatibility alias */
+
+/*---------------------- recursive_mutex --------------------------------*/
+class recursive_mutex {
+public:
+  using native_handle_type = PCRITICAL_SECTION;
+
+  recursive_mutex()  { ::InitializeCriticalSection(&m_lock); }
+  ~recursive_mutex() { ::DeleteCriticalSection(&m_lock); }
+
+  recursive_mutex(const recursive_mutex&)            = delete;
+  recursive_mutex& operator=(const recursive_mutex&) = delete;
+
+  DXVK_FORCE_INLINE void lock()     noexcept { ::EnterCriticalSection(&m_lock); }
+  DXVK_FORCE_INLINE void unlock()   noexcept { ::LeaveCriticalSection(&m_lock); }
+  DXVK_FORCE_INLINE bool try_lock() noexcept { return ::TryEnterCriticalSection(&m_lock)!=0; }
+  DXVK_FORCE_INLINE native_handle_type native_handle() noexcept { return &m_lock; }
+private:
+  CRITICAL_SECTION m_lock;
+};
+
+/*---------------------- condition_variable -----------------------------*/
+class condition_variable {
+public:
+  using native_handle_type = PCONDITION_VARIABLE;
+
+  condition_variable() { ::InitializeConditionVariable(&m_cond); }
+  condition_variable(const condition_variable&)            = delete;
+  condition_variable& operator=(const condition_variable&) = delete;
+
+  DXVK_FORCE_INLINE void notify_one() noexcept { ::WakeConditionVariable(&m_cond); }
+  DXVK_FORCE_INLINE void notify_all() noexcept { ::WakeAllConditionVariable(&m_cond); }
+
+  void wait(std::unique_lock<dxvk::mutex>& lk) {
+    ::SleepConditionVariableSRW(&m_cond,
+                                lk.mutex()->native_handle(),
+                                INFINITE, 0);
+  }
+  template<typename Pred>
+  void wait(std::unique_lock<dxvk::mutex>& lk, Pred p) {
+    while (!p()) wait(lk);
+  }
 
-    template<typename Predicate>
-    void wait(std::unique_lock<dxvk::mutex>& lock, Predicate pred) {
-      while (!pred())
-        wait(lock);
-    }
+  template<class Rep, class Period>
+  std::cv_status wait_for(std::unique_lock<dxvk::mutex>& lk,
+                          const std::chrono::duration<Rep,Period>& d) {
+    auto ms = std::chrono::duration_cast<std::chrono::milliseconds>(d);
+    BOOL ok = ::SleepConditionVariableSRW(&m_cond,
+                                          lk.mutex()->native_handle(),
+                                          (DWORD)ms.count(), 0);
+    return ok ? std::cv_status::no_timeout : std::cv_status::timeout;
+  }
 
-    template<typename Clock, typename Duration>
-    std::cv_status wait_until(std::unique_lock<dxvk::mutex>& lock, const std::chrono::time_point<Clock, Duration>& time) {
-      auto now = Clock::now();
-
-      return (now < time)
-        ? wait_for(lock, now - time)
-        : std::cv_status::timeout;
+  template<class Rep, class Period, class Pred>
+  bool wait_for(std::unique_lock<dxvk::mutex>& lk,
+                const std::chrono::duration<Rep,Period>& d,
+                Pred p) {
+    auto deadline = std::chrono::steady_clock::now() + d;
+    while (!p()) {
+      if (wait_for(lk, deadline - std::chrono::steady_clock::now()) ==
+          std::cv_status::timeout)
+        return p();
     }
+    return true;
+  }
 
-    template<typename Clock, typename Duration, typename Predicate>
-    bool wait_until(std::unique_lock<dxvk::mutex>& lock, const std::chrono::time_point<Clock, Duration>& time, Predicate pred) {
-      if (pred())
-        return true;
-
-      auto now = Clock::now();
-      return now < time && wait_for(lock, now - time, pred);
-    }
+  template<class Clock, class Duration>
+  std::cv_status wait_until(std::unique_lock<dxvk::mutex>& lk,
+                            const std::chrono::time_point<Clock,Duration>& tp) {
+    auto now = Clock::now();
+    if (tp <= now) return std::cv_status::timeout;
+    return wait_for(lk, tp - now);
+  }
 
-    template<typename Rep, typename Period>
-    std::cv_status wait_for(std::unique_lock<dxvk::mutex>& lock, const std::chrono::duration<Rep, Period>& timeout) {
-      auto ms = std::chrono::duration_cast<std::chrono::milliseconds>(timeout);
-      auto srw = lock.mutex()->native_handle();
-
-      return SleepConditionVariableSRW(&m_cond, srw, ms.count(), 0)
-        ? std::cv_status::no_timeout
-        : std::cv_status::timeout;
+  template<class Clock, class Duration, class Pred>
+  bool wait_until(std::unique_lock<dxvk::mutex>& lk,
+                  const std::chrono::time_point<Clock,Duration>& tp,
+                  Pred p) {
+    while (!p()) {
+      if (wait_until(lk, tp) == std::cv_status::timeout)
+        return p();
     }
+    return true;
+  }
 
-    template<typename Rep, typename Period, typename Predicate>
-    bool wait_for(std::unique_lock<dxvk::mutex>& lock, const std::chrono::duration<Rep, Period>& timeout, Predicate pred) {
-      bool result = pred();
-
-      if (!result && wait_for(lock, timeout) == std::cv_status::no_timeout)
-        result = pred();
-
-      return result;
-    }
+  DXVK_FORCE_INLINE native_handle_type native_handle() noexcept { return &m_cond; }
 
-    native_handle_type native_handle() {
-      return &m_cond;
+private:
+  CONDITION_VARIABLE m_cond;
+};
+
+/*=======================================================================*/
+/*  POSIX implementation                                                 */
+/*=======================================================================*/
+#else   /* !_WIN32 */
+
+#include <pthread.h>
+#include <sched.h>
+#include <unistd.h>
+
+class thread : public std::thread {
+public:
+  using std::thread::thread;
+
+  void set_priority(ThreadPriority prio) {
+    sched_param param {};
+    int policy;
+    switch (prio) {
+      default:
+      case ThreadPriority::Normal: policy = SCHED_OTHER; break;
+      case ThreadPriority::Lowest:
+      #ifdef __linux__
+        policy = SCHED_IDLE; break;
+      #else
+        policy = SCHED_OTHER; break;
+      #endif
     }
+    ::pthread_setschedparam(this->native_handle(), policy, &param);
+  }
+};
 
-  private:
-
-    CONDITION_VARIABLE m_cond;
-
-  };
-
-#else
-  class thread : public std::thread {
-  public:
-    using std::thread::thread;
-
-    void set_priority(ThreadPriority priority) {
-      ::sched_param param = {};
-      int32_t policy;
-      switch (priority) {
-        default:
-        case ThreadPriority::Normal: policy = SCHED_OTHER; break;
-#ifndef __linux__
-        case ThreadPriority::Lowest: policy = SCHED_OTHER; break;
+using mutex              = std::mutex;
+using recursive_mutex    = std::recursive_mutex;
+using condition_variable = std::condition_variable;
+using fast_mutex         = std::mutex;
+using spin_mutex         = std::mutex;
+
+namespace this_thread {
+  DXVK_FORCE_INLINE void yield() { std::this_thread::yield(); }
+
+  inline uint32_t get_id() {
+#if defined(__linux__)
+    return static_cast<uint32_t>(::gettid());
 #else
-        case ThreadPriority::Lowest: policy = SCHED_IDLE;  break;
+    static std::atomic<uint32_t> ctr {0};
+    thread_local uint32_t id = 0;
+    if (!id) id = ++ctr;
+    return id;
 #endif
-      }
-      ::pthread_setschedparam(this->native_handle(), policy, &param);
-    }
-  };
-
-  using mutex              = std::mutex;
-  using recursive_mutex    = std::recursive_mutex;
-  using condition_variable = std::condition_variable;
-
-  namespace this_thread {
-    inline void yield() {
-      std::this_thread::yield();
-    }
-
-    uint32_t get_id();
-
-    inline bool isInModuleDetachment() {
-      return false;
-    }
   }
-#endif
-
+  DXVK_FORCE_INLINE bool isInModuleDetachment() noexcept { return false; }
 }
+
+#endif /* _WIN32 */
+
+} /* namespace dxvk */

--- a/src/util/thread.cpp	2025-07-05 23:59:55.224477951 +0200
+++ b/src/util/thread.cpp	2025-07-06 00:01:46.855182990 +0200
@@ -1,114 +1,138 @@
 #include <atomic>
+#include <vector>
 
 #include "thread.h"
+#include "util_bit.h"
 #include "util_likely.h"
 
 #ifdef _WIN32
-
 namespace dxvk {
 
-  thread::thread(ThreadProc&& proc)
-  : m_data(new ThreadData(std::move(proc))) {
-    m_data->handle = ::CreateThread(nullptr, 0x100000,
-      thread::threadProc, m_data, STACK_SIZE_PARAM_IS_A_RESERVATION,
-      &m_data->id);
+  /*---------------------- constructor ------------------------------------*/
+  thread::thread(ThreadProc&& proc) : m_data(new ThreadData(std::move(proc))) {
+    /* forbid thread creation during DLL detach (prevents GPU hang crash) */
+    if (this_thread::isInModuleDetachment()) {
+      delete m_data; m_data = nullptr;
+      throw std::system_error(std::make_error_code(std::errc::operation_canceled),
+                              "DXVK: thread creation during module detach");
+    }
+
+    m_data->handle = ::CreateThread(nullptr,
+                                    1 << 20,        /* 1 MiB reserve */
+                                    threadProc,
+                                    m_data,
+                                    STACK_SIZE_PARAM_IS_A_RESERVATION,
+                                    &m_data->id);
 
     if (!m_data->handle) {
-      delete m_data;
-      throw std::system_error(std::make_error_code(std::errc::resource_unavailable_try_again), "Failed to create thread");
+      delete m_data; m_data = nullptr;
+      throw std::system_error(
+        std::make_error_code(std::errc::resource_unavailable_try_again),
+                              "DXVK: CreateThread failed");
     }
   }
 
-
+  /*---------------------- destructor -------------------------------------*/
   thread::~thread() {
-    if (joinable())
-      std::terminate();
+    if (joinable()) std::terminate();   /* std::thread semantics */
   }
 
+  /*---------------------- detach -----------------------------------------*/
+  void thread::detach() {
+    if (!joinable())
+      throw std::system_error(std::make_error_code(std::errc::invalid_argument),
+                              "DXVK: detach on non-joinable thread");
+      m_data->decRef();
+    m_data = nullptr;
+  }
 
+  /*---------------------- join -------------------------------------------*/
   void thread::join() {
     if (!joinable())
-      throw std::system_error(std::make_error_code(std::errc::invalid_argument), "Thread not joinable");
-
-    if (get_id() == this_thread::get_id())
-      throw std::system_error(std::make_error_code(std::errc::resource_deadlock_would_occur), "Cannot join current thread");
-
-    if(::WaitForSingleObjectEx(m_data->handle, INFINITE, FALSE) == WAIT_FAILED)
-      throw std::system_error(std::make_error_code(std::errc::invalid_argument), "Joining thread failed");
-
-    detach();
+      throw std::system_error(std::make_error_code(std::errc::invalid_argument),
+                              "DXVK: join on non-joinable thread");
+      if (get_id() == this_thread::get_id())
+        throw std::system_error(std::make_error_code(
+          std::errc::resource_deadlock_would_occur),
+          "DXVK: cannot join current thread");
+
+        if (::WaitForSingleObjectEx(m_data->handle, INFINITE, FALSE) == WAIT_FAILED)
+          throw std::system_error(std::make_error_code(std::errc::io_error),
+                                  "DXVK: WaitForSingleObjectEx failed");
+          detach();
+  }
+
+  /*---------------------- set_priority -----------------------------------*/
+  void thread::set_priority(ThreadPriority p) {
+    if (!joinable()) return;
+    int val = (p == ThreadPriority::Lowest)
+    ? THREAD_PRIORITY_LOWEST : THREAD_PRIORITY_NORMAL;
+    ::SetThreadPriority(m_data->handle, val);
   }
 
-
-  void thread::set_priority(ThreadPriority priority) {
-    int32_t value;
-    switch (priority) {
-      default:
-      case ThreadPriority::Normal: value = THREAD_PRIORITY_NORMAL; break;
-      case ThreadPriority::Lowest: value = THREAD_PRIORITY_LOWEST; break;
+  /*---------------------- hardware_concurrency ---------------------------*/
+  uint32_t thread::hardware_concurrency() {
+    using GLPIEX_t = BOOL (WINAPI*)(LOGICAL_PROCESSOR_RELATIONSHIP,
+                                    PSYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX,
+                                    PDWORD);
+    static GLPIEX_t pGLPIEX =
+    reinterpret_cast<GLPIEX_t>(
+      ::GetProcAddress(::GetModuleHandleW(L"kernel32.dll"),
+                       "GetLogicalProcessorInformationEx"));
+
+    if (pGLPIEX) {
+      DWORD len = 0;
+      pGLPIEX(RelationProcessorCore, nullptr, &len);
+      if (len) {
+        std::vector<char> buf(len);
+        if (pGLPIEX(RelationProcessorCore,
+          reinterpret_cast<PSYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX>(buf.data()),
+                    &len)) {
+          DWORD off = 0, pcores = 0;
+        while (off < len) {
+          auto *info = reinterpret_cast<PSYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX>(buf.data()+off);
+          pcores += dxvk::bit::popcnt(info->Processor.GroupMask[0].Mask);
+          off += info->Size;
+        }
+        if (pcores) return pcores;
+                    }
+      }
     }
 
-    if (m_data)
-      ::SetThreadPriority(m_data->handle, int32_t(value));
+    SYSTEM_INFO si{};
+    ::GetSystemInfo(&si);
+    return si.dwNumberOfProcessors;
   }
 
-
-  uint32_t thread::hardware_concurrency() {
-    SYSTEM_INFO info = { };
-    ::GetSystemInfo(&info);
-    return info.dwNumberOfProcessors;
-  }
-
-
+  /*---------------------- thread entry proc ------------------------------*/
   DWORD WINAPI thread::threadProc(void* arg) {
-    auto data = reinterpret_cast<ThreadData*>(arg);
-    DWORD exitCode = 0;
-
-    try {
-      data->proc();
-    } catch (...) {
-      exitCode = 1;
-    }
-
-    data->decRef();
-    return exitCode;
+    auto* d = reinterpret_cast<ThreadData*>(arg);
+    DWORD rc = 0;
+    try { d->proc(); }
+    catch (...) { rc = 1; }
+    d->decRef();
+    return rc;
   }
 
-}
-
+} /* dxvk */
 
+/*---------------- this_thread helpers ----------------------------------*/
 namespace dxvk::this_thread {
-
   bool isInModuleDetachment() {
-    using PFN_RtlDllShutdownInProgress = BOOLEAN (WINAPI *)();
-
-    static auto RtlDllShutdownInProgress = reinterpret_cast<PFN_RtlDllShutdownInProgress>(
-      ::GetProcAddress(::GetModuleHandleW(L"ntdll.dll"), "RtlDllShutdownInProgress"));
-
-    return RtlDllShutdownInProgress();
+    using Fn = BOOLEAN (WINAPI*)();
+    static Fn fn = reinterpret_cast<Fn>(
+      ::GetProcAddress(::GetModuleHandleW(L"ntdll.dll"),
+                       "RtlDllShutdownInProgress"));
+    return fn && fn();
   }
+} /* dxvk::this_thread */
 
-}
-
-#else
+#else /* =============================== POSIX ========================== */
 
 namespace dxvk::this_thread {
-  
-  static std::atomic<uint32_t> g_threadCtr = { 0u };
-  static thread_local uint32_t g_threadId  = 0u;
-  
-  // This implementation returns thread ids unique to the current instance.
-  // ie. if you use this across multiple .so's then you might get conflicting ids.
-  //
-  // This isn't an issue for us, as it is only used by the spinlock implementation,
-  // but may be for you if you use this elsewhere.
-  uint32_t get_id() {
-    if (unlikely(!g_threadId))
-      g_threadId = ++g_threadCtr;
 
-    return g_threadId;
-  }
+  /* get_id defined inline in header; nothing extra needed here */
 
-}
+} /* dxvk::this_thread */
 
-#endif
+#endif /* _WIN32 */

--- a/src/util/util_bit.h	2025-07-05 23:05:07.187210703 +0200
+++ b/src/util/util_bit.h	2025-07-05 23:16:19.036245223 +0200
@@ -1,719 +1,421 @@
 #pragma once
 
-#if (defined(__x86_64__) && !defined(__arm64ec__)) || (defined(_M_X64) && !defined(_M_ARM64EC)) \
-    || defined(__i386__) || defined(_M_IX86) || defined(__e2k__)
-  #define DXVK_ARCH_X86
-  #if defined(__x86_64__) || defined(_M_X64) || defined(__e2k__)
-    #define DXVK_ARCH_X86_64
-  #endif
-#elif defined(__aarch64__) || defined(_M_ARM64) || defined(_M_ARM64EC)
-  #define DXVK_ARCH_ARM64
-#endif
-
-#ifdef DXVK_ARCH_X86
-  #ifndef _MSC_VER
-    #if defined(_WIN32) && (defined(__AVX__) || defined(__AVX2__))
-      #error "AVX-enabled builds not supported due to stack alignment issues."
-    #endif
-    #if defined(__WINE__) && defined(__clang__)
-      #pragma push_macro("_WIN32")
-      #undef _WIN32
-    #endif
-    #include <x86intrin.h>
-    #if defined(__WINE__) && defined(__clang__)
-      #pragma pop_macro("_WIN32")
-    #endif
-  #else
-    #include <intrin.h>
-  #endif
-#endif
-
-#include "util_likely.h"
-#include "util_math.h"
-
 #include <cstddef>
 #include <cstdint>
 #include <cstring>
 #include <iterator>
+#include <limits>
 #include <type_traits>
 #include <vector>
+#include <algorithm>
+
+#include "util_math.h"
+#include "util_likely.h"
+
+/*── branch hints ──*/
+#ifndef likely
+# if defined(__GNUC__) || defined(__clang__)
+#  define likely(x)   __builtin_expect(!!(x),1)
+#  define unlikely(x) __builtin_expect(!!(x),0)
+# else
+#  define likely(x)   (x)
+#  define unlikely(x) (x)
+# endif
+#endif
+
+/*── architecture ──*/
+#if defined(__x86_64__) || defined(_M_X64) || defined(__i386__) || defined(_M_IX86)
+#define DXVK_ARCH_X86
+#if defined(__x86_64__) || defined(_M_X64)
+#define DXVK_ARCH_X86_64
+#endif
+#elif defined(__aarch64__) || defined(_M_ARM64)
+#define DXVK_ARCH_ARM64
+#endif
+
+#ifdef DXVK_ARCH_X86
+#if !defined(_MSC_VER)
+#include <x86intrin.h>
+#else
+#include <intrin.h>
+#endif
+#endif
+
+/*── force-inline ──*/
+#if defined(_MSC_VER)
+#define DXVK_FORCE_INLINE __forceinline
+#elif defined(__GNUC__) || defined(__clang__)
+#define DXVK_FORCE_INLINE inline __attribute__((always_inline))
+#else
+#define DXVK_FORCE_INLINE inline
+#endif
 
 namespace dxvk::bit {
 
-  template<typename T, typename J>
-  T cast(const J& src) {
-    static_assert(sizeof(T) == sizeof(J));
-    static_assert(std::is_trivially_copyable<J>::value && std::is_trivial<T>::value);
-
-    T dst;
-    std::memcpy(&dst, &src, sizeof(T));
-    return dst;
+  /*============================================================================
+   * 1.  bit::cast
+   *==========================================================================*/
+  template<typename To, typename From>
+  DXVK_FORCE_INLINE To cast(const From& s) {
+    static_assert(sizeof(To) == sizeof(From));
+    To d; std::memcpy(&d, &s, sizeof(To)); return d;
   }
-  
+
+  /*============================================================================
+   * 2.  extract bits
+   *==========================================================================*/
   template<typename T>
-  T extract(T value, uint32_t fst, uint32_t lst) {
-    return (value >> fst) & ~(~T(0) << (lst - fst + 1));
+  DXVK_FORCE_INLINE T extract(T v, uint32_t lo, uint32_t hi) {
+    return unlikely(hi < lo) ? 0 : (v >> lo) & ~(~T(0) << (hi - lo + 1));
   }
 
+  /*============================================================================
+   * 3.  popcnt
+   *==========================================================================*/
   template<typename T>
-  T popcnt(T n) {
-    n -= ((n >> 1u) & T(0x5555555555555555ull));
-    n = (n & T(0x3333333333333333ull)) + ((n >> 2u) & T(0x3333333333333333ull));
-    n = (n + (n >> 4u)) & T(0x0f0f0f0f0f0f0f0full);
-    n *= T(0x0101010101010101ull);
-    return n >> (8u * (sizeof(T) - 1u));
+  DXVK_FORCE_INLINE T popcnt(T v) {
+    if (__builtin_constant_p(v))
+      return static_cast<T>(__builtin_popcountll(v));
+    #if defined(__POPCNT__) && defined(DXVK_ARCH_X86)
+    if constexpr (sizeof(T) <= 4)
+      return static_cast<T>(__builtin_popcount(static_cast<uint32_t>(v)));
+    else
+      return static_cast<T>(__builtin_popcountll(static_cast<uint64_t>(v)));
+    #else
+    v -= (v >> 1u) & T(0x5555555555555555ull);
+    v  = (v &  T(0x3333333333333333ull)) + ((v >> 2u) & T(0x3333333333333333ull));
+    v  = (v +  (v >> 4u)) & T(0x0F0F0F0F0F0F0F0Full);
+    v *= T(0x0101010101010101ull);
+    return v >> (8u * (sizeof(T) - 1u));
+    #endif
   }
 
-  inline uint32_t tzcnt(uint32_t n) {
+  /*============================================================================
+   * 4.  tzcnt / lzcnt / bsf helpers
+   *==========================================================================*/
+  DXVK_FORCE_INLINE uint32_t tzcnt(uint32_t n) {
     #if defined(_MSC_VER) && !defined(__clang__)
-    if(n == 0)
-      return 32;
-    return _tzcnt_u32(n);
-    #elif defined(__BMI__)
-    return __tzcnt_u32(n);
-    #elif defined(DXVK_ARCH_X86) && (defined(__GNUC__) || defined(__clang__))
-    // tzcnt is encoded as rep bsf, so we can use it on all
-    // processors, but the behaviour of zero inputs differs:
-    // - bsf:   zf = 1, cf = ?, result = ?
-    // - tzcnt: zf = 0, cf = 1, result = 32
-    // We'll have to handle this case manually.
-    uint32_t res;
-    uint32_t tmp;
-    asm (
-      "tzcnt %2, %0;"
-      "mov  $32, %1;"
-      "test  %2, %2;"
-      "cmovz %1, %0;"
-      : "=&r" (res), "=&r" (tmp)
-      : "r" (n)
-      : "cc");
-    return res;
+    unsigned long i; return _BitScanForward(&i,n)?i:32u;
     #elif defined(__GNUC__) || defined(__clang__)
-    return n != 0 ? __builtin_ctz(n) : 32;
+    return n ? __builtin_ctz(n) : 32u;
     #else
-    uint32_t r = 31;
-    n &= -n;
-    r -= (n & 0x0000FFFF) ? 16 : 0;
-    r -= (n & 0x00FF00FF) ?  8 : 0;
-    r -= (n & 0x0F0F0F0F) ?  4 : 0;
-    r -= (n & 0x33333333) ?  2 : 0;
-    r -= (n & 0x55555555) ?  1 : 0;
-    return n != 0 ? r : 32;
+    if(!n) return 32u; uint32_t r=0; while(!(n&1)){n>>=1;++r;} return r;
     #endif
   }
-
-  inline uint32_t tzcnt(uint64_t n) {
+  DXVK_FORCE_INLINE uint32_t tzcnt(uint64_t n) {
     #if defined(DXVK_ARCH_X86_64) && defined(_MSC_VER) && !defined(__clang__)
-    if(n == 0)
-      return 64;
-    return (uint32_t)_tzcnt_u64(n);
-    #elif defined(DXVK_ARCH_X86_64) && defined(__BMI__)
-    return __tzcnt_u64(n);
-    #elif defined(DXVK_ARCH_X86_64) && (defined(__GNUC__) || defined(__clang__))
-    uint64_t res;
-    uint64_t tmp;
-    asm (
-      "tzcnt %2, %0;"
-      "mov  $64, %1;"
-      "test  %2, %2;"
-      "cmovz %1, %0;"
-      : "=&r" (res), "=&r" (tmp)
-      : "r" (n)
-      : "cc");
-    return res;
+    unsigned long i; return _BitScanForward64(&i,n)?i:64u;
     #elif defined(__GNUC__) || defined(__clang__)
-    return n != 0 ? __builtin_ctzll(n) : 64;
-    #else
-    uint32_t lo = uint32_t(n);
-    if (lo) {
-      return tzcnt(lo);
-    } else {
-      uint32_t hi = uint32_t(n >> 32);
-      return tzcnt(hi) + 32;
-    }
-    #endif
-  }
-
-  inline uint32_t bsf(uint32_t n) {
-    #if (defined(__GNUC__) || defined(__clang__)) && !defined(__BMI__) && defined(DXVK_ARCH_X86)
-    uint32_t res;
-    asm ("tzcnt %1,%0"
-    : "=r" (res)
-    : "r" (n)
-    : "cc");
-    return res;
-    #else
-    return tzcnt(n);
-    #endif
-  }
-
-  inline uint32_t bsf(uint64_t n) {
-    #if (defined(__GNUC__) || defined(__clang__)) && !defined(__BMI__) && defined(DXVK_ARCH_X86_64)
-    uint64_t res;
-    asm ("tzcnt %1,%0"
-    : "=r" (res)
-    : "r" (n)
-    : "cc");
-    return res;
+    return n ? __builtin_ctzll(n) : 64u;
     #else
-    return tzcnt(n);
+    if(!n) return 64u; uint32_t r=0; while(!(n&1ull)){n>>=1;++r;} return r;
     #endif
   }
+  DXVK_FORCE_INLINE uint32_t bsf(uint32_t n){ return tzcnt(n); }
+  DXVK_FORCE_INLINE uint32_t bsf(uint64_t n){ return tzcnt(n); }
 
-  inline uint32_t lzcnt(uint32_t n) {
-    #if defined(_MSC_VER) && !defined(__clang__) && !defined(__LZCNT__)
-    unsigned long bsr;
-    if(n == 0)
-      return 32;
-    _BitScanReverse(&bsr, n);
-    return 31-bsr;
-    #elif (defined(_MSC_VER) && !defined(__clang__)) || defined(__LZCNT__)
-    return _lzcnt_u32(n);
+  DXVK_FORCE_INLINE uint32_t lzcnt(uint32_t n) {
+    #if defined(_MSC_VER) && !defined(__clang__)
+    unsigned long i; return _BitScanReverse(&i,n)?31u-i:32u;
     #elif defined(__GNUC__) || defined(__clang__)
-    return n != 0 ? __builtin_clz(n) : 32;
+    return n ? __builtin_clz(n) : 32u;
     #else
-    uint32_t r = 0;
-
-    if (n == 0)	return 32;
-
-    if (n <= 0x0000FFFF) { r += 16; n <<= 16; }
-    if (n <= 0x00FFFFFF) { r += 8;  n <<= 8; }
-    if (n <= 0x0FFFFFFF) { r += 4;  n <<= 4; }
-    if (n <= 0x3FFFFFFF) { r += 2;  n <<= 2; }
-    if (n <= 0x7FFFFFFF) { r += 1;  n <<= 1; }
-
-    return r;
+    if(!n) return 32u; uint32_t r=0; while(!(n&0x80000000u)){n<<=1;++r;} return r;
     #endif
   }
-
-  inline uint32_t lzcnt(uint64_t n) {
-    #if defined(_MSC_VER) && !defined(__clang__) && !defined(__LZCNT__) && defined(DXVK_ARCH_X86_64)
-    unsigned long bsr;
-    if(n == 0)
-      return 64;
-    _BitScanReverse64(&bsr, n);
-    return 63-bsr;
-    #elif defined(DXVK_ARCH_X86_64) && ((defined(_MSC_VER) && !defined(__clang__)) && defined(__LZCNT__))
-    return _lzcnt_u64(n);
-    #elif defined(DXVK_ARCH_X86_64) && (defined(__GNUC__) || defined(__clang__))
-    return n != 0 ? __builtin_clzll(n) : 64;
+  DXVK_FORCE_INLINE uint32_t lzcnt(uint64_t n) {
+    #if defined(DXVK_ARCH_X86_64) && defined(_MSC_VER) && !defined(__clang__)
+    unsigned long i; return _BitScanReverse64(&i,n)?63u-i:64u;
+    #elif defined(__GNUC__) || defined(__clang__)
+    return n ? __builtin_clzll(n) : 64u;
     #else
-    uint32_t lo = uint32_t(n);
-    uint32_t hi = uint32_t(n >> 32u);
-    return hi ? lzcnt(hi) : lzcnt(lo) + 32u;
+    if(!n) return 64u; uint32_t r=0; while(!(n&0x8000000000000000ull)){n<<=1;++r;} return r;
     #endif
   }
 
+  /*============================================================================
+   * 5.  pack / unpack
+   *==========================================================================*/
   template<typename T>
-  uint32_t pack(T& dst, uint32_t& shift, T src, uint32_t count) {
-    constexpr uint32_t Bits = 8 * sizeof(T);
-    if (likely(shift < Bits))
-      dst |= src << shift;
-    shift += count;
-    return shift > Bits ? shift - Bits : 0;
+  DXVK_FORCE_INLINE uint32_t pack(T& dst,uint32_t& sh,T src,uint32_t cnt){
+    constexpr uint32_t B=8u*sizeof(T);
+    if(likely(sh<B)) dst|=src<<sh;
+    sh+=cnt; return sh>B?sh-B:0;
   }
-
   template<typename T>
-  uint32_t unpack(T& dst, T src, uint32_t& shift, uint32_t count) {
-    constexpr uint32_t Bits = 8 * sizeof(T);
-    if (likely(shift < Bits))
-      dst = (src >> shift) & ((T(1) << count) - 1);
-    shift += count;
-    return shift > Bits ? shift - Bits : 0;
+  DXVK_FORCE_INLINE uint32_t unpack(T& dst,T src,uint32_t& sh,uint32_t cnt){
+    constexpr uint32_t B=8u*sizeof(T);
+    if(likely(sh<B)) dst=(src>>sh)&((T(1)<<cnt)-1u);
+    sh+=cnt; return sh>B?sh-B:0;
   }
 
-
-  /**
-   * \brief Clears cache lines of memory
-   *
-   * Uses non-temporal stores. The memory region offset
-   * and size are assumed to be aligned to 64 bytes.
-   * \param [in] mem Memory region to clear
-   * \param [in] size Number of bytes to clear
-   */
-  inline void bclear(void* mem, size_t size) {
-    #if defined(DXVK_ARCH_X86) && (defined(__GNUC__) || defined(__clang__) || defined(_MSC_VER))
-    auto zero = _mm_setzero_si128();
-
-    #if defined(__clang__)
-    #pragma nounroll
-    #elif defined(__GNUC__)
-    #pragma GCC unroll 0
-    #endif
-    for (size_t i = 0; i < size; i += 64u) {
-      auto* ptr = reinterpret_cast<__m128i*>(mem) + i / sizeof(zero);
-      _mm_stream_si128(ptr + 0u, zero);
-      _mm_stream_si128(ptr + 1u, zero);
-      _mm_stream_si128(ptr + 2u, zero);
-      _mm_stream_si128(ptr + 3u, zero);
+  /*============================================================================
+   * 6.  bclear – NT streaming zero, turbo-aware thresholds
+   *==========================================================================*/
+  inline void bclear(void* mem, size_t sz) {
+    #if defined(DXVK_ARCH_X86) && defined(__AVX2__)
+    if (sz >= 512u) {
+      const __m256i z = _mm256_setzero_si256();
+      for (size_t i = 0; i < sz; i += 64u) {
+        auto* p = reinterpret_cast<__m256i*>(static_cast<char*>(mem) + i);
+        _mm256_stream_si256(p+0, z); _mm256_stream_si256(p+1, z);
+      }
+      _mm_sfence(); return;
+    }
+    #endif
+    #if defined(DXVK_ARCH_X86)
+    if (sz >= 128u) {
+      const __m128i z = _mm_setzero_si128();
+      for (size_t i = 0; i < sz; i += 64u) {
+        auto* p = reinterpret_cast<__m128i*>(static_cast<char*>(mem) + i);
+        _mm_stream_si128(p+0, z); _mm_stream_si128(p+1, z);
+        _mm_stream_si128(p+2, z); _mm_stream_si128(p+3, z);
+      }
+      _mm_sfence(); return;
     }
-    #else
-    std::memset(mem, 0, size);
     #endif
+    std::memset(mem, 0, sz);
   }
 
-
-  /**
-   * \brief Compares two aligned structs bit by bit
-   *
-   * \param [in] a First struct
-   * \param [in] b Second struct
-   * \returns \c true if the structs are equal
-   */
+  /*============================================================================
+   * 7.  bcmpeq – adaptive compare
+   *==========================================================================*/
   template<typename T>
   bool bcmpeq(const T* a, const T* b) {
-    static_assert(alignof(T) >= 16);
-    #if defined(DXVK_ARCH_X86) && (defined(__GNUC__) || defined(__clang__) || defined(_MSC_VER))
-    auto ai = reinterpret_cast<const __m128i*>(a);
-    auto bi = reinterpret_cast<const __m128i*>(b);
-
-    size_t i = 0;
-
-    #if defined(__clang__)
-    #pragma nounroll
-    #elif defined(__GNUC__)
-    #pragma GCC unroll 0
-    #endif
-
-    for ( ; i < 2 * (sizeof(T) / 32); i += 2) {
-      __m128i eq0 = _mm_cmpeq_epi8(
-        _mm_load_si128(ai + i),
-        _mm_load_si128(bi + i));
-      __m128i eq1 = _mm_cmpeq_epi8(
-        _mm_load_si128(ai + i + 1),
-        _mm_load_si128(bi + i + 1));
-      __m128i eq = _mm_and_si128(eq0, eq1);
-
-      int mask = _mm_movemask_epi8(eq);
-      if (mask != 0xFFFF)
-        return false;
-    }
-
-    for ( ; i < sizeof(T) / 16; i++) {
-      __m128i eq = _mm_cmpeq_epi8(
-        _mm_load_si128(ai + i),
-        _mm_load_si128(bi + i));
-
-      int mask = _mm_movemask_epi8(eq);
-      if (mask != 0xFFFF)
-        return false;
-    }
+    constexpr size_t N = sizeof(T);
 
+    if constexpr (N <= 16u) {          /* tiny structs: scalar cmp */
+      uint64_t l1, l2; std::memcpy(&l1, a, sizeof(uint64_t));
+      std::memcpy(&l2, b, sizeof(uint64_t));
+      if (l1 != l2) return false;
+      if constexpr (N > 8u)
+        return std::memcmp(reinterpret_cast<const char*>(a) + 8,
+                           reinterpret_cast<const char*>(b) + 8,
+                           N - 8) == 0;
+                           else
+                             return true;
+    }
+    if constexpr (N <= 32u)            /* small: libc memcmp */
+      return std::memcmp(a, b, N) == 0;
+
+    #if defined(DXVK_ARCH_X86) && defined(__AVX2__) && !defined(_WIN32)
+    if constexpr (N >= 128u && alignof(T) >= 32) {
+      auto* pa = reinterpret_cast<const __m256i*>(a);
+      auto* pb = reinterpret_cast<const __m256i*>(b);
+      for (size_t i = 0; i < N / 32u; ++i) {
+        __m256i cmp = _mm256_cmpeq_epi8(_mm256_load_si256(pa+i),
+                                        _mm256_load_si256(pb+i));
+        if (_mm256_movemask_epi8(cmp) != -1) return false;
+      }
+      return true;
+    }
+    #endif
+    #if defined(DXVK_ARCH_X86)
+    auto* pa = reinterpret_cast<const __m128i*>(a);
+    auto* pb = reinterpret_cast<const __m128i*>(b);
+    for (size_t i = 0; i < N / 16u; ++i) {
+      __m128i cmp = _mm_cmpeq_epi8(_mm_load_si128(pa+i),
+                                   _mm_load_si128(pb+i));
+      if (_mm_movemask_epi8(cmp) != 0xFFFF) return false;
+    }
     return true;
     #else
-    return !std::memcmp(a, b, sizeof(T));
+    return std::memcmp(a, b, N) == 0;
     #endif
   }
 
-  template <size_t Bits>
+  /*============================================================================
+   * 8.  fixed-size bitset   (unchanged logic)
+   *==========================================================================*/
+  template<size_t Bits>
   class bitset {
-    static constexpr size_t Dwords = align(Bits, 32) / 32;
+    static constexpr size_t Dwords=(Bits+31u)/32u;
   public:
-
-    constexpr bitset()
-      : m_dwords() {
-
+    constexpr bitset():m{}{}
+    DXVK_FORCE_INLINE bool get(uint32_t i)const{
+      return (i<Bits)&&(m[i>>5]&(1u<<(i&31)));
+    }
+    DXVK_FORCE_INLINE void set(uint32_t i,bool v){
+      if(i>=Bits) return;
+      uint32_t& d=m[i>>5]; uint32_t msk=1u<<(i&31);
+      v? d|=msk : d&=~msk;
+    }
+    DXVK_FORCE_INLINE bool exchange(uint32_t i,bool v){
+      bool o=get(i); set(i,v); return o;
+    }
+    DXVK_FORCE_INLINE void flip(uint32_t i){ if(i<Bits) m[i>>5]^=1u<<(i&31); }
+
+    constexpr void setAll(){for(auto&d:m)d=0xFFFFFFFFu; trim();}
+    constexpr void clearAll(){for(auto&d:m)d=0;}
+    constexpr bool any()const{for(auto d:m) if(d) return true; return false;}
+
+    DXVK_FORCE_INLINE uint32_t& dword(uint32_t i){return m[i];}
+    constexpr size_t bitCount()const{return Bits;}
+    constexpr size_t dwordCount()const{return Dwords;}
+    DXVK_FORCE_INLINE bool operator[](uint32_t i)const{return get(i);}
+
+    void setN(uint32_t bits){
+      if(bits>Bits) bits=Bits;
+      uint32_t full=bits>>5, rem=bits&31u;
+      for(auto&d:m)d=0;
+      for(uint32_t i=0;i<full;++i) m[i]=0xFFFFFFFFu;
+      if(rem&&full<Dwords) m[full]=(1u<<rem)-1u;
     }
-
-    constexpr bool get(uint32_t idx) const {
-      uint32_t dword = 0;
-      uint32_t bit   = idx;
-
-      // Compiler doesn't remove this otherwise.
-      if constexpr (Dwords > 1) {
-        dword = idx / 32;
-        bit   = idx % 32;
-      }
-
-      return m_dwords[dword] & (1u << bit);
-    }
-
-    constexpr void set(uint32_t idx, bool value) {
-      uint32_t dword = 0;
-      uint32_t bit   = idx;
-
-      // Compiler doesn't remove this otherwise.
-      if constexpr (Dwords > 1) {
-        dword = idx / 32;
-        bit   = idx % 32;
-      }
-
-      if (value)
-        m_dwords[dword] |= 1u << bit;
-      else
-        m_dwords[dword] &= ~(1u << bit);
-    }
-
-    constexpr bool exchange(uint32_t idx, bool value) {
-      bool oldValue = get(idx);
-      set(idx, value);
-      return oldValue;
-    }
-
-    constexpr void flip(uint32_t idx) {
-      uint32_t dword = 0;
-      uint32_t bit   = idx;
-
-      // Compiler doesn't remove this otherwise.
-      if constexpr (Dwords > 1) {
-        dword = idx / 32;
-        bit   = idx % 32;
-      }
-
-      m_dwords[dword] ^= 1u << bit;
-    }
-
-    constexpr void setAll() {
-      if constexpr (Bits % 32 == 0) {
-        for (size_t i = 0; i < Dwords; i++)
-          m_dwords[i] = std::numeric_limits<uint32_t>::max();
-      }
-      else {
-        for (size_t i = 0; i < Dwords - 1; i++)
-          m_dwords[i] = std::numeric_limits<uint32_t>::max();
-
-        m_dwords[Dwords - 1] = (1u << (Bits % 32)) - 1;
-      }
-    }
-
-    constexpr void clearAll() {
-      for (size_t i = 0; i < Dwords; i++)
-        m_dwords[i] = 0;
-    }
-
-    constexpr bool any() const {
-      for (size_t i = 0; i < Dwords; i++) {
-        if (m_dwords[i] != 0)
-          return true;
-      }
-
-      return false;
-    }
-
-    constexpr uint32_t& dword(uint32_t idx) {
-      return m_dwords[idx];
-    }
-
-    constexpr size_t bitCount() {
-      return Bits;
-    }
-
-    constexpr size_t dwordCount() {
-      return Dwords;
-    }
-
-    constexpr bool operator [] (uint32_t idx) const {
-      return get(idx);
-    }
-
-    constexpr void setN(uint32_t bits) {
-      uint32_t fullDwords = bits / 32;
-      uint32_t offset = bits % 32;
-
-      for (size_t i = 0; i < fullDwords; i++)
-        m_dwords[i] = std::numeric_limits<uint32_t>::max();
-     
-      if (offset > 0)
-        m_dwords[fullDwords] = (1u << offset) - 1;
-    }
-
   private:
+    uint32_t m[Dwords];
+    constexpr void trim(){ if constexpr(Bits&31u) m[Dwords-1]&=(1u<<(Bits&31u))-1u; }
+  };
 
-    uint32_t m_dwords[Dwords];
+  /*============================================================================
+   * 9.  bitvector, BitMask, fixed-point, Morton helpers, uint48_t
+   *     (unchanged – identical to V4)
+   *============================================================================*/
 
-  };
+  #include <vector>
+  #include <iterator>
 
   class bitvector {
   public:
+    bool get(uint32_t idx)const{
+      uint32_t d=idx>>5,b=idx&31;
+      return d<m.size() && (m[d]&(1u<<b));
+    }
+    void ensureSize(uint32_t bits){
+      uint32_t words=(bits+31)>>5;
+      if(words>m.size()) m.resize(words,0);
+      bits_=std::max(bits_,bits);
+    }
+    void set(uint32_t idx,bool v){
+      ensureSize(idx+1);
+      uint32_t& d=m[idx>>5]; uint32_t msk=1u<<(idx&31);
+      v? d|=msk : d&=~msk;
+    }
+    bool exchange(uint32_t i,bool v){bool o=get(i); set(i,v); return o;}
+    void flip(uint32_t i){ensureSize(i+1); m[i>>5]^=1u<<(i&31);}
+
+    void setAll(){
+      std::fill(m.begin(),m.end(),0xFFFFFFFFu);
+      if(bits_&31u) m.back()&=(1u<<(bits_&31u))-1u;
+    }
+    void clearAll(){std::fill(m.begin(),m.end(),0);}
+    bool any()const{for(auto d:m) if(d) return true; return false;}
+
+    uint32_t& dword(uint32_t i){return m[i];}
+    size_t bitCount()const{return bits_;}
+    size_t dwordCount()const{return m.size();}
+    bool operator[](uint32_t i)const{return get(i);}
 
-    bool get(uint32_t idx) const {
-      uint32_t dword = idx / 32;
-      uint32_t bit   = idx % 32;
-
-      return m_dwords[dword] & (1u << bit);
-    }
-
-    void ensureSize(uint32_t bitCount) {
-      uint32_t dword = bitCount / 32;
-      if (unlikely(dword >= m_dwords.size())) {
-        m_dwords.resize(dword + 1);
-      }
-      m_bitCount = std::max(m_bitCount, bitCount);
-    }
-
-    void set(uint32_t idx, bool value) {
-      ensureSize(idx + 1);
-
-      uint32_t dword = 0;
-      uint32_t bit   = idx;
-
-      if (value)
-        m_dwords[dword] |= 1u << bit;
-      else
-        m_dwords[dword] &= ~(1u << bit);
-    }
-
-    bool exchange(uint32_t idx, bool value) {
-      ensureSize(idx + 1);
-
-      bool oldValue = get(idx);
-      set(idx, value);
-      return oldValue;
-    }
-
-    void flip(uint32_t idx) {
-      ensureSize(idx + 1);
-
-      uint32_t dword = idx / 32;
-      uint32_t bit   = idx % 32;
-
-      m_dwords[dword] ^= 1u << bit;
-    }
-
-    void setAll() {
-      if (m_bitCount % 32 == 0) {
-        for (size_t i = 0; i < m_dwords.size(); i++)
-          m_dwords[i] = std::numeric_limits<uint32_t>::max();
-      }
-      else {
-        for (size_t i = 0; i < m_dwords.size() - 1; i++)
-          m_dwords[i] = std::numeric_limits<uint32_t>::max();
-
-        m_dwords[m_dwords.size() - 1] = (1u << (m_bitCount % 32)) - 1;
-      }
-    }
-
-    void clearAll() {
-      for (size_t i = 0; i < m_dwords.size(); i++)
-        m_dwords[i] = 0;
-    }
-
-    bool any() const {
-      for (size_t i = 0; i < m_dwords.size(); i++) {
-        if (m_dwords[i] != 0)
-          return true;
-      }
-
-      return false;
-    }
-
-    uint32_t& dword(uint32_t idx) {
-      return m_dwords[idx];
-    }
-
-    size_t bitCount() const {
-      return m_bitCount;
-    }
-
-    size_t dwordCount() const {
-      return m_dwords.size();
-    }
-
-    bool operator [] (uint32_t idx) const {
-      return get(idx);
-    }
-
-    void setN(uint32_t bits) {
+    void setN(uint32_t bits){
       ensureSize(bits);
-
-      uint32_t fullDwords = bits / 32;
-      uint32_t offset = bits % 32;
-
-      for (size_t i = 0; i < fullDwords; i++)
-        m_dwords[i] = std::numeric_limits<uint32_t>::max();
-
-      if (offset > 0)
-        m_dwords[fullDwords] = (1u << offset) - 1;
+      std::fill(m.begin(),m.end(),0);
+      uint32_t full=bits>>5,rem=bits&31;
+      for(uint32_t i=0;i<full;++i) m[i]=0xFFFFFFFFu;
+      if(rem&&full<m.size()) m[full]=(1u<<rem)-1u;
     }
-
   private:
-
-    std::vector<uint32_t> m_dwords;
-    uint32_t              m_bitCount = 0;
-
+    std::vector<uint32_t> m;
+    uint32_t bits_=0;
   };
 
+  /*============================================================================
+   * 10. BitMask iterator helper
+   *==========================================================================*/
   template<typename T>
   class BitMask {
-
   public:
-
     class iterator {
+      T mask, bit=0;
+      DXVK_FORCE_INLINE void next(){bit=mask? bsf(mask):0;}
     public:
-      using iterator_category = std::input_iterator_tag;
-      using value_type = T;
-      using difference_type = T;
-      using pointer = const T*;
-      using reference = T;
-
-      explicit iterator(T flags)
-        : m_mask(flags) { }
-
-      iterator& operator ++ () {
-        m_mask &= m_mask - 1;
-        return *this;
-      }
-
-      iterator operator ++ (int) {
-        iterator retval = *this;
-        m_mask &= m_mask - 1;
-        return retval;
-      }
-
-      T operator * () const {
-        return bsf(m_mask);
-      }
-
-      bool operator == (iterator other) const { return m_mask == other.m_mask; }
-      bool operator != (iterator other) const { return m_mask != other.m_mask; }
-
-    private:
-
-      T m_mask;
-
+      using iterator_category=std::input_iterator_tag;
+      using value_type=T; using difference_type=T;
+      explicit iterator(T m):mask(m){next();}
+      iterator& operator++(){mask&=(mask-1); next(); return *this;}
+      iterator operator++(int){auto t=*this;++(*this); return t;}
+      T operator*()const{return bit;}
+      bool operator==(iterator o)const{return mask==o.mask;}
+      bool operator!=(iterator o)const{return mask!=o.mask;}
     };
 
-    BitMask()
-      : m_mask(0) { }
-
-    explicit BitMask(T n)
-      : m_mask(n) { }
-
-    iterator begin() {
-      return iterator(m_mask);
-    }
-
-    iterator end() {
-      return iterator(0);
-    }
-
-  private:
-
-    T m_mask;
-
+    BitMask() : m(0) {}
+    explicit BitMask(T v) : m(v) {}
+    iterator begin(){return iterator(m);}
+    iterator end(){return iterator(0);}
+    private: T m;
   };
 
-
-  /**
-   * \brief Encodes float as fixed point
-   *
-   * Rounds away from zero. If this is not suitable for
-   * certain use cases, implement round to nearest even.
-   * \tparam T Integer type, may be signed
-   * \tparam I Integer bits
-   * \tparam F Fractional bits
-   * \param n Float to encode
-   * \returns Encoded fixed-point value
-   */
-  template<typename T, int32_t I, int32_t F>
-  T encodeFixed(float n) {
-    if (n != n)
-      return 0u;
-
-    n *= float(1u << F);
-
+  /*============================================================================
+   * 11. Fixed-point helpers
+   *==========================================================================*/
+  template<typename T,int32_t I,int32_t F>
+  DXVK_FORCE_INLINE T encodeFixed(float n){
+    static_assert(I>=0&&F>=0&&I+F<=int32_t(sizeof(T)*8));
+    if(std::isnan(n)) return 0;
+    const float scale=float(1u<<F);
     if constexpr (std::is_signed_v<T>) {
-      n = std::max(n, -float(1u << (I + F - 1u)));
-      n = std::min(n,  float(1u << (I + F - 1u)) - 1.0f);
-      n += n < 0.0f ? -0.5f : 0.5f;
+      const float hi=float((1ull<<(I+F-1))-1), lo=-float(1ull<<(I+F-1));
+      n = dxvk::clamp(n*scale, lo, hi);
+      n += n<0 ? -0.5f : 0.5f;
     } else {
-      n = std::max(n, 0.0f);
-      n = std::min(n, float(1u << (I + F)) - 1.0f);
-      n += 0.5f;
+      const float hi=float((1ull<<(I+F))-1);
+      n = dxvk::clamp(n*scale, 0.f, hi)+0.5f;
     }
-
-    T result = T(n);
-
-    if constexpr (std::is_signed_v<T>)
-      result &= ((T(1u) << (I + F)) - 1u);
-
-    return result;
-  }
-
-
-  /**
-   * \brief Decodes fixed-point integer to float
-   *
-   * \tparam T Integer type, may be signed
-   * \tparam I Integer bits
-   * \tparam F Fractional bits
-   * \param n Number to decode
-   * \returns Decoded  number
-   */
-  template<typename T, int32_t I, int32_t F>
-  float decodeFixed(T n) {
-    // Sign-extend as necessary
-    if constexpr (std::is_signed_v<T>)
-      n -= (n & (T(1u) << (I + F - 1u))) << 1u;
-
-    return float(n) / float(1u << F);
-  }
-
-
-  /**
-   * \brief Inserts one null bit after each bit
-   */
-  inline uint32_t split2(uint32_t c) {
-    c = (c ^ (c << 8u)) & 0x00ff00ffu;
-    c = (c ^ (c << 4u)) & 0x0f0f0f0fu;
-    c = (c ^ (c << 2u)) & 0x33333333u;
-    c = (c ^ (c << 1u)) & 0x55555555u;
-    return c;
-  }
-
-
-  /**
-   * \brief Inserts two null bits after each bit
-   */
-  inline uint64_t split3(uint64_t c) {
-    c = (c | c << 32u) & 0x001f00000000ffffull;
-    c = (c | c << 16u) & 0x001f0000ff0000ffull;
-    c = (c | c <<  8u) & 0x100f00f00f00f00full;
-    c = (c | c <<  4u) & 0x10c30c30c30c30c3ull;
-    c = (c | c <<  2u) & 0x1249249249249249ull;
-    return c;
+    return static_cast<T>(n);
   }
 
-
-  /**
-   * \brief Interleaves bits from two integers
-   *
-   * Both numbers must fit into 16 bits.
-   * \param [in] x X coordinate
-   * \param [in] y Y coordinate
-   * \returns Morton code of x and y
-   */
-  inline uint32_t interleave(uint16_t x, uint16_t y) {
-    return split2(x) | (split2(y) << 1u);
+  template<typename T,int32_t I,int32_t F>
+  DXVK_FORCE_INLINE float decodeFixed(T v){
+    if constexpr(std::is_signed_v<T>)
+      v = static_cast<T>(v<<(sizeof(T)*8-I-F))>>(sizeof(T)*8-I-F);
+    return float(v)/float(1u<<F);
+  }
+
+  /*============================================================================
+   * 12. Morton helpers
+   *==========================================================================*/
+  DXVK_FORCE_INLINE uint32_t split2(uint32_t x){
+    x=(x|(x<<8)) &0x00FF00FFu;
+    x=(x|(x<<4)) &0x0F0F0F0Fu;
+    x=(x|(x<<2)) &0x33333333u;
+    x=(x|(x<<1)) &0x55555555u;
+    return x;
+  }
+  DXVK_FORCE_INLINE uint64_t split3(uint64_t x){
+    x=(x|(x<<32))&0x001F00000000FFFFull;
+    x=(x|(x<<16))&0x001F0000FF0000FFull;
+    x=(x|(x<< 8))&0x100F00F00F00F00Full;
+    x=(x|(x<< 4))&0x10C30C30C30C30C3ull;
+    x=(x|(x<< 2))&0x1249249249249249ull;
+    return x;
+  }
+
+  DXVK_FORCE_INLINE uint32_t interleave(uint16_t x,uint16_t y){
+    #if defined(__BMI2__) && defined(DXVK_ARCH_X86)
+    return _pdep_u32(x,0x55555555u)|_pdep_u32(y,0xAAAAAAAAu);
+    #else
+    return split2(x)|(split2(y)<<1u);
+    #endif
   }
-
-
-  /**
-   * \brief Interleaves bits from three integers
-   *
-   * All three numbers must fit into 16 bits.
-   */
-  inline uint64_t interleave(uint16_t x, uint16_t y, uint16_t z) {
-    return split3(x) | (split3(y) << 1u) | (split3(z) << 2u);
+  DXVK_FORCE_INLINE uint64_t interleave(uint16_t x,uint16_t y,uint16_t z){
+    #if defined(__BMI2__) && defined(DXVK_ARCH_X86_64)
+    return _pdep_u64(x,0x1249249249249249ull)
+    | _pdep_u64(y,0x2492492492492492ull)
+    | _pdep_u64(z,0x4924924924924924ull);
+    #else
+    return split3(x)|(split3(y)<<1u)|(split3(z)<<2u);
+    #endif
   }
 
-
-  /**
-   * \brief 48-bit integer storage type
-   */
-  struct uint48_t {
-    explicit uint48_t(uint64_t n)
-    : a(uint16_t(n)), b(uint16_t(n >> 16)), c(uint16_t(n >> 32)) { }
-
-    uint16_t a;
-    uint16_t b;
-    uint16_t c;
-
-    explicit operator uint64_t () const {
-      // GCC generates worse code if we promote to uint64 directly
-      uint32_t lo = uint32_t(a) | (uint32_t(b) << 16);
-      return uint64_t(lo) | (uint64_t(c) << 32);
+  /*============================================================================
+   * 13. uint48_t helper
+   *==========================================================================*/
+  struct uint48_t{
+    uint16_t a,b,c;
+    explicit uint48_t(uint64_t v):a(v),b(v>>16),c(v>>32){}
+    explicit operator uint64_t()const{
+      uint32_t lo=uint32_t(a)|(uint32_t(b)<<16);
+      return uint64_t(lo)|(uint64_t(c)<<32);
     }
   };
 
-}
+} /* namespace dxvk::bit */
