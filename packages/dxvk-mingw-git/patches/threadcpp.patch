--- thread.cpp.orig	2025-07-05 23:59:55.224477951 +0200
+++ thread.cpp	2025-07-06 14:02:49.208942173 +0200
@@ -9,12 +9,21 @@ namespace dxvk {
 
   thread::thread(ThreadProc&& proc)
   : m_data(new ThreadData(std::move(proc))) {
+    // Check if we're in DLL detachment
+    if (this_thread::isInModuleDetachment()) {
+      delete m_data;
+      m_data = nullptr;
+      throw std::system_error(std::make_error_code(std::errc::operation_canceled),
+                              "Cannot create thread during module detachment");
+    }
+
     m_data->handle = ::CreateThread(nullptr, 0x100000,
-      thread::threadProc, m_data, STACK_SIZE_PARAM_IS_A_RESERVATION,
-      &m_data->id);
+                                    thread::threadProc, m_data, STACK_SIZE_PARAM_IS_A_RESERVATION,
+                                    &m_data->id);
 
     if (!m_data->handle) {
       delete m_data;
+      m_data = nullptr;
       throw std::system_error(std::make_error_code(std::errc::resource_unavailable_try_again), "Failed to create thread");
     }
   }
@@ -49,11 +58,20 @@ namespace dxvk {
     }
 
     if (m_data)
-      ::SetThreadPriority(m_data->handle, int32_t(value));
+      ::SetThreadPriority(m_data->handle, value);
   }
 
 
   uint32_t thread::hardware_concurrency() {
+    // Try Windows 7+ API for processor groups
+    using GetActiveProcessorCount_t = DWORD (WINAPI *)(WORD);
+    static auto pGetActiveProcessorCount = reinterpret_cast<GetActiveProcessorCount_t>(
+      ::GetProcAddress(::GetModuleHandleW(L"kernel32.dll"), "GetActiveProcessorCount"));
+
+    if (pGetActiveProcessorCount)
+      return pGetActiveProcessorCount(ALL_PROCESSOR_GROUPS);
+
+    // Fallback to legacy API
     SYSTEM_INFO info = { };
     ::GetSystemInfo(&info);
     return info.dwNumberOfProcessors;
@@ -85,7 +103,7 @@ namespace dxvk::this_thread {
     static auto RtlDllShutdownInProgress = reinterpret_cast<PFN_RtlDllShutdownInProgress>(
       ::GetProcAddress(::GetModuleHandleW(L"ntdll.dll"), "RtlDllShutdownInProgress"));
 
-    return RtlDllShutdownInProgress();
+    return RtlDllShutdownInProgress && RtlDllShutdownInProgress();
   }
 
 }
@@ -93,19 +111,20 @@ namespace dxvk::this_thread {
 #else
 
 namespace dxvk::this_thread {
-  
+
   static std::atomic<uint32_t> g_threadCtr = { 0u };
   static thread_local uint32_t g_threadId  = 0u;
-  
+
   // This implementation returns thread ids unique to the current instance.
   // ie. if you use this across multiple .so's then you might get conflicting ids.
   //
   // This isn't an issue for us, as it is only used by the spinlock implementation,
   // but may be for you if you use this elsewhere.
   uint32_t get_id() {
-    if (unlikely(!g_threadId))
-      g_threadId = ++g_threadCtr;
+    if (likely(g_threadId != 0))
+      return g_threadId;
 
+    g_threadId = ++g_threadCtr;
     return g_threadId;
   }
 
