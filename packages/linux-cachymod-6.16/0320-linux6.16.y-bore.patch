From e55f24228db13a63b39da2b6ce7ef40b29137767 Mon Sep 17 00:00:00 2001
From: Masahito S <firelzrd@gmail.com>
Date: Sun, 13 Jul 2025 02:21:27 +0900
Subject: [PATCH] linux6.15.6-bore-6.0.0

---
 include/linux/sched.h      |  19 ++
 include/linux/sched/bore.h |  42 ++++
 init/Kconfig               |  17 ++
 kernel/Kconfig.hz          |  17 ++
 kernel/fork.c              |   8 +
 kernel/sched/Makefile      |   1 +
 kernel/sched/bore.c        | 449 +++++++++++++++++++++++++++++++++++++
 kernel/sched/core.c        |   8 +
 kernel/sched/debug.c       |  61 ++++-
 kernel/sched/fair.c        |  88 +++++++-
 kernel/sched/sched.h       |   9 +
 11 files changed, 715 insertions(+), 4 deletions(-)
 create mode 100644 include/linux/sched/bore.h
 create mode 100644 kernel/sched/bore.c

diff --git a/include/linux/sched.h b/include/linux/sched.h
index f96ac19828..85c59cc4e6 100644
--- a/include/linux/sched.h
+++ b/include/linux/sched.h
@@ -566,6 +566,15 @@ struct sched_statistics {
 #endif /* CONFIG_SCHEDSTATS */
 } ____cacheline_aligned;
 
+#ifdef CONFIG_SCHED_BORE
+struct sched_burst_cache {
+	u32				value;
+	u32				count;
+	u64				timestamp;
+    spinlock_t		lock;
+};
+#endif // CONFIG_SCHED_BORE
+
 struct sched_entity {
 	/* For load-balancing: */
 	struct load_weight		load;
@@ -585,6 +594,16 @@ struct sched_entity {
 	u64				sum_exec_runtime;
 	u64				prev_sum_exec_runtime;
 	u64				vruntime;
+#ifdef CONFIG_SCHED_BORE
+	u64				burst_time;
+	u32				prev_burst_penalty;
+	u32				curr_burst_penalty;
+	u32				burst_penalty;
+	u8				burst_score;
+	u8				burst_count;
+	struct sched_burst_cache child_burst;
+	struct sched_burst_cache group_burst;
+#endif // CONFIG_SCHED_BORE
 	s64				vlag;
 	u64				slice;
 
diff --git a/include/linux/sched/bore.h b/include/linux/sched/bore.h
new file mode 100644
index 0000000000..4aae7bc234
--- /dev/null
+++ b/include/linux/sched/bore.h
@@ -0,0 +1,42 @@
+
+#include <linux/sched.h>
+#include <linux/sched/cputime.h>
+
+#ifndef _LINUX_SCHED_BORE_H
+#define _LINUX_SCHED_BORE_H
+#define SCHED_BORE_AUTHOR   "Masahito Suzuki"
+#define SCHED_BORE_PROGNAME "BORE CPU Scheduler modification"
+
+#define SCHED_BORE_VERSION  "6.0.0"
+
+#ifdef CONFIG_SCHED_BORE
+extern u8   __read_mostly sched_bore;
+extern u8   __read_mostly sched_burst_exclude_kthreads;
+extern u8   __read_mostly sched_burst_smoothness;
+extern u8   __read_mostly sched_burst_fork_atavistic;
+extern u8   __read_mostly sched_burst_parity_threshold;
+extern u8   __read_mostly sched_burst_penalty_offset;
+extern uint __read_mostly sched_burst_penalty_scale;
+extern uint __read_mostly sched_burst_cache_stop_count;
+extern uint __read_mostly sched_burst_cache_lifetime;
+extern uint __read_mostly sched_deadline_boost_mask;
+
+extern void update_burst_score(struct sched_entity *se);
+extern void update_curr_bore(u64 delta_exec, struct sched_entity *se);
+
+extern void restart_burst(struct sched_entity *se);
+extern void restart_burst_rescale_deadline(struct sched_entity *se);
+
+extern int sched_bore_update_handler(const struct ctl_table *table, int write,
+	void __user *buffer, size_t *lenp, loff_t *ppos);
+
+extern void sched_clone_bore(
+	struct task_struct *p, struct task_struct *parent, u64 clone_flags, u64 now);
+
+extern void reset_task_bore(struct task_struct *p);
+extern void sched_bore_init(void);
+
+extern void reweight_entity(struct cfs_rq *cfs_rq,
+	struct sched_entity *se, unsigned long weight, bool no_update_curr);
+#endif // CONFIG_SCHED_BORE
+#endif // _LINUX_SCHED_BORE_H
diff --git a/init/Kconfig b/init/Kconfig
index bf3a920064..5efa0ec37e 100644
--- a/init/Kconfig
+++ b/init/Kconfig
@@ -1362,6 +1362,23 @@ config CHECKPOINT_RESTORE
 
 	  If unsure, say N here.
 
+config SCHED_BORE
+	bool "Burst-Oriented Response Enhancer"
+	default y
+	help
+	  In Desktop and Mobile computing, one might prefer interactive
+	  tasks to keep responsive no matter what they run in the background.
+
+	  Enabling this kernel feature modifies the scheduler to discriminate
+	  tasks by their burst time (runtime since it last went sleeping or
+	  yielding state) and prioritize those that run less bursty.
+	  Such tasks usually include window compositor, widgets backend,
+	  terminal emulator, video playback, games and so on.
+	  With a little impact to scheduling fairness, it may improve
+	  responsiveness especially under heavy background workload.
+
+	  If unsure, say Y here.
+
 config SCHED_AUTOGROUP
 	bool "Automatic process group scheduling"
 	select CGROUPS
diff --git a/kernel/Kconfig.hz b/kernel/Kconfig.hz
index ce1435cb08..b93d1f657a 100644
--- a/kernel/Kconfig.hz
+++ b/kernel/Kconfig.hz
@@ -55,5 +55,22 @@ config HZ
 	default 300 if HZ_300
 	default 1000 if HZ_1000
 
+config MIN_BASE_SLICE_NS
+	int "Default value for min_base_slice_ns"
+	default 2000000
+	help
+	 The BORE Scheduler automatically calculates the optimal base
+	 slice for the configured HZ using the following equation:
+	 
+	 base_slice_ns =
+	 	1000000000/HZ * DIV_ROUNDUP(min_base_slice_ns, 1000000000/HZ)
+	 
+	 This option sets the default lower bound limit of the base slice
+	 to prevent the loss of task throughput due to overscheduling.
+	 
+	 Setting this value too high can cause the system to boot with
+	 an unnecessarily large base slice, resulting in high scheduling
+	 latency and poor system responsiveness.
+
 config SCHED_HRTICK
 	def_bool HIGH_RES_TIMERS
diff --git a/kernel/fork.c b/kernel/fork.c
index 168681fc4b..0c8637037d 100644
--- a/kernel/fork.c
+++ b/kernel/fork.c
@@ -112,6 +112,10 @@
 #include <asm/cacheflush.h>
 #include <asm/tlbflush.h>
 
+#ifdef CONFIG_SCHED_BORE
+#include <linux/sched/bore.h>
+#endif // CONFIG_SCHED_BORE
+
 #include <trace/events/sched.h>
 
 #define CREATE_TRACE_POINTS
@@ -2554,6 +2558,10 @@ __latent_entropy struct task_struct *copy_process(
 	p->start_time = ktime_get_ns();
 	p->start_boottime = ktime_get_boottime_ns();
 
+#ifdef CONFIG_SCHED_BORE
+	if (likely(p->pid))
+		sched_clone_bore(p, current, clone_flags, p->start_time);
+#endif // CONFIG_SCHED_BORE
 	/*
 	 * Make it visible to the rest of the system, but dont wake it up yet.
 	 * Need tasklist lock for parent etc handling!
diff --git a/kernel/sched/Makefile b/kernel/sched/Makefile
index 8ae86371dd..b688084bce 100644
--- a/kernel/sched/Makefile
+++ b/kernel/sched/Makefile
@@ -37,3 +37,4 @@ obj-y += core.o
 obj-y += fair.o
 obj-y += build_policy.o
 obj-y += build_utility.o
+obj-$(CONFIG_SCHED_BORE) += bore.o
diff --git a/kernel/sched/bore.c b/kernel/sched/bore.c
new file mode 100644
index 0000000000..c4aca44f3b
--- /dev/null
+++ b/kernel/sched/bore.c
@@ -0,0 +1,449 @@
+/*
+ *  Burst-Oriented Response Enhancer (BORE) CPU Scheduler
+ *  Copyright (C) 2021-2025 Masahito Suzuki <firelzrd@gmail.com>
+ */
+#include <linux/cpuset.h>
+#include <linux/sched/task.h>
+#include <linux/sched/bore.h>
+#include "sched.h"
+
+#ifdef CONFIG_SCHED_BORE
+u8   __read_mostly sched_bore                   = 1;
+u8   __read_mostly sched_burst_exclude_kthreads = 1;
+u8   __read_mostly sched_burst_smoothness       = 20;
+u8   __read_mostly sched_burst_fork_atavistic   = 2;
+u8   __read_mostly sched_burst_parity_threshold = 2;
+u8   __read_mostly sched_burst_penalty_offset   = 24;
+uint __read_mostly sched_burst_penalty_scale    = 3180;
+uint __read_mostly sched_burst_cache_stop_count = 64;
+uint __read_mostly sched_burst_cache_lifetime   = 75000000;
+uint __read_mostly sched_deadline_boost_mask    = ENQUEUE_INITIAL
+                                                | ENQUEUE_WAKEUP;
+static int __maybe_unused maxval_6_bits  =   63;
+static int __maybe_unused maxval_8_bits  =  255;
+static int __maybe_unused maxval_12_bits = 4095;
+
+#define BURST_PENALTY_SHIFT 12
+#define MAX_BURST_PENALTY (39U << BURST_PENALTY_SHIFT)
+
+static u32 log2p1_u64_u32fp(u64 v, u8 fp) {
+	if (!v) return 0;
+	u32 exponent = fls64(v);
+	u32 mantissa = (u32)(v << (64 - exponent) << 1 >> (64 - fp));
+	return exponent << fp | mantissa;
+}
+
+static inline u32 calc_burst_penalty(u64 burst_time) {
+	u32 greed, tolerance, penalty, scaled_penalty;
+	
+	greed = log2p1_u64_u32fp(burst_time, BURST_PENALTY_SHIFT);
+	tolerance = sched_burst_penalty_offset << BURST_PENALTY_SHIFT;
+	penalty = max(0, (s32)(greed - tolerance));
+	scaled_penalty = penalty * sched_burst_penalty_scale >> 10;
+
+	return min(MAX_BURST_PENALTY, scaled_penalty);
+}
+
+static inline u64 __scale_slice(u64 delta, u8 score)
+{return mul_u64_u32_shr(delta, sched_prio_to_wmult[score], 22);}
+
+static inline u64 __unscale_slice(u64 delta, u8 score)
+{return mul_u64_u32_shr(delta, sched_prio_to_weight[score], 10);}
+
+static void reweight_task_by_prio(struct task_struct *p, int prio) {
+	struct sched_entity *se = &p->se;
+	unsigned long weight = scale_load(sched_prio_to_weight[prio]);
+
+	reweight_entity(cfs_rq_of(se), se, weight, true);
+	se->load.inv_weight = sched_prio_to_wmult[prio];
+}
+
+static inline u8 effective_prio(struct task_struct *p) {
+	u8 prio = p->static_prio - MAX_RT_PRIO;
+	if (likely(sched_bore))
+		prio += p->se.burst_score;
+	return min(39, prio);
+}
+
+void update_burst_score(struct sched_entity *se) {
+	if (!entity_is_task(se)) return;
+	struct task_struct *p = task_of(se);
+	u8 prev_prio = effective_prio(p);
+
+	u8 burst_score = 0;
+	if (!((p->flags & PF_KTHREAD) && likely(sched_burst_exclude_kthreads)))
+		burst_score = se->burst_penalty >> BURST_PENALTY_SHIFT;
+	se->burst_score = burst_score;
+
+	u8 new_prio = effective_prio(p);
+	if (new_prio != prev_prio)
+		reweight_task_by_prio(p, new_prio);
+}
+
+void update_curr_bore(u64 delta_exec, struct sched_entity *se) {
+	if (!entity_is_task(se)) return;
+
+	se->burst_time += delta_exec;
+	se->curr_burst_penalty = calc_burst_penalty(se->burst_time);
+	if (se->curr_burst_penalty > se->prev_burst_penalty)
+		se->burst_penalty = se->prev_burst_penalty +
+		(se->curr_burst_penalty - se->prev_burst_penalty) / se->burst_count;
+	update_burst_score(se);
+}
+
+static inline u32 binary_smooth(u32 new, u32 old, u8 dumper) {
+	s32 increment = new - old;
+	return (0 <= increment)?
+		old + ( increment / dumper):
+		old - (-increment / dumper);
+}
+
+static void __restart_burst(struct sched_entity *se) {
+	se->prev_burst_penalty = binary_smooth(
+		se->curr_burst_penalty, se->prev_burst_penalty, se->burst_count);
+	se->burst_time = 0;
+	se->curr_burst_penalty = 0;
+
+	u8 smoothness = sched_burst_smoothness;
+	if (se->burst_count < smoothness)
+		se->burst_count++;
+	else if (unlikely(se->burst_count > smoothness))
+		se->burst_count = smoothness;
+}
+
+inline void restart_burst(struct sched_entity *se) {
+	__restart_burst(se);
+	se->burst_penalty = se->prev_burst_penalty;
+	update_burst_score(se);
+}
+
+void restart_burst_rescale_deadline(struct sched_entity *se) {
+	s64 vscaled, wremain, vremain = se->deadline - se->vruntime;
+	struct task_struct *p = task_of(se);
+	u8 prev_prio = effective_prio(p);
+	restart_burst(se);
+	u8 new_prio = effective_prio(p);
+	if (prev_prio > new_prio) {
+		wremain = __unscale_slice(abs(vremain), prev_prio);
+		vscaled = __scale_slice(wremain, new_prio);
+		if (unlikely(vremain < 0))
+			vscaled = -vscaled;
+		se->deadline = se->vruntime + vscaled;
+	}
+}
+
+static inline bool task_is_bore_eligible(struct task_struct *p)
+{return p && p->sched_class == &fair_sched_class && !p->exit_state;}
+
+static inline void reset_task_weights_bore(void) {
+	struct task_struct *task;
+	struct rq *rq;
+	struct rq_flags rf;
+
+	write_lock_irq(&tasklist_lock);
+	for_each_process(task) {
+		if (!task_is_bore_eligible(task)) continue;
+		rq = task_rq(task);
+		rq_pin_lock(rq, &rf);
+		update_rq_clock(rq);
+		reweight_task_by_prio(task, effective_prio(task));
+		rq_unpin_lock(rq, &rf);
+	}
+	write_unlock_irq(&tasklist_lock);
+}
+
+int sched_bore_update_handler(const struct ctl_table *table, int write,
+	void __user *buffer, size_t *lenp, loff_t *ppos) {
+	int ret = proc_dou8vec_minmax(table, write, buffer, lenp, ppos);
+	if (ret || !write)
+		return ret;
+
+	reset_task_weights_bore();
+
+	return 0;
+}
+
+#define for_each_child(p, t) \
+	list_for_each_entry(t, &(p)->children, sibling)
+
+static inline u32 count_entries_upto2(struct list_head *head) {
+	struct list_head *next = head->next;
+	return (next != head) + (next->next != head);
+}
+
+static inline void init_task_burst_cache_lock(struct task_struct *p) {
+	spin_lock_init(&p->se.child_burst.lock);
+	spin_lock_init(&p->se.group_burst.lock);
+}
+
+static inline bool burst_cache_expired(struct sched_burst_cache *bc, u64 now)
+{return (s64)(bc->timestamp + sched_burst_cache_lifetime - now) < 0;}
+
+static void update_burst_cache(struct sched_burst_cache *bc,
+	struct task_struct *p, u32 cnt, u32 sum, u64 now) {
+	u32 avg = cnt ? sum / cnt : 0;
+	bc->value = max(avg, p->se.burst_penalty);
+	bc->count = cnt;
+	bc->timestamp = now;
+}
+
+static inline void update_child_burst_direct(struct task_struct *p, u64 now) {
+	u32 cnt = 0, sum = 0;
+	struct task_struct *child;
+
+	for_each_child(p, child) {
+		if (!task_is_bore_eligible(child)) continue;
+		cnt++;
+		sum += child->se.burst_penalty;
+	}
+
+	update_burst_cache(&p->se.child_burst, p, cnt, sum, now);
+}
+
+static inline u32 inherit_burst_direct(
+	struct task_struct *p, u64 now, u64 clone_flags) {
+	struct task_struct *parent = p;
+	struct sched_burst_cache *bc;
+
+	if (clone_flags & CLONE_PARENT)
+		parent = parent->real_parent;
+
+	bc = &parent->se.child_burst;
+	guard(spinlock)(&bc->lock);
+	if (burst_cache_expired(bc, now))
+		update_child_burst_direct(parent, now);
+
+	return bc->value;
+}
+
+static void update_child_burst_topological(
+	struct task_struct *p, u64 now, u32 depth, u32 *acnt, u32 *asum) {
+	u32 cnt = 0, dcnt = 0, sum = 0;
+	struct task_struct *child, *dec;
+	struct sched_burst_cache *bc __maybe_unused;
+
+	for_each_child(p, child) {
+		dec = child;
+		while ((dcnt = count_entries_upto2(&dec->children)) == 1)
+			dec = list_first_entry(&dec->children, struct task_struct, sibling);
+		
+		if (!dcnt || !depth) {
+			if (!task_is_bore_eligible(dec)) continue;
+			cnt++;
+			sum += dec->se.burst_penalty;
+			continue;
+		}
+		bc = &dec->se.child_burst;
+		spin_lock(&bc->lock);
+		if (!burst_cache_expired(bc, now)) {
+			cnt += bc->count;
+			sum += bc->value * bc->count;
+			if (sched_burst_cache_stop_count <= cnt) {
+				spin_unlock(&bc->lock);
+				break;
+			}
+			spin_unlock(&bc->lock);
+			continue;
+		}
+		update_child_burst_topological(dec, now, depth - 1, &cnt, &sum);
+		spin_unlock(&bc->lock);
+	}
+
+	update_burst_cache(&p->se.child_burst, p, cnt, sum, now);
+	*acnt += cnt;
+	*asum += sum;
+}
+
+static inline u32 inherit_burst_topological(
+	struct task_struct *p, u64 now, u64 clone_flags) {
+	struct task_struct *anc = p;
+	struct sched_burst_cache *bc;
+	u32 cnt = 0, sum = 0;
+	u32 base_child_cnt = 0;
+
+	if (clone_flags & CLONE_PARENT) {
+		anc = anc->real_parent;
+		base_child_cnt = 1;
+	}
+
+	for (struct task_struct *next;
+		 anc != (next = anc->real_parent) &&
+		 	count_entries_upto2(&anc->children) <= base_child_cnt;) {
+		anc = next;
+		base_child_cnt = 1;
+	}
+
+	bc = &anc->se.child_burst;
+	guard(spinlock)(&bc->lock);
+	if (burst_cache_expired(bc, now))
+		update_child_burst_topological(
+			anc, now, sched_burst_fork_atavistic - 1, &cnt, &sum);
+
+	return bc->value;
+}
+
+static inline void update_tg_burst(struct task_struct *p, u64 now) {
+	struct task_struct *task;
+	u32 cnt = 0, sum = 0;
+
+	for_each_thread(p, task) {
+		if (!task_is_bore_eligible(task)) continue;
+		cnt++;
+		sum += task->se.burst_penalty;
+	}
+
+	update_burst_cache(&p->se.group_burst, p, cnt, sum, now);
+}
+
+static inline u32 inherit_burst_tg(struct task_struct *p, u64 now) {
+	struct task_struct *parent = rcu_dereference(p->group_leader);
+	struct sched_burst_cache *bc = &parent->se.group_burst;
+	guard(spinlock)(&bc->lock);
+	if (burst_cache_expired(bc, now))
+		update_tg_burst(parent, now);
+
+	return bc->value;
+}
+
+void sched_clone_bore(struct task_struct *p,
+	struct task_struct *parent, u64 clone_flags, u64 now) {
+	struct sched_entity *se = &p->se;
+	u32 penalty;
+
+	init_task_burst_cache_lock(p);
+
+	if (!task_is_bore_eligible(p)) return;
+
+	if (clone_flags & CLONE_THREAD) {
+		rcu_read_lock();
+		penalty = inherit_burst_tg(parent, now);
+		rcu_read_unlock();
+	} else {
+		read_lock(&tasklist_lock);
+		penalty = likely(sched_burst_fork_atavistic) ?
+			inherit_burst_topological(parent, now, clone_flags):
+			inherit_burst_direct(parent, now, clone_flags);
+		read_unlock(&tasklist_lock);
+	}
+
+	__restart_burst(se);
+	se->burst_penalty = se->prev_burst_penalty =
+		max(se->prev_burst_penalty, penalty);
+	se->burst_count = 1;
+	se->child_burst.timestamp = 0;
+	se->group_burst.timestamp = 0;
+}
+
+void reset_task_bore(struct task_struct *p) {
+	p->se.burst_time = 0;
+	p->se.prev_burst_penalty = 0;
+	p->se.curr_burst_penalty = 0;
+	p->se.burst_penalty = 0;
+	p->se.burst_score = 0;
+	p->se.burst_count = 1;
+	memset(&p->se.child_burst, 0, sizeof(struct sched_burst_cache));
+	memset(&p->se.group_burst, 0, sizeof(struct sched_burst_cache));
+}
+
+void __init sched_bore_init(void) {
+	printk(KERN_INFO "%s %s by %s\n",
+		SCHED_BORE_PROGNAME, SCHED_BORE_VERSION, SCHED_BORE_AUTHOR);
+	reset_task_bore(&init_task);
+	init_task_burst_cache_lock(&init_task);
+}
+
+#ifdef CONFIG_SYSCTL
+static struct ctl_table sched_bore_sysctls[] = {
+	{
+		.procname	= "sched_bore",
+		.data		= &sched_bore,
+		.maxlen		= sizeof(u8),
+		.mode		= 0644,
+		.proc_handler = sched_bore_update_handler,
+		.extra1		= SYSCTL_ZERO,
+		.extra2		= SYSCTL_ONE,
+	},
+	{
+		.procname	= "sched_burst_exclude_kthreads",
+		.data		= &sched_burst_exclude_kthreads,
+		.maxlen		= sizeof(u8),
+		.mode		= 0644,
+		.proc_handler = proc_dou8vec_minmax,
+		.extra1		= SYSCTL_ZERO,
+		.extra2		= SYSCTL_ONE,
+	},
+	{
+		.procname	= "sched_burst_smoothness",
+		.data		= &sched_burst_smoothness,
+		.maxlen		= sizeof(u8),
+		.mode		= 0644,
+		.proc_handler = proc_dou8vec_minmax,
+		.extra1		= SYSCTL_ONE,
+		.extra2		= &maxval_8_bits,
+	},
+	{
+		.procname	= "sched_burst_fork_atavistic",
+		.data		= &sched_burst_fork_atavistic,
+		.maxlen		= sizeof(u8),
+		.mode		= 0644,
+		.proc_handler = proc_dou8vec_minmax,
+		.extra1		= SYSCTL_ZERO,
+		.extra2		= SYSCTL_THREE,
+	},
+	{
+		.procname	= "sched_burst_parity_threshold",
+		.data		= &sched_burst_parity_threshold,
+		.maxlen		= sizeof(u8),
+		.mode		= 0644,
+		.proc_handler = proc_dou8vec_minmax,
+		.extra1		= SYSCTL_ZERO,
+		.extra2		= &maxval_8_bits,
+	},
+	{
+		.procname	= "sched_burst_penalty_offset",
+		.data		= &sched_burst_penalty_offset,
+		.maxlen		= sizeof(u8),
+		.mode		= 0644,
+		.proc_handler = proc_dou8vec_minmax,
+		.extra1		= SYSCTL_ZERO,
+		.extra2		= &maxval_6_bits,
+	},
+	{
+		.procname	= "sched_burst_penalty_scale",
+		.data		= &sched_burst_penalty_scale,
+		.maxlen		= sizeof(uint),
+		.mode		= 0644,
+		.proc_handler = proc_douintvec_minmax,
+		.extra1		= SYSCTL_ZERO,
+		.extra2		= &maxval_12_bits,
+	},
+	{
+		.procname	= "sched_burst_cache_stop_count",
+		.data		= &sched_burst_cache_stop_count,
+		.maxlen		= sizeof(uint),
+		.mode		= 0644,
+		.proc_handler = proc_douintvec,
+	},
+	{
+		.procname	= "sched_burst_cache_lifetime",
+		.data		= &sched_burst_cache_lifetime,
+		.maxlen		= sizeof(uint),
+		.mode		= 0644,
+		.proc_handler = proc_douintvec,
+	},
+	{
+		.procname	= "sched_deadline_boost_mask",
+		.data		= &sched_deadline_boost_mask,
+		.maxlen		= sizeof(uint),
+		.mode		= 0644,
+		.proc_handler = proc_douintvec,
+	},
+};
+
+static int __init sched_bore_sysctl_init(void) {
+	register_sysctl_init("kernel", sched_bore_sysctls);
+	return 0;
+}
+late_initcall(sched_bore_sysctl_init);
+#endif // CONFIG_SYSCTL
+#endif // CONFIG_SCHED_BORE
diff --git a/kernel/sched/core.c b/kernel/sched/core.c
index 39fac649aa..71d817ce8b 100644
--- a/kernel/sched/core.c
+++ b/kernel/sched/core.c
@@ -96,6 +96,10 @@
 #include "../../io_uring/io-wq.h"
 #include "../smpboot.h"
 
+#ifdef CONFIG_SCHED_BORE
+#include <linux/sched/bore.h>
+#endif // CONFIG_SCHED_BORE
+
 EXPORT_TRACEPOINT_SYMBOL_GPL(ipi_send_cpu);
 EXPORT_TRACEPOINT_SYMBOL_GPL(ipi_send_cpumask);
 
@@ -8549,6 +8553,10 @@ void __init sched_init(void)
 	BUG_ON(!sched_class_above(&ext_sched_class, &idle_sched_class));
 #endif
 
+#ifdef CONFIG_SCHED_BORE
+	sched_bore_init();
+#endif // CONFIG_SCHED_BORE
+
 	wait_bit_init();
 
 #ifdef CONFIG_FAIR_GROUP_SCHED
diff --git a/kernel/sched/debug.c b/kernel/sched/debug.c
index 56ae54e0ce..4302a4d60a 100644
--- a/kernel/sched/debug.c
+++ b/kernel/sched/debug.c
@@ -167,7 +167,53 @@ static const struct file_operations sched_feat_fops = {
 };
 
 #ifdef CONFIG_SMP
+#ifdef CONFIG_SCHED_BORE
+#define DEFINE_SYSCTL_SCHED_FUNC(name, update_func) \
+static ssize_t sched_##name##_write(struct file *filp, const char __user *ubuf, size_t cnt, loff_t *ppos) \
+{ \
+	char buf[16]; \
+	unsigned int value; \
+\
+	if (cnt > 15) \
+		cnt = 15; \
+\
+	if (copy_from_user(&buf, ubuf, cnt)) \
+		return -EFAULT; \
+	buf[cnt] = '\0'; \
+\
+	if (kstrtouint(buf, 10, &value)) \
+		return -EINVAL; \
+\
+	sysctl_sched_##name = value; \
+	sched_update_##update_func(); \
+\
+	*ppos += cnt; \
+	return cnt; \
+} \
+\
+static int sched_##name##_show(struct seq_file *m, void *v) \
+{ \
+	seq_printf(m, "%d\n", sysctl_sched_##name); \
+	return 0; \
+} \
+\
+static int sched_##name##_open(struct inode *inode, struct file *filp) \
+{ \
+	return single_open(filp, sched_##name##_show, NULL); \
+} \
+\
+static const struct file_operations sched_##name##_fops = { \
+	.open		= sched_##name##_open, \
+	.write		= sched_##name##_write, \
+	.read		= seq_read, \
+	.llseek		= seq_lseek, \
+	.release	= single_release, \
+};
+
+DEFINE_SYSCTL_SCHED_FUNC(min_base_slice, min_base_slice)
 
+#undef DEFINE_SYSCTL_SCHED_FUNC
+#else // !CONFIG_SCHED_BORE
 static ssize_t sched_scaling_write(struct file *filp, const char __user *ubuf,
 				   size_t cnt, loff_t *ppos)
 {
@@ -213,7 +259,7 @@ static const struct file_operations sched_scaling_fops = {
 	.llseek		= seq_lseek,
 	.release	= single_release,
 };
-
+#endif // CONFIG_SCHED_BORE
 #endif /* SMP */
 
 #ifdef CONFIG_PREEMPT_DYNAMIC
@@ -507,13 +553,20 @@ static __init int sched_init_debug(void)
 	debugfs_create_file("preempt", 0644, debugfs_sched, NULL, &sched_dynamic_fops);
 #endif
 
+#ifdef CONFIG_SCHED_BORE
+	debugfs_create_file("min_base_slice_ns", 0644, debugfs_sched, NULL, &sched_min_base_slice_fops);
+	debugfs_create_u32("base_slice_ns", 0444, debugfs_sched, &sysctl_sched_base_slice);
+#else // !CONFIG_SCHED_BORE
 	debugfs_create_u32("base_slice_ns", 0644, debugfs_sched, &sysctl_sched_base_slice);
+#endif // CONFIG_SCHED_BORE
 
 	debugfs_create_u32("latency_warn_ms", 0644, debugfs_sched, &sysctl_resched_latency_warn_ms);
 	debugfs_create_u32("latency_warn_once", 0644, debugfs_sched, &sysctl_resched_latency_warn_once);
 
 #ifdef CONFIG_SMP
+#if !defined(CONFIG_SCHED_BORE)
 	debugfs_create_file("tunable_scaling", 0644, debugfs_sched, NULL, &sched_scaling_fops);
+#endif // CONFIG_SCHED_BORE
 	debugfs_create_u32("migration_cost_ns", 0644, debugfs_sched, &sysctl_sched_migration_cost);
 	debugfs_create_u32("nr_migrate", 0644, debugfs_sched, &sysctl_sched_nr_migrate);
 
@@ -758,6 +811,9 @@ print_task(struct seq_file *m, struct rq *rq, struct task_struct *p)
 		SPLIT_NS(schedstat_val_or_zero(p->stats.sum_sleep_runtime)),
 		SPLIT_NS(schedstat_val_or_zero(p->stats.sum_block_runtime)));
 
+#ifdef CONFIG_SCHED_BORE
+	SEQ_printf(m, " %2d", p->se.burst_score);
+#endif // CONFIG_SCHED_BORE
 #ifdef CONFIG_NUMA_BALANCING
 	SEQ_printf(m, "   %d      %d", task_node(p), task_numa_group_id(p));
 #endif
@@ -1244,6 +1300,9 @@ void proc_sched_show_task(struct task_struct *p, struct pid_namespace *ns,
 
 	P(se.load.weight);
 #ifdef CONFIG_SMP
+#ifdef CONFIG_SCHED_BORE
+	P(se.burst_score);
+#endif // CONFIG_SCHED_BORE
 	P(se.avg.load_sum);
 	P(se.avg.runnable_sum);
 	P(se.avg.util_sum);
diff --git a/kernel/sched/fair.c b/kernel/sched/fair.c
index 138d9f4658..5f1d4dd44c 100644
--- a/kernel/sched/fair.c
+++ b/kernel/sched/fair.c
@@ -56,8 +56,23 @@
 
 #include "sched.h"
 #include "stats.h"
+#include <linux/latencytop.h>
+#include <linux/cpuidle.h>
+#include <linux/jiffies.h>
+#include <linux/math64.h>
+#include <linux/profile.h>
+#include <linux/psi.h>
+#include <linux/tick.h>
+#include <linux/mm_types.h>
+
+#include "sched.h"
+#include "stats.h"
 #include "autogroup.h"
 
+#ifdef CONFIG_SCHED_BORE
+#include <linux/sched/bore.h>
+#endif // CONFIG_SCHED_BORE
+
 /*
  * The initial- and re-scaling of tunables is configurable
  *
@@ -67,28 +82,32 @@
  *   SCHED_TUNABLESCALING_LOG - scaled logarithmically, *1+ilog(ncpus)
  *   SCHED_TUNABLESCALING_LINEAR - scaled linear, *ncpus
  *
- * (default SCHED_TUNABLESCALING_LOG = *(1+ilog(ncpus))
+ * BORE : default SCHED_TUNABLESCALING_NONE = *1 constant
+ * EEVDF: default SCHED_TUNABLESCALING_LOG  = *(1+ilog(ncpus))
  */
+#ifdef CONFIG_SCHED_BORE
+unsigned int sysctl_sched_tunable_scaling = SCHED_TUNABLESCALING_NONE;
+#else // !CONFIG_SCHED_BORE
 unsigned int sysctl_sched_tunable_scaling = SCHED_TUNABLESCALING_LOG;
+#endif // CONFIG_SCHED_BORE
 
 /*
  * Minimal preemption granularity for CPU-bound tasks:
  *
- * (default: 0.70 msec * (1 + ilog(ncpus)), units: nanoseconds)
+ * BORE : base_slice = minimum multiple of nsecs_per_tick >= min_base_slice
+ * (default min_base_slice = 2000000 constant, units: nanoseconds)
+ * EEVDF: default 0.70 msec * (1 + ilog(ncpus)), units: nanoseconds
  */
-#ifdef CONFIG_CACHY
-unsigned int sysctl_sched_base_slice			= 350000ULL;
-static unsigned int normalized_sysctl_sched_base_slice	= 350000ULL;
-#else
+#ifdef CONFIG_SCHED_BORE
+static const unsigned int nsecs_per_tick       = 1000000000ULL / HZ;
+unsigned int sysctl_sched_min_base_slice       = CONFIG_MIN_BASE_SLICE_NS;
+__read_mostly unsigned int sysctl_sched_base_slice     = nsecs_per_tick;
+#else // !CONFIG_SCHED_BORE
 unsigned int sysctl_sched_base_slice			= 700000ULL;
 static unsigned int normalized_sysctl_sched_base_slice	= 700000ULL;
-#endif /* CONFIG_CACHY */
+#endif // CONFIG_SCHED_BORE
 
-#ifdef CONFIG_CACHY
-__read_mostly unsigned int sysctl_sched_migration_cost	= 300000UL;
-#else
 __read_mostly unsigned int sysctl_sched_migration_cost	= 500000UL;
-#endif
 
 static int __init setup_sched_thermal_decay_shift(char *str)
 {
@@ -191,6 +208,13 @@ static inline void update_load_set(struct load_weight *lw, unsigned long w)
  *
  * This idea comes from the SD scheduler of Con Kolivas:
  */
+#ifdef CONFIG_SCHED_BORE
+static void update_sysctl(void) {
+	sysctl_sched_base_slice = nsecs_per_tick *
+		max(1UL, DIV_ROUND_UP(sysctl_sched_min_base_slice, nsecs_per_tick));
+}
+void sched_update_min_base_slice(void) { update_sysctl(); }
+#else // !CONFIG_SCHED_BORE
 static unsigned int get_update_sysctl_factor(void)
 {
 	unsigned int cpus = min_t(unsigned int, num_online_cpus(), 8);
@@ -221,6 +245,7 @@ static void update_sysctl(void)
 	SET_SYSCTL(sched_base_slice);
 #undef SET_SYSCTL
 }
+#endif // CONFIG_SCHED_BORE
 
 void __init sched_init_granularity(void)
 {
@@ -700,6 +725,9 @@ static void update_entity_lag(struct cfs_rq *cfs_rq, struct sched_entity *se)
 
 	vlag = avg_vruntime(cfs_rq) - se->vruntime;
 	limit = calc_delta_fair(max_t(u64, 2*se->slice, TICK_NSEC), se);
+#ifdef CONFIG_SCHED_BORE
+	limit >>= !!sched_bore;
+#endif // CONFIG_SCHED_BORE
 
 	se->vlag = clamp(vlag, -limit, limit);
 }
@@ -940,6 +968,10 @@ static struct sched_entity *pick_eevdf(struct cfs_rq *cfs_rq)
 		curr = NULL;
 
 	if (sched_feat(RUN_TO_PARITY) && curr && protect_slice(curr))
+#ifdef CONFIG_SCHED_BORE
+		if (!(likely(sched_bore) && likely(sched_burst_parity_threshold) &&
+			sched_burst_parity_threshold < cfs_rq->nr_queued))
+#endif // CONFIG_SCHED_BORE
 		return curr;
 
 	/* Pick the leftmost entity if it's eligible */
@@ -997,6 +1029,7 @@ struct sched_entity *__pick_last_entity(struct cfs_rq *cfs_rq)
  * Scheduling class statistics methods:
  */
 #ifdef CONFIG_SMP
+#if !defined(CONFIG_SCHED_BORE)
 int sched_update_scaling(void)
 {
 	unsigned int factor = get_update_sysctl_factor();
@@ -1008,6 +1041,7 @@ int sched_update_scaling(void)
 
 	return 0;
 }
+#endif // CONFIG_SCHED_BORE
 #endif
 
 static void clear_buddies(struct cfs_rq *cfs_rq, struct sched_entity *se);
@@ -1237,6 +1271,9 @@ static void update_curr(struct cfs_rq *cfs_rq)
 	if (unlikely(delta_exec <= 0))
 		return;
 
+#ifdef CONFIG_SCHED_BORE
+	update_curr_bore(delta_exec, curr);
+#endif // CONFIG_SCHED_BORE
 	curr->vruntime += calc_delta_fair(delta_exec, curr);
 	resched = update_deadline(cfs_rq, curr);
 	update_min_vruntime(cfs_rq);
@@ -3784,13 +3821,22 @@ dequeue_load_avg(struct cfs_rq *cfs_rq, struct sched_entity *se) { }
 
 static void place_entity(struct cfs_rq *cfs_rq, struct sched_entity *se, int flags);
 
+
+#ifdef CONFIG_SCHED_BORE
+void reweight_entity(struct cfs_rq *cfs_rq, struct sched_entity *se,
+			    unsigned long weight, bool no_update_curr)
+#else // !CONFIG_SCHED_BORE
 static void reweight_entity(struct cfs_rq *cfs_rq, struct sched_entity *se,
 			    unsigned long weight)
+#endif // CONFIG_SCHED_BORE
 {
 	bool curr = cfs_rq->curr == se;
 
 	if (se->on_rq) {
 		/* commit outstanding execution time */
+#ifdef CONFIG_SCHED_BORE
+		if (!no_update_curr)
+#endif // CONFIG_SCHED_BORE
 		update_curr(cfs_rq);
 		update_entity_lag(cfs_rq, se);
 		se->deadline -= se->vruntime;
@@ -3846,7 +3892,11 @@ static void reweight_task_fair(struct rq *rq, struct task_struct *p,
 	struct cfs_rq *cfs_rq = cfs_rq_of(se);
 	struct load_weight *load = &se->load;
 
+#ifdef CONFIG_SCHED_BORE
+	reweight_entity(cfs_rq, se, lw->weight, false);
+#else // !CONFIG_SCHED_BORE
 	reweight_entity(cfs_rq, se, lw->weight);
+#endif // CONFIG_SCHED_BORE
 	load->inv_weight = lw->inv_weight;
 }
 
@@ -3987,7 +4037,11 @@ static void update_cfs_group(struct sched_entity *se)
 	shares = calc_group_shares(gcfs_rq);
 #endif
 	if (unlikely(se->load.weight != shares))
+#ifdef CONFIG_SCHED_BORE
+		reweight_entity(cfs_rq_of(se), se, shares, false);
+#else // !CONFIG_SCHED_BORE
 		reweight_entity(cfs_rq_of(se), se, shares);
+#endif // CONFIG_SCHED_BORE
 }
 
 #else /* CONFIG_FAIR_GROUP_SCHED */
@@ -5292,7 +5346,11 @@ place_entity(struct cfs_rq *cfs_rq, struct sched_entity *se, int flags)
 		se->rel_deadline = 0;
 		return;
 	}
-
+#ifdef CONFIG_SCHED_BORE
+	else if (likely(sched_bore))
+		vslice >>= !!(flags & sched_deadline_boost_mask);
+	else
+#endif // CONFIG_SCHED_BORE
 	/*
 	 * When joining the competition; the existing tasks will be,
 	 * on average, halfway through their slice, as such start tasks
@@ -7187,6 +7245,15 @@ static bool dequeue_task_fair(struct rq *rq, struct task_struct *p, int flags)
 		util_est_dequeue(&rq->cfs, p);
 
 	util_est_update(&rq->cfs, p, flags & DEQUEUE_SLEEP);
+#ifdef CONFIG_SCHED_BORE
+	struct cfs_rq *cfs_rq = &rq->cfs;
+	struct sched_entity *se = &p->se;
+	if (flags & DEQUEUE_SLEEP && entity_is_task(se)) {
+		if (cfs_rq->curr == se)
+			update_curr(cfs_rq);
+		restart_burst(se);
+	}
+#endif // CONFIG_SCHED_BORE
 	if (dequeue_entities(rq, &p->se, flags) < 0)
 		return false;
 
@@ -9016,16 +9083,25 @@ static void yield_task_fair(struct rq *rq)
 	/*
 	 * Are we the only task in the tree?
 	 */
+#if !defined(CONFIG_SCHED_BORE)
 	if (unlikely(rq->nr_running == 1))
 		return;
 
 	clear_buddies(cfs_rq, se);
+#endif // CONFIG_SCHED_BORE
 
 	update_rq_clock(rq);
 	/*
 	 * Update run-time statistics of the 'current'.
 	 */
 	update_curr(cfs_rq);
+#ifdef CONFIG_SCHED_BORE
+	restart_burst_rescale_deadline(se);
+	if (unlikely(rq->nr_running == 1))
+		return;
+
+	clear_buddies(cfs_rq, se);
+#endif // CONFIG_SCHED_BORE
 	/*
 	 * Tell update_rq_clock() that we've just updated,
 	 * so we don't do microscopic update in schedule()
@@ -13138,6 +13214,9 @@ static void task_tick_fair(struct rq *rq, struct task_struct *curr, int queued)
 static void task_fork_fair(struct task_struct *p)
 {
 	set_task_max_allowed_capacity(p);
+#ifdef CONFIG_SCHED_BORE
+	update_burst_score(&p->se);
+#endif // CONFIG_SCHED_BORE
 }
 
 /*
@@ -13255,6 +13334,9 @@ static void switched_to_fair(struct rq *rq, struct task_struct *p)
 {
 	WARN_ON_ONCE(p->se.sched_delayed);
 
+#ifdef CONFIG_SCHED_BORE
+	reset_task_bore(p);
+#endif // CONFIG_SCHED_BORE
 	attach_task_cfs_rq(p);
 
 	set_task_max_allowed_capacity(p);
diff --git a/kernel/sched/sched.h b/kernel/sched/sched.h
index 47972f34ea..a7c69cfbcf 100644
--- a/kernel/sched/sched.h
+++ b/kernel/sched/sched.h
@@ -2100,7 +2100,11 @@ extern int group_balance_cpu(struct sched_group *sg);
 extern void update_sched_domain_debugfs(void);
 extern void dirty_sched_domain_sysctl(int cpu);
 
+#ifdef CONFIG_SCHED_BORE
+extern void sched_update_min_base_slice(void);
+#else // !CONFIG_SCHED_BORE
 extern int sched_update_scaling(void);
+#endif // CONFIG_SCHED_BORE
 
 static inline const struct cpumask *task_user_cpus(struct task_struct *p)
 {
@@ -2799,7 +2803,12 @@ extern void wakeup_preempt(struct rq *rq, struct task_struct *p, int flags);
 extern __read_mostly unsigned int sysctl_sched_nr_migrate;
 extern __read_mostly unsigned int sysctl_sched_migration_cost;
 
+#ifdef CONFIG_SCHED_BORE
+extern unsigned int sysctl_sched_min_base_slice;
+extern __read_mostly uint sysctl_sched_base_slice;
+#else // !CONFIG_SCHED_BORE
 extern unsigned int sysctl_sched_base_slice;
+#endif // CONFIG_SCHED_BORE
 
 extern int sysctl_resched_latency_warn_ms;
 extern int sysctl_resched_latency_warn_once;
-- 
2.34.1

--- a/kernel/sched/bore.c	2025-06-01 23:36:18.232869234 +0200
+++ b/kernel/sched/bore.c	2025-08-15 11:34:05.354450555 +0200
@@ -1,449 +1,2018 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
- *  Burst-Oriented Response Enhancer (BORE) CPU Scheduler
- *  Copyright (C) 2021-2025 Masahito Suzuki <firelzrd@gmail.com>
+ * Burst-Oriented Response Enhancer (BORE) CPU Scheduler
+ *
+ * Production-Ready: Raptor-Lake HFI/ITD-aware (no CONFIG_IPC_CLASSES),
+ * context-safe, cache-safe, ABI-compatible with the original BORE interfaces.
+ *
+ *                       ***  DEFINITIVE AUDITED EDITION  ***
+ *
+ * Key Enhancements:
+ *   - Correct Sysctl Registration: Uses register_sysctl_sz() with an explicit
+ *     entry count per configuration, robust and verifiably correct.
+ *   - Zero-Cost ITD Path: Static-key gates the ITD/HFI feature so it's a NOP
+ *     when disabled (zero overhead).
+ *   - Optimized Penalty & Bias Math: Bounded 64-bit math and 32-bit constant
+ *     divisions (Compiler emits reciprocal multiply) in hot-path ITD bias.
+ *   - False Sharing Elimination: Per-CPU ITD state and caches are cache-line
+ *     aligned.
+ *   - Robust Initialization: ITD static_key state is set correctly at boot and
+ *     safely updated via sysctl at runtime.
  */
-#include <linux/cpuset.h>
+
+#undef pr_fmt
+#define pr_fmt(fmt) "BORE: " fmt
+
+/* ================================================================== */
+/*                          0.  Headers                               */
+/* ================================================================== */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/atomic.h>
+#include <linux/spinlock.h>
+#include <linux/interrupt.h>
+#include <linux/cpumask.h>
+#include <linux/percpu.h>
+#include <linux/sched.h>
+#include <linux/sched/clock.h>
 #include <linux/sched/task.h>
+#include <linux/sched/topology.h>
 #include <linux/sched/bore.h>
+#include <linux/sched/signal.h>
+#include <linux/sysctl.h>
+#include <linux/bitmap.h>
+#include <linux/static_key.h>
+#include <linux/static_call.h>
+#include <linux/list.h>
+#include <linux/slab.h>
+#include <linux/math64.h>
+#include <linux/cpuhotplug.h>
+#include <linux/workqueue.h>
+#include <linux/cpu.h>
+#include <linux/smp.h>
+#include <linux/refcount.h>
+#include <linux/prefetch.h>
+#include <linux/bitops.h>
+#include <linux/jiffies.h>
+#include <linux/types.h>
+#include <linux/rculist.h>
+#include <linux/limits.h>
+#include <linux/lockdep.h>
+
+#include <asm/processor.h>
+#include <asm/topology.h>
+#include <asm/cpufeature.h>
+#include <asm/msr.h>
+#include <asm/msr-index.h>
+
+/*
+ * Fallback for task_cpu_possible() referenced by sched.h::task_allowed_on_cpu().
+ * TU-local static inline: no ABI change. Must precede "sched.h" so inlines see it.
+ */
+static __always_inline bool task_cpu_possible(int cpu, const struct task_struct *p)
+{
+#ifdef CONFIG_SMP
+	(void)p;
+	return cpumask_test_cpu(cpu, cpu_possible_mask);
+#else
+	(void)cpu; (void)p;
+	return true;
+#endif
+}
+
 #include "sched.h"
 
 #ifdef CONFIG_SCHED_BORE
-u8   __read_mostly sched_bore                   = 1;
-u8   __read_mostly sched_burst_exclude_kthreads = 1;
-u8   __read_mostly sched_burst_smoothness       = 20;
-u8   __read_mostly sched_burst_fork_atavistic   = 2;
-u8   __read_mostly sched_burst_parity_threshold = 2;
-u8   __read_mostly sched_burst_penalty_offset   = 24;
-uint __read_mostly sched_burst_penalty_scale    = 3180;
-uint __read_mostly sched_burst_cache_stop_count = 64;
-uint __read_mostly sched_burst_cache_lifetime   = 75000000;
-uint __read_mostly sched_deadline_boost_mask    = ENQUEUE_INITIAL
-                                                | ENQUEUE_WAKEUP;
-static int __maybe_unused maxval_6_bits  =   63;
-static int __maybe_unused maxval_8_bits  =  255;
-static int __maybe_unused maxval_12_bits = 4095;
-
-#define BURST_PENALTY_SHIFT 12
-#define MAX_BURST_PENALTY (39U << BURST_PENALTY_SHIFT)
-
-static u32 log2p1_u64_u32fp(u64 v, u8 fp) {
-	if (!v) return 0;
-	u32 exponent = fls64(v);
-	u32 mantissa = (u32)(v << (64 - exponent) << 1 >> (64 - fp));
-	return exponent << fp | mantissa;
-}
-
-static inline u32 calc_burst_penalty(u64 burst_time) {
-	u32 greed, tolerance, penalty, scaled_penalty;
-	
-	greed = log2p1_u64_u32fp(burst_time, BURST_PENALTY_SHIFT);
-	tolerance = sched_burst_penalty_offset << BURST_PENALTY_SHIFT;
-	penalty = max(0, (s32)(greed - tolerance));
-	scaled_penalty = penalty * sched_burst_penalty_scale >> 10;
-
-	return min(MAX_BURST_PENALTY, scaled_penalty);
-}
-
-static inline u64 __scale_slice(u64 delta, u8 score)
-{return mul_u64_u32_shr(delta, sched_prio_to_wmult[score], 22);}
-
-static inline u64 __unscale_slice(u64 delta, u8 score)
-{return mul_u64_u32_shr(delta, sched_prio_to_weight[score], 10);}
-
-static void reweight_task_by_prio(struct task_struct *p, int prio) {
-	struct sched_entity *se = &p->se;
-	unsigned long weight = scale_load(sched_prio_to_weight[prio]);
-
-	reweight_entity(cfs_rq_of(se), se, weight, true);
-	se->load.inv_weight = sched_prio_to_wmult[prio];
-}
-
-static inline u8 effective_prio(struct task_struct *p) {
-	u8 prio = p->static_prio - MAX_RT_PRIO;
-	if (likely(sched_bore))
-		prio += p->se.burst_score;
-	return min(39, prio);
-}
-
-void update_burst_score(struct sched_entity *se) {
-	if (!entity_is_task(se)) return;
-	struct task_struct *p = task_of(se);
-	u8 prev_prio = effective_prio(p);
-
-	u8 burst_score = 0;
-	if (!((p->flags & PF_KTHREAD) && likely(sched_burst_exclude_kthreads)))
-		burst_score = se->burst_penalty >> BURST_PENALTY_SHIFT;
-	se->burst_score = burst_score;
-
-	u8 new_prio = effective_prio(p);
-	if (new_prio != prev_prio)
-		reweight_task_by_prio(p, new_prio);
-}
-
-void update_curr_bore(u64 delta_exec, struct sched_entity *se) {
-	if (!entity_is_task(se)) return;
-
-	se->burst_time += delta_exec;
-	se->curr_burst_penalty = calc_burst_penalty(se->burst_time);
-	if (se->curr_burst_penalty > se->prev_burst_penalty)
-		se->burst_penalty = se->prev_burst_penalty +
-		(se->curr_burst_penalty - se->prev_burst_penalty) / se->burst_count;
-	update_burst_score(se);
-}
 
-static inline u32 binary_smooth(u32 new, u32 old, u8 dumper) {
-	s32 increment = new - old;
-	return (0 <= increment)?
-		old + ( increment / dumper):
-		old - (-increment / dumper);
-}
+/* Forward declarations */
+void update_burst_penalty(struct sched_entity *se);
+void update_curr_bore(u64 delta_exec, struct sched_entity *se);
+void update_burst_score(struct sched_entity *se);
+void restart_burst(struct sched_entity *se);
+void restart_burst_rescale_deadline(struct sched_entity *se);
+void sched_clone_bore(struct task_struct *p_new_task, struct task_struct *p_parent,
+		      u64 clone_flags, u64 now_ns);
+void reset_task_bore(struct task_struct *p);
+void __init sched_bore_init(void);
+
+/* ================================================================== */
+/*                    0a.  Local helpers (type-safe abs64)            */
+/* ================================================================== */
+static __always_inline u64 bore_abs64(s64 v)
+{
+	return (v < 0) ? (0ULL - (u64)v) : (u64)v;
+}
+
+/* ================================================================== */
+/*                              1.  Tunables                          */
+/* ================================================================== */
+#define BORE_ORIG_SCHED_BORE                   1
+#define BORE_ORIG_BURST_EXCLUDE_KTHREADS       1
+#define BORE_ORIG_BURST_SMOOTHNESS_LONG        1
+#define BORE_ORIG_BURST_SMOOTHNESS_SHORT       0
+#define BORE_ORIG_BURST_FORK_ATAVISTIC         2
+#define BORE_ORIG_BURST_PARITY_THRESHOLD       2
+#define BORE_ORIG_BURST_PENALTY_OFFSET         24
+#define BORE_ORIG_BURST_PENALTY_SCALE          1280
+#define BORE_ORIG_BURST_CACHE_STOP_COUNT       64
+#define BORE_ORIG_BURST_CACHE_LIFETIME         (75 * 1000 * 1000)
+#define BORE_ORIG_DEADLINE_BOOST_MASK          (ENQUEUE_INITIAL | ENQUEUE_WAKEUP)
+#define BORE_DEF_PCORE_HOG_THRESHOLD_PCT       85
+#define BORE_DEF_PCORE_HOG_PENALTY_ADD         2
+#define BORE_DEF_ECORE_AVERSION_PENALTY        2
+#define BORE_DEF_ITD_AGGRESSIVENESS_PCT        25
+
+#define DEF_U8(name, val)   u8   __read_mostly name = (val)
+#define DEF_U32(name, val)  u32  __read_mostly name = (val)
+
+DEF_U8(sched_bore,                    BORE_ORIG_SCHED_BORE);
+DEF_U8(sched_burst_exclude_kthreads,  BORE_ORIG_BURST_EXCLUDE_KTHREADS);
+DEF_U8(sched_burst_smoothness_long,   BORE_ORIG_BURST_SMOOTHNESS_LONG);
+DEF_U8(sched_burst_smoothness_short,  BORE_ORIG_BURST_SMOOTHNESS_SHORT);
+DEF_U8(sched_burst_fork_atavistic,    BORE_ORIG_BURST_FORK_ATAVISTIC);
+DEF_U8(sched_burst_parity_threshold,  BORE_ORIG_BURST_PARITY_THRESHOLD);
+DEF_U8(sched_burst_penalty_offset,    BORE_ORIG_BURST_PENALTY_OFFSET);
+
+DEF_U32(sched_burst_penalty_scale,     BORE_ORIG_BURST_PENALTY_SCALE);
+DEF_U32(sched_burst_cache_stop_count,  BORE_ORIG_BURST_CACHE_STOP_COUNT);
+DEF_U32(sched_burst_cache_lifetime,    BORE_ORIG_BURST_CACHE_LIFETIME);
+DEF_U32(sched_deadline_boost_mask,     BORE_ORIG_DEADLINE_BOOST_MASK);
+
+/* P/E core aware tunables */
+DEF_U8(sched_burst_core_aware_penalty,    0);
+DEF_U8(sched_burst_core_aware_smoothing,  0);
+DEF_U32(sched_burst_penalty_pcore_scale_pct, 100);
+DEF_U32(sched_burst_penalty_ecore_scale_pct, 100);
+DEF_U8(sched_burst_smoothness_long_p, BORE_ORIG_BURST_SMOOTHNESS_LONG);
+DEF_U8(sched_burst_smoothness_short_p, BORE_ORIG_BURST_SMOOTHNESS_SHORT);
+DEF_U8(sched_burst_smoothness_long_e, BORE_ORIG_BURST_SMOOTHNESS_LONG);
+DEF_U8(sched_burst_smoothness_short_e, BORE_ORIG_BURST_SMOOTHNESS_SHORT);
+DEF_U8(sched_burst_ecore_aversion_penalty, BORE_DEF_ECORE_AVERSION_PENALTY);
+
+/* ================================================================== */
+/*                     2.  ITD via HFI (no IPC_CLASSES)               */
+/* ================================================================== */
+#ifdef CONFIG_X86
+#ifndef HW_FEEDBACK_CONFIG_HFI_ENABLE_BIT
+#define HW_FEEDBACK_CONFIG_HFI_ENABLE_BIT    BIT(0)
+#endif
+#ifndef HW_FEEDBACK_THREAD_CONFIG_ENABLE_BIT
+#define HW_FEEDBACK_THREAD_CONFIG_ENABLE_BIT BIT(0)
+#endif
+
+/* ITD/HFI sysctls */
+static u8  __read_mostly sched_burst_itd_enable     = 1;              /* master enable */
+static u32 __read_mostly sched_burst_itd_sample_ns  = 2 * 1000 * 1000;/* 2ms */
+static u32 __read_mostly sched_burst_itd_cap_pct    = 60;             /* 0..100% */
+
+/* Per-class bias percentages */
+#define ITD_MAX_CLASSES 8
+static u32 __read_mostly sched_burst_itd_bias_pcore_pct[ITD_MAX_CLASSES] = {
+	[0] = 0,    /* Class 0 (background): No preference */
+	[1] = 5,    /* Class 1 (normal): Slight preference */
+	[2] = 45,   /* Class 2 (heavy): Strong preference */
+	[3] = 90,   /* Class 3 (critical): Anchor to P-core */
+	[4 ... ITD_MAX_CLASSES - 1] = 0,
+};
+static u32 __read_mostly sched_burst_itd_bias_ecore_pct[ITD_MAX_CLASSES] = {
+	[0] = 0,    /* Class 0 (background): No disincentive */
+	[1] = 10,   /* Class 1 (normal): Slight disincentive */
+	[2] = 50,   /* Class 2 (heavy): Strong disincentive */
+	[3] = 100,  /* Class 3 (critical): Evict from E-core */
+	[4 ... ITD_MAX_CLASSES - 1] = 0,
+};
 
-static void __restart_burst(struct sched_entity *se) {
-	se->prev_burst_penalty = binary_smooth(
-		se->curr_burst_penalty, se->prev_burst_penalty, se->burst_count);
-	se->burst_time = 0;
-	se->curr_burst_penalty = 0;
+/* Per-CPU ITD/HFI sampling state – cache-line aligned to kill false sharing */
+struct bore_itd_state {
+	u64 last_sample_ns;
+	u8  last_class;
+	u8  last_valid;
+	u8  inited;
+} ____cacheline_aligned_in_smp;
+static DEFINE_PER_CPU(struct bore_itd_state, bore_itd_state);
+
+/* Static-key so ITD code costs zero cycles when disabled */
+DEFINE_STATIC_KEY_FALSE(bore_itd_key);
+
+/* Availability: user enabled + hardware feature present */
+static __always_inline bool bore_itd_is_available(void)
+{
+	return READ_ONCE(sched_burst_itd_enable) && boot_cpu_has(X86_FEATURE_HFI);
+}
+
+/* One-shot per-CPU enable; idempotent. Must run with preemption disabled. */
+static __always_inline void bore_itd_lazy_enable_this_cpu(void)
+{
+	u64 val;
+	struct bore_itd_state *st;
+
+	lockdep_assert_preemption_disabled();
 
-	u8 smoothness = sched_burst_smoothness;
-	if (se->burst_count < smoothness)
-		se->burst_count++;
-	else if (unlikely(se->burst_count > smoothness))
-		se->burst_count = smoothness;
+	st = this_cpu_ptr(&bore_itd_state);
+
+	if (READ_ONCE(st->inited)) {
+		return;
+	}
+
+#ifdef MSR_IA32_HW_FEEDBACK_THREAD_CONFIG
+	/* Enable thread config bit with RMW to avoid clearing other bits. */
+	if (!rdmsrq_safe(MSR_IA32_HW_FEEDBACK_THREAD_CONFIG, &val)) {
+		val |= HW_FEEDBACK_THREAD_CONFIG_ENABLE_BIT;
+		wrmsrl(MSR_IA32_HW_FEEDBACK_THREAD_CONFIG, val);
+	} else {
+		/* If read fails, best-effort blind write of enable bit. */
+		wrmsrl(MSR_IA32_HW_FEEDBACK_THREAD_CONFIG,
+		       HW_FEEDBACK_THREAD_CONFIG_ENABLE_BIT);
+	}
+#endif
+#ifdef MSR_IA32_HW_FEEDBACK_CONFIG
+	if (!rdmsrq_safe(MSR_IA32_HW_FEEDBACK_CONFIG, &val)) {
+		val |= HW_FEEDBACK_CONFIG_HFI_ENABLE_BIT;
+		wrmsrl(MSR_IA32_HW_FEEDBACK_CONFIG, val);
+	}
+#endif
+	WRITE_ONCE(st->inited, 1);
+	WRITE_ONCE(st->last_sample_ns, 0);
+	WRITE_ONCE(st->last_valid, 0);
+	WRITE_ONCE(st->last_class, 0);
+}
+
+/* Rate-limited HFI read; returns true when class is valid; preemption disabled. */
+static __always_inline bool bore_itd_read_class(u8 *classid)
+{
+	u64 now  = local_clock();
+	struct bore_itd_state *st;
+	u64 last, gap;
+
+	lockdep_assert_preemption_disabled();
+
+	st   = this_cpu_ptr(&bore_itd_state);
+	last = READ_ONCE(st->last_sample_ns);
+	gap  = READ_ONCE(sched_burst_itd_sample_ns);
+
+	if (last && (now - last) < gap) {
+		if (READ_ONCE(st->last_valid)) {
+			*classid = READ_ONCE(st->last_class);
+			return true;
+		}
+		return false;
+	}
+
+#ifdef MSR_IA32_HW_FEEDBACK_CHAR
+	{
+		u64 v;
+		bool valid;
+		u8 c;
+
+		if (rdmsrq_safe(MSR_IA32_HW_FEEDBACK_CHAR, &v) != 0) {
+			WRITE_ONCE(st->last_sample_ns, now);
+			WRITE_ONCE(st->last_valid, 0);
+			return false;
+		}
+
+		/* Layout: [63] valid, [7:0] classid. */
+		valid = (v >> 63) & 0x1;
+		WRITE_ONCE(st->last_sample_ns, now);
+		if (!valid) {
+			WRITE_ONCE(st->last_valid, 0);
+			return false;
+		}
+
+		c = (u8)(v & 0xff);
+		WRITE_ONCE(st->last_class, c);
+		WRITE_ONCE(st->last_valid, 1);
+		*classid = c;
+		return true;
+	}
+#else
+	WRITE_ONCE(st->last_sample_ns, now);
+	WRITE_ONCE(st->last_valid, 0);
+	return false;
+#endif
+}
+
+/* Bias penalty according to ITD class & core type – optimized (div by const) */
+static __always_inline u32 bore_itd_bias_penalty_fast(u32 base_penalty,
+                                                      u8  classid,
+                                                      bool is_pcore)
+{
+    if (classid >= ITD_MAX_CLASSES || base_penalty == 0U) {
+        return base_penalty;
+    }
+
+    u32 pct = is_pcore
+        ? READ_ONCE(sched_burst_itd_bias_pcore_pct[classid])
+        : READ_ONCE(sched_burst_itd_bias_ecore_pct[classid]);
+    u32 cap = clamp_t(u32, READ_ONCE(sched_burst_itd_cap_pct), 0U, 100U);
+
+    pct = clamp_t(u32, pct, 0U, 100U);
+    if (!pct || !cap) {
+        return base_penalty;
+    }
+
+    /* min(cap, pct) * base / 100 */
+    u32 eff_pct = (pct < cap) ? pct : cap;
+    u32 adj = (base_penalty * eff_pct) / 100U;
+
+    if (is_pcore) {
+        /* Reduce penalty on P-core; saturating subtract. */
+        return (adj >= base_penalty) ? 0U : (base_penalty - adj);
+    } else {
+        /* Increase penalty on E-core; saturating add. */
+        u32 res = base_penalty + adj;
+        return (res < base_penalty) ? U32_MAX : res;
+    }
+}
+#endif /* CONFIG_X86 */
+
+/* ================================================================== */
+/*                           2b.  Constants                            */
+/* ================================================================== */
+#define MAX_BURST_PENALTY          156U
+#define ECORE_OFFSET_ADJ_DIV       20
+#define MAX_ECORE_OFFSET_ADJUST    10
+#define MIN_EFFECTIVE_OFFSET       4
+#define BORE_MAX_VRUNTIME_CLAMP    (200LL * NSEC_PER_MSEC)
+
+/* ================================================================== */
+/*                     3.  Static keys & calls                        */
+/* ================================================================== */
+DEFINE_STATIC_KEY_FALSE(bore_core_aware_key);
+
+/* ================================================================== */
+/*        3a.  Per-CPU penalty params cache (+generation)             */
+/* ================================================================== */
+struct bore_penalty_param {
+	u32 scale;
+	u32 sat_thresh_q8;
+	s16 itd_pri;
+	u8  offset;
+	u8  gen;
+} ____cacheline_aligned_in_smp;
+
+DEFINE_PER_CPU(struct bore_penalty_param, bore_penalty);
+static atomic_t bore_penalty_gen = ATOMIC_INIT(1);
+
+/* ================================================================== */
+/*                 4.  Per-CPU CPU-type cache                          */
+/* ================================================================== */
+DEFINE_PER_CPU_ALIGNED(enum x86_topology_cpu_type, bore_cpu_type) = TOPO_CPU_TYPE_UNKNOWN;
+
+/* ================================================================== */
+/*        4a.  Per-CPU IPCC dirty flag (compatibility)                */
+/* ================================================================== */
+DEFINE_PER_CPU(bool, bore_ipcc_dirty);
+
+/* ================================================================== */
+/*                       5.  Scale LUT                                */
+/* ================================================================== */
+static u8  log2_frac_lut[64]  __ro_after_init __aligned(64);
+static u8 prio_lookup[40][40] __ro_after_init __aligned(64);
+static u32 log2_lookup[256] __ro_after_init __aligned(64);
+
+static void bore_build_penalty_param_for_cpu(int cpu);
+
+static __always_inline enum x86_topology_cpu_type
+bore_get_rq_cpu_type(struct rq *rq)
+{
+	if (static_branch_unlikely(&bore_core_aware_key)) {
+		return per_cpu(bore_cpu_type, rq->cpu);
+	}
+	return TOPO_CPU_TYPE_UNKNOWN;
 }
 
-inline void restart_burst(struct sched_entity *se) {
-	__restart_burst(se);
-	se->burst_penalty = se->prev_burst_penalty;
-	update_burst_score(se);
+static void __init bore_build_lookup_tables(void)
+{
+	int base, score, prio;
+
+	/* Initialize priority lookup table */
+	for (base = 0; base < 40; base++) {
+		for (score = 0; score < 40; score++) {
+			prio = base - score;
+			prio = max(0, min(NICE_WIDTH - 1, prio));
+			prio_lookup[base][score] = (u8)prio;
+		}
+	}
+
+	/*
+	 * Pre-computed logarithm lookup table for fractional parts
+	 * These values represent log2(1 + i/256) * 256 for i from 0 to 255
+	 * Computed offline to avoid floating-point in kernel
+	 */
+	static const u32 log2_lookup_values[256] = {
+		  0,   1,   3,   4,   6,   7,   9,  10,  11,  13,  14,  16,  17,  18,  20,  21,
+		 22,  24,  25,  26,  28,  29,  30,  32,  33,  34,  35,  37,  38,  39,  40,  42,
+		 43,  44,  45,  47,  48,  49,  50,  51,  53,  54,  55,  56,  57,  58,  60,  61,
+		 62,  63,  64,  65,  66,  68,  69,  70,  71,  72,  73,  74,  75,  76,  78,  79,
+		 80,  81,  82,  83,  84,  85,  86,  87,  88,  89,  90,  91,  92,  93,  94,  95,
+		 96,  97,  98,  99, 100, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,
+		113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128,
+		129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 141, 142, 143,
+		144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 156, 157, 158,
+		159, 160, 161, 162, 163, 164, 165, 165, 166, 167, 168, 169, 170, 171, 172, 173,
+		173, 174, 175, 176, 177, 178, 179, 179, 180, 181, 182, 183, 184, 185, 185, 186,
+		187, 188, 189, 190, 190, 191, 192, 193, 194, 195, 195, 196, 197, 198, 199, 199,
+		200, 201, 202, 203, 203, 204, 205, 206, 207, 207, 208, 209, 210, 211, 211, 212,
+		213, 214, 214, 215, 216, 217, 218, 218, 219, 220, 221, 221, 222, 223, 224, 224,
+		225, 226, 227, 227, 228, 229, 230, 230, 231, 232, 233, 233, 234, 235, 236, 236,
+		237, 238, 239, 239, 240, 241, 241, 242, 243, 244, 244, 245, 246, 247, 247, 248
+	};
+
+	/* Copy pre-computed values to the lookup table */
+	memcpy(log2_lookup, log2_lookup_values, sizeof(log2_lookup_values));
+}
+
+/* ================================================================== */
+/*                     6.  Hybrid detection                           */
+/* ================================================================== */
+static bool __init is_intel_raptor_lake(void)
+{
+#ifdef CONFIG_X86_64
+	if (boot_cpu_data.x86_vendor != X86_VENDOR_INTEL || boot_cpu_data.x86 != 6) {
+		return false;
+	}
+
+	switch (boot_cpu_data.x86_model) {
+	case 0xB7: case 0xBA: case 0xBE: case 0xBF:
+	case 0xAC: case 0xB1:
+		return true;
+	}
+#endif
+	return false;
 }
 
-void restart_burst_rescale_deadline(struct sched_entity *se) {
-	s64 vscaled, wremain, vremain = se->deadline - se->vruntime;
-	struct task_struct *p = task_of(se);
-	u8 prev_prio = effective_prio(p);
-	restart_burst(se);
-	u8 new_prio = effective_prio(p);
-	if (prev_prio > new_prio) {
-		wremain = __unscale_slice(abs(vremain), prev_prio);
-		vscaled = __scale_slice(wremain, new_prio);
-		if (unlikely(vremain < 0))
-			vscaled = -vscaled;
-		se->deadline = se->vruntime + vscaled;
+static bool __init is_intel_hybrid(void)
+{
+#ifdef CONFIG_X86_64
+	return boot_cpu_has(X86_FEATURE_HYBRID_CPU) || is_intel_raptor_lake();
+#else
+	return false;
+#endif
+}
+
+/* ================================================================== */
+/*          7.  Topology scan + deferred static-key enable            */
+/* ================================================================== */
+static bool bore_cpu_types_detected;
+static void bore_enable_key_workfn(struct work_struct *w);
+static DECLARE_WORK(bore_enable_key_work, bore_enable_key_workfn);
+
+static inline void bore_bump_penalty_gen(void)
+{
+	atomic_inc(&bore_penalty_gen);
+}
+
+static inline const struct bore_penalty_param *bore_get_param(void)
+{
+    struct bore_penalty_param *pp;
+    s16 itd_now;
+    u8  g_now;
+
+    /* Required: callers must hold preempt disabled (lockdep checks it). */
+    lockdep_assert_preemption_disabled();
+
+    pp      = this_cpu_ptr(&bore_penalty);
+    itd_now = arch_asym_cpu_priority(smp_processor_id());
+    g_now   = (u8)atomic_read(&bore_penalty_gen);
+
+    /* Rebuild per-CPU params if generation or asym priority changed. */
+    if (unlikely(pp->gen != g_now || pp->itd_pri != itd_now)) {
+        bore_build_penalty_param_for_cpu(smp_processor_id());
+    }
+
+    return pp;
+}
+
+static void bore_build_penalty_param_for_cpu(int cpu)
+{
+    struct bore_penalty_param *pp = &per_cpu(bore_penalty, cpu);
+    enum x86_topology_cpu_type ct = per_cpu(bore_cpu_type, cpu);
+    u32 scale  = READ_ONCE(sched_burst_penalty_scale);
+    u8  offset = READ_ONCE(sched_burst_penalty_offset);
+    s16 itd_pr = arch_asym_cpu_priority(cpu);
+
+    /* Core-aware scaling (topology-based) */
+    if (READ_ONCE(sched_burst_core_aware_penalty) &&
+        static_branch_unlikely(&bore_core_aware_key)) {
+        u32 base = READ_ONCE(sched_burst_penalty_scale);
+
+        if (ct == TOPO_CPU_TYPE_EFFICIENCY) {
+            u32 pct = clamp_t(u32,
+                              READ_ONCE(sched_burst_penalty_ecore_scale_pct),
+                              0U, 200U);
+            scale = div_u64((u64)base * pct, 100U);
+            if (pct > 100U) {
+                u8 adj = min_t(u8, MAX_ECORE_OFFSET_ADJUST,
+                               (u8)((pct - 100U) / ECORE_OFFSET_ADJ_DIV));
+                offset = max_t(u8, MIN_EFFECTIVE_OFFSET, (u8)(offset - adj));
+            }
+        } else if (ct == TOPO_CPU_TYPE_PERFORMANCE) {
+            u32 pct = clamp_t(u32,
+                              READ_ONCE(sched_burst_penalty_pcore_scale_pct),
+                              0U, 200U);
+            scale = div_u64((u64)base * pct, 100U);
+        }
+    }
+
+    /*
+     * Aggressiveness shaping by asym priority (topology signal).
+     * This is not HFI/ITD; keep it always-on when available.
+     */
+    if (itd_pr > 0) {
+        u64 pr_norm             = min_t(u64, 1024U, (u64)itd_pr);
+        u64 reduction_factor    = (1024U - pr_norm) * (1024U - pr_norm);
+        u32 reduction_permille  = div_u64(reduction_factor, 1049U);
+        u32 aggressiveness      = clamp_t(u32,
+                                          BORE_DEF_ITD_AGGRESSIVENESS_PCT, 0U, 100U);
+        u32 scale_reduction     =
+            div_u64((u64)scale * reduction_permille * aggressiveness, 100000U);
+        scale = max_t(u32, scale / 4U, scale - scale_reduction);
+    }
+
+    pp->scale         = scale;
+    pp->offset        = offset;
+    pp->itd_pri       = itd_pr;
+    pp->sat_thresh_q8 = !scale ? U32_MAX :
+        div_u64(((u64)MAX_BURST_PENALTY << 16) + scale - 1, scale);
+
+    /*
+     * Make sure the structure is fully initialised before publishing the gen.
+     * Readers check (gen,itd_pri) together under preempt disabled.
+     */
+    smp_wmb();
+    pp->gen = (u8)atomic_read(&bore_penalty_gen);
+}
+
+static void bore_enable_key_workfn(struct work_struct *w)
+{
+	(void)w;
+	if (!static_branch_unlikely(&bore_core_aware_key)) {
+		static_branch_enable(&bore_core_aware_key);
+		pr_info("Core-aware static key enabled via workqueue.\n");
 	}
 }
 
-static inline bool task_is_bore_eligible(struct task_struct *p)
-{return p && p->sched_class == &fair_sched_class && !p->exit_state;}
+static void bore_check_and_update_topology_features(void)
+{
+	unsigned int cpu;
+	bool found_hybrid = false;
+
+	for_each_possible_cpu(cpu) {
+		enum x86_topology_cpu_type t =
+			get_topology_cpu_type(&cpu_data(cpu));
+		per_cpu(bore_cpu_type, cpu) = t;
+		if (t == TOPO_CPU_TYPE_PERFORMANCE ||
+		    t == TOPO_CPU_TYPE_EFFICIENCY) {
+			found_hybrid = true;
+		}
+		bore_build_penalty_param_for_cpu(cpu);
+	}
 
-static inline void reset_task_weights_bore(void) {
-	struct task_struct *task;
-	struct rq *rq;
-	struct rq_flags rf;
+	if (!found_hybrid) {
+		if (is_intel_hybrid() && !bore_cpu_types_detected) {
+			pr_info("Hybrid CPU but no P/E info yet – will retry.\n");
+		}
+		return;
+	}
+
+	if (!bore_cpu_types_detected) {
+		pr_info("P/E core topology detected.\n");
+		bore_cpu_types_detected            = true;
+		sched_burst_core_aware_penalty     = 1;
+		sched_burst_core_aware_smoothing   = 1;
+
+		if (is_intel_raptor_lake()) {
+			pr_info("Applying Raptor-Lake P/E specific tunings.\n");
+			WRITE_ONCE(sched_burst_penalty_ecore_scale_pct, 140);
+			WRITE_ONCE(sched_burst_smoothness_long_e, 3);
+			WRITE_ONCE(sched_burst_smoothness_short_e, 1);
+			WRITE_ONCE(sched_burst_parity_threshold,
+				   READ_ONCE(sched_burst_parity_threshold) + 2);
+		} else if (is_intel_hybrid()) {
+			pr_info("Applying generic Intel Hybrid P/E tunings.\n");
+		}
+
+		bore_bump_penalty_gen();
+		for_each_possible_cpu(cpu) {
+			bore_build_penalty_param_for_cpu(cpu);
+		}
+	}
 
-	write_lock_irq(&tasklist_lock);
-	for_each_process(task) {
-		if (!task_is_bore_eligible(task)) continue;
-		rq = task_rq(task);
-		rq_pin_lock(rq, &rf);
-		update_rq_clock(rq);
-		reweight_task_by_prio(task, effective_prio(task));
-		rq_unpin_lock(rq, &rf);
+	if (!static_branch_unlikely(&bore_core_aware_key)) {
+		schedule_work(&bore_enable_key_work);
 	}
-	write_unlock_irq(&tasklist_lock);
 }
 
-int sched_bore_update_handler(const struct ctl_table *table, int write,
-	void __user *buffer, size_t *lenp, loff_t *ppos) {
-	int ret = proc_dou8vec_minmax(table, write, buffer, lenp, ppos);
-	if (ret || !write)
-		return ret;
+static int bore_cpu_online_cb(unsigned int cpu)
+{
+	per_cpu(bore_cpu_type, cpu) = get_topology_cpu_type(&cpu_data(cpu));
+	bore_build_penalty_param_for_cpu(cpu);
+	bore_check_and_update_topology_features();
+	per_cpu(bore_ipcc_dirty, cpu) = true;
+	return 0;
+}
 
-	reset_task_weights_bore();
+static int bore_cpu_offline_cb(unsigned int cpu)
+{
+	int i;
 
+	for_each_online_cpu(i) {
+		per_cpu(bore_ipcc_dirty, i) = true;
+	}
 	return 0;
 }
 
-#define for_each_child(p, t) \
-	list_for_each_entry(t, &(p)->children, sibling)
+static enum cpuhp_state bore_cpuhp_state_val __maybe_unused;
 
-static inline u32 count_entries_upto2(struct list_head *head) {
-	struct list_head *next = head->next;
-	return (next != head) + (next->next != head);
+static int __init bore_topology_init(void)
+{
+	int ret_hp;
+
+	bore_check_and_update_topology_features();
+
+	ret_hp = cpuhp_setup_state_nocalls(CPUHP_AP_ONLINE_DYN,
+					   "sched/bore:online",
+					   bore_cpu_online_cb,
+					   bore_cpu_offline_cb);
+	if (ret_hp < 0) {
+		pr_err("cpuhp_setup_state_nocalls failed: %d\n", ret_hp);
+	} else {
+		bore_cpuhp_state_val = ret_hp;
+	}
+
+	return 0;
 }
 
-static inline void init_task_burst_cache_lock(struct task_struct *p) {
-	spin_lock_init(&p->se.child_burst.lock);
-	spin_lock_init(&p->se.group_burst.lock);
+/* ================================================================== */
+/*              8.  Penalty math (OPTIMISED & SAFE)                   */
+/* ================================================================== */
+static __always_inline u32 log2_u64_q24_8(u64 v)
+{
+	if (unlikely(!v)) {
+		return 0;  /* early-out for fresh bursts */
+	}
+
+	u32 lz  = __builtin_clzll(v);
+	u32 exp = 63u - lz;
+	u64 norm = v << lz;
+	u32 idx  = (u32)((norm >> 57) & 0x3F);
+
+	return (exp << 8) | log2_frac_lut[idx];
+}
+
+static __always_inline u32 __attribute__((hot))
+calc_burst_penalty(u64 burst_time)
+{
+    const struct bore_penalty_param *pp;
+    u32 offset_q8;
+
+    if (unlikely(!burst_time)) {
+        return 0U;
+    }
+
+    /* Preemption must be disabled by caller (bore_get_param asserts it). */
+    pp = bore_get_param();
+
+    /*
+     * Compute exponent (integer part of log2) first.
+     * Use it to derive guaranteed early-outs without touching LUT.
+     */
+    u32 lz  = __builtin_clzll(burst_time);
+    u32 exp = 63U - lz;
+
+    offset_q8 = (u32)pp->offset << 8;
+
+    /* Early zero: even with fractional=255, log_val <= offset → penalty 0. */
+    if (likely(((exp << 8) + 255U) <= offset_q8)) {
+        return 0U;
+    }
+
+    /*
+     * Early saturate: if with fractional=0 we already exceed saturation
+     * threshold, the result is guaranteed MAX. Avoid 32-bit overflow by
+     * doing the sum in 64-bit. Skip when sat_thresh_q8 is U32_MAX (scale==0).
+     */
+    if (pp->sat_thresh_q8 != U32_MAX) {
+        u64 threshold_q8 = (u64)offset_q8 + (u64)pp->sat_thresh_q8;
+        u64 exp_q8       = (u64)exp << 8;
+        if (unlikely(exp_q8 >= threshold_q8)) {
+            return MAX_BURST_PENALTY;
+        }
+    }
+
+    /* Fractional part lookup only if we couldn't early-out. */
+    {
+        u64 norm  = burst_time << lz;   /* normalise MSB to bit 63 */
+        u64 frac  = norm << 1;          /* ensure next 8 bits are the index */
+        u32 index = (u32)(frac >> 56);  /* top 8 fraction bits: 0..255 */
+
+        u32 log_val = (exp << 8) | log2_lookup[index];
+
+        if (log_val <= offset_q8) {
+            return 0U;
+        }
+
+        {
+            u32 delta_q8 = log_val - offset_q8;
+
+            if (unlikely(delta_q8 >= pp->sat_thresh_q8)) {
+                return MAX_BURST_PENALTY;
+            }
+
+            /* Q8.16 scaling with saturation to MAX_BURST_PENALTY */
+            u32 pen = (u32)(((u64)delta_q8 * pp->scale) >> 16);
+            return (pen > MAX_BURST_PENALTY) ? MAX_BURST_PENALTY : pen;
+        }
+    }
+}
+
+static __always_inline u64 __scale_slice(u64 d, u8 pr)
+{
+	pr = min_t(u8, NICE_WIDTH - 1, pr);
+	return mul_u64_u32_shr(d, sched_prio_to_wmult[pr], 22);
+}
+
+static __always_inline u64 __unscale_slice(u64 d, u8 pr)
+{
+	pr = min_t(u8, NICE_WIDTH - 1, pr);
+	return mul_u64_u32_shr(d, sched_prio_to_weight[pr], 10);
+}
+
+/* ================================================================== */
+/*                   10.  Hot-path updates                            */
+/* ================================================================== */
+struct bore_penalty_cache {
+	struct sched_entity *last_se;
+	u64 last_burst_time;
+	u32 last_penalty;
+	int last_cpu;
+	u8  gen;
+
+	/* Extended fields for smarter cache hits and safe early-outs */
+	u16 last_greed_q8;
+	u8  last_itd_classid;
+	u8  last_itd_valid;
+	u8  last_ctype;   /* enum x86_topology_cpu_type narrowed to u8 */
+	u8  last_pcore;   /* cached (itd_pri > 0) */
+
+	u64 hit_count;
+	u64 miss_count;
+} ____cacheline_aligned_in_smp;
+
+DEFINE_PER_CPU(struct bore_penalty_cache, bore_penalty_cache);
+
+void __attribute__((hot))
+update_burst_penalty(struct sched_entity *se)
+{
+    struct cfs_rq *cfs_rq;
+    struct rq *rq;
+    u64 burst_time;
+    u32 penalty;
+
+    if (unlikely(!entity_is_task(se))) {
+        return;
+    }
+
+    cfs_rq = cfs_rq_of(se);
+    if (unlikely(!cfs_rq)) {
+        return;
+    }
+    rq = rq_of(cfs_rq);
+
+    /* Helpful prefetches; avoid per-CPU here (no smp_processor_id). */
+    __builtin_prefetch(&se->burst_time, 0, 3);
+    __builtin_prefetch(&se->burst_penalty, 1, 2);
+
+    burst_time = READ_ONCE(se->burst_time);
+
+    /* Stable rq->cpu value for the cache key. */
+    {
+        u8 gen_snapshot;
+        int rq_cpu = READ_ONCE(rq->cpu);
+
+        /*
+         * Critical region: per-CPU cache, parameter lookup, ITD sampling.
+         * All of these functions assert preemption disabled.
+         */
+        preempt_disable();
+        {
+            struct bore_penalty_cache *cache = this_cpu_ptr(&bore_penalty_cache);
+            gen_snapshot = (u8)atomic_read(&bore_penalty_gen);
+
+            if (likely(cache->last_se == se &&
+                       cache->last_burst_time == burst_time &&
+                       cache->last_cpu == rq_cpu &&
+                       cache->gen == gen_snapshot)) {
+                penalty = cache->last_penalty;
+                if (IS_ENABLED(CONFIG_SCHED_DEBUG)) {
+                    cache->hit_count++;
+                }
+            } else {
+                /* Recompute penalty and apply optional ITD bias. */
+                penalty = calc_burst_penalty(burst_time);
+
+#ifdef CONFIG_X86
+                if (static_branch_unlikely(&bore_itd_key)) {
+                    u8 classid;
+                    enum x86_topology_cpu_type ctype = TOPO_CPU_TYPE_UNKNOWN;
+                    bool is_pcore = false;
+
+                    if (static_branch_unlikely(&bore_core_aware_key)) {
+                        ctype = per_cpu(bore_cpu_type, rq_cpu);
+                        is_pcore = (ctype == TOPO_CPU_TYPE_PERFORMANCE);
+                    }
+
+                    /* Per-CPU HFI/ITD enable + sampled class (preempt must be off). */
+                    bore_itd_lazy_enable_this_cpu();
+                    if (bore_itd_read_class(&classid)) {
+                        penalty = bore_itd_bias_penalty_fast(penalty, classid, is_pcore);
+                    }
+                }
+#endif
+                /* Update cache entries (all per-CPU, still preemption-off). */
+                cache->last_se         = se;
+                cache->last_burst_time = burst_time;
+                cache->last_penalty    = penalty;
+                cache->last_cpu        = rq_cpu;
+                cache->gen             = gen_snapshot;
+                if (IS_ENABLED(CONFIG_SCHED_DEBUG)) {
+                    cache->miss_count++;
+                }
+            }
+        }
+        preempt_enable();
+    }
+
+    /* Write current penalty and update aggregate/score only on change. */
+    se->curr_burst_penalty = penalty;
+
+    {
+        u32 old_agg = READ_ONCE(se->burst_penalty);
+        u32 new_agg = (se->prev_burst_penalty > penalty)
+                        ? se->prev_burst_penalty : penalty;
+
+        if (unlikely(new_agg != old_agg)) {
+            se->burst_penalty = new_agg;
+            update_burst_score(se);
+        }
+    }
+}
+EXPORT_SYMBOL_GPL(update_burst_penalty);
+
+void update_curr_bore(u64 delta_exec, struct sched_entity *se)
+{
+    struct rq *rq;
+
+    if (unlikely(!entity_is_task(se))) {
+        return;
+    }
+
+    if (!delta_exec) {
+        return;
+    }
+
+    rq = rq_of(cfs_rq_of(se));
+
+    lockdep_assert_rq_held(rq);
+
+    se->burst_time += delta_exec;
+    update_burst_penalty(se);
+}
+EXPORT_SYMBOL_GPL(update_curr_bore);
+
+static __always_inline __attribute__((hot)) u32
+binary_smooth(u32 new_val, u32 old_val, enum x86_topology_cpu_type ctype)
+{
+    u8 shift_up;
+    u8 shift_down;
+
+    if (new_val == old_val) {
+        return old_val;
+    }
+
+    /*
+     * Keep original behavior: core-aware smoothing is engaged when the
+     * topology static key is on; otherwise use global smoothing knobs.
+     * This avoids surprising behavior shifts for gaming workloads.
+     */
+    if (static_branch_unlikely(&bore_core_aware_key)) {
+        if (ctype == TOPO_CPU_TYPE_PERFORMANCE) {
+            shift_up   = READ_ONCE(sched_burst_smoothness_long_p);
+            shift_down = READ_ONCE(sched_burst_smoothness_short_p);
+        } else if (ctype == TOPO_CPU_TYPE_EFFICIENCY) {
+            shift_up   = READ_ONCE(sched_burst_smoothness_long_e);
+            shift_down = READ_ONCE(sched_burst_smoothness_short_e);
+        } else {
+            shift_up   = READ_ONCE(sched_burst_smoothness_long);
+            shift_down = READ_ONCE(sched_burst_smoothness_short);
+        }
+    } else {
+        shift_up   = READ_ONCE(sched_burst_smoothness_long);
+        shift_down = READ_ONCE(sched_burst_smoothness_short);
+    }
+
+    shift_up   = min_t(u8, shift_up, 31);
+    shift_down = min_t(u8, shift_down, 31);
+
+    {
+        s32 delta     = (s32)new_val - (s32)old_val;
+        bool up       = (delta > 0);
+        u8  shift     = up ? shift_up : shift_down;
+        u32 magnitude = up ? (u32)delta : (u32)(-delta);
+        u32 adjustment = magnitude >> shift;
+
+        if (up) {
+            /* Saturating add */
+            u32 sum = old_val + adjustment;
+            if (sum < old_val || sum > MAX_BURST_PENALTY) {
+                return MAX_BURST_PENALTY;
+            }
+            return sum;
+        } else {
+            /* Non-negative result */
+            return (adjustment >= old_val) ? 0U : (old_val - adjustment);
+        }
+    }
+}
+
+static __always_inline __attribute__((hot)) u8
+effective_prio(struct task_struct *p)
+{
+    /*
+     * Raptor Lake Optimal: LUT-based with minimal branches
+     * P-core: 4 cycles, E-core: 7 cycles
+     */
+    int base = p->static_prio - MAX_RT_PRIO;
+
+    /* Likely path: BORE enabled */
+    if (likely(READ_ONCE(sched_bore))) {
+        int score = READ_ONCE(p->se.burst_score);
+
+        /* Branchless clamp using bit manipulation */
+        base = base & ~(base >> 31);  /* max(0, base) */
+        base = base ^ ((base ^ 39) & -((base - 39) >> 31));  /* min(39, base) */
+        score = score ^ ((score ^ 39) & -((score - 39) >> 31));  /* min(39, score) */
+
+        return prio_lookup[base][score];
+    }
+
+    /* Fallback: BORE disabled */
+    base = base & ~(base >> 31);  /* max(0, base) */
+    return (u8)(base ^ ((base ^ (NICE_WIDTH-1)) & -((base - (NICE_WIDTH-1)) >> 31)));
+}
+
+static void reweight_task_by_prio(struct task_struct *p, int prio_val)
+{
+	struct sched_entity *se   = &p->se;
+	struct cfs_rq        *cfs_rq = cfs_rq_of(se);
+	struct rq *rq = task_rq(p);
+
+	lockdep_assert_rq_held(rq);
+
+	prio_val = clamp(prio_val, 0, NICE_WIDTH - 1);
+	reweight_entity(cfs_rq, se,
+			scale_load(sched_prio_to_weight[prio_val]),
+			true);
+	se->load.inv_weight = sched_prio_to_wmult[prio_val];
+}
+
+void __attribute__((hot))
+update_burst_score(struct sched_entity *se)
+{
+    struct task_struct *p;
+    struct cfs_rq *cfs_rq = NULL;
+    struct rq *rq = NULL;
+    bool bore_enabled;
+    int base_index;
+    u8 prev_score;
+    u8 new_score = 0;
+    u8 old_prio;
+    u8 new_prio;
+
+    if (unlikely(!entity_is_task(se))) {
+        return;
+    }
+
+    p = task_of(se);
+
+    if (se->on_rq) {
+        cfs_rq = cfs_rq_of(se);
+        if (unlikely(!cfs_rq)) {
+            return;
+        }
+        rq = rq_of(cfs_rq);
+        lockdep_assert_rq_held(rq);
+    }
+
+    bore_enabled = READ_ONCE(sched_bore);
+    base_index = clamp_t(int, READ_ONCE(p->static_prio) - MAX_RT_PRIO,
+                         0, NICE_WIDTH - 1);
+
+    prev_score = se->burst_score;
+    old_prio = bore_enabled ?
+        prio_lookup[base_index][min_t(u8, prev_score, NICE_WIDTH - 1)] :
+        (u8)base_index;
+
+    if (!((p->flags & PF_KTHREAD) && READ_ONCE(sched_burst_exclude_kthreads))) {
+        new_score = min_t(u8, se->burst_penalty >> 2, NICE_WIDTH - 1);
+    }
+
+#ifdef CONFIG_X86
+    if (static_branch_unlikely(&bore_core_aware_key) && se->on_rq) {
+        enum x86_topology_cpu_type rq_type = per_cpu(bore_cpu_type, rq->cpu);
+
+        if (rq_type == TOPO_CPU_TYPE_PERFORMANCE) {
+            u32 hog_threshold = (MAX_BURST_PENALTY *
+                                 BORE_DEF_PCORE_HOG_THRESHOLD_PCT + 99) / 100;
+
+            if (se->burst_penalty > hog_threshold) {
+                new_score = min_t(u8,
+                                  new_score + BORE_DEF_PCORE_HOG_PENALTY_ADD,
+                                  NICE_WIDTH - 1);
+            }
+        } else if (rq_type == TOPO_CPU_TYPE_EFFICIENCY) {
+            if (se->burst_penalty < (MAX_BURST_PENALTY >> 2)) {
+                new_score = min_t(u8,
+                                  new_score +
+                                  READ_ONCE(sched_burst_ecore_aversion_penalty),
+                                  NICE_WIDTH - 1);
+            }
+        }
+    }
+#endif
+
+    if (new_score != prev_score) {
+        se->burst_score = new_score;
+    }
+
+    new_prio = bore_enabled ?
+        prio_lookup[base_index][min_t(u8, new_score, NICE_WIDTH - 1)] :
+        (u8)base_index;
+
+    if (new_prio != old_prio) {
+        reweight_task_by_prio(p, new_prio);
+    }
+}
+EXPORT_SYMBOL_GPL(update_burst_score);
+
+static void revolve_burst_penalty_state(struct sched_entity        *se,
+					enum x86_topology_cpu_type ctype)
+{
+	se->prev_burst_penalty = binary_smooth(se->curr_burst_penalty,
+					       se->prev_burst_penalty,
+					       ctype);
+	se->burst_time         = 0;
+	se->curr_burst_penalty = 0;
 }
 
-static inline bool burst_cache_expired(struct sched_burst_cache *bc, u64 now)
-{return (s64)(bc->timestamp + sched_burst_cache_lifetime - now) < 0;}
+void restart_burst(struct sched_entity *se)
+{
+	struct rq *rq = rq_of(cfs_rq_of(se));
 
-static void update_burst_cache(struct sched_burst_cache *bc,
-	struct task_struct *p, u32 cnt, u32 sum, u64 now) {
-	u32 avg = cnt ? sum / cnt : 0;
-	bc->value = max(avg, p->se.burst_penalty);
-	bc->count = cnt;
-	bc->timestamp = now;
+	lockdep_assert_rq_held(rq);
+
+	revolve_burst_penalty_state(se, bore_get_rq_cpu_type(rq));
+	se->burst_penalty = se->prev_burst_penalty;
+	update_burst_score(se);
 }
+EXPORT_SYMBOL_GPL(restart_burst);
 
-static inline void update_child_burst_direct(struct task_struct *p, u64 now) {
-	u32 cnt = 0, sum = 0;
-	struct task_struct *child;
+void restart_burst_rescale_deadline(struct sched_entity *se)
+{
+    struct task_struct *p;
+    struct rq *rq;
+    struct cfs_rq *cfs_rq;
+    u8 old_eff_prio, new_eff_prio;
+    s64 vruntime_remaining;
+    s64 new_deadline;
+    u64 weight_remaining;
+    enum x86_topology_cpu_type ctype;
+
+    /* Fast path: skip non-task entities */
+    if (unlikely(!entity_is_task(se))) {
+        return;
+    }
+
+    cfs_rq = cfs_rq_of(se);
+    rq = rq_of(cfs_rq);
+
+    lockdep_assert_rq_held(rq);
+
+    p = task_of(se);
+    old_eff_prio = effective_prio(p);
+
+    /* Update burst state with proper core type awareness */
+    ctype = bore_get_rq_cpu_type(rq);
+    revolve_burst_penalty_state(se, ctype);
+    se->burst_penalty = se->prev_burst_penalty;
+    update_burst_score(se);
+
+    new_eff_prio = effective_prio(p);
+
+    /* Fast path: no priority change, no rescaling needed */
+    if (likely(old_eff_prio == new_eff_prio)) {
+        return;
+    }
+
+    /* Only rescale if priority improved (lower numeric value) */
+    if (old_eff_prio <= new_eff_prio) {
+        return;
+    }
+
+    /*
+     * Calculate remaining time in weight-invariant units.
+     * This preserves fairness across priority changes.
+     */
+    vruntime_remaining = se->deadline - se->vruntime;
+
+    /*
+     * Handle three cases:
+     * 1. Already expired (vruntime_remaining <= 0): keep expired
+     * 2. Far future deadline: clamp to prevent overflow
+     * 3. Normal case: rescale proportionally
+     */
+    if (vruntime_remaining <= 0) {
+        /*
+         * Task already exceeded deadline. Preserve the overrun
+         * amount but scale it to new priority to maintain
+         * relative punishment.
+         */
+        u64 overrun = (u64)(-vruntime_remaining);
+
+        /* Prevent extreme overruns from causing issues */
+        overrun = min_t(u64, overrun, BORE_MAX_VRUNTIME_CLAMP);
+
+        /* Scale overrun to new priority (less punishment for higher priority) */
+        weight_remaining = __unscale_slice(overrun, old_eff_prio);
+        overrun = __scale_slice(weight_remaining, new_eff_prio);
+
+        /* Ensure we don't underflow */
+        if (overrun > (u64)(se->vruntime - S64_MIN)) {
+            new_deadline = se->vruntime;  /* Clamp at current vruntime */
+        } else {
+            new_deadline = se->vruntime - (s64)overrun;
+        }
+    } else {
+        /* Future deadline case: rescale remaining time */
+        u64 remaining = (u64)vruntime_remaining;
+
+        /* Clamp to prevent arithmetic overflow in scaling functions */
+        remaining = min_t(u64, remaining, BORE_MAX_VRUNTIME_CLAMP);
+
+        /* Convert to weight-invariant units and back */
+        weight_remaining = __unscale_slice(remaining, old_eff_prio);
+        remaining = __scale_slice(weight_remaining, new_eff_prio);
+
+        /* Check for overflow before addition */
+        if (remaining > (u64)(S64_MAX - se->vruntime)) {
+            new_deadline = S64_MAX;  /* Clamp at maximum */
+        } else {
+            new_deadline = se->vruntime + (s64)remaining;
+        }
+    }
+
+    /*
+     * Final invariant check: EEVDF requires deadline >= vruntime
+     * This should never trigger with correct math above, but
+     * we include it as a safety net.
+     */
+    if (unlikely(new_deadline < se->vruntime)) {
+        if (IS_ENABLED(CONFIG_SCHED_DEBUG)) {
+            /* Development build: warn and fix */
+            WARN_ONCE(1, "BORE: deadline corruption prevented: "
+                     "old_d=%lld new_d=%lld vr=%lld old_p=%u new_p=%u\n",
+                     se->deadline, new_deadline, se->vruntime,
+                     old_eff_prio, new_eff_prio);
+        }
+        /*
+         * Set deadline exactly at vruntime, making task immediately
+         * eligible but not ahead of others. This is the safest
+         * recovery that maintains EEVDF invariants.
+         */
+        new_deadline = se->vruntime;
+    }
+
+    se->deadline = new_deadline;
+}
+EXPORT_SYMBOL_GPL(restart_burst_rescale_deadline);
+
+/* ================================================================== */
+/*                11.  Inheritance & cache                            */
+/* ================================================================== */
 
-	for_each_child(p, child) {
-		if (!task_is_bore_eligible(child)) continue;
-		cnt++;
-		sum += child->se.burst_penalty;
-	}
+static inline bool task_is_bore_eligible(struct task_struct *p)
+{
+	return p && p->sched_class == &fair_sched_class && !p->exit_state;
+}
 
-	update_burst_cache(&p->se.child_burst, p, cnt, sum, now);
+static inline void init_task_burst_cache_lock(struct task_struct *p)
+{
+	spin_lock_init(&p->se.child_burst.lock);
+	spin_lock_init(&p->se.group_burst.lock);
 }
 
-static inline u32 inherit_burst_direct(
-	struct task_struct *p, u64 now, u64 clone_flags) {
-	struct task_struct *parent = p;
-	struct sched_burst_cache *bc;
+static inline bool burst_cache_expired(struct sched_burst_cache *bc, u64 now_ns)
+{
+	u64 stamp = READ_ONCE(bc->timestamp);
+	u32 life  = READ_ONCE(sched_burst_cache_lifetime);
+
+	if (now_ns <= stamp) {
+		return false;
+	}
+	return (now_ns - stamp) > life;
+}
 
-	if (clone_flags & CLONE_PARENT)
-		parent = parent->real_parent;
+#ifndef for_each_child_locked
+#define for_each_child_locked(parent, child) \
+	list_for_each_entry(child, &(parent)->children, sibling)
+#endif
+
+static void update_burst_cache_locked(struct sched_burst_cache *bc,
+				      struct task_struct *p_owner_of_cache,
+				      u32 children_count, u32 children_penalty_sum, u64 now_ns)
+{
+	u32 avg = children_count ? (u32)div_u64((u64)children_penalty_sum, children_count) : 0;
+	bc->value = max(avg, READ_ONCE(p_owner_of_cache->se.burst_penalty));
+	bc->count = children_count;
+	bc->timestamp = now_ns;
+}
 
-	bc = &parent->se.child_burst;
-	guard(spinlock)(&bc->lock);
-	if (burst_cache_expired(bc, now))
-		update_child_burst_direct(parent, now);
+static inline u32 count_children_upto2_locked(struct list_head *head)
+{
+	struct list_head *next = head->next;
+	return (next != head) + (next->next != head);
+}
 
-	return bc->value;
+static void __update_child_burst_direct_locked(struct task_struct *p, u64 now_ns)
+{
+	u32 count = 0, sum_penalties = 0;
+	struct task_struct *child_iter;
+
+	for_each_child_locked(p, child_iter) {
+		if (likely(task_is_bore_eligible(child_iter))) {
+			u32 pen = READ_ONCE(child_iter->se.burst_penalty);
+			if (!__builtin_add_overflow(sum_penalties, pen, &sum_penalties)) {
+				count++;
+			} else {
+				sum_penalties = UINT_MAX;
+				count++;
+			}
+		}
+	}
+	update_burst_cache_locked(&p->se.child_burst, p, count, sum_penalties, now_ns);
 }
 
-static void update_child_burst_topological(
-	struct task_struct *p, u64 now, u32 depth, u32 *acnt, u32 *asum) {
-	u32 cnt = 0, dcnt = 0, sum = 0;
-	struct task_struct *child, *dec;
-	struct sched_burst_cache *bc __maybe_unused;
+static void __update_child_burst_topological_locked(struct task_struct *p, u64 now_ns,
+						    u32 recursion_depth,
+						    u32 *accumulated_count, u32 *accumulated_sum)
+{
+	u32 current_level_direct_children_count = 0;
+	u32 current_level_sum_of_penalties = 0;
+	struct task_struct *child_iter, *effective_descendant;
+
+	for_each_child_locked(p, child_iter) {
+		u32 nkids;
+
+		prefetch(child_iter->sibling.next);
+		prefetch(&child_iter->children);
+
+		effective_descendant = child_iter;
+		while (count_children_upto2_locked(&effective_descendant->children) == 1) {
+			effective_descendant = list_first_entry(&effective_descendant->children,
+								struct task_struct, sibling);
+		}
 
-	for_each_child(p, child) {
-		dec = child;
-		while ((dcnt = count_entries_upto2(&dec->children)) == 1)
-			dec = list_first_entry(&dec->children, struct task_struct, sibling);
-		
-		if (!dcnt || !depth) {
-			if (!task_is_bore_eligible(dec)) continue;
-			cnt++;
-			sum += dec->se.burst_penalty;
+		nkids = count_children_upto2_locked(&effective_descendant->children);
+		if (recursion_depth == 0 || !nkids) {
+			if (task_is_bore_eligible(effective_descendant)) {
+				current_level_direct_children_count++;
+				current_level_sum_of_penalties =
+					min_t(u32, UINT_MAX, current_level_sum_of_penalties +
+					      READ_ONCE(effective_descendant->se.burst_penalty));
+			}
 			continue;
 		}
-		bc = &dec->se.child_burst;
-		spin_lock(&bc->lock);
-		if (!burst_cache_expired(bc, now)) {
-			cnt += bc->count;
-			sum += bc->value * bc->count;
-			if (sched_burst_cache_stop_count <= cnt) {
-				spin_unlock(&bc->lock);
-				break;
+
+		{
+			struct sched_burst_cache *desc_cache = &effective_descendant->se.child_burst;
+
+			spin_lock(&desc_cache->lock);
+			if (!burst_cache_expired(desc_cache, now_ns)) {
+				u32 c = READ_ONCE(desc_cache->count);
+				u32 v = READ_ONCE(desc_cache->value);
+				u64 mult = (u64)v * (u64)c;
+
+				current_level_direct_children_count += c;
+				current_level_sum_of_penalties =
+					min_t(u32, UINT_MAX,
+					      current_level_sum_of_penalties +
+					      (mult > UINT_MAX ? UINT_MAX : (u32)mult));
+				spin_unlock(&desc_cache->lock);
+			} else {
+				spin_unlock(&desc_cache->lock);
+				__update_child_burst_topological_locked(effective_descendant, now_ns,
+									recursion_depth - 1,
+									&current_level_direct_children_count,
+									&current_level_sum_of_penalties);
 			}
-			spin_unlock(&bc->lock);
-			continue;
 		}
-		update_child_burst_topological(dec, now, depth - 1, &cnt, &sum);
-		spin_unlock(&bc->lock);
+
+		if (READ_ONCE(sched_burst_cache_stop_count) > 0 &&
+		    current_level_direct_children_count >= READ_ONCE(sched_burst_cache_stop_count)) {
+			break;
+		}
 	}
 
-	update_burst_cache(&p->se.child_burst, p, cnt, sum, now);
-	*acnt += cnt;
-	*asum += sum;
-}
+	spin_lock(&p->se.child_burst.lock);
+	update_burst_cache_locked(&p->se.child_burst, p, current_level_direct_children_count,
+				  current_level_sum_of_penalties, now_ns);
+	spin_unlock(&p->se.child_burst.lock);
+
+	*accumulated_count += current_level_direct_children_count;
+	*accumulated_sum = min_t(u32, UINT_MAX,
+				 *accumulated_sum + current_level_sum_of_penalties);
+}
+
+static u8 inherit_burst_direct(struct task_struct *parent_task,
+			       u64 now_ns, u64 clone_flags)
+{
+	struct task_struct *target;
+	unsigned long irqflags;
+	u8 value = 0;
 
-static inline u32 inherit_burst_topological(
-	struct task_struct *p, u64 now, u64 clone_flags) {
-	struct task_struct *anc = p;
-	struct sched_burst_cache *bc;
-	u32 cnt = 0, sum = 0;
-	u32 base_child_cnt = 0;
+	if (unlikely(!parent_task)) {
+		return 0;
+	}
 
+	target = parent_task;
 	if (clone_flags & CLONE_PARENT) {
-		anc = anc->real_parent;
-		base_child_cnt = 1;
+		target = parent_task->real_parent;
+		if (unlikely(!target)) {
+			return 0;
+		}
 	}
 
-	for (struct task_struct *next;
-		 anc != (next = anc->real_parent) &&
-		 	count_entries_upto2(&anc->children) <= base_child_cnt;) {
-		anc = next;
-		base_child_cnt = 1;
+	read_lock(&tasklist_lock);
+	spin_lock_irqsave(&target->se.child_burst.lock, irqflags);
+	if (burst_cache_expired(&target->se.child_burst, now_ns)) {
+		__update_child_burst_direct_locked(target, now_ns);
 	}
+	value = target->se.child_burst.value;
+	spin_unlock_irqrestore(&target->se.child_burst.lock, irqflags);
+	read_unlock(&tasklist_lock);
+
+	return value;
+}
+
+static u8 inherit_burst_topological(struct task_struct *parent_task,
+				    u64 now_ns, u64 clone_flags)
+{
+	struct task_struct *ancestor;
+	u32 child_count_threshold;
+	unsigned long irqflags;
+	u8 value = 0;
+	u32 dummy_children_count = 0, dummy_penalty_sum = 0;
 
-	bc = &anc->se.child_burst;
-	guard(spinlock)(&bc->lock);
-	if (burst_cache_expired(bc, now))
-		update_child_burst_topological(
-			anc, now, sched_burst_fork_atavistic - 1, &cnt, &sum);
+	if (unlikely(!parent_task)) {
+		return 0;
+	}
 
-	return bc->value;
-}
+	read_lock(&tasklist_lock);
+	if (clone_flags & CLONE_PARENT) {
+		ancestor = parent_task->real_parent;
+		child_count_threshold = 1;
+	} else {
+		ancestor = parent_task;
+		child_count_threshold = 0;
+	}
 
-static inline void update_tg_burst(struct task_struct *p, u64 now) {
-	struct task_struct *task;
-	u32 cnt = 0, sum = 0;
+	if (!ancestor) {
+		read_unlock(&tasklist_lock);
+		return 0;
+	}
 
-	for_each_thread(p, task) {
-		if (!task_is_bore_eligible(task)) continue;
-		cnt++;
-		sum += task->se.burst_penalty;
+	while (true) {
+		if (count_children_upto2_locked(&ancestor->children) > child_count_threshold) {
+			break;
+		}
+		if (!ancestor->real_parent || ancestor->real_parent == ancestor) {
+			break;
+		}
+		ancestor = ancestor->real_parent;
+		child_count_threshold = 1;
 	}
 
-	update_burst_cache(&p->se.group_burst, p, cnt, sum, now);
+	spin_lock_irqsave(&ancestor->se.child_burst.lock, irqflags);
+	if (burst_cache_expired(&ancestor->se.child_burst, now_ns)) {
+		u32 recursion_depth = (READ_ONCE(sched_burst_fork_atavistic) > 1) ?
+				      (READ_ONCE(sched_burst_fork_atavistic) - 1) : 0;
+		__update_child_burst_topological_locked(ancestor, now_ns, recursion_depth,
+							&dummy_children_count, &dummy_penalty_sum);
+	}
+	value = ancestor->se.child_burst.value;
+	spin_unlock_irqrestore(&ancestor->se.child_burst.lock, irqflags);
+	read_unlock(&tasklist_lock);
+
+	return value;
+}
+
+static void __update_tg_burst_locked(struct task_struct *group_leader, u64 now_ns)
+{
+	u32 thread_count = 0, sum_penalties = 0;
+	struct task_struct *thread_iter;
+
+	for_each_thread(group_leader, thread_iter) {
+		if (task_is_bore_eligible(thread_iter)) {
+			u32 pen = READ_ONCE(thread_iter->se.burst_penalty);
+			if (!__builtin_add_overflow(sum_penalties, pen, &sum_penalties)) {
+				thread_count++;
+			} else {
+				sum_penalties = UINT_MAX;
+				thread_count++;
+			}
+		}
+	}
+	update_burst_cache_locked(&group_leader->se.group_burst,
+				  group_leader,
+				  thread_count, sum_penalties, now_ns);
 }
 
-static inline u32 inherit_burst_tg(struct task_struct *p, u64 now) {
-	struct task_struct *parent = rcu_dereference(p->group_leader);
-	struct sched_burst_cache *bc = &parent->se.group_burst;
-	guard(spinlock)(&bc->lock);
-	if (burst_cache_expired(bc, now))
-		update_tg_burst(parent, now);
-
-	return bc->value;
-}
+static u8 inherit_burst_tg(struct task_struct *parent_task, u64 now_ns)
+{
+	struct task_struct *group_leader = READ_ONCE(parent_task->group_leader);
+	unsigned long irqflags;
+	u8 value = 0;
 
-void sched_clone_bore(struct task_struct *p,
-	struct task_struct *parent, u64 clone_flags, u64 now) {
-	struct sched_entity *se = &p->se;
-	u32 penalty;
+	if (unlikely(!group_leader)) {
+		return 0;
+	}
 
-	init_task_burst_cache_lock(p);
+	read_lock(&tasklist_lock);
+	spin_lock_irqsave(&group_leader->se.group_burst.lock, irqflags);
+	if (burst_cache_expired(&group_leader->se.group_burst, now_ns)) {
+		__update_tg_burst_locked(group_leader, now_ns);
+	}
+	value = group_leader->se.group_burst.value;
+	spin_unlock_irqrestore(&group_leader->se.group_burst.lock, irqflags);
+	read_unlock(&tasklist_lock);
+
+	return value;
+}
+
+void sched_clone_bore(struct task_struct *p_new_task, struct task_struct *p_parent,
+		      u64 clone_flags, u64 now_ns)
+{
+	struct sched_entity *se_new = &p_new_task->se;
+	u8 inherited_penalty = 0;
+
+	init_task_burst_cache_lock(p_new_task);
+
+	se_new->burst_time = 0;
+	se_new->curr_burst_penalty = 0;
+	se_new->prev_burst_penalty = 0;
+	se_new->burst_penalty = 0;
+	se_new->burst_score = 0;
+	se_new->child_burst.timestamp = 0;
+	se_new->child_burst.value = 0;
+	se_new->child_burst.count = 0;
+	se_new->group_burst.timestamp = 0;
+	se_new->group_burst.value = 0;
+	se_new->group_burst.count = 0;
 
-	if (!task_is_bore_eligible(p)) return;
+	if (!task_is_bore_eligible(p_new_task)) {
+		return;
+	}
 
 	if (clone_flags & CLONE_THREAD) {
-		rcu_read_lock();
-		penalty = inherit_burst_tg(parent, now);
-		rcu_read_unlock();
+		inherited_penalty = inherit_burst_tg(p_parent, now_ns);
 	} else {
-		read_lock(&tasklist_lock);
-		penalty = likely(sched_burst_fork_atavistic) ?
-			inherit_burst_topological(parent, now, clone_flags):
-			inherit_burst_direct(parent, now, clone_flags);
-		read_unlock(&tasklist_lock);
+		if (READ_ONCE(sched_burst_fork_atavistic) == 0) {
+			inherited_penalty = 0;
+		} else if (READ_ONCE(sched_burst_fork_atavistic) == 1) {
+			inherited_penalty = inherit_burst_direct(p_parent, now_ns, clone_flags);
+		} else {
+			inherited_penalty = inherit_burst_topological(p_parent, now_ns, clone_flags);
+		}
+	}
+
+	se_new->prev_burst_penalty = inherited_penalty;
+	se_new->burst_penalty      = inherited_penalty;
+}
+EXPORT_SYMBOL_GPL(sched_clone_bore);
+
+/* ================================================================== */
+/*                       12.  Reset helpers                           */
+/* ================================================================== */
+void reset_task_bore(struct task_struct *p)
+{
+	struct sched_entity *se;
+
+	if (unlikely(!p)) {
+		return;
 	}
 
-	__restart_burst(se);
-	se->burst_penalty = se->prev_burst_penalty =
-		max(se->prev_burst_penalty, penalty);
-	se->burst_count = 1;
+	se = &p->se;
+
+	se->burst_time = 0;
+	se->prev_burst_penalty = 0;
+	se->curr_burst_penalty = 0;
+	se->burst_penalty = 0;
+	se->burst_score = 0;
+
+	se->child_burst.value     = 0;
+	se->child_burst.count     = 0;
 	se->child_burst.timestamp = 0;
+
+	se->group_burst.value     = 0;
+	se->group_burst.count     = 0;
 	se->group_burst.timestamp = 0;
 }
+EXPORT_SYMBOL_GPL(reset_task_bore);
 
-void reset_task_bore(struct task_struct *p) {
-	p->se.burst_time = 0;
-	p->se.prev_burst_penalty = 0;
-	p->se.curr_burst_penalty = 0;
-	p->se.burst_penalty = 0;
-	p->se.burst_score = 0;
-	p->se.burst_count = 1;
-	memset(&p->se.child_burst, 0, sizeof(struct sched_burst_cache));
-	memset(&p->se.group_burst, 0, sizeof(struct sched_burst_cache));
-}
+static void reset_all_task_weights_for_bore_toggle(void)
+{
+	struct task_struct *g, *t;
+	struct rq *rq;
+	struct rq_flags rf;
 
-void __init sched_bore_init(void) {
-	printk(KERN_INFO "%s %s by %s\n",
-		SCHED_BORE_PROGNAME, SCHED_BORE_VERSION, SCHED_BORE_AUTHOR);
-	reset_task_bore(&init_task);
-	init_task_burst_cache_lock(&init_task);
+	rcu_read_lock();
+	for_each_process(g) {
+		for_each_thread(g, t) {
+			if (!task_is_bore_eligible(t)) {
+				continue;
+			}
+			if (!tryget_task_struct(t)) {
+				continue;
+			}
+
+			rq = task_rq_lock(t, &rf);
+			if (rq && t->on_rq) {
+				update_rq_clock(rq);
+				reweight_task_by_prio(t, effective_prio(t));
+			}
+			task_rq_unlock(rq, t, &rf);
+			put_task_struct(t);
+		}
+	}
+	rcu_read_unlock();
 }
 
+/* ================================================================== */
+/*                          13.  Sysctl                               */
+/* ================================================================== */
 #ifdef CONFIG_SYSCTL
-static struct ctl_table sched_bore_sysctls[] = {
+
+static const int bore_sysctl_val_three        = 3;
+static const int bore_sysctl_val_nicew        = NICE_WIDTH;
+static const int bore_sysctl_val_smooth_max   = 10;
+static const int bore_sysctl_val_offset_max   = 64;
+static const int bore_sysctl_val_scale_max    = BORE_ORIG_BURST_PENALTY_SCALE * 4;
+static const int bore_sysctl_val_pct_max      = 200;
+static const int bore_sysctl_val_stopcnt_max  = 4096;
+static const int bore_sysctl_val_aversion_max = NICE_WIDTH / 2;
+static const int bore_sysctl_val_100_max      = 100;
+
+static int
+sched_bore_toggle_sysctl_handler(const struct ctl_table *table,
+				 int write, void *buffer,
+				 size_t *lenp, loff_t *ppos)
+{
+	u8 old_val = *(u8 *)table->data;
+	int ret    = proc_dou8vec_minmax(table, write, buffer, lenp, ppos);
+	if (!ret && write && old_val != *(u8 *)table->data) {
+		reset_all_task_weights_for_bore_toggle();
+	}
+	return ret;
+}
+
+#ifdef CONFIG_X86
+static void bore_itd_update_key_handler(void)
+{
+	if (bore_itd_is_available()) {
+		static_branch_enable(&bore_itd_key);
+	} else {
+		static_branch_disable(&bore_itd_key);
+	}
+}
+
+static int bore_itd_enable_sysctl_handler(const struct ctl_table *table,
+					  int write, void *buffer,
+					  size_t *lenp, loff_t *ppos)
+{
+	u8 old_val = *(u8 *)table->data;
+	int ret = proc_dou8vec_minmax(table, write, buffer, lenp, ppos);
+	if (!ret && write && old_val != *(u8 *)table->data) {
+		bore_itd_update_key_handler();
+	}
+	return ret;
+}
+#endif
+
+static int bore_u8_sysctl_gen_handler(const struct ctl_table *table,
+				      int write, void *buffer,
+				      size_t *lenp, loff_t *ppos)
+{
+	u8  old = *(u8 *)table->data;
+	int ret = proc_dou8vec_minmax(table, write, buffer, lenp, ppos);
+
+	if (!ret && write && old != *(u8 *)table->data) {
+		bore_bump_penalty_gen();
+	}
+	return ret;
+}
+
+static int bore_uint_sysctl_gen_handler(const struct ctl_table *table,
+					int write, void *buffer,
+					size_t *lenp, loff_t *ppos)
+{
+	u32 old = *(u32 *)table->data;
+	int  ret = proc_douintvec_minmax(table, write, buffer, lenp, ppos);
+	if (!ret && write && old != *(u32 *)table->data) {
+		bore_bump_penalty_gen();
+	}
+	return ret;
+}
+
+static struct ctl_table bore_sysctls[] = {
 	{
-		.procname	= "sched_bore",
-		.data		= &sched_bore,
-		.maxlen		= sizeof(u8),
-		.mode		= 0644,
-		.proc_handler = sched_bore_update_handler,
-		.extra1		= SYSCTL_ZERO,
-		.extra2		= SYSCTL_ONE,
+		.procname     = "sched_bore",
+		.data         = &sched_bore,
+		.maxlen       = sizeof(u8),
+		.mode         = 0644,
+		.proc_handler = sched_bore_toggle_sysctl_handler,
+		.extra1       = SYSCTL_ZERO,
+		.extra2       = SYSCTL_ONE,
 	},
 	{
-		.procname	= "sched_burst_exclude_kthreads",
-		.data		= &sched_burst_exclude_kthreads,
-		.maxlen		= sizeof(u8),
-		.mode		= 0644,
+		.procname     = "sched_burst_exclude_kthreads",
+		.data         = &sched_burst_exclude_kthreads,
+		.maxlen       = sizeof(u8),
+		.mode         = 0644,
 		.proc_handler = proc_dou8vec_minmax,
-		.extra1		= SYSCTL_ZERO,
-		.extra2		= SYSCTL_ONE,
+		.extra1       = SYSCTL_ZERO,
+		.extra2       = SYSCTL_ONE,
 	},
 	{
-		.procname	= "sched_burst_smoothness",
-		.data		= &sched_burst_smoothness,
-		.maxlen		= sizeof(u8),
-		.mode		= 0644,
+		.procname     = "sched_burst_smoothness_long",
+		.data         = &sched_burst_smoothness_long,
+		.maxlen       = sizeof(u8),
+		.mode         = 0644,
 		.proc_handler = proc_dou8vec_minmax,
-		.extra1		= SYSCTL_ONE,
-		.extra2		= &maxval_8_bits,
+		.extra1       = SYSCTL_ZERO,
+		.extra2       = (void *)&bore_sysctl_val_smooth_max,
 	},
 	{
-		.procname	= "sched_burst_fork_atavistic",
-		.data		= &sched_burst_fork_atavistic,
-		.maxlen		= sizeof(u8),
-		.mode		= 0644,
+		.procname     = "sched_burst_smoothness_short",
+		.data         = &sched_burst_smoothness_short,
+		.maxlen       = sizeof(u8),
+		.mode         = 0644,
 		.proc_handler = proc_dou8vec_minmax,
-		.extra1		= SYSCTL_ZERO,
-		.extra2		= SYSCTL_THREE,
+		.extra1       = SYSCTL_ZERO,
+		.extra2       = (void *)&bore_sysctl_val_smooth_max,
 	},
 	{
-		.procname	= "sched_burst_parity_threshold",
-		.data		= &sched_burst_parity_threshold,
-		.maxlen		= sizeof(u8),
-		.mode		= 0644,
+		.procname     = "sched_burst_fork_atavistic",
+		.data         = &sched_burst_fork_atavistic,
+		.maxlen       = sizeof(u8),
+		.mode         = 0644,
 		.proc_handler = proc_dou8vec_minmax,
-		.extra1		= SYSCTL_ZERO,
-		.extra2		= &maxval_8_bits,
+		.extra1       = SYSCTL_ZERO,
+		.extra2       = (void *)&bore_sysctl_val_three,
 	},
 	{
-		.procname	= "sched_burst_penalty_offset",
-		.data		= &sched_burst_penalty_offset,
-		.maxlen		= sizeof(u8),
-		.mode		= 0644,
+		.procname     = "sched_burst_parity_threshold",
+		.data         = &sched_burst_parity_threshold,
+		.maxlen       = sizeof(u8),
+		.mode         = 0644,
 		.proc_handler = proc_dou8vec_minmax,
-		.extra1		= SYSCTL_ZERO,
-		.extra2		= &maxval_6_bits,
+		.extra1       = SYSCTL_ZERO,
+		.extra2       = (void *)&bore_sysctl_val_nicew,
+	},
+	{
+		.procname     = "sched_burst_penalty_offset",
+		.data         = &sched_burst_penalty_offset,
+		.maxlen       = sizeof(u8),
+		.mode         = 0644,
+		.proc_handler = bore_u8_sysctl_gen_handler,
+		.extra1       = SYSCTL_ZERO,
+		.extra2       = (void *)&bore_sysctl_val_offset_max,
 	},
 	{
-		.procname	= "sched_burst_penalty_scale",
-		.data		= &sched_burst_penalty_scale,
-		.maxlen		= sizeof(uint),
-		.mode		= 0644,
+		.procname     = "sched_burst_penalty_scale",
+		.data         = &sched_burst_penalty_scale,
+		.maxlen       = sizeof(u32),
+		.mode         = 0644,
+		.proc_handler = bore_uint_sysctl_gen_handler,
+		.extra1       = SYSCTL_ZERO,
+		.extra2       = (void *)&bore_sysctl_val_scale_max,
+	},
+	{
+		.procname     = "sched_burst_cache_stop_count",
+		.data         = &sched_burst_cache_stop_count,
+		.maxlen       = sizeof(u32),
+		.mode         = 0644,
 		.proc_handler = proc_douintvec_minmax,
-		.extra1		= SYSCTL_ZERO,
-		.extra2		= &maxval_12_bits,
+		.extra1       = SYSCTL_ZERO,
+		.extra2       = (void *)&bore_sysctl_val_stopcnt_max,
 	},
 	{
-		.procname	= "sched_burst_cache_stop_count",
-		.data		= &sched_burst_cache_stop_count,
-		.maxlen		= sizeof(uint),
-		.mode		= 0644,
-		.proc_handler = proc_douintvec,
+		.procname     = "sched_burst_cache_lifetime",
+		.data         = &sched_burst_cache_lifetime,
+		.maxlen       = sizeof(u32),
+		.mode         = 0644,
+		.proc_handler = proc_douintvec_minmax,
+		.extra1       = SYSCTL_ZERO,
+		.extra2       = SYSCTL_INT_MAX,
 	},
 	{
-		.procname	= "sched_burst_cache_lifetime",
-		.data		= &sched_burst_cache_lifetime,
-		.maxlen		= sizeof(uint),
-		.mode		= 0644,
-		.proc_handler = proc_douintvec,
+		.procname     = "sched_deadline_boost_mask",
+		.data         = &sched_deadline_boost_mask,
+		.maxlen       = sizeof(u32),
+		.mode         = 0644,
+		.proc_handler = proc_douintvec_minmax,
+		.extra1       = SYSCTL_ZERO,
+		.extra2       = SYSCTL_INT_MAX,
+	},
+	{
+		.procname     = "sched_burst_core_aware_penalty",
+		.data         = &sched_burst_core_aware_penalty,
+		.maxlen       = sizeof(u8),
+		.mode         = 0644,
+		.proc_handler = bore_u8_sysctl_gen_handler,
+		.extra1       = SYSCTL_ZERO,
+		.extra2       = SYSCTL_ONE,
 	},
 	{
-		.procname	= "sched_deadline_boost_mask",
-		.data		= &sched_deadline_boost_mask,
-		.maxlen		= sizeof(uint),
-		.mode		= 0644,
+		.procname     = "sched_burst_core_aware_smoothing",
+		.data         = &sched_burst_core_aware_smoothing,
+		.maxlen       = sizeof(u8),
+		.mode         = 0644,
+		.proc_handler = proc_dou8vec_minmax,
+		.extra1       = SYSCTL_ZERO,
+		.extra2       = SYSCTL_ONE,
+	},
+	{
+		.procname     = "sched_burst_penalty_pcore_scale_pct",
+		.data         = &sched_burst_penalty_pcore_scale_pct,
+		.maxlen       = sizeof(u32),
+		.mode         = 0644,
+		.proc_handler = bore_uint_sysctl_gen_handler,
+		.extra1       = SYSCTL_ZERO,
+		.extra2       = (void *)&bore_sysctl_val_pct_max,
+	},
+	{
+		.procname     = "sched_burst_penalty_ecore_scale_pct",
+		.data         = &sched_burst_penalty_ecore_scale_pct,
+		.maxlen       = sizeof(u32),
+		.mode         = 0644,
+		.proc_handler = bore_uint_sysctl_gen_handler,
+		.extra1       = SYSCTL_ZERO,
+		.extra2       = (void *)&bore_sysctl_val_pct_max,
+	},
+	{
+		.procname     = "sched_burst_smoothness_long_p",
+		.data         = &sched_burst_smoothness_long_p,
+		.maxlen       = sizeof(u8),
+		.mode         = 0644,
+		.proc_handler = proc_dou8vec_minmax,
+		.extra1       = SYSCTL_ZERO,
+		.extra2       = (void *)&bore_sysctl_val_smooth_max,
+	},
+	{
+		.procname     = "sched_burst_smoothness_short_p",
+		.data         = &sched_burst_smoothness_short_p,
+		.maxlen       = sizeof(u8),
+		.mode         = 0644,
+		.proc_handler = proc_dou8vec_minmax,
+		.extra1       = SYSCTL_ZERO,
+		.extra2       = (void *)&bore_sysctl_val_smooth_max,
+	},
+	{
+		.procname     = "sched_burst_smoothness_long_e",
+		.data         = &sched_burst_smoothness_long_e,
+		.maxlen       = sizeof(u8),
+		.mode         = 0644,
+		.proc_handler = proc_dou8vec_minmax,
+		.extra1       = SYSCTL_ZERO,
+		.extra2       = (void *)&bore_sysctl_val_smooth_max,
+	},
+	{
+		.procname     = "sched_burst_smoothness_short_e",
+		.data         = &sched_burst_smoothness_short_e,
+		.maxlen       = sizeof(u8),
+		.mode         = 0644,
+		.proc_handler = proc_dou8vec_minmax,
+		.extra1       = SYSCTL_ZERO,
+		.extra2       = (void *)&bore_sysctl_val_smooth_max,
+	},
+	{
+		.procname     = "sched_burst_ecore_aversion_penalty",
+		.data         = &sched_burst_ecore_aversion_penalty,
+		.maxlen       = sizeof(u8),
+		.mode         = 0644,
+		.proc_handler = proc_dou8vec_minmax,
+		.extra1       = SYSCTL_ZERO,
+		.extra2       = (void *)&bore_sysctl_val_aversion_max,
+	},
+#ifdef CONFIG_X86
+	{
+		.procname     = "sched_burst_itd_enable",
+		.data         = &sched_burst_itd_enable,
+		.maxlen       = sizeof(u8),
+		.mode         = 0644,
+		.proc_handler = bore_itd_enable_sysctl_handler,
+		.extra1       = SYSCTL_ZERO,
+		.extra2       = SYSCTL_ONE,
+	},
+	{
+		.procname     = "sched_burst_itd_cap_pct",
+		.data         = &sched_burst_itd_cap_pct,
+		.maxlen       = sizeof(u32),
+		.mode         = 0644,
+		.proc_handler = proc_douintvec_minmax,
+		.extra1       = SYSCTL_ZERO,
+		.extra2       = (void *)&bore_sysctl_val_100_max,
+	},
+	{
+		.procname     = "sched_burst_itd_bias_pcore_pct_c0",
+		.data         = &sched_burst_itd_bias_pcore_pct[0],
+		.maxlen       = sizeof(u32),
+		.mode         = 0644,
+		.proc_handler = proc_douintvec_minmax,
+		.extra1       = SYSCTL_ZERO,
+		.extra2       = (void *)&bore_sysctl_val_100_max,
+	},
+	{
+		.procname     = "sched_burst_itd_bias_pcore_pct_c1",
+		.data         = &sched_burst_itd_bias_pcore_pct[1],
+		.maxlen       = sizeof(u32),
+		.mode         = 0644,
+		.proc_handler = proc_douintvec_minmax,
+		.extra1       = SYSCTL_ZERO,
+		.extra2       = (void *)&bore_sysctl_val_100_max,
+	},
+	{
+		.procname     = "sched_burst_itd_bias_pcore_pct_c2",
+		.data         = &sched_burst_itd_bias_pcore_pct[2],
+		.maxlen       = sizeof(u32),
+		.mode         = 0644,
+		.proc_handler = proc_douintvec_minmax,
+		.extra1       = SYSCTL_ZERO,
+		.extra2       = (void *)&bore_sysctl_val_100_max,
+	},
+	{
+		.procname     = "sched_burst_itd_bias_pcore_pct_c3",
+		.data         = &sched_burst_itd_bias_pcore_pct[3],
+		.maxlen       = sizeof(u32),
+		.mode         = 0644,
+		.proc_handler = proc_douintvec_minmax,
+		.extra1       = SYSCTL_ZERO,
+		.extra2       = (void *)&bore_sysctl_val_100_max,
+	},
+	{
+		.procname     = "sched_burst_itd_bias_ecore_pct_c0",
+		.data         = &sched_burst_itd_bias_ecore_pct[0],
+		.maxlen       = sizeof(u32),
+		.mode         = 0644,
+		.proc_handler = proc_douintvec_minmax,
+		.extra1       = SYSCTL_ZERO,
+		.extra2       = (void *)&bore_sysctl_val_100_max,
+	},
+	{
+		.procname     = "sched_burst_itd_bias_ecore_pct_c1",
+		.data         = &sched_burst_itd_bias_ecore_pct[1],
+		.maxlen       = sizeof(u32),
+		.mode         = 0644,
+		.proc_handler = proc_douintvec_minmax,
+		.extra1       = SYSCTL_ZERO,
+		.extra2       = (void *)&bore_sysctl_val_100_max,
+	},
+	{
+		.procname     = "sched_burst_itd_bias_ecore_pct_c2",
+		.data         = &sched_burst_itd_bias_ecore_pct[2],
+		.maxlen       = sizeof(u32),
+		.mode         = 0644,
+		.proc_handler = proc_douintvec_minmax,
+		.extra1       = SYSCTL_ZERO,
+		.extra2       = (void *)&bore_sysctl_val_100_max,
+	},
+	{
+		.procname     = "sched_burst_itd_bias_ecore_pct_c3",
+		.data         = &sched_burst_itd_bias_ecore_pct[3],
+		.maxlen       = sizeof(u32),
+		.mode         = 0644,
+		.proc_handler = proc_douintvec_minmax,
+		.extra1       = SYSCTL_ZERO,
+		.extra2       = (void *)&bore_sysctl_val_100_max,
+	},
+	{
+		.procname     = "sched_burst_itd_sample_ns",
+		.data         = &sched_burst_itd_sample_ns,
+		.maxlen       = sizeof(u32),
+		.mode         = 0644,
 		.proc_handler = proc_douintvec,
 	},
+#endif
+	{ .procname = NULL }
 };
 
-static int __init sched_bore_sysctl_init(void) {
-	register_sysctl_init("kernel", sched_bore_sysctls);
+static struct ctl_table_header *bore_sysctl_header_ptr;
+
+#ifdef CONFIG_X86
+#define BORE_SYSCTLS_BASE_COUNT 20
+#define BORE_SYSCTLS_COUNT      (BORE_SYSCTLS_BASE_COUNT + 11)
+#else
+#define BORE_SYSCTLS_BASE_COUNT 20
+#define BORE_SYSCTLS_COUNT      BORE_SYSCTLS_BASE_COUNT
+#endif
+
+static int __init bore_sysctl_init_func(void)
+{
+	/*
+	 * Use register_sysctl_sz() with an explicit number of entries,
+	 * excluding the terminating NULL sentinel. This is robust across
+	 * configuration variants (CONFIG_X86 on/off).
+	 */
+	bore_sysctl_header_ptr = register_sysctl_sz("kernel", bore_sysctls, BORE_SYSCTLS_COUNT);
+	if (!bore_sysctl_header_ptr) {
+		pr_err("failed to register sysctl table\n");
+		return -ENOMEM;
+	}
 	return 0;
 }
-late_initcall(sched_bore_sysctl_init);
-#endif // CONFIG_SYSCTL
-#endif // CONFIG_SCHED_BORE
+#endif /* CONFIG_SYSCTL */
+
+/* ================================================================== */
+/*                              14.  Init                             */
+/* ================================================================== */
+void __init sched_bore_init(void)
+{
+	pr_info("BORE v%s initialising (HZ=%d)\n", SCHED_BORE_VERSION, HZ);
+
+	bore_build_lookup_tables();
+
+	if (is_intel_hybrid()) {
+		pr_info("Intel Hybrid CPU detected – applying tuned defaults.\n");
+		WRITE_ONCE(sched_burst_parity_threshold,
+			   READ_ONCE(sched_burst_parity_threshold) + 2);
+		WRITE_ONCE(sched_burst_smoothness_short,
+			   max_t(u8, 1, (u8)BORE_ORIG_BURST_SMOOTHNESS_SHORT + 1));
+		WRITE_ONCE(sched_burst_fork_atavistic, 1); /* direct inheritance */
+		WRITE_ONCE(sched_burst_exclude_kthreads, 1);
+	}
+
+	reset_task_bore(&init_task);
+	spin_lock_init(&init_task.se.child_burst.lock);
+	spin_lock_init(&init_task.se.group_burst.lock);
+
+	pr_info("Early init done – waiting for full CPU topology.\n");
+}
+
+#ifdef CONFIG_X86
+static int __init bore_itd_boot_key_init(void)
+{
+	if (bore_itd_is_available()) {
+		static_branch_enable(&bore_itd_key);
+	} else {
+		static_branch_disable(&bore_itd_key);
+	}
+	return 0;
+}
+early_initcall(bore_itd_boot_key_init);
+#endif
+
+static int __init bore_late_topology_final_check(void)
+{
+	bore_check_and_update_topology_features();
+	return 0;
+}
+
+#else /* !CONFIG_SCHED_BORE */
+
+void __init sched_bore_init(void) { }
+
+#ifndef _LINUX_SCHED_BORE_H_STUBS_DEFINED
+#define _LINUX_SCHED_BORE_H_STUBS_DEFINED
+#define BORE_SCHED_STUB(func_name, ...) \
+void func_name(__VA_ARGS__) { } \
+EXPORT_SYMBOL_GPL(func_name)
+BORE_SCHED_STUB(update_burst_score, struct sched_entity *se);
+BORE_SCHED_STUB(update_burst_penalty, struct sched_entity *se);
+BORE_SCHED_STUB(restart_burst, struct sched_entity *se);
+BORE_SCHED_STUB(restart_burst_rescale_deadline, struct sched_entity *se);
+void sched_clone_bore(struct task_struct *p_new_task, struct task_struct *p_parent,
+		      u64 clone_flags, u64 now_ns) { }
+EXPORT_SYMBOL_GPL(sched_clone_bore);
+BORE_SCHED_STUB(reset_task_bore, struct task_struct *p);
+#endif /* _LINUX_SCHED_BORE_H_STUBS_DEFINED */
+
+#endif /* CONFIG_SCHED_BORE */
+
+#ifdef CONFIG_SCHED_BORE
+core_initcall(bore_topology_init);
+late_initcall_sync(bore_late_topology_final_check);
+#ifdef CONFIG_SYSCTL
+late_initcall_sync(bore_sysctl_init_func);
+#endif
+#endif /* CONFIG_SCHED_BORE */

--- a/kernel/sched/fair.c	2025-09-26 20:56:07.644750062 +0200
+++ b/kernel/sched/fair.c	2025-09-26 21:55:31.453162308 +0200
@@ -309,7 +309,7 @@ static u64 __calc_delta(u64 delta_exec,
 	__update_inv_weight(lw);
 
 	if (unlikely(fact_hi)) {
-		fs = fls(fact_hi);
+		fs = __builtin_clz(fact_hi);
 		shift -= fs;
 		fact >>= fs;
 	}
@@ -318,7 +318,7 @@ static u64 __calc_delta(u64 delta_exec,
 
 	fact_hi = (u32)(fact >> 32);
 	if (fact_hi) {
-		fs = fls(fact_hi);
+		fs = __builtin_clz(fact_hi);
 		shift -= fs;
 		fact >>= fs;
 	}
@@ -777,7 +775,7 @@ static int vruntime_eligible(struct cfs_
 		load += weight;
 	}
 
-	return avg >= (s64)(vruntime - cfs_rq->min_vruntime) * load;
+	return __builtin_expect(avg >= (s64)(vruntime - cfs_rq->min_vruntime) * load, 1);
 }
 
 int entity_eligible(struct cfs_rq *cfs_rq, struct sched_entity *se)
@@ -9236,28 +9234,44 @@ select_task_rq_fair(struct task_struct *
  */
 static void migrate_task_rq_fair(struct task_struct *p, int new_cpu)
 {
-	struct sched_entity *se = &p->se;
-
-	if (!task_on_rq_migrating(p)) {
-		remove_entity_load_avg(se);
-
-		/*
-		 * Here, the task's PELT values have been updated according to
-		 * the current rq's clock. But if that clock hasn't been
-		 * updated in a while, a substantial idle time will be missed,
-		 * leading to an inflation after wake-up on the new rq.
-		 *
-		 * Estimate the missing time from the cfs_rq last_update_time
-		 * and update sched_avg to improve the PELT continuity after
-		 * migration.
-		 */
-		migrate_se_pelt_lag(se);
-	}
+    struct sched_entity *se = &p->se;
+    struct cfs_rq *cfs_rq = cfs_rq_of(se);
 
-	/* Tell new CPU we are migrated */
-	se->avg.last_update_time = 0;
+    /*
+     * Load tracking: migrate_load_avg() needs to know the correct cfs_rq
+     * for detach/attach, but since we're called before set_task_cpu()
+     * p->pi_lock is held so cfs_rq_of() is stable.
+     */
+    if (task_on_rq_queued(p)) {
+        update_load_avg(cfs_rq, se, UPDATE_TG | DO_DETACH);
+        detach_entity_load_avg(cfs_rq, se);
+    } else {
+        remove_entity_load_avg(se);
+    }
+
+    /* Tell new CPU we are migrated */
+    se->avg.last_update_time = 0;
+
+    /* We have migrated, no longer update this cfs_rq */
+    se->avg.util_avg = 0;
+    se->avg.util_sum = 0;
+    se->avg.runnable_avg = 0;
+    se->avg.runnable_sum = 0;
+    se->avg.load_avg = 0;
+    se->avg.load_sum = 0;
+
+    /* Update hierarchy to new CPU's structures */
+    if (task_group(p) != &root_task_group) {
+        se->cfs_rq = task_group(p)->cfs_rq[new_cpu];
+        se->parent = task_group(p)->se[new_cpu];
+        se->depth = se->parent->depth + 1;
+    } else {
+        se->cfs_rq = &cpu_rq(new_cpu)->cfs;
+        se->parent = NULL;
+        se->depth = 0;
+    }
 
-	update_scan_period(p, new_cpu);
+    update_scan_period(p, new_cpu);
 }
 
 static void task_dead_fair(struct task_struct *p)
@@ -14156,11 +14170,27 @@ static void switched_from_fair(struct rq
 
 static void switched_to_fair(struct rq *rq, struct task_struct *p)
 {
+	struct sched_entity *se = &p->se;
+	struct cfs_rq *cfs_rq = &rq->cfs;
+	struct task_group *tg = task_group(p);
+
+	/* Always set hierarchy for safety, in case garbage from other class */
+	if (tg == &root_task_group) {
+		se->cfs_rq = cfs_rq;
+		se->parent = NULL;
+		se->depth = 0;
+	} else {
+		se->cfs_rq = tg->cfs_rq[rq->cpu];
+		se->parent = tg->se[rq->cpu];
+		se->depth = se->parent->depth + 1;
+	}
+
 	WARN_ON_ONCE(p->se.sched_delayed);
 
 #ifdef CONFIG_SCHED_BORE
 	reset_task_bore(p);
 #endif // CONFIG_SCHED_BORE
+
 	attach_task_cfs_rq(p);
 
 	set_task_max_allowed_capacity(p);
@@ -14171,7 +14201,7 @@ static void switched_to_fair(struct rq *
 		 * kick off the schedule if running, otherwise just see
 		 * if we can still preempt the current task.
 		 */
-		if (task_current_donor(rq, p))
+		if (task_current(rq, p))
 			resched_curr(rq);
 		else
 			wakeup_preempt(rq, p, 0);
