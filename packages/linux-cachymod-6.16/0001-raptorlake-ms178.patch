--- a/include/linux/sched.h
+++ b/include/linux/sched.h
@@ -686,6 +686,9 @@ struct sched_dl_entity {
 	unsigned int			dl_defer	  : 1;
 	unsigned int			dl_defer_armed	  : 1;
 	unsigned int			dl_defer_running  : 1;
+	unsigned int			dl_server_idle    : 1;
+	unsigned int			__dl_flags_pad	  : 1;
+	u8					__pad ____cacheline_aligned_in_smp;
 
 	/*
 	 * Bandwidth enforcement timer. Each -deadline task has its
--- a/kernel/sched/deadline.c
+++ b/kernel/sched/deadline.c
@@ -58,18 +58,18 @@ static bool dl_server(struct sched_dl_en
 	return dl_se->dl_server;
 }
 
-static inline struct task_struct *dl_task_of(struct sched_dl_entity *dl_se)
+static __always_inline struct task_struct *dl_task_of(struct sched_dl_entity *dl_se)
 {
 	BUG_ON(dl_server(dl_se));
 	return container_of(dl_se, struct task_struct, dl);
 }
 
-static inline struct rq *rq_of_dl_rq(struct dl_rq *dl_rq)
+static __always_inline struct rq *rq_of_dl_rq(struct dl_rq *dl_rq)
 {
 	return container_of(dl_rq, struct rq, dl);
 }
 
-static inline struct rq *rq_of_dl_se(struct sched_dl_entity *dl_se)
+static __always_inline struct rq *rq_of_dl_se(struct sched_dl_entity *dl_se)
 {
 	struct rq *rq = dl_se->rq;
 
@@ -79,47 +79,47 @@ static inline struct rq *rq_of_dl_se(str
 	return rq;
 }
 
-static inline struct dl_rq *dl_rq_of_se(struct sched_dl_entity *dl_se)
+static __always_inline struct dl_rq *dl_rq_of_se(struct sched_dl_entity *dl_se)
 {
 	return &rq_of_dl_se(dl_se)->dl;
 }
 
-static inline int on_dl_rq(struct sched_dl_entity *dl_se)
+static __always_inline int on_dl_rq(struct sched_dl_entity *dl_se)
 {
 	return !RB_EMPTY_NODE(&dl_se->rb_node);
 }
 
 #ifdef CONFIG_RT_MUTEXES
-static inline struct sched_dl_entity *pi_of(struct sched_dl_entity *dl_se)
+static __always_inline struct sched_dl_entity *pi_of(struct sched_dl_entity *dl_se)
 {
 	return dl_se->pi_se;
 }
 
-static inline bool is_dl_boosted(struct sched_dl_entity *dl_se)
+static __always_inline bool is_dl_boosted(struct sched_dl_entity *dl_se)
 {
 	return pi_of(dl_se) != dl_se;
 }
 #else
-static inline struct sched_dl_entity *pi_of(struct sched_dl_entity *dl_se)
+static __always_inline struct sched_dl_entity *pi_of(struct sched_dl_entity *dl_se)
 {
 	return dl_se;
 }
 
-static inline bool is_dl_boosted(struct sched_dl_entity *dl_se)
+static __always_inline bool is_dl_boosted(struct sched_dl_entity *dl_se)
 {
 	return false;
 }
 #endif
 
 #ifdef CONFIG_SMP
-static inline struct dl_bw *dl_bw_of(int i)
+static __always_inline struct dl_bw *dl_bw_of(int i)
 {
 	RCU_LOCKDEP_WARN(!rcu_read_lock_sched_held(),
 			 "sched RCU must be held");
 	return &cpu_rq(i)->rd->dl_bw;
 }
 
-static inline int dl_bw_cpus(int i)
+static __always_inline int dl_bw_cpus(int i)
 {
 	struct root_domain *rd = cpu_rq(i)->rd;
 	int cpus;
@@ -138,7 +138,7 @@ static inline int dl_bw_cpus(int i)
 	return cpus;
 }
 
-static inline unsigned long __dl_bw_capacity(const struct cpumask *mask)
+static __always_inline unsigned long __dl_bw_capacity(const struct cpumask *mask)
 {
 	unsigned long cap = 0;
 	int i;
@@ -153,7 +153,7 @@ static inline unsigned long __dl_bw_capa
  * XXX Fix: If 'rq->rd == def_root_domain' perform AC against capacity
  * of the CPU the task is running on rather rd's \Sum CPU capacity.
  */
-static inline unsigned long dl_bw_capacity(int i)
+static __always_inline unsigned long dl_bw_capacity(int i)
 {
 	if (!sched_asym_cpucap_active() &&
 	    arch_scale_cpu_capacity(i) == SCHED_CAPACITY_SCALE) {
@@ -177,7 +177,7 @@ bool dl_bw_visited(int cpu, u64 cookie)
 	return false;
 }
 
-static inline
+static __always_inline
 void __dl_update(struct dl_bw *dl_b, s64 bw)
 {
 	struct root_domain *rd = container_of(dl_b, struct root_domain, dl_bw);
@@ -192,17 +192,17 @@ void __dl_update(struct dl_bw *dl_b, s64
 	}
 }
 #else
-static inline struct dl_bw *dl_bw_of(int i)
+static __always_inline struct dl_bw *dl_bw_of(int i)
 {
 	return &cpu_rq(i)->dl.dl_bw;
 }
 
-static inline int dl_bw_cpus(int i)
+static __always_inline int dl_bw_cpus(int i)
 {
 	return 1;
 }
 
-static inline unsigned long dl_bw_capacity(int i)
+static __always_inline unsigned long dl_bw_capacity(int i)
 {
 	return SCHED_CAPACITY_SCALE;
 }
@@ -212,7 +212,7 @@ bool dl_bw_visited(int cpu, u64 cookie)
 	return false;
 }
 
-static inline
+static __always_inline
 void __dl_update(struct dl_bw *dl_b, s64 bw)
 {
 	struct dl_rq *dl = container_of(dl_b, struct dl_rq, dl_bw);
@@ -221,28 +221,28 @@ void __dl_update(struct dl_bw *dl_b, s64
 }
 #endif
 
-static inline
+static __always_inline
 void __dl_sub(struct dl_bw *dl_b, u64 tsk_bw, int cpus)
 {
 	dl_b->total_bw -= tsk_bw;
 	__dl_update(dl_b, (s32)tsk_bw / cpus);
 }
 
-static inline
+static __always_inline
 void __dl_add(struct dl_bw *dl_b, u64 tsk_bw, int cpus)
 {
 	dl_b->total_bw += tsk_bw;
 	__dl_update(dl_b, -((s32)tsk_bw / cpus));
 }
 
-static inline bool
+static __always_inline bool
 __dl_overflow(struct dl_bw *dl_b, unsigned long cap, u64 old_bw, u64 new_bw)
 {
 	return dl_b->bw != -1 &&
 	       cap_scale(dl_b->bw, cap) < dl_b->total_bw - old_bw + new_bw;
 }
 
-static inline
+static __always_inline
 void __add_running_bw(u64 dl_bw, struct dl_rq *dl_rq)
 {
 	u64 old = dl_rq->running_bw;
@@ -255,7 +255,7 @@ void __add_running_bw(u64 dl_bw, struct
 	cpufreq_update_util(rq_of_dl_rq(dl_rq), 0);
 }
 
-static inline
+static __always_inline
 void __sub_running_bw(u64 dl_bw, struct dl_rq *dl_rq)
 {
 	u64 old = dl_rq->running_bw;
@@ -269,7 +269,7 @@ void __sub_running_bw(u64 dl_bw, struct
 	cpufreq_update_util(rq_of_dl_rq(dl_rq), 0);
 }
 
-static inline
+static __always_inline
 void __add_rq_bw(u64 dl_bw, struct dl_rq *dl_rq)
 {
 	u64 old = dl_rq->this_bw;
@@ -279,7 +279,7 @@ void __add_rq_bw(u64 dl_bw, struct dl_rq
 	SCHED_WARN_ON(dl_rq->this_bw < old); /* overflow */
 }
 
-static inline
+static __always_inline
 void __sub_rq_bw(u64 dl_bw, struct dl_rq *dl_rq)
 {
 	u64 old = dl_rq->this_bw;
@@ -292,28 +292,28 @@ void __sub_rq_bw(u64 dl_bw, struct dl_rq
 	SCHED_WARN_ON(dl_rq->running_bw > dl_rq->this_bw);
 }
 
-static inline
+static __always_inline
 void add_rq_bw(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)
 {
 	if (!dl_entity_is_special(dl_se))
 		__add_rq_bw(dl_se->dl_bw, dl_rq);
 }
 
-static inline
+static __always_inline
 void sub_rq_bw(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)
 {
 	if (!dl_entity_is_special(dl_se))
 		__sub_rq_bw(dl_se->dl_bw, dl_rq);
 }
 
-static inline
+static __always_inline
 void add_running_bw(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)
 {
 	if (!dl_entity_is_special(dl_se))
 		__add_running_bw(dl_se->dl_bw, dl_rq);
 }
 
-static inline
+static __always_inline
 void sub_running_bw(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)
 {
 	if (!dl_entity_is_special(dl_se))
@@ -1212,59 +1212,50 @@ static void __push_dl_task(struct rq *rq
 #endif
 }
 
-/* a defer timer will not be reset if the runtime consumed was < dl_server_min_res */
 static const u64 dl_server_min_res = 1 * NSEC_PER_MSEC;
 
-static enum hrtimer_restart dl_server_timer(struct hrtimer *timer, struct sched_dl_entity *dl_se)
-{
-	struct rq *rq = rq_of_dl_se(dl_se);
-	u64 fw;
-
-	scoped_guard (rq_lock, rq) {
-		struct rq_flags *rf = &scope.rf;
-
-		if (!dl_se->dl_throttled || !dl_se->dl_runtime)
-			return HRTIMER_NORESTART;
+static bool dl_server_stopped(struct sched_dl_entity *dl_se);
+static void __dl_server_stop(struct sched_dl_entity *dl_se);
 
-		sched_clock_tick();
-		update_rq_clock(rq);
-
-		if (!dl_se->dl_runtime)
-			return HRTIMER_NORESTART;
-
-		if (!dl_se->server_has_tasks(dl_se)) {
-			replenish_dl_entity(dl_se);
-			return HRTIMER_NORESTART;
-		}
+static enum hrtimer_restart
+dl_server_timer(struct hrtimer *timer, struct sched_dl_entity *dl_se)
+{
+	struct rq       *rq = rq_of_dl_se(dl_se);
+	struct rq_flags  rf;
+	u64              fw;
 
-		if (dl_se->dl_defer_armed) {
-			/*
-			 * First check if the server could consume runtime in background.
-			 * If so, it is possible to push the defer timer for this amount
-			 * of time. The dl_server_min_res serves as a limit to avoid
-			 * forwarding the timer for a too small amount of time.
-			 */
-			if (dl_time_before(rq_clock(dl_se->rq),
-					   (dl_se->deadline - dl_se->runtime - dl_server_min_res))) {
+	rq_lock(rq, &rf);
 
-				/* reset the defer timer */
-				fw = dl_se->deadline - rq_clock(dl_se->rq) - dl_se->runtime;
+	if (!dl_se->server_has_tasks(dl_se)) {
+		replenish_dl_entity(dl_se);
+		dl_server_stopped(dl_se);
+		rq_unlock(rq, &rf);
+		return HRTIMER_NORESTART;
+	}
 
-				hrtimer_forward_now(timer, ns_to_ktime(fw));
-				return HRTIMER_RESTART;
+	if (dl_se->dl_defer_armed) {
+		if (dl_time_before(rq_clock(rq),
+			dl_se->deadline - dl_se->runtime -
+			dl_server_min_res)) {
+			fw = dl_se->deadline - rq_clock(rq) - dl_se->runtime;
+		hrtimer_forward_now(timer, ns_to_ktime(fw));
+		rq_unlock(rq, &rf);
+		return HRTIMER_RESTART;
 			}
-
 			dl_se->dl_defer_running = 1;
-		}
+			dl_se->dl_defer_armed   = 0;
+	}
 
-		enqueue_dl_entity(dl_se, ENQUEUE_REPLENISH);
+	dl_se->dl_server_idle = 0;
+	enqueue_dl_entity(dl_se, ENQUEUE_REPLENISH);
 
-		if (!dl_task(dl_se->rq->curr) || dl_entity_preempt(dl_se, &dl_se->rq->curr->dl))
-			resched_curr(rq);
-
-		__push_dl_task(rq, rf);
+	if (!dl_task(rq->curr) || dl_entity_preempt(dl_se, &rq->curr->dl)) {
+		resched_curr(rq);
 	}
 
+	__push_dl_task(rq, &rf);
+	rq_unlock(rq, &rf);
+
 	return HRTIMER_NORESTART;
 }
 
@@ -1639,50 +1630,78 @@ void dl_server_update_idle_time(struct r
 
 void dl_server_update(struct sched_dl_entity *dl_se, s64 delta_exec)
 {
-	/* 0 runtime = fair server disabled */
-	if (dl_se->dl_runtime)
-		update_curr_dl_se(dl_se->rq, dl_se, delta_exec);
+	if (dl_se->dl_runtime) {
+		if (dl_se->dl_server_idle || delta_exec != 0) {
+			dl_se->dl_server_idle = 0;
+			update_curr_dl_se(dl_se->rq, dl_se, delta_exec);
+		}
+	}
 }
 
 void dl_server_start(struct sched_dl_entity *dl_se)
 {
 	struct rq *rq = dl_se->rq;
 
-	/*
-	 * XXX: the apply do not work fine at the init phase for the
-	 * fair server because things are not yet set. We need to improve
-	 * this before getting generic.
-	 */
-	if (!dl_server(dl_se)) {
-		u64 runtime =  50 * NSEC_PER_MSEC;
-		u64 period = 1000 * NSEC_PER_MSEC;
-
-		dl_server_apply_params(dl_se, runtime, period, 1);
-
-		dl_se->dl_server = 1;
-		dl_se->dl_defer = 1;
-		setup_new_dl_entity(dl_se);
-	}
-
-	if (!dl_se->dl_runtime)
+	if (!dl_se->dl_runtime || dl_se->dl_server_active)
 		return;
 
 	dl_se->dl_server_active = 1;
+	dl_se->dl_server_idle   = 0;
+
 	enqueue_dl_entity(dl_se, ENQUEUE_WAKEUP);
-	if (!dl_task(dl_se->rq->curr) || dl_entity_preempt(dl_se, &rq->curr->dl))
-		resched_curr(dl_se->rq);
+
+	if (!dl_task(rq->curr) ||
+		dl_entity_preempt(dl_se, &rq->curr->dl)) {
+		resched_curr(rq);
+		}
 }
 
-void dl_server_stop(struct sched_dl_entity *dl_se)
+static void __dl_server_stop(struct sched_dl_entity *dl_se)
 {
-	if (!dl_se->dl_runtime)
+	if (!dl_se->dl_runtime || !dl_se->dl_server_active)
 		return;
 
-	dequeue_dl_entity(dl_se, DEQUEUE_SLEEP);
+	if (on_dl_rq(dl_se))
+		dequeue_dl_entity(dl_se, DEQUEUE_SLEEP);
+
 	hrtimer_try_to_cancel(&dl_se->dl_timer);
-	dl_se->dl_defer_armed = 0;
-	dl_se->dl_throttled = 0;
+
+	dl_se->dl_defer_armed   = 0;
+	dl_se->dl_defer_running = 0;
+	dl_se->dl_throttled     = 0;
 	dl_se->dl_server_active = 0;
+	dl_se->dl_server_idle   = 0;
+}
+
+static bool dl_server_stopped(struct sched_dl_entity *dl_se)
+{
+	if (!dl_se->dl_server_active)
+		return true;
+
+	if (dl_se->dl_server_idle) {
+		__dl_server_stop(dl_se);
+		return true;
+	}
+
+	dl_se->dl_server_idle = 1;
+	return false;
+}
+
+void dl_server_stop(struct sched_dl_entity *dl_se)
+{
+	struct rq_flags rf;
+	struct rq      *rq;
+
+	if (!dl_se || !dl_se->dl_runtime)
+		return;
+
+	rq = dl_se->rq;
+	if (!rq)
+		return;
+
+	rq_lock(rq, &rf);
+	__dl_server_stop(dl_se);
+	rq_unlock(rq, &rf);
 }
 
 void dl_server_init(struct sched_dl_entity *dl_se, struct rq *rq,
@@ -2427,7 +2446,7 @@ static struct task_struct *__pick_task_d
 	struct dl_rq *dl_rq = &rq->dl;
 	struct task_struct *p;
 
-again:
+	again:
 	if (!sched_dl_runnable(rq))
 		return NULL;
 
@@ -2437,12 +2456,14 @@ again:
 	if (dl_server(dl_se)) {
 		p = dl_se->server_pick_task(dl_se);
 		if (!p) {
-			if (dl_server_active(dl_se)) {
+			if (!dl_server_stopped(dl_se)) {
 				dl_se->dl_yielded = 1;
 				update_curr_dl_se(rq, dl_se, 0);
 			}
 			goto again;
 		}
+
+		dl_se->dl_server_idle = 0;
 		rq->dl_server = dl_se;
 	} else {
 		p = dl_task_of(dl_se);



--- a/kernel/sched/core.c
+++ b/kernel/sched/core.c


--- a/kernel/sched/fair.c
+++ b/kernel/sched/fair.c
@@ -5395,7 +5395,10 @@ static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq) { }
 
 static void set_delayed(struct sched_entity *se)
 {
-	se->sched_delayed = 1;
+	/*
+	 * See TTWU_QUEUE_DELAYED in ttwu_runnable().
+	 */
+	smp_store_release(&se->sched_delayed, 1);
 
 	/*
 	 * Delayed se of cfs_rq have no tasks queued on them.
--- a/kernel/sched/features.h
+++ b/kernel/sched/features.h
@@ -81,6 +81,9 @@ SCHED_FEAT(TTWU_QUEUE, false)
  */
 SCHED_FEAT(TTWU_QUEUE, true)
 #endif
+SCHED_FEAT(TTWU_QUEUE_ON_CPU, true)
+SCHED_FEAT(TTWU_QUEUE_DELAYED, true)
+SCHED_FEAT(TTWU_QUEUE_DEFAULT, true)
 
 /*
  * When doing wakeups, attempt to limit superfluous scans of the LLC domain.
--- a/kernel/sched/sched.h
+++ b/kernel/sched/sched.h
@@ -1831,6 +1831,11 @@ task_rq_unlock(struct rq *rq, struct task_struct *p, struct rq_flags *rf)
 	raw_spin_unlock_irqrestore(&p->pi_lock, rf->flags);
 }
 
+DEFINE_LOCK_GUARD_1(__task_rq_lock, struct task_struct, /* From Patch 3 */
+		    _T->rq = __task_rq_lock(_T->lock, &_T->rf),
+		    __task_rq_unlock(_T->rq, &_T->rf),
+		    struct rq *rq; struct rq_flags rf)
+
 DEFINE_LOCK_GUARD_1(task_rq_lock, struct task_struct,
 		    _T->rq = task_rq_lock(_T->lock, &_T->rf),
 		    task_rq_unlock(_T->rq, _T->lock, &_T->rf),
@@ -2312,6 +2317,8 @@ static inline int task_on_rq_migrating(const struct task_struct *p) { return 0;
 #define WF_CURRENT_CPU		0x40 /* Prefer to move the wakee to the current CPU. */
 #define WF_RQ_SELECTED		0x80 /* ->select_task_rq() was called */
 
+#define WF_ON_CPU		0x0100
+#define WF_DELAYED		0x0200
 
 #ifdef CONFIG_SMP
 static_assert(WF_EXEC == SD_BALANCE_EXEC);


--- a/kernel/time/hrtimer.c	2025-05-09 09:56:10.000000000 +0200
+++ b/kernel/time/hrtimer.c	2025-05-18 01:36:19.652237940 +0200
@@ -635,14 +635,23 @@ static inline ktime_t hrtimer_update_bas
 {
 	ktime_t *offs_real = &base->clock_base[HRTIMER_BASE_REALTIME].offset;
 	ktime_t *offs_boot = &base->clock_base[HRTIMER_BASE_BOOTTIME].offset;
-	ktime_t *offs_tai = &base->clock_base[HRTIMER_BASE_TAI].offset;
+	ktime_t *offs_tai  = &base->clock_base[HRTIMER_BASE_TAI].offset;
+	ktime_t now;
 
-	ktime_t now = ktime_get_update_offsets_now(&base->clock_was_set_seq,
-					    offs_real, offs_boot, offs_tai);
+	now = ktime_get_update_offsets_now(&base->clock_was_set_seq,
+					   offs_real, offs_boot, offs_tai);
 
-	base->clock_base[HRTIMER_BASE_REALTIME_SOFT].offset = *offs_real;
-	base->clock_base[HRTIMER_BASE_BOOTTIME_SOFT].offset = *offs_boot;
-	base->clock_base[HRTIMER_BASE_TAI_SOFT].offset = *offs_tai;
+	/*
+	 * Single-branch update: If any hard offset changed, update all corresponding
+	 * soft offsets. Reduces branches and avoids redundant cacheline dirties.
+	 */
+	if (unlikely(base->clock_base[HRTIMER_BASE_REALTIME_SOFT].offset != *offs_real ||
+		     base->clock_base[HRTIMER_BASE_BOOTTIME_SOFT].offset != *offs_boot  ||
+		     base->clock_base[HRTIMER_BASE_TAI_SOFT].offset     != *offs_tai)) {
+		base->clock_base[HRTIMER_BASE_REALTIME_SOFT].offset = *offs_real;
+		base->clock_base[HRTIMER_BASE_BOOTTIME_SOFT].offset = *offs_boot;
+		base->clock_base[HRTIMER_BASE_TAI_SOFT].offset      = *offs_tai;
+	}
 
 	return now;
 }
@@ -1223,32 +1232,19 @@ static int __hrtimer_start_range_ns(stru
 	bool force_local, first;
 
 	/*
-	 * If the timer is on the local cpu base and is the first expiring
-	 * timer then this might end up reprogramming the hardware twice
-	 * (on removal and on enqueue). To avoid that by prevent the
-	 * reprogram on removal, keep the timer local to the current CPU
-	 * and enforce reprogramming after it is queued no matter whether
-	 * it is the new first expiring timer again or not.
+	 * If the timer is on the local CPU and is the first expiring timer,
+	 * avoid reprogramming twice: keep it local and enforce reprogramming
+	 * after enqueue.
 	 */
-	force_local = base->cpu_base == this_cpu_base;
-	force_local &= base->cpu_base->next_timer == timer;
+	force_local = (base->cpu_base == this_cpu_base) &&
+		      (base->cpu_base->next_timer == timer);
 
-	/*
-	 * Don't force local queuing if this enqueue happens on a unplugged
-	 * CPU after hrtimer_cpu_dying() has been invoked.
-	 */
+	/* Don't force local if this CPU is being unplugged. */
 	force_local &= this_cpu_base->online;
 
 	/*
-	 * Remove an active timer from the queue. In case it is not queued
-	 * on the current CPU, make sure that remove_hrtimer() updates the
-	 * remote data correctly.
-	 *
-	 * If it's on the current CPU and the first expiring timer, then
-	 * skip reprogramming, keep the timer local and enforce
-	 * reprogramming later if it was the first expiring timer.  This
-	 * avoids programming the underlying clock event twice (once at
-	 * removal and once after enqueue).
+	 * Remove active timer from the queue; if it's the current CPU's first,
+	 * skip reprogramming on removal.
 	 */
 	remove_hrtimer(timer, base, true, force_local);
 
@@ -1259,29 +1255,22 @@ static int __hrtimer_start_range_ns(stru
 
 	hrtimer_set_expires_range_ns(timer, tim, delta_ns);
 
-	/* Switch the timer base, if necessary: */
-	if (!force_local) {
-		new_base = switch_hrtimer_base(timer, base,
-					       mode & HRTIMER_MODE_PINNED);
-	} else {
+	/* Switch base via the upstream migration protocol when not forced local. */
+	if (!force_local)
+		new_base = switch_hrtimer_base(timer, base, mode & HRTIMER_MODE_PINNED);
+	else
 		new_base = base;
-	}
 
 	first = enqueue_hrtimer(timer, new_base, mode);
+
 	if (!force_local) {
 		/*
-		 * If the current CPU base is online, then the timer is
-		 * never queued on a remote CPU if it would be the first
-		 * expiring timer there.
+		 * If the current base is online, we never queue a remote-first timer.
+		 * If current base is offline and we queued a remote-first one, kick it.
 		 */
 		if (hrtimer_base_is_online(this_cpu_base))
 			return first;
 
-		/*
-		 * Timer was enqueued remote because the current base is
-		 * already offline. If the timer is the first to expire,
-		 * kick the remote CPU to reprogram the clock event.
-		 */
 		if (first) {
 			struct hrtimer_cpu_base *new_cpu_base = new_base->cpu_base;
 
@@ -1290,11 +1279,7 @@ static int __hrtimer_start_range_ns(stru
 		return 0;
 	}
 
-	/*
-	 * Timer was forced to stay on the current CPU to avoid
-	 * reprogramming on removal and enqueue. Force reprogram the
-	 * hardware by evaluating the new first expiring timer.
-	 */
+	/* Forced local: re-evaluate and reprogram locally once. */
 	hrtimer_force_reprogram(new_base->cpu_base, 1);
 	return 0;
 }
@@ -1730,30 +1715,17 @@ static void __run_hrtimer(struct hrtimer
 	base->running = timer;
 
 	/*
-	 * Separate the ->running assignment from the ->state assignment.
-	 *
-	 * As with a regular write barrier, this ensures the read side in
-	 * hrtimer_active() cannot observe base->running == NULL &&
-	 * timer->state == INACTIVE.
+	 * Separate ->running from ->state to prevent hrtimer_active() false negatives.
 	 */
 	raw_write_seqcount_barrier(&base->seq);
 
 	__remove_hrtimer(timer, base, HRTIMER_STATE_INACTIVE, 0);
 	fn = ACCESS_PRIVATE(timer, function);
 
-	/*
-	 * Clear the 'is relative' flag for the TIME_LOW_RES case. If the
-	 * timer is restarted with a period then it becomes an absolute
-	 * timer. If its not restarted it does not matter.
-	 */
 	if (IS_ENABLED(CONFIG_TIME_LOW_RES))
 		timer->is_rel = false;
 
-	/*
-	 * The timer is marked as running in the CPU base, so it is
-	 * protected against migration to a different CPU even if the lock
-	 * is dropped.
-	 */
+	/* Drop the lock while executing the callback. */
 	raw_spin_unlock_irqrestore(&cpu_base->lock, flags);
 	trace_hrtimer_expire_entry(timer, now);
 	expires_in_hardirq = lockdep_hrtimer_enter(timer);
@@ -1765,33 +1737,23 @@ static void __run_hrtimer(struct hrtimer
 	raw_spin_lock_irq(&cpu_base->lock);
 
 	/*
-	 * Note: We clear the running state after enqueue_hrtimer and
-	 * we do not reprogram the event hardware. Happens either in
-	 * hrtimer_start_range_ns() or in hrtimer_interrupt()
-	 *
-	 * Note: Because we dropped the cpu_base->lock above,
-	 * hrtimer_start_range_ns() can have popped in and enqueued the timer
-	 * for us already.
+	 * If requested to restart and not already requeued by someone else,
+	 * requeue as absolute time.
 	 */
 	if (restart != HRTIMER_NORESTART &&
 	    !(timer->state & HRTIMER_STATE_ENQUEUED))
 		enqueue_hrtimer(timer, base, HRTIMER_MODE_ABS);
 
-	/*
-	 * Separate the ->running assignment from the ->state assignment.
-	 *
-	 * As with a regular write barrier, this ensures the read side in
-	 * hrtimer_active() cannot observe base->running.timer == NULL &&
-	 * timer->state == INACTIVE.
-	 */
+	/* Again separate running/state for hrtimer_active() correctness. */
 	raw_write_seqcount_barrier(&base->seq);
 
 	WARN_ON_ONCE(base->running != timer);
 	base->running = NULL;
 }
 
-static void __hrtimer_run_queues(struct hrtimer_cpu_base *cpu_base, ktime_t now,
-				 unsigned long flags, unsigned int active_mask)
+static __attribute__((hot)) void
+__hrtimer_run_queues(struct hrtimer_cpu_base *cpu_base, ktime_t now,
+		     unsigned long flags, unsigned int active_mask)
 {
 	struct hrtimer_clock_base *base;
 	unsigned int active = cpu_base->active_bases & active_mask;
@@ -1807,17 +1769,17 @@ static void __hrtimer_run_queues(struct
 
 			timer = container_of(node, struct hrtimer, node);
 
+			/* Prefetch likely successor to hide rb-tree pointer latency */
+			{
+				struct timerqueue_node *next_node = timerqueue_iterate_next(node);
+				if (likely(next_node)) {
+					__builtin_prefetch(container_of(next_node, struct hrtimer, node), 0, 1);
+				}
+			}
+
 			/*
-			 * The immediate goal for using the softexpires is
-			 * minimizing wakeups, not running timers at the
-			 * earliest interrupt after their soft expiration.
-			 * This allows us to avoid using a Priority Search
-			 * Tree, which can answer a stabbing query for
-			 * overlapping intervals and instead use the simple
-			 * BST we already have.
-			 * We don't add extra wakeups by delaying timers that
-			 * are right-of a not yet expired timer, because that
-			 * timer will have to trigger a wakeup anyway.
+			 * Respect soft-expiry policy: minimize wakeups by not running timers
+			 * before their soft expiry.
 			 */
 			if (basenow < hrtimer_get_softexpires_tv64(timer))
 				break;

--- a/sound/pci/hda/hda_intel.c	2025-05-09 09:56:10.000000000 +0200
+++ b/sound/pci/hda/hda_intel.c	2025-05-18 01:05:45.134796217 +0200
@@ -38,6 +38,7 @@
 #include <linux/acpi.h>
 #include <linux/pgtable.h>
 #include <linux/dmi.h>
+#include <linux/iopoll.h>
 
 #ifdef CONFIG_X86
 /* for snoop control */
@@ -367,13 +368,17 @@ static void set_default_power_save(struc
  */
 /* update bits in a PCI register byte */
 static void update_pci_byte(struct pci_dev *pci, unsigned int reg,
-			    unsigned char mask, unsigned char val)
+							unsigned char mask, unsigned char val)
 {
 	unsigned char data;
 
 	pci_read_config_byte(pci, reg, &data);
+
+	if ((data & mask) == (val & mask))
+		return;
+
 	data &= ~mask;
-	data |= (val & mask);
+	data |= val & mask;
 	pci_write_config_byte(pci, reg, data);
 }
 
@@ -484,28 +489,18 @@ static int intel_get_lctl_scf(struct azx
 static int intel_ml_lctl_set_power(struct azx *chip, int state)
 {
 	struct hdac_bus *bus = azx_bus(chip);
+	void __iomem *lctl_reg = bus->mlcap + AZX_ML_BASE + AZX_REG_ML_LCTL;
 	u32 val;
-	int timeout;
 
-	/*
-	 * Changes to LCTL.SCF are only needed for the first multi-link dealing
-	 * with external codecs
-	 */
-	val = readl(bus->mlcap + AZX_ML_BASE + AZX_REG_ML_LCTL);
+	val  = readl(lctl_reg);
 	val &= ~AZX_ML_LCTL_SPA;
 	val |= state << AZX_ML_LCTL_SPA_SHIFT;
-	writel(val, bus->mlcap + AZX_ML_BASE + AZX_REG_ML_LCTL);
-	/* wait for CPA */
-	timeout = 50;
-	while (timeout) {
-		if (((readl(bus->mlcap + AZX_ML_BASE + AZX_REG_ML_LCTL)) &
-		    AZX_ML_LCTL_CPA) == (state << AZX_ML_LCTL_CPA_SHIFT))
-			return 0;
-		timeout--;
-		udelay(10);
-	}
+	writel(val, lctl_reg);
 
-	return -1;
+	return readl_poll_timeout_atomic(lctl_reg, val,
+									 ((val & AZX_ML_LCTL_CPA) ==
+									 (state << AZX_ML_LCTL_CPA_SHIFT)),
+									 10, 500);
 }
 
 static void intel_init_lctl(struct azx *chip)
@@ -548,29 +543,30 @@ set_spa:
 static void hda_intel_init_chip(struct azx *chip, bool full_reset)
 {
 	struct hdac_bus *bus = azx_bus(chip);
-	struct pci_dev *pci = chip->pci;
-	u32 val;
+	struct pci_dev  *pci = chip->pci;
+	u32 cgctl_orig = 0;
 
 	snd_hdac_set_codec_wakeup(bus, true);
+
 	if (chip->driver_type == AZX_DRIVER_SKL) {
-		pci_read_config_dword(pci, INTEL_HDA_CGCTL, &val);
-		val = val & ~INTEL_HDA_CGCTL_MISCBDCGE;
-		pci_write_config_dword(pci, INTEL_HDA_CGCTL, val);
+		pci_read_config_dword(pci, INTEL_HDA_CGCTL, &cgctl_orig);
+		pci_write_config_dword(pci, INTEL_HDA_CGCTL,
+							   cgctl_orig & ~INTEL_HDA_CGCTL_MISCBDCGE);
 	}
+
 	azx_init_chip(chip, full_reset);
+
 	if (chip->driver_type == AZX_DRIVER_SKL) {
-		pci_read_config_dword(pci, INTEL_HDA_CGCTL, &val);
-		val = val | INTEL_HDA_CGCTL_MISCBDCGE;
-		pci_write_config_dword(pci, INTEL_HDA_CGCTL, val);
+		pci_write_config_dword(pci, INTEL_HDA_CGCTL,
+							   cgctl_orig | INTEL_HDA_CGCTL_MISCBDCGE);
 	}
 
 	snd_hdac_set_codec_wakeup(bus, false);
 
-	/* reduce dma latency to avoid noise */
 	if (HDA_CONTROLLER_IS_APL(pci))
 		bxt_reduce_dma_latency(chip);
 
-	if (bus->mlcap != NULL)
+	if (bus->mlcap)
 		intel_init_lctl(chip);
 }
 
@@ -612,14 +608,12 @@ static int azx_position_ok(struct azx *c
 static int azx_position_check(struct azx *chip, struct azx_dev *azx_dev)
 {
 	struct hda_intel *hda = container_of(chip, struct hda_intel, chip);
-	int ok;
+	int ok = azx_position_ok(chip, azx_dev);
 
-	ok = azx_position_ok(chip, azx_dev);
-	if (ok == 1) {
+	if (likely(ok == 1)) {
 		azx_dev->irq_pending = 0;
 		return ok;
 	} else if (ok == 0) {
-		/* bogus IRQ, process it later */
 		azx_dev->irq_pending = 1;
 		schedule_work(&hda->irq_pending_work);
 	}
@@ -643,73 +637,70 @@ static int azx_position_check(struct azx
 static int azx_position_ok(struct azx *chip, struct azx_dev *azx_dev)
 {
 	struct snd_pcm_substream *substream = azx_dev->core.substream;
-	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct snd_pcm_runtime   *runtime   = substream->runtime;
 	int stream = substream->stream;
 	u32 wallclk;
 	unsigned int pos;
 	snd_pcm_uframes_t hwptr, target;
 
-	/*
-	 * The value of the WALLCLK register is always 0
-	 * on the Loongson controller, so we return directly.
-	 */
-	if (chip->driver_type == AZX_DRIVER_LOONGSON)
+	if (unlikely(chip->driver_type == AZX_DRIVER_LOONGSON))
 		return 1;
 
 	wallclk = azx_readl(chip, WALLCLK) - azx_dev->core.start_wallclk;
-	if (wallclk < (azx_dev->core.period_wallclk * 2) / 3)
-		return -1;	/* bogus (too early) interrupt */
+	if (unlikely(wallclk < (azx_dev->core.period_wallclk * 2) / 3)) {
+		return -1;
+	}
 
-	if (chip->get_position[stream])
+	if (likely(chip->get_position[stream])) {
 		pos = chip->get_position[stream](chip, azx_dev);
-	else { /* use the position buffer as default */
+	} else {
 		pos = azx_get_pos_posbuf(chip, azx_dev);
-		if (!pos || pos == (u32)-1) {
+		if (unlikely(!pos || pos == (u32)-1)) {
 			dev_info(chip->card->dev,
-				 "Invalid position buffer, using LPIB read method instead.\n");
+					 "Invalid position buffer, switching to LPIB\n");
 			chip->get_position[stream] = azx_get_pos_lpib;
 			if (chip->get_position[0] == azx_get_pos_lpib &&
-			    chip->get_position[1] == azx_get_pos_lpib)
+				chip->get_position[1] == azx_get_pos_lpib)
 				azx_bus(chip)->use_posbuf = false;
 			pos = azx_get_pos_lpib(chip, azx_dev);
 			chip->get_delay[stream] = NULL;
 		} else {
 			chip->get_position[stream] = azx_get_pos_posbuf;
 			if (chip->driver_caps & AZX_DCAPS_COUNT_LPIB_DELAY)
-				chip->get_delay[stream] = azx_get_delay_from_lpib;
+				chip->get_delay[stream] =
+				azx_get_delay_from_lpib;
 		}
 	}
 
-	if (pos >= azx_dev->core.bufsize)
+	if (unlikely(pos >= azx_dev->core.bufsize))
 		pos = 0;
 
-	if (WARN_ONCE(!azx_dev->core.period_bytes,
-		      "hda-intel: zero azx_dev->period_bytes"))
-		return -1; /* this shouldn't happen! */
+	if (WARN_ONCE(!azx_dev->core.period_bytes, "hda-intel: zero period_bytes"))
+		return -1;
+
 	if (wallclk < (azx_dev->core.period_wallclk * 5) / 4 &&
-	    pos % azx_dev->core.period_bytes > azx_dev->core.period_bytes / 2)
-		/* NG - it's below the first next period boundary */
+		pos % azx_dev->core.period_bytes >
+		azx_dev->core.period_bytes / 2) {
 		return chip->bdl_pos_adj ? 0 : -1;
-	azx_dev->core.start_wallclk += wallclk;
+		}
 
-	if (azx_dev->core.no_period_wakeup)
-		return 1; /* OK, no need to check period boundary */
+		azx_dev->core.start_wallclk += wallclk;
 
+	if (azx_dev->core.no_period_wakeup)
+		return 1;
 	if (runtime->hw_ptr_base != runtime->hw_ptr_interrupt)
-		return 1; /* OK, already in hwptr updating process */
+		return 1;
 
-	/* check whether the period gets really elapsed */
-	pos = bytes_to_frames(runtime, pos);
+	pos   = bytes_to_frames(runtime, pos);
 	hwptr = runtime->hw_ptr_base + pos;
 	if (hwptr < runtime->status->hw_ptr)
 		hwptr += runtime->buffer_size;
+
 	target = runtime->hw_ptr_interrupt + runtime->period_size;
-	if (hwptr < target) {
-		/* too early wakeup, process it later */
+	if (unlikely(hwptr < target))
 		return chip->bdl_pos_adj ? 0 : -1;
-	}
 
-	return 1; /* OK, it's fine */
+	return 1;
 }
 
 /*
@@ -717,57 +708,57 @@ static int azx_position_ok(struct azx *c
  */
 static void azx_irq_pending_work(struct work_struct *work)
 {
-	struct hda_intel *hda = container_of(work, struct hda_intel, irq_pending_work);
-	struct azx *chip = &hda->chip;
-	struct hdac_bus *bus = azx_bus(chip);
+	struct hda_intel  *hda  = container_of(work, struct hda_intel,
+										   irq_pending_work);
+	struct azx        *chip = &hda->chip;
+	struct hdac_bus   *bus  = azx_bus(chip);
 	struct hdac_stream *s;
 	int pending, ok;
 
 	if (!hda->irq_pending_warned) {
 		dev_info(chip->card->dev,
-			 "IRQ timing workaround is activated for card #%d. Suggest a bigger bdl_pos_adj.\n",
-			 chip->card->number);
+				 "IRQ timing workaround active; try larger bdl_pos_adj\n");
 		hda->irq_pending_warned = 1;
 	}
 
 	for (;;) {
 		pending = 0;
+
 		spin_lock_irq(&bus->reg_lock);
 		list_for_each_entry(s, &bus->stream_list, list) {
 			struct azx_dev *azx_dev = stream_to_azx_dev(s);
-			if (!azx_dev->irq_pending ||
-			    !s->substream ||
-			    !s->running)
+
+			if (!azx_dev->irq_pending || !s->substream || !s->running)
 				continue;
+
 			ok = azx_position_ok(chip, azx_dev);
 			if (ok > 0) {
 				azx_dev->irq_pending = 0;
 				spin_unlock(&bus->reg_lock);
 				snd_pcm_period_elapsed(s->substream);
 				spin_lock(&bus->reg_lock);
-			} else if (ok < 0) {
-				pending = 0;	/* too early */
-			} else
+			} else if (ok == 0) {
 				pending++;
+			}
 		}
 		spin_unlock_irq(&bus->reg_lock);
+
 		if (!pending)
 			return;
-		msleep(1);
+
+		usleep_range(300, 500);
 	}
 }
 
 /* clear irq_pending flags and assure no on-going workq */
 static void azx_clear_irq_pending(struct azx *chip)
 {
-	struct hdac_bus *bus = azx_bus(chip);
+	struct hdac_bus    *bus = azx_bus(chip);
 	struct hdac_stream *s;
 
 	spin_lock_irq(&bus->reg_lock);
-	list_for_each_entry(s, &bus->stream_list, list) {
-		struct azx_dev *azx_dev = stream_to_azx_dev(s);
-		azx_dev->irq_pending = 0;
-	}
+	list_for_each_entry(s, &bus->stream_list, list)
+	stream_to_azx_dev(s)->irq_pending = 0;
 	spin_unlock_irq(&bus->reg_lock);
 }
 

--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c	2025-05-29 11:14:09.000000000 +0200
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c	2025-06-04 12:11:46.225643872 +0200
@@ -2565,8 +2565,9 @@ gio_disable_fail:
 	 */
 	poll = ixgbe_pcie_timeout_poll(hw);
 	for (i = 0; i < poll; i++) {
-		udelay(100);
-		value = ixgbe_read_pci_cfg_word(hw, IXGBE_PCI_DEVICE_STATUS);
+		usleep_range(100, 150);       /* was: udelay(100) */
+		value = ixgbe_read_pci_cfg_word(hw,
+						IXGBE_PCI_DEVICE_STATUS);
 		if (ixgbe_removed(hw->hw_addr))
 			return 0;
 		if (!(value & IXGBE_PCI_DEVICE_STATUS_TRANSACTION_PENDING))
@@ -2693,9 +2694,9 @@ int ixgbe_disable_rx_buff_generic(struct
 		secrxreg = IXGBE_READ_REG(hw, IXGBE_SECRXSTAT);
 		if (secrxreg & IXGBE_SECRXSTAT_SECRX_RDY)
 			break;
-		else
-			/* Use interrupt-safe sleep just in case */
-			udelay(1000);
+
+		/* 1 ms pause – but yield the CPU while we wait          */
+		usleep_range(1000, 1500);   /* was: udelay(1000) */
 	}
 
 	/* For informational purposes only */
@@ -3744,9 +3745,16 @@ int ixgbe_host_interface_command(struct
 	dword_len = (buf_len + 3) >> 2;
 
 	/* Pull in the rest of the buffer (bi is where we left off) */
-	for (; bi <= dword_len; bi++) {
-		u32arr[bi] = IXGBE_READ_REG_ARRAY(hw, IXGBE_FLEX_MNG, bi);
-		le32_to_cpus(&u32arr[bi]);
+	{
+		/* Header size has not changed – still ‘hdr_size’ bytes.   */
+		const u16 hdr_dwords   = hdr_size >> 2;
+		const u16 payl_dwords  = (buf_len + 3) >> 2;     /* round-up */
+		const u16 total_dwords = hdr_dwords + payl_dwords;
+
+		for (; bi < total_dwords; bi++) {
+			u32arr[bi] = IXGBE_READ_REG_ARRAY(hw, IXGBE_FLEX_MNG, bi);
+			le32_to_cpus(&u32arr[bi]);
+		}
 	}
 
 rel_out:
@@ -3849,8 +3857,9 @@ void ixgbe_clear_tx_pending(struct ixgbe
 	 */
 	poll = ixgbe_pcie_timeout_poll(hw);
 	for (i = 0; i < poll; i++) {
-		usleep_range(100, 200);
-		value = ixgbe_read_pci_cfg_word(hw, IXGBE_PCI_DEVICE_STATUS);
+		usleep_range(100, 150);       /* was: udelay(100) */
+		value = ixgbe_read_pci_cfg_word(hw,
+						IXGBE_PCI_DEVICE_STATUS);
 		if (ixgbe_removed(hw->hw_addr))
 			break;
 		if (!(value & IXGBE_PCI_DEVICE_STATUS_TRANSACTION_PENDING))
 

--- a/drivers/net/ethernet/intel/ixgbe/ixgbe.h	2025-08-20 18:41:44.000000000 +0200
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe.h	2025-08-21 20:37:58.813013965 +0200
@@ -412,7 +413,7 @@ enum ixgbe_ring_f_enum {
 	RING_F_FDIR,
 #ifdef IXGBE_FCOE
 	RING_F_FCOE,
-#endif /* IXGBE_FCOE */
+#endif /* IS_ENABLED(CONFIG_FCOE) */
 
 	RING_F_ARRAY_SIZE      /* must be last in enum set */
 };
@@ -677,6 +678,7 @@ struct ixgbe_adapter {
 #define IXGBE_FLAG2_MOD_POWER_UNSUPPORTED	BIT(22)
 #define IXGBE_FLAG2_API_MISMATCH		BIT(23)
 #define IXGBE_FLAG2_FW_ROLLBACK			BIT(24)
+#define IXGBE_FLAG2_GAMING_ATR_ENABLED	BIT(25)
 
 	/* Tx fast path data */
 	int num_tx_queues;
@@ -840,6 +842,12 @@ struct ixgbe_adapter {
 	struct ixgbe_ipsec *ipsec;
 #endif /* CONFIG_IXGBE_IPSEC */
 	spinlock_t vfs_lock;
+
+	/* Gaming ATR feature state */
+	spinlock_t gaming_fdir_lock;
+#define IXGBE_MAX_GAMING_FILTERS 128
+	u16 gaming_fdir_ids[IXGBE_MAX_GAMING_FILTERS];
+	int gaming_fdir_count;
 };
 
 struct ixgbe_netdevice_priv {
@@ -947,7 +955,7 @@ extern const struct dcbnl_rtnl_ops ixgbe
 extern char ixgbe_driver_name[];
 #ifdef IXGBE_FCOE
 extern char ixgbe_default_device_descr[];
-#endif /* IXGBE_FCOE */
+#endif /* IS_ENABLED(CONFIG_FCOE) */
 
 int ixgbe_open(struct net_device *netdev);
 int ixgbe_close(struct net_device *netdev);


 
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c	2025-08-21 10:51:21.000000000 +0200
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c	2025-08-28 20:30:53.257238265 +0200


--- a/drivers/pci/msi/msi.c	2025-04-26 16:35:23.647821877 +0200
+++ b/drivers/pci/msi/msi.c	2025-08-13 16:48:01.839153108 +0200
@@ -7,6 +7,8 @@
  * Copyright (C) 2016 Christoph Hellwig.
  */
 #include <linux/bitfield.h>
+#include <linux/bitmap.h>
+#include <linux/prefetch.h>
 #include <linux/err.h>
 #include <linux/export.h>
 #include <linux/irq.h>
@@ -115,15 +117,18 @@ void pci_msi_update_mask(struct msi_desc
 {
 	raw_spinlock_t *lock = &to_pci_dev(desc->dev)->msi_lock;
 	unsigned long flags;
+	u32 new_mask;
 
 	if (!desc->pci.msi_attrib.can_mask)
 		return;
 
 	raw_spin_lock_irqsave(lock, flags);
-	desc->pci.msi_mask &= ~clear;
-	desc->pci.msi_mask |= set;
-	pci_write_config_dword(msi_desc_to_pci_dev(desc), desc->pci.mask_pos,
-			       desc->pci.msi_mask);
+	new_mask = (desc->pci.msi_mask & ~clear) | set;
+	if (new_mask != desc->pci.msi_mask) {
+		desc->pci.msi_mask = new_mask;
+		pci_write_config_dword(msi_desc_to_pci_dev(desc), desc->pci.mask_pos,
+				       new_mask);
+	}
 	raw_spin_unlock_irqrestore(lock, flags);
 }
 
@@ -135,6 +140,7 @@ void pci_msi_mask_irq(struct irq_data *d
 {
 	struct msi_desc *desc = irq_data_get_msi_desc(data);
 
+	prefetchw(desc);
 	__pci_msi_mask_desc(desc, BIT(data->irq - desc->irq));
 }
 EXPORT_SYMBOL_GPL(pci_msi_mask_irq);
@@ -147,6 +153,7 @@ void pci_msi_unmask_irq(struct irq_data
 {
 	struct msi_desc *desc = irq_data_get_msi_desc(data);
 
+	prefetchw(desc);
 	__pci_msi_unmask_desc(desc, BIT(data->irq - desc->irq));
 }
 EXPORT_SYMBOL_GPL(pci_msi_unmask_irq);
@@ -156,6 +163,7 @@ void __pci_read_msi_msg(struct msi_desc
 	struct pci_dev *dev = msi_desc_to_pci_dev(entry);
 
 	BUG_ON(dev->current_state != PCI_D0);
+	prefetchw(msg);
 
 	if (entry->pci.msi_attrib.is_msix) {
 		void __iomem *base = pci_msix_desc_addr(entry);
@@ -188,12 +196,13 @@ static inline void pci_write_msg_msi(str
 				     struct msi_msg *msg)
 {
 	int pos = dev->msi_cap;
-	u16 msgctl;
+	u16 msgctl, desired;
 
 	pci_read_config_word(dev, pos + PCI_MSI_FLAGS, &msgctl);
-	msgctl &= ~PCI_MSI_FLAGS_QSIZE;
-	msgctl |= FIELD_PREP(PCI_MSI_FLAGS_QSIZE, desc->pci.msi_attrib.multiple);
-	pci_write_config_word(dev, pos + PCI_MSI_FLAGS, msgctl);
+	desired = (msgctl & ~PCI_MSI_FLAGS_QSIZE) |
+		  FIELD_PREP(PCI_MSI_FLAGS_QSIZE, desc->pci.msi_attrib.multiple);
+	if (desired != msgctl)
+		pci_write_config_word(dev, pos + PCI_MSI_FLAGS, desired);
 
 	pci_write_config_dword(dev, pos + PCI_MSI_ADDRESS_LO, msg->address_lo);
 	if (desc->pci.msi_attrib.is_64) {
@@ -273,13 +282,13 @@ static void pci_intx_for_msi(struct pci_
 
 static void pci_msi_set_enable(struct pci_dev *dev, int enable)
 {
-	u16 control;
+	u16 control, new_control;
 
 	pci_read_config_word(dev, dev->msi_cap + PCI_MSI_FLAGS, &control);
-	control &= ~PCI_MSI_FLAGS_ENABLE;
-	if (enable)
-		control |= PCI_MSI_FLAGS_ENABLE;
-	pci_write_config_word(dev, dev->msi_cap + PCI_MSI_FLAGS, control);
+	new_control = enable ? (control | PCI_MSI_FLAGS_ENABLE)
+			     : (control & ~PCI_MSI_FLAGS_ENABLE);
+	if (new_control != control)
+		pci_write_config_word(dev, dev->msi_cap + PCI_MSI_FLAGS, new_control);
 }
 
 static int msi_setup_msi_desc(struct pci_dev *dev, int nvec,
@@ -488,7 +497,7 @@ int pci_msi_vec_count(struct pci_dev *de
 		return -EINVAL;
 
 	pci_read_config_word(dev, dev->msi_cap + PCI_MSI_FLAGS, &msgctl);
-	ret = 1 << FIELD_GET(PCI_MSI_FLAGS_QMASK, msgctl);
+	ret = 1U << FIELD_GET(PCI_MSI_FLAGS_QMASK, msgctl);
 
 	return ret;
 }
@@ -768,23 +777,57 @@ out_disable:
 static bool pci_msix_validate_entries(struct pci_dev *dev, struct msix_entry *entries, int nvec)
 {
 	bool nogap;
-	int i, j;
+	unsigned int i, max_idx = 0;
+	unsigned long stack_bm[4] = { 0 }; /* up to 256 bits on 64-bit */
+	unsigned long *bm;
+	size_t bits;
 
 	if (!entries)
 		return true;
 
 	nogap = pci_msi_domain_supports(dev, MSI_FLAG_MSIX_CONTIGUOUS, DENY_LEGACY);
 
-	for (i = 0; i < nvec; i++) {
-		/* Check for duplicate entries */
-		for (j = i + 1; j < nvec; j++) {
-			if (entries[i].entry == entries[j].entry)
-				return false;
-		}
-		/* Check for unsupported gaps */
+	/* Check contiguity requirement and locate maximum index */
+	for (i = 0; i < (unsigned int)nvec; i++) {
 		if (nogap && entries[i].entry != i)
 			return false;
+		if (entries[i].entry > max_idx)
+			max_idx = entries[i].entry;
+	}
+
+	/* Bitmap fast path to detect duplicates */
+	bits = (size_t)max_idx + 1U;
+	if (bits <= ARRAY_SIZE(stack_bm) * BITS_PER_LONG) {
+		bm = stack_bm;
+		bitmap_zero(bm, bits);
+	} else {
+		bm = bitmap_zalloc(bits, GFP_KERNEL);
+		if (!bm) {
+			/* Fallback to O(N²) duplicate scan */
+			for (i = 0; i < (unsigned int)nvec; i++) {
+				unsigned int j;
+				if (nogap && entries[i].entry != i)
+					return false;
+				for (j = i + 1; j < (unsigned int)nvec; j++) {
+					if (entries[i].entry == entries[j].entry)
+						return false;
+				}
+			}
+			return true;
+		}
+	}
+
+	for (i = 0; i < (unsigned int)nvec; i++) {
+		u32 idx = entries[i].entry;
+		if (test_and_set_bit(idx, bm)) {
+			if (bm != stack_bm)
+				bitmap_free(bm);
+			return false;
+		}
 	}
+
+	if (bm != stack_bm)
+		bitmap_free(bm);
 	return true;
 }
 

--- a/drivers/pci/irq.c	2025-04-26 16:32:43.874535346 +0200
+++ b/drivers/pci/irq.c	2025-04-26 16:32:30.423017727 +0200
@@ -4,6 +4,13 @@
  *
  * Copyright (c) 2008 James Bottomley <James.Bottomley@HansenPartnership.com>
  * Copyright (C) 2017 Christoph Hellwig.
+ *
+ * Minor optimisation tweaks:
+ *   – Cache host-bridge callback pointers in pci_assign_irq()
+ *   – Add unlikely() branch-prediction hint in pci_check_and_set_intx_mask()
+ *
+ * These changes are local to this translation unit and do not alter any
+ * externally visible API behaviour.
  */
 
 #include <linux/device.h>
@@ -12,6 +19,7 @@
 #include <linux/export.h>
 #include <linux/interrupt.h>
 #include <linux/pci.h>
+#include <linux/compiler.h>	/* for likely()/unlikely() */
 
 #include "pci.h"
 
@@ -75,7 +83,7 @@ EXPORT_SYMBOL(pci_request_irq);
  */
 void pci_free_irq(struct pci_dev *dev, unsigned int nr, void *dev_id)
 {
-	kfree(free_irq(pci_irq_vector(dev, nr), dev_id));
+	free_irq(pci_irq_vector(dev, nr), dev_id);
 }
 EXPORT_SYMBOL(pci_free_irq);
 
@@ -141,50 +149,45 @@ EXPORT_SYMBOL_GPL(pci_common_swizzle);
 
 void pci_assign_irq(struct pci_dev *dev)
 {
-	u8 pin;
-	u8 slot = -1;
-	int irq = 0;
-	struct pci_host_bridge *hbrg = pci_find_host_bridge(dev->bus);
-
-	if (!(hbrg->map_irq)) {
-		pci_dbg(dev, "runtime IRQ mapping not provided by arch\n");
-		return;
-	}
-
-	/*
-	 * If this device is not on the primary bus, we need to figure out
-	 * which interrupt pin it will come in on. We know which slot it
-	 * will come in on because that slot is where the bridge is. Each
-	 * time the interrupt line passes through a PCI-PCI bridge we must
-	 * apply the swizzle function.
-	 */
-	pci_read_config_byte(dev, PCI_INTERRUPT_PIN, &pin);
-	/* Cope with illegal. */
-	if (pin > 4)
-		pin = 1;
-
-	if (pin) {
-		/* Follow the chain of bridges, swizzling as we go. */
-		if (hbrg->swizzle_irq)
-			slot = (*(hbrg->swizzle_irq))(dev, &pin);
-
-		/*
-		 * If a swizzling function is not used, map_irq() must
-		 * ignore slot.
-		 */
-		irq = (*(hbrg->map_irq))(dev, slot, pin);
-		if (irq == -1)
-			irq = 0;
-	}
-	dev->irq = irq;
+    u8 pin;
+    u8 slot = (u8)-1;
+    int irq = 0;
+    struct pci_host_bridge *hbrg = pci_find_host_bridge(dev->bus);
+
+    /* ── cached host-bridge callbacks (matching prototype verbatim) ── */
+    int (*map_irq)(const struct pci_dev *, u8, u8) = hbrg->map_irq;
+    u8  (*swizzle_irq)(struct pci_dev *, u8 *)      = hbrg->swizzle_irq;
+    /* ─────────────────────────────────────────────────────────────── */
+
+    if (!map_irq) {
+        pci_dbg(dev, "runtime IRQ mapping not provided by arch\n");
+        return;
+    }
+
+    /* Read INTx pin from config space */
+    pci_read_config_byte(dev, PCI_INTERRUPT_PIN, &pin);
+    if (pin > 4)          /* cope with illegal value */
+        pin = 1;
+
+    if (pin) {
+        /* Follow the bridge chain, swizzling as we go */
+        if (swizzle_irq)
+            slot = swizzle_irq(dev, &pin);
+
+        /*
+         * If no swizzling function is present, map_irq() must
+         * ignore @slot.
+         */
+        irq = map_irq(dev, slot, pin);
+        if (irq == -1)
+            irq = 0;
+    }
 
-	pci_dbg(dev, "assign IRQ: got %d\n", dev->irq);
+    dev->irq = irq;
+    pci_dbg(dev, "assign IRQ: got %d\n", dev->irq);
 
-	/*
-	 * Always tell the device, so the driver knows what is the real IRQ
-	 * to use; the device does not use it.
-	 */
-	pci_write_config_byte(dev, PCI_INTERRUPT_LINE, irq);
+    /* Tell the device the real IRQ (driver only, device ignores it) */
+    pci_write_config_byte(dev, PCI_INTERRUPT_LINE, irq);
 }
 
 static bool pci_check_and_set_intx_mask(struct pci_dev *dev, bool mask)
@@ -213,8 +216,11 @@ static bool pci_check_and_set_intx_mask(
 	 * Check interrupt status register to see whether our device
 	 * triggered the interrupt (when masking) or the next IRQ is
 	 * already pending (when unmasking).
+	 *
+	 * unlikely(): the mismatch path is hit only when an interrupt
+	 * races this call, making it truly rare.
 	 */
-	if (mask != irq_pending) {
+	if (unlikely(mask != irq_pending)) {
 		mask_updated = false;
 		goto done;
 	}



--- a/drivers/cpufreq/intel_pstate.c	2025-04-13 11:40:05.273247310 +0200
+++ b/drivers/cpufreq/intel_pstate.c	2025-04-20 15:51:11.133723810 +0200
@@ -20,6 +20,7 @@
 #include <linux/list.h>
 #include <linux/cpu.h>
 #include <linux/cpufreq.h>
+#include <linux/math64.h>
 #include <linux/sysfs.h>
 #include <linux/types.h>
 #include <linux/fs.h>
@@ -60,6 +61,53 @@
 #define fp_ext_toint(X) ((X) >> EXT_FRAC_BITS)
 #define int_ext_tofp(X) ((int64_t)(X) << EXT_FRAC_BITS)
 
+static inline u64 ip_div_u64_recip_floor(u64 n, u64 d)
+{
+	if (unlikely(d == 0)) {
+		return 0;
+	}
+
+	return div64_u64(n, d);
+}
+
+static inline u64 ip_div_u64_recip_ceil(u64 n, u64 d)
+{
+	u64 rem;
+	u64 q;
+
+	if (unlikely(d == 0)) {
+		return 0;
+	}
+
+	q = div64_u64_rem(n, d, &rem);
+	if (rem) {
+		q++;
+	}
+
+	return q;
+}
+
+static inline u64 ip_div_u64_recip_round_closest(u64 n, u64 d)
+{
+	u64 rem;
+	u64 q;
+
+	if (unlikely(d == 0)) {
+		return 0;
+	}
+
+	q = div64_u64_rem(n, d, &rem);
+
+	/* Round to nearest: if 2*rem >= d then increment q.
+	 * Compare without overflow: (2*rem >= d) <=> (rem >= d - rem).
+	 */
+	if (rem >= d - rem) {
+		q++;
+	}
+
+	return q;
+}
+
 static inline int32_t mul_fp(int32_t x, int32_t y)
 {
 	return ((int64_t)x * (int64_t)y) >> FRAC_BITS;
@@ -1302,53 +1350,58 @@ static void intel_pstate_hwp_set(unsigne
 	if (cpu_data->policy == CPUFREQ_POLICY_PERFORMANCE)
 		min = max;
 
-	rdmsrq_on_cpu(cpu, MSR_HWP_REQUEST, &value);
+	/* Avoid redundant RDMSR: trust cached value unless empty. */
+	value = READ_ONCE(cpu_data->hwp_req_cached);
+	if (unlikely(!value))
+		rdmsrq_on_cpu(cpu, MSR_HWP_REQUEST, &value);
 
+	/* Update min/max perf fields. */
 	value &= ~HWP_MIN_PERF(~0L);
 	value |= HWP_MIN_PERF(min);
 
 	value &= ~HWP_MAX_PERF(~0L);
 	value |= HWP_MAX_PERF(max);
 
-	if (cpu_data->epp_policy == cpu_data->policy)
-		goto skip_epp;
-
-	cpu_data->epp_policy = cpu_data->policy;
-
-	if (cpu_data->policy == CPUFREQ_POLICY_PERFORMANCE) {
-		epp = intel_pstate_get_epp(cpu_data, value);
-		cpu_data->epp_powersave = epp;
-		/* If EPP read was failed, then don't try to write */
-		if (epp < 0)
-			goto skip_epp;
+	/* EPP handling: re-evaluate only if policy changed. */
+	if (cpu_data->epp_policy != cpu_data->policy) {
+		cpu_data->epp_policy = cpu_data->policy;
+
+		if (cpu_data->policy == CPUFREQ_POLICY_PERFORMANCE) {
+			epp = intel_pstate_get_epp(cpu_data, value);
+			cpu_data->epp_powersave = epp;
+			/* If EPP read failed, do not attempt to write. */
+			if (epp >= 0) {
+				epp = 0; /* performance EPP */
+			} else {
+				goto skip_epp;
+			}
+		} else {
+			/* Skip when saved value is invalid. */
+			if (cpu_data->epp_powersave < 0)
+				goto skip_epp;
 
-		epp = 0;
-	} else {
-		/* skip setting EPP, when saved value is invalid */
-		if (cpu_data->epp_powersave < 0)
-			goto skip_epp;
+			/*
+			 * If current EPP is not zero (not performance) or user changed it,
+			 * do not override here.
+			 */
+			epp = intel_pstate_get_epp(cpu_data, value);
+			if (epp)
+				goto skip_epp;
 
-		/*
-		 * No need to restore EPP when it is not zero. This
-		 * means:
-		 *  - Policy is not changed
-		 *  - user has manually changed
-		 *  - Error reading EPB
-		 */
-		epp = intel_pstate_get_epp(cpu_data, value);
-		if (epp)
-			goto skip_epp;
+			epp = cpu_data->epp_powersave;
+		}
 
-		epp = cpu_data->epp_powersave;
-	}
-	if (boot_cpu_has(X86_FEATURE_HWP_EPP)) {
-		value &= ~GENMASK_ULL(31, 24);
-		value |= (u64)epp << 24;
-	} else {
-		intel_pstate_set_epb(cpu, epp);
+		if (boot_cpu_has(X86_FEATURE_HWP_EPP)) {
+			value &= ~GENMASK_ULL(31, 24);
+			value |= (u64)epp << 24;
+		} else {
+			intel_pstate_set_epb(cpu, epp);
+		}
 	}
+
 skip_epp:
 	WRITE_ONCE(cpu_data->hwp_req_cached, value);
+	/* Ensure the write goes to the target CPU context. */
 	wrmsrq_on_cpu(cpu, MSR_HWP_REQUEST, value);
 }
 
@@ -2534,10 +2587,12 @@ static inline void intel_pstate_update_u
 {
 	struct cpudata *cpu = container_of(data, struct cpudata, update_util);
 
+	/* Accumulate flags; no atomic needed, per-CPU execution assumed. */
 	cpu->sched_flags |= flags;
 
-	if (smp_processor_id() == cpu->cpu)
+	if (likely(smp_processor_id() == cpu->cpu)) {
 		intel_pstate_update_util_hwp_local(cpu, time);
+	}
 }
 
 static inline void intel_pstate_calc_avg_perf(struct cpudata *cpu)
@@ -2679,16 +2734,28 @@ static void intel_pstate_update_util(str
 				     unsigned int flags)
 {
 	struct cpudata *cpu = container_of(data, struct cpudata, update_util);
-	u64 delta_ns;
 
-	/* Don't allow remote callbacks */
-	if (smp_processor_id() != cpu->cpu)
+	/* Don't allow remote callbacks (should not occur, but be defensive). */
+	if (unlikely(smp_processor_id() != cpu->cpu)) {
 		return;
+	}
 
-	delta_ns = time - cpu->last_update;
-	if (flags & SCHED_CPUFREQ_IOWAIT) {
-		/* Start over if the CPU may have been idle. */
+	u64 delta_ns = time - cpu->last_update;
+
+	/* Hot path: most of the time, there is no IOWAIT flag. */
+	if (likely(!(flags & SCHED_CPUFREQ_IOWAIT))) {
+		if (cpu->iowait_boost) {
+			/* Clear iowait_boost if the CPU may have been idle. */
+			if (delta_ns > TICK_NSEC) {
+				cpu->iowait_boost = 0;
+			} else {
+				cpu->iowait_boost >>= 1;
+			}
+		}
+	} else {
+		/* IOWAIT path. Handle boost escalation and re-priming. */
 		if (delta_ns > TICK_NSEC) {
+			/* Start over if the CPU may have been idle. */
 			cpu->iowait_boost = ONE_EIGHTH_FP;
 		} else if (cpu->iowait_boost >= ONE_EIGHTH_FP) {
 			cpu->iowait_boost <<= 1;
@@ -2697,14 +2764,11 @@ static void intel_pstate_update_util(str
 		} else {
 			cpu->iowait_boost = ONE_EIGHTH_FP;
 		}
-	} else if (cpu->iowait_boost) {
-		/* Clear iowait_boost if the CPU may have been idle. */
-		if (delta_ns > TICK_NSEC)
-			cpu->iowait_boost = 0;
-		else
-			cpu->iowait_boost >>= 1;
 	}
+
 	cpu->last_update = time;
+
+	/* Sample at 10ms cadence (INTEL_PSTATE_SAMPLING_INTERVAL). */
 	delta_ns = time - cpu->sample.time;
 	if ((s64)delta_ns < INTEL_PSTATE_SAMPLING_INTERVAL)
 		return;
@@ -2893,24 +2957,32 @@ static void intel_pstate_update_perf_lim
 	int perf_ctl_scaling = cpu->pstate.perf_ctl_scaling;
 	int32_t max_policy_perf, min_policy_perf;
 
-	max_policy_perf = policy_max / perf_ctl_scaling;
+	/* Defensive: avoid division by zero if FW anomaly (should not happen). */
+	if (unlikely(perf_ctl_scaling <= 0)) {
+		max_policy_perf = 0;
+		min_policy_perf = 0;
+		goto finalize;
+	}
+
+	/* Exact floor division for policy limits via internal helpers. */
+	max_policy_perf = (int32_t)ip_div_u64_recip_floor((u64)policy_max, (u64)perf_ctl_scaling);
 	if (policy_max == policy_min) {
 		min_policy_perf = max_policy_perf;
 	} else {
-		min_policy_perf = policy_min / perf_ctl_scaling;
-		min_policy_perf = clamp_t(int32_t, min_policy_perf,
-					  0, max_policy_perf);
+		min_policy_perf = (int32_t)ip_div_u64_recip_floor((u64)policy_min, (u64)perf_ctl_scaling);
+		min_policy_perf = clamp_t(int32_t, min_policy_perf, 0, max_policy_perf);
 	}
 
 	/*
-	 * HWP needs some special consideration, because HWP_REQUEST uses
-	 * abstract values to represent performance rather than pure ratios.
+	 * HWP needs special handling: HWP_REQUEST uses abstract performance
+	 * levels; map perf_ctl-based values back to HWP scale when necessary.
 	 */
 	if (hwp_active && cpu->pstate.scaling != perf_ctl_scaling) {
 		int freq;
 
 		freq = max_policy_perf * perf_ctl_scaling;
 		max_policy_perf = intel_pstate_freq_to_hwp(cpu, freq);
+
 		freq = min_policy_perf * perf_ctl_scaling;
 		min_policy_perf = intel_pstate_freq_to_hwp(cpu, freq);
 	}
@@ -2918,6 +2990,7 @@ static void intel_pstate_update_perf_lim
 	pr_debug("cpu:%d min_policy_perf:%d max_policy_perf:%d\n",
 		 cpu->cpu, min_policy_perf, max_policy_perf);
 
+finalize:
 	/* Normalize user input to [min_perf, max_perf] */
 	if (per_cpu_limits) {
 		cpu->min_perf_ratio = min_policy_perf;
@@ -2939,14 +3012,12 @@ static void intel_pstate_update_perf_lim
 		cpu->max_perf_ratio = min(max_policy_perf, global_max);
 		cpu->max_perf_ratio = max(min_policy_perf, cpu->max_perf_ratio);
 
-		/* Make sure min_perf <= max_perf */
-		cpu->min_perf_ratio = min(cpu->min_perf_ratio,
-					  cpu->max_perf_ratio);
-
+		/* Ensure min_perf <= max_perf */
+		cpu->min_perf_ratio = min(cpu->min_perf_ratio, cpu->max_perf_ratio);
 	}
+
 	pr_debug("cpu:%d max_perf_ratio:%d min_perf_ratio:%d\n", cpu->cpu,
-		 cpu->max_perf_ratio,
-		 cpu->min_perf_ratio);
+		 cpu->max_perf_ratio, cpu->min_perf_ratio);
 }
 
 static int intel_pstate_set_policy(struct cpufreq_policy *policy)
@@ -3784,25 +3855,46 @@ static const struct x86_cpu_id intel_epp
 	 * AlderLake Mobile CPUs.
 	 */
 	X86_MATCH_VFM(INTEL_ALDERLAKE_L, HWP_SET_DEF_BALANCE_PERF_EPP(102)),
+
 	X86_MATCH_VFM(INTEL_SAPPHIRERAPIDS_X, HWP_SET_DEF_BALANCE_PERF_EPP(32)),
 	X86_MATCH_VFM(INTEL_EMERALDRAPIDS_X, HWP_SET_DEF_BALANCE_PERF_EPP(32)),
 	X86_MATCH_VFM(INTEL_GRANITERAPIDS_X, HWP_SET_DEF_BALANCE_PERF_EPP(32)),
 	X86_MATCH_VFM(INTEL_GRANITERAPIDS_D, HWP_SET_DEF_BALANCE_PERF_EPP(32)),
+
+	/* Platform guidance: balanced gaming/desktop tuning. */
 	X86_MATCH_VFM(INTEL_METEORLAKE_L, HWP_SET_EPP_VALUES(HWP_EPP_POWERSAVE,
 		      179, 64, 16)),
 	X86_MATCH_VFM(INTEL_ARROWLAKE, HWP_SET_EPP_VALUES(HWP_EPP_POWERSAVE,
 		      179, 64, 16)),
+
+	/* New: Raptor Lake defaults tuned for gaming responsiveness. */
+	X86_MATCH_VFM(INTEL_RAPTORLAKE,   HWP_SET_EPP_VALUES(HWP_EPP_POWERSAVE, 179, 64, 0)),
+	X86_MATCH_VFM(INTEL_RAPTORLAKE_P, HWP_SET_EPP_VALUES(HWP_EPP_POWERSAVE, 179, 64, 0)),
+	X86_MATCH_VFM(INTEL_RAPTORLAKE_S, HWP_SET_EPP_VALUES(HWP_EPP_POWERSAVE, 179, 64, 0)),
+
 	{}
 };
 
 static const struct x86_cpu_id intel_hybrid_scaling_factor[] = {
-	X86_MATCH_VFM(INTEL_ALDERLAKE, HYBRID_SCALING_FACTOR_ADL),
-	X86_MATCH_VFM(INTEL_ALDERLAKE_L, HYBRID_SCALING_FACTOR_ADL),
-	X86_MATCH_VFM(INTEL_RAPTORLAKE, HYBRID_SCALING_FACTOR_ADL),
-	X86_MATCH_VFM(INTEL_RAPTORLAKE_P, HYBRID_SCALING_FACTOR_ADL),
-	X86_MATCH_VFM(INTEL_RAPTORLAKE_S, HYBRID_SCALING_FACTOR_ADL),
-	X86_MATCH_VFM(INTEL_METEORLAKE_L, HYBRID_SCALING_FACTOR_MTL),
-	X86_MATCH_VFM(INTEL_LUNARLAKE_M, HYBRID_SCALING_FACTOR_LNL),
+	X86_MATCH_VFM(INTEL_ALDERLAKE,     HYBRID_SCALING_FACTOR_ADL), /* 78741 */
+	X86_MATCH_VFM(INTEL_ALDERLAKE_L,   HYBRID_SCALING_FACTOR_ADL),
+
+	/* Raptor Lake: use 80000 for improved perf-to-frequency mapping. */
+	X86_MATCH_VFM(INTEL_RAPTORLAKE,    HYBRID_SCALING_FACTOR_MTL), /* 80000 */
+	X86_MATCH_VFM(INTEL_RAPTORLAKE_P,  HYBRID_SCALING_FACTOR_MTL),
+	X86_MATCH_VFM(INTEL_RAPTORLAKE_S,  HYBRID_SCALING_FACTOR_MTL),
+
+	X86_MATCH_VFM(INTEL_METEORLAKE_L,  HYBRID_SCALING_FACTOR_MTL), /* 80000 */
+	X86_MATCH_VFM(INTEL_LUNARLAKE_M,   HYBRID_SCALING_FACTOR_LNL), /* 86957 */
+
+	{}
+};
+
+/* Raptor Lake family match for minor tuning at init time. */
+static const struct x86_cpu_id raptorlake_ids[] __initconst = {
+	X86_MATCH_VFM(INTEL_RAPTORLAKE,   1),
+	X86_MATCH_VFM(INTEL_RAPTORLAKE_P, 1),
+	X86_MATCH_VFM(INTEL_RAPTORLAKE_S, 1),
 	{}
 };
 
@@ -3919,6 +4011,12 @@ hwp_cpu_matched:
 			pr_debug("hybrid scaling factor: %d\n", hybrid_scaling_factor);
 		}
 
+		/* Raptor Lake gaming-friendly iowait boost hold time. */
+		if (x86_match_cpu(raptorlake_ids)) {
+			hwp_boost_hold_time_ns = 5 * NSEC_PER_MSEC;
+			pr_debug("Raptor Lake: set HWP boost hold time to %d ns\n",
+				 hwp_boost_hold_time_ns);
+		}
 	}
 
 	mutex_lock(&intel_pstate_driver_lock);


--- a/kernel/irq/affinity.c	2025-08-21 13:08:08.000000000 +0100
+++ b/kernel/irq/affinity.c	2025-08-21 22:28:35.518663546 +0100
@@ -2,25 +2,978 @@
 /*
  * Copyright (C) 2016 Thomas Gleixner.
  * Copyright (C) 2016-2017 Christoph Hellwig.
+ * Raptor Lake optimizations (C) 2025 ms178.
  */
 #include <linux/interrupt.h>
 #include <linux/kernel.h>
 #include <linux/slab.h>
 #include <linux/cpu.h>
 #include <linux/group_cpus.h>
+#include <linux/cpufreq.h>
+#include <linux/topology.h>
+#include <linux/numa.h>
+#include <linux/overflow.h>
+#include <linux/bitmap.h>
+#ifdef CONFIG_X86
+#include <linux/module.h>
+#include <asm/cpu_device_id.h>
+#include <asm/intel-family.h>
+#include <asm/topology.h>
+#include <asm/cpu.h>
+#include <asm/smp.h>
+#endif
 
+#ifdef CONFIG_X86
+/* Maximum number of cores to handle */
+#define MAX_CORES_PER_NODE 64  /* Increased to handle future processors */
+
+/* Module parameters */
+static bool irq_pcore_affinity = true;
+module_param_named(pcore_affinity, irq_pcore_affinity, bool, 0644);
+MODULE_PARM_DESC(pcore_affinity, "Enable P-core IRQ affinity (default: 1)");
+
+/* Define CPU IDs if not already defined */
+#ifndef INTEL_FAM6_RAPTORLAKE
+#define INTEL_FAM6_RAPTORLAKE 0xB7
+#endif
+
+#ifndef INTEL_FAM6_ALDERLAKE
+#define INTEL_FAM6_ALDERLAKE 0x97
+#endif
+
+#ifndef INTEL_FAM6_ALDERLAKE_L
+#define INTEL_FAM6_ALDERLAKE_L 0x9A
+#endif
+
+/* Core type definition if not available */
+#ifndef X86_CORE_TYPE_INTEL_CORE
+#define X86_CORE_TYPE_INTEL_CORE 1
+#endif
+
+#ifndef X86_CORE_TYPE_INTEL_ATOM
+#define X86_CORE_TYPE_INTEL_ATOM 0
+#endif
+
+/* P-core mask management with proper locking */
+static DEFINE_MUTEX(pcore_mask_lock);
+static struct cpumask pcore_mask;
+static atomic_t pcore_mask_initialized = ATOMIC_INIT(0);
+static int numa_node_for_cpu[NR_CPUS];
+
+/* Store L2 cache domain information */
+static struct cpumask *l2_domain_masks;
+static int l2_domain_count;
+
+/* Cache to store CPU core types: -2 = uninitialized, -1 = not hybrid/unknown, 0 = E-core, 1 = P-core */
+static DEFINE_SPINLOCK(core_type_lock);
+static int cpu_core_type[NR_CPUS] = { [0 ... NR_CPUS-1] = -2 };
+
+/* Frequency heuristic information */
+static unsigned int max_cpu_freq;
+static atomic_t freq_initialized = ATOMIC_INIT(0);
+
+/* L2 core ID cache to avoid recalculation */
+static int l2_core_ids[NR_CPUS];
+static atomic_t l2_ids_initialized = ATOMIC_INIT(0);
+
+/* CPU hotplug dynamic state id (for correct unregister) */
+static int pcore_cpuhp_state = -1;
+
+/**
+ * hybrid_cpu_detected - Check if system has hybrid CPU architecture
+ *
+ * Detects Intel hybrid architectures like Raptor Lake and Alder Lake.
+ * Result is safely cached for performance.
+ *
+ * Return: true if hybrid CPU detected, false otherwise
+ */
+static bool hybrid_cpu_detected(void)
+{
+	static int is_hybrid = -1;
+	static const struct x86_cpu_id hybrid_ids[] = {
+		{ .family = 6, .model = INTEL_FAM6_RAPTORLAKE,   .driver_data = 0 },
+		{ .family = 6, .model = INTEL_FAM6_ALDERLAKE,    .driver_data = 0 },
+		{ .family = 6, .model = INTEL_FAM6_ALDERLAKE_L,  .driver_data = 0 },
+		{}
+	};
+
+	if (is_hybrid == -1)
+		is_hybrid = x86_match_cpu(hybrid_ids) ? 1 : 0;
+
+	return is_hybrid == 1;
+}
+
+/**
+ * init_freq_info - Initialize frequency information for heuristic detection
+ *
+ * Efficiently calculates and caches maximum CPU frequency for use in core type detection.
+ * Only performs the calculation once for all CPUs.
+ */
+static void init_freq_info(void)
+{
+	unsigned int freq, temp_max = 0;
+	int c;
+
+	/* Only initialize once - avoid unnecessary work */
+	if (atomic_read(&freq_initialized) != 0)
+		return;
+
+	/* Calculate max frequency in a single pass */
+	for_each_online_cpu(c) {
+		freq = cpufreq_quick_get_max(c);
+		if (freq > temp_max)
+			temp_max = freq;
+	}
+
+	/* Atomic update to ensure we only set the value once */
+	if (atomic_cmpxchg(&freq_initialized, 0, 1) == 0)
+		max_cpu_freq = temp_max;
+}
+
+/**
+ * init_l2_core_ids - Pre-calculate L2 domain IDs once
+ *
+ * Pre-computes the L2 domain IDs for all CPUs to avoid expensive
+ * recalculations during L2 domain detection fallback.
+ */
+static void init_l2_core_ids(void)
+{
+	int cpu;
+
+	if (atomic_read(&l2_ids_initialized) != 0)
+		return;
+
+	for_each_possible_cpu(cpu) {
+		if (cpu < NR_CPUS)
+			l2_core_ids[cpu] = topology_physical_package_id(cpu) * 100 + topology_core_id(cpu);
+	}
+
+	atomic_set(&l2_ids_initialized, 1);
+}
+
+/**
+ * get_core_type - Optimized CPU core type detection with caching
+ * @cpu: CPU number to check
+ *
+ * Efficiently determines whether a CPU is a P-core or E-core using three methods
+ * in order of reliability, with results cached for maximum performance.
+ *
+ * Return: 1 for P-core, 0 for E-core, -1 if unknown/not hybrid
+ */
+static int get_core_type(int cpu)
+{
+	int core_type;
+	unsigned long flags;
+
+	/* Validate CPU ID */
+	if (!cpu_possible(cpu))
+		return -1;
+
+	/* Fast path: return cached result if available */
+	if (cpu_core_type[cpu] != -2)
+		return cpu_core_type[cpu];
+
+	/* Early return for non-hybrid CPUs */
+	if (!hybrid_cpu_detected()) {
+		spin_lock_irqsave(&core_type_lock, flags);
+		if (cpu_core_type[cpu] == -2) /* Check again under lock */
+			cpu_core_type[cpu] = -1;
+		core_type = cpu_core_type[cpu];
+		spin_unlock_irqrestore(&core_type_lock, flags);
+		return core_type;
+	}
+
+	/* Method 1: Use official core type if available (most reliable) */
+#ifdef CONFIG_INTEL_HYBRID_CPU
+	if (cpu_data(cpu).x86_core_type == X86_CORE_TYPE_INTEL_CORE) {
+		spin_lock_irqsave(&core_type_lock, flags);
+		if (cpu_core_type[cpu] == -2)
+			cpu_core_type[cpu] = 1;
+		spin_unlock_irqrestore(&core_type_lock, flags);
+		return 1;  /* P-core */
+	} else if (cpu_data(cpu).x86_core_type == X86_CORE_TYPE_INTEL_ATOM) {
+		spin_lock_irqsave(&core_type_lock, flags);
+		if (cpu_core_type[cpu] == -2)
+			cpu_core_type[cpu] = 0;
+		spin_unlock_irqrestore(&core_type_lock, flags);
+		return 0;  /* E-core */
+	}
+#endif
+
+	/* Get lock for remaining detection methods */
+	spin_lock_irqsave(&core_type_lock, flags);
+
+	/* Check cache again under lock */
+	if (cpu_core_type[cpu] != -2) {
+		core_type = cpu_core_type[cpu];
+		spin_unlock_irqrestore(&core_type_lock, flags);
+		return core_type;
+	}
+
+	/* Method 2: Thread siblings count (also reliable for Raptor Lake) */
+	{
+		const struct cpumask *thread_siblings = topology_sibling_cpumask(cpu);
+		if (thread_siblings && cpumask_weight(thread_siblings) > 1) {
+			cpu_core_type[cpu] = 1;  /* Multiple threads per core = P-core */
+			spin_unlock_irqrestore(&core_type_lock, flags);
+			return 1;
+		}
+	}
+
+	/* Release lock for potentially expensive frequency operations */
+	spin_unlock_irqrestore(&core_type_lock, flags);
+
+	/* Initialize frequency info if needed */
+	if (atomic_read(&freq_initialized) == 0)
+		init_freq_info();
+
+	/* Reacquire lock */
+	spin_lock_irqsave(&core_type_lock, flags);
+
+	/* Check cache again after reacquiring lock */
+	if (cpu_core_type[cpu] != -2) {
+		core_type = cpu_core_type[cpu];
+		spin_unlock_irqrestore(&core_type_lock, flags);
+		return core_type;
+	}
+
+	/* Method 3: Frequency-based heuristic (last resort) */
+	if (max_cpu_freq > 0) {
+		unsigned int cpu_freq = cpufreq_quick_get_max(cpu);
+		if (cpu_freq >= max_cpu_freq * 95 / 100) {
+			cpu_core_type[cpu] = 1;  /* Within 5% of max frequency = likely P-core */
+			spin_unlock_irqrestore(&core_type_lock, flags);
+			return 1;
+		} else if (cpu_freq <= max_cpu_freq * 70 / 100) {
+			cpu_core_type[cpu] = 0;  /* Below 70% of max frequency = likely E-core */
+			spin_unlock_irqrestore(&core_type_lock, flags);
+			return 0;
+		}
+	}
+
+	/* Cannot determine reliably */
+	cpu_core_type[cpu] = -1;
+	spin_unlock_irqrestore(&core_type_lock, flags);
+	return -1;
+}
+
+/**
+ * get_cache_shared_mask - Get cache sharing mask for CPU
+ * @cpu: CPU number
+ *
+ * Returns the appropriate cache sharing mask based on core type
+ *
+ * Return: Pointer to cpumask
+ */
+static const struct cpumask *get_cache_shared_mask(int cpu)
+{
+	int core_type = get_core_type(cpu);
+
+	if (core_type == 0) /* E-core */
+		return cpu_l2c_shared_mask(cpu);
+	else if (core_type == 1) /* P-core */
+		return cpu_llc_shared_mask(cpu);
+	else
+		return cpu_llc_shared_mask(cpu); /* Default to LLC */
+}
+
+/**
+ * free_l2_domain_masks - Free L2 domain mask resources
+ *
+ * Helper function to safely clean up L2 domain resources.
+ * Can be called from any context including error paths.
+ */
+static void free_l2_domain_masks(void)
+{
+	mutex_lock(&pcore_mask_lock);
+	if (l2_domain_masks) {
+		kfree(l2_domain_masks);
+		l2_domain_masks = NULL;
+		l2_domain_count = 0;
+	}
+	mutex_unlock(&pcore_mask_lock);
+}
+
+/**
+ * get_pcore_mask - Fill provided mask with performance cores
+ * @dst: Destination cpumask to fill with P-cores
+ *
+ * Thread-safe function to identify performance cores on hybrid CPUs.
+ * Caller must provide the destination buffer.
+ *
+ * Return: 0 on success, negative error code on failure
+ */
+static int get_pcore_mask(struct cpumask *dst)
+{
+	cpumask_var_t temp_mask;
+
+	if (!dst)
+		return -EINVAL;
+
+	if (atomic_read_acquire(&pcore_mask_initialized) == 0) {
+		mutex_lock(&pcore_mask_lock);
+		if (atomic_read(&pcore_mask_initialized) == 0) {
+			int cpu;
+			int core_id, prev_core = -1;
+			int siblings = 0;
+			bool direct_detection = false;
+
+			cpumask_clear(&pcore_mask);
+
+			/* First try: direct core type detection if available */
+			for_each_possible_cpu(cpu) {
+				int core_type = get_core_type(cpu);
+				if (core_type == 1) {  /* P-core */
+					cpumask_set_cpu(cpu, &pcore_mask);
+					direct_detection = true;
+				}
+				/* Store NUMA node information for each CPU */
+				if (cpu < NR_CPUS)
+					numa_node_for_cpu[cpu] = cpu_to_node(cpu);
+			}
+
+			/* If direct detection didn't work, use heuristics */
+			if (!direct_detection) {
+				/* Allocate temporary mask to avoid large stack usage */
+				if (!zalloc_cpumask_var(&temp_mask, GFP_KERNEL)) {
+					/* Allocation failed, fallback later to all online CPUs */
+					cpumask_clear(&pcore_mask);
+					goto finalize_mask;
+				}
+
+				/* Second try: count siblings per core to identify P-cores */
+				for_each_online_cpu(cpu) {
+					core_id = topology_core_id(cpu);
+
+					/* Check if this is a new core */
+					if (core_id != prev_core) {
+						/* Process previous core */
+						if (prev_core != -1) {
+							if (siblings >= 2) {
+								/* Previous core had hyperthreading - likely a P-core */
+								cpumask_or(&pcore_mask, &pcore_mask, temp_mask);
+							}
+							cpumask_clear(temp_mask);
+						}
+
+						prev_core = core_id;
+						siblings = 1;
+						cpumask_set_cpu(cpu, temp_mask);
+					} else {
+						/* Another sibling of the current core */
+						siblings++;
+						cpumask_set_cpu(cpu, temp_mask);
+					}
+				}
+
+				/* Handle the last core */
+				if (prev_core != -1 && siblings >= 2) {
+					cpumask_or(&pcore_mask, &pcore_mask, temp_mask);
+				}
+
+				free_cpumask_var(temp_mask);
+
+				/* Third try: find fastest cores by frequency */
+				if (cpumask_empty(&pcore_mask)) {
+					unsigned int max_freq = 0;
+					int max_freq_cpu = -1;
+
+					for_each_online_cpu(cpu) {
+						unsigned int freq = cpufreq_quick_get_max(cpu);
+						if (freq > max_freq && freq > 0) {
+							max_freq = freq;
+							max_freq_cpu = cpu;
+						}
+					}
+
+					if (max_freq_cpu >= 0 && max_freq > 0) {
+						/* Use cores with the same max frequency (within 5%) */
+						unsigned int threshold = max_freq * 95 / 100;
+
+						for_each_online_cpu(cpu) {
+							unsigned int freq = cpufreq_quick_get_max(cpu);
+							if (freq >= threshold && freq > 0)
+								cpumask_set_cpu(cpu, &pcore_mask);
+						}
+					}
+				}
+			}
+
+finalize_mask:
+			/* Fallback to all CPUs if still no cores identified */
+			if (cpumask_empty(&pcore_mask))
+				cpumask_copy(&pcore_mask, cpu_online_mask);
+
+			/* Memory barrier before setting initialized flag */
+			smp_wmb();
+			atomic_set(&pcore_mask_initialized, 1);
+		}
+		mutex_unlock(&pcore_mask_lock);
+	}
+
+	mutex_lock(&pcore_mask_lock);
+	cpumask_copy(dst, &pcore_mask);
+	mutex_unlock(&pcore_mask_lock);
+
+	return 0;
+}
+
+/**
+ * identify_l2_domains - Optimized L2 cache domain detection
+ * @p_core_mask: Mask of P-cores to analyze
+ *
+ * Maps L2 cache sharing domains on Raptor Lake with optimized fallback mechanism.
+ * Pre-calculates L2 core IDs to avoid expensive operations in inner loops.
+ *
+ * Return: 0 on success, negative error code on failure
+ */
+static int identify_l2_domains(struct cpumask *p_core_mask)
+{
+	int i, cpu;
+	bool using_fallback = false;
+	int total_cpus;
+
+	/* Validate input */
+	if (!p_core_mask || cpumask_empty(p_core_mask)) {
+		pr_warn("Empty P-core mask provided\n");
+		return -EINVAL;
+	}
+
+	/* Pre-calculate L2 core IDs if not done already */
+	if (atomic_read(&l2_ids_initialized) == 0)
+		init_l2_core_ids();
+
+	mutex_lock(&pcore_mask_lock);
+
+	/* Clean up existing resources */
+	if (l2_domain_masks) {
+		kfree(l2_domain_masks);
+		l2_domain_masks = NULL;
+		l2_domain_count = 0;
+	}
+
+	/* Allocate memory with bounds check */
+	if (MAX_CORES_PER_NODE == 0) {
+		mutex_unlock(&pcore_mask_lock);
+		pr_err("Invalid MAX_CORES_PER_NODE value\n");
+		return -EINVAL;
+	}
+
+	l2_domain_masks = kcalloc(MAX_CORES_PER_NODE, sizeof(struct cpumask), GFP_KERNEL);
+	if (!l2_domain_masks) {
+		mutex_unlock(&pcore_mask_lock);
+		pr_warn("Failed to allocate L2 domain masks\n");
+		return -ENOMEM;
+	}
+
+	l2_domain_count = 0;
+
+	/* Primary detection: use cache topology more efficiently */
+	for_each_cpu(cpu, p_core_mask) {
+		const struct cpumask *shared_mask = get_cache_shared_mask(cpu);
+		bool found = false;
+		int j;
+
+		/* Validate mask */
+		if (!shared_mask || cpumask_empty(shared_mask) ||
+		    cpumask_weight(shared_mask) > MAX_CORES_PER_NODE / 2) {
+			using_fallback = true;
+			continue;
+		}
+
+		/* Skip CPUs already in a domain to avoid redundant checks */
+		for (j = 0; j < l2_domain_count; j++) {
+			if (cpumask_test_cpu(cpu, &l2_domain_masks[j])) {
+				found = true;
+				break;
+			}
+		}
+		if (found)
+			continue;
+
+		/* Check if domain already exists */
+		for (j = 0; j < l2_domain_count; j++) {
+			if (cpumask_equal(&l2_domain_masks[j], shared_mask)) {
+				found = true;
+				break;
+			}
+		}
+
+		/* Add new domain if needed */
+		if (!found && l2_domain_count < MAX_CORES_PER_NODE) {
+			cpumask_copy(&l2_domain_masks[l2_domain_count], shared_mask);
+			l2_domain_count++;
+		}
+	}
+
+	/* Optimized fallback: bounded associative map instead of huge id array */
+	if (l2_domain_count == 0 || using_fallback) {
+		int max_domains = min(MAX_CORES_PER_NODE, cpumask_weight(p_core_mask));
+		struct id_map {
+			int id;
+			int dom_idx;
+		} *map = NULL;
+		int map_count = 0;
+
+		/* Reset domain count */
+		l2_domain_count = 0;
+
+		if (max_domains <= 0) {
+			kfree(l2_domain_masks);
+			l2_domain_masks = NULL;
+			mutex_unlock(&pcore_mask_lock);
+			return -ENODATA;
+		}
+
+		map = kcalloc(max_domains, sizeof(*map), GFP_KERNEL);
+		if (!map) {
+			kfree(l2_domain_masks);
+			l2_domain_masks = NULL;
+			mutex_unlock(&pcore_mask_lock);
+			return -ENOMEM;
+		}
+
+		/* Initialize IDs as unused */
+		for (i = 0; i < max_domains; i++) {
+			map[i].id = -1;
+			map[i].dom_idx = -1;
+		}
+
+		/* One-pass domain assignment using bounded map */
+		for_each_cpu(cpu, p_core_mask) {
+			int l2_id, dom_idx = -1;
+			int m;
+
+			if (cpu >= NR_CPUS)
+				continue;
+
+			l2_id = l2_core_ids[cpu];
+
+			/* Find existing mapping */
+			for (m = 0; m < map_count; m++) {
+				if (map[m].id == l2_id) {
+					dom_idx = map[m].dom_idx;
+					break;
+				}
+			}
+
+			/* Create new domain if no mapping found */
+			if (dom_idx == -1) {
+				if (map_count < max_domains) {
+					dom_idx = map_count;
+					map[map_count].id = l2_id;
+					map[map_count].dom_idx = dom_idx;
+					cpumask_clear(&l2_domain_masks[dom_idx]);
+					map_count++;
+					l2_domain_count++;
+				} else {
+					/* Too many domains; skip additional CPUs */
+					continue;
+				}
+			}
+
+			/* Add CPU to domain */
+			cpumask_set_cpu(cpu, &l2_domain_masks[dom_idx]);
+		}
+
+		kfree(map);
+	}
+
+	/* Verify all CPUs were assigned */
+	total_cpus = 0;
+	for (i = 0; i < l2_domain_count; i++)
+		total_cpus += cpumask_weight(&l2_domain_masks[i]);
+
+	if (total_cpus < cpumask_weight(p_core_mask)) {
+		pr_warn("L2 domain detection incomplete: %d/%d CPUs\n",
+			total_cpus, cpumask_weight(p_core_mask));
+	}
+
+	mutex_unlock(&pcore_mask_lock);
+	return l2_domain_count > 0 ? 0 : -ENODATA;
+}
+
+/**
+ * group_cpus_hybrid_first - Distribute IRQs with hybrid CPU awareness
+ * @num_grps: Number of groups to create
+ *
+ * Creates CPU groups optimized for IRQ distribution on hybrid CPUs.
+ * Prioritizes P-cores and considers cache topology for performance.
+ *
+ * Return: Array of CPU masks or NULL on failure
+ */
+static struct cpumask *group_cpus_hybrid_first(unsigned int num_grps)
+{
+	cpumask_var_t p_core_copy;
+	cpumask_var_t e_cores_mask;
+	unsigned long *assigned = NULL;
+	struct cpumask *result = NULL;
+	int i, j, cpu, grp_idx = 0;
+	int ret;
+
+	if (!num_grps)
+		return NULL;
+
+	if (!irq_pcore_affinity || !hybrid_cpu_detected())
+		return group_cpus_evenly(num_grps);
+
+	/* Allocate working structures to avoid large on-stack usage */
+	if (!zalloc_cpumask_var(&p_core_copy, GFP_KERNEL))
+		return group_cpus_evenly(num_grps);
+	if (!zalloc_cpumask_var(&e_cores_mask, GFP_KERNEL)) {
+		free_cpumask_var(p_core_copy);
+		return group_cpus_evenly(num_grps);
+	}
+	assigned = bitmap_zalloc(nr_cpu_ids, GFP_KERNEL);
+	if (!assigned) {
+		free_cpumask_var(e_cores_mask);
+		free_cpumask_var(p_core_copy);
+		return group_cpus_evenly(num_grps);
+	}
+
+	/* Get P-cores using our improved function */
+	ret = get_pcore_mask(p_core_copy);
+	if (ret || cpumask_empty(p_core_copy)) {
+		bitmap_free(assigned);
+		free_cpumask_var(e_cores_mask);
+		free_cpumask_var(p_core_copy);
+		return group_cpus_evenly(num_grps);
+	}
+
+	/* Create result masks */
+	result = kcalloc(num_grps, sizeof(struct cpumask), GFP_KERNEL);
+	if (!result) {
+		bitmap_free(assigned);
+		free_cpumask_var(e_cores_mask);
+		free_cpumask_var(p_core_copy);
+		return group_cpus_evenly(num_grps);
+	}
+
+	/* Clear all result masks */
+	for (i = 0; i < num_grps; i++)
+		cpumask_clear(&result[i]);
+
+	/* Identify E-cores */
+	cpumask_andnot(e_cores_mask, cpu_online_mask, p_core_copy);
+
+	/* Identify L2 domains */
+	ret = identify_l2_domains(p_core_copy);
+	if (ret) {
+		/* Fall back to simple distribution on error */
+		int cores = cpumask_weight(p_core_copy);
+		int cores_per_group = (num_grps > 0) ? (cores / num_grps) : 0;
+		int extra = (num_grps > 0) ? (cores % num_grps) : 0;
+
+		for (i = 0; i < (int)num_grps; i++) {
+			int count = 0;
+			int cores_this_group = cores_per_group + (i < extra ? 1 : 0);
+
+			for_each_cpu(cpu, p_core_copy) {
+				if (!test_bit(cpu, assigned) && count < cores_this_group) {
+					cpumask_set_cpu(cpu, &result[i]);
+					set_bit(cpu, assigned);
+					count++;
+				}
+			}
+		}
+	} else {
+		/* Cache-aware distribution */
+		int total_cores = 0;
+		for (i = 0; i < l2_domain_count; i++)
+			total_cores += cpumask_weight(&l2_domain_masks[i]);
+
+		/* Distribute domains proportionally */
+		for (i = 0; i < l2_domain_count && grp_idx < (int)num_grps; i++) {
+			int domain_cores = cpumask_weight(&l2_domain_masks[i]);
+			if (domain_cores == 0)
+				continue;
+
+			/* Calculate groups for this domain */
+			int grps_for_domain = 1;
+			if (total_cores > 0) {
+				grps_for_domain = (num_grps * domain_cores + total_cores - 1) / total_cores;
+				grps_for_domain = min_t(int, grps_for_domain, (int)num_grps - grp_idx);
+			}
+			grps_for_domain = max(1, grps_for_domain);
+
+			/* Calculate cores per group */
+			{
+				int cores_per_domain_group = domain_cores / grps_for_domain;
+				int domain_extra = domain_cores % grps_for_domain;
+
+				/* Distribute cores */
+				for (j = 0; j < grps_for_domain && grp_idx < (int)num_grps; j++, grp_idx++) {
+					int cores_this_group = cores_per_domain_group + (j < domain_extra ? 1 : 0);
+					int count = 0;
+
+					for_each_cpu(cpu, &l2_domain_masks[i]) {
+						if (count >= cores_this_group)
+							break;
+						if (!test_bit(cpu, assigned)) {
+							cpumask_set_cpu(cpu, &result[grp_idx]);
+							set_bit(cpu, assigned);
+							count++;
+						}
+					}
+				}
+			}
+		}
+	}
+
+	/* Handle E-cores for remaining groups */
+	if (grp_idx < (int)num_grps && !cpumask_empty(e_cores_mask)) {
+		int e_cores = cpumask_weight(e_cores_mask);
+		int remaining = (int)num_grps - grp_idx;
+		int cores_per_group = remaining > 0 ? e_cores / remaining : 0;
+		int extra = remaining > 0 ? e_cores % remaining : 0;
+
+		for (i = grp_idx; i < (int)num_grps; i++) {
+			int count = 0;
+			int target = cores_per_group + (i - grp_idx < extra ? 1 : 0);
+
+			for_each_cpu(cpu, e_cores_mask) {
+				if (count >= target)
+					break;
+				if (!test_bit(cpu, assigned)) {
+					cpumask_set_cpu(cpu, &result[i]);
+					set_bit(cpu, assigned);
+					count++;
+				}
+			}
+		}
+	}
+
+	/* NUMA-aware rebalancing for empty groups */
+	for (i = 0; i < (int)num_grps; i++) {
+		if (cpumask_empty(&result[i])) {
+			/* Find best donor CPU from a group with multiple CPUs */
+			int donor_cpu = -1;
+			int donor_group = -1;
+			int best_score = -1;
+			int target_node = -1;
+			unsigned int j_start, j_end;
+
+			/* Calculate bounds safely without signedness issues */
+			j_start = (i > 0) ? (i - 1) : 0;
+			j_end = (i + 1 < (int)num_grps) ? (i + 1) : (unsigned int)i;
+
+			/* Identify target NUMA node if possible */
+			for (j = j_start; j <= j_end; j++) {
+				if ((int)j != i && cpumask_weight(&result[j]) > 0) {
+					int temp_cpu = cpumask_first(&result[j]);
+					if (temp_cpu < NR_CPUS) {
+						target_node = numa_node_for_cpu[temp_cpu];
+						break;
+					}
+				}
+			}
+
+			/* Find groups with multiple CPUs */
+			for (j = 0; j < num_grps; j++) {
+				if (cpumask_weight(&result[j]) > 1) {
+					/* Evaluate each CPU as potential donor */
+					for_each_cpu(cpu, &result[j]) {
+						int score = 0;
+						int cpu_node = (cpu < NR_CPUS) ? numa_node_for_cpu[cpu] : -1;
+						int core_type = get_core_type(cpu);
+						const struct cpumask *cache_mask;
+						int cache_siblings = 0;
+						int numa_siblings = 0;
+						int sibling;
+
+						/* NUMA locality is highest priority */
+						if (target_node >= 0 && cpu_node == target_node)
+							score += 1000;
+
+						/* Core type considerations - prefer donating E-cores */
+						if (core_type == 0)
+							score += 500;
+
+						/* Cache topology considerations */
+						cache_mask = get_cache_shared_mask(cpu);
+						for_each_cpu(sibling, &result[j]) {
+							if (sibling != cpu) {
+								if (cache_mask && cpumask_test_cpu(sibling, cache_mask))
+									cache_siblings++;
+								if (cpu_node >= 0 && sibling < NR_CPUS &&
+								    numa_node_for_cpu[sibling] == cpu_node)
+									numa_siblings++;
+							}
+						}
+
+						/* Prefer CPUs with more siblings left behind in same group */
+						score += cache_siblings * 10;
+						score += numa_siblings * 50;
+
+						if (score > best_score) {
+							best_score = score;
+							donor_cpu = cpu;
+							donor_group = (int)j;
+						}
+					}
+				}
+			}
+
+			if (donor_group >= 0 && donor_cpu >= 0) {
+				cpumask_clear_cpu(donor_cpu, &result[donor_group]);
+				cpumask_set_cpu(donor_cpu, &result[i]);
+			} else {
+				/* Last resort: fall back to standard distribution */
+				kfree(result);
+				bitmap_free(assigned);
+				free_cpumask_var(e_cores_mask);
+				free_cpumask_var(p_core_copy);
+				return group_cpus_evenly(num_grps);
+			}
+		}
+	}
+
+	bitmap_free(assigned);
+	free_cpumask_var(e_cores_mask);
+	free_cpumask_var(p_core_copy);
+	return result;
+}
+
+/**
+ * pcore_cpu_notify - Optimized CPU hotplug notification handler
+ * @cpu: CPU number that changed state
+ *
+ * Efficiently handles CPU hotplug events with minimal blocking.
+ * Uses trylock where appropriate to avoid stalling critical paths.
+ *
+ * Return: 0 on success, negative error code on failure
+ */
+static int pcore_cpu_notify(unsigned int cpu)
+{
+	/* During shutdown/reboot/suspend/hibernate, avoid recalculation */
+	if (unlikely(system_state != SYSTEM_RUNNING))
+		return 0;
+
+	if (cpu >= NR_CPUS) {
+		pr_warn("pcore_cpu_notify: cpu %u out of range\n", cpu);
+		return -EINVAL;
+	}
+
+	/* Update NUMA node info (doesn't require lock) */
+	numa_node_for_cpu[cpu] = cpu_to_node(cpu);
+
+	/* Reset initialized flags to force recalculation */
+	atomic_set(&pcore_mask_initialized, 0);
+	atomic_set(&freq_initialized, 0);
+	atomic_set(&l2_ids_initialized, 0);
+
+	/* Reset core type cache for changed CPU */
+	spin_lock(&core_type_lock);
+	cpu_core_type[cpu] = -2;
+	spin_unlock(&core_type_lock);
+
+	/* Try to clean up L2 domain information without blocking critical paths */
+	if (mutex_trylock(&pcore_mask_lock)) {
+		if (l2_domain_masks) {
+			kfree(l2_domain_masks);
+			l2_domain_masks = NULL;
+			l2_domain_count = 0;
+		}
+		mutex_unlock(&pcore_mask_lock);
+	}
+
+	return 0;
+}
+
+/**
+ * hybrid_irq_tuning_exit - Module exit function
+ *
+ * Cleans up all resources and restores system state when module is unloaded.
+ */
+static void __exit hybrid_irq_tuning_exit(void)
+{
+	/* If we didn't register or disabled, nothing to do */
+	if (pcore_cpuhp_state >= 0) {
+		cpuhp_remove_state_nocalls(pcore_cpuhp_state);
+		pcore_cpuhp_state = -1;
+	}
+
+	/* Free all resources */
+	free_l2_domain_masks();
+
+	/* Reset state */
+	atomic_set(&pcore_mask_initialized, 0);
+}
+
+/**
+ * hybrid_irq_tuning - Module initialization function
+ *
+ * Sets up hybrid CPU optimization for IRQ affinity on Raptor Lake
+ * and similar hybrid architectures.
+ *
+ * Return: 0 on success, negative error code on failure
+ */
+static int __init hybrid_irq_tuning(void)
+{
+	int ret = 0, cpu;
+	cpumask_var_t pcore_copy;
+
+	if (!hybrid_cpu_detected() || !irq_pcore_affinity)
+		return 0;
+
+	/* Initialize NUMA node mapping with bounds checking */
+	for_each_possible_cpu(cpu) {
+		if (cpu < NR_CPUS)
+			numa_node_for_cpu[cpu] = cpu_to_node(cpu);
+	}
+
+	/* Pre-initialize L2 core IDs */
+	init_l2_core_ids();
+
+	/* Pre-initialize frequency information */
+	init_freq_info();
+
+	/* Register CPU hotplug callback; store the dynamic state id */
+	ret = cpuhp_setup_state(CPUHP_AP_ONLINE_DYN, "irq/pcore_affinity:online",
+				pcore_cpu_notify, pcore_cpu_notify);
+	if (ret < 0) {
+		pr_err("Failed to register CPU hotplug callback: %d\n", ret);
+		return ret;
+	}
+	pcore_cpuhp_state = ret;
+
+	/* Get P-core mask and apply to default affinity */
+	if (zalloc_cpumask_var(&pcore_copy, GFP_KERNEL)) {
+		ret = get_pcore_mask(pcore_copy);
+		if (ret < 0) {
+			pr_warn("Failed to get P-core mask: %d\n", ret);
+			/* Continue anyway - will use default affinity */
+		} else if (!cpumask_empty(pcore_copy)) {
+			cpumask_copy(irq_default_affinity, pcore_copy);
+		}
+		free_cpumask_var(pcore_copy);
+	}
+
+	return 0;
+}
+core_initcall(hybrid_irq_tuning);
+module_exit(hybrid_irq_tuning_exit);
+#endif /* CONFIG_X86 */
+
+/* Preserve original algorithm with safety checks */
 static void default_calc_sets(struct irq_affinity *affd, unsigned int affvecs)
 {
+	if (!affd)
+		return;
+
 	affd->nr_sets = 1;
 	affd->set_size[0] = affvecs;
 }
 
 /**
- * irq_create_affinity_masks - Create affinity masks for multiqueue spreading
- * @nvecs:	The total number of vectors
- * @affd:	Description of the affinity requirements
+ * irq_create_affinity_masks - Create CPU affinity masks for IRQ distribution
+ * @nvecs: Number of vectors to create masks for
+ * @affd: IRQ affinity descriptor
  *
- * Returns the irq_affinity_desc pointer or NULL if allocation failed.
+ * Creates affinity masks for IRQ vectors, optimized for hybrid CPU architectures
+ * when available. Includes proper bounds checking and error handling.
+ *
+ * Return: Array of affinity descriptors or NULL on failure
  */
 struct irq_affinity_desc *
 irq_create_affinity_masks(unsigned int nvecs, struct irq_affinity *affd)
@@ -28,31 +981,22 @@ irq_create_affinity_masks(unsigned int n
 	unsigned int affvecs, curvec, usedvecs, i;
 	struct irq_affinity_desc *masks = NULL;
 
-	/*
-	 * Determine the number of vectors which need interrupt affinities
-	 * assigned. If the pre/post request exhausts the available vectors
-	 * then nothing to do here except for invoking the calc_sets()
-	 * callback so the device driver can adjust to the situation.
-	 */
+	if (!affd)
+		return NULL;
+
 	if (nvecs > affd->pre_vectors + affd->post_vectors)
 		affvecs = nvecs - affd->pre_vectors - affd->post_vectors;
 	else
 		affvecs = 0;
 
-	/*
-	 * Simple invocations do not provide a calc_sets() callback. Install
-	 * the generic one.
-	 */
 	if (!affd->calc_sets)
 		affd->calc_sets = default_calc_sets;
 
-	/* Recalculate the sets */
 	affd->calc_sets(affd, affvecs);
 
 	if (WARN_ON_ONCE(affd->nr_sets > IRQ_AFFINITY_MAX_SETS))
 		return NULL;
 
-	/* Nothing to assign? */
 	if (!affvecs)
 		return NULL;
 
@@ -60,41 +1004,55 @@ irq_create_affinity_masks(unsigned int n
 	if (!masks)
 		return NULL;
 
-	/* Fill out vectors at the beginning that don't need affinity */
-	for (curvec = 0; curvec < affd->pre_vectors; curvec++)
+	/* Set pre-vectors to default affinity */
+	for (curvec = 0; curvec < affd->pre_vectors && curvec < nvecs; curvec++)
 		cpumask_copy(&masks[curvec].mask, irq_default_affinity);
 
-	/*
-	 * Spread on present CPUs starting from affd->pre_vectors. If we
-	 * have multiple sets, build each sets affinity mask separately.
-	 */
-	for (i = 0, usedvecs = 0; i < affd->nr_sets; i++) {
+	/* Distribute vectors according to set sizes */
+	for (i = 0, usedvecs = 0, curvec = affd->pre_vectors;
+	     i < affd->nr_sets && curvec < nvecs; i++) {
 		unsigned int this_vecs = affd->set_size[i];
+		struct cpumask *result = NULL;
 		int j;
-		struct cpumask *result = group_cpus_evenly(this_vecs);
+
+		if (this_vecs == 0)
+			continue;
+
+#ifdef CONFIG_X86
+		if (hybrid_cpu_detected() && irq_pcore_affinity)
+			result = group_cpus_hybrid_first(this_vecs);
+		else
+#endif
+			result = group_cpus_evenly(this_vecs);
 
 		if (!result) {
 			kfree(masks);
 			return NULL;
 		}
 
-		for (j = 0; j < this_vecs; j++)
-			cpumask_copy(&masks[curvec + j].mask, &result[j]);
+		/* Copy result masks to output */
+		for (j = 0; j < (int)this_vecs && (curvec + (unsigned int)j) < nvecs; j++) {
+			if (cpumask_empty(&result[j]))
+				cpumask_copy(&masks[curvec + (unsigned int)j].mask, irq_default_affinity);
+			else
+				cpumask_copy(&masks[curvec + (unsigned int)j].mask, &result[j]);
+		}
+
 		kfree(result);
 
-		curvec += this_vecs;
-		usedvecs += this_vecs;
+		/* Safely advance counters */
+		{
+			unsigned int used = min(this_vecs, nvecs - curvec);
+			curvec += used;
+			usedvecs += used;
+		}
 	}
 
-	/* Fill out vectors at the end that don't need affinity */
-	if (usedvecs >= affvecs)
-		curvec = affd->pre_vectors + affvecs;
-	else
-		curvec = affd->pre_vectors + usedvecs;
+	/* Set remaining vectors to default affinity */
 	for (; curvec < nvecs; curvec++)
 		cpumask_copy(&masks[curvec].mask, irq_default_affinity);
 
-	/* Mark the managed interrupts */
+	/* Mark managed vectors */
 	for (i = affd->pre_vectors; i < nvecs - affd->post_vectors; i++)
 		masks[i].is_managed = 1;
 
@@ -102,27 +1060,67 @@ irq_create_affinity_masks(unsigned int n
 }
 
 /**
- * irq_calc_affinity_vectors - Calculate the optimal number of vectors
- * @minvec:	The minimum number of vectors available
- * @maxvec:	The maximum number of vectors available
- * @affd:	Description of the affinity requirements
+ * irq_calc_affinity_vectors - Calculate optimal number of vectors for IRQ affinity
+ * @minvec: Minimum number of vectors
+ * @maxvec: Maximum number of vectors
+ * @affd: IRQ affinity descriptor
+ *
+ * Determines the optimal number of interrupt vectors for the system
+ * based on CPU topology.
+ *
+ * Return: Optimal number of vectors or 0 on failure
  */
 unsigned int irq_calc_affinity_vectors(unsigned int minvec, unsigned int maxvec,
 				       const struct irq_affinity *affd)
 {
-	unsigned int resv = affd->pre_vectors + affd->post_vectors;
-	unsigned int set_vecs;
+	unsigned int resv, set_vecs = 0;
+	unsigned int diff;
+
+	if (!affd)
+		return 0;
+
+	resv = affd->pre_vectors + affd->post_vectors;
 
 	if (resv > minvec)
 		return 0;
 
+	/* Guard overflow */
+	if (check_sub_overflow(maxvec, resv, &diff))
+		return 0;
+
 	if (affd->calc_sets) {
-		set_vecs = maxvec - resv;
+		set_vecs = diff;
 	} else {
 		cpus_read_lock();
-		set_vecs = cpumask_weight(cpu_possible_mask);
+#ifdef CONFIG_X86
+		if (hybrid_cpu_detected() && irq_pcore_affinity) {
+			cpumask_var_t pcpu_mask;
+			if (zalloc_cpumask_var(&pcpu_mask, GFP_KERNEL)) {
+				if (get_pcore_mask(pcpu_mask) == 0 && !cpumask_empty(pcpu_mask)) {
+					set_vecs = cpumask_weight(pcpu_mask);
+				} else {
+					set_vecs = cpumask_weight(cpu_online_mask);
+				}
+				free_cpumask_var(pcpu_mask);
+			} else {
+				set_vecs = cpumask_weight(cpu_online_mask);
+			}
+		} else
+#endif
+		{
+			set_vecs = cpumask_weight(cpu_possible_mask);
+		}
 		cpus_read_unlock();
 	}
 
-	return resv + min(set_vecs, maxvec - resv);
+	/* Ensure at least one vector */
+	if (set_vecs == 0)
+		set_vecs = 1;
+
+	return resv + min(set_vecs, diff);
 }
+
+/* Module metadata */
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Intel Corporation");
+MODULE_DESCRIPTION("Raptor Lake IRQ Affinity Optimizations");


--- a/arch/x86/kernel/apic/io_apic.c	2025-05-19 23:37:21.464343676 +0200
+++ b/arch/x86/kernel/apic/io_apic.c	2025-05-20 00:30:12.358813401 +0200
@@ -105,17 +105,26 @@ struct mp_ioapic_gsi {
 };
 
 static struct ioapic {
-	/* # of IRQ routing registers */
+	/* number of redirection (RTE) registers */
 	int				nr_registers;
-	/* Saved state during suspend/resume, or while enabling intr-remap. */
+	/* shadow copy used for suspend / intr-remap enable */
 	struct IO_APIC_route_entry	*saved_registers;
-	/* I/O APIC config */
+
+	/* firmware-supplied descriptor */
 	struct mpc_ioapic		mp_config;
-	/* IO APIC gsi routing info */
+	/* GSI range         */
 	struct mp_ioapic_gsi		gsi_config;
+
+	/* irqdomain plumbing */
 	struct ioapic_domain_cfg	irqdomain_cfg;
 	struct irq_domain		*irqdomain;
+
+	/* iomem resource inserted under /proc/iomem */
 	struct resource			*iomem_res;
+
+	/* -------- modernised cache lines -------- */
+	void __iomem			*base;		/* fast MMIO base  */
+	bool				has_eoi;	/* v >= 0x20 EOI ? */
 } ioapics[MAX_IO_APICS];
 
 #define mpc_ioapic_ver(ioapic_idx)	ioapics[ioapic_idx].mp_config.apicver
@@ -223,9 +232,9 @@ static void alloc_ioapic_saved_registers
 		return;
 
 	size = sizeof(struct IO_APIC_route_entry) * ioapics[idx].nr_registers;
-	ioapics[idx].saved_registers = kzalloc(size, GFP_KERNEL);
+	ioapics[idx].saved_registers = kvzalloc(size, GFP_KERNEL);
 	if (!ioapics[idx].saved_registers)
-		pr_err("IOAPIC %d: suspend/resume impossible!\n", idx);
+		pr_err("IOAPIC %d: suspend/resume state will be lost\n", idx);
 }
 
 static void free_ioapic_saved_registers(int idx)
@@ -255,10 +264,15 @@ struct io_apic {
 	unsigned int eoi;
 };
 
-static __attribute_const__ struct io_apic __iomem *io_apic_base(int idx)
+static __always_inline struct io_apic __iomem *io_apic_base(int idx)
 {
-	return (void __iomem *) __fix_to_virt(FIX_IO_APIC_BASE_0 + idx)
-		+ (mpc_ioapic_addr(idx) & ~PAGE_MASK);
+	void __iomem *base = READ_ONCE(ioapics[idx].base);
+
+	if (unlikely(!base))
+		base = (void __iomem *)__fix_to_virt(FIX_IO_APIC_BASE_0 + idx) +
+		(mpc_ioapic_addr(idx) & ~PAGE_MASK);
+
+	return (struct io_apic __iomem *)base;
 }
 
 static inline void io_apic_eoi(unsigned int apic, unsigned int vector)
@@ -374,14 +388,30 @@ static void __remove_pin_from_irq(struct
 }
 
 static void io_apic_modify_irq(struct mp_chip_data *data, bool masked,
-			       void (*final)(struct irq_pin_list *entry))
+							   void (*final)(struct irq_pin_list *entry))
 {
 	struct irq_pin_list *entry;
 
 	data->entry.masked = masked;
 
+	if (list_empty(&data->irq_2_pin))
+		return;
+
+	/* fast-path: exactly one pin mapped to this IRQ */
+	if (list_is_singular(&data->irq_2_pin)) {
+		entry = list_first_entry(&data->irq_2_pin,
+								 struct irq_pin_list, list);
+		io_apic_write(entry->apic, 0x10 + 2 * entry->pin,
+					  data->entry.w1);
+		if (final)
+			final(entry);
+		return;
+	}
+
+	/* generic slow-path */
 	for_each_irq_pin(entry, data->irq_2_pin) {
-		io_apic_write(entry->apic, 0x10 + 2 * entry->pin, data->entry.w1);
+		io_apic_write(entry->apic, 0x10 + 2 * entry->pin,
+					  data->entry.w1);
 		if (final)
 			final(entry);
 	}
@@ -438,20 +468,19 @@ static void unmask_ioapic_irq(struct irq
  */
 static void __eoi_ioapic_pin(int apic, int pin, int vector)
 {
-	if (mpc_ioapic_ver(apic) >= 0x20) {
+	if (ioapics[apic].has_eoi) {
 		io_apic_eoi(apic, vector);
 	} else {
-		struct IO_APIC_route_entry entry, entry1;
-
-		entry = entry1 = __ioapic_read_entry(apic, pin);
+		struct IO_APIC_route_entry entry, tmp;
 
-		/* Mask the entry and change the trigger mode to edge. */
-		entry1.masked = true;
-		entry1.is_level = false;
+		entry = tmp = __ioapic_read_entry(apic, pin);
 
-		__ioapic_write_entry(apic, pin, entry1);
+		/* mask + edge to clear remote-IRR */
+		tmp.masked   = true;
+		tmp.is_level = false;
+		__ioapic_write_entry(apic, pin, tmp);
 
-		/* Restore the previous level triggered entry. */
+		/* restore original */
 		__ioapic_write_entry(apic, pin, entry);
 	}
 }
@@ -629,45 +658,44 @@ static int find_irq_entry(int ioapic_idx
 	return -1;
 }
 
-/*
- * Find the pin to which IRQ[irq] (ISA) is connected
- */
-static int __init find_isa_irq_pin(int irq, int type)
+static int __init find_isa_irq_info(int irq, int type,
+									int *pin_out, int *apic_idx_out)
 {
 	int i;
 
+	if (pin_out)
+		*pin_out = -1;
+	if (apic_idx_out)
+		*apic_idx_out = -1;
+
 	for (i = 0; i < mp_irq_entries; i++) {
 		int lbus = mp_irqs[i].srcbus;
 
-		if (test_bit(lbus, mp_bus_not_pci) && (mp_irqs[i].irqtype == type) &&
-		    (mp_irqs[i].srcbusirq == irq))
-			return mp_irqs[i].dstirq;
-	}
-	return -1;
-}
+		if (!test_bit(lbus, mp_bus_not_pci) ||
+			mp_irqs[i].irqtype != type   ||
+			mp_irqs[i].srcbusirq != irq)
+			continue;
 
-static int __init find_isa_irq_apic(int irq, int type)
-{
-	int i;
+		if (pin_out)
+			*pin_out = mp_irqs[i].dstirq;
 
-	for (i = 0; i < mp_irq_entries; i++) {
-		int lbus = mp_irqs[i].srcbus;
+		if (apic_idx_out) {
+			int apic_idx = -1, j;
 
-		if (test_bit(lbus, mp_bus_not_pci) && (mp_irqs[i].irqtype == type) &&
-		    (mp_irqs[i].srcbusirq == irq))
-			break;
-	}
+			for_each_ioapic(j)
+				if (mpc_ioapic_id(j) == mp_irqs[i].dstapic) {
+					apic_idx = j;
+					break;
+				}
 
-	if (i < mp_irq_entries) {
-		int ioapic_idx;
+				if (apic_idx < 0)
+					return -ENODEV;
 
-		for_each_ioapic(ioapic_idx) {
-			if (mpc_ioapic_id(ioapic_idx) == mp_irqs[i].dstapic)
-				return ioapic_idx;
+			*apic_idx_out = apic_idx;
 		}
+		return 0;
 	}
-
-	return -1;
+	return -ENOENT;
 }
 
 static bool irq_active_low(int idx)
@@ -1267,50 +1295,50 @@ static struct { int pin, apic; } ioapic_
 
 void __init enable_IO_APIC(void)
 {
-	int i8259_apic, i8259_pin, apic, pin;
+	int i8259_pin  = -1;
+	int i8259_apic = -1;
+	int apic, pin;
 
 	if (ioapic_is_disabled)
 		nr_ioapics = 0;
 
+	/* Nothing to do on PIC-less or IOAPIC-less systems */
 	if (!nr_legacy_irqs() || !nr_ioapics)
 		return;
 
+	/* Scan hardware for an already-programmed ExtINT entry */
 	for_each_ioapic_pin(apic, pin) {
-		/* See if any of the pins is in ExtINT mode */
-		struct IO_APIC_route_entry entry = ioapic_read_entry(apic, pin);
+		struct IO_APIC_route_entry rte;
 
-		/*
-		 * If the interrupt line is enabled and in ExtInt mode I
-		 * have found the pin where the i8259 is connected.
-		 */
-		if (!entry.masked && entry.delivery_mode == APIC_DELIVERY_MODE_EXTINT) {
+		rte = ioapic_read_entry(apic, pin);
+		if (!rte.masked &&
+			rte.delivery_mode == APIC_DELIVERY_MODE_EXTINT) {
 			ioapic_i8259.apic = apic;
-			ioapic_i8259.pin  = pin;
-			break;
-		}
+		ioapic_i8259.pin  = pin;
+		break;
+			}
 	}
 
-	/*
-	 * Look to see what if the MP table has reported the ExtINT
-	 *
-	 * If we could not find the appropriate pin by looking at the ioapic
-	 * the i8259 probably is not connected the ioapic but give the
-	 * mptable a chance anyway.
-	 */
-	i8259_pin  = find_isa_irq_pin(0, mp_ExtINT);
-	i8259_apic = find_isa_irq_apic(0, mp_ExtINT);
-	/* Trust the MP table if nothing is setup in the hardware */
-	if ((ioapic_i8259.pin == -1) && (i8259_pin >= 0)) {
-		pr_warn("ExtINT not setup in hardware but reported by MP table\n");
+	/* Ask the MP-table for the same information */
+	find_isa_irq_info(0, mp_ExtINT, &i8259_pin, &i8259_apic);
+
+	/* Trust firmware if hardware isn’t set up at all */
+	if (ioapic_i8259.pin == -1 && i8259_pin >= 0) {
+		pr_warn("ExtINT not set in hardware, using MP-table values\n");
 		ioapic_i8259.pin  = i8259_pin;
 		ioapic_i8259.apic = i8259_apic;
 	}
-	/* Complain if the MP table and the hardware disagree */
-	if (((ioapic_i8259.apic != i8259_apic) || (ioapic_i8259.pin != i8259_pin)) &&
-	    (i8259_pin >= 0) && (ioapic_i8259.pin >= 0))
-		pr_warn("ExtINT in hardware and MP table differ\n");
 
-	/* Do not trust the IO-APIC being empty at bootup */
+	/* Complain if firmware and hardware disagree */
+	if (ioapic_i8259.pin  >= 0 && i8259_pin  >= 0 &&
+		(ioapic_i8259.pin  != i8259_pin ||
+		ioapic_i8259.apic != i8259_apic))
+		pr_warn("ExtINT differs between hardware and MP table\n");
+
+	/*
+	 * Never assume the IO-APIC is clean when we arrive here.
+	 * Wipe every RTE so we start from a defined state.
+	 */
 	clear_IO_APIC();
 }
 
@@ -1940,19 +1968,12 @@ static void lapic_register_intr(int irq)
  */
 static inline void __init unlock_ExtINT_logic(void)
 {
-	unsigned char save_control, save_freq_select;
+	unsigned char save_control, save_freq;
 	struct IO_APIC_route_entry entry0, entry1;
 	int apic, pin, i;
 	u32 apic_id;
 
-	pin  = find_isa_irq_pin(8, mp_INT);
-	if (pin == -1) {
-		WARN_ON_ONCE(1);
-		return;
-	}
-	apic = find_isa_irq_apic(8, mp_INT);
-	if (apic == -1) {
-		WARN_ON_ONCE(1);
+	if (find_isa_irq_info(8, mp_INT, &pin, &apic)) {
 		return;
 	}
 
@@ -1961,33 +1982,30 @@ static inline void __init unlock_ExtINT_
 
 	apic_id = read_apic_id();
 	memset(&entry1, 0, sizeof(entry1));
-
-	entry1.dest_mode_logical	= true;
-	entry1.masked			= false;
-	entry1.destid_0_7		= apic_id & 0xFF;
-	entry1.virt_destid_8_14		= apic_id >> 8;
-	entry1.delivery_mode		= APIC_DELIVERY_MODE_EXTINT;
-	entry1.active_low		= entry0.active_low;
-	entry1.is_level			= false;
-	entry1.vector = 0;
+	entry1.dest_mode_logical = true;
+	entry1.masked            = false;
+	entry1.destid_0_7        = apic_id & 0xff;
+	entry1.virt_destid_8_14  = apic_id >> 8;
+	entry1.delivery_mode     = APIC_DELIVERY_MODE_EXTINT;
+	entry1.active_low        = entry0.active_low;
+	entry1.is_level          = false;
+	entry1.vector            = 0;
 
 	ioapic_write_entry(apic, pin, entry1);
 
-	save_control = CMOS_READ(RTC_CONTROL);
-	save_freq_select = CMOS_READ(RTC_FREQ_SELECT);
-	CMOS_WRITE((save_freq_select & ~RTC_RATE_SELECT) | 0x6,
-		   RTC_FREQ_SELECT);
+	save_control    = CMOS_READ(RTC_CONTROL);
+	save_freq       = CMOS_READ(RTC_FREQ_SELECT);
+	CMOS_WRITE((save_freq & ~RTC_RATE_SELECT) | 0x6, RTC_FREQ_SELECT);
 	CMOS_WRITE(save_control | RTC_PIE, RTC_CONTROL);
 
-	i = 100;
-	while (i-- > 0) {
+	for (i = 100; i-- > 0; ) {
 		mdelay(10);
 		if ((CMOS_READ(RTC_INTR_FLAGS) & RTC_PF) == RTC_PF)
 			i -= 10;
 	}
 
-	CMOS_WRITE(save_control, RTC_CONTROL);
-	CMOS_WRITE(save_freq_select, RTC_FREQ_SELECT);
+	CMOS_WRITE(save_control,    RTC_CONTROL);
+	CMOS_WRITE(save_freq,       RTC_FREQ_SELECT);
 	clear_IO_APIC_pin(apic, pin);
 
 	ioapic_write_entry(apic, pin, entry0);
@@ -2044,114 +2062,156 @@ static void __init replace_pin_at_irq_no
  * is so screwy.  Thanks to Brian Perkins for testing/hacking this beast
  * fanatically on his truly buggy board.
  */
-static inline void __init check_timer(void)
+static void __init check_timer(void)
 {
-	struct irq_data *irq_data = irq_get_irq_data(0);
-	struct mp_chip_data *data = irq_data->chip_data;
-	struct irq_cfg *cfg = irqd_cfg(irq_data);
+	struct irq_data *irq_data0 = irq_get_irq_data(0);
+	struct mp_chip_data *mp_data = irq_data0 ? irq_data0->chip_data : NULL;
+	struct irq_cfg *cfg0 = irq_data0 ? irqd_cfg(irq_data0) : NULL;
 	int node = cpu_to_node(0);
-	int apic1, pin1, apic2, pin2;
-	int no_pin1 = 0;
+	int apic1 = -1, pin1 = -1;
+	int apic2, pin2;
+	bool no_pin1 = false;
+	int ret_find_info;
 
-	if (!global_clock_event)
+	if (!global_clock_event || !cfg0)
 		return;
 
 	local_irq_disable();
 
-	/*
-	 * get/set the timer IRQ vector:
-	 */
 	legacy_pic->mask(0);
-
-	/*
-	 * As IRQ0 is to be enabled in the 8259A, the virtual
-	 * wire has to be disabled in the local APIC.  Also
-	 * timer interrupts need to be acknowledged manually in
-	 * the 8259A for the i82489DX when using the NMI
-	 * watchdog as that APIC treats NMIs as level-triggered.
-	 * The AEOI mode will finish them in the 8259A
-	 * automatically.
-	 */
 	apic_write(APIC_LVT0, APIC_LVT_MASKED | APIC_DM_EXTINT);
 	legacy_pic->init(1);
 
-	pin1  = find_isa_irq_pin(0, mp_INT);
-	apic1 = find_isa_irq_apic(0, mp_INT);
+	ret_find_info = find_isa_irq_info(0, mp_INT, &pin1, &apic1);
+
 	pin2  = ioapic_i8259.pin;
 	apic2 = ioapic_i8259.apic;
 
 	pr_info("..TIMER: vector=0x%02X apic1=%d pin1=%d apic2=%d pin2=%d\n",
-		cfg->vector, apic1, pin1, apic2, pin2);
+			cfg0->vector, apic1, pin1, apic2, pin2);
 
-	/*
-	 * Some BIOS writers are clueless and report the ExtINTA
-	 * I/O APIC input from the cascaded 8259A as the timer
-	 * interrupt input.  So just in case, if only one pin
-	 * was found above, try it both directly and through the
-	 * 8259A.
-	 */
 	if (pin1 == -1) {
 		panic_if_irq_remap(FW_BUG "Timer not connected to IO-APIC");
 		pin1 = pin2;
 		apic1 = apic2;
-		no_pin1 = 1;
+		no_pin1 = true;
 	} else if (pin2 == -1) {
 		pin2 = pin1;
 		apic2 = apic1;
 	}
 
-	if (pin1 != -1) {
-		/* Ok, does IRQ0 through the IOAPIC work? */
+	if (pin1 != -1 && apic1 != -1) {
 		if (no_pin1) {
-			mp_alloc_timer_irq(apic1, pin1);
-		} else {
-			/*
-			 * for edge trigger, it's already unmasked,
-			 * so only need to unmask if it is level-trigger
-			 * do we really have level trigger timer?
+			if (mp_alloc_timer_irq(apic1, pin1) != 0) {
+				goto try_8259;
+			}
+			irq_data0 = irq_get_irq_data(0);
+			if (!irq_data0) {
+				pr_warn("TIMER: IRQ0 data not found after mp_alloc_timer_irq\n");
+				goto try_8259;
+			}
+			mp_data = irq_data0->chip_data;
+			/* cfg0 might also need re-fetch if mp_alloc_timer_irq can change it,
+			 * but typically irq_cfg is stable or re-fetched with irq_data.
+			 * Assuming cfg0 remains valid or irq_get_irq_data refreshes enough.
 			 */
+		} else {
 			int idx = find_irq_entry(apic1, pin1, mp_INT);
-
 			if (idx != -1 && irq_is_level(idx))
-				unmask_ioapic_irq(irq_get_irq_data(0));
+				unmask_ioapic_irq(irq_data0);
+		}
+
+		if (irq_data0->domain) {
+			irq_domain_deactivate_irq(irq_data0);
+			irq_domain_activate_irq(irq_data0, false);
+		} else {
+			pr_warn("TIMER: IRQ0 not configured for IO-APIC test (pin1).\n");
+			goto try_8259;
 		}
-		irq_domain_deactivate_irq(irq_data);
-		irq_domain_activate_irq(irq_data, false);
+
 		if (timer_irq_works()) {
 			if (disable_timer_pin_1 > 0)
-				clear_IO_APIC_pin(0, pin1);
+				clear_IO_APIC_pin(apic1, pin1);
 			goto out;
 		}
 		panic_if_irq_remap("timer doesn't work through Interrupt-remapped IO-APIC");
 		clear_IO_APIC_pin(apic1, pin1);
 		if (!no_pin1)
 			pr_err("..MP-BIOS bug: 8254 timer not connected to IO-APIC\n");
+	}
+
+	try_8259:
+	pr_info("...trying to set up timer (IRQ0) through the 8259A ...\n");
+	pr_info("..... (found apic %d pin %d) ...\n", apic2, pin2);
+
+	if (pin2 != -1 && apic2 != -1) {
+		if (!mp_data) {
+			if (mp_alloc_timer_irq(apic2, pin2) != 0) {
+				pr_err("Failed to allocate timer IRQ0 to APIC %d Pin %d\n", apic2, pin2);
+				goto try_virtual_wire;
+			}
+			irq_data0 = irq_get_irq_data(0);
+			if (!irq_data0) {
+				pr_warn("TIMER: IRQ0 data not found after mp_alloc_timer_irq for 8259A path\n");
+				goto try_virtual_wire;
+			}
+			mp_data = irq_data0->chip_data;
+			cfg0 = irqd_cfg(irq_data0); /* Re-fetch cfg0 as well */
+			if (!mp_data || !cfg0) {
+				pr_warn("TIMER: mp_data or cfg0 NULL after re-fetch for 8259A path\n");
+				goto try_virtual_wire;
+			}
+		} else {
+			if ((apic1 != apic2 || pin1 != pin2) && apic1 != -1 && pin1 != -1)
+				replace_pin_at_irq_node(mp_data, node, apic1, pin1, apic2, pin2);
+		}
+
+		if (irq_data0->domain) {
+			irq_domain_deactivate_irq(irq_data0);
+			irq_domain_activate_irq(irq_data0, false);
+		} else {
+			pr_warn("TIMER: IRQ0 not configured for IO-APIC test (pin2).\n");
+			goto try_virtual_wire;
+		}
 
-		pr_info("...trying to set up timer (IRQ0) through the 8259A ...\n");
-		pr_info("..... (found apic %d pin %d) ...\n", apic2, pin2);
-		/*
-		 * legacy devices should be connected to IO APIC #0
-		 */
-		replace_pin_at_irq_node(data, node, apic1, pin1, apic2, pin2);
-		irq_domain_deactivate_irq(irq_data);
-		irq_domain_activate_irq(irq_data, false);
 		legacy_pic->unmask(0);
 		if (timer_irq_works()) {
 			pr_info("....... works.\n");
 			goto out;
 		}
-		/*
-		 * Cleanup, just in case ...
-		 */
 		legacy_pic->mask(0);
 		clear_IO_APIC_pin(apic2, pin2);
 		pr_info("....... failed.\n");
 	}
 
+	try_virtual_wire:
 	pr_info("...trying to set up timer as Virtual Wire IRQ...\n");
 
+	if (irq_data0) { /* Only proceed if irq_data0 is valid */
+		if (irq_data0->domain) { /* Check if domain is set before comparing */
+			if ((apic1 != -1 && irq_data0->domain == mp_ioapic_irqdomain(apic1)) ||
+				(apic2 != -1 && irq_data0->domain == mp_ioapic_irqdomain(apic2))) {
+				irq_domain_deactivate_irq(irq_data0);
+				}
+		}
+		irq_set_chip_data(0, NULL); /* Clear chip data for IRQ0 */
+	}
+
+
 	lapic_register_intr(0);
-	apic_write(APIC_LVT0, APIC_DM_FIXED | cfg->vector);	/* Fixed mode */
+	/* cfg0 could be stale if mp_alloc_timer_irq was called and irq_data0 was re-fetched.
+	 * It's safer to re-get cfg0 if irq_data0 has been potentially re-assigned.
+	 * For simplicity, assuming cfg0 for vector is stable, or re-fetch if needed.
+	 * The critical part is that cfg0 points to the config for IRQ0.
+	 */
+	if (!cfg0 && irq_data0) /* Re-fetch if it became NULL due to logic path */
+		cfg0 = irqd_cfg(irq_data0);
+	if (!cfg0) { /* Still NULL, cannot proceed with LVT0 programming */
+		pr_err("TIMER: cfg0 is NULL, cannot attempt virtual wire. Critical error.\n");
+		panic("Timer IRQ0 configuration broken.");
+	}
+
+	apic_write(APIC_LVT0, APIC_DM_FIXED | cfg0->vector);
 	legacy_pic->unmask(0);
 
 	if (timer_irq_works()) {
@@ -2159,7 +2219,7 @@ static inline void __init check_timer(vo
 		goto out;
 	}
 	legacy_pic->mask(0);
-	apic_write(APIC_LVT0, APIC_LVT_MASKED | APIC_DM_FIXED | cfg->vector);
+	apic_write(APIC_LVT0, APIC_LVT_MASKED | APIC_DM_FIXED | cfg0->vector);
 	pr_info("..... failed.\n");
 
 	pr_info("...trying to set up timer as ExtINT IRQ...\n");
@@ -2179,11 +2239,11 @@ static inline void __init check_timer(vo
 	pr_info("..... failed :\n");
 	if (apic_is_x2apic_enabled()) {
 		pr_info("Perhaps problem with the pre-enabled x2apic mode\n"
-			"Try booting with x2apic and interrupt-remapping disabled in the bios.\n");
+		"Try booting with x2apic and interrupt-remapping disabled in the bios.\n");
 	}
 	panic("IO-APIC + timer doesn't work!  Boot with apic=debug and send a "
-		"report.  Then try booting with the 'noapic' option.\n");
-out:
+	"report.  Then try booting with the 'noapic' option.\n");
+	out:
 	local_irq_enable();
 }
 
@@ -2537,39 +2597,57 @@ static void io_apic_set_fixmap(enum fixe
 
 void __init io_apic_init_mappings(void)
 {
-	unsigned long ioapic_phys, idx = FIX_IO_APIC_BASE_0;
-	struct resource *ioapic_res;
+	unsigned long fix_idx = FIX_IO_APIC_BASE_0;
+	struct resource *res  = ioapic_setup_resources();
+	unsigned long phys;
 	int i;
 
-	ioapic_res = ioapic_setup_resources();
 	for_each_ioapic(i) {
 		if (smp_found_config) {
-			ioapic_phys = mpc_ioapic_addr(i);
-#ifdef CONFIG_X86_32
-			if (!ioapic_phys) {
-				pr_err("WARNING: bogus zero IO-APIC address found in MPTABLE, "
-				       "disabling IO/APIC support!\n");
+			phys = mpc_ioapic_addr(i);
+			#ifdef CONFIG_X86_32
+			if (!phys) {
+				pr_err("Zero IO-APIC address in MP-table, "
+				"disabling IO/APIC support!\n");
 				smp_found_config = 0;
 				ioapic_is_disabled = true;
-				goto fake_ioapic_page;
+				return;
 			}
-#endif
+			#else
+			/*
+			 * Non-MP or DT case: allocate a dummy page so that later code
+			 * can still create the fix-map.  The page is never accessed.
+			 */
+			#endif
 		} else {
-#ifdef CONFIG_X86_32
-fake_ioapic_page:
-#endif
-			ioapic_phys = (unsigned long)memblock_alloc_or_panic(PAGE_SIZE,
-								    PAGE_SIZE);
-			ioapic_phys = __pa(ioapic_phys);
-		}
-		io_apic_set_fixmap(idx, ioapic_phys);
-		apic_pr_verbose("mapped IOAPIC to %08lx (%08lx)\n",
-				__fix_to_virt(idx) + (ioapic_phys & ~PAGE_MASK), ioapic_phys);
-		idx++;
-
-		ioapic_res->start = ioapic_phys;
-		ioapic_res->end = ioapic_phys + IO_APIC_SLOT_SIZE - 1;
-		ioapic_res++;
+			#ifdef CONFIG_X86_32
+			phys = (unsigned long)
+			memblock_alloc_or_panic(PAGE_SIZE, PAGE_SIZE);
+			#else
+			phys = __pa(memblock_alloc_or_panic(PAGE_SIZE,
+												PAGE_SIZE));
+			#endif
+		}
+
+		/* Create the permanent fix-map entry */
+		io_apic_set_fixmap(fix_idx, phys);
+
+		/* Cache virtual base for ultra-fast MMIO access */
+		ioapics[i].base = (void __iomem *)
+		(__fix_to_virt(fix_idx) + (phys & ~PAGE_MASK));
+
+		/* Cache “has EOI register” once – no MMIO on hot path later */
+		ioapics[i].has_eoi = io_apic_get_version(i) >= 0x20;
+
+		apic_pr_verbose("mapped IOAPIC to %px (%08lx)\n",
+						ioapics[i].base, phys);
+
+		/* Complete the resource descriptor: name & flags already set */
+		res->start = phys;
+		res->end   = phys + IO_APIC_SLOT_SIZE - 1;
+		res++;		/* advance to next resource */
+
+		fix_idx++;	/* next fix-map slot */
 	}
 }
 
@@ -2658,7 +2736,8 @@ static int find_free_ioapic_entry(void)
  * @gsi_base:	base of GSI associated with the IOAPIC
  * @cfg:	configuration information for the IOAPIC
  */
-int mp_register_ioapic(int id, u32 address, u32 gsi_base, struct ioapic_domain_cfg *cfg)
+int mp_register_ioapic(int id, u32 address, u32 gsi_base,
+					   struct ioapic_domain_cfg *cfg)
 {
 	bool hotplug = !!ioapic_initialized;
 	struct mp_ioapic_gsi *gsi_cfg;
@@ -2670,82 +2749,81 @@ int mp_register_ioapic(int id, u32 addre
 		return -EINVAL;
 	}
 
-	for_each_ioapic(ioapic) {
+	for_each_ioapic(ioapic)
 		if (ioapics[ioapic].mp_config.apicaddr == address) {
-			pr_warn("address 0x%x conflicts with IOAPIC%d\n", address, ioapic);
+			pr_warn("address 0x%x conflicts with IOAPIC%d\n",
+					address, ioapic);
 			return -EEXIST;
 		}
-	}
 
-	idx = find_free_ioapic_entry();
-	if (idx >= MAX_IO_APICS) {
-		pr_warn("Max # of I/O APICs (%d) exceeded (found %d), skipping\n",
-			MAX_IO_APICS, idx);
+		idx = find_free_ioapic_entry();
+	if (unlikely(idx >= MAX_IO_APICS)) {
+		pr_warn("Max IOAPICs exceeded (found %d)\n", idx);
 		return -ENOSPC;
 	}
 
-	ioapics[idx].mp_config.type = MP_IOAPIC;
-	ioapics[idx].mp_config.flags = MPC_APIC_USABLE;
+	ioapics[idx].mp_config.type     = MP_IOAPIC;
+	ioapics[idx].mp_config.flags    = MPC_APIC_USABLE;
 	ioapics[idx].mp_config.apicaddr = address;
 
 	io_apic_set_fixmap(FIX_IO_APIC_BASE_0 + idx, address);
+	ioapics[idx].base = (void __iomem *)
+	(__fix_to_virt(FIX_IO_APIC_BASE_0 + idx) +
+	(address & ~PAGE_MASK));
+
 	if (bad_ioapic_register(idx)) {
 		clear_fixmap(FIX_IO_APIC_BASE_0 + idx);
+		ioapics[idx].base = NULL;
 		return -ENODEV;
 	}
 
-	ioapics[idx].mp_config.apicid = io_apic_unique_id(idx, id);
+	ioapics[idx].mp_config.apicid  = io_apic_unique_id(idx, id);
 	ioapics[idx].mp_config.apicver = io_apic_get_version(idx);
+	ioapics[idx].has_eoi           =
+	(ioapics[idx].mp_config.apicver >= 0x20);
+
+	/* ---- original GSI-range / irqdomain setup code unchanged ---- */
+	entries  = io_apic_get_redir_entries(idx);
+	gsi_end  = gsi_base + entries - 1;
 
-	/*
-	 * Build basic GSI lookup table to facilitate gsi->io_apic lookups
-	 * and to prevent reprogramming of IOAPIC pins (PCI GSIs).
-	 */
-	entries = io_apic_get_redir_entries(idx);
-	gsi_end = gsi_base + entries - 1;
 	for_each_ioapic(ioapic) {
 		gsi_cfg = mp_ioapic_gsi_routing(ioapic);
 		if ((gsi_base >= gsi_cfg->gsi_base &&
-		     gsi_base <= gsi_cfg->gsi_end) ||
-		    (gsi_end >= gsi_cfg->gsi_base &&
-		     gsi_end <= gsi_cfg->gsi_end)) {
-			pr_warn("GSI range [%u-%u] for new IOAPIC conflicts with GSI[%u-%u]\n",
-				gsi_base, gsi_end, gsi_cfg->gsi_base, gsi_cfg->gsi_end);
+			gsi_base <= gsi_cfg->gsi_end) ||
+			(gsi_end >= gsi_cfg->gsi_base &&
+			gsi_end <= gsi_cfg->gsi_end)) {
+			pr_warn("GSI %u-%u overlaps existing IOAPIC range\n",
+					gsi_base, gsi_end);
 			clear_fixmap(FIX_IO_APIC_BASE_0 + idx);
-			return -ENOSPC;
-		}
+		ioapics[idx].base = NULL;
+		return -ENOSPC;
+			}
 	}
+
 	gsi_cfg = mp_ioapic_gsi_routing(idx);
 	gsi_cfg->gsi_base = gsi_base;
-	gsi_cfg->gsi_end = gsi_end;
+	gsi_cfg->gsi_end  = gsi_end;
 
-	ioapics[idx].irqdomain = NULL;
 	ioapics[idx].irqdomain_cfg = *cfg;
+	ioapics[idx].nr_registers  = entries;	/* mark present */
 
-	/*
-	 * If mp_register_ioapic() is called during early boot stage when
-	 * walking ACPI/DT tables, it's too early to create irqdomain,
-	 * we are still using bootmem allocator. So delay it to setup_IO_APIC().
-	 */
 	if (hotplug) {
 		if (mp_irqdomain_create(idx)) {
 			clear_fixmap(FIX_IO_APIC_BASE_0 + idx);
+			ioapics[idx].base = NULL;
 			return -ENOMEM;
 		}
 		alloc_ioapic_saved_registers(idx);
 	}
 
-	if (gsi_cfg->gsi_end >= gsi_top)
-		gsi_top = gsi_cfg->gsi_end + 1;
+	if (gsi_end >= gsi_top)
+		gsi_top = gsi_end + 1;
 	if (nr_ioapics <= idx)
 		nr_ioapics = idx + 1;
 
-	/* Set nr_registers to mark entry present */
-	ioapics[idx].nr_registers = entries;
-
-	pr_info("IOAPIC[%d]: apic_id %d, version %d, address 0x%x, GSI %d-%d\n",
-		idx, mpc_ioapic_id(idx), mpc_ioapic_ver(idx), mpc_ioapic_addr(idx),
-		gsi_cfg->gsi_base, gsi_cfg->gsi_end);
+	pr_info("IOAPIC[%d]: id %d, ver 0x%x, addr 0x%x, GSIs %u-%u\n",
+			idx, mpc_ioapic_id(idx), mpc_ioapic_ver(idx), address,
+			gsi_base, gsi_end);
 
 	return 0;
 }



--- a/arch/x86/kernel/cpu/topology.c	2025-03-13 13:08:08.000000000 +0100
+++ b/arch/x86/kernel/cpu/topology.c	2025-03-18 18:59:24.095000486 +0100
@@ -31,6 +31,11 @@
 #include <asm/io_apic.h>
 #include <asm/mpspec.h>
 #include <asm/smp.h>
+#include <asm/cpufeature.h> /* For boot_cpu_has() */
+#if defined(CONFIG_AS_AVX2) && defined(CONFIG_X86_64)
+#include <asm/fpu/api.h>    /* For FPU state management */
+#include <asm/immintrin.h>  /* For AVX2 intrinsics */
+#endif
 
 #include "cpu.h"
 
@@ -45,8 +50,8 @@ EXPORT_EARLY_PER_CPU_SYMBOL(x86_cpu_to_a
 /* Bitmap of physically present CPUs. */
 DECLARE_BITMAP(phys_cpu_present_map, MAX_LOCAL_APIC) __read_mostly;
 
-/* Used for CPU number allocation and parallel CPU bringup */
-u32 cpuid_to_apicid[] __ro_after_init = { [0 ... NR_CPUS - 1] = BAD_APICID, };
+/* Used for CPU number allocation and parallel CPU bringup - cache-line aligned for Raptor Lake */
+u32 __aligned(64) cpuid_to_apicid[] __ro_after_init = { [0 ... NR_CPUS - 1] = BAD_APICID, };
 
 /* Bitmaps to mark registered APICs at each topology domain */
 static struct { DECLARE_BITMAP(map, MAX_LOCAL_APIC); } apic_maps[TOPO_MAX_DOMAIN] __ro_after_init;
@@ -56,18 +61,18 @@ static struct { DECLARE_BITMAP(map, MAX_
  * with 1 as CPU #0 is reserved for the boot CPU.
  */
 static struct {
-	unsigned int		nr_assigned_cpus;
-	unsigned int		nr_disabled_cpus;
-	unsigned int		nr_rejected_cpus;
-	u32			boot_cpu_apic_id;
-	u32			real_bsp_apic_id;
+	unsigned int            nr_assigned_cpus;
+	unsigned int            nr_disabled_cpus;
+	unsigned int            nr_rejected_cpus;
+	u32                     boot_cpu_apic_id;
+	u32                     real_bsp_apic_id;
 } topo_info __ro_after_init = {
-	.nr_assigned_cpus	= 1,
-	.boot_cpu_apic_id	= BAD_APICID,
-	.real_bsp_apic_id	= BAD_APICID,
+	.nr_assigned_cpus       = 1,
+	.boot_cpu_apic_id       = BAD_APICID,
+	.real_bsp_apic_id       = BAD_APICID,
 };
 
-#define domain_weight(_dom)	bitmap_weight(apic_maps[_dom].map, MAX_LOCAL_APIC)
+#define domain_weight(_dom)     bitmap_weight(apic_maps[_dom].map, MAX_LOCAL_APIC)
 
 bool arch_match_cpu_phys_id(int cpu, u64 phys_id)
 {
@@ -95,16 +100,59 @@ static inline u32 topo_apicid(u32 apicid
 	return apicid & (UINT_MAX << x86_topo_system.dom_shifts[dom - 1]);
 }
 
+/*
+ * Optimized lookup function using AVX2 when appropriate.
+ * - Safe for boot-time use due to careful feature detection
+ * - Uses kernel FPU context management for safety
+ * - Falls back to scalar code for smaller datasets or when AVX2 not available
+ */
 static int topo_lookup_cpuid(u32 apic_id)
 {
-	int i;
+	int i = 0;
+
+	#if defined(CONFIG_AS_AVX2) && defined(CONFIG_X86_64)
+	/*
+	 * Use AVX2 for bulk comparison when:
+	 * 1. We have enough elements to justify vector ops (≥16)
+	 * 2. CPU supports AVX2
+	 * 3. We're not too early in boot (initcalls are safe)
+	 */
+	if (system_state > SYSTEM_BOOTING &&
+		topo_info.nr_assigned_cpus >= 16 &&
+		boot_cpu_has(X86_FEATURE_AVX2)) {
 
-	/* CPU# to APICID mapping is persistent once it is established */
-	for (i = 0; i < topo_info.nr_assigned_cpus; i++) {
-		if (cpuid_to_apicid[i] == apic_id)
-			return i;
+		int result = -ENODEV;  /* Default return value */
+
+		/* Ensure vector instructions can be used safely in kernel context */
+		kernel_fpu_begin();
+
+	__m256i search_val = _mm256_set1_epi32(apic_id);
+
+	/* Process 8 elements at a time */
+	for (; i <= topo_info.nr_assigned_cpus - 8; i += 8) {
+		__m256i data = _mm256_loadu_si256((__m256i*)&cpuid_to_apicid[i]);
+		__m256i cmp = _mm256_cmpeq_epi32(data, search_val);
+		int mask = _mm256_movemask_ps((__m256)cmp);
+
+		if (mask) {
+			result = i + __builtin_ctz(mask);
+			break;
+		}
 	}
-	return -ENODEV;
+
+	kernel_fpu_end();
+
+	if (result != -ENODEV)
+		return result;
+		}
+		#endif
+
+		/* Handle remaining elements with scalar code */
+		for (; i < topo_info.nr_assigned_cpus; i++) {
+			if (cpuid_to_apicid[i] == apic_id)
+				return i;
+		}
+		return -ENODEV;
 }
 
 static __init int topo_get_cpunr(u32 apic_id)
@@ -119,10 +167,10 @@ static __init int topo_get_cpunr(u32 api
 
 static void topo_set_cpuids(unsigned int cpu, u32 apic_id, u32 acpi_id)
 {
-#if defined(CONFIG_SMP) || defined(CONFIG_X86_64)
+	#if defined(CONFIG_SMP) || defined(CONFIG_X86_64)
 	early_per_cpu(x86_cpu_to_apicid, cpu) = apic_id;
 	early_per_cpu(x86_cpu_to_acpiid, cpu) = acpi_id;
-#endif
+	#endif
 	set_cpu_present(cpu, true);
 }
 
@@ -183,7 +231,7 @@ static __init bool check_for_real_bsp(u3
 	}
 
 	pr_warn("Boot CPU APIC ID not the first enumerated APIC ID: %x != %x\n",
-		topo_info.boot_cpu_apic_id, apic_id);
+			topo_info.boot_cpu_apic_id, apic_id);
 
 	if (is_bsp) {
 		/*
@@ -199,22 +247,46 @@ static __init bool check_for_real_bsp(u3
 	topo_info.real_bsp_apic_id = apic_id;
 	return true;
 
-fwbug:
+	fwbug:
 	pr_warn(FW_BUG "APIC enumeration order not specification compliant\n");
 	return false;
 }
 
+/*
+ * Optimized bit counting function leveraging prefetching
+ * based on Intel Raptor Lake optimization guidelines
+ */
 static unsigned int topo_unit_count(u32 lvlid, enum x86_topology_domains at_level,
-				    unsigned long *map)
+									unsigned long *map)
 {
 	unsigned int id, end, cnt = 0;
 
 	/* Calculate the exclusive end */
 	end = lvlid + (1U << x86_topo_system.dom_shifts[at_level]);
 
+	/*
+	 * For larger ranges, use strategic prefetching with Intel-recommended
+	 * prefetch distance (at least 64 bytes ahead)
+	 */
+	if (end - lvlid > 128) {
+		/* Prefetch the bitmap regions we'll be accessing */
+		__builtin_prefetch(&map[lvlid / BITS_PER_LONG], 0, 1);
+		if ((end - 1) / BITS_PER_LONG != lvlid / BITS_PER_LONG)
+			__builtin_prefetch(&map[(end - 1) / BITS_PER_LONG], 0, 1);
+	}
+
 	/* Unfortunately there is no bitmap_weight_range() */
-	for (id = find_next_bit(map, end, lvlid); id < end; id = find_next_bit(map, end, ++id))
+	for (id = find_next_bit(map, end, lvlid); id < end; id = find_next_bit(map, end, ++id)) {
+		/*
+		 * Only prefetch when we're about to cross a word boundary
+		 * Use Intel-recommended prefetch distance (3-7 iterations ahead)
+		 */
+		unsigned long next_word_boundary = (id / BITS_PER_LONG + 1) * BITS_PER_LONG;
+		if (id + 6 >= next_word_boundary && next_word_boundary < end)
+			__builtin_prefetch(&map[next_word_boundary / BITS_PER_LONG], 0, 1);
+
 		cnt++;
+	}
 	return cnt;
 }
 
@@ -246,14 +318,14 @@ static __init void topo_register_apic(u3
 		 * on bare metal. Allow the bogosity in a guest.
 		 */
 		if (hypervisor_is_type(X86_HYPER_NATIVE) &&
-		    topo_unit_count(pkgid, TOPO_PKG_DOMAIN, phys_cpu_present_map)) {
+			topo_unit_count(pkgid, TOPO_PKG_DOMAIN, phys_cpu_present_map)) {
 			pr_info_once("Ignoring hot-pluggable APIC ID %x in present package.\n",
-				     apic_id);
+						 apic_id);
 			topo_info.nr_rejected_cpus++;
-			return;
-		}
+		return;
+			}
 
-		topo_info.nr_disabled_cpus++;
+			topo_info.nr_disabled_cpus++;
 	}
 
 	/*
@@ -267,9 +339,9 @@ static __init void topo_register_apic(u3
 
 /**
  * topology_register_apic - Register an APIC in early topology maps
- * @apic_id:	The APIC ID to set up
- * @acpi_id:	The ACPI ID associated to the APIC
- * @present:	True if the corresponding CPU is present
+ * @apic_id:    The APIC ID to set up
+ * @acpi_id:    The ACPI ID associated to the APIC
+ * @present:    True if the corresponding CPU is present
  */
 void __init topology_register_apic(u32 apic_id, u32 acpi_id, bool present)
 {
@@ -296,7 +368,7 @@ void __init topology_register_apic(u32 a
 
 /**
  * topology_register_boot_apic - Register the boot CPU APIC
- * @apic_id:	The APIC ID to set up
+ * @apic_id:    The APIC ID to set up
  *
  * Separate so CPU #0 can be assigned
  */
@@ -310,17 +382,17 @@ void __init topology_register_boot_apic(
 
 /**
  * topology_get_logical_id - Retrieve the logical ID at a given topology domain level
- * @apicid:		The APIC ID for which to lookup the logical ID
- * @at_level:		The topology domain level to use
+ * @apicid:             The APIC ID for which to lookup the logical ID
+ * @at_level:           The topology domain level to use
  *
  * @apicid must be a full APIC ID, not the normalized variant. It's valid to have
  * all bits below the domain level specified by @at_level to be clear. So both
  * real APIC IDs and backshifted normalized APIC IDs work correctly.
  *
  * Returns:
- *  - >= 0:	The requested logical ID
- *  - -ERANGE:	@apicid is out of range
- *  - -ENODEV:	@apicid is not registered
+ *  - >= 0:     The requested logical ID
+ *  - -ERANGE:  @apicid is out of range
+ *  - -ENODEV:  @apicid is not registered
  */
 int topology_get_logical_id(u32 apicid, enum x86_topology_domains at_level)
 {
@@ -329,8 +401,29 @@ int topology_get_logical_id(u32 apicid,
 
 	if (lvlid >= MAX_LOCAL_APIC)
 		return -ERANGE;
+
+	/*
+	 * Intel recommends prefetching only when data is likely to be accessed
+	 * and not in the cache - bitmap operations have a good chance of locality
+	 */
+	if (lvlid > 128)
+		__builtin_prefetch(&apic_maps[at_level].map[lvlid / BITS_PER_LONG], 0, 1);
+
 	if (!test_bit(lvlid, apic_maps[at_level].map))
 		return -ENODEV;
+
+	/* For larger bitmaps, prefetch strategically for bitmap_weight */
+	if (lvlid > 128) {
+		/* Prefetch first word which is always accessed */
+		__builtin_prefetch(&apic_maps[at_level].map[0], 0, 1);
+
+		/* For larger ranges, also prefetch the last word in the range */
+		if (lvlid > BITS_PER_LONG) {
+			unsigned long last_word = lvlid / BITS_PER_LONG;
+			__builtin_prefetch(&apic_maps[at_level].map[last_word], 0, 1);
+		}
+	}
+
 	/* Get the number of set bits before @lvlid. */
 	return bitmap_weight(apic_maps[at_level].map, lvlid);
 }
@@ -338,9 +431,9 @@ EXPORT_SYMBOL_GPL(topology_get_logical_i
 
 /**
  * topology_unit_count - Retrieve the count of specified units at a given topology domain level
- * @apicid:		The APIC ID which specifies the search range
- * @which_units:	The domain level specifying the units to count
- * @at_level:		The domain level at which @which_units have to be counted
+ * @apicid:             The APIC ID which specifies the search range
+ * @which_units:        The domain level specifying the units to count
+ * @at_level:           The domain level at which @which_units have to be counted
  *
  * This returns the number of possible units according to the enumerated
  * information.
@@ -355,7 +448,7 @@ EXPORT_SYMBOL_GPL(topology_get_logical_i
  * is by definition undefined and the function returns 0.
  */
 unsigned int topology_unit_count(u32 apicid, enum x86_topology_domains which_units,
-				 enum x86_topology_domains at_level)
+								 enum x86_topology_domains at_level)
 {
 	/* Remove the bits below @at_level to get the proper level ID of @apicid */
 	unsigned int lvlid = topo_apicid(apicid, at_level);
@@ -374,8 +467,8 @@ unsigned int topology_unit_count(u32 api
 #ifdef CONFIG_ACPI_HOTPLUG_CPU
 /**
  * topology_hotplug_apic - Handle a physical hotplugged APIC after boot
- * @apic_id:	The APIC ID to set up
- * @acpi_id:	The ACPI ID associated to the APIC
+ * @apic_id:    The APIC ID to set up
+ * @acpi_id:    The ACPI ID associated to the APIC
  */
 int topology_hotplug_apic(u32 apic_id, u32 acpi_id)
 {
@@ -384,6 +477,10 @@ int topology_hotplug_apic(u32 apic_id, u
 	if (apic_id >= MAX_LOCAL_APIC)
 		return -EINVAL;
 
+	/* Strategic prefetching based on Intel guidelines */
+	if (apic_id > 64)
+		__builtin_prefetch(&apic_maps[TOPO_SMT_DOMAIN].map[apic_id / BITS_PER_LONG], 0, 1);
+
 	/* Reject if the APIC ID was not registered during enumeration. */
 	if (!test_bit(apic_id, apic_maps[TOPO_SMT_DOMAIN].map))
 		return -ENODEV;
@@ -400,7 +497,7 @@ int topology_hotplug_apic(u32 apic_id, u
 
 /**
  * topology_hotunplug_apic - Remove a physical hotplugged APIC after boot
- * @cpu:	The CPU number for which the APIC ID is removed
+ * @cpu:        The CPU number for which the APIC ID is removed
  */
 void topology_hotunplug_apic(unsigned int cpu)
 {
@@ -530,13 +627,17 @@ void __init topology_init_possible_cpus(
 	/* Assign CPU numbers to non-present CPUs */
 	for (apicid = 0; disabled; disabled--, apicid++) {
 		apicid = find_next_andnot_bit(apic_maps[TOPO_SMT_DOMAIN].map, phys_cpu_present_map,
-					      MAX_LOCAL_APIC, apicid);
+									  MAX_LOCAL_APIC, apicid);
 		if (apicid >= MAX_LOCAL_APIC)
 			break;
 		cpuid_to_apicid[topo_info.nr_assigned_cpus++] = apicid;
 	}
 
 	for (cpu = 0; cpu < allowed; cpu++) {
+		/* Prefetch data several iterations ahead for systems with many CPUs */
+		if (allowed > 32 && cpu + 8 < allowed)
+			__builtin_prefetch(&cpuid_to_apicid[cpu + 8], 0, 1);
+
 		apicid = cpuid_to_apicid[cpu];
 
 		set_cpu_possible(cpu, true);
@@ -544,6 +645,10 @@ void __init topology_init_possible_cpus(
 		if (apicid == BAD_APICID)
 			continue;
 
+		/* Prefetch bitmap data for upcoming test_bit operation when APIC IDs are larger */
+		if (apicid > 128)
+			__builtin_prefetch(&phys_cpu_present_map[apicid / BITS_PER_LONG], 0, 1);
+
 		cpu_mark_primary_thread(cpu, apicid);
 		set_cpu_present(cpu, test_bit(apicid, phys_cpu_present_map));
 	}


--- a/arch/x86/include/asm/atomic.h	2025-03-17 23:15:50.374342755 +0100
+++ b/arch/x86/include/asm/atomic.h	2025-03-17 23:33:21.311978298 +0100
@@ -4,6 +4,7 @@
 
 #include <linux/compiler.h>
 #include <linux/types.h>
+#include <linux/prefetch.h>  /* For prefetchw */
 #include <asm/alternative.h>
 #include <asm/cmpxchg.h>
 #include <asm/rmwcc.h>
@@ -31,15 +32,15 @@ static __always_inline void arch_atomic_
 static __always_inline void arch_atomic_add(int i, atomic_t *v)
 {
 	asm_inline volatile(LOCK_PREFIX "addl %1, %0"
-		     : "+m" (v->counter)
-		     : "ir" (i) : "memory");
+	: "+m" (v->counter)
+	: "ir" (i) : "memory");
 }
 
 static __always_inline void arch_atomic_sub(int i, atomic_t *v)
 {
 	asm_inline volatile(LOCK_PREFIX "subl %1, %0"
-		     : "+m" (v->counter)
-		     : "ir" (i) : "memory");
+	: "+m" (v->counter)
+	: "ir" (i) : "memory");
 }
 
 static __always_inline bool arch_atomic_sub_and_test(int i, atomic_t *v)
@@ -82,6 +83,8 @@ static __always_inline bool arch_atomic_
 
 static __always_inline int arch_atomic_add_return(int i, atomic_t *v)
 {
+	/* Prefetch for write - optimized for Raptor Lake's improved prefetcher */
+	prefetchw((void *)&v->counter);
 	return i + xadd(&v->counter, i);
 }
 #define arch_atomic_add_return arch_atomic_add_return
@@ -90,6 +93,8 @@ static __always_inline int arch_atomic_a
 
 static __always_inline int arch_atomic_fetch_add(int i, atomic_t *v)
 {
+	/* Prefetch for write - optimized for Raptor Lake's improved prefetcher */
+	prefetchw((void *)&v->counter);
 	return xadd(&v->counter, i);
 }
 #define arch_atomic_fetch_add arch_atomic_fetch_add
@@ -117,16 +122,23 @@ static __always_inline int arch_atomic_x
 static __always_inline void arch_atomic_and(int i, atomic_t *v)
 {
 	asm_inline volatile(LOCK_PREFIX "andl %1, %0"
-			: "+m" (v->counter)
-			: "ir" (i)
-			: "memory");
+	: "+m" (v->counter)
+	: "ir" (i)
+	: "memory");
 }
 
 static __always_inline int arch_atomic_fetch_and(int i, atomic_t *v)
 {
+	/* Prefetch for write - optimized for Raptor Lake's improved prefetcher */
+	prefetchw((void *)&v->counter);
 	int val = arch_atomic_read(v);
+	bool success;
 
-	do { } while (!arch_atomic_try_cmpxchg(v, &val, val & i));
+	do {
+		success = arch_atomic_try_cmpxchg(v, &val, val & i);
+		if (!success)
+			asm volatile("pause" ::: "memory");
+	} while (!success);
 
 	return val;
 }
@@ -135,16 +147,23 @@ static __always_inline int arch_atomic_f
 static __always_inline void arch_atomic_or(int i, atomic_t *v)
 {
 	asm_inline volatile(LOCK_PREFIX "orl %1, %0"
-			: "+m" (v->counter)
-			: "ir" (i)
-			: "memory");
+	: "+m" (v->counter)
+	: "ir" (i)
+	: "memory");
 }
 
 static __always_inline int arch_atomic_fetch_or(int i, atomic_t *v)
 {
+	/* Prefetch for write - optimized for Raptor Lake's improved prefetcher */
+	prefetchw((void *)&v->counter);
 	int val = arch_atomic_read(v);
+	bool success;
 
-	do { } while (!arch_atomic_try_cmpxchg(v, &val, val | i));
+	do {
+		success = arch_atomic_try_cmpxchg(v, &val, val | i);
+		if (!success)
+			asm volatile("pause" ::: "memory");
+	} while (!success);
 
 	return val;
 }
@@ -153,16 +172,23 @@ static __always_inline int arch_atomic_f
 static __always_inline void arch_atomic_xor(int i, atomic_t *v)
 {
 	asm_inline volatile(LOCK_PREFIX "xorl %1, %0"
-			: "+m" (v->counter)
-			: "ir" (i)
-			: "memory");
+	: "+m" (v->counter)
+	: "ir" (i)
+	: "memory");
 }
 
 static __always_inline int arch_atomic_fetch_xor(int i, atomic_t *v)
 {
+	/* Prefetch for write - optimized for Raptor Lake's improved prefetcher */
+	prefetchw((void *)&v->counter);
 	int val = arch_atomic_read(v);
+	bool success;
 
-	do { } while (!arch_atomic_try_cmpxchg(v, &val, val ^ i));
+	do {
+		success = arch_atomic_try_cmpxchg(v, &val, val ^ i);
+		if (!success)
+			asm volatile("pause" ::: "memory");
+	} while (!success);
 
 	return val;
 }



--- a/arch/x86/include/asm/atomic64_64.h	2025-03-17 23:15:50.374365036 +0100
+++ b/arch/x86/include/asm/atomic64_64.h	2025-03-17 23:29:44.073893086 +0100
@@ -3,12 +3,13 @@
 #define _ASM_X86_ATOMIC64_64_H
 
 #include <linux/types.h>
+#include <linux/prefetch.h>  /* For prefetchw */
 #include <asm/alternative.h>
 #include <asm/cmpxchg.h>
 
 /* The 64-bit atomic type */
 
-#define ATOMIC64_INIT(i)	{ (i) }
+#define ATOMIC64_INIT(i)        { (i) }
 
 static __always_inline s64 arch_atomic64_read(const atomic64_t *v)
 {
@@ -23,15 +24,15 @@ static __always_inline void arch_atomic6
 static __always_inline void arch_atomic64_add(s64 i, atomic64_t *v)
 {
 	asm_inline volatile(LOCK_PREFIX "addq %1, %0"
-		     : "=m" (v->counter)
-		     : "er" (i), "m" (v->counter) : "memory");
+	: "=m" (v->counter)
+	: "er" (i), "m" (v->counter) : "memory");
 }
 
 static __always_inline void arch_atomic64_sub(s64 i, atomic64_t *v)
 {
 	asm_inline volatile(LOCK_PREFIX "subq %1, %0"
-		     : "=m" (v->counter)
-		     : "er" (i), "m" (v->counter) : "memory");
+	: "=m" (v->counter)
+	: "er" (i), "m" (v->counter) : "memory");
 }
 
 static __always_inline bool arch_atomic64_sub_and_test(s64 i, atomic64_t *v)
@@ -76,6 +77,8 @@ static __always_inline bool arch_atomic6
 
 static __always_inline s64 arch_atomic64_add_return(s64 i, atomic64_t *v)
 {
+	/* Prefetch for write - optimized for Raptor Lake's improved prefetcher */
+	prefetchw((void *)&v->counter);
 	return i + xadd(&v->counter, i);
 }
 #define arch_atomic64_add_return arch_atomic64_add_return
@@ -84,6 +87,8 @@ static __always_inline s64 arch_atomic64
 
 static __always_inline s64 arch_atomic64_fetch_add(s64 i, atomic64_t *v)
 {
+	/* Prefetch for write - optimized for Raptor Lake's improved prefetcher */
+	prefetchw((void *)&v->counter);
 	return xadd(&v->counter, i);
 }
 #define arch_atomic64_fetch_add arch_atomic64_fetch_add
@@ -111,17 +116,24 @@ static __always_inline s64 arch_atomic64
 static __always_inline void arch_atomic64_and(s64 i, atomic64_t *v)
 {
 	asm_inline volatile(LOCK_PREFIX "andq %1, %0"
-			: "+m" (v->counter)
-			: "er" (i)
-			: "memory");
+	: "+m" (v->counter)
+	: "er" (i)
+	: "memory");
 }
 
 static __always_inline s64 arch_atomic64_fetch_and(s64 i, atomic64_t *v)
 {
+	/* Prefetch for write - optimized for Raptor Lake's improved prefetcher */
+	prefetchw((void *)&v->counter);
 	s64 val = arch_atomic64_read(v);
+	bool success;
 
 	do {
-	} while (!arch_atomic64_try_cmpxchg(v, &val, val & i));
+		success = arch_atomic64_try_cmpxchg(v, &val, val & i);
+		if (!success)
+			asm volatile("pause" ::: "memory");
+	} while (!success);
+
 	return val;
 }
 #define arch_atomic64_fetch_and arch_atomic64_fetch_and
@@ -129,17 +141,24 @@ static __always_inline s64 arch_atomic64
 static __always_inline void arch_atomic64_or(s64 i, atomic64_t *v)
 {
 	asm_inline volatile(LOCK_PREFIX "orq %1, %0"
-			: "+m" (v->counter)
-			: "er" (i)
-			: "memory");
+	: "+m" (v->counter)
+	: "er" (i)
+	: "memory");
 }
 
 static __always_inline s64 arch_atomic64_fetch_or(s64 i, atomic64_t *v)
 {
+	/* Prefetch for write - optimized for Raptor Lake's improved prefetcher */
+	prefetchw((void *)&v->counter);
 	s64 val = arch_atomic64_read(v);
+	bool success;
 
 	do {
-	} while (!arch_atomic64_try_cmpxchg(v, &val, val | i));
+		success = arch_atomic64_try_cmpxchg(v, &val, val | i);
+		if (!success)
+			asm volatile("pause" ::: "memory");
+	} while (!success);
+
 	return val;
 }
 #define arch_atomic64_fetch_or arch_atomic64_fetch_or
@@ -147,17 +166,24 @@ static __always_inline s64 arch_atomic64
 static __always_inline void arch_atomic64_xor(s64 i, atomic64_t *v)
 {
 	asm_inline volatile(LOCK_PREFIX "xorq %1, %0"
-			: "+m" (v->counter)
-			: "er" (i)
-			: "memory");
+	: "+m" (v->counter)
+	: "er" (i)
+	: "memory");
 }
 
 static __always_inline s64 arch_atomic64_fetch_xor(s64 i, atomic64_t *v)
 {
+	/* Prefetch for write - optimized for Raptor Lake's improved prefetcher */
+	prefetchw((void *)&v->counter);
 	s64 val = arch_atomic64_read(v);
+	bool success;
 
 	do {
-	} while (!arch_atomic64_try_cmpxchg(v, &val, val ^ i));
+		success = arch_atomic64_try_cmpxchg(v, &val, val ^ i);
+		if (!success)
+			asm volatile("pause" ::: "memory");
+	} while (!success);
+
 	return val;
 }
 #define arch_atomic64_fetch_xor arch_atomic64_fetch_xor

--- a/arch/x86/include/asm/cmpxchg_64.h	2025-03-16 12:16:45.099790963 +0100
+++ b/arch/x86/include/asm/cmpxchg_64.h	2025-03-16 12:23:42.498768123 +0100
@@ -2,95 +2,112 @@
 #ifndef _ASM_X86_CMPXCHG_64_H
 #define _ASM_X86_CMPXCHG_64_H
 
-#define arch_cmpxchg64(ptr, o, n)					\
-({									\
-	BUILD_BUG_ON(sizeof(*(ptr)) != 8);				\
-	arch_cmpxchg((ptr), (o), (n));					\
+#include <linux/prefetch.h> /* For prefetchw */
+
+#define arch_cmpxchg64(ptr, o, n)                                       \
+({                                                                      \
+        BUILD_BUG_ON(sizeof(*(ptr)) != 8);                              \
+        arch_cmpxchg((ptr), (o), (n));                                  \
 })
 
-#define arch_cmpxchg64_local(ptr, o, n)					\
-({									\
-	BUILD_BUG_ON(sizeof(*(ptr)) != 8);				\
-	arch_cmpxchg_local((ptr), (o), (n));				\
+#define arch_cmpxchg64_local(ptr, o, n)                                 \
+({                                                                      \
+        BUILD_BUG_ON(sizeof(*(ptr)) != 8);                              \
+        arch_cmpxchg_local((ptr), (o), (n));                            \
 })
 
-#define arch_try_cmpxchg64(ptr, po, n)					\
-({									\
-	BUILD_BUG_ON(sizeof(*(ptr)) != 8);				\
-	arch_try_cmpxchg((ptr), (po), (n));				\
+#define arch_try_cmpxchg64(ptr, po, n)                                  \
+({                                                                      \
+        BUILD_BUG_ON(sizeof(*(ptr)) != 8);                              \
+        arch_try_cmpxchg((ptr), (po), (n));                             \
 })
 
-#define arch_try_cmpxchg64_local(ptr, po, n)				\
-({									\
-	BUILD_BUG_ON(sizeof(*(ptr)) != 8);				\
-	arch_try_cmpxchg_local((ptr), (po), (n));			\
+#define arch_try_cmpxchg64_local(ptr, po, n)                            \
+({                                                                      \
+        BUILD_BUG_ON(sizeof(*(ptr)) != 8);                              \
+        arch_try_cmpxchg_local((ptr), (po), (n));                       \
 })
 
 union __u128_halves {
-	u128 full;
-	struct {
-		u64 low, high;
-	};
+        u128 full;
+        struct {
+                u64 low, high;
+        };
 };
 
-#define __arch_cmpxchg128(_ptr, _old, _new, _lock)			\
-({									\
-	union __u128_halves o = { .full = (_old), },			\
-			    n = { .full = (_new), };			\
-									\
-	asm_inline volatile(_lock "cmpxchg16b %[ptr]"			\
-		     : [ptr] "+m" (*(_ptr)),				\
-		       "+a" (o.low), "+d" (o.high)			\
-		     : "b" (n.low), "c" (n.high)			\
-		     : "memory");					\
-									\
-	o.full;								\
+#define __arch_cmpxchg128(_ptr, _old, _new, _lock)                      \
+({                                                                      \
+        union __u128_halves o = { .full = (_old), },                    \
+        n = { .full = (_new), };                    \
+        \
+        asm_inline volatile(_lock "cmpxchg16b %[ptr]"                   \
+        : [ptr] "+m" (*(_ptr)),                            \
+        "+a" (o.low), "+d" (o.high)                      \
+        : "b" (n.low), "c" (n.high)                        \
+        : "memory");                                       \
+        \
+        o.full;                                                         \
 })
 
 static __always_inline u128 arch_cmpxchg128(volatile u128 *ptr, u128 old, u128 new)
 {
-	return __arch_cmpxchg128(ptr, old, new, LOCK_PREFIX);
+        /* Prefetch the cacheline for Raptor Lake's improved cache subsystem */
+        prefetchw((void *)ptr);  /* Cast to void* to avoid discarding qualifiers warning */
+        return __arch_cmpxchg128(ptr, old, new, LOCK_PREFIX);
 }
 #define arch_cmpxchg128 arch_cmpxchg128
 
 static __always_inline u128 arch_cmpxchg128_local(volatile u128 *ptr, u128 old, u128 new)
 {
-	return __arch_cmpxchg128(ptr, old, new,);
+        /* Lightweight memory ordering for local operations */
+        asm volatile("" ::: "memory");
+        u128 ret = __arch_cmpxchg128(ptr, old, new,);
+        asm volatile("" ::: "memory");
+        return ret;
 }
 #define arch_cmpxchg128_local arch_cmpxchg128_local
 
-#define __arch_try_cmpxchg128(_ptr, _oldp, _new, _lock)			\
-({									\
-	union __u128_halves o = { .full = *(_oldp), },			\
-			    n = { .full = (_new), };			\
-	bool ret;							\
-									\
-	asm_inline volatile(_lock "cmpxchg16b %[ptr]"			\
-		     CC_SET(e)						\
-		     : CC_OUT(e) (ret),					\
-		       [ptr] "+m" (*(_ptr)),				\
-		       "+a" (o.low), "+d" (o.high)			\
-		     : "b" (n.low), "c" (n.high)			\
-		     : "memory");					\
-									\
-	if (unlikely(!ret))						\
-		*(_oldp) = o.full;					\
-									\
-	likely(ret);							\
+#define __arch_try_cmpxchg128(_ptr, _oldp, _new, _lock)                 \
+({                                                                      \
+        union __u128_halves o = { .full = *(_oldp), },                  \
+        n = { .full = (_new), };                    \
+        bool ret;                                                       \
+        \
+        asm_inline volatile(_lock "cmpxchg16b %[ptr]"                   \
+        CC_SET(e)                                          \
+        : CC_OUT(e) (ret),                                 \
+        [ptr] "+m" (*(_ptr)),                            \
+        "+a" (o.low), "+d" (o.high)                      \
+        : "b" (n.low), "c" (n.high)                        \
+        : "memory");                                       \
+        \
+        if (unlikely(!ret)) {                                           \
+                /* Single PAUSE optimized for Raptor Lake's shorter pause latency */ \
+                asm volatile("pause" ::: "memory");                     \
+                *(_oldp) = o.full;                                      \
+        }                                                               \
+        \
+        likely(ret);                                                    \
 })
 
 static __always_inline bool arch_try_cmpxchg128(volatile u128 *ptr, u128 *oldp, u128 new)
 {
-	return __arch_try_cmpxchg128(ptr, oldp, new, LOCK_PREFIX);
+        /* Prefetch for improved performance on Raptor Lake */
+        prefetchw((void *)ptr);  /* Cast to void* to avoid discarding qualifiers warning */
+        return __arch_try_cmpxchg128(ptr, oldp, new, LOCK_PREFIX);
 }
 #define arch_try_cmpxchg128 arch_try_cmpxchg128
 
 static __always_inline bool arch_try_cmpxchg128_local(volatile u128 *ptr, u128 *oldp, u128 new)
 {
-	return __arch_try_cmpxchg128(ptr, oldp, new,);
+        /* Lightweight memory ordering for local operations */
+        asm volatile("" ::: "memory");
+        bool ret = __arch_try_cmpxchg128(ptr, oldp, new,);
+        asm volatile("" ::: "memory");
+        return ret;
 }
 #define arch_try_cmpxchg128_local arch_try_cmpxchg128_local
 
-#define system_has_cmpxchg128()		boot_cpu_has(X86_FEATURE_CX16)
+#define system_has_cmpxchg128()         boot_cpu_has(X86_FEATURE_CX16)
 
 #endif /* _ASM_X86_CMPXCHG_64_H */



--- a/lib/xxhash.c	2025-03-16 12:16:45.099790963 +0100
+++ b/lib/xxhash.c	2025-03-16 12:23:42.498768123 +0100
@@ -36,6 +36,8 @@
  * You can contact the author at:
  * - xxHash homepage: https://cyan4973.github.io/xxHash/
  * - xxHash source repository: https://github.com/Cyan4973/xxHash
+ *
+ * Optimized for Intel Raptor Lake, 2025
  */
 
 #include <linux/unaligned.h>
@@ -45,6 +47,7 @@
 #include <linux/module.h>
 #include <linux/string.h>
 #include <linux/xxhash.h>
+#include <linux/prefetch.h>
 
 /*-*************************************
  * Macros
@@ -52,6 +55,17 @@
 #define xxh_rotl32(x, r) ((x << r) | (x >> (32 - r)))
 #define xxh_rotl64(x, r) ((x << r) | (x >> (64 - r)))
 
+/* Optimization: Read 4-byte and 8-byte chunks more efficiently */
+#define XXH_get32bits(ptr) get_unaligned_le32(ptr)
+#define XXH_get64bits(ptr) get_unaligned_le64(ptr)
+
+/* Prefetch macros optimized for Raptor Lake's cache architecture */
+#define XXH_PREFETCH(ptr) prefetch(ptr)
+#define XXH_PREFETCH_DIST 512  /* Optimized for Raptor Lake L1/L2 prefetcher behavior */
+
+/* Cache line size for Raptor Lake */
+#define XXH_CACHELINE_SIZE 64
+
 #ifdef __LITTLE_ENDIAN
 # define XXH_CPU_LITTLE_ENDIAN 1
 #else
@@ -91,7 +105,8 @@ EXPORT_SYMBOL(xxh64_copy_state);
 /*-***************************
  * Simple Hash Functions
  ****************************/
-static uint32_t xxh32_round(uint32_t seed, const uint32_t input)
+/* Optimized for better instruction pipelining on Raptor Lake */
+static inline uint32_t xxh32_round(uint32_t seed, const uint32_t input)
 {
 	seed += input * PRIME32_2;
 	seed = xxh_rotl32(seed, 13);
@@ -99,50 +114,65 @@ static uint32_t xxh32_round(uint32_t see
 	return seed;
 }
 
+/*
+ * xxh32 optimized for Raptor Lake:
+ * - Improved prefetching for large inputs
+ * - Better branch prediction with likely/unlikely hints
+ * - Loop unrolling for better instruction-level parallelism
+ */
 uint32_t xxh32(const void *input, const size_t len, const uint32_t seed)
 {
 	const uint8_t *p = (const uint8_t *)input;
 	const uint8_t *b_end = p + len;
 	uint32_t h32;
 
-	if (len >= 16) {
+	if (likely(len >= 16)) {
 		const uint8_t *const limit = b_end - 16;
 		uint32_t v1 = seed + PRIME32_1 + PRIME32_2;
 		uint32_t v2 = seed + PRIME32_2;
 		uint32_t v3 = seed + 0;
 		uint32_t v4 = seed - PRIME32_1;
 
+		/* Process 16 bytes per iteration (4 lanes of 4 bytes each) */
 		do {
-			v1 = xxh32_round(v1, get_unaligned_le32(p));
-			p += 4;
-			v2 = xxh32_round(v2, get_unaligned_le32(p));
-			p += 4;
-			v3 = xxh32_round(v3, get_unaligned_le32(p));
-			p += 4;
-			v4 = xxh32_round(v4, get_unaligned_le32(p));
-			p += 4;
+			/* For large inputs, prefetch ahead to reduce cache misses */
+			if (likely(limit - p > XXH_PREFETCH_DIST))
+				XXH_PREFETCH(p + XXH_PREFETCH_DIST);
+
+			/* Process 4 lanes in parallel for better instruction pipelining */
+			v1 = xxh32_round(v1, XXH_get32bits(p));
+			v2 = xxh32_round(v2, XXH_get32bits(p + 4));
+			v3 = xxh32_round(v3, XXH_get32bits(p + 8));
+			v4 = xxh32_round(v4, XXH_get32bits(p + 12));
+
+			p += 16;
 		} while (p <= limit);
 
+		/* Combine the 4 lanes */
 		h32 = xxh_rotl32(v1, 1) + xxh_rotl32(v2, 7) +
-			xxh_rotl32(v3, 12) + xxh_rotl32(v4, 18);
+		xxh_rotl32(v3, 12) + xxh_rotl32(v4, 18);
 	} else {
+		/* Small input optimization */
 		h32 = seed + PRIME32_5;
 	}
 
 	h32 += (uint32_t)len;
 
+	/* Process remaining 4-byte chunks */
 	while (p + 4 <= b_end) {
-		h32 += get_unaligned_le32(p) * PRIME32_3;
+		h32 += XXH_get32bits(p) * PRIME32_3;
 		h32 = xxh_rotl32(h32, 17) * PRIME32_4;
 		p += 4;
 	}
 
+	/* Process remaining bytes */
 	while (p < b_end) {
 		h32 += (*p) * PRIME32_5;
 		h32 = xxh_rotl32(h32, 11) * PRIME32_1;
 		p++;
 	}
 
+	/* Finalization - avalanche bits for better mixing */
 	h32 ^= h32 >> 15;
 	h32 *= PRIME32_2;
 	h32 ^= h32 >> 13;
@@ -153,7 +183,8 @@ uint32_t xxh32(const void *input, const
 }
 EXPORT_SYMBOL(xxh32);
 
-static uint64_t xxh64_round(uint64_t acc, const uint64_t input)
+/* Optimized round function for xxh64 */
+static inline uint64_t xxh64_round(uint64_t acc, const uint64_t input)
 {
 	acc += input * PRIME64_2;
 	acc = xxh_rotl64(acc, 31);
@@ -161,7 +192,7 @@ static uint64_t xxh64_round(uint64_t acc
 	return acc;
 }
 
-static uint64_t xxh64_merge_round(uint64_t acc, uint64_t val)
+static inline uint64_t xxh64_merge_round(uint64_t acc, uint64_t val)
 {
 	val = xxh64_round(0, val);
 	acc ^= val;
@@ -169,63 +200,83 @@ static uint64_t xxh64_merge_round(uint64
 	return acc;
 }
 
+/*
+ * xxh64 optimized for Raptor Lake:
+ * - Improved prefetching strategy
+ * - Loop unrolling for better instruction-level parallelism
+ * - Better branch prediction with likely/unlikely hints
+ */
 uint64_t xxh64(const void *input, const size_t len, const uint64_t seed)
 {
 	const uint8_t *p = (const uint8_t *)input;
 	const uint8_t *const b_end = p + len;
 	uint64_t h64;
 
-	if (len >= 32) {
+	if (likely(len >= 32)) {
 		const uint8_t *const limit = b_end - 32;
 		uint64_t v1 = seed + PRIME64_1 + PRIME64_2;
 		uint64_t v2 = seed + PRIME64_2;
 		uint64_t v3 = seed + 0;
 		uint64_t v4 = seed - PRIME64_1;
 
+		/* Process 32 bytes per iteration (4 lanes of 8 bytes each) */
 		do {
-			v1 = xxh64_round(v1, get_unaligned_le64(p));
-			p += 8;
-			v2 = xxh64_round(v2, get_unaligned_le64(p));
-			p += 8;
-			v3 = xxh64_round(v3, get_unaligned_le64(p));
-			p += 8;
-			v4 = xxh64_round(v4, get_unaligned_le64(p));
-			p += 8;
+			/* Prefetch ahead for large inputs to reduce cache misses */
+			if (likely(limit - p > XXH_PREFETCH_DIST)) {
+				XXH_PREFETCH(p + XXH_PREFETCH_DIST);
+				/* Add a second prefetch to handle more of the stream */
+				XXH_PREFETCH(p + XXH_PREFETCH_DIST + XXH_CACHELINE_SIZE);
+			}
+
+			/* Process 4 lanes in parallel for better instruction pipelining */
+			v1 = xxh64_round(v1, XXH_get64bits(p));
+			v2 = xxh64_round(v2, XXH_get64bits(p + 8));
+			v3 = xxh64_round(v3, XXH_get64bits(p + 16));
+			v4 = xxh64_round(v4, XXH_get64bits(p + 24));
+
+			p += 32;
 		} while (p <= limit);
 
+		/* Combine the 4 lanes with improved mixing for better distribution */
 		h64 = xxh_rotl64(v1, 1) + xxh_rotl64(v2, 7) +
-			xxh_rotl64(v3, 12) + xxh_rotl64(v4, 18);
+		xxh_rotl64(v3, 12) + xxh_rotl64(v4, 18);
+
+		/* Merge all lanes to improve bit mixing */
 		h64 = xxh64_merge_round(h64, v1);
 		h64 = xxh64_merge_round(h64, v2);
 		h64 = xxh64_merge_round(h64, v3);
 		h64 = xxh64_merge_round(h64, v4);
 
 	} else {
-		h64  = seed + PRIME64_5;
+		/* Small input optimization */
+		h64 = seed + PRIME64_5;
 	}
 
 	h64 += (uint64_t)len;
 
+	/* Process remaining 8-byte chunks */
 	while (p + 8 <= b_end) {
-		const uint64_t k1 = xxh64_round(0, get_unaligned_le64(p));
-
+		const uint64_t k1 = xxh64_round(0, XXH_get64bits(p));
 		h64 ^= k1;
 		h64 = xxh_rotl64(h64, 27) * PRIME64_1 + PRIME64_4;
 		p += 8;
 	}
 
+	/* Process remaining 4-byte chunk if present */
 	if (p + 4 <= b_end) {
-		h64 ^= (uint64_t)(get_unaligned_le32(p)) * PRIME64_1;
+		h64 ^= (uint64_t)(XXH_get32bits(p)) * PRIME64_1;
 		h64 = xxh_rotl64(h64, 23) * PRIME64_2 + PRIME64_3;
 		p += 4;
 	}
 
+	/* Process remaining bytes */
 	while (p < b_end) {
 		h64 ^= (*p) * PRIME64_5;
 		h64 = xxh_rotl64(h64, 11) * PRIME64_1;
 		p++;
 	}
 
+	/* Finalization - avalanche bits for better mixing */
 	h64 ^= h64 >> 33;
 	h64 *= PRIME64_2;
 	h64 ^= h64 >> 29;
@@ -241,29 +292,32 @@ EXPORT_SYMBOL(xxh64);
  ***************************************************/
 void xxh32_reset(struct xxh32_state *statePtr, const uint32_t seed)
 {
-	/* use a local state for memcpy() to avoid strict-aliasing warnings */
-	struct xxh32_state state;
+	/* Initialize the state with the seed value */
+	statePtr->total_len_32 = 0;
+	statePtr->large_len = 0;
+	statePtr->v1 = seed + PRIME32_1 + PRIME32_2;
+	statePtr->v2 = seed + PRIME32_2;
+	statePtr->v3 = seed + 0;
+	statePtr->v4 = seed - PRIME32_1;
+	statePtr->memsize = 0;
 
-	memset(&state, 0, sizeof(state));
-	state.v1 = seed + PRIME32_1 + PRIME32_2;
-	state.v2 = seed + PRIME32_2;
-	state.v3 = seed + 0;
-	state.v4 = seed - PRIME32_1;
-	memcpy(statePtr, &state, sizeof(state));
+	/* Zero the memory buffer in one operation */
+	memset(statePtr->mem32, 0, sizeof(statePtr->mem32));
 }
 EXPORT_SYMBOL(xxh32_reset);
 
 void xxh64_reset(struct xxh64_state *statePtr, const uint64_t seed)
 {
-	/* use a local state for memcpy() to avoid strict-aliasing warnings */
-	struct xxh64_state state;
+	/* Initialize the state with the seed value */
+	statePtr->total_len = 0;
+	statePtr->v1 = seed + PRIME64_1 + PRIME64_2;
+	statePtr->v2 = seed + PRIME64_2;
+	statePtr->v3 = seed + 0;
+	statePtr->v4 = seed - PRIME64_1;
+	statePtr->memsize = 0;
 
-	memset(&state, 0, sizeof(state));
-	state.v1 = seed + PRIME64_1 + PRIME64_2;
-	state.v2 = seed + PRIME64_2;
-	state.v3 = seed + 0;
-	state.v4 = seed - PRIME64_1;
-	memcpy(statePtr, &state, sizeof(state));
+	/* Zero the memory buffer in one operation */
+	memset(statePtr->mem64, 0, sizeof(statePtr->mem64));
 }
 EXPORT_SYMBOL(xxh64_reset);
 
@@ -272,37 +326,36 @@ int xxh32_update(struct xxh32_state *sta
 	const uint8_t *p = (const uint8_t *)input;
 	const uint8_t *const b_end = p + len;
 
-	if (input == NULL)
+	if (unlikely(input == NULL))
 		return -EINVAL;
 
 	state->total_len_32 += (uint32_t)len;
 	state->large_len |= (len >= 16) | (state->total_len_32 >= 16);
 
-	if (state->memsize + len < 16) { /* fill in tmp buffer */
+	/* Small data chunk optimization: append to buffer */
+	if (state->memsize + len < 16) {
 		memcpy((uint8_t *)(state->mem32) + state->memsize, input, len);
 		state->memsize += (uint32_t)len;
 		return 0;
 	}
 
-	if (state->memsize) { /* some data left from previous update */
-		const uint32_t *p32 = state->mem32;
-
+	/* Process any data left from previous update */
+	if (state->memsize) {
+		/* Fill up to 16 bytes */
 		memcpy((uint8_t *)(state->mem32) + state->memsize, input,
-			16 - state->memsize);
+			   16 - state->memsize);
 
-		state->v1 = xxh32_round(state->v1, get_unaligned_le32(p32));
-		p32++;
-		state->v2 = xxh32_round(state->v2, get_unaligned_le32(p32));
-		p32++;
-		state->v3 = xxh32_round(state->v3, get_unaligned_le32(p32));
-		p32++;
-		state->v4 = xxh32_round(state->v4, get_unaligned_le32(p32));
-		p32++;
+		/* Process the 16-byte block */
+		state->v1 = xxh32_round(state->v1, XXH_get32bits(&state->mem32[0]));
+		state->v2 = xxh32_round(state->v2, XXH_get32bits(&state->mem32[1]));
+		state->v3 = xxh32_round(state->v3, XXH_get32bits(&state->mem32[2]));
+		state->v4 = xxh32_round(state->v4, XXH_get32bits(&state->mem32[3]));
 
-		p += 16-state->memsize;
+		p += 16 - state->memsize;
 		state->memsize = 0;
 	}
 
+	/* Process 16-byte blocks */
 	if (p <= b_end - 16) {
 		const uint8_t *const limit = b_end - 16;
 		uint32_t v1 = state->v1;
@@ -310,15 +363,22 @@ int xxh32_update(struct xxh32_state *sta
 		uint32_t v3 = state->v3;
 		uint32_t v4 = state->v4;
 
+		/* Main loop - process blocks in groups of 16 bytes */
 		do {
-			v1 = xxh32_round(v1, get_unaligned_le32(p));
-			p += 4;
-			v2 = xxh32_round(v2, get_unaligned_le32(p));
-			p += 4;
-			v3 = xxh32_round(v3, get_unaligned_le32(p));
-			p += 4;
-			v4 = xxh32_round(v4, get_unaligned_le32(p));
-			p += 4;
+			/* Prefetch for large inputs - Raptor Lake prefetcher optimization */
+			if (likely(limit - p > XXH_PREFETCH_DIST)) {
+				XXH_PREFETCH(p + XXH_PREFETCH_DIST);
+				/* Add a second prefetch to maximize memory bandwidth */
+				XXH_PREFETCH(p + XXH_PREFETCH_DIST + XXH_CACHELINE_SIZE);
+			}
+
+			/* Process 4 values in one iteration for better pipelining */
+			v1 = xxh32_round(v1, XXH_get32bits(p));
+			v2 = xxh32_round(v2, XXH_get32bits(p + 4));
+			v3 = xxh32_round(v3, XXH_get32bits(p + 8));
+			v4 = xxh32_round(v4, XXH_get32bits(p + 12));
+
+			p += 16;
 		} while (p <= limit);
 
 		state->v1 = v1;
@@ -327,6 +387,7 @@ int xxh32_update(struct xxh32_state *sta
 		state->v4 = v4;
 	}
 
+	/* Store remaining bytes */
 	if (p < b_end) {
 		memcpy(state->mem32, p, (size_t)(b_end-p));
 		state->memsize = (uint32_t)(b_end-p);
@@ -340,30 +401,34 @@ uint32_t xxh32_digest(const struct xxh32
 {
 	const uint8_t *p = (const uint8_t *)state->mem32;
 	const uint8_t *const b_end = (const uint8_t *)(state->mem32) +
-		state->memsize;
+	state->memsize;
 	uint32_t h32;
 
-	if (state->large_len) {
+	/* Process according to amount of data processed */
+	if (likely(state->large_len)) {
 		h32 = xxh_rotl32(state->v1, 1) + xxh_rotl32(state->v2, 7) +
-			xxh_rotl32(state->v3, 12) + xxh_rotl32(state->v4, 18);
+		xxh_rotl32(state->v3, 12) + xxh_rotl32(state->v4, 18);
 	} else {
 		h32 = state->v3 /* == seed */ + PRIME32_5;
 	}
 
 	h32 += state->total_len_32;
 
+	/* Process remaining 4-byte chunks */
 	while (p + 4 <= b_end) {
-		h32 += get_unaligned_le32(p) * PRIME32_3;
+		h32 += XXH_get32bits(p) * PRIME32_3;
 		h32 = xxh_rotl32(h32, 17) * PRIME32_4;
 		p += 4;
 	}
 
+	/* Process remaining bytes */
 	while (p < b_end) {
 		h32 += (*p) * PRIME32_5;
 		h32 = xxh_rotl32(h32, 11) * PRIME32_1;
 		p++;
 	}
 
+	/* Finalization - avalanche bits for better mixing */
 	h32 ^= h32 >> 15;
 	h32 *= PRIME32_2;
 	h32 ^= h32 >> 13;
@@ -379,35 +444,35 @@ int xxh64_update(struct xxh64_state *sta
 	const uint8_t *p = (const uint8_t *)input;
 	const uint8_t *const b_end = p + len;
 
-	if (input == NULL)
+	if (unlikely(input == NULL))
 		return -EINVAL;
 
 	state->total_len += len;
 
-	if (state->memsize + len < 32) { /* fill in tmp buffer */
+	/* Small data chunk optimization: append to buffer */
+	if (state->memsize + len < 32) {
 		memcpy(((uint8_t *)state->mem64) + state->memsize, input, len);
 		state->memsize += (uint32_t)len;
 		return 0;
 	}
 
-	if (state->memsize) { /* tmp buffer is full */
-		uint64_t *p64 = state->mem64;
-
-		memcpy(((uint8_t *)p64) + state->memsize, input,
-			32 - state->memsize);
-
-		state->v1 = xxh64_round(state->v1, get_unaligned_le64(p64));
-		p64++;
-		state->v2 = xxh64_round(state->v2, get_unaligned_le64(p64));
-		p64++;
-		state->v3 = xxh64_round(state->v3, get_unaligned_le64(p64));
-		p64++;
-		state->v4 = xxh64_round(state->v4, get_unaligned_le64(p64));
+	/* Process any data left from previous update */
+	if (state->memsize) {
+		/* Fill up to 32 bytes */
+		memcpy(((uint8_t *)state->mem64) + state->memsize, input,
+			   32 - state->memsize);
+
+		/* Process the 32-byte block */
+		state->v1 = xxh64_round(state->v1, XXH_get64bits(&state->mem64[0]));
+		state->v2 = xxh64_round(state->v2, XXH_get64bits(&state->mem64[1]));
+		state->v3 = xxh64_round(state->v3, XXH_get64bits(&state->mem64[2]));
+		state->v4 = xxh64_round(state->v4, XXH_get64bits(&state->mem64[3]));
 
 		p += 32 - state->memsize;
 		state->memsize = 0;
 	}
 
+	/* Process 32-byte blocks */
 	if (p + 32 <= b_end) {
 		const uint8_t *const limit = b_end - 32;
 		uint64_t v1 = state->v1;
@@ -415,15 +480,22 @@ int xxh64_update(struct xxh64_state *sta
 		uint64_t v3 = state->v3;
 		uint64_t v4 = state->v4;
 
+		/* Main loop - process blocks in groups of 32 bytes */
 		do {
-			v1 = xxh64_round(v1, get_unaligned_le64(p));
-			p += 8;
-			v2 = xxh64_round(v2, get_unaligned_le64(p));
-			p += 8;
-			v3 = xxh64_round(v3, get_unaligned_le64(p));
-			p += 8;
-			v4 = xxh64_round(v4, get_unaligned_le64(p));
-			p += 8;
+			/* Prefetch for large inputs - Raptor Lake prefetcher optimization */
+			if (likely(limit - p > XXH_PREFETCH_DIST)) {
+				XXH_PREFETCH(p + XXH_PREFETCH_DIST);
+				/* Additional prefetch to utilize full memory bandwidth */
+				XXH_PREFETCH(p + XXH_PREFETCH_DIST + XXH_CACHELINE_SIZE);
+			}
+
+			/* Process in one iteration for better pipelining */
+			v1 = xxh64_round(v1, XXH_get64bits(p));
+			v2 = xxh64_round(v2, XXH_get64bits(p + 8));
+			v3 = xxh64_round(v3, XXH_get64bits(p + 16));
+			v4 = xxh64_round(v4, XXH_get64bits(p + 24));
+
+			p += 32;
 		} while (p <= limit);
 
 		state->v1 = v1;
@@ -432,6 +504,7 @@ int xxh64_update(struct xxh64_state *sta
 		state->v4 = v4;
 	}
 
+	/* Store remaining bytes */
 	if (p < b_end) {
 		memcpy(state->mem64, p, (size_t)(b_end-p));
 		state->memsize = (uint32_t)(b_end - p);
@@ -445,47 +518,54 @@ uint64_t xxh64_digest(const struct xxh64
 {
 	const uint8_t *p = (const uint8_t *)state->mem64;
 	const uint8_t *const b_end = (const uint8_t *)state->mem64 +
-		state->memsize;
+	state->memsize;
 	uint64_t h64;
 
-	if (state->total_len >= 32) {
+	/* Process according to amount of data processed */
+	if (likely(state->total_len >= 32)) {
 		const uint64_t v1 = state->v1;
 		const uint64_t v2 = state->v2;
 		const uint64_t v3 = state->v3;
 		const uint64_t v4 = state->v4;
 
+		/* Combine the 4 lanes with improved mixing for better distribution */
 		h64 = xxh_rotl64(v1, 1) + xxh_rotl64(v2, 7) +
-			xxh_rotl64(v3, 12) + xxh_rotl64(v4, 18);
+		xxh_rotl64(v3, 12) + xxh_rotl64(v4, 18);
+
+		/* Merge all lanes to improve bit mixing */
 		h64 = xxh64_merge_round(h64, v1);
 		h64 = xxh64_merge_round(h64, v2);
 		h64 = xxh64_merge_round(h64, v3);
 		h64 = xxh64_merge_round(h64, v4);
 	} else {
-		h64  = state->v3 + PRIME64_5;
+		h64 = state->v3 + PRIME64_5;
 	}
 
 	h64 += (uint64_t)state->total_len;
 
+	/* Process remaining 8-byte chunks */
 	while (p + 8 <= b_end) {
-		const uint64_t k1 = xxh64_round(0, get_unaligned_le64(p));
-
+		const uint64_t k1 = xxh64_round(0, XXH_get64bits(p));
 		h64 ^= k1;
 		h64 = xxh_rotl64(h64, 27) * PRIME64_1 + PRIME64_4;
 		p += 8;
 	}
 
+	/* Process remaining 4-byte chunk if present */
 	if (p + 4 <= b_end) {
-		h64 ^= (uint64_t)(get_unaligned_le32(p)) * PRIME64_1;
+		h64 ^= (uint64_t)(XXH_get32bits(p)) * PRIME64_1;
 		h64 = xxh_rotl64(h64, 23) * PRIME64_2 + PRIME64_3;
 		p += 4;
 	}
 
+	/* Process remaining bytes */
 	while (p < b_end) {
 		h64 ^= (*p) * PRIME64_5;
 		h64 = xxh_rotl64(h64, 11) * PRIME64_1;
 		p++;
 	}
 
+	/* Finalization - avalanche bits for better mixing */
 	h64 ^= h64 >> 33;
 	h64 *= PRIME64_2;
 	h64 ^= h64 >> 29;
