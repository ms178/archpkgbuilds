# Maintainer: Super Genius CachyOS Maintainer
pkgbase=networkmanager
pkgname=(networkmanager libnm)
pkgver=1.54.1
pkgrel=4.1
pkgdesc="Network connection manager and user applications (PGO + optional BOLT; advanced instrumentation)"
url="https://networkmanager.dev/"
arch=(x86_64)
license=(LGPL-2.1-or-later)
makedepends=(
  audit bash curl dhclient dhcpcd dnsmasq gcc-libs git glib2 glib2-devel glibc
  gobject-introspection gtk-doc iproute2 iptables iwd jansson libmm-glib libndp
  libnewt libpsl libteam meson modemmanager nftables nspr nss openresolv
  pacrunner perl-yaml polkit ppp python-gobject readline systemd systemd-libs
  vala wpa_supplicant
  llvm
)
checkdepends=(libx11 python-dbus)
source=("git+https://gitlab.freedesktop.org/NetworkManager/NetworkManager.git?signed#tag=$pkgver")
b2sums=('50ab9977f045f4ffc99aeb5f31c854690078b84d7a8f172d52f924260f999bfee9587bf45cfe4f2c1761a908c244f776435f39aea6b058890ef14b5dbbcf3bcc')
validpgpkeys=(
  3D10AD045AB4AAFF8E8F36AF9B980AC2FB874FEB
  F07F7C1EABD382F81CBFBA3B998D4828CD7E1656
  2B5F3B2028801E15F57AAA309906C97AA15D984F
  48FD6FAE515A77B48436821C8789567B8715CEBC
  4B8EF9745A973724E965939189A2DA5AF73D5E3D
  E472337703D0C46002928B5790617850A125DE59
  49EA7C670E0850E7419514F629C2366E4DFC5728
  07F9AEC86144386D9576210B66A44781B4EBC2D0
)

# Advanced compile-time instrumentation for higher quality PGO
_extra_instr='-g3 -fno-omit-frame-pointer -Xclang -mllvm -Xclang -vp-counters-per-site=150 -Xclang -mllvm -Xclang -runtime-counter-relocation -Xclang -mllvm -Xclang -enable-value-profiling'

# Strip any preexisting -fprofile-* to avoid mixing generate/use
_strip_profile_flags() {
  local out=() tok
  for tok in $@; do
    case "$tok" in
      -fprofile-generate|-fprofile-generate=*|-fprofile-use|-fprofile-use=*|-fprofile-sample-use=*|-fauto-profile=*|-fcs-profile-generate=*)
        ;;
      *) out+=("$tok");;
    esac
  done
  printf '%s ' "${out[@]}"
}

prepare() {
  cd NetworkManager
}

# Build runtime env pointing to build dir libs so just-built libnm is used
_env_with_build_libs() {
  local builddir="$1"
  # libnm lives under $builddir/src/libnm
  echo "LD_LIBRARY_PATH=$builddir/src/libnm:${LD_LIBRARY_PATH:-}"
}

# Comprehensive typical workload, read-only and safe
_run_nm_workload() { # $1=nmcli; $2=nm-online; $3=builddir; $4 profile env (e.g. LLVM_PROFILE_FILE=...); $5 extra env (e.g. LD_PRELOAD=...)
  local nmcli="$1" nmonline="$2" bdir="$3" profenv="$4" extraenv="$5"
  local env_ld; env_ld="$(_env_with_build_libs "$bdir")"
  _rt(){ local s="$1"; shift; timeout -k 2 "$s" "$@" >/dev/null 2>&1 || true; }

  [[ -x "$nmcli" ]] || return 0

  local running="no"
  if env $env_ld $profenv $extraenv "$nmcli" -t -f RUNNING general status >/dev/null 2>&1; then
    local st; st="$(env $env_ld $profenv $extraenv "$nmcli" -t -f RUNNING general status 2>/dev/null || true)"
    [[ "$st" == "running" ]] && running="yes"
  fi

  if [[ "$running" == "yes" ]]; then
    _rt 8  env $env_ld $profenv $extraenv "$nmcli" general status
    _rt 8  env $env_ld $profenv $extraenv "$nmcli" general permissions
    _rt 8  env $env_ld $profenv $extraenv "$nmcli" -f all general

    _rt 8  env $env_ld $profenv $extraenv "$nmcli" -t -f DEVICE,TYPE,STATE device status
    local line dev typ state
    while IFS= read -r line; do
      IFS=':' read -r dev typ state <<<"$line"
      [[ -n "$dev" ]] || continue
      _rt 10 env $env_ld $profenv $extraenv "$nmcli" -f GENERAL,IP4,IP6,WIRED,WIFI device show "$dev"
      [[ "$typ" == "wifi" ]] && _rt 12 env $env_ld $profenv $extraenv "$nmcli" device wifi list ifname "$dev"
    done < <(env $env_ld $profenv $extraenv "$nmcli" -t -f DEVICE,TYPE,STATE device status 2>/dev/null)

    _rt 10 env $env_ld $profenv $extraenv "$nmcli" -t -f NAME,UUID,TYPE,DEVICE,TIMESTAMP-REAL connection show
    while IFS= read -r line; do
      IFS=':' read -r _ uuid _rest <<<"$line"
      [[ -n "$uuid" ]] || continue
      _rt 8 env $env_ld $profenv $extraenv "$nmcli" -f name,uuid,type,autoconnect,timestamp-real connection show "$uuid"
    done < <(env $env_ld $profenv $extraenv "$nmcli" -t -f NAME,UUID,TYPE,DEVICE,TIMESTAMP-REAL connection show 2>/dev/null)

    _rt 6 env $env_ld $profenv $extraenv "$nmcli" radio all
    _rt 6 env $env_ld $profenv $extraenv "$nmcli" networking
    _rt 8 env $env_ld $profenv $extraenv "$nmcli" networking connectivity check
    [[ -x "$nmonline" ]] && _rt 8 env $env_ld $profenv $extraenv "$nmonline" -t 5
  else
    _rt 8 env $env_ld $profenv $extraenv "$nmcli" --help
    _rt 8 env $env_ld $profenv $extraenv "$nmcli" help
    _rt 6 env $env_ld $profenv $extraenv "$nmcli" --version
    for sub in general device connection radio networking agent monitor settings; do
      _rt 6 env $env_ld $profenv $extraenv "$nmcli" "$sub" --help
      _rt 6 env $env_ld $profenv $extraenv "$nmcli" help "$sub"
    done
    [[ -x "$nmonline" ]] && _rt 6 env $env_ld $profenv $extraenv "$nmonline" --help
  fi
}

build() {
  # Respect user flags; only append PGO/BOLT-specific via meson -D*c_args/link_args
  local BASE_CFLAGS;   BASE_CFLAGS="$(_strip_profile_flags $CFLAGS)"
  local BASE_CXXFLAGS; BASE_CXXFLAGS="$(_strip_profile_flags $CXXFLAGS)"
  local BASE_LDFLAGS="$LDFLAGS"

  # Common meson options (no LTO to keep BOLT-friendly relocs/link time reasonable)
  local meson_opts=(
    -D b_lto=false
    -D b_ndebug=true
    -D b_pie=false
    -D c_std=gnu2x
    -D cpp_std=gnu++2a
    --wrap-mode=nofallback
    --buildtype=release
    -D dist_version="$pkgver-$pkgrel"
    -D session_tracking_consolekit=false
    -D suspend_resume=systemd
    -D modify_system=true
    -D selinux=false
    -D iwd=true
    -D teamdctl=true
    -D nm_cloud_setup=false
    -D config_plugins_default=keyfile
    -D ifupdown=false
    -D netconfig=no
    -D config_dns_rc_manager_default=symlink
    -D vapi=true
    -D docs=false
    -D more_asserts=no
    -D more_logging=false
    -D qt=false
    -D tests=no
    -D python.bytecompile=2
  )

  # ---------------- PASS 1: PGO-instrumented build ----------------
  local gen_dir="$srcdir/pgo-gen"; mkdir -p "$gen_dir"
  local c_args_gen="$BASE_CFLAGS $_extra_instr -fprofile-generate=$gen_dir"
  local cxx_args_gen="$BASE_CXXFLAGS $_extra_instr -fprofile-generate=$gen_dir"
  local link_args_gen="$BASE_LDFLAGS -fprofile-generate=$gen_dir"

  arch-meson NetworkManager build-gen "${meson_opts[@]}" \
    -D b_lto=false \
    -Dc_args="$c_args_gen" -Dcpp_args="$cxx_args_gen" \
    -Dc_link_args="$link_args_gen" -Dcpp_link_args="$link_args_gen"

  meson compile -C build-gen

  # Training
  echo "==> PGO training..."
  local nmcli_gen nmonline_gen
  nmcli_gen="$(find "$srcdir/build-gen" -type f -name nmcli -perm -111 -print -quit)"
  nmonline_gen="$(find "$srcdir/build-gen" -type f -name nm-online -perm -111 -print -quit || true)"
  if [[ -n "$nmcli_gen" ]]; then
    LLVM_PROFILE_FILE="$gen_dir/nm.%p.profraw" _run_nm_workload "$nmcli_gen" "$nmonline_gen" "$srcdir/build-gen" "LLVM_PROFILE_FILE=$gen_dir/nm.%p.profraw"
  else
    echo "Warning: nmcli not found for PGO training; skipping training phase."
  fi

  if compgen -G "$gen_dir"/*.profraw >/dev/null; then
    llvm-profdata merge -o "$srcdir/pgo-merged.profdata" "$gen_dir"/*.profraw
  else
    echo "Warning: no PGO .profraw produced; proceeding without profile-use."
    : > "$srcdir/pgo-merged.profdata" || true
  fi

  # ---------------- PASS 2: optimized build (with --emit-relocs for BOLT) ----------------
  local c_args_use="$BASE_CFLAGS"
  local cxx_args_use="$BASE_CXXFLAGS"
  local link_args_use="$BASE_LDFLAGS -Wl,--emit-relocs"
  if [[ -s "$srcdir/pgo-merged.profdata" ]]; then
    c_args_use+=" -fprofile-use=$srcdir/pgo-merged.profdata -Wno-profile-instr-missing -Wno-profile-instr-out-of-date"
    cxx_args_use+=" -fprofile-use=$srcdir/pgo-merged.profdata -Wno-profile-instr-missing -Wno-profile-instr-out-of-date"
    link_args_use+=" -fprofile-use=$srcdir/pgo-merged.profdata"
  fi

  arch-meson NetworkManager build-opt "${meson_opts[@]}" \
    -D b_lto=false \
    -Dc_args="$c_args_use" -Dcpp_args="$cxx_args_use" \
    -Dc_link_args="$link_args_use" -Dcpp_link_args="$link_args_use"

  meson compile -C build-opt

  # ---------------- BOLT instrumentation/training/optimization (nmcli + libnm) ----------------
  if command -v llvm-bolt >/dev/null 2>&1; then
    echo "==> BOLT: instrumenting nmcli and libnm"
    local bolt_dir="$srcdir/bolt"; mkdir -p "$bolt_dir"
    local nmcli_opt libnm_real
    nmcli_opt="$(find "$srcdir/build-opt" -type f -name nmcli -perm -111 -print -quit)"
    libnm_real="$(find "$srcdir/build-opt/src/libnm" -maxdepth 1 -type f -name 'libnm.so*' -print -quit || true)"

    # Save originals
    if [[ -n "$nmcli_opt" ]]; then
      cp -f "$nmcli_opt" "$bolt_dir/nmcli.orig"
    fi
    if [[ -n "$libnm_real" ]]; then
      cp -f "$libnm_real" "$bolt_dir/libnm.so.orig"
    fi

    # Instrument each with separate fdata paths
    local lib_present=0
    if [[ -n "$nmcli_opt" ]] && llvm-bolt "$nmcli_opt" \
          --relocs --lite=false \
          --instrument --instrumentation-file="$bolt_dir/nmcli.fdata" --instrumentation-file-append-pid \
          -o "$bolt_dir/nmcli.inst"; then
      install -m755 "$bolt_dir/nmcli.inst" "$nmcli_opt"
    else
      echo "BOLT: nmcli instrumentation failed; skipping BOLT."
      return 0
    fi
    if [[ -n "$libnm_real" ]] && llvm-bolt "$libnm_real" \
          --relocs --lite=false \
          --instrument --instrumentation-file="$bolt_dir/libnm.fdata" --instrumentation-file-append-pid \
          -o "$bolt_dir/libnm.so.inst"; then
      install -m755 "$bolt_dir/libnm.so.inst" "$libnm_real"
      lib_present=1
    fi

    # Training (force loading instrumented libnm via LD_PRELOAD if present)
    local env_ld; env_ld="$(_env_with_build_libs "$srcdir/build-opt")"
    if [[ -n "$nmcli_opt" ]]; then
      if [[ $lib_present -eq 1 ]]; then
        env $env_ld LD_PRELOAD="$libnm_real" timeout -k 2 10 "$nmcli_opt" --help >/dev/null 2>&1 || true
        env $env_ld LD_PRELOAD="$libnm_real" timeout -k 2 10 "$nmcli_opt" general --help >/dev/null 2>&1 || true
      else
        env $env_ld timeout -k 2 10 "$nmcli_opt" --help >/dev/null 2>&1 || true
      fi
    fi

    # Merge fdata shards
    local merged_cli="$bolt_dir/nmcli.merged.fdata"
    if compgen -G "$bolt_dir/nmcli.fdata".* >/dev/null; then
      if command -v merge-fdata >/dev/null 2>&1; then
        merge-fdata "$bolt_dir/nmcli.fdata".* -o "$merged_cli" || true
      else
        cat "$bolt_dir/nmcli.fdata".* > "$merged_cli" || true
      fi
    elif [[ -s "$bolt_dir/nmcli.fdata" ]]; then
      cp -f "$bolt_dir/nmcli.fdata" "$merged_cli"
    fi

    local merged_lib="$bolt_dir/libnm.merged.fdata"
    if [[ $lib_present -eq 1 ]]; then
      if compgen -G "$bolt_dir/libnm.fdata".* >/dev/null; then
        if command -v merge-fdata >/dev/null 2>&1; then
          merge-fdata "$bolt_dir/libnm.fdata".* -o "$merged_lib" || true
        else
          cat "$bolt_dir/libnm.fdata".* > "$merged_lib" || true
        fi
      elif [[ -s "$bolt_dir/libnm.fdata" ]]; then
        cp -f "$bolt_dir/libnm.fdata" "$merged_lib"
      fi
    fi

    # Optimize nmcli and install back
    if [[ -s "$merged_cli" ]]; then
      local bolt_help; bolt_help="$(llvm-bolt --help 2>&1 || true)"
      local align_flags=(--align-blocks)
      grep -q -- '--block-alignment' <<<"$bolt_help" && align_flags=(--align-blocks --block-alignment=32)
      if llvm-bolt "$bolt_dir/nmcli.orig" \
            --relocs --data="$merged_cli" \
            --reorder-blocks=ext-tsp --reorder-functions=cdsort \
            --split-functions --split-strategy=cdsplit \
            --icf=all --jump-tables=move --peepholes=all \
            --reg-reassign --use-aggr-reg-reassign \
            "${align_flags[@]}" --dyno-stats \
            -o "$bolt_dir/nmcli.bolt"; then
        install -m755 "$bolt_dir/nmcli.bolt" "$nmcli_opt"
      else
        echo "BOLT: nmcli optimization failed; restoring PGO nmcli"
        install -m755 "$bolt_dir/nmcli.orig" "$nmcli_opt"
      fi
    else
      echo "BOLT: no nmcli fdata; restoring PGO nmcli"
      install -m755 "$bolt_dir/nmcli.orig" "$nmcli_opt"
    fi

    # Optimize libnm if profiled
    if [[ $lib_present -eq 1 && -s "$merged_lib" ]]; then
      if llvm-bolt "$bolt_dir/libnm.so.orig" \
            --relocs --data="$merged_lib" \
            --reorder-blocks=ext-tsp --reorder-functions=cdsort \
            --split-functions --split-strategy=cdsplit \
            --icf=all --jump-tables=move --peepholes=all \
            --reg-reassign --use-aggr-reg-reassign \
            "${align_flags[@]}" --dyno-stats \
            -o "$bolt_dir/libnm.so.bolt"; then
        install -m755 "$bolt_dir/libnm.so.bolt" "$libnm_real"
      else
        echo "BOLT: libnm optimization failed; restoring PGO libnm"
        install -m755 "$bolt_dir/libnm.so.orig" "$libnm_real"
      fi
    elif [[ $lib_present -eq 1 ]]; then
      echo "BOLT: no libnm fdata; restoring PGO libnm"
      install -m755 "$bolt_dir/libnm.so.orig" "$libnm_real"
    fi
  else
    echo "llvm-bolt not found; skipping BOLT."
  fi
}

#check() {
#  NMTST_FORCE_REAL_ROOT=1 meson test -C build-opt --print-errorlogs
#}

_pick() {
  local p="$1" f d; shift
  for f; do
    d="$srcdir/$p/${f#$pkgdir/}"
    mkdir -p "$(dirname "$d")"
    mv "$f" "$d"
    rmdir -p --ignore-fail-on-non-empty "$(dirname "$f")"
  done
}

package_networkmanager() {
  depends=(
    audit curl gcc-libs glib2 glibc iproute2 jansson libmm-glib libndp libnewt libnm
    libpsl libteam mobile-broadband-provider-info nspr nss readline systemd-libs
    wpa_supplicant
  )
  optdepends=(
    'bluez: Bluetooth support'
    'dhclient: alternative DHCP client'
    'dhcpcd: alternative DHCP client'
    'dnsmasq: connection sharing'
    'firewalld: firewall support'
    'iptables: connection sharing'
    'iwd: wpa_supplicant alternative'
    'modemmanager: cellular network support'
    'nftables: connection sharing'
    'openresolv: alternative resolv.conf manager'
    'pacrunner: PAC proxy support'
    'polkit: let non-root users control networking'
    'ppp: dialup connection support'
  )
  backup=(etc/NetworkManager/NetworkManager.conf)
  license+=(GPL-2.0-or-later)

  meson install -C build-opt --destdir "$pkgdir"

  cd "$pkgdir"

  install -d etc/NetworkManager/{conf,dnsmasq}.d
  install -dm700 etc/NetworkManager/system-connections
  install -m644 /dev/stdin etc/NetworkManager/NetworkManager.conf <<'END'
# Configuration file for NetworkManager.
# See "man 5 NetworkManager.conf" for details.
END

  install -Dm644 /dev/stdin usr/lib/NetworkManager/conf.d/20-connectivity.conf <<'END'
[connectivity]
uri=http://ping.archlinux.org/nm-check.txt
END

  shopt -s globstar
  _pick libnm usr/include/libnm
  _pick libnm usr/lib/girepository-1.0/NM-*
  _pick libnm usr/lib/libnm.*
  _pick libnm usr/lib/pkgconfig/libnm.pc
  _pick libnm usr/share/gir-1.0/NM-*
  _pick libnm usr/share/vala/vapi/libnm.*
  _pick ovs usr/lib/systemd/system/NetworkManager.service.d/NetworkManager-ovs.conf

  install -d usr/lib/NetworkManager/dispatcher.d/no-wait.d
}

package_libnm() {
  pkgdesc="NetworkManager client library"
  depends=(gcc-libs glib2 glibc nspr nss systemd-libs util-linux-libs)
  provides=(libnm.so)
  mv libnm/* "$pkgdir"
}
