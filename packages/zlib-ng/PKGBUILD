pkgname=(
  zlib-ng
  zlib-ng-compat
)
pkgver=2.2.5
pkgrel=15.3
_zlibver=1.3.1
pkgdesc='zlib-Ersatz mit Optimierungen für Systeme der nächsten Generation'
url='https://github.com/zlib-ng/zlib-ng'
arch=('x86_64')
license=('custom:zlib')
depends=('glibc')
makedepends=(
  cmake
  ninja
  git
  llvm
  clang
  bolt
  mimalloc
)
source=(git+https://github.com/zlib-ng/zlib-ng#tag=${pkgver})
sha256sums=('SKIP')

generate_training_data() {
    local pgo_dir="$1"
    echo "Generating training corpus..."
    rm -rf "${pgo_dir}/training"
    mkdir -p "${pgo_dir}/training"

    # 30 diverse pattern files
    for i in {1..30}; do
        {
            seq 1 20000
            yes "pattern${i}" | head -n 20000
            dd if=/dev/urandom bs=16K count=20 2>/dev/null | base64 -w0
            printf "%0.sA" $(seq 1 500000)
        } > "${pgo_dir}/training/corpus_${i}.dat"
    done

    # Realistic data profiles
    dd if=/dev/urandom bs=1M count=100 2>/dev/null > "${pgo_dir}/training/random_100M.bin"
    seq 1 10000000 > "${pgo_dir}/training/sequential_10M.txt"
    yes "Repetitive pattern for dictionary training" | head -n 5000000 > "${pgo_dir}/training/repetitive_5M.txt"

    # Compression ratio ladder
    for i in {1..8}; do
        dd if=/dev/urandom bs=512K count=$((i * 25)) 2>/dev/null > "${pgo_dir}/training/entropy_${i}.bin"
    done

    # Real-world text
    find /usr/share/doc /usr/share/man -type f -size -512k 2>/dev/null | head -n 100 | while read -r f; do
        [[ -r "$f" ]] && cat "$f" 2>/dev/null >> "${pgo_dir}/training/real_world.txt"
    done
}

run_pgo_training() {
    local build_dir="$1"
    local pgo_dir="$2"
    local lib_path="${build_dir}"
    local tmp_dir="${pgo_dir}/tmp"
    mkdir -p "${tmp_dir}"

    # Test harness
    test_file() {
        local file="$1"
        local temp_base="${tmp_dir}/tmp_$$"

        for level in {1..9}; do
            LD_LIBRARY_PATH="${lib_path}" "${build_dir}/minigzip" -${level} < "${file}" > "${temp_base}.gz"
            LD_LIBRARY_PATH="${lib_path}" "${build_dir}/minigzip" -d < "${temp_base}.gz" > /dev/null
        done

        for strategy in {0..4}; do
            LD_LIBRARY_PATH="${lib_path}" "${build_dir}/example" -s${strategy} "${file}" /dev/null
        done

        for bits in {9..15}; do
            LD_LIBRARY_PATH="${lib_path}" "${build_dir}/example" "${file}" "${temp_base}.def" ${bits}
            LD_LIBRARY_PATH="${lib_path}" "${build_dir}/example" -d "${temp_base}.def" /dev/null ${bits}
        done

        rm -f "${temp_base}".*
    }

    find "${pgo_dir}/training" -type f -print0 | while IFS= read -r -d '' file; do
        test_file "${file}"

        # Parallel stress
        for i in $(seq 1 $(nproc)); do
            LD_LIBRARY_PATH="${lib_path}" "${build_dir}/minigzip" -6 < "${file}" > /dev/null &
        done
        wait
    done

    rm -rf "${tmp_dir}"
}

build() {
    cd "zlib-ng"

    local PGO_DIR="${srcdir}/pgo-data"
    local orig_cflags="${CFLAGS}"
    local orig_cxxflags="${CXXFLAGS}"
    local orig_ldflags="${LDFLAGS}"

    # Clean slate
    rm -rf "${PGO_DIR}"
    mkdir -p "${PGO_DIR}/profiles"

    # Generate training corpus
    generate_training_data "${PGO_DIR}"

    ###########################################################################
    # Phase 1: PGO Instrumentation Build
    ###########################################################################
    msg2 "Building PGO-instrumented libraries..."

    export CFLAGS="${orig_cflags} -fprofile-generate=${PGO_DIR}/profiles -fno-omit-frame-pointer -mllvm -vp-counters-per-site=2000"
    export CXXFLAGS="${orig_cxxflags} -fprofile-generate=${PGO_DIR}/profiles -fno-omit-frame-pointer -mllvm -vp-counters-per-site=2000"
    export LDFLAGS="${orig_ldflags} -fprofile-generate=${PGO_DIR}/profiles"

    local cmake_options=(
        -G Ninja
        -DCMAKE_BUILD_TYPE=Release
        -DCMAKE_C_STANDARD=11
        -DCMAKE_INSTALL_PREFIX=/usr
        -DCMAKE_INSTALL_LIBDIR=lib
        -DWITH_GTEST=ON
        -DWITH_OPTIM=ON
        -Wno-dev
    )

    cmake -B build_pgo "${cmake_options[@]}"
    cmake --build build_pgo
    cmake -B build_pgo_compat "${cmake_options[@]}" -DZLIB_COMPAT=ON
    cmake --build build_pgo_compat

    ###########################################################################
    # Phase 2: Training Run
    ###########################################################################
    msg2 "Running PGO training workload..."
    run_pgo_training "${srcdir}/zlib-ng/build_pgo" "${PGO_DIR}"
    run_pgo_training "${srcdir}/zlib-ng/build_pgo_compat" "${PGO_DIR}"

    ctest --test-dir build_pgo --output-on-failure || true
    ctest --test-dir build_pgo_compat --output-on-failure || true

    ###########################################################################
    # Phase 3: Profile Merging
    ###########################################################################
    msg2 "Merging PGO profiles..."
    if ! llvm-profdata merge -output="${PGO_DIR}/pgo.profdata" "${PGO_DIR}"/profiles/*.profraw; then
        error "Profile merging failed"
        return 1
    fi

    ###########################################################################
    # Phase 4: Optimized Build
    ###########################################################################
    msg2 "Building PGO-optimized libraries..."

    export CFLAGS="${orig_cflags} -fprofile-use=${PGO_DIR}/pgo.profdata"
    export CXXFLAGS="${orig_cxxflags} -fprofile-use=${PGO_DIR}/pgo.profdata"
    export LDFLAGS="${orig_ldflags} -fprofile-use=${PGO_DIR}/pgo.profdata -Wl,--emit-relocs"

    cmake -B build_opt "${cmake_options[@]}" -DWITH_GTEST=OFF
    cmake --build build_opt
    cmake -B build_opt_compat "${cmake_options[@]}" -DWITH_GTEST=OFF -DZLIB_COMPAT=ON
    cmake --build build_opt_compat

    ###########################################################################
    # Phase 5: BOLT Instrumentation & Training
    ###########################################################################
    msg2 "BOLT instrumentation and training..."

    # BACKUP original PGO-optimized binary
    cp "${srcdir}/zlib-ng/build_opt/libz-ng.so.${pkgver}" "${srcdir}/zlib-ng/build_opt/libz-ng.so.${pkgver}.pgo"
    cp "${srcdir}/zlib-ng/build_opt_compat/libz.so.${_zlibver}.zlib-ng" "${srcdir}/zlib-ng/build_opt_compat/libz.so.${_zlibver}.zlib-ng.pgo"

    # Instrument the BACKUP
    llvm-bolt "${srcdir}/zlib-ng/build_opt/libz-ng.so.${pkgver}.pgo" \
        --instrument --instrumentation-file-append-pid \
        --instrumentation-file="${PGO_DIR}/bolt.fdata" \
        -o "${srcdir}/zlib-ng/build_opt/libz-ng.so.${pkgver}.bolt.inst"

    llvm-bolt "${srcdir}/zlib-ng/build_opt_compat/libz.so.${_zlibver}.zlib-ng.pgo" \
        --instrument --instrumentation-file-append-pid \
        --instrumentation-file="${PGO_DIR}/bolt.fdata" \
        -o "${srcdir}/zlib-ng/build_opt_compat/libz.so.${_zlibver}.zlib-ng.bolt.inst"

    # Install instrumented version for training
    mv "${srcdir}/zlib-ng/build_opt/libz-ng.so.${pkgver}.bolt.inst" "${srcdir}/zlib-ng/build_opt/libz-ng.so.${pkgver}"
    mv "${srcdir}/zlib-ng/build_opt_compat/libz.so.${_zlibver}.zlib-ng.bolt.inst" "${srcdir}/zlib-ng/build_opt_compat/libz.so.${_zlibver}.zlib-ng"

    # Run BOLT training
    export BOLT_PROFILE_FILE="${PGO_DIR}/bolt.fdata"
    run_pgo_training "${srcdir}/zlib-ng/build_opt" "${PGO_DIR}"
    run_pgo_training "${srcdir}/zlib-ng/build_opt_compat" "${PGO_DIR}"

    ###########################################################################
    # Phase 6: BOLT Profile Merging
    ###########################################################################
    msg2 "Merging BOLT profiles..."

    # CRITICAL FIX: Unquoted glob pattern for proper expansion
    local bolt_profiles=(${PGO_DIR}/bolt.fdata.*)
    if [[ ${#bolt_profiles[@]} -eq 0 ]]; then
        warning "No BOLT profiles generated, skipping BOLT optimization"
    elif command -v merge-fdata >/dev/null 2>&1; then
        # PROPER: No quotes around glob pattern
        LD_PRELOAD=/usr/lib/libmimalloc.so merge-fdata ${PGO_DIR}/bolt.fdata.* > "${PGO_DIR}/bolt_merged.fdata"

        if [[ ! -s "${PGO_DIR}/bolt_merged.fdata" ]]; then
            warning "BOLT profile merge failed, skipping optimization"
        else
            ###########################################################################
            # Phase 7: BOLT Optimization
            ###########################################################################
            msg2 "Applying BOLT optimizations..."

            # OPTIMIZE the ORIGINAL PGO binary, not the instrumented one
            LD_PRELOAD=/usr/lib/libmimalloc.so llvm-bolt "${srcdir}/zlib-ng/build_opt/libz-ng.so.${pkgver}.pgo" \
                --data "${PGO_DIR}/bolt_merged.fdata" \
                -o "${srcdir}/zlib-ng/build_opt/libz-ng.so.${pkgver}.bolt" \
                --dyno-stats --lite=false --icf=all --plt=all --hugify --peepholes=all \
                --x86-strip-redundant-address-size --indirect-call-promotion=all \
                --reorder-blocks=ext-tsp --reorder-functions=cdsort --split-all-cold \
                --split-eh --split-functions --split-strategy=cdsplit || exit 1

            LD_PRELOAD=/usr/lib/libmimalloc.so llvm-bolt "${srcdir}/zlib-ng/build_opt_compat/libz.so.${_zlibver}.zlib-ng.pgo" \
                --data "${PGO_DIR}/bolt_merged.fdata" \
                -o "${srcdir}/zlib-ng/build_opt_compat/libz.so.${_zlibver}.zlib-ng.bolt" \
                --dyno-stats --lite=false --icf=all --plt=all --hugify --peepholes=all \
                --x86-strip-redundant-address-size --indirect-call-promotion=all \
                --reorder-blocks=ext-tsp --reorder-functions=cdsort --split-all-cold \
                --split-eh --split-functions --split-strategy=cdsplit || exit 1

            # Install BOLT-optimized versions
            mv "${srcdir}/zlib-ng/build_opt/libz-ng.so.${pkgver}.bolt" "${srcdir}/zlib-ng/build_opt/libz-ng.so.${pkgver}"
            mv "${srcdir}/zlib-ng/build_opt_compat/libz.so.${_zlibver}.zlib-ng.bolt" "${srcdir}/zlib-ng/build_opt_compat/libz.so.${_zlibver}.zlib-ng"
        fi
    else
        warning "merge-fdata not found, skipping BOLT optimization"
        # Restore original PGO binaries
        mv "${srcdir}/zlib-ng/build_opt/libz-ng.so.${pkgver}.pgo" "${srcdir}/zlib-ng/build_opt/libz-ng.so.${pkgver}"
        mv "${srcdir}/zlib-ng/build_opt_compat/libz.so.${_zlibver}.zlib-ng.pgo" "${srcdir}/zlib-ng/build_opt_compat/libz.so.${_zlibver}.zlib-ng"
    fi

    ###########################################################################
    # Phase 8: Finalize Symlinks
    ###########################################################################
    ln -sf "libz-ng.so.${pkgver}" "${srcdir}/zlib-ng/build_opt/libz-ng.so.2"
    ln -sf "libz-ng.so.2" "${srcdir}/zlib-ng/build_opt/libz-ng.so"
    ln -sf "libz.so.${_zlibver}.zlib-ng" "${srcdir}/zlib-ng/build_opt_compat/libz.so.1"
    ln -sf "libz.so.1" "${srcdir}/zlib-ng/build_opt_compat/libz.so"

    # Restore environment
    export CFLAGS="${orig_cflags}"
    export CXXFLAGS="${orig_cxxflags}"
    export LDFLAGS="${orig_ldflags}"
}

check() {
    cd "zlib-ng"
    msg "Testing PGO-optimized builds..."
    ctest --test-dir build_opt --output-on-failure
    ctest --test-dir build_opt_compat --output-on-failure
}

package_zlib-ng() {
    pkgdesc='zlib-Ersatz mit Optimierungen für Systeme der nächsten Generation'
    provides=("libz-ng.so=2")
    options=(!strip)
    cd "zlib-ng"
    DESTDIR="${pkgdir}" cmake --install build_opt

    find "${pkgdir}" -type f \( -name '*.so*' -o -name '*.a' -o -executable \) -print0 | while IFS= read -r -d '' file; do
        llvm-strip --strip-unneeded "$file" 2>/dev/null || llvm-strip --strip-all "$file" 2>/dev/null || true
    done

    install -Dm644 LICENSE.md -t "${pkgdir}/usr/share/licenses/${pkgname[0]}"
    install -Dm644 README.md -t "${pkgdir}/usr/share/doc/${pkgname[0]}"
}

package_zlib-ng-compat() {
    pkgdesc='zlib-Ersatz mit Optimierungen für Systeme der nächsten Generation (zlib compat)'
    provides=("zlib=1:${_zlibver}" "libz.so=1")
    depends=('zlib-ng')
    conflicts=('zlib')
    replaces=('zlib')
    options=('staticlibs' !strip)
    cd "zlib-ng"
    DESTDIR="${pkgdir}" cmake --install build_opt_compat

    find "${pkgdir}" -type f \( -name '*.so*' -o -name '*.a' -o -executable \) -print0 | while IFS= read -r -d '' file; do
        llvm-strip --strip-unneeded "$file" 2>/dev/null || llvm-strip --strip-all "$file" 2>/dev/null || true
    done

    install -Dm644 LICENSE.md -t "${pkgdir}/usr/share/licenses/${pkgname[0]}"
    install -Dm644 README.md -t "${pkgdir}/usr/share/doc/${pkgname[0]}"
}
