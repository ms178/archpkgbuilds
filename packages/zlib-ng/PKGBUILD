pkgname=(
  zlib-ng
  zlib-ng-compat
)
pkgver=2.2.3
pkgrel=14.1
_zlibver=1.3.1  # Muss konsistent zur ersetzten zlib-Version bleiben
pkgdesc='zlib-Ersatz mit Optimierungen für Systeme der nächsten Generation'
url='https://github.com/zlib-ng/zlib-ng'
arch=('x86_64')
license=('custom:zlib')
depends=('glibc')
makedepends=(
  cmake
  ninja
  git
  llvm              # Für clang, llvm-profdata, llvm-bolt, merge-fdata
)
source=(git+https://github.com/zlib-ng/zlib-ng#tag=${pkgver})
sha256sums=('SKIP')

build() {
  cd "zlib-ng"

  # Speichere ursprüngliche Flags
  orig_cflags="${CFLAGS}"
  orig_cxxflags="${CXXFLAGS}"
  orig_ldflags="${LDFLAGS}"
  extra_flags=" "

  # Erstelle Profilverzeichnis
  mkdir -p "$srcdir/bolt_profile"
  chmod -R u+rw "$srcdir/bolt_profile"

  ###########################################################################
  # Phase 1: PGO-Instrumentierungs-Build (PGO raw profile generation)
  ###########################################################################
  msg2 "== Aufbau des PGO-instrumentierten Builds (zlib-ng)"
  export CFLAGS="${orig_cflags}${extra_flags} -fprofile-generate -Wl,--build-id=sha1 -fdebug-info-for-profiling -g3 -fno-omit-frame-pointer -mllvm -vp-counters-per-site=10"
  export CXXFLAGS="${orig_cxxflags}${extra_flags} -fprofile-generate -Wl,--build-id=sha1 -fdebug-info-for-profiling -g3 -fno-omit-frame-pointer -mllvm -vp-counters-per-site=10"
  export LDFLAGS="${orig_ldflags}${extra_flags}"
  local _options=(
    -G Ninja
    -DCMAKE_BUILD_TYPE=Release
    -DCMAKE_C_STANDARD=11
    -DCMAKE_CXX_STANDARD=23
    -DCMAKE_INSTALL_PREFIX=/usr
    -DCMAKE_INSTALL_LIBDIR=lib
    -Wno-dev
    -DWITH_GTEST=OFF
  )
  # Für zlib-ng
  cmake -B build_pgo "${_options[@]}"
  cmake --build build_pgo
  # Für zlib-ng-compat
  cmake -B build_pgo_compat "${_options[@]}" -DZLIB_COMPAT=ON
  cmake --build build_pgo_compat

  ###########################################################################
  # Phase 2: Testlauf zum Erzeugen der PGO-Rohprofile
  ###########################################################################
  msg2 "== Ausführen der Tests zur Erzeugung der PGO-Profil-Daten (instrumentierter Build)"
  export LLVM_PROFILE_FILE="$srcdir/bolt_profile/%p.profraw"
  ctest --test-dir build_pgo --output-on-failure
  ctest --test-dir build_pgo_compat --output-on-failure

  ###########################################################################
  # Phase 3: Zusammenführen der PGO-Rohprofile
  ###########################################################################
  msg2 "== Zusammenführen der PGO-Profil-Daten"
  shopt -s nullglob
  profraw_files=("$srcdir/bolt_profile/"*.profraw)
  if [ ${#profraw_files[@]} -eq 0 ]; then
      msg2 "Es wurden keine .profraw-Dateien erzeugt. Bitte stellen Sie sicher, dass Ihre Tests genügend Codepfade abdecken."
      exit 1
  fi
  llvm-profdata merge "${profraw_files[@]}" -o "$srcdir/bolt_profile/profile.profdata"
  shopt -u nullglob

  ###########################################################################
  # Phase 4: Rebuild mit PGO-Optimierung
  ###########################################################################
  msg2 "== Aufbau des PGO-optimierten Builds (zlib-ng)"
  export CFLAGS="${orig_cflags}${extra_flags} -fprofile-use=$srcdir/bolt_profile/profile.profdata"
  export CXXFLAGS="${orig_cxxflags}${extra_flags} -fprofile-use=$srcdir/bolt_profile/profile.profdata"
  export LDFLAGS="${orig_ldflags}${extra_flags} -Wl,--emit-relocs"
  cmake -B build_opt "${_options[@]}"
  cmake --build build_opt
  msg2 "== Aufbau des PGO-optimierten Builds (zlib-ng-compat)"
  cmake -B build_opt_compat "${_options[@]}" -DZLIB_COMPAT=ON
  cmake --build build_opt_compat

  ###########################################################################
  # Phase 5: BOLT-Instrumentierung (Erzeuge rohes BOLT-Profil in fdata-Form)
  ###########################################################################
  msg2 "== BOLT-Instrumentierung (zlib-ng)"
  llvm-bolt "$srcdir/zlib-ng/build_opt/libz-ng.so.${pkgver}" \
      --instrument \
      --lite=false \
      --instrumentation-file-append-pid \
      --instrumentation-file="$srcdir/bolt_profile/bolt.fdata" \
      -o "$srcdir/zlib-ng/build_opt/libz-ng.so.${pkgver}.inst"
  # Ersetze das Original: sichere es unter .org und setze das instrumentierte Binary ein
  mv "$srcdir/zlib-ng/build_opt/libz-ng.so.${pkgver}" "$srcdir/zlib-ng/build_opt/libz-ng.so.${pkgver}.org"
  mv "$srcdir/zlib-ng/build_opt/libz-ng.so.${pkgver}.inst" "$srcdir/zlib-ng/build_opt/libz-ng.so.${pkgver}"

  msg2 "== BOLT-Instrumentierung (zlib-ng-compat)"
  llvm-bolt "$srcdir/zlib-ng/build_opt_compat/libz.so.${_zlibver}.zlib-ng" \
      --instrument \
      --lite=false \
      --instrumentation-file-append-pid \
      --instrumentation-file="$srcdir/bolt_profile/bolt_compat.fdata" \
      -o "$srcdir/zlib-ng/build_opt_compat/libz.so.${_zlibver}.zlib-ng.inst"
  mv "$srcdir/zlib-ng/build_opt_compat/libz.so.${_zlibver}.zlib-ng" "$srcdir/zlib-ng/build_opt_compat/libz.so.${_zlibver}.zlib-ng.org"
  mv "$srcdir/zlib-ng/build_opt_compat/libz.so.${_zlibver}.zlib-ng.inst" "$srcdir/zlib-ng/build_opt_compat/libz.so.${_zlibver}.zlib-ng"

  ###########################################################################
  # Phase 6: Ausführen der Tests mit den BOLT-instrumentierten Binaries
  ###########################################################################
  msg2 "== Ausführen der Tests mit den BOLT-instrumentierten Binaries (zlib-ng)"
  export BOLT_PROFILE_FILE="$srcdir/bolt_profile/bolt.fdata"
  ctest --test-dir build_opt --output-on-failure

  msg2 "== Ausführen der Tests mit den BOLT-instrumentierten Binaries (zlib-ng-compat)"
  export BOLT_PROFILE_FILE="$srcdir/bolt_profile/bolt_compat.fdata"
  ctest --test-dir build_opt_compat --output-on-failure

  ###########################################################################
  # Phase 7: Zusammenführen der BOLT fdata-Profile
  ###########################################################################
  msg2 "== Zusammenführen der BOLT fdata-Profile"
  # Hier wird merge-fdata verwendet – LD_PRELOAD wird gesetzt wie im Vorbild
  LD_PRELOAD=/usr/lib/libmimalloc.so merge-fdata "$srcdir/bolt_profile/"*.fdata > "$srcdir/bolt_profile/combined.fdata"

  ###########################################################################
  # Phase 8: BOLT-Optimierung mithilfe der kombinierten fdata
  ###########################################################################
  msg2 "== BOLT-Optimierung (zlib-ng)"
  LD_PRELOAD=/usr/lib/libmimalloc.so llvm-bolt "$srcdir/zlib-ng/build_opt/libz-ng.so.${pkgver}.org" \
      --data "$srcdir/bolt_profile/combined.fdata" \
      -o "$srcdir/zlib-ng/build_opt/libz-ng.so.${pkgver}.bolt" \
      --dyno-stats --icf=safe --plt=all --hugify --peepholes=all \
      --x86-strip-redundant-address-size --indirect-call-promotion=all \
      --reorder-blocks=ext-tsp --reorder-functions=cdsort \
      --split-all-cold --split-eh --split-functions --split-strategy=cdsplit \
      --redirect-never-taken-jumps || exit 1

  msg2 "== BOLT-Optimierung (zlib-ng-compat)"
  LD_PRELOAD=/usr/lib/libmimalloc.so llvm-bolt "$srcdir/zlib-ng/build_opt_compat/libz.so.${_zlibver}.zlib-ng.org" \
      --data "$srcdir/bolt_profile/combined.fdata" \
      -o "$srcdir/zlib-ng/build_opt_compat/libz.so.${_zlibver}.zlib-ng.bolt" \
      --dyno-stats --icf=safe --plt=all --hugify --peepholes=all \
      --x86-strip-redundant-address-size --indirect-call-promotion=all \
      --reorder-blocks=ext-tsp --reorder-functions=cdsort \
      --split-all-cold --split-eh --split-functions --split-strategy=cdsplit \
      --redirect-never-taken-jumps || exit 1
}

check() {
  cd "zlib-ng"
  msg "Prüfe zlib-ng (PGO-optimierter Build)"
  ctest --test-dir build_opt --output-on-failure
  msg "Prüfe zlib-ng-compat (PGO-optimierter Build)"
  ctest --test-dir build_opt_compat --output-on-failure
}

package_zlib-ng() {
  pkgdesc='zlib-Ersatz mit Optimierungen für Systeme der nächsten Generation'
  provides=("libz-ng.so")
  options=(!strip)
  cd "zlib-ng"
  DESTDIR="${pkgdir}" cmake --install build_opt

  find "$pkgdir" -type f \( -name '*.so*' -o -name '*.a' -o -executable \) -print0 | \
    while IFS= read -r -d '' file; do
      if llvm-strip --strip-unneeded "$file" 2>/dev/null || llvm-strip --strip-all "$file" 2>/dev/null; then
        echo "Stripped: $file"
      else
        echo "Skipping: $file (kein gültiges Objekt)" >&2
      fi
    done

  if [ -f "$srcdir/zlib-ng/build_opt/libz-ng.so.${pkgver}.bolt" ]; then
    install -Dm755 "$srcdir/zlib-ng/build_opt/libz-ng.so.${pkgver}.bolt" "$pkgdir/usr/lib/libz-ng.so.${pkgver}"
  fi

  install -Dm644 LICENSE.md -t "${pkgdir}/usr/share/licenses/${pkgname[0]}"
  install -Dm644 README.md -t "${pkgdir}/usr/share/doc/${pkgname[0]}"
}

package_zlib-ng-compat() {
  pkgdesc='zlib-Ersatz mit Optimierungen für Systeme der nächsten Generation (zlib compat)'
  provides=("zlib=1:${_zlibver}" "libz.so")
  depends=('zlib-ng')
  conflicts=('zlib')
  replaces=('zlib')
  options=('staticlibs' !strip)
  cd "zlib-ng"
  DESTDIR="${pkgdir}" cmake --install build_opt_compat

  find "$pkgdir" -type f \( -name '*.so*' -o -name '*.a' -o -executable \) -print0 | \
    while IFS= read -r -d '' file; do
      if llvm-strip --strip-unneeded "$file" 2>/dev/null || llvm-strip --strip-all "$file" 2>/dev/null; then
        echo "Stripped: $file"
      else
        echo "Skipping: $file (kein gültiges Objekt)" >&2
      fi
    done

  if [ -f "$srcdir/zlib-ng/build_opt_compat/libz.so.${_zlibver}.zlib-ng.bolt" ]; then
    install -Dm755 "$srcdir/zlib-ng/build_opt_compat/libz.so.${_zlibver}.zlib-ng.bolt" "$pkgdir/usr/lib/libz.so.${_zlibver}.zlib-ng"
  fi

  install -Dm644 LICENSE.md -t "${pkgdir}/usr/share/licenses/${pkgname[0]}"
  install -Dm644 README.md -t "${pkgdir}/usr/share/doc/${pkgname[0]}"
}
