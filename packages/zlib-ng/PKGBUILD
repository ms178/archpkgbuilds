pkgname=(
  zlib-ng
  zlib-ng-compat
)
pkgver=2.3.1
pkgrel=15.4  # Critical CS-PGO restoration + /tmp build fix
_zlibver=1.3.1
pkgdesc='zlib-Ersatz mit Optimierungen für Systeme der nächsten Generation'
url='https://github.com/zlib-ng/zlib-ng'
arch=('x86_64')
license=('custom:zlib')
depends=('glibc')
makedepends=(
  cmake
  ninja
  git
  llvm
  clang
  bolt
  mimalloc
)
source=(git+https://github.com/zlib-ng/zlib-ng#tag=${pkgver}
ms178-1.patch
)
sha256sums=('SKIP')

prepare() {
  cd "${pkgname}"

  # Apply patches
  for src in "${source[@]}"; do
    src="${src%%::*}"
    src="${src##*/}"
    [[ $src = *.patch ]] || continue
    patch -Np1 -i "../${src}"
  done
}

# Training data generator
generate_training_data() {
    local pgo_dir="$1"
    echo "Generating comprehensive training corpus..."
    rm -rf "${pgo_dir}/training"
    mkdir -p "${pgo_dir}/training"

    # 30 diverse pattern files
    for i in {1..30}; do
        {
            seq 1 20000
            yes "pattern${i}" | head -n 20000
            dd if=/dev/urandom bs=16K count=20 2>/dev/null | base64 -w0
            printf "%0.sA" $(seq 1 500000)
        } > "${pgo_dir}/training/corpus_${i}.dat"
    done

    # Realistic data profiles
    dd if=/dev/urandom bs=1M count=100 2>/dev/null > "${pgo_dir}/training/random_100M.bin"
    seq 1 10000000 > "${pgo_dir}/training/sequential_10M.txt"
    yes "Repetitive pattern for dictionary training" | head -n 5000000 > "${pgo_dir}/training/repetitive_5M.txt"

    # Compression ratio ladder
    for i in {1..8}; do
        dd if=/dev/urandom bs=512K count=$((i * 25)) 2>/dev/null > "${pgo_dir}/training/entropy_${i}.bin"
    done

    # Real-world text corpus
    if [[ -d /usr/share/doc ]]; then
        find /usr/share/doc /usr/share/man -type f -size -512k 2>/dev/null | head -n 100 | while read -r f; do
            [[ -r "$f" ]] && cat "$f" 2>/dev/null >> "${pgo_dir}/training/real_world.txt"
        done
    fi
}

# Universal training runner
run_pgo_training() {
    local build_dir="$1"
    local pgo_dir="$2"
    local lib_path="${build_dir}"
    local tmp_dir="${pgo_dir}/tmp"
    mkdir -p "${tmp_dir}"

    # Test harness: All compression levels, strategies, window bits
    test_file() {
        local file="$1"
        local temp_base="${tmp_dir}/tmp_$$"

        for level in {1..9}; do
            LD_LIBRARY_PATH="${lib_path}" "${build_dir}/minigzip" -${level} < "${file}" > "${temp_base}.gz"
            LD_LIBRARY_PATH="${lib_path}" "${build_dir}/minigzip" -d < "${temp_base}.gz" > /dev/null
        done

        for strategy in {0..4}; do
            LD_LIBRARY_PATH="${lib_path}" "${build_dir}/example" -s${strategy} "${file}" /dev/null
        done

        for bits in {9..15}; do
            LD_LIBRARY_PATH="${lib_path}" "${build_dir}/example" "${file}" "${temp_base}.def" ${bits}
            LD_LIBRARY_PATH="${lib_path}" "${build_dir}/example" -d "${temp_base}.def" /dev/null ${bits}
        done

        rm -f "${temp_base}".*
    }

    # Process all training files
    find "${pgo_dir}/training" -type f -print0 | while IFS= read -r -d '' file; do
        test_file "${file}"

        # Parallel stress test
        for i in $(seq 1 $(nproc)); do
            LD_LIBRARY_PATH="${lib_path}" "${build_dir}/minigzip" -6 < "${file}" > /dev/null &
        done
        wait
    done

    rm -rf "${tmp_dir}"
}

build() {
    cd "zlib-ng"

    # CRITICAL FIX: Define all PGO paths INSIDE build() for /tmp compatibility
    local PGO_DIR="${srcdir}/pgo-data"
    local STANDARD_PROFILE_DIR="${PGO_DIR}/standard"
    local CS_PROFILE_DIR="${PGO_DIR}/cs"
    local MERGED_PROFDATA="${PGO_DIR}/merged.profdata"
    local BOLT_FDATA="${PGO_DIR}/bolt.fdata"

    local orig_cflags="${CFLAGS}"
    local orig_cxxflags="${CXXFLAGS}"
    local orig_ldflags="${LDFLAGS}"

    # Clean slate
    rm -rf "${PGO_DIR}"
    mkdir -p "${STANDARD_PROFILE_DIR}" "${CS_PROFILE_DIR}"

    # Generate training corpus
    generate_training_data "${PGO_DIR}"

    ###########################################################################
    # Phase 1: Standard PGO Instrumentation
    ###########################################################################
    msg2 "Phase 1: Building with standard PGO instrumentation..."

    export CFLAGS="${orig_cflags} -fprofile-generate=${STANDARD_PROFILE_DIR} -fno-omit-frame-pointer -mllvm -vp-counters-per-site=2000"
    export CXXFLAGS="${orig_cxxflags} -fprofile-generate=${STANDARD_PROFILE_DIR} -fno-omit-frame-pointer -mllvm -vp-counters-per-site=2000"
    export LDFLAGS="${orig_ldflags} -fprofile-generate=${STANDARD_PROFILE_DIR}"

    local cmake_options=(
        -G Ninja
        -DCMAKE_BUILD_TYPE=Release
        -DCMAKE_C_STANDARD=23
        -DCMAKE_INSTALL_PREFIX=/usr
        -DCMAKE_INSTALL_LIBDIR=lib
        -DWITH_GTEST=ON
        -DWITH_OPTIM=ON
        -DWITH_CRC32_CHORBA=OFF
        -DWITH_NATIVE_INSTRUCTIONS=ON
        -Wno-dev
    )

    cmake -B build_std_pgo "${cmake_options[@]}"
    cmake --build build_std_pgo
    cmake -B build_std_pgo_compat "${cmake_options[@]}" -DZLIB_COMPAT=ON
    cmake --build build_std_pgo_compat

    # Run standard PGO training
    msg2 "Phase 1: Running standard PGO training..."
    run_pgo_training "${srcdir}/zlib-ng/build_std_pgo" "${PGO_DIR}"
    run_pgo_training "${srcdir}/zlib-ng/build_std_pgo_compat" "${PGO_DIR}"

    # Run tests for coverage
    ctest --test-dir build_std_pgo --output-on-failure || true
    ctest --test-dir build_std_pgo_compat --output-on-failure || true

    # Merge standard profiles
    msg2 "Phase 1: Merging standard PGO profiles..."
    if ! llvm-profdata merge -output="${PGO_DIR}/standard.profdata" "${STANDARD_PROFILE_DIR}"/*.profraw; then
        error "Standard PGO profile merge failed"
        return 1
    fi

    ###########################################################################
    # Phase 2: Context-Sensitive PGO Instrumentation
    ###########################################################################
    msg2 "Phase 2: Building with context-sensitive PGO instrumentation..."

    export CFLAGS="${orig_cflags} -fprofile-use=${PGO_DIR}/standard.profdata -fcs-profile-generate=${CS_PROFILE_DIR} -fno-omit-frame-pointer -mllvm -vp-counters-per-site=2000"
    export CXXFLAGS="${orig_cxxflags} -fprofile-use=${PGO_DIR}/standard.profdata -fcs-profile-generate=${CS_PROFILE_DIR} -fno-omit-frame-pointer -mllvm -vp-counters-per-site=2000"
    export LDFLAGS="${orig_ldflags} -fprofile-use=${PGO_DIR}/standard.profdata -fcs-profile-generate=${CS_PROFILE_DIR}"

    cmake -B build_cs_pgo "${cmake_options[@]}"
    cmake --build build_cs_pgo
    cmake -B build_cs_pgo_compat "${cmake_options[@]}" -DZLIB_COMPAT=ON
    cmake --build build_cs_pgo_compat

    # Run CS-PGO training
    msg2 "Phase 2: Running context-sensitive PGO training..."
    run_pgo_training "${srcdir}/zlib-ng/build_cs_pgo" "${PGO_DIR}"
    run_pgo_training "${srcdir}/zlib-ng/build_cs_pgo_compat" "${PGO_DIR}"

    # Run tests for additional coverage
    ctest --test-dir build_cs_pgo --output-on-failure || true
    ctest --test-dir build_cs_pgo_compat --output-on-failure || true

    # Merge CS-PGO profiles with standard profiles
    msg2 "Phase 2: Merging CS-PGO and standard profiles..."
    if ! llvm-profdata merge -output="${MERGED_PROFDATA}" "${CS_PROFILE_DIR}"/*.profraw "${PGO_DIR}/standard.profdata"; then
        error "CS-PGO profile merge failed"
        return 1
    fi

    ###########################################################################
    # Phase 3: Final Optimized Build (with merged CS-PGO profiles)
    ###########################################################################
    msg2 "Phase 3: Building final optimized libraries with merged profiles..."

    export CFLAGS="${orig_cflags} -fprofile-use=${MERGED_PROFDATA} -fno-common -ffunction-sections -fdata-sections"
    export CXXFLAGS="${orig_cxxflags} -fprofile-use=${MERGED_PROFDATA} -fno-common -ffunction-sections -fdata-sections"
    export LDFLAGS="${orig_ldflags} -fprofile-use=${MERGED_PROFDATA} -Wl,--emit-relocs"

    cmake -B build_opt "${cmake_options[@]}" -DWITH_GTEST=OFF
    cmake --build build_opt
    cmake -B build_opt_compat "${cmake_options[@]}" -DWITH_GTEST=OFF -DZLIB_COMPAT=ON
    cmake --build build_opt_compat

    ###########################################################################
    # Phase 4: BOLT Instrumentation & Training
    ###########################################################################
    msg2 "Phase 4: BOLT instrumentation and training..."

    # BACKUP the CS-PGO optimized binary
    cp "${srcdir}/zlib-ng/build_opt/libz-ng.so.${pkgver}" "${srcdir}/zlib-ng/build_opt/libz-ng.so.${pkgver}.cspgo"
    cp "${srcdir}/zlib-ng/build_opt_compat/libz.so.${_zlibver}.zlib-ng" "${srcdir}/zlib-ng/build_opt_compat/libz.so.${_zlibver}.zlib-ng.cspgo"

    # Instrument the BACKUP
    llvm-bolt "${srcdir}/zlib-ng/build_opt/libz-ng.so.${pkgver}.cspgo" \
        --instrument --instrumentation-file-append-pid \
        --instrumentation-file="${BOLT_FDATA}" \
        -o "${srcdir}/zlib-ng/build_opt/libz-ng.so.${pkgver}.bolt.inst"

    llvm-bolt "${srcdir}/zlib-ng/build_opt_compat/libz.so.${_zlibver}.zlib-ng.cspgo" \
        --instrument --instrumentation-file-append-pid \
        --instrumentation-file="${BOLT_FDATA}" \
        -o "${srcdir}/zlib-ng/build_opt_compat/libz.so.${_zlibver}.zlib-ng.bolt.inst"

    # Install instrumented version for training
    mv "${srcdir}/zlib-ng/build_opt/libz-ng.so.${pkgver}.bolt.inst" "${srcdir}/zlib-ng/build_opt/libz-ng.so.${pkgver}"
    mv "${srcdir}/zlib-ng/build_opt_compat/libz.so.${_zlibver}.zlib-ng.bolt.inst" "${srcdir}/zlib-ng/build_opt_compat/libz.so.${_zlibver}.zlib-ng"

    # Run BOLT training
    export BOLT_PROFILE_FILE="${BOLT_FDATA}"
    run_pgo_training "${srcdir}/zlib-ng/build_opt" "${PGO_DIR}"
    run_pgo_training "${srcdir}/zlib-ng/build_opt_compat" "${PGO_DIR}"

    ###########################################################################
    # Phase 5: BOLT Profile Merging & Optimization
    ###########################################################################
    msg2 "Phase 5: Merging BOLT profiles..."

    # CRITICAL FIX: Unquoted glob for proper expansion
    local bolt_profiles=(${PGO_DIR}/bolt.fdata.*)
    if [[ ${#bolt_profiles[@]} -eq 0 ]]; then
        warning "No BOLT profiles generated, skipping BOLT optimization"
        # Restore CS-PGO binaries
        mv "${srcdir}/zlib-ng/build_opt/libz-ng.so.${pkgver}.cspgo" "${srcdir}/zlib-ng/build_opt/libz-ng.so.${pkgver}"
        mv "${srcdir}/zlib-ng/build_opt_compat/libz.so.${_zlibver}.zlib-ng.cspgo" "${srcdir}/zlib-ng/build_opt_compat/libz.so.${_zlibver}.zlib-ng"
    elif command -v merge-fdata >/dev/null 2>&1; then
        # PROPER: Unquoted glob pattern
        LD_PRELOAD=/usr/lib/libmimalloc.so merge-fdata ${PGO_DIR}/bolt.fdata.* > "${PGO_DIR}/bolt_merged.fdata"

        if [[ ! -s "${PGO_DIR}/bolt_merged.fdata" ]]; then
            warning "BOLT profile merge failed, skipping optimization"
            mv "${srcdir}/zlib-ng/build_opt/libz-ng.so.${pkgver}.cspgo" "${srcdir}/zlib-ng/build_opt/libz-ng.so.${pkgver}"
            mv "${srcdir}/zlib-ng/build_opt_compat/libz.so.${_zlibver}.zlib-ng.cspgo" "${srcdir}/zlib-ng/build_opt_compat/libz.so.${_zlibver}.zlib-ng"
        else
            msg2 "Phase 5: Applying BOLT optimizations..."

            # OPTIMIZE the CS-PGO binary, not the instrumented one
            LD_PRELOAD=/usr/lib/libmimalloc.so llvm-bolt "${srcdir}/zlib-ng/build_opt/libz-ng.so.${pkgver}.cspgo" \
                --data "${PGO_DIR}/bolt_merged.fdata" \
                -o "${srcdir}/zlib-ng/build_opt/libz-ng.so.${pkgver}.bolt" \
                --dyno-stats --lite=false --icf=all --plt=all --hugify --peepholes=all \
                --x86-strip-redundant-address-size --indirect-call-promotion=all \
                --reorder-blocks=ext-tsp --reorder-functions=cdsort --split-all-cold \
                --split-eh --split-functions --split-strategy=cdsplit || exit 1

            LD_PRELOAD=/usr/lib/libmimalloc.so llvm-bolt "${srcdir}/zlib-ng/build_opt_compat/libz.so.${_zlibver}.zlib-ng.cspgo" \
                --data "${PGO_DIR}/bolt_merged.fdata" \
                -o "${srcdir}/zlib-ng/build_opt_compat/libz.so.${_zlibver}.zlib-ng.bolt" \
                --dyno-stats --lite=false --icf=all --plt=all --hugify --peepholes=all \
                --x86-strip-redundant-address-size --indirect-call-promotion=all \
                --reorder-blocks=ext-tsp --reorder-functions=cdsort --split-all-cold \
                --split-eh --split-functions --split-strategy=cdsplit || exit 1

            # Install BOLT-optimized versions
            mv "${srcdir}/zlib-ng/build_opt/libz-ng.so.${pkgver}.bolt" "${srcdir}/zlib-ng/build_opt/libz-ng.so.${pkgver}"
            mv "${srcdir}/zlib-ng/build_opt_compat/libz.so.${_zlibver}.zlib-ng.bolt" "${srcdir}/zlib-ng/build_opt_compat/libz.so.${_zlibver}.zlib-ng"
        fi
    else
        warning "merge-fdata not found, skipping BOLT optimization"
        mv "${srcdir}/zlib-ng/build_opt/libz-ng.so.${pkgver}.cspgo" "${srcdir}/zlib-ng/build_opt/libz-ng.so.${pkgver}"
        mv "${srcdir}/zlib-ng/build_opt_compat/libz.so.${_zlibver}.zlib-ng.cspgo" "${srcdir}/zlib-ng/build_opt_compat/libz.so.${_zlibver}.zlib-ng"
    fi

    ###########################################################################
    # Phase 6: Finalize Symlinks
    ###########################################################################
    ln -sf "libz-ng.so.${pkgver}" "${srcdir}/zlib-ng/build_opt/libz-ng.so.2"
    ln -sf "libz-ng.so.2" "${srcdir}/zlib-ng/build_opt/libz-ng.so"
    ln -sf "libz.so.${_zlibver}.zlib-ng" "${srcdir}/zlib-ng/build_opt_compat/libz.so.1"
    ln -sf "libz.so.1" "${srcdir}/zlib-ng/build_opt_compat/libz.so"

    # Restore environment
    export CFLAGS="${orig_cflags}"
    export CXXFLAGS="${orig_cxxflags}"
    export LDFLAGS="${orig_ldflags}"
}

check() {
    cd "zlib-ng"
    msg "Testing CS-PGO + BOLT optimized builds..."
    ctest --test-dir build_opt --output-on-failure
    ctest --test-dir build_opt_compat --output-on-failure
}

package_zlib-ng() {
    pkgdesc='zlib-Ersatz mit Optimierungen für Systeme der nächsten Generation'
    provides=("libz-ng.so=2")
    options=(!strip)
    cd "zlib-ng"
    DESTDIR="${pkgdir}" cmake --install build_opt

    find "${pkgdir}" -type f \( -name '*.so*' -o -name '*.a' -o -executable \) -print0 | while IFS= read -r -d '' file; do
        llvm-strip --strip-unneeded "$file" 2>/dev/null || llvm-strip --strip-all "$file" 2>/dev/null || true
    done

    install -Dm644 LICENSE.md -t "${pkgdir}/usr/share/licenses/${pkgname[0]}"
    install -Dm644 README.md -t "${pkgdir}/usr/share/doc/${pkgname[0]}"
}

package_zlib-ng-compat() {
    pkgdesc='zlib-Ersatz mit Optimierungen für Systeme der nächsten Generation (zlib compat)'
    provides=("zlib=1:${_zlibver}" "libz.so=1")
    depends=('zlib-ng')
    conflicts=('zlib')
    replaces=('zlib')
    options=('staticlibs' !strip)
    cd "zlib-ng"
    DESTDIR="${pkgdir}" cmake --install build_opt_compat

    find "${pkgdir}" -type f \( -name '*.so*' -o -name '*.a' -o -executable \) -print0 | while IFS= read -r -d '' file; do
        llvm-strip --strip-unneeded "$file" 2>/dev/null || llvm-strip --strip-all "$file" 2>/dev/null || true
    done

    install -Dm644 LICENSE.md -t "${pkgdir}/usr/share/licenses/${pkgname[0]}"
    install -Dm644 README.md -t "${pkgdir}/usr/share/doc/${pkgname[0]}"
}
