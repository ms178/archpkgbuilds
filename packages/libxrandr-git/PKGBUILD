# Maintainer: James An <james@jamesan.ca>
# Contributor: Jan de Groot <jgc@archlinux.org>
# Contributor: Andreas Radke <andyrtr@archlinux.org>
# Contributor: Alexander Baldeck <alexander@archlinux.org>
# PGO Optimization: CachyOS

_pkgname=libxrandr
pkgname=libxrandr-git
pkgver=libXrandr.1.5.5.r0.g540c3ce
pkgrel=1
pkgdesc='X11 RandR extension library (PGO/CS-PGO optimized). Git version.'
arch=('i686' 'x86_64')
license=('custom')
url='http://xorg.freedesktop.org'
depends=('libxext' 'libxrender' 'xorgproto-git')
makedepends=('xorg-util-macros' 'git' 'clang' 'llvm')
provides=("$_pkgname=$pkgver")
conflicts=("$_pkgname")
source=("$_pkgname"::'git+http://anongit.freedesktop.org/git/xorg/lib/libXrandr.git')
md5sums=('SKIP')

pkgver() {
  cd "$_pkgname"
  (
    set -o pipefail
    git describe --long --tag | sed -r 's/([^-]*-g)/r\1/;s/-/./g' ||
    printf "r%s.%s" "$(git rev-list --count HEAD)" "$(git rev-parse --short HEAD)"
  )
}

prepare() {
  cd "$_pkgname"
  autoreconf -vfi

  # Generate comprehensive PGO training workload for XRandR
  cat > "${srcdir}/xrandr_pgo_workload.c" << 'EOF'
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <X11/Xlib.h>
#include <X11/extensions/Xrandr.h>

#define WORKLOAD_ITERATIONS 3
#define SYNC_INTERVAL 100

/* Sync with X server periodically to prevent buffer issues */
static inline void maybe_sync(Display *dpy, int counter) {
    if (counter % SYNC_INTERVAL == 0) {
        XSync(dpy, False);
    }
}

/* Exercise extension and version queries */
static void train_extension_queries(Display *dpy, int iterations) {
    int i;
    int event_base, error_base;
    int major, minor;

    for (i = 0; i < iterations; i++) {
        XRRQueryExtension(dpy, &event_base, &error_base);
        XRRQueryVersion(dpy, &major, &minor);
        maybe_sync(dpy, i);
    }
}

/* Exercise screen resources queries */
static void train_screen_resources(Display *dpy, Window root, int iterations) {
    int i;
    XRRScreenResources *res;
    XRRScreenResources *res_current;

    for (i = 0; i < iterations; i++) {
        /* Full screen resources (slower, more complete) */
        res = XRRGetScreenResources(dpy, root);
        if (res) {
            XRRFreeScreenResources(res);
        }

        /* Current screen resources (faster, cached) */
        res_current = XRRGetScreenResourcesCurrent(dpy, root);
        if (res_current) {
            XRRFreeScreenResources(res_current);
        }

        maybe_sync(dpy, i);
    }
}

/* Exercise screen size queries */
static void train_screen_size(Display *dpy, Window root, int iterations) {
    int i;
    int minWidth, minHeight, maxWidth, maxHeight;
    XRRScreenSize *sizes;
    int nsizes;
    Rotation current_rotation;
    SizeID current_size;
    Time config_timestamp;  /* Fixed: proper variable instead of NULL */
    Time timestamp;

    for (i = 0; i < iterations; i++) {
        /* Get size range */
        XRRGetScreenSizeRange(dpy, root, &minWidth, &minHeight, &maxWidth, &maxHeight);

        /* Get available sizes (legacy API) */
        sizes = XRRSizes(dpy, DefaultScreen(dpy), &nsizes);
        (void)sizes;

        /* Get current configuration (legacy API) */
        XRRScreenConfiguration *config = XRRGetScreenInfo(dpy, root);
        if (config) {
            current_size = XRRConfigCurrentConfiguration(config, &current_rotation);
            (void)current_size;

            /* Fixed: use proper Time variables instead of NULL */
            timestamp = XRRConfigTimes(config, &config_timestamp);
            (void)timestamp;
            (void)config_timestamp;

            XRRFreeScreenConfigInfo(config);
        }

        /* Get rotations */
        Rotation rotations = XRRRotations(dpy, DefaultScreen(dpy), &current_rotation);
        (void)rotations;

        maybe_sync(dpy, i);
    }
}

/* Exercise output info queries */
static void train_output_info(Display *dpy, Window root, XRRScreenResources *res, int iterations) {
    int i, j;

    if (!res || res->noutput == 0) return;

    for (i = 0; i < iterations; i++) {
        for (j = 0; j < res->noutput; j++) {
            XRROutputInfo *output_info = XRRGetOutputInfo(dpy, res, res->outputs[j]);
            if (output_info) {
                /* Access various output info fields to exercise parsing */
                volatile const char *name = output_info->name;
                volatile unsigned long nameLen = output_info->nameLen;
                volatile unsigned long mm_width = output_info->mm_width;
                volatile unsigned long mm_height = output_info->mm_height;
                volatile Connection connection = output_info->connection;
                volatile SubpixelOrder subpixel_order = output_info->subpixel_order;
                volatile int ncrtc = output_info->ncrtc;
                volatile int nclone = output_info->nclone;
                volatile int nmode = output_info->nmode;
                volatile int npreferred = output_info->npreferred;

                (void)name; (void)nameLen; (void)mm_width; (void)mm_height;
                (void)connection; (void)subpixel_order;
                (void)ncrtc; (void)nclone; (void)nmode; (void)npreferred;

                XRRFreeOutputInfo(output_info);
            }
        }
        maybe_sync(dpy, i);
    }
}

/* Exercise CRTC info queries */
static void train_crtc_info(Display *dpy, XRRScreenResources *res, int iterations) {
    int i, j;

    if (!res || res->ncrtc == 0) return;

    for (i = 0; i < iterations; i++) {
        for (j = 0; j < res->ncrtc; j++) {
            XRRCrtcInfo *crtc_info = XRRGetCrtcInfo(dpy, res, res->crtcs[j]);
            if (crtc_info) {
                /* Access CRTC info fields */
                volatile int x = crtc_info->x;
                volatile int y = crtc_info->y;
                volatile unsigned int width = crtc_info->width;
                volatile unsigned int height = crtc_info->height;
                volatile RRMode mode = crtc_info->mode;
                volatile Rotation rotation = crtc_info->rotation;
                volatile int noutput = crtc_info->noutput;
                volatile int npossible = crtc_info->npossible;

                (void)x; (void)y; (void)width; (void)height;
                (void)mode; (void)rotation; (void)noutput; (void)npossible;

                /* Get CRTC gamma */
                XRRCrtcGamma *gamma = XRRGetCrtcGamma(dpy, res->crtcs[j]);
                if (gamma) {
                    XRRFreeGamma(gamma);
                }

                /* Get gamma size */
                int gamma_size = XRRGetCrtcGammaSize(dpy, res->crtcs[j]);
                (void)gamma_size;

                XRRFreeCrtcInfo(crtc_info);
            }
        }
        maybe_sync(dpy, i);
    }
}

/* Exercise mode info handling */
static void train_mode_info(Display *dpy, XRRScreenResources *res, int iterations) {
    int i, j;

    if (!res || res->nmode == 0) return;

    for (i = 0; i < iterations; i++) {
        /* Iterate through all modes */
        for (j = 0; j < res->nmode; j++) {
            XRRModeInfo *mode = &res->modes[j];

            /* Access mode info fields */
            volatile RRMode id = mode->id;
            volatile unsigned int width = mode->width;
            volatile unsigned int height = mode->height;
            volatile unsigned long dotClock = mode->dotClock;
            volatile unsigned int hSyncStart = mode->hSyncStart;
            volatile unsigned int hSyncEnd = mode->hSyncEnd;
            volatile unsigned int hTotal = mode->hTotal;
            volatile unsigned int hSkew = mode->hSkew;
            volatile unsigned int vSyncStart = mode->vSyncStart;
            volatile unsigned int vSyncEnd = mode->vSyncEnd;
            volatile unsigned int vTotal = mode->vTotal;
            volatile const char *name = mode->name;
            volatile unsigned int nameLength = mode->nameLength;
            volatile XRRModeFlags modeFlags = mode->modeFlags;

            (void)id; (void)width; (void)height; (void)dotClock;
            (void)hSyncStart; (void)hSyncEnd; (void)hTotal; (void)hSkew;
            (void)vSyncStart; (void)vSyncEnd; (void)vTotal;
            (void)name; (void)nameLength; (void)modeFlags;
        }
        maybe_sync(dpy, i);
    }
}

/* Exercise output property queries */
static void train_output_properties(Display *dpy, XRRScreenResources *res, int iterations) {
    int i, j, k;

    if (!res || res->noutput == 0) return;

    for (i = 0; i < iterations; i++) {
        for (j = 0; j < res->noutput; j++) {
            int nprop = 0;
            Atom *props = XRRListOutputProperties(dpy, res->outputs[j], &nprop);

            if (props && nprop > 0) {
                /* Only query first few properties to avoid overwhelming X server */
                int max_props = nprop < 5 ? nprop : 5;
                for (k = 0; k < max_props; k++) {
                    XRRPropertyInfo *prop_info = XRRQueryOutputProperty(dpy, res->outputs[j], props[k]);
                    if (prop_info) {
                        XFree(prop_info);
                    }

                    /* Get property value */
                    Atom actual_type;
                    int actual_format;
                    unsigned long nitems, bytes_after;
                    unsigned char *data = NULL;

                    if (XRRGetOutputProperty(dpy, res->outputs[j], props[k],
                                            0, 100, False, False, AnyPropertyType,
                                            &actual_type, &actual_format,
                                            &nitems, &bytes_after, &data) == Success) {
                        if (data) {
                            XFree(data);
                        }
                    }
                }
                XFree(props);
            }
        }
        maybe_sync(dpy, i);
    }
}

/* Exercise provider queries (for multi-GPU systems) */
static void train_provider_info(Display *dpy, Window root, XRRScreenResources *res, int iterations) {
    int i, j;

    if (!res) return;

    for (i = 0; i < iterations; i++) {
        XRRProviderResources *prov_res = XRRGetProviderResources(dpy, root);
        if (prov_res) {
            for (j = 0; j < prov_res->nproviders; j++) {
                XRRProviderInfo *prov_info = XRRGetProviderInfo(dpy, res, prov_res->providers[j]);
                if (prov_info) {
                    /* Access provider info fields */
                    volatile unsigned int capabilities = prov_info->capabilities;
                    volatile const char *name = prov_info->name;
                    volatile int ncrtcs = prov_info->ncrtcs;
                    volatile int noutputs = prov_info->noutputs;
                    volatile int nassoc = prov_info->nassociatedproviders;

                    (void)capabilities; (void)name;
                    (void)ncrtcs; (void)noutputs; (void)nassoc;

                    XRRFreeProviderInfo(prov_info);
                }
            }
            XRRFreeProviderResources(prov_res);
        }
        maybe_sync(dpy, i);
    }
}

/* Exercise monitor queries (RandR 1.5+) */
static void train_monitor_info(Display *dpy, Window root, int iterations) {
    int i, j;

    for (i = 0; i < iterations; i++) {
        int nmonitors = 0;
        XRRMonitorInfo *monitors = XRRGetMonitors(dpy, root, True, &nmonitors);
        if (monitors && nmonitors > 0) {
            for (j = 0; j < nmonitors; j++) {
                /* Access monitor info fields */
                volatile Atom name = monitors[j].name;
                volatile Bool primary = monitors[j].primary;
                volatile Bool automatic = monitors[j].automatic;
                volatile int noutput = monitors[j].noutput;
                volatile int x = monitors[j].x;
                volatile int y = monitors[j].y;
                volatile int width = monitors[j].width;
                volatile int height = monitors[j].height;
                volatile int mwidth = monitors[j].mwidth;
                volatile int mheight = monitors[j].mheight;

                (void)name; (void)primary; (void)automatic; (void)noutput;
                (void)x; (void)y; (void)width; (void)height;
                (void)mwidth; (void)mheight;
            }
            XRRFreeMonitors(monitors);
        }

        /* Also get without active filter */
        monitors = XRRGetMonitors(dpy, root, False, &nmonitors);
        if (monitors) {
            XRRFreeMonitors(monitors);
        }

        maybe_sync(dpy, i);
    }
}

/* Exercise primary output queries */
static void train_primary_output(Display *dpy, Window root, int iterations) {
    int i;

    for (i = 0; i < iterations; i++) {
        RROutput primary = XRRGetOutputPrimary(dpy, root);
        (void)primary;
        maybe_sync(dpy, i);
    }
}

/* Exercise event selection (without actually waiting for events) */
static void train_event_selection(Display *dpy, Window root, int iterations) {
    int i;

    for (i = 0; i < iterations; i++) {
        /* Select for various event types */
        XRRSelectInput(dpy, root,
                      RRScreenChangeNotifyMask |
                      RRCrtcChangeNotifyMask |
                      RROutputChangeNotifyMask |
                      RROutputPropertyNotifyMask);

        XSync(dpy, False);

        /* Deselect events */
        XRRSelectInput(dpy, root, 0);

        maybe_sync(dpy, i);
    }
}

/* Exercise refresh rate calculations */
static void train_refresh_rates(Display *dpy, int iterations) {
    int i, j;
    int screen = DefaultScreen(dpy);
    Window root = RootWindow(dpy, screen);

    for (i = 0; i < iterations; i++) {
        int nsizes = 0;
        XRRScreenSize *sizes = XRRSizes(dpy, screen, &nsizes);
        (void)sizes;

        for (j = 0; j < nsizes && j < 10; j++) {
            int nrates = 0;
            short *rates = XRRRates(dpy, screen, j, &nrates);
            (void)rates;
        }

        XRRScreenConfiguration *config = XRRGetScreenInfo(dpy, root);
        if (config) {
            Rotation rotation;
            short rate = XRRConfigCurrentRate(config);
            SizeID size = XRRConfigCurrentConfiguration(config, &rotation);
            (void)rate;
            (void)size;
            XRRFreeScreenConfigInfo(config);
        }

        maybe_sync(dpy, i);
    }
}

int main(int argc, char **argv) {
    Display *dpy;
    Window root;
    int screen;
    int event_base, error_base;
    int major, minor;
    XRRScreenResources *res = NULL;
    int iterations = argc > 1 ? atoi(argv[1]) : WORKLOAD_ITERATIONS;

    fprintf(stderr, "XRandR PGO Training starting...\n");

    dpy = XOpenDisplay(NULL);
    if (!dpy) {
        fprintf(stderr, "Cannot open display, skipping XRandR training\n");
        return 0;
    }

    if (!XRRQueryExtension(dpy, &event_base, &error_base)) {
        fprintf(stderr, "XRandR extension not available\n");
        XCloseDisplay(dpy);
        return 0;
    }

    if (!XRRQueryVersion(dpy, &major, &minor)) {
        fprintf(stderr, "Cannot query XRandR version\n");
        XCloseDisplay(dpy);
        return 0;
    }

    fprintf(stderr, "XRandR version %d.%d\n", major, minor);

    screen = DefaultScreen(dpy);
    root = RootWindow(dpy, screen);

    /* Get screen resources once for reuse */
    res = XRRGetScreenResourcesCurrent(dpy, root);
    if (!res) {
        fprintf(stderr, "Warning: Could not get screen resources\n");
    }

    /* Reduced iteration counts to avoid overwhelming X server */
    fprintf(stderr, "Training: Extension queries (%d iterations)...\n", iterations * 200);
    train_extension_queries(dpy, iterations * 200);

    fprintf(stderr, "Training: Screen resources (%d iterations)...\n", iterations * 20);
    train_screen_resources(dpy, root, iterations * 20);

    fprintf(stderr, "Training: Screen size (%d iterations)...\n", iterations * 100);
    train_screen_size(dpy, root, iterations * 100);

    if (res) {
        fprintf(stderr, "Training: Output info (%d iterations)...\n", iterations * 50);
        train_output_info(dpy, root, res, iterations * 50);

        fprintf(stderr, "Training: CRTC info (%d iterations)...\n", iterations * 50);
        train_crtc_info(dpy, res, iterations * 50);

        fprintf(stderr, "Training: Mode info (%d iterations)...\n", iterations * 100);
        train_mode_info(dpy, res, iterations * 100);

        fprintf(stderr, "Training: Output properties (%d iterations)...\n", iterations * 20);
        train_output_properties(dpy, res, iterations * 20);

        fprintf(stderr, "Training: Provider info (%d iterations)...\n", iterations * 30);
        train_provider_info(dpy, root, res, iterations * 30);
    }

    fprintf(stderr, "Training: Monitor info (%d iterations)...\n", iterations * 50);
    train_monitor_info(dpy, root, iterations * 50);

    fprintf(stderr, "Training: Primary output (%d iterations)...\n", iterations * 100);
    train_primary_output(dpy, root, iterations * 100);

    fprintf(stderr, "Training: Event selection (%d iterations)...\n", iterations * 30);
    train_event_selection(dpy, root, iterations * 30);

    fprintf(stderr, "Training: Refresh rates (%d iterations)...\n", iterations * 50);
    train_refresh_rates(dpy, iterations * 50);

    if (res) {
        XRRFreeScreenResources(res);
    }

    XSync(dpy, False);
    XCloseDisplay(dpy);

    fprintf(stderr, "XRandR PGO Training complete.\n");
    return 0;
}
EOF
}

# Run the workload against the build directory using libtool
_run_xrandr_workload() {
  local build_dir="$1"
  local pgo_flags="$2"
  local orig_cflags="$3"
  local orig_ldflags="$4"

  cd "$build_dir" || return 1

  local lib_dir="${build_dir}/src/.libs"
  local include_dir="${build_dir}/include"
  local libtool_la="src/libXrandr.la"

  if [[ ! -f "$libtool_la" ]]; then
    echo "Error: Could not find $libtool_la"
    find "$build_dir" -name "*.la" -print 2>/dev/null
    return 1
  fi

  echo "Using libtool archive: $libtool_la"
  echo "Library directory: $lib_dir"
  ls -la "$lib_dir"/libXrandr*.so* 2>/dev/null || echo "No libXrandr shared libraries found"

  echo "Compiling XRandR PGO workload using libtool..."

  CC="${CC:-clang}" \
  CFLAGS="${orig_cflags} ${pgo_flags}" \
  LDFLAGS="${orig_ldflags} ${pgo_flags}" \
  ./libtool --tag=CC --mode=link "${CC:-clang}" \
    "${srcdir}/xrandr_pgo_workload.c" \
    -o "${srcdir}/xrandr_pgo_runner" \
    -I"$include_dir" \
    -I"${srcdir}/${_pkgname}/include" \
    "$libtool_la" \
    -lX11 -lXrender -lXext \
    -Wl,-rpath,"$lib_dir" || { echo "Failed to compile workload"; return 1; }

  echo "Running XRandR PGO workload..."
  "${srcdir}/xrandr_pgo_runner" 5 || echo "Warning: Workload exited with non-zero status (may be missing display)"

  # Additional runs with varying parameters for diverse profile coverage
  "${srcdir}/xrandr_pgo_runner" 3 || true
  "${srcdir}/xrandr_pgo_runner" 8 || true

  rm -f "${srcdir}/xrandr_pgo_runner"
  return 0
}

build() {
  # --- Setup ---
  export CC="clang"
  export CXX="clang++"
  local _original_cflags="${CFLAGS}"
  local _original_cxxflags="${CXXFLAGS}"
  local _original_ldflags="${LDFLAGS}"

  local PGO_DATA_DIR="${srcdir}/pgo_data"
  local CS_PGO_DATA_DIR="${srcdir}/cspgo_data"
  mkdir -p "$PGO_DATA_DIR" "$CS_PGO_DATA_DIR"

  trap 'rm -rf "$PGO_DATA_DIR" "$CS_PGO_DATA_DIR" "${srcdir}/xrandr_pgo_workload.c" "${srcdir}/xrandr_pgo_runner"' EXIT

  local _configure_opts=(
    --prefix=/usr
    --sysconfdir=/etc
    --disable-static
  )

  local pgo_failed=false
  # --- End Setup ---

  cd "${srcdir}/${_pkgname}"

  # --- Stage 1: PGO Instrumentation Build ---
  msg2 "Stage 1: Building PGO instrumented build..."

  local _pgo_gen_flags="-fprofile-generate=${PGO_DATA_DIR}"

  export CFLAGS="${_original_cflags} ${_pgo_gen_flags}"
  export CXXFLAGS="${_original_cxxflags} ${_pgo_gen_flags}"
  export LDFLAGS="${_original_ldflags} ${_pgo_gen_flags}"

  ./configure "${_configure_opts[@]}" || { echo "Configure failed (Stage 1)"; return 1; }
  make -j1 || { echo "Make failed (Stage 1)"; return 1; }

  # --- Stage 1: PGO Training Run ---
  msg2 "Stage 1: Running PGO training workloads..."
  export LLVM_PROFILE_FILE="${PGO_DATA_DIR}/libxrandr-%p-%m.profraw"

  # Run custom workload
  _run_xrandr_workload "$PWD" "${_pgo_gen_flags}" "${_original_cflags}" "${_original_ldflags}" || {
    echo "Custom workload failed (Stage 1)"
    pgo_failed=true
  }

  unset LLVM_PROFILE_FILE

  # --- Stage 1: Merge PGO Profiles ---
  msg2 "Stage 1: Merging PGO profiles..."
  sleep 1

  if ! find "$PGO_DATA_DIR" -name "*.profraw" 2>/dev/null | grep -q .; then
    echo "No raw PGO profile data (*.profraw) generated. Aborting PGO."
    pgo_failed=true
  elif ! $pgo_failed; then
    if ! llvm-profdata merge -output="${PGO_DATA_DIR}/default.profdata" "${PGO_DATA_DIR}"/*.profraw; then
      echo "llvm-profdata merge failed (Stage 1). Aborting PGO."
      pgo_failed=true
    elif [[ ! -s "${PGO_DATA_DIR}/default.profdata" ]]; then
      echo "Merged PGO profile data is empty (Stage 1). Aborting PGO."
      pgo_failed=true
    fi
    rm -f "${PGO_DATA_DIR}"/*.profraw
  fi
  # --- End Stage 1 ---

  # --- Stage 2: CS-PGO Instrumentation Build ---
  if ! $pgo_failed; then
    msg2 "Stage 2: Building CS-PGO instrumented build..."
    make distclean || echo "Warning: make distclean failed before Stage 2"

    if [[ ! -f configure ]]; then
      autoreconf -vfi || { echo "autoreconf failed before Stage 2"; pgo_failed=true; }
    fi

    if ! $pgo_failed; then
      local _cspgo_gen_flags="-fprofile-use=${PGO_DATA_DIR}/default.profdata -fcs-profile-generate=${CS_PGO_DATA_DIR}"

      export CFLAGS="${_original_cflags} ${_cspgo_gen_flags}"
      export CXXFLAGS="${_original_cxxflags} ${_cspgo_gen_flags}"
      export LDFLAGS="${_original_ldflags} ${_cspgo_gen_flags}"

      ./configure "${_configure_opts[@]}" || { echo "Configure failed (Stage 2)"; pgo_failed=true; }

      if ! $pgo_failed; then
        make -j"$(nproc)" || { echo "Make failed (Stage 2)"; pgo_failed=true; }
      fi
    fi
  fi
  # --- End Stage 2 ---

  # --- Stage 2: CS-PGO Training Run ---
  if ! $pgo_failed; then
    msg2 "Stage 2: Running CS-PGO training workloads..."
    export LLVM_PROFILE_FILE="${CS_PGO_DATA_DIR}/libxrandr-cs-%p-%m.profraw"

    _run_xrandr_workload "$PWD" "${_cspgo_gen_flags}" "${_original_cflags}" "${_original_ldflags}" || {
      echo "Custom workload failed (Stage 2)"
      pgo_failed=true
    }

    unset LLVM_PROFILE_FILE

    # --- Stage 2: Merge CS-PGO Profiles ---
    msg2 "Stage 2: Merging CS-PGO profiles..."
    sleep 1

    if ! find "$CS_PGO_DATA_DIR" -name "*.profraw" 2>/dev/null | grep -q .; then
      echo "Warning: No raw CS-PGO profile data generated. Using Stage 1 PGO data."
      cp "${PGO_DATA_DIR}/default.profdata" "${CS_PGO_DATA_DIR}/cs.profdata" || {
        echo "Failed to copy fallback profile data."
        pgo_failed=true
      }
    elif ! $pgo_failed; then
      if ! llvm-profdata merge -output="${CS_PGO_DATA_DIR}/cs.profdata" \
           "${CS_PGO_DATA_DIR}"/*.profraw "${PGO_DATA_DIR}/default.profdata"; then
        echo "llvm-profdata merge failed (Stage 2). Aborting CS-PGO."
        pgo_failed=true
      fi
      rm -f "${CS_PGO_DATA_DIR}"/*.profraw
    fi

    if ! $pgo_failed && [[ ! -s "${CS_PGO_DATA_DIR}/cs.profdata" ]]; then
      echo "Final merged CS-PGO profile is empty (Stage 2). Aborting CS-PGO."
      pgo_failed=true
    fi
  fi
  # --- End Stage 2 ---

  # --- Stage 3: Final Optimized Build ---
  msg2 "Stage 3: Building final optimized build..."
  make distclean || echo "Warning: make distclean failed before Stage 3"

  if [[ ! -f configure ]]; then
    autoreconf -vfi || { echo "autoreconf failed before Stage 3"; return 1; }
  fi

  CFLAGS="${_original_cflags}"
  CXXFLAGS="${_original_cxxflags}"
  LDFLAGS="${_original_ldflags}"

  if ! $pgo_failed; then
    local _final_opt_flags=""
    if [[ -s "${CS_PGO_DATA_DIR}/cs.profdata" ]]; then
      msg2 "Applying CS-PGO profile data for final build."
      _final_opt_flags="-fprofile-use=${CS_PGO_DATA_DIR}/cs.profdata"
    elif [[ -s "${PGO_DATA_DIR}/default.profdata" ]]; then
      msg2 "Applying fallback PGO profile data for final build."
      _final_opt_flags="-fprofile-use=${PGO_DATA_DIR}/default.profdata"
    else
      warning "No usable profile data found. Building without PGO."
    fi
    CFLAGS+=" ${_final_opt_flags}"
    CXXFLAGS+=" ${_final_opt_flags}"
    LDFLAGS+=" ${_final_opt_flags}"
  else
    warning "Building final version without PGO optimization due to previous errors."
  fi

  export CFLAGS CXXFLAGS LDFLAGS

  ./configure "${_configure_opts[@]}" || { echo "Configure failed (Stage 3)"; return 1; }
  make -j"$(nproc)" || { echo "Make failed (Stage 3)"; return 1; }
  # --- End Stage 3 ---

  if $pgo_failed; then
    warning "PGO optimization could not be fully applied. Package built without PGO."
  else
    msg "CS-PGO build process completed successfully."
  fi
}

package() {
  cd "${srcdir}/${_pkgname}"
  make DESTDIR="${pkgdir}" install

  install -Dm644 COPYING "${pkgdir}/usr/share/licenses/${_pkgname}/COPYING"
}
