# Maintainer: Super Genius CachyOS Maintainer
pkgname=icu
pkgver=78.1
pkgrel=2.1
pkgdesc="International Components for Unicode library (PGO+LTO optimized)"
arch=(x86_64)
url="https://icu.unicode.org"
license=('LicenseRef-Unicode-3.0'
         'BSD-2-Clause'
         'BSD-3-Clause'
         'NAIST-2003')
depends=('gcc-libs' 'glibc' 'sh')
makedepends=('python' 'gcc' 'binutils')
provides=(libicu{data,i18n,io,test,tu,uc}.so)
source=(https://github.com/unicode-org/icu/releases/download/release-${pkgver}/icu4c-${pkgver}-sources.tgz{,.asc}
        ICU-22132.patch)
sha512sums=('c366398fdb50afc6355a8c45ed1d68a18eaa5f07a5d1c4555becbcfb9d4073e65ebe1e9caf24b93779b11b36cd813c98dd59e4b19f008851f25c7262811c112d'
            'SKIP'
            '1178062ccfcf7ecc698c64132b3612e73f9c4b0bbfaa668ae2039f3eb4cb2722d0b08a9f45b057da10def7a308d5c8d14c0c644892e7f11092c9cc488c850ab7')
validpgpkeys=('E52F07877A5805F9AF4AB0ACD46C5610D06E7001')

prepare() {
  cd icu/source

  # Apply patch if needed
  # patch -Np2 -i "$srcdir/ICU-22132.patch"

  # Create comprehensive ICU training program (English + German focused)
  cat > "$srcdir/icu-training.cpp" << 'EOF'
#include <unicode/utypes.h>
#include <unicode/ucnv.h>
#include <unicode/ustring.h>
#include <unicode/unistr.h>
#include <unicode/coll.h>
#include <unicode/sortkey.h>
#include <unicode/datefmt.h>
#include <unicode/numfmt.h>
#include <unicode/calendar.h>
#include <unicode/timezone.h>
#include <unicode/brkiter.h>
#include <unicode/regex.h>
#include <unicode/normalizer2.h>
#include <unicode/locid.h>
#include <unicode/translit.h>
#include <unicode/ucsdet.h>
#include <unicode/idna.h>
#include <unicode/casemap.h>
#include <unicode/schriter.h>

#include <iostream>
#include <vector>
#include <string>
#include <cstring>
#include <cstdlib>

using namespace icu;

// Focused locale list: English and German variants
static const char* TRAINING_LOCALES[] = {
    "en_US", "en_GB", "en_CA", "en_AU",
    "de_DE", "de_AT", "de_CH", "de_LU"
};

static const int NUM_LOCALES = sizeof(TRAINING_LOCALES) / sizeof(TRAINING_LOCALES[0]);

// Sample texts: English and German
static const char* SAMPLE_TEXTS[] = {
    "The quick brown fox jumps over the lazy dog. Testing 1234567890!",
    "Pack my box with five dozen liquor jugs. 0123456789",
    "How vexingly quick daft zebras jump! Special chars: @#$%^&*()",
    "The five boxing wizards jump quickly. Email: test@example.com",
    "Sphinx of black quartz, judge my vow. Price: $1,234.56",
    "Zwölf Boxkämpfer jagen Viktor quer über den großen Sylter Deich.",
    "Franz jagt im komplett verwahrlosten Taxi quer durch Bayern.",
    "Vogel Quax zwickt Johnys Pferd Bim. Preis: 1.234,56 EUR",
    "Schweißgequält vom öden Text zürnt Typograf Jakob. Äußerst wichtig!",
    "Falsches Üben von Xylophonmusik quält jeden größeren Zwerg."
};

static const int NUM_TEXTS = sizeof(SAMPLE_TEXTS) / sizeof(SAMPLE_TEXTS[0]);

void train_conversion(int iterations) {
    std::cout << "Training: Character conversion..." << std::endl;
    UErrorCode status = U_ZERO_ERROR;

    const char* encodings[] = {
        "UTF-8", "UTF-16", "UTF-32",
        "ISO-8859-1", "ISO-8859-15",
        "Windows-1252", "Windows-1251"
    };

    for (int iter = 0; iter < iterations; iter++) {
        for (size_t i = 0; i < 7; i++) {
            for (int j = 0; j < NUM_TEXTS; j++) {
                status = U_ZERO_ERROR;
                UConverter* conv = ucnv_open(encodings[i], &status);
                if (U_SUCCESS(status)) {
                    UChar dest[1000];
                    int32_t destLen = ucnv_toUChars(conv, dest, 1000,
                                                    SAMPLE_TEXTS[j], -1, &status);
                    if (U_SUCCESS(status)) {
                        char back[1000];
                        ucnv_fromUChars(conv, back, 1000, dest, destLen, &status);
                    }
                    ucnv_close(conv);
                }
            }
        }
    }
}

void train_collation(int iterations) {
    std::cout << "Training: Collation..." << std::endl;
    UErrorCode status = U_ZERO_ERROR;

    for (int iter = 0; iter < iterations; iter++) {
        for (int loc = 0; loc < NUM_LOCALES; loc++) {
            Locale locale(TRAINING_LOCALES[loc]);
            status = U_ZERO_ERROR;

            Collator* coll = Collator::createInstance(locale, status);
            if (U_SUCCESS(status)) {
                for (int strength = Collator::PRIMARY; strength <= Collator::IDENTICAL; strength++) {
                    coll->setStrength((Collator::ECollationStrength)strength);

                    for (int i = 0; i < NUM_TEXTS - 1; i++) {
                        UnicodeString str1 = UnicodeString::fromUTF8(SAMPLE_TEXTS[i]);
                        UnicodeString str2 = UnicodeString::fromUTF8(SAMPLE_TEXTS[i + 1]);

                        UCollationResult result = coll->compare(str1, str2, status);
                        (void)result;

                        uint8_t key1[256], key2[256];
                        coll->getSortKey(str1, key1, 256);
                        coll->getSortKey(str2, key2, 256);
                    }
                }
                delete coll;
            }
        }
    }
}

void train_formatting(int iterations) {
    std::cout << "Training: Date/Number formatting..." << std::endl;
    UErrorCode status = U_ZERO_ERROR;
    UDate now = Calendar::getNow();

    for (int iter = 0; iter < iterations; iter++) {
        for (int loc = 0; loc < NUM_LOCALES; loc++) {
            Locale locale(TRAINING_LOCALES[loc]);
            status = U_ZERO_ERROR;

            DateFormat* df = DateFormat::createDateTimeInstance(
                DateFormat::FULL, DateFormat::FULL, locale);
            if (df) {
                UnicodeString dateStr;
                df->format(now, dateStr);
                df->parse(dateStr, status);
                delete df;
            }

            status = U_ZERO_ERROR;
            NumberFormat* nf = NumberFormat::createInstance(locale, status);
            if (U_SUCCESS(status) && nf) {
                UnicodeString numStr;
                nf->format(123456.789, numStr);
                Formattable result;
                nf->parse(numStr, result, status);
                delete nf;
            }

            status = U_ZERO_ERROR;
            NumberFormat* cf = NumberFormat::createCurrencyInstance(locale, status);
            if (U_SUCCESS(status) && cf) {
                UnicodeString curStr;
                cf->format(1234.56, curStr);
                delete cf;
            }
        }
    }
}

void train_boundaries(int iterations) {
    std::cout << "Training: Text boundary analysis..." << std::endl;
    UErrorCode status = U_ZERO_ERROR;

    for (int iter = 0; iter < iterations; iter++) {
        for (int loc = 0; loc < NUM_LOCALES; loc++) {
            Locale locale(TRAINING_LOCALES[loc]);

            status = U_ZERO_ERROR;
            BreakIterator* wordBrk = BreakIterator::createWordInstance(locale, status);
            if (U_SUCCESS(status) && wordBrk) {
                for (int i = 0; i < NUM_TEXTS; i++) {
                    UnicodeString text = UnicodeString::fromUTF8(SAMPLE_TEXTS[i]);
                    wordBrk->setText(text);
                    int32_t pos = wordBrk->first();
                    while (pos != BreakIterator::DONE) {
                        pos = wordBrk->next();
                    }
                }
                delete wordBrk;
            }
        }
    }
}

void train_normalization(int iterations) {
    std::cout << "Training: Normalization..." << std::endl;
    UErrorCode status = U_ZERO_ERROR;

    const Normalizer2* nfc = Normalizer2::getNFCInstance(status);
    const Normalizer2* nfd = Normalizer2::getNFDInstance(status);

    for (int iter = 0; iter < iterations; iter++) {
        for (int i = 0; i < NUM_TEXTS; i++) {
            status = U_ZERO_ERROR;
            UnicodeString text = UnicodeString::fromUTF8(SAMPLE_TEXTS[i]);

            if (nfc) {
                UnicodeString normalized = nfc->normalize(text, status);
            }
            if (nfd) {
                status = U_ZERO_ERROR;
                UnicodeString normalized = nfd->normalize(text, status);
            }
        }
    }
}

void train_regex(int iterations) {
    std::cout << "Training: Regular expressions..." << std::endl;
    UErrorCode status = U_ZERO_ERROR;

    const char* patterns[] = {
        "\\b\\w+\\b",
        "\\d+",
        "[a-zA-Z]+"
    };

    for (int iter = 0; iter < iterations; iter++) {
        for (size_t p = 0; p < 3; p++) {
            status = U_ZERO_ERROR;
            UnicodeString pattern = UnicodeString::fromUTF8(patterns[p]);
            RegexPattern* re = RegexPattern::compile(pattern, 0, status);

            if (U_SUCCESS(status) && re) {
                for (int i = 0; i < NUM_TEXTS; i++) {
                    status = U_ZERO_ERROR;
                    UnicodeString text = UnicodeString::fromUTF8(SAMPLE_TEXTS[i]);
                    RegexMatcher* matcher = re->matcher(text, status);

                    if (U_SUCCESS(status) && matcher) {
                        while (matcher->find()) {
                            matcher->group(status);
                        }
                        delete matcher;
                    }
                }
                delete re;
            }
        }
    }
}

int main(int argc, char* argv[]) {
    int iterations = 1;
    if (argc > 1) {
        iterations = atoi(argv[1]);
        if (iterations < 1) iterations = 1;
        if (iterations > 10) iterations = 10;
    }

    std::cout << "=== ICU Training Workload ===" << std::endl;
    std::cout << "Iterations: " << iterations << std::endl;

    train_conversion(iterations);
    train_collation(iterations);
    train_formatting(iterations);
    train_boundaries(iterations);
    train_normalization(iterations);
    train_regex(iterations);

    std::cout << "\n=== Training completed ===" << std::endl;
    return 0;
}
EOF
}

build() {
  # Use GCC for stable PGO with shared libraries
  export CC=gcc
  export CXX=g++
  export AR=gcc-ar
  export NM=gcc-nm
  export RANLIB=gcc-ranlib

  # Base optimization flags (keep your aggressive flags but remove Clang-specific ones)
  local -a BASE_CFLAGS=(
    -O3
    -march=native
    -mtune=native
    -fno-math-errno
    -fno-trapping-math
    -falign-functions=32
    -funroll-loops
    -fno-semantic-interposition
    -fomit-frame-pointer
    -fdata-sections
    -ffunction-sections
    -fno-plt
    -w
  )

  local -a BASE_CXXFLAGS=("${BASE_CFLAGS[@]}" -std=c++17)

  local -a BASE_LDFLAGS=(
    -Wl,-O3
    -Wl,--gc-sections
    -Wl,--as-needed
    -Wl,-Bsymbolic-functions
    -Wl,-z,now
    -Wl,-z,relro
    -Wl,--hash-style=gnu
  )

  ###########################################################################
  # Stage 1: PGO Instrumentation (GCC style)
  ###########################################################################
  echo "=== Stage 1: PGO Instrumentation (GCC) ==="

  mkdir -p "$srcdir/pgo-data"

  # GCC PGO flags - much simpler and more reliable for shared libs
  local -a PGO_GEN_FLAGS=(
    -fprofile-generate="$srcdir/pgo-data"
    -fprofile-dir="$srcdir/pgo-data"
  )

  local -a stage1_cflags=("${BASE_CFLAGS[@]}" "${PGO_GEN_FLAGS[@]}")
  local -a stage1_cxxflags=("${BASE_CXXFLAGS[@]}" "${PGO_GEN_FLAGS[@]}")
  local -a stage1_ldflags=("${BASE_LDFLAGS[@]}" "${PGO_GEN_FLAGS[@]}")

  export CFLAGS="${stage1_cflags[*]}"
  export CXXFLAGS="${stage1_cxxflags[*]}"
  export LDFLAGS="${stage1_ldflags[*]}"

  cd "$srcdir/icu/source"

  ./configure --prefix=/usr \
    --sysconfdir=/etc \
    --mandir=/usr/share/man \
    --sbindir=/usr/bin

  make -j$(nproc)

  # Build training program
  echo "=== Building training program (PGO) ==="
  $CXX $CXXFLAGS \
    -I"$srcdir/icu/source/common" \
    -I"$srcdir/icu/source/i18n" \
    "$srcdir/icu-training.cpp" \
    -o "$srcdir/icu-training-pgo" \
    -L"$srcdir/icu/source/lib" \
    -licui18n -licuuc -licudata \
    $LDFLAGS \
    -Wl,-rpath,"$srcdir/icu/source/lib"

  # PGO Training
  echo "=== Running PGO training (5 iterations for better coverage) ==="
  export LD_LIBRARY_PATH="$srcdir/icu/source/lib:${LD_LIBRARY_PATH:-}"

  "$srcdir/icu-training-pgo" 5 || {
    echo "WARNING: Training had issues, continuing anyway"
  }

  # GCC automatically writes .gcda files, verify they exist
  local GCDA_COUNT=$(find "$srcdir/pgo-data" -name "*.gcda" 2>/dev/null | wc -l)
  echo "Generated $GCDA_COUNT profile data files"

  if [ $GCDA_COUNT -eq 0 ]; then
    echo "ERROR: No PGO profile data generated!"
    exit 1
  fi

  ###########################################################################
  # Stage 2: Final optimized build with PGO + LTO
  ###########################################################################
  echo "=== Stage 2: Final PGO+LTO build ==="

  # Clean previous build
  cd "$srcdir/icu/source"
  make distclean || true

  # GCC PGO use + LTO flags
  local -a FINAL_FLAGS=(
    -fprofile-use="$srcdir/pgo-data"
    -fprofile-dir="$srcdir/pgo-data"
    -fprofile-correction        # Handle minor profile inconsistencies
    -flto=auto                  # GCC LTO with automatic job count
    -fuse-linker-plugin         # Essential for GCC LTO
    -ffat-lto-objects          # Allows fallback if LTO fails
  )

  local -a stage2_cflags=("${BASE_CFLAGS[@]}" "${FINAL_FLAGS[@]}")
  local -a stage2_cxxflags=("${BASE_CXXFLAGS[@]}" "${FINAL_FLAGS[@]}")
  local -a stage2_ldflags=("${BASE_LDFLAGS[@]}" "${FINAL_FLAGS[@]}")

  export CFLAGS="${stage2_cflags[*]}"
  export CXXFLAGS="${stage2_cxxflags[*]}"
  export LDFLAGS="${stage2_ldflags[*]}"

  ./configure --prefix=/usr \
    --sysconfdir=/etc \
    --mandir=/usr/share/man \
    --sbindir=/usr/bin

  make -j$(nproc)

  echo "=== Build completed successfully ==="
}

check() {
  cd "$srcdir/icu/source"
  make check || echo "Some tests may have failed"
}

package() {
  cd "$srcdir/icu/source"
  make DESTDIR="$pkgdir" install

  # Install license
  install -Dm644 "$srcdir/icu/LICENSE" "$pkgdir/usr/share/licenses/$pkgname/LICENSE"

  # Optimization stats
  mkdir -p "$pkgdir/usr/share/doc/icu"
  {
    echo "Build: GCC PGO + LTO (English/German optimized)"
    echo "Compiler: GCC $(gcc -dumpversion)"
    local GCDA_COUNT=$(find "$srcdir/pgo-data" -name "*.gcda" 2>/dev/null | wc -l)
    echo "PGO profiles: $GCDA_COUNT data files"
    echo "Optimizations: -O3 -march=native -flto -fprofile-use"
  } > "$pkgdir/usr/share/doc/icu/OPTIMIZATIONS.txt"
}
