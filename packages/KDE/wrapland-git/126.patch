From de66e65a8c16e4c596ca48a6d608fcce06dd7e4a Mon Sep 17 00:00:00 2001
From: Francesco Sorrentino <francesco.sorr@gmail.com>
Date: Thu, 10 Feb 2022 17:54:46 +0100
Subject: [PATCH 1/5] fix(server): correct typo in Wayland::Global

Fix typo in template.
---
 server/wayland/global.h | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/server/wayland/global.h b/server/wayland/global.h
index 7eb9f0cc..84e83f31 100644
--- a/server/wayland/global.h
+++ b/server/wayland/global.h
@@ -120,7 +120,7 @@ public:

     std::vector<Bind<type>*> getBinds()
     {
-        return nucleus->binds();
+        return nucleus->binds;
     }

     std::vector<Bind<type>*> getBinds(Server::Client* client)
--
GitLab


From fe6848840bb2cb7c145c8154ec8bb6080d37044c Mon Sep 17 00:00:00 2001
From: Francesco Sorrentino <francesco.sorr@gmail.com>
Date: Thu, 10 Feb 2022 12:42:07 +0100
Subject: [PATCH 2/5] style(client): review PlasmaWindowManagement

Silence some clang warnings in PlasmaWindowManagement:
- use same param names in declaration and definition,
- use `auto` when possible,
- prefer empty initializer,
- declare static members as const,
- don't access static members through an instance,
- concatenate nested namespace.
Plus:
- replace `emit` with `Q_EMIT`.
---
 autotests/client/plasma_window_management.cpp |  24 ++-
 src/client/plasmawindowmanagement.cpp         | 144 +++++++++---------
 src/client/plasmawindowmanagement.h           |   7 +-
 3 files changed, 80 insertions(+), 95 deletions(-)

diff --git a/autotests/client/plasma_window_management.cpp b/autotests/client/plasma_window_management.cpp
index 3303f2b7..756c84d8 100644
--- a/autotests/client/plasma_window_management.cpp
+++ b/autotests/client/plasma_window_management.cpp
@@ -94,24 +94,20 @@ private:
         Srv::Surface* surface{nullptr};
     } server;
 
-    Clt::Surface* m_surface = nullptr;
-    Clt::ConnectionThread* m_connection;
-    Clt::Compositor* m_compositor;
-    Clt::EventQueue* m_queue;
-    Clt::PlasmaWindowManagement* m_windowManagement;
-    Clt::PlasmaWindow* m_window;
-    QThread* m_thread;
-    Clt::Registry* m_registry;
+    Clt::Surface* m_surface{};
+    Clt::ConnectionThread* m_connection{};
+    Clt::Compositor* m_compositor{};
+    Clt::EventQueue* m_queue{};
+    Clt::PlasmaWindowManagement* m_windowManagement{};
+    Clt::PlasmaWindow* m_window{};
+    QThread* m_thread{};
+    Clt::Registry* m_registry{};
 };
 
 constexpr auto socket_name{"wrapland-test-wayland-windowmanagement-0"};
 
 TestWindowManagement::TestWindowManagement(QObject* parent)
     : QObject(parent)
-    , m_connection(nullptr)
-    , m_compositor(nullptr)
-    , m_queue(nullptr)
-    , m_thread(nullptr)
 {
 }
 
@@ -288,8 +284,8 @@ void TestWindowManagement::testCreateAfterUnmap()
     serverWindow->unmap();
 
     QCOMPARE(server.globals.plasma_window_manager->children().count(), 0);
-    QCoreApplication::instance()->processEvents();
-    QCoreApplication::instance()->processEvents(QEventLoop::WaitForMoreEvents);
+    QCoreApplication::processEvents();
+    QCoreApplication::processEvents(QEventLoop::WaitForMoreEvents);
     QTRY_COMPARE(m_windowManagement->children().count(), 2);
 
     auto window = dynamic_cast<Clt::PlasmaWindow*>(m_windowManagement->children().last());
diff --git a/src/client/plasmawindowmanagement.cpp b/src/client/plasmawindowmanagement.cpp
index d0d1d6f8..6e7b2972 100644
--- a/src/client/plasmawindowmanagement.cpp
+++ b/src/client/plasmawindowmanagement.cpp
@@ -32,37 +32,31 @@ License along with this library.  If not, see <http://www.gnu.org/licenses/>.
 #include <QtConcurrentRun>
 #include <qplatformdefs.h>
 
-#include <errno.h>
+#include <cerrno>
 
-namespace Wrapland
-{
-namespace Client
+namespace Wrapland::Client
 {
 
 class Q_DECL_HIDDEN PlasmaWindowManagement::Private
 {
 public:
-    Private(PlasmaWindowManagement* q);
+    explicit Private(PlasmaWindowManagement* q);
     WaylandPointer<org_kde_plasma_window_management, org_kde_plasma_window_management_destroy> wm;
     EventQueue* queue = nullptr;
     bool showingDesktop = false;
     QList<PlasmaWindow*> windows;
     PlasmaWindow* activeWindow = nullptr;
 
-    void setup(org_kde_plasma_window_management* wm);
+    void setup(org_kde_plasma_window_management* proxy);
 
 private:
     static void
-    showDesktopCallback(void* data,
-                        org_kde_plasma_window_management* org_kde_plasma_window_management,
-                        uint32_t state);
-    static void windowCallback(void* data,
-                               org_kde_plasma_window_management* org_kde_plasma_window_management,
-                               uint32_t id);
+    showDesktopCallback(void* data, org_kde_plasma_window_management* proxy, uint32_t state);
+    static void windowCallback(void* data, org_kde_plasma_window_management* proxy, uint32_t id);
     void setShowDesktop(bool set);
     void windowCreated(org_kde_plasma_window* id, quint32 internalId);
 
-    static struct org_kde_plasma_window_management_listener s_listener;
+    org_kde_plasma_window_management_listener static const s_listener;
     PlasmaWindowManagement* q;
 };
 
@@ -158,7 +152,7 @@ private:
     void setResizable(bool set);
     void setVirtualDesktopChangeable(bool set);
     void setParentWindow(PlasmaWindow* parentWindow);
-    void setPid(const quint32 pid);
+    void setPid(quint32 pid);
 
     static Private* cast(void* data)
     {
@@ -167,7 +161,7 @@ private:
 
     PlasmaWindow* q;
 
-    static struct org_kde_plasma_window_listener s_listener;
+    org_kde_plasma_window_listener static const s_listener;
 };
 
 PlasmaWindowManagement::Private::Private(PlasmaWindowManagement* q)
@@ -175,26 +169,25 @@ PlasmaWindowManagement::Private::Private(PlasmaWindowManagement* q)
 {
 }
 
-org_kde_plasma_window_management_listener PlasmaWindowManagement::Private::s_listener = {
+org_kde_plasma_window_management_listener const PlasmaWindowManagement::Private::s_listener = {
     showDesktopCallback,
     windowCallback,
 };
 
-void PlasmaWindowManagement::Private::setup(org_kde_plasma_window_management* windowManagement)
+void PlasmaWindowManagement::Private::setup(org_kde_plasma_window_management* proxy)
 {
     Q_ASSERT(!wm);
-    Q_ASSERT(windowManagement);
-    wm.setup(windowManagement);
-    org_kde_plasma_window_management_add_listener(windowManagement, &s_listener, this);
+    Q_ASSERT(proxy);
+    wm.setup(proxy);
+    org_kde_plasma_window_management_add_listener(proxy, &s_listener, this);
 }
 
-void PlasmaWindowManagement::Private::showDesktopCallback(
-    void* data,
-    org_kde_plasma_window_management* org_kde_plasma_window_management,
-    uint32_t state)
+void PlasmaWindowManagement::Private::showDesktopCallback(void* data,
+                                                          org_kde_plasma_window_management* proxy,
+                                                          uint32_t state)
 {
     auto wm = reinterpret_cast<PlasmaWindowManagement::Private*>(data);
-    Q_ASSERT(wm->wm == org_kde_plasma_window_management);
+    Q_ASSERT(wm->wm == proxy);
     switch (state) {
     case ORG_KDE_PLASMA_WINDOW_MANAGEMENT_SHOW_DESKTOP_ENABLED:
         wm->setShowDesktop(true);
@@ -214,16 +207,16 @@ void PlasmaWindowManagement::Private::setShowDesktop(bool set)
         return;
     }
     showingDesktop = set;
-    emit q->showingDesktopChanged(showingDesktop);
+    Q_EMIT q->showingDesktopChanged(showingDesktop);
 }
 
 void PlasmaWindowManagement::Private::windowCallback(void* data,
-                                                     org_kde_plasma_window_management* interface,
+                                                     org_kde_plasma_window_management* proxy,
                                                      uint32_t id)
 {
     auto wm = reinterpret_cast<PlasmaWindowManagement::Private*>(data);
-    Q_ASSERT(wm->wm == interface);
-    QTimer* timer = new QTimer();
+    Q_ASSERT(wm->wm == proxy);
+    auto timer = new QTimer();
     timer->setSingleShot(true);
     timer->setInterval(0);
     QObject::connect(
@@ -243,20 +236,20 @@ void PlasmaWindowManagement::Private::windowCreated(org_kde_plasma_window* id, q
     if (queue) {
         queue->addProxy(id);
     }
-    PlasmaWindow* window = new PlasmaWindow(q, id, internalId);
+    auto window = new PlasmaWindow(q, id, internalId);
     window->d->wm = q;
     windows << window;
     QObject::connect(window, &QObject::destroyed, q, [this, window] {
         windows.removeAll(window);
         if (activeWindow == window) {
             activeWindow = nullptr;
-            emit q->activeWindowChanged();
+            Q_EMIT q->activeWindowChanged();
         }
     });
     QObject::connect(window, &PlasmaWindow::unmapped, q, [this, window] {
         if (activeWindow == window) {
             activeWindow = nullptr;
-            emit q->activeWindowChanged();
+            Q_EMIT q->activeWindowChanged();
         }
     });
     QObject::connect(window, &PlasmaWindow::activeChanged, q, [this, window] {
@@ -265,11 +258,11 @@ void PlasmaWindowManagement::Private::windowCreated(org_kde_plasma_window* id, q
                 return;
             }
             activeWindow = window;
-            emit q->activeWindowChanged();
+            Q_EMIT q->activeWindowChanged();
         } else {
             if (activeWindow == window) {
                 activeWindow = nullptr;
-                emit q->activeWindowChanged();
+                Q_EMIT q->activeWindowChanged();
             }
         }
     });
@@ -291,13 +284,13 @@ void PlasmaWindowManagement::release()
     if (!d->wm) {
         return;
     }
-    emit interfaceAboutToBeReleased();
+    Q_EMIT interfaceAboutToBeReleased();
     d->wm.release();
 }
 
-void PlasmaWindowManagement::setup(org_kde_plasma_window_management* wm)
+void PlasmaWindowManagement::setup(org_kde_plasma_window_management* shell)
 {
-    d->setup(wm);
+    d->setup(shell);
 }
 
 void PlasmaWindowManagement::setEventQueue(EventQueue* queue)
@@ -363,7 +356,7 @@ PlasmaWindowModel* PlasmaWindowManagement::createWindowModel()
     return new PlasmaWindowModel(this);
 }
 
-org_kde_plasma_window_listener PlasmaWindow::Private::s_listener = {
+org_kde_plasma_window_listener const PlasmaWindow::Private::s_listener = {
     titleChangedCallback,
     appIdChangedCallback,
     stateChangedCallback,
@@ -407,7 +400,7 @@ void PlasmaWindow::Private::windowGeometryCallback(void* data,
         return;
     }
     p->geometry = geo;
-    emit p->q->geometryChanged();
+    Q_EMIT p->q->geometryChanged();
 }
 
 void PlasmaWindow::Private::setParentWindow(PlasmaWindow* parent)
@@ -423,7 +416,7 @@ void PlasmaWindow::Private::setParentWindow(PlasmaWindow* parent)
         parentWindowUnmappedConnection = QMetaObject::Connection();
     }
     if (parentWindow.data() != old.data()) {
-        emit q->parentWindowChanged();
+        Q_EMIT q->parentWindowChanged();
     }
 }
 
@@ -432,7 +425,7 @@ void PlasmaWindow::Private::initialStateCallback(void* data, org_kde_plasma_wind
     Q_UNUSED(window)
     Private* p = cast(data);
     if (!p->unmapped) {
-        emit p->wm->windowCreated(p->q);
+        Q_EMIT p->wm->windowCreated(p->q);
     }
 }
 
@@ -447,21 +440,21 @@ void PlasmaWindow::Private::titleChangedCallback(void* data,
         return;
     }
     p->title = t;
-    emit p->q->titleChanged();
+    Q_EMIT p->q->titleChanged();
 }
 
 void PlasmaWindow::Private::appIdChangedCallback(void* data,
                                                  org_kde_plasma_window* window,
-                                                 const char* appId)
+                                                 const char* app_id)
 {
     Q_UNUSED(window)
     Private* p = cast(data);
-    const QString s = QString::fromUtf8(appId);
+    const QString s = QString::fromUtf8(app_id);
     if (s == p->appId) {
         return;
     }
     p->appId = s;
-    emit p->q->appIdChanged();
+    Q_EMIT p->q->appIdChanged();
 }
 
 void PlasmaWindow::Private::pidChangedCallback(void* data,
@@ -505,7 +498,7 @@ void PlasmaWindow::Private::unmappedCallback(void* data, org_kde_plasma_window*
     auto p = cast(data);
     Q_UNUSED(window);
     p->unmapped = true;
-    emit p->q->unmapped();
+    Q_EMIT p->q->unmapped();
     p->q->deleteLater();
 }
 
@@ -517,9 +510,9 @@ void PlasmaWindow::Private::virtualDesktopEnteredCallback(void* data,
     Q_UNUSED(window);
     const QString stringId(QString::fromUtf8(id));
     p->plasmaVirtualDesktops << stringId;
-    emit p->q->plasmaVirtualDesktopEntered(stringId);
+    Q_EMIT p->q->plasmaVirtualDesktopEntered(stringId);
     if (p->plasmaVirtualDesktops.count() == 1) {
-        emit p->q->onAllDesktopsChanged();
+        Q_EMIT p->q->onAllDesktopsChanged();
     }
 }
 
@@ -531,9 +524,9 @@ void PlasmaWindow::Private::virtualDesktopLeftCallback(void* data,
     Q_UNUSED(window);
     const QString stringId(QString::fromUtf8(id));
     p->plasmaVirtualDesktops.removeAll(stringId);
-    emit p->q->plasmaVirtualDesktopLeft(stringId);
+    Q_EMIT p->q->plasmaVirtualDesktopLeft(stringId);
     if (p->plasmaVirtualDesktops.isEmpty()) {
-        emit p->q->onAllDesktopsChanged();
+        Q_EMIT p->q->onAllDesktopsChanged();
     }
 }
 
@@ -578,7 +571,7 @@ void PlasmaWindow::Private::themedIconNameChangedCallback(void* data,
     } else {
         p->icon = QIcon();
     }
-    emit p->q->iconChanged();
+    Q_EMIT p->q->iconChanged();
 }
 
 static int readData(int fd, QByteArray& data)
@@ -617,7 +610,7 @@ void PlasmaWindow::Private::iconChangedCallback(void* data, org_kde_plasma_windo
         QByteArray content;
         if (readData(pipeFd, content) != 0) {
             close(pipeFd);
-            return QIcon();
+            return {};
         }
         close(pipeFd);
         QDataStream ds(content);
@@ -625,7 +618,7 @@ void PlasmaWindow::Private::iconChangedCallback(void* data, org_kde_plasma_windo
         ds >> icon;
         return icon;
     };
-    QFutureWatcher<QIcon>* watcher = new QFutureWatcher<QIcon>(p->q);
+    auto watcher = new QFutureWatcher<QIcon>(p->q);
     QObject::connect(watcher, &QFutureWatcher<QIcon>::finished, p->q, [p, watcher] {
         watcher->deleteLater();
         QIcon icon = watcher->result();
@@ -634,7 +627,7 @@ void PlasmaWindow::Private::iconChangedCallback(void* data, org_kde_plasma_windo
         } else {
             p->icon = QIcon::fromTheme(QStringLiteral("wayland"));
         }
-        emit p->q->iconChanged();
+        Q_EMIT p->q->iconChanged();
     });
     watcher->setFuture(QtConcurrent::run(readIcon));
 }
@@ -645,7 +638,7 @@ void PlasmaWindow::Private::setActive(bool set)
         return;
     }
     active = set;
-    emit q->activeChanged();
+    Q_EMIT q->activeChanged();
 }
 
 void PlasmaWindow::Private::setFullscreen(bool set)
@@ -654,7 +647,7 @@ void PlasmaWindow::Private::setFullscreen(bool set)
         return;
     }
     fullscreen = set;
-    emit q->fullscreenChanged();
+    Q_EMIT q->fullscreenChanged();
 }
 
 void PlasmaWindow::Private::setKeepAbove(bool set)
@@ -663,7 +656,7 @@ void PlasmaWindow::Private::setKeepAbove(bool set)
         return;
     }
     keepAbove = set;
-    emit q->keepAboveChanged();
+    Q_EMIT q->keepAboveChanged();
 }
 
 void PlasmaWindow::Private::setKeepBelow(bool set)
@@ -672,7 +665,7 @@ void PlasmaWindow::Private::setKeepBelow(bool set)
         return;
     }
     keepBelow = set;
-    emit q->keepBelowChanged();
+    Q_EMIT q->keepBelowChanged();
 }
 
 void PlasmaWindow::Private::setMaximized(bool set)
@@ -681,7 +674,7 @@ void PlasmaWindow::Private::setMaximized(bool set)
         return;
     }
     maximized = set;
-    emit q->maximizedChanged();
+    Q_EMIT q->maximizedChanged();
 }
 
 void PlasmaWindow::Private::setMinimized(bool set)
@@ -690,7 +683,7 @@ void PlasmaWindow::Private::setMinimized(bool set)
         return;
     }
     minimized = set;
-    emit q->minimizedChanged();
+    Q_EMIT q->minimizedChanged();
 }
 
 void PlasmaWindow::Private::setOnAllDesktops(bool set)
@@ -699,7 +692,7 @@ void PlasmaWindow::Private::setOnAllDesktops(bool set)
         return;
     }
     onAllDesktops = set;
-    emit q->onAllDesktopsChanged();
+    Q_EMIT q->onAllDesktopsChanged();
 }
 
 void PlasmaWindow::Private::setDemandsAttention(bool set)
@@ -708,7 +701,7 @@ void PlasmaWindow::Private::setDemandsAttention(bool set)
         return;
     }
     demandsAttention = set;
-    emit q->demandsAttentionChanged();
+    Q_EMIT q->demandsAttentionChanged();
 }
 
 void PlasmaWindow::Private::setCloseable(bool set)
@@ -717,7 +710,7 @@ void PlasmaWindow::Private::setCloseable(bool set)
         return;
     }
     closeable = set;
-    emit q->closeableChanged();
+    Q_EMIT q->closeableChanged();
 }
 
 void PlasmaWindow::Private::setFullscreenable(bool set)
@@ -726,7 +719,7 @@ void PlasmaWindow::Private::setFullscreenable(bool set)
         return;
     }
     fullscreenable = set;
-    emit q->fullscreenableChanged();
+    Q_EMIT q->fullscreenableChanged();
 }
 
 void PlasmaWindow::Private::setMaximizeable(bool set)
@@ -735,7 +728,7 @@ void PlasmaWindow::Private::setMaximizeable(bool set)
         return;
     }
     maximizeable = set;
-    emit q->maximizeableChanged();
+    Q_EMIT q->maximizeableChanged();
 }
 
 void PlasmaWindow::Private::setMinimizeable(bool set)
@@ -744,7 +737,7 @@ void PlasmaWindow::Private::setMinimizeable(bool set)
         return;
     }
     minimizeable = set;
-    emit q->minimizeableChanged();
+    Q_EMIT q->minimizeableChanged();
 }
 
 void PlasmaWindow::Private::setSkipTaskbar(bool skip)
@@ -753,7 +746,7 @@ void PlasmaWindow::Private::setSkipTaskbar(bool skip)
         return;
     }
     skipTaskbar = skip;
-    emit q->skipTaskbarChanged();
+    Q_EMIT q->skipTaskbarChanged();
 }
 
 void PlasmaWindow::Private::setSkipSwitcher(bool skip)
@@ -762,7 +755,7 @@ void PlasmaWindow::Private::setSkipSwitcher(bool skip)
         return;
     }
     skipSwitcher = skip;
-    emit q->skipSwitcherChanged();
+    Q_EMIT q->skipSwitcherChanged();
 }
 
 void PlasmaWindow::Private::setShadeable(bool set)
@@ -771,7 +764,7 @@ void PlasmaWindow::Private::setShadeable(bool set)
         return;
     }
     shadeable = set;
-    emit q->shadeableChanged();
+    Q_EMIT q->shadeableChanged();
 }
 
 void PlasmaWindow::Private::setShaded(bool set)
@@ -780,7 +773,7 @@ void PlasmaWindow::Private::setShaded(bool set)
         return;
     }
     shaded = set;
-    emit q->shadedChanged();
+    Q_EMIT q->shadedChanged();
 }
 
 void PlasmaWindow::Private::setMovable(bool set)
@@ -789,7 +782,7 @@ void PlasmaWindow::Private::setMovable(bool set)
         return;
     }
     movable = set;
-    emit q->movableChanged();
+    Q_EMIT q->movableChanged();
 }
 
 void PlasmaWindow::Private::setResizable(bool set)
@@ -798,7 +791,7 @@ void PlasmaWindow::Private::setResizable(bool set)
         return;
     }
     resizable = set;
-    emit q->resizableChanged();
+    Q_EMIT q->resizableChanged();
 }
 
 void PlasmaWindow::Private::setVirtualDesktopChangeable(bool set)
@@ -807,7 +800,7 @@ void PlasmaWindow::Private::setVirtualDesktopChangeable(bool set)
         return;
     }
     virtualDesktopChangeable = set;
-    emit q->virtualDesktopChangeableChanged();
+    Q_EMIT q->virtualDesktopChangeableChanged();
 }
 
 PlasmaWindow::Private::Private(org_kde_plasma_window* w, quint32 internalId, PlasmaWindow* q)
@@ -901,9 +894,9 @@ bool PlasmaWindow::isOnAllDesktops() const
     // from protocol version 8 virtual desktops are managed by plasmaVirtualDesktops
     if (org_kde_plasma_window_get_version(d->window) < 8) {
         return d->onAllDesktops;
-    } else {
-        return d->plasmaVirtualDesktops.isEmpty();
     }
+
+    return d->plasmaVirtualDesktops.isEmpty();
 }
 
 bool PlasmaWindow::isDemandingAttention() const
@@ -1110,4 +1103,3 @@ QStringList PlasmaWindow::plasmaVirtualDesktops() const
 }
 
 }
-}
diff --git a/src/client/plasmawindowmanagement.h b/src/client/plasmawindowmanagement.h
index 2e6e346e..7483d7a3 100644
--- a/src/client/plasmawindowmanagement.h
+++ b/src/client/plasmawindowmanagement.h
@@ -31,9 +31,7 @@ License along with this library.  If not, see <http://www.gnu.org/licenses/>.
 struct org_kde_plasma_window_management;
 struct org_kde_plasma_window;
 
-namespace Wrapland
-{
-namespace Client
+namespace Wrapland::Client
 {
 class EventQueue;
 class PlasmaWindow;
@@ -645,13 +643,12 @@ Q_SIGNALS:
 private:
     friend class PlasmaWindowManagement;
     explicit PlasmaWindow(PlasmaWindowManagement* parent,
-                          org_kde_plasma_window* dataOffer,
+                          org_kde_plasma_window* window,
                           quint32 internalId);
     class Private;
     std::unique_ptr<Private> d;
 };
 
-}
 }
 
 Q_DECLARE_METATYPE(Wrapland::Client::PlasmaWindow*)
-- 
GitLab


From e3e7d49f37aed1d4b79ab299dcbe3c70cb9c1e1d Mon Sep 17 00:00:00 2001
From: Tom Englund <tomenglund26@gmail.com>
Date: Sun, 1 May 2022 15:30:14 +0200
Subject: [PATCH 3/5] refactor(client): remove timer from windowCreated

the timer was added in commit 460c18bc without an explanation why its
needed.
however with the timer we can enter a state where the captured objects
are destroyed before the timer finishes.
---
 src/client/plasmawindowmanagement.cpp | 15 ++-------------
 1 file changed, 2 insertions(+), 13 deletions(-)

diff --git a/src/client/plasmawindowmanagement.cpp b/src/client/plasmawindowmanagement.cpp
index 6e7b2972..e2f83795 100644
--- a/src/client/plasmawindowmanagement.cpp
+++ b/src/client/plasmawindowmanagement.cpp
@@ -216,19 +216,8 @@ void PlasmaWindowManagement::Private::windowCallback(void* data,
 {
     auto wm = reinterpret_cast<PlasmaWindowManagement::Private*>(data);
     Q_ASSERT(wm->wm == proxy);
-    auto timer = new QTimer();
-    timer->setSingleShot(true);
-    timer->setInterval(0);
-    QObject::connect(
-        timer,
-        &QTimer::timeout,
-        wm->q,
-        [timer, wm, id] {
-            wm->windowCreated(org_kde_plasma_window_management_get_window(wm->wm, id), id);
-            timer->deleteLater();
-        },
-        Qt::QueuedConnection);
-    timer->start();
+
+    wm->windowCreated(org_kde_plasma_window_management_get_window(wm->wm, id), id);
 }
 
 void PlasmaWindowManagement::Private::windowCreated(org_kde_plasma_window* id, quint32 internalId)
-- 
GitLab


From 3e98a4c29c47983ae8276157968a90a995918f03 Mon Sep 17 00:00:00 2001
From: Francesco Sorrentino <francesco.sorr@gmail.com>
Date: Thu, 10 Feb 2022 17:52:18 +0100
Subject: [PATCH 4/5] feat: bump PlasmaWindowManagement to version 15

Jump from version 10 to version 15.
Internal ids are now deprecated, in favour of uuids.
Introduce `stacking_order` and `send_to_output`.
Ignore functions related to activities.
---
 autotests/client/plasma_window_management.cpp | 137 ++++++++++++++
 server/plasma_window.cpp                      | 165 ++++++++++++++++-
 server/plasma_window.h                        |  17 ++
 server/plasma_window_p.h                      |  19 +-
 src/client/plasmawindowmanagement.cpp         | 170 +++++++++++++++++-
 src/client/plasmawindowmanagement.h           |  49 ++++-
 .../protocols/plasma-window-management.xml    | 127 +++++++++++--
 src/client/registry.cpp                       |   2 +-
 8 files changed, 655 insertions(+), 31 deletions(-)

diff --git a/autotests/client/plasma_window_management.cpp b/autotests/client/plasma_window_management.cpp
index 756c84d8..d37d6e68 100644
--- a/autotests/client/plasma_window_management.cpp
+++ b/autotests/client/plasma_window_management.cpp
@@ -1,5 +1,6 @@
 /********************************************************************
 Copyright 2015 Marco Martin <mart@kde.org>
+Copyright 2022 Francesco Sorrentino <francesco.sorr@gmail.com>
 
 This library is free software; you can redistribute it and/or
 modify it under the terms of the GNU Lesser General Public
@@ -22,6 +23,7 @@ License along with this library.  If not, see <http://www.gnu.org/licenses/>.
 #include "../../src/client/compositor.h"
 #include "../../src/client/connection_thread.h"
 #include "../../src/client/event_queue.h"
+#include "../../src/client/output.h"
 #include "../../src/client/plasmawindowmanagement.h"
 #include "../../src/client/region.h"
 #include "../../src/client/registry.h"
@@ -35,6 +37,10 @@ License along with this library.  If not, see <http://www.gnu.org/licenses/>.
 
 #include <wayland-plasma-window-management-client-protocol.h>
 
+#include <memory>
+#include <string>
+#include <vector>
+
 namespace Clt = Wrapland::Client;
 namespace Srv = Wrapland::Server;
 
@@ -85,6 +91,16 @@ private Q_SLOTS:
     void testPid();
     void testApplicationMenu();
 
+    void testStackingOrder_data();
+    void testStackingOrder();
+    void testStackingOrder_empty();
+
+    void testStackingOrderUuid_data();
+    void testStackingOrderUuid();
+    void testStackingOrderUuid_empty();
+
+    void testSendToOutput();
+
 private:
     struct {
         std::unique_ptr<Wrapland::Server::Display> display;
@@ -113,6 +129,8 @@ TestWindowManagement::TestWindowManagement(QObject* parent)
 
 void TestWindowManagement::init()
 {
+    qRegisterMetaType<std::string const&>();
+    qRegisterMetaType<Wrapland::Server::Output*>();
     qRegisterMetaType<Wrapland::Server::Surface*>();
     qRegisterMetaType<Srv::PlasmaWindowManager::ShowingDesktopState>("ShowingDesktopState");
 
@@ -738,5 +756,124 @@ void TestWindowManagement::testApplicationMenu()
     QCOMPARE(m_window->applicationMenuObjectPath(), objectPath);
 }
 
+void TestWindowManagement::testStackingOrder_data()
+{
+    QTest::addColumn<std::vector<uint32_t>>("stack");
+
+    QTest::newRow("0") << std::vector<uint32_t>{};
+    QTest::newRow("1") << std::vector<uint32_t>{42};
+    QTest::newRow("4") << std::vector<uint32_t>{74, 75, 76, 77};
+    QTest::newRow("7") << std::vector<uint32_t>{1121, 1119, 1117, 1115, 1113, 1111, 1109};
+}
+
+void TestWindowManagement::testStackingOrder()
+{
+    QSignalSpy stacking_order_spy(m_windowManagement,
+                                  &Clt::PlasmaWindowManagement::stacking_order_changed);
+    QVERIFY(stacking_order_spy.isValid());
+
+    QFETCH(std::vector<uint32_t>, stack);
+    server.globals.plasma_window_manager->set_stacking_order(stack);
+
+    QVERIFY(stacking_order_spy.wait() || stack.empty());
+    QCOMPARE(m_windowManagement->stacking_order().size(), stack.size());
+    QCOMPARE(m_windowManagement->stacking_order(), stack);
+}
+
+/// First populate the stack, then clear it.
+void TestWindowManagement::testStackingOrder_empty()
+{
+    QSignalSpy stacking_order_spy(m_windowManagement,
+                                  &Clt::PlasmaWindowManagement::stacking_order_changed);
+    QVERIFY(stacking_order_spy.isValid());
+
+    std::vector<uint32_t> stack{1};
+    server.globals.plasma_window_manager->set_stacking_order(stack);
+
+    QVERIFY(stacking_order_spy.wait());
+    QCOMPARE(m_windowManagement->stacking_order().size(), stack.size());
+    QCOMPARE(m_windowManagement->stacking_order(), stack);
+
+    stack.clear();
+    server.globals.plasma_window_manager->set_stacking_order(stack);
+
+    QVERIFY(stacking_order_spy.wait());
+    QCOMPARE(m_windowManagement->stacking_order_uuid().size(), 0);
+}
+
+void TestWindowManagement::testStackingOrderUuid_data()
+{
+    QTest::addColumn<std::vector<std::string>>("stack");
+
+    QTest::newRow("0") << std::vector<std::string>{};
+    QTest::newRow("1") << std::vector<std::string>{"forty-two"};
+    QTest::newRow("4") << std::vector<std::string>{"74", "seventy five", "76___", "77?"};
+    QTest::newRow("7") << std::vector<std::string>{
+        "1'121", "1119.", "hi", "11-15", "1113$", "++1111", "end"};
+}
+
+void TestWindowManagement::testStackingOrderUuid()
+{
+    QSignalSpy stacking_order_spy(m_windowManagement,
+                                  &Clt::PlasmaWindowManagement::stacking_order_uuid_changed);
+    QVERIFY(stacking_order_spy.isValid());
+
+    QFETCH(std::vector<std::string>, stack);
+    server.globals.plasma_window_manager->set_stacking_order_uuids(stack);
+
+    QVERIFY(stacking_order_spy.wait() || stack.empty());
+    QCOMPARE(m_windowManagement->stacking_order_uuid().size(), stack.size());
+    QCOMPARE(m_windowManagement->stacking_order_uuid(), stack);
+}
+
+/// First populate the stack, then clear it.
+void TestWindowManagement::testStackingOrderUuid_empty()
+{
+    QSignalSpy stacking_order_spy(m_windowManagement,
+                                  &Clt::PlasmaWindowManagement::stacking_order_uuid_changed);
+    QVERIFY(stacking_order_spy.isValid());
+
+    std::vector<std::string> stack{"HeLLo", "world!"};
+    server.globals.plasma_window_manager->set_stacking_order_uuids(stack);
+
+    QVERIFY(stacking_order_spy.wait());
+    QCOMPARE(m_windowManagement->stacking_order_uuid().size(), stack.size());
+    QCOMPARE(m_windowManagement->stacking_order_uuid(), stack);
+
+    stack.clear();
+    server.globals.plasma_window_manager->set_stacking_order_uuids(stack);
+
+    QVERIFY(stacking_order_spy.wait());
+    QCOMPARE(m_windowManagement->stacking_order_uuid().size(), 0);
+}
+
+void TestWindowManagement::testSendToOutput()
+{
+    QSignalSpy sendToOutputSpy(server.plasma_window, &Srv::PlasmaWindow::sendToOutputRequested);
+    QVERIFY(sendToOutputSpy.isValid());
+
+    // Create output
+    QSignalSpy outputAnnouncedSpy(m_registry, &Wrapland::Client::Registry::outputAnnounced);
+    QVERIFY(outputAnnouncedSpy.isValid());
+
+    auto srv_output = std::make_unique<Srv::Output>(server.display.get());
+    srv_output->set_enabled(true);
+    srv_output->done();
+
+    QVERIFY(outputAnnouncedSpy.wait());
+    std::unique_ptr<Wrapland::Client::Output> clt_output{
+        m_registry->createOutput(outputAnnouncedSpy.first().first().value<quint32>(),
+                                 outputAnnouncedSpy.first().last().value<quint32>())};
+    QVERIFY(clt_output->isValid());
+
+    // Send window to output
+    m_window->request_send_to_output(clt_output.get());
+    m_connection->flush();
+
+    QVERIFY(sendToOutputSpy.wait());
+    auto actual = sendToOutputSpy.first().first().value<Wrapland::Server::Output*>();
+    QCOMPARE(actual, srv_output.get());
+}
+
 QTEST_GUILESS_MAIN(TestWindowManagement)
 #include "plasma_window_management.moc"
diff --git a/server/plasma_window.cpp b/server/plasma_window.cpp
index fa8a539f..7fb7dde4 100644
--- a/server/plasma_window.cpp
+++ b/server/plasma_window.cpp
@@ -20,15 +20,18 @@ License along with this library.  If not, see <http://www.gnu.org/licenses/>.
 #include "plasma_window_p.h"
 
 #include "display.h"
+#include "output.h"
 #include "plasma_virtual_desktop.h"
 #include "surface.h"
 #include "utils.h"
+#include "wl_output_p.h"
 
 #include <QFile>
 #include <QHash>
 #include <QIcon>
 #include <QList>
 #include <QRect>
+#include <QUuid>
 #include <QVector>
 #include <QtConcurrentRun>
 
@@ -43,6 +46,7 @@ const struct org_kde_plasma_window_management_interface PlasmaWindowManager::Pri
     = {
         showDesktopCallback,
         getWindowCallback,
+        get_window_by_uuid_callback,
 };
 
 PlasmaWindowManager::Private::Private(Display* display, PlasmaWindowManager* qptr)
@@ -69,8 +73,16 @@ PlasmaWindowManager::~PlasmaWindowManager() = default;
 void PlasmaWindowManager::Private::bindInit(PlasmaWindowManagerBind* bind)
 {
     for (auto&& window : windows) {
-        send<org_kde_plasma_window_management_send_window>(bind, window->d_ptr->windowId);
+        if (bind->version >= ORG_KDE_PLASMA_WINDOW_MANAGEMENT_WINDOW_WITH_UUID_SINCE_VERSION) {
+            send<org_kde_plasma_window_management_send_window_with_uuid>(
+                bind, window->d_ptr->windowId, window->d_ptr->uuid.data());
+        } else {
+            send<org_kde_plasma_window_management_send_window>(bind, window->d_ptr->windowId);
+        }
     }
+
+    send_stacking_order_changed(bind);
+    send_stacking_order_uuid_changed(bind);
 }
 
 void PlasmaWindowManager::Private::sendShowingDesktopState()
@@ -90,6 +102,55 @@ void PlasmaWindowManager::Private::sendShowingDesktopState()
     send<org_kde_plasma_window_management_send_show_desktop_changed>(state);
 }
 
+void PlasmaWindowManager::Private::send_stacking_order_changed()
+{
+    for (const auto bind : getBinds()) {
+        send_stacking_order_changed(bind);
+    }
+}
+
+void PlasmaWindowManager::Private::send_stacking_order_changed(PlasmaWindowManagerBind* bind)
+{
+    if (bind->version < ORG_KDE_PLASMA_WINDOW_MANAGEMENT_STACKING_ORDER_CHANGED_SINCE_VERSION) {
+        return;
+    }
+
+    wl_array ids;
+    wl_array_init(&ids);
+    for (auto const id : id_stack) {
+        auto key = static_cast<uint32_t*>(wl_array_add(&ids, sizeof(uint32_t)));
+        *key = id;
+    }
+
+    send<org_kde_plasma_window_management_send_stacking_order_changed>(bind, &ids);
+    wl_array_release(&ids);
+}
+
+void PlasmaWindowManager::Private::send_stacking_order_uuid_changed()
+{
+    for (const auto bind : getBinds()) {
+        send_stacking_order_uuid_changed(bind);
+    }
+}
+
+void PlasmaWindowManager::Private::send_stacking_order_uuid_changed(PlasmaWindowManagerBind* bind)
+{
+    if (bind->version
+        < ORG_KDE_PLASMA_WINDOW_MANAGEMENT_STACKING_ORDER_UUID_CHANGED_SINCE_VERSION) {
+        return;
+    }
+
+    std::string uuids;
+    if (!uuid_stack.empty()) {
+        // Concatenate all uuids using ';' as a separator
+        auto concatenate = [](auto a, auto const& b) { return std::move(a) + ';' + b; };
+        uuids = std::accumulate(
+            std::next(uuid_stack.begin()), uuid_stack.end(), uuid_stack[0], concatenate);
+    }
+
+    send<org_kde_plasma_window_management_send_stacking_order_uuid_changed>(bind, uuids.data());
+}
+
 void PlasmaWindowManager::Private::showDesktopCallback([[maybe_unused]] wl_client* wlClient,
                                                        wl_resource* wlResource,
                                                        uint32_t desktopState)
@@ -128,6 +189,32 @@ void PlasmaWindowManager::Private::getWindowCallback([[maybe_unused]] wl_client*
         window->d_ptr->createResource(bind->version, id, bind->client, true);
         return;
     }
+
+    (*it)->d_ptr->createResource(bind->version, id, bind->client, false);
+}
+
+void PlasmaWindowManager::Private::get_window_by_uuid_callback([[maybe_unused]] wl_client* wlClient,
+                                                               wl_resource* wlResource,
+                                                               uint32_t id,
+                                                               const char* uuid)
+{
+    assert(uuid != nullptr);
+
+    auto priv = get_handle(wlResource)->d_ptr.get();
+    auto bind = priv->getBind(wlResource);
+    std::string str_uuid = uuid;
+
+    auto it = std::find_if(priv->windows.cbegin(), priv->windows.cend(), [str_uuid](auto window) {
+        return window->d_ptr->uuid == str_uuid;
+    });
+
+    if (it == priv->windows.cend()) {
+        // Create a temp window just for the resource and directly send unmapped.
+        auto window = std::unique_ptr<PlasmaWindow>(new PlasmaWindow(priv->handle));
+        window->d_ptr->createResource(bind->version, id, bind->client, true);
+        return;
+    }
+
     (*it)->d_ptr->createResource(bind->version, id, bind->client, false);
 }
 
@@ -141,13 +228,28 @@ void PlasmaWindowManager::setShowingDesktopState(ShowingDesktopState desktopStat
 }
 
 PlasmaWindow* PlasmaWindowManager::createWindow(QObject* parent)
+{
+    auto uuid = QUuid::createUuid().toString(QUuid::WithoutBraces).toStdString();
+    return createWindow(uuid, parent);
+}
+
+PlasmaWindow* PlasmaWindowManager::createWindow(std::string const& uuid, QObject* parent)
 {
     auto window = new PlasmaWindow(this, parent);
 
     // TODO(unknown author): improve window ids so that it cannot wrap around
     window->d_ptr->windowId = ++d_ptr->windowIdCounter;
+    window->d_ptr->uuid = uuid;
 
-    d_ptr->send<org_kde_plasma_window_management_send_window>(window->d_ptr->windowId);
+    for (auto bind : d_ptr->getBinds()) {
+        if (bind->version < ORG_KDE_PLASMA_WINDOW_MANAGEMENT_WINDOW_WITH_UUID_SINCE_VERSION) {
+            bind->send<org_kde_plasma_window_management_send_window>(window->d_ptr->windowId);
+            continue;
+        }
+
+        bind->send<org_kde_plasma_window_management_send_window_with_uuid>(window->d_ptr->windowId,
+                                                                           uuid.data());
+    }
 
     d_ptr->windows.push_back(window);
     connect(
@@ -161,6 +263,26 @@ std::vector<PlasmaWindow*> const& PlasmaWindowManager::windows() const
     return d_ptr->windows;
 }
 
+void PlasmaWindowManager::set_stacking_order(std::vector<uint32_t> const& stack)
+{
+    if (d_ptr->id_stack == stack) {
+        return;
+    }
+
+    d_ptr->id_stack = stack;
+    d_ptr->send_stacking_order_changed();
+}
+
+void PlasmaWindowManager::set_stacking_order_uuids(std::vector<std::string> const& stack)
+{
+    if (d_ptr->uuid_stack == stack) {
+        return;
+    }
+
+    d_ptr->uuid_stack = stack;
+    d_ptr->send_stacking_order_uuid_changed();
+}
+
 void PlasmaWindowManager::unmapWindow(PlasmaWindow* window)
 {
     if (!window) {
@@ -612,6 +734,11 @@ std::vector<std::string> const& PlasmaWindow::plasmaVirtualDesktops() const
     return d_ptr->plasmaVirtualDesktops;
 }
 
+std::string const& PlasmaWindow::uuid() const
+{
+    return d_ptr->uuid;
+}
+
 void PlasmaWindow::setShadeable(bool set)
 {
     d_ptr->setState(ORG_KDE_PLASMA_WINDOW_MANAGEMENT_STATE_SHADEABLE, set);
@@ -683,6 +810,9 @@ const struct org_kde_plasma_window_interface PlasmaWindowRes::Private::s_interfa
     requestEnterVirtualDesktopCallback,
     requestEnterNewVirtualDesktopCallback,
     requestLeaveVirtualDesktopCallback,
+    request_enter_activity_callback,
+    request_leave_activity_callback,
+    send_to_output_callback,
 };
 
 void PlasmaWindowRes::Private::getIconCallback([[maybe_unused]] wl_client* wlClient,
@@ -929,6 +1059,37 @@ void PlasmaWindowRes::Private::unsetMinimizedGeometryCallback([[maybe_unused]] w
     Q_EMIT priv->window->minimizedGeometriesChanged();
 }
 
+void PlasmaWindowRes::Private::request_enter_activity_callback(wl_client* /*wlClient*/,
+                                                               wl_resource* /*wlResource*/,
+                                                               const char* /*id*/)
+{
+}
+
+void PlasmaWindowRes::Private::request_leave_activity_callback(wl_client* /*wlClient*/,
+                                                               wl_resource* /*wlResource*/,
+                                                               const char* /*id*/)
+{
+}
+
+void PlasmaWindowRes::Private::send_to_output_callback(wl_client* /*wlClient*/,
+                                                       wl_resource* wlResource,
+                                                       wl_resource* wlOutput)
+{
+    auto priv = get_handle(wlResource)->d_ptr;
+    if (!priv->window) {
+        return;
+    }
+
+    auto wloutput = WlOutputGlobal::get_handle(wlOutput);
+
+    // Don't emit signal if output has been destroyed server-side, for example being hotplugged.
+    if (wloutput == nullptr) {
+        return;
+    }
+
+    Q_EMIT priv->window->sendToOutputRequested(wloutput->output());
+}
+
 void PlasmaWindowRes::Private::unmap()
 {
     window = nullptr;
diff --git a/server/plasma_window.h b/server/plasma_window.h
index 444aefc6..ed322e43 100644
--- a/server/plasma_window.h
+++ b/server/plasma_window.h
@@ -33,6 +33,7 @@ namespace Wrapland::Server
 {
 
 class Display;
+class Output;
 class PlasmaWindow;
 class Surface;
 class PlasmaVirtualDesktopManager;
@@ -47,7 +48,12 @@ public:
     enum class ShowingDesktopState { Disabled, Enabled };
     void setShowingDesktopState(ShowingDesktopState state);
 
+    /// Create a window with random uuid.
     PlasmaWindow* createWindow(QObject* parent = nullptr);
+
+    /// Create a window with specific uuid.
+    PlasmaWindow* createWindow(std::string const& uuid, QObject* parent = nullptr);
+
     std::vector<PlasmaWindow*> const& windows() const;
 
     void unmapWindow(PlasmaWindow* window);
@@ -56,6 +62,9 @@ public:
 
     PlasmaVirtualDesktopManager* virtualDesktopManager() const;
 
+    void set_stacking_order(std::vector<uint32_t> const& stack);
+    void set_stacking_order_uuids(std::vector<std::string> const& stack);
+
 Q_SIGNALS:
     void requestChangeShowingDesktop(ShowingDesktopState requestedState);
 
@@ -110,6 +119,11 @@ public:
     void removePlasmaVirtualDesktop(std::string const& id);
     std::vector<std::string> const& plasmaVirtualDesktops() const;
 
+    /**
+     * @return a unique string that identifies this window
+     */
+    std::string const& uuid() const;
+
 Q_SIGNALS:
     void closeRequested();
     void moveRequested();
@@ -138,6 +152,9 @@ Q_SIGNALS:
     void enterNewPlasmaVirtualDesktopRequested();
     void leavePlasmaVirtualDesktopRequested(const QString& desktop);
 
+    /// Client asked for this window to be displayed on @p output
+    void sendToOutputRequested(Wrapland::Server::Output* output);
+
 private:
     friend class PlasmaWindowManager;
     friend class PlasmaWindowRes;
diff --git a/server/plasma_window_p.h b/server/plasma_window_p.h
index ead64d1e..7f45cdec 100644
--- a/server/plasma_window_p.h
+++ b/server/plasma_window_p.h
@@ -40,7 +40,7 @@ class Surface;
 class PlasmaVirtualDesktopManager;
 class PlasmaWindowRes;
 
-constexpr uint32_t PlasmaWindowManagerVersion = 10;
+constexpr uint32_t PlasmaWindowManagerVersion = 15;
 using PlasmaWindowManagerGlobal = Wayland::Global<PlasmaWindowManager, PlasmaWindowManagerVersion>;
 using PlasmaWindowManagerBind = Wayland::Bind<PlasmaWindowManagerGlobal>;
 
@@ -49,11 +49,17 @@ class PlasmaWindowManager::Private : public PlasmaWindowManagerGlobal
 public:
     Private(Display* display, PlasmaWindowManager* qptr);
     void sendShowingDesktopState();
+    void send_stacking_order_changed();
+    void send_stacking_order_changed(PlasmaWindowManagerBind* bind);
+    void send_stacking_order_uuid_changed();
+    void send_stacking_order_uuid_changed(PlasmaWindowManagerBind* bind);
 
     void bindInit(PlasmaWindowManagerBind* bind) override;
 
     ShowingDesktopState desktopState = ShowingDesktopState::Disabled;
     std::vector<PlasmaWindow*> windows;
+    std::vector<uint32_t> id_stack;
+    std::vector<std::string> uuid_stack;
     PlasmaVirtualDesktopManager* virtualDesktopManager = nullptr;
     uint32_t windowIdCounter = 0;
 
@@ -64,6 +70,10 @@ private:
                                   wl_resource* resource,
                                   uint32_t id,
                                   uint32_t internalWindowId);
+    static void get_window_by_uuid_callback(wl_client* client,
+                                            wl_resource* resource,
+                                            uint32_t id,
+                                            const char* uuid);
 
     static const struct org_kde_plasma_window_management_interface s_interface;
 };
@@ -90,6 +100,7 @@ public:
     static PlasmaWindowRes* getResourceOfParent(PlasmaWindow* parent, PlasmaWindowRes* childRes);
 
     std::vector<PlasmaWindowRes*> resources;
+    std::string uuid;
     uint32_t windowId = 0;
     QHash<Surface*, QRect> minimizedGeometries;
     PlasmaWindowManager* manager;
@@ -170,6 +181,12 @@ private:
     static void requestEnterNewVirtualDesktopCallback(wl_client* client, wl_resource* resource);
     static void
     requestLeaveVirtualDesktopCallback(wl_client* client, wl_resource* resource, const char* id);
+    static void
+    request_enter_activity_callback(wl_client* client, wl_resource* resource, const char* id);
+    static void
+    request_leave_activity_callback(wl_client* client, wl_resource* resource, const char* id);
+    static void
+    send_to_output_callback(wl_client* client, wl_resource* resource, wl_resource* output);
 
     PlasmaWindow* window;
     static const struct org_kde_plasma_window_interface s_interface;
diff --git a/src/client/plasmawindowmanagement.cpp b/src/client/plasmawindowmanagement.cpp
index e2f83795..13d38326 100644
--- a/src/client/plasmawindowmanagement.cpp
+++ b/src/client/plasmawindowmanagement.cpp
@@ -1,5 +1,6 @@
 /********************************************************************
 Copyright 2015  Martin Gräßlin <mgraesslin@kde.org>
+Copyright 2022  Francesco Sorrentino <francesco.sorr@gmail.com>
 
 This library is free software; you can redistribute it and/or
 modify it under the terms of the GNU Lesser General Public
@@ -26,6 +27,7 @@ License along with this library.  If not, see <http://www.gnu.org/licenses/>.
 #include "wayland_pointer_p.h"
 // Wayland
 #include <wayland-plasma-window-management-client-protocol.h>
+#include <wayland-util.h>
 
 #include <QFutureWatcher>
 #include <QTimer>
@@ -45,16 +47,32 @@ public:
     EventQueue* queue = nullptr;
     bool showingDesktop = false;
     QList<PlasmaWindow*> windows;
+    std::vector<std::string> stacking_order_uuid;
+    std::vector<uint32_t> stacking_order;
     PlasmaWindow* activeWindow = nullptr;
 
     void setup(org_kde_plasma_window_management* proxy);
+    PlasmaWindow*
+    windowCreated(org_kde_plasma_window* id, quint32 internalId, std::string const& uuid);
 
 private:
     static void
     showDesktopCallback(void* data, org_kde_plasma_window_management* proxy, uint32_t state);
     static void windowCallback(void* data, org_kde_plasma_window_management* proxy, uint32_t id);
+    static void stacking_order_changed_callback(void* data,
+                                                org_kde_plasma_window_management* proxy,
+                                                wl_array* ids);
+    static void stacking_order_uuid_changed_callback(void* data,
+                                                     org_kde_plasma_window_management* proxy,
+                                                     char const* uuids);
+    static void window_with_uuid_callback(void* data,
+                                          org_kde_plasma_window_management* proxy,
+                                          uint32_t id,
+                                          char const* uuid);
+
     void setShowDesktop(bool set);
-    void windowCreated(org_kde_plasma_window* id, quint32 internalId);
+    void set_stacking_order(std::vector<uint32_t> const& stack);
+    void set_stacking_order_uuids(std::vector<std::string> const& stack);
 
     org_kde_plasma_window_management_listener static const s_listener;
     PlasmaWindowManagement* q;
@@ -63,9 +81,10 @@ private:
 class Q_DECL_HIDDEN PlasmaWindow::Private
 {
 public:
-    Private(org_kde_plasma_window* window, quint32 internalId, PlasmaWindow* q);
+    Private(org_kde_plasma_window* window, quint32 internalId, std::string uuid, PlasmaWindow* q);
     WaylandPointer<org_kde_plasma_window, org_kde_plasma_window_destroy> window;
     quint32 internalId;
+    std::string uuid;
     QString title;
     QString appId;
     quint32 desktop = 0;
@@ -131,6 +150,9 @@ private:
                                        org_kde_plasma_window* org_kde_plasma_window,
                                        char const* service_name,
                                        char const* object_path);
+    static void
+    activity_entered_callback(void* data, org_kde_plasma_window* window, char const* id);
+    static void activity_left_callback(void* data, org_kde_plasma_window* window, char const* id);
 
     void setActive(bool set);
     void setMinimized(bool set);
@@ -152,7 +174,6 @@ private:
     void setResizable(bool set);
     void setVirtualDesktopChangeable(bool set);
     void setParentWindow(PlasmaWindow* parentWindow);
-    void setPid(quint32 pid);
 
     static Private* cast(void* data)
     {
@@ -172,6 +193,9 @@ PlasmaWindowManagement::Private::Private(PlasmaWindowManagement* q)
 org_kde_plasma_window_management_listener const PlasmaWindowManagement::Private::s_listener = {
     showDesktopCallback,
     windowCallback,
+    stacking_order_changed_callback,
+    stacking_order_uuid_changed_callback,
+    window_with_uuid_callback,
 };
 
 void PlasmaWindowManagement::Private::setup(org_kde_plasma_window_management* proxy)
@@ -217,15 +241,96 @@ void PlasmaWindowManagement::Private::windowCallback(void* data,
     auto wm = reinterpret_cast<PlasmaWindowManagement::Private*>(data);
     Q_ASSERT(wm->wm == proxy);
 
-    wm->windowCreated(org_kde_plasma_window_management_get_window(wm->wm, id), id);
+    wm->windowCreated(org_kde_plasma_window_management_get_window(wm->wm, id), id, "unavailable");
+}
+
+void PlasmaWindowManagement::Private::stacking_order_changed_callback(
+    void* data,
+    org_kde_plasma_window_management* proxy,
+    wl_array* ids)
+{
+    auto wm = reinterpret_cast<PlasmaWindowManagement::Private*>(data);
+    Q_ASSERT(wm->wm == proxy);
+
+    auto begin = static_cast<uint32_t*>(ids->data);
+    auto end = begin + ids->size / sizeof(uint32_t);
+    auto stack = std::vector(begin, end);
+
+    wm->set_stacking_order(stack);
+}
+
+void PlasmaWindowManagement::Private::set_stacking_order(std::vector<uint32_t> const& stack)
+{
+    if (stacking_order == stack) {
+        return;
+    }
+
+    stacking_order = stack;
+    Q_EMIT q->stacking_order_changed();
+}
+
+void PlasmaWindowManagement::Private::stacking_order_uuid_changed_callback(
+    void* data,
+    org_kde_plasma_window_management* proxy,
+    char const* uuids)
+{
+    auto wm = reinterpret_cast<PlasmaWindowManagement::Private*>(data);
+    Q_ASSERT(wm->wm == proxy);
+
+    // TODO(fsorrent): C++20
+    // for (auto const uuid : std::views::split(std::string_view(uuids), ';')) {
+    //     stack.push_back(uuid);
+    // }
+
+    auto s = std::string(uuids);
+    auto stack = std::vector<std::string>();
+    size_t pos = 0;
+    while ((pos = s.find(';')) != std::string::npos) {
+        std::string uuid = s.substr(0, pos);
+        stack.push_back(uuid);
+        s.erase(0, pos + 1);
+    }
+    if (!s.empty()) {
+        stack.push_back(s);
+    }
+
+    wm->set_stacking_order_uuids(stack);
+}
+
+void PlasmaWindowManagement::Private::set_stacking_order_uuids(
+    std::vector<std::string> const& stack)
+{
+    if (stacking_order_uuid == stack) {
+        return;
+    }
+
+    stacking_order_uuid = stack;
+    Q_EMIT q->stacking_order_uuid_changed();
+}
+
+void PlasmaWindowManagement::Private::window_with_uuid_callback(
+    void* data,
+    org_kde_plasma_window_management* proxy,
+    uint32_t id,
+    char const* uuid)
+{
+    auto wm = reinterpret_cast<PlasmaWindowManagement::Private*>(data);
+    Q_ASSERT(wm->wm == proxy);
+    Q_ASSERT(uuid != nullptr);
+
+    wm->windowCreated(org_kde_plasma_window_management_get_window_by_uuid(wm->wm, uuid), id, uuid);
+
+    Q_EMIT wm->q->window_with_uuid(uuid);
 }
 
-void PlasmaWindowManagement::Private::windowCreated(org_kde_plasma_window* id, quint32 internalId)
+PlasmaWindow* PlasmaWindowManagement::Private::windowCreated(org_kde_plasma_window* id,
+                                                             quint32 internalId,
+                                                             std::string const& uuid)
 {
     if (queue) {
         queue->addProxy(id);
     }
-    auto window = new PlasmaWindow(q, id, internalId);
+    auto window = new PlasmaWindow(q, id, internalId, uuid);
     window->d->wm = q;
     windows << window;
     QObject::connect(window, &QObject::destroyed, q, [this, window] {
@@ -255,6 +360,8 @@ void PlasmaWindowManagement::Private::windowCreated(org_kde_plasma_window* id, q
             }
         }
     });
+
+    return window;
 }
 
 PlasmaWindowManagement::PlasmaWindowManagement(QObject* parent)
@@ -330,11 +437,27 @@ bool PlasmaWindowManagement::isShowingDesktop() const
     return d->showingDesktop;
 }
 
+PlasmaWindow* PlasmaWindowManagement::get_window_by_uuid(std::string const& uuid) const
+{
+    auto proxy = org_kde_plasma_window_management_get_window_by_uuid(d->wm, uuid.data());
+    return d->windowCreated(proxy, 0, uuid);
+}
+
 QList<PlasmaWindow*> PlasmaWindowManagement::windows() const
 {
     return d->windows;
 }
 
+std::vector<uint32_t> const& PlasmaWindowManagement::stacking_order() const
+{
+    return d->stacking_order;
+}
+
+std::vector<std::string> const& PlasmaWindowManagement::stacking_order_uuid() const
+{
+    return d->stacking_order_uuid;
+}
+
 PlasmaWindow* PlasmaWindowManagement::activeWindow() const
 {
     return d->activeWindow;
@@ -360,8 +483,22 @@ org_kde_plasma_window_listener const PlasmaWindow::Private::s_listener = {
     virtualDesktopEnteredCallback,
     virtualDesktopLeftCallback,
     appmenuChangedCallback,
+    activity_entered_callback,
+    activity_left_callback,
 };
 
+void PlasmaWindow::Private::activity_entered_callback(void* /*data*/,
+                                                      org_kde_plasma_window* /*window*/,
+                                                      char const* /*id*/)
+{
+}
+
+void PlasmaWindow::Private::activity_left_callback(void* /*data*/,
+                                                   org_kde_plasma_window* /*window*/,
+                                                   char const* /*id*/)
+{
+}
+
 void PlasmaWindow::Private::parentWindowCallback(void* data,
                                                  org_kde_plasma_window* window,
                                                  org_kde_plasma_window* parent)
@@ -792,8 +929,12 @@ void PlasmaWindow::Private::setVirtualDesktopChangeable(bool set)
     Q_EMIT q->virtualDesktopChangeableChanged();
 }
 
-PlasmaWindow::Private::Private(org_kde_plasma_window* w, quint32 internalId, PlasmaWindow* q)
+PlasmaWindow::Private::Private(org_kde_plasma_window* w,
+                               quint32 internalId,
+                               std::string uuid,
+                               PlasmaWindow* q)
     : internalId(internalId)
+    , uuid(std::move(uuid))
     , q(q)
 {
     window.setup(w);
@@ -802,9 +943,10 @@ PlasmaWindow::Private::Private(org_kde_plasma_window* w, quint32 internalId, Pla
 
 PlasmaWindow::PlasmaWindow(PlasmaWindowManagement* parent,
                            org_kde_plasma_window* window,
-                           quint32 internalId)
+                           quint32 internalId,
+                           std::string const& uuid)
     : QObject(parent)
-    , d(new Private(window, internalId, this))
+    , d(new Private(window, internalId, uuid, this))
 {
 }
 
@@ -1071,6 +1213,11 @@ QRect PlasmaWindow::geometry() const
     return d->geometry;
 }
 
+std::string const& PlasmaWindow::uuid() const
+{
+    return d->uuid;
+}
+
 void PlasmaWindow::requestEnterVirtualDesktop(const QString& id)
 {
     org_kde_plasma_window_request_enter_virtual_desktop(d->window, id.toUtf8());
@@ -1086,6 +1233,11 @@ void PlasmaWindow::requestLeaveVirtualDesktop(const QString& id)
     org_kde_plasma_window_request_leave_virtual_desktop(d->window, id.toUtf8());
 }
 
+void PlasmaWindow::request_send_to_output(Output* output)
+{
+    org_kde_plasma_window_send_to_output(d->window, output->output());
+}
+
 QStringList PlasmaWindow::plasmaVirtualDesktops() const
 {
     return d->plasmaVirtualDesktops;
diff --git a/src/client/plasmawindowmanagement.h b/src/client/plasmawindowmanagement.h
index 7483d7a3..c025af2e 100644
--- a/src/client/plasmawindowmanagement.h
+++ b/src/client/plasmawindowmanagement.h
@@ -24,7 +24,10 @@ License along with this library.  If not, see <http://www.gnu.org/licenses/>.
 #include <QObject>
 #include <QSize>
 // STD
+#include <cstdint>
 #include <memory>
+#include <string>
+#include <vector>
 
 #include <Wrapland/Client/wraplandclient_export.h>
 
@@ -34,6 +37,7 @@ struct org_kde_plasma_window;
 namespace Wrapland::Client
 {
 class EventQueue;
+class Output;
 class PlasmaWindow;
 class PlasmaWindowModel;
 class Surface;
@@ -136,11 +140,27 @@ public:
      **/
     void hideDesktop();
 
+    /**
+     * Retrieve a window or create a new one.
+     **/
+    PlasmaWindow* get_window_by_uuid(std::string const& uuid) const;
+
     /**
      * @returns All windows currently known to the PlasmaWindowManagement
      * @see windowCreated
      **/
     QList<PlasmaWindow*> windows() const;
+
+    /**
+     * @returns The stack of windows, by internal id (deprecated).
+     **/
+    std::vector<uint32_t> const& stacking_order() const;
+
+    /**
+     * @returns The stack of windows, by unique identifiers.
+     **/
+    std::vector<std::string> const& stacking_order_uuid() const;
+
     /**
      * @returns The currently active PlasmaWindow, the PlasmaWindow which
      * returns @c true in {@link PlasmaWindow::isActive} or @c nullptr in case
@@ -176,6 +196,23 @@ Q_SIGNALS:
      **/
     void activeWindowChanged();
 
+    /**
+     * Windows stacking order changed (deprecated).
+     * @see stacking_order
+     **/
+    void stacking_order_changed();
+
+    /**
+     * Windows stacking order changed.
+     * @see stacking_order_with_uuids
+     **/
+    void stacking_order_uuid_changed();
+
+    /**
+     * A window was mapped.
+     **/
+    void window_with_uuid(std::string const& uuid);
+
     /**
      * The corresponding global for this interface on the Registry got removed.
      *
@@ -236,6 +273,10 @@ public:
      * @see appIdChanged
      **/
     QString appId() const;
+    /**
+     * @returns the window's uuid
+     */
+    std::string const& uuid() const;
     /**
      * @returns Whether the window is currently the active Window.
      * @see activeChanged
@@ -461,6 +502,11 @@ public:
      */
     void requestLeaveVirtualDesktop(const QString& id);
 
+    /**
+     * Requests this window to be displayed in a specific output.
+     */
+    void request_send_to_output(Output* output);
+
     /**
      * Return all the virtual desktop ids this window is associated to.
      * When a desktop gets deleted, it will be automatically removed from this list.
@@ -644,7 +690,8 @@ private:
     friend class PlasmaWindowManagement;
     explicit PlasmaWindow(PlasmaWindowManagement* parent,
                           org_kde_plasma_window* window,
-                          quint32 internalId);
+                          quint32 internalId,
+                          std::string const& uuid);
     class Private;
     std::unique_ptr<Private> d;
 };
diff --git a/src/client/protocols/plasma-window-management.xml b/src/client/protocols/plasma-window-management.xml
index 684b1ea2..2bbf0760 100644
--- a/src/client/protocols/plasma-window-management.xml
+++ b/src/client/protocols/plasma-window-management.xml
@@ -1,23 +1,12 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <protocol name="plasma_window_management">
   <copyright><![CDATA[
-    Copyright (C) 2013-2014 Pier Luigi Fiorini
+    SPDX-FileCopyrightText: 2013-2014 Pier Luigi Fiorini
 
-    This program is free software: you can redistribute it and/or modify
-    it under the terms of the GNU Lesser General Public License as published by
-    the Free Software Foundation, either version 2.1 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU Lesser General Public License for more details.
-
-    You should have received a copy of the GNU Lesser General Public License
-    along with this program.  If not, see <http://www.gnu.org/licenses/>.
+    SPDX-License-Identifier: LGPL-2.1-or-later
   ]]></copyright>
 
-  <interface name="org_kde_plasma_window_management" version="10">
+  <interface name="org_kde_plasma_window_management" version="15">
     <description summary="application windows management">
       This interface manages application windows.
       It provides requests to show and hide the desktop and emits
@@ -62,10 +51,16 @@
     </request>
 
     <request name="get_window">
+        <description summary="deprecated">Deprecated: use get_window_by_uuid</description>
         <arg name="id" type="new_id" interface="org_kde_plasma_window"/>
         <arg name="internal_window_id" type="uint" summary="The internal window id of the window to create"/>
     </request>
 
+    <request name="get_window_by_uuid" since="12">
+        <arg name="id" type="new_id" interface="org_kde_plasma_window"/>
+        <arg name="internal_window_uuid" type="string" summary="The internal window uuiid of the window to create"/>
+    </request>
+
     <event name="show_desktop_changed">
         <description summary="notify the client when the show desktop mode is entered/left">
             This event will be sent whenever the show desktop mode changes. E.g. when it is entered
@@ -80,11 +75,33 @@
       <description summary="notify the client that a window was mapped">
         This event will be sent immediately after a window is mapped.
       </description>
-      <arg name="id" type="uint" summary="internal window Id"/>
+      <arg name="id" type="uint" summary="Deprecated: internal window Id"/>
+    </event>
+
+    <event name="stacking_order_changed" since="11">
+      <description summary="notify the client when stacking order changed">
+        This event will be sent when stacking order changed and on bind
+      </description>
+      <arg name="ids" type="array" summary="internal windows id array"/>
+    </event>
+
+    <event name="stacking_order_uuid_changed" since="12">
+      <description summary="notify the client when stacking order changed">
+        This event will be sent when stacking order changed and on bind
+      </description>
+      <arg name="uuids" type="string" summary="internal windows id ;-separated"/>
+    </event>
+
+    <event name="window_with_uuid" since="13">
+      <description summary="notify the client that a window was mapped">
+        This event will be sent immediately after a window is mapped.
+      </description>
+      <arg name="id" type="uint" summary="Deprecated: internal window Id"/>
+      <arg name="uuid" type="string" summary="internal window uuid"/>
     </event>
   </interface>
 
-  <interface name="org_kde_plasma_window" version="10">
+  <interface name="org_kde_plasma_window" version="15">
     <description summary="interface to control application windows">
       Manages and control an application window.
 
@@ -318,7 +335,83 @@
       </description>
       <arg name="service_name" type="string" />
       <arg name="object_path" type="string" />
-  </event>
+    </event>
+
+    <request name="request_enter_activity" since="14">
+      <description summary="map window on an activity">
+        Make the window enter an activity. A window can enter more activity. If the id is empty or invalid, no action will be performed.
+      </description>
+      <arg name="id" type="string" summary="activity id"/>
+    </request>
+
+    <request name="request_leave_activity" since="14">
+      <description summary="remove a window from an activity">
+        Make the window exit a an activity. If it exits all activities it will be considered on all of them.
+      </description>
+      <arg name="id" type="string" summary="activity id"/>
+    </request>
+
+    <event name="activity_entered" since="14">
+      <description summary="the window entered an activity">
+        This event will be sent when the window has entered an activity. The window can be on more than one activity, or none: then is considered on all of them.
+      </description>
+      <arg name="id" type="string" summary="activity id"/>
+    </event>
+
+    <event name="activity_left" since="14">
+      <description summary="the window left an activity">
+        This event will be sent when the window left an activity. If the window leaves all activities, it will be considered on all.
+        If the window gets manually added on all activities, the server has to send activity_left for every previous activity it was in for the window to be really considered on all activities.
+      </description>
+      <arg name="id" type="string" summary="activity id"/>
+    </event>
+
+    <request name="send_to_output" since="15">
+     <description summary="send window to specified output">
+        Requests this window to be displayed in a specific output.
+      </description>
+      <arg name="output" type="object" interface="wl_output"/>
+    </request>
+  </interface>
+
+  <interface name="org_kde_plasma_activation_feedback" version="1">
+    <description summary="activation feedback">
+      The activation manager interface provides a way to get notified
+      when an application is about to be activated.
+    </description>
+
+    <request name="destroy" type="destructor">
+      <description summary="destroy the activation manager object">
+        Destroy the activation manager object. The activation objects introduced
+        by this manager object will be unaffected.
+      </description>
+    </request>
+
+    <event name="activation">
+      <description summary="notify that an app is starting">
+        Will be issued when an app is set to be activated. It offers
+        an instance of org_kde_plasma_activation that will tell us the app_id
+        and the extent of the activation.
+      </description>
+      <arg name="id" type="new_id" interface="org_kde_plasma_activation"/>
+    </event>
+  </interface>
 
+  <interface name="org_kde_plasma_activation" version="1">
+    <request name="destroy" type="destructor">
+      <description summary="destroy the org_kde_plasma_activation object">
+        Notify the compositor that the org_kde_plasma_activation object will no
+        longer be used.
+      </description>
+    </request>
+
+    <event name="app_id">
+      <description summary="Offers the app_id"></description>
+      <arg name="app_id" type="string" summary="application id, as described in xdg_activation_v1"/>
+    </event>
+
+    <event name="finished">
+        <description summary="Notifies about activation finished, either by activation or because it got invalidated"></description>
+    </event>
   </interface>
 </protocol>
diff --git a/src/client/registry.cpp b/src/client/registry.cpp
index a119224d..706d2dca 100644
--- a/src/client/registry.cpp
+++ b/src/client/registry.cpp
@@ -262,7 +262,7 @@ static const QMap<Registry::Interface, SuppertedInterfaceData> s_interfaces = {
     {
         Registry::Interface::PlasmaWindowManagement,
         {
-            10,
+            15,
             QByteArrayLiteral("org_kde_plasma_window_management"),
             &org_kde_plasma_window_management_interface,
             &Registry::plasmaWindowManagementAnnounced,
-- 
GitLab


From 4e000545c1e4aae92a111992a67708ab7506a50d Mon Sep 17 00:00:00 2001
From: Tom Englund <tomenglund26@gmail.com>
Date: Fri, 15 Apr 2022 14:31:19 +0200
Subject: [PATCH 5/5] feat(server): add id to PlasmaWindow class

add a way to return the windowId.
compositors may use the function to retrieve the id for internal logic.
---
 server/plasma_window.cpp | 5 +++++
 server/plasma_window.h   | 5 +++++
 2 files changed, 10 insertions(+)

diff --git a/server/plasma_window.cpp b/server/plasma_window.cpp
index 7fb7dde4..facc08e1 100644
--- a/server/plasma_window.cpp
+++ b/server/plasma_window.cpp
@@ -734,6 +734,11 @@ std::vector<std::string> const& PlasmaWindow::plasmaVirtualDesktops() const
     return d_ptr->plasmaVirtualDesktops;
 }
 
+std::uint32_t const& PlasmaWindow::id() const
+{
+    return d_ptr->windowId;
+}
+
 std::string const& PlasmaWindow::uuid() const
 {
     return d_ptr->uuid;
diff --git a/server/plasma_window.h b/server/plasma_window.h
index ed322e43..eb923a59 100644
--- a/server/plasma_window.h
+++ b/server/plasma_window.h
@@ -119,6 +119,11 @@ public:
     void removePlasmaVirtualDesktop(std::string const& id);
     std::vector<std::string> const& plasmaVirtualDesktops() const;
 
+    /**
+     * @return a windowId identifying the window in the stacking_order.
+     */
+    std::uint32_t const& id() const;
+
     /**
      * @return a unique string that identifies this window
      */
-- 
GitLab

