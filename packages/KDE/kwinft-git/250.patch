From 6dbcfd69fd6dc6b7db70f4333f326ebc05d2f269 Mon Sep 17 00:00:00 2001
From: Tom Englund <tomenglund26@gmail.com>
Date: Thu, 6 Oct 2022 17:50:53 +0200
Subject: [PATCH 01/14] fix: use free on allocated memory with malloc

dont use delete on memory allocated with malloc, it is undefined
behaviour. use free(foo).
---
 input/xkb/keymap.cpp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/input/xkb/keymap.cpp b/input/xkb/keymap.cpp
index 2afe32a64..afbe6dda9 100644
--- a/input/xkb/keymap.cpp
+++ b/input/xkb/keymap.cpp
@@ -47,7 +47,7 @@ keymap::keymap(int fd, uint32_t size, xkb_context* context)
 
 keymap::~keymap()
 {
-    delete cache;
+    free(cache);
     if (raw) {
         xkb_keymap_unref(raw);
     }
-- 
GitLab


From 1d5b73c97c59ff6eb9e11a8110060192dcd518c6 Mon Sep 17 00:00:00 2001
From: Tom Englund <tomenglund26@gmail.com>
Date: Thu, 6 Oct 2022 17:52:04 +0200
Subject: [PATCH 02/14] fix: add virtual destructor to base class

without virtual destructor to base class pointer_config which is a
derivative of device_config will not get destructed properly when used
with pointers.
---
 input/control/config.h | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/input/control/config.h b/input/control/config.h
index 8de5f95bd..0597e73f2 100644
--- a/input/control/config.h
+++ b/input/control/config.h
@@ -114,6 +114,8 @@ void load_config(Dev* device)
 class device_config
 {
 public:
+    virtual ~device_config() = default;
+
     KConfigGroup group;
     bool writable{true};
 
-- 
GitLab


From 629dfd9139affc4a09ae8137900efb3acd921664 Mon Sep 17 00:00:00 2001
From: Tom Englund <tomenglund26@gmail.com>
Date: Thu, 6 Oct 2022 23:58:58 +0200
Subject: [PATCH 03/14] fix: ensure we dont have duplicates

internal remnant windows can both be in stacking order and
render_overlays, ensure we dont add duplicates of the same pointer to
the render_stack and later get use after free issues.
---
 win/wayland/space.h | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/win/wayland/space.h b/win/wayland/space.h
index 53d07c74c..810e6f0ae 100644
--- a/win/wayland/space.h
+++ b/win/wayland/space.h
@@ -123,7 +123,7 @@ public:
                              for (auto win : windows) {
                                  std::visit(
                                      overload{[&](internal_window_t* win) {
-                                                  if (win->isShown()) {
+                                                  if (win->isShown() && !win->remnant) {
                                                       stacking.order.render_overlays.push_back(win);
                                                   }
                                               },
-- 
GitLab


From 8dd1476b48918a1ec9cd2389bc120935abef330b Mon Sep 17 00:00:00 2001
From: Tom Englund <tomenglund26@gmail.com>
Date: Fri, 7 Oct 2022 00:16:42 +0200
Subject: [PATCH 04/14] fix: ensure space pointer is null

if space is destructed upon exit of kwinft the space pointer will not be
nulled, which means the if check for comp.space in compositor_stop fails
and we get a use after free. set space to nullptr on qobject signal
destroyed.
---
 render/wayland/compositor.h | 1 +
 render/x11/compositor.h     | 1 +
 2 files changed, 2 insertions(+)

diff --git a/render/wayland/compositor.h b/render/wayland/compositor.h
index 88c6ce254..fffa19149 100644
--- a/render/wayland/compositor.h
+++ b/render/wayland/compositor.h
@@ -56,6 +56,7 @@ public:
     ~compositor()
     {
         Q_EMIT this->qobject->aboutToDestroy();
+        this->space = nullptr;
         compositor_stop(*this, true);
         delete_unused_support_properties(*this);
         compositor_destroy_selection(*this);
diff --git a/render/x11/compositor.h b/render/x11/compositor.h
index 0c27df55d..64432016a 100644
--- a/render/x11/compositor.h
+++ b/render/x11/compositor.h
@@ -107,6 +107,7 @@ public:
     ~compositor()
     {
         Q_EMIT this->qobject->aboutToDestroy();
+        this->space = nullptr;
         compositor_stop(*this, true);
         delete_unused_support_properties(*this);
         compositor_destroy_selection(*this);
-- 
GitLab


From 5e6afea53f990dfa9739bfd7700b363163f3c584 Mon Sep 17 00:00:00 2001
From: Tom Englund <tomenglund26@gmail.com>
Date: Fri, 7 Oct 2022 00:22:49 +0200
Subject: [PATCH 05/14] fix: add virtual destructor to base class

without virtual destructor to base class platform its derivatives
will not get destructed properly when used with pointers.
---
 input/platform.h | 1 +
 1 file changed, 1 insertion(+)

diff --git a/input/platform.h b/input/platform.h
index 6004a29a0..673e3d1ce 100644
--- a/input/platform.h
+++ b/input/platform.h
@@ -96,6 +96,7 @@ public:
 
     platform(platform const&) = delete;
     platform& operator=(platform const&) = delete;
+    virtual ~platform() = default;
 
     void registerPointerShortcut(Qt::KeyboardModifiers modifiers,
                                  Qt::MouseButton pointerButtons,
-- 
GitLab


From 0c08ba2362ce65160b25827573b6769d7381ccfb Mon Sep 17 00:00:00 2001
From: Tom Englund <tomenglund26@gmail.com>
Date: Fri, 7 Oct 2022 01:10:41 +0200
Subject: [PATCH 06/14] fix: delete transfer later

we have to delete transfer later to ensure we dont use after free when
transfering clipboard contents.
---
 xwl/selection_wl.h  | 2 +-
 xwl/selection_x11.h | 2 +-
 2 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/xwl/selection_wl.h b/xwl/selection_wl.h
index 71003b68b..725a3b2e4 100644
--- a/xwl/selection_wl.h
+++ b/xwl/selection_wl.h
@@ -88,7 +88,7 @@ void start_transfer_to_x11(Selection* sel, xcb_selection_request_event_t* event,
             Q_EMIT sel->data.qobject->transfer_finished(transfer->get_timestamp());
 
             // TODO(romangg): Serialize? see comment below.
-            delete transfer;
+            transfer->deleteLater();
             remove_all(sel->data.transfers.wl_to_x11, transfer);
             end_timeout_transfers_timer(sel);
         });
diff --git a/xwl/selection_x11.h b/xwl/selection_x11.h
index 3b89c4850..f77fcb8d1 100644
--- a/xwl/selection_x11.h
+++ b/xwl/selection_x11.h
@@ -73,7 +73,7 @@ void start_transfer_to_wayland(Selection* sel, xcb_atom_t target, qint32 fd)
     QObject::connect(
         transfer, &x11_to_wl_transfer::finished, sel->data.qobject.get(), [sel, transfer]() {
             Q_EMIT sel->data.qobject->transfer_finished(transfer->get_timestamp());
-            delete transfer;
+            transfer->deleteLater();
             remove_all(sel->data.transfers.x11_to_wl, transfer);
             end_timeout_transfers_timer(sel);
         });
-- 
GitLab


From 80430b61cf66dc9974739464be90fdb5b4b9e440 Mon Sep 17 00:00:00 2001
From: Tom Englund <tomenglund26@gmail.com>
Date: Tue, 11 Oct 2022 12:52:53 +0200
Subject: [PATCH 07/14] fix: check for null group

ensure we dont null pointer derefence on windows with a null group.
---
 render/effect/window_impl.h | 10 +++++++---
 1 file changed, 7 insertions(+), 3 deletions(-)

diff --git a/render/effect/window_impl.h b/render/effect/window_impl.h
index 2bd986916..fd46d25da 100644
--- a/render/effect/window_impl.h
+++ b/render/effect/window_impl.h
@@ -147,9 +147,13 @@ public:
     {
         using x11_win = typename space_t::x11_window;
         return std::visit(
-            overload{
-                [](x11_win* ref_win) -> EffectWindowGroup* { return ref_win->group->effect_group; },
-                [](auto&& /*ref_win*/) -> EffectWindowGroup* { return nullptr; }},
+            overload{[](x11_win* ref_win) -> EffectWindowGroup* {
+                         if (!ref_win->group) {
+                             return nullptr;
+                         }
+                         return ref_win->group->effect_group;
+                     },
+                     [](auto&& /*ref_win*/) -> EffectWindowGroup* { return nullptr; }},
             *window.ref_win);
     }
 
-- 
GitLab


From 3aa978ae507351fb6d3e84e3612f9912d00c38ec Mon Sep 17 00:00:00 2001
From: Tom Englund <tomenglund26@gmail.com>
Date: Tue, 11 Oct 2022 13:31:49 +0200
Subject: [PATCH 08/14] fix: avoid heap buffer overflow while casting

set transient types in the template classes directly and dont static
cast in x11_transient() template function.
---
 win/wayland/xwl_window.h |  7 +++----
 win/x11/transient.h      | 28 ++++++++++------------------
 win/x11/window.h         |  6 +++---
 3 files changed, 16 insertions(+), 25 deletions(-)

diff --git a/win/wayland/xwl_window.h b/win/wayland/xwl_window.h
index f090731d6..a73d88380 100644
--- a/win/wayland/xwl_window.h
+++ b/win/wayland/xwl_window.h
@@ -60,7 +60,7 @@ public:
     xwl_window(win::remnant remnant, Space& space)
         : qobject{std::make_unique<window_qobject>()}
         , meta{++space.window_id}
-        , transient{std::make_unique<win::transient<type>>(this)}
+        , transient{std::make_unique<x11::transient<type>>(this)}
         , remnant{std::move(remnant)}
         , motif_hints{space.atoms->motif_wm_hints}
         , space{space}
@@ -267,8 +267,7 @@ public:
 
     bool groupTransient() const
     {
-        return static_cast<x11::transient<xwl_window>*>(this->transient.get())->lead_id
-            == rootWindow();
+        return this->transient->lead_id == rootWindow();
     }
 
     type* findModal()
@@ -568,7 +567,7 @@ public:
     win::window_topology<output_t> topo;
     win::window_render_data<output_t> render_data;
 
-    std::unique_ptr<win::transient<type>> transient;
+    std::unique_ptr<x11::transient<type>> transient;
     std::unique_ptr<win::control<type>> control;
     std::unique_ptr<render_t> render;
     std::optional<win::remnant> remnant;
diff --git a/win/x11/transient.h b/win/x11/transient.h
index df88ab616..aac3df27d 100644
--- a/win/x11/transient.h
+++ b/win/x11/transient.h
@@ -93,12 +93,6 @@ public:
  - every window in the group : group()->members
 */
 
-template<typename Win>
-transient<Win>* x11_transient(Win* win)
-{
-    return static_cast<x11::transient<Win>*>(win->transient.get());
-}
-
 template<typename Win>
 base::x11::xcb::transient_for fetch_transient(Win* win)
 {
@@ -149,7 +143,7 @@ void update_group(Win* win, bool add)
         win->group->removeMember(win);
 
         for (auto member : win->group->members) {
-            if (x11_transient(win)->lead_id == member->xcb_windows.client) {
+            if (win->transient->lead_id == member->xcb_windows.client) {
                 if (!contains(member->transient->children, win)) {
                     member->transient->add_child(win);
                 }
@@ -187,8 +181,8 @@ void update_group(Win* win, bool add)
 template<typename Win>
 void clean_grouping(Win* win)
 {
-    x11_transient(win)->lead_id = XCB_WINDOW_NONE;
-    x11_transient(win)->original_lead_id = XCB_WINDOW_NONE;
+    win->transient->lead_id = XCB_WINDOW_NONE;
+    win->transient->original_lead_id = XCB_WINDOW_NONE;
 
     update_group(win, false);
 }
@@ -265,7 +259,7 @@ xcb_window_t verify_transient_for(Win* win, xcb_window_t new_transient_for, bool
             break;
         }
 
-        loop_pos = x11_transient(pos)->lead_id;
+        loop_pos = pos->transient->lead_id;
 
         if (--count == 0 || pos == win) {
             qCWarning(KWIN_CORE) << "Client " << win << " caused WM_TRANSIENT_FOR loop.";
@@ -280,7 +274,7 @@ xcb_window_t verify_transient_for(Win* win, xcb_window_t new_transient_for, bool
         new_transient_for = rootWindow();
     }
 
-    if (new_property_value != x11_transient(win)->original_lead_id) {
+    if (new_property_value != win->transient->original_lead_id) {
         base::x11::xcb::set_transient_for(win->xcb_windows.client, new_property_value);
     }
 
@@ -313,7 +307,7 @@ void check_active_modal(Space& space)
 template<typename Win>
 void change_client_leader_group(Win* win, decltype(win->group) group)
 {
-    auto lead_id = x11_transient(win)->lead_id;
+    auto lead_id = win->transient->lead_id;
     if (lead_id != XCB_WINDOW_NONE && lead_id != rootWindow()) {
         // Transients are in the group of their lead.
         return;
@@ -423,9 +417,7 @@ void check_group(Win* win, decltype(win->group) group)
 template<typename Win>
 void set_transient_lead(Win* win, xcb_window_t lead_id)
 {
-    auto x11_tr = x11_transient(win);
-
-    if (lead_id == x11_tr->lead_id) {
+    if (lead_id == win->transient->lead_id) {
         return;
     }
 
@@ -433,7 +425,7 @@ void set_transient_lead(Win* win, xcb_window_t lead_id)
         lead->transient->remove_child(win);
     }
 
-    x11_tr->lead_id = lead_id;
+    win->transient->lead_id = lead_id;
 
     if (lead_id != XCB_WINDOW_NONE && lead_id != rootWindow()) {
         auto lead = find_controlled_window<Win>(win->space, predicate_match::window, lead_id);
@@ -478,7 +470,7 @@ template<typename Win, typename CheckWin>
 void check_transient(Win& win, CheckWin& check)
 {
     auto id = static_cast<xcb_window_t>(check.xcb_windows.client);
-    if (x11_transient(&win)->original_lead_id != id) {
+    if (win.transient->original_lead_id != id) {
         return;
     }
     id = verify_transient_for(&win, id, true);
@@ -496,7 +488,7 @@ void read_transient_property(Win* win, base::x11::xcb::transient_for& transientF
         failed = true;
     }
 
-    x11_transient(win)->original_lead_id = lead_id;
+    win->transient->original_lead_id = lead_id;
     lead_id = verify_transient_for(win, lead_id, !failed);
 
     set_transient_lead(win, lead_id);
diff --git a/win/x11/window.h b/win/x11/window.h
index b6e731981..fc95333b3 100644
--- a/win/x11/window.h
+++ b/win/x11/window.h
@@ -66,7 +66,7 @@ public:
     window(win::remnant remnant, Space& space)
         : qobject{std::make_unique<window_qobject>()}
         , meta{++space.window_id}
-        , transient{std::make_unique<win::transient<type>>(this)}
+        , transient{std::make_unique<x11::transient<type>>(this)}
         , remnant{std::move(remnant)}
         , motif_hints{space.atoms->motif_wm_hints}
         , space{space}
@@ -293,7 +293,7 @@ public:
         //
         // [1] https://specifications.freedesktop.org/wm-spec/wm-spec-latest.html#idm45623487728576
         //
-        return static_cast<x11::transient<window>*>(this->transient.get())->lead_id == rootWindow();
+        return this->transient->lead_id == rootWindow();
     }
 
     type* findModal()
@@ -517,7 +517,7 @@ public:
     win::window_topology<output_t> topo;
     win::window_render_data<output_t> render_data;
 
-    std::unique_ptr<win::transient<type>> transient;
+    std::unique_ptr<x11::transient<type>> transient;
     std::unique_ptr<win::control<type>> control;
     std::unique_ptr<render_t> render;
     std::optional<win::remnant> remnant;
-- 
GitLab


From 283f82cd695a692d767ea133ea364d8c2ca59925 Mon Sep 17 00:00:00 2001
From: Tom Englund <tomenglund26@gmail.com>
Date: Wed, 12 Oct 2022 10:55:28 +0200
Subject: [PATCH 09/14] refactor: rearrange template functions

rearrange template functions so they are initialized in the correct
translation unit and order, found with -fpermissive and
fsanitize=undefined.
---
 win/x11/deco.h |  42 -------------
 win/x11/geo.h  | 160 +++++++++++++++++++++++++++++++------------------
 2 files changed, 101 insertions(+), 101 deletions(-)

diff --git a/win/x11/deco.h b/win/x11/deco.h
index 3254113d8..7c85b36bf 100644
--- a/win/x11/deco.h
+++ b/win/x11/deco.h
@@ -47,48 +47,6 @@ void layout_decoration_rects(Win* win, QRect& left, QRect& top, QRect& right, QR
                   rect.height() - top.height() - bottom.height());
 }
 
-template<typename Win>
-void detect_no_border(Win* win)
-{
-    if (win->is_shape) {
-        win->user_no_border = true;
-        win->app_no_border = true;
-        return;
-    }
-
-    switch (win->windowType()) {
-    case NET::Desktop:
-    case NET::Dock:
-    case NET::TopMenu:
-    case NET::Splash:
-    case NET::Notification:
-    case NET::OnScreenDisplay:
-    case NET::CriticalNotification:
-    case NET::AppletPopup:
-        win->user_no_border = true;
-        win->app_no_border = true;
-        break;
-    case NET::Unknown:
-    case NET::Normal:
-    case NET::Toolbar:
-    case NET::Menu:
-    case NET::Dialog:
-    case NET::Utility:
-        win->user_no_border = false;
-        break;
-    default:
-        abort();
-    }
-
-    // NET::Override is some strange beast without clear definition, usually
-    // just meaning "no_border", so let's treat it only as such flag, and ignore it as
-    // a window type otherwise (SUPPORTED_WINDOW_TYPES_MASK doesn't include it)
-    if (win->net_info->windowType(NET::OverrideMask) == NET::Override) {
-        win->user_no_border = true;
-        win->app_no_border = true;
-    }
-}
-
 template<typename Win>
 void set_frame_extents(Win* win)
 {
diff --git a/win/x11/geo.h b/win/x11/geo.h
index 0cdffc0e3..61f73d77e 100644
--- a/win/x11/geo.h
+++ b/win/x11/geo.h
@@ -82,6 +82,48 @@ bool geo_is_minimizable(Win const& win)
     return true;
 }
 
+template<typename Win>
+void detect_no_border(Win* win)
+{
+    if (win->is_shape) {
+        win->user_no_border = true;
+        win->app_no_border = true;
+        return;
+    }
+
+    switch (win->windowType()) {
+    case NET::Desktop:
+    case NET::Dock:
+    case NET::TopMenu:
+    case NET::Splash:
+    case NET::Notification:
+    case NET::OnScreenDisplay:
+    case NET::CriticalNotification:
+    case NET::AppletPopup:
+        win->user_no_border = true;
+        win->app_no_border = true;
+        break;
+    case NET::Unknown:
+    case NET::Normal:
+    case NET::Toolbar:
+    case NET::Menu:
+    case NET::Dialog:
+    case NET::Utility:
+        win->user_no_border = false;
+        break;
+    default:
+        abort();
+    }
+
+    // NET::Override is some strange beast without clear definition, usually
+    // just meaning "no_border", so let's treat it only as such flag, and ignore it as
+    // a window type otherwise (SUPPORTED_WINDOW_TYPES_MASK doesn't include it)
+    if (win->net_info->windowType(NET::OverrideMask) == NET::Override) {
+        win->user_no_border = true;
+        win->app_no_border = true;
+    }
+}
+
 template<typename Win>
 void update_shape(Win* win)
 {
@@ -172,6 +214,65 @@ void do_set_geometry(Win& win, QRect const& frame_geo)
     }
 }
 
+template<typename Win>
+bool update_server_geometry(Win* win, QRect const& frame_geo)
+{
+    // The render geometry defines the outer bounds of the window (that is with SSD or GTK CSD).
+    auto const outer_geo = frame_to_render_rect(win, frame_geo);
+
+    // Our wrapper geometry is in global coordinates the outer geometry excluding SSD.
+    // That equals the the client geometry.
+    auto const abs_wrapper_geo = outer_geo - frame_margins(win);
+    assert(abs_wrapper_geo == frame_to_client_rect(win, frame_geo));
+
+    // The wrapper is relatively positioned to the outer geometry.
+    auto const rel_wrapper_geo = abs_wrapper_geo.translated(-outer_geo.topLeft());
+
+    // Adding the original client frame extents does the same as frame_to_render_rect.
+    auto const old_outer_geo = win->synced_geometry.client + win->geo.update.original.deco_margins;
+
+    auto const old_abs_wrapper_geo = old_outer_geo - win->geo.update.original.deco_margins;
+
+    auto const old_rel_wrapper_geo = old_abs_wrapper_geo.translated(-old_outer_geo.topLeft());
+
+    win->synced_geometry.max_mode = win->geo.update.max_mode;
+    win->synced_geometry.fullscreen = win->geo.update.fullscreen;
+
+    if (old_outer_geo.size() != outer_geo.size() || old_rel_wrapper_geo != rel_wrapper_geo
+        || win->synced_geometry.init) {
+        win->xcb_windows.outer.set_geometry(outer_geo);
+        win->xcb_windows.wrapper.set_geometry(rel_wrapper_geo);
+        win->xcb_windows.client.resize(rel_wrapper_geo.size());
+
+        update_shape(win);
+        update_input_window(win, frame_geo);
+
+        win->synced_geometry.frame = frame_geo;
+        win->synced_geometry.client = abs_wrapper_geo;
+
+        return true;
+    }
+
+    if (win->control->move_resize.enabled) {
+        if (win->space.base.render->compositor->scene) {
+            // Defer the X server update until we leave this mode.
+            win->move_needs_server_update = true;
+        } else {
+            // sendSyntheticConfigureNotify() on finish shall be sufficient
+            win->xcb_windows.outer.move(outer_geo.topLeft());
+            win->synced_geometry.frame = frame_geo;
+            win->synced_geometry.client = abs_wrapper_geo;
+        }
+    } else {
+        win->xcb_windows.outer.move(outer_geo.topLeft());
+        win->synced_geometry.frame = frame_geo;
+        win->synced_geometry.client = abs_wrapper_geo;
+    }
+
+    win->xcb_windows.input.move(outer_geo.topLeft() + win->input_offset);
+    return false;
+}
+
 template<typename Win>
 void do_set_maximize_mode(Win& win, win::maximize_mode mode)
 {
@@ -1021,65 +1122,6 @@ void net_move_resize_window(Win* win, int flags, int x, int y, int width, int he
     configure_request(win, value_mask, x, y, width, height, gravity, true);
 }
 
-template<typename Win>
-bool update_server_geometry(Win* win, QRect const& frame_geo)
-{
-    // The render geometry defines the outer bounds of the window (that is with SSD or GTK CSD).
-    auto const outer_geo = frame_to_render_rect(win, frame_geo);
-
-    // Our wrapper geometry is in global coordinates the outer geometry excluding SSD.
-    // That equals the the client geometry.
-    auto const abs_wrapper_geo = outer_geo - frame_margins(win);
-    assert(abs_wrapper_geo == frame_to_client_rect(win, frame_geo));
-
-    // The wrapper is relatively positioned to the outer geometry.
-    auto const rel_wrapper_geo = abs_wrapper_geo.translated(-outer_geo.topLeft());
-
-    // Adding the original client frame extents does the same as frame_to_render_rect.
-    auto const old_outer_geo = win->synced_geometry.client + win->geo.update.original.deco_margins;
-
-    auto const old_abs_wrapper_geo = old_outer_geo - win->geo.update.original.deco_margins;
-
-    auto const old_rel_wrapper_geo = old_abs_wrapper_geo.translated(-old_outer_geo.topLeft());
-
-    win->synced_geometry.max_mode = win->geo.update.max_mode;
-    win->synced_geometry.fullscreen = win->geo.update.fullscreen;
-
-    if (old_outer_geo.size() != outer_geo.size() || old_rel_wrapper_geo != rel_wrapper_geo
-        || win->synced_geometry.init) {
-        win->xcb_windows.outer.set_geometry(outer_geo);
-        win->xcb_windows.wrapper.set_geometry(rel_wrapper_geo);
-        win->xcb_windows.client.resize(rel_wrapper_geo.size());
-
-        update_shape(win);
-        update_input_window(win, frame_geo);
-
-        win->synced_geometry.frame = frame_geo;
-        win->synced_geometry.client = abs_wrapper_geo;
-
-        return true;
-    }
-
-    if (win->control->move_resize.enabled) {
-        if (win->space.base.render->compositor->scene) {
-            // Defer the X server update until we leave this mode.
-            win->move_needs_server_update = true;
-        } else {
-            // sendSyntheticConfigureNotify() on finish shall be sufficient
-            win->xcb_windows.outer.move(outer_geo.topLeft());
-            win->synced_geometry.frame = frame_geo;
-            win->synced_geometry.client = abs_wrapper_geo;
-        }
-    } else {
-        win->xcb_windows.outer.move(outer_geo.topLeft());
-        win->synced_geometry.frame = frame_geo;
-        win->synced_geometry.client = abs_wrapper_geo;
-    }
-
-    win->xcb_windows.input.move(outer_geo.topLeft() + win->input_offset);
-    return false;
-}
-
 template<typename Win>
 void sync_geometry(Win* win, QRect const& frame_geo)
 {
-- 
GitLab


From f75ec04f811cc406d39349453fd4fb4c8c1a455d Mon Sep 17 00:00:00 2001
From: Tom Englund <tomenglund26@gmail.com>
Date: Fri, 14 Oct 2022 18:38:50 +0200
Subject: [PATCH 10/14] fix: ensure we dont leak file descriptors

ensure we dont leak file descriptors, close them on failure to open.
---
 win/wayland/xdg_activation.h | 13 ++++++++++++-
 1 file changed, 12 insertions(+), 1 deletion(-)

diff --git a/win/wayland/xdg_activation.h b/win/wayland/xdg_activation.h
index 796eef12e..03660c62e 100644
--- a/win/wayland/xdg_activation.h
+++ b/win/wayland/xdg_activation.h
@@ -12,10 +12,15 @@
 #include "win/stacking.h"
 
 #include <Wrapland/Server/xdg_activation_v1.h>
+#include <fcntl.h>
 #include <inttypes.h>
 #include <stdint.h>
 #include <stdio.h>
 #include <string.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <unistd.h>
+#define _POSIX_C_SOURCE 200809L
 
 namespace KWin::win::wayland
 {
@@ -31,10 +36,16 @@ inline bool generate_token(char out[token_strlen])
     uint64_t data[2];
 
     if (!urandom) {
-        if (!(urandom = fopen("/dev/urandom", "r"))) {
+        int fd = open("/dev/urandom", O_RDONLY | O_CLOEXEC);
+        if (fd < 0) {
             qCWarning(KWIN_CORE) << "Failed to open random device.";
             return false;
         }
+        if (!(urandom = fdopen(fd, "r"))) {
+            qCWarning(KWIN_CORE) << "Failed to fdopen.";
+            close(fd);
+            return false;
+        }
     }
     if (fread(data, sizeof(data), 1, urandom) != 1) {
         qCWarning(KWIN_CORE) << "Failed to read from random device.";
-- 
GitLab


From 92d11ff3e118176803c87abfe490e879be9b2670 Mon Sep 17 00:00:00 2001
From: Tom Englund <tomenglund26@gmail.com>
Date: Sun, 16 Oct 2022 03:41:57 +0200
Subject: [PATCH 11/14] fix: ensure input devices gets added early

add missing Q_EMIT of signals, and ensure we add dbus early enough to
catch devices being added before our session starts.
---
 input/platform.h | 8 ++++----
 main_wayland.cpp | 2 +-
 2 files changed, 5 insertions(+), 5 deletions(-)

diff --git a/input/platform.h b/input/platform.h
index 673e3d1ce..811ae5038 100644
--- a/input/platform.h
+++ b/input/platform.h
@@ -27,28 +27,28 @@ template<typename Keys, typename Platform>
 void platform_add_keyboard(Keys* keys, Platform& platform)
 {
     platform.keyboards.push_back(keys);
-    platform.qobject->keyboard_added(keys);
+    Q_EMIT platform.qobject->keyboard_added(keys);
 }
 
 template<typename Pointer, typename Platform>
 void platform_add_pointer(Pointer* pointer, Platform& platform)
 {
     platform.pointers.push_back(pointer);
-    platform.qobject->pointer_added(pointer);
+    Q_EMIT platform.qobject->pointer_added(pointer);
 }
 
 template<typename Switch, typename Platform>
 void platform_add_switch(Switch* switch_dev, Platform& platform)
 {
     platform.switches.push_back(switch_dev);
-    platform.qobject->switch_added(switch_dev);
+    Q_EMIT platform.qobject->switch_added(switch_dev);
 }
 
 template<typename Touch, typename Platform>
 void platform_add_touch(Touch* touch, Platform& platform)
 {
     platform.touchs.push_back(touch);
-    platform.qobject->touch_added(touch);
+    Q_EMIT platform.qobject->touch_added(touch);
 }
 
 template<typename Keys, typename Platform>
diff --git a/main_wayland.cpp b/main_wayland.cpp
index 3dd083fe7..76f69501e 100644
--- a/main_wayland.cpp
+++ b/main_wayland.cpp
@@ -210,6 +210,7 @@ void ApplicationWayland::start(OperationMode mode,
     session->take_control();
 
     base->input = std::make_unique<input::backend::wlroots::platform>(*base);
+    input::wayland::add_dbus(base->input.get());
     base->input->install_shortcuts();
 
     try {
@@ -227,7 +228,6 @@ void ApplicationWayland::start(OperationMode mode,
     }
 
     base->space = std::make_unique<base_t::space_t>(*base, base->server.get());
-    input::wayland::add_dbus(base->input.get());
     win::init_shortcuts(*base->space);
     base->space->scripting = std::make_unique<scripting::platform<base_t::space_t>>(*base->space);
 
-- 
GitLab


From 5d98467fd502627b9550b80e921221950d78f1d7 Mon Sep 17 00:00:00 2001
From: Tom Englund <tomenglund26@gmail.com>
Date: Wed, 19 Oct 2022 16:40:18 +0200
Subject: [PATCH 12/14] fix: ensure we dont modify container while looping

looping an container and modifying it, in this case with remove_all is
undefined behaviour. store a local copy and iterate it.
---
 win/session.h     | 5 +++--
 win/space_setup.h | 3 ++-
 2 files changed, 5 insertions(+), 3 deletions(-)

diff --git a/win/session.h b/win/session.h
index 426dbb522..fcaeacc41 100644
--- a/win/session.h
+++ b/win/session.h
@@ -284,11 +284,12 @@ session_info* take_session_info(Space& space, Win* c)
     QByteArray wmCommand = x11::get_wm_command(*c);
     auto const& resourceName = c->meta.wm_class.res_name;
     auto const& resourceClass = c->meta.wm_class.res_class;
+    auto session_copy = space.session;
 
     // First search ``session''
     if (!sessionId.isEmpty()) {
         // look for a real session managed client (algorithm suggested by ICCCM)
-        for (auto const& info : space.session) {
+        for (auto const& info : session_copy) {
             if (realInfo) {
                 break;
             }
@@ -309,7 +310,7 @@ session_info* take_session_info(Space& space, Win* c)
         }
     } else {
         // look for a sessioninfo with matching features.
-        for (auto const& info : space.session) {
+        for (auto const& info : session_copy) {
             if (realInfo) {
                 break;
             }
diff --git a/win/space_setup.h b/win/space_setup.h
index 75b0116bc..0ee3d2023 100644
--- a/win/space_setup.h
+++ b/win/space_setup.h
@@ -198,7 +198,8 @@ void clear_space(Space& space)
 
     if constexpr (requires { Space::internal_window_t; }) {
         using int_win = typename Space::internal_window_t;
-        for (auto const& window : space.windows) {
+        auto windows_copy = space.windows;
+        for (auto const& window : windows_copy) {
             std::visit(overload{[&](int_win* win) {
                            if (!win->remnant) {
                                win->destroyClient();
-- 
GitLab


From b04801f0455dd08d4d8637247f15b52800350b51 Mon Sep 17 00:00:00 2001
From: Tom Englund <tomenglund26@gmail.com>
Date: Fri, 21 Oct 2022 01:07:48 +0200
Subject: [PATCH 13/14] fix: make auto hide panels work again

screen_edger::handle calls showOnScreenEdge, which eventually calls
screen_edger::unreserve, which destroys the same edge. when showScreenOnEdge
returns, 'this' has been freed. using a singleshot timer allows
screen_edger::handle to return before the edge is destroyed.

Co-authored-by: Andreas Haratzis <andreas.haratzis@gmail.com>
---
 autotests/integration/plasma_surface_test.cpp |  1 +
 win/wayland/window.h                          | 16 ++++++++++------
 2 files changed, 11 insertions(+), 6 deletions(-)

diff --git a/autotests/integration/plasma_surface_test.cpp b/autotests/integration/plasma_surface_test.cpp
index 4a4c06d79..e70d2998f 100644
--- a/autotests/integration/plasma_surface_test.cpp
+++ b/autotests/integration/plasma_surface_test.cpp
@@ -403,6 +403,7 @@ void PlasmaSurfaceTest::testPanelWindowsCanCover()
     // trigger screenedge
     QFETCH(QPoint, triggerPoint);
     Test::cursor()->set_pos(triggerPoint);
+    QVERIFY(stackingOrderChangedSpy.wait());
     QCOMPARE(stackingOrderChangedSpy.count(), 1);
     stackingOrder = Test::app()->base.space->stacking.order.stack;
     QCOMPARE(stackingOrder.size(), 2);
diff --git a/win/wayland/window.h b/win/wayland/window.h
index 2c95df696..ee006f69b 100644
--- a/win/wayland/window.h
+++ b/win/wayland/window.h
@@ -863,13 +863,17 @@ public:
             return;
         }
 
-        hideClient(false);
-        raise_window(this->space, this);
+        // ShowOnScreenEdge can be called by an Edge, and hideClient could destroy the Edge
+        // Use the singleshot to avoid use-after-free
+        QTimer::singleShot(0, this->qobject.get(), [this]() {
+            hideClient(false);
+            raise_window(this->space, this);
 
-        if (plasma_shell_surface->panelBehavior()
-            == Wrapland::Server::PlasmaShellSurface::PanelBehavior::AutoHide) {
-            plasma_shell_surface->showAutoHidingPanel();
-        }
+            if (plasma_shell_surface->panelBehavior()
+                == Wrapland::Server::PlasmaShellSurface::PanelBehavior::AutoHide) {
+                plasma_shell_surface->showAutoHidingPanel();
+            }
+        });
     }
 
     void cancel_popup()
-- 
GitLab
