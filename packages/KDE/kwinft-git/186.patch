From e9417526f460caa3769e4a8ce9c06b950da5a13a Mon Sep 17 00:00:00 2001
From: Roman Gilg <subdiff@gmail.com>
Date: Thu, 24 Feb 2022 22:46:58 +0100
Subject: [PATCH 1/9] feat: create wlr_texture for SHM buffers

Make use of the wlr_texture type for SHM buffers by creating one and
getting the GLuint texture from that. Use wlr_texture_write_pixels for later
updates. This allows us to remove our own code for updating the texture.
---
 render/backend/wlroots/egl_texture.cpp  |   1 +
 render/backend/wlroots/egl_texture.h    |   6 +-
 render/backend/wlroots/texture_update.h | 143 +++++++++++-------------
 render/backend/wlroots/wlr_includes.h   |   1 +
 4 files changed, 72 insertions(+), 79 deletions(-)

diff --git a/render/backend/wlroots/egl_texture.cpp b/render/backend/wlroots/egl_texture.cpp
index 41a06b566..2f7fd1ba6 100644
--- a/render/backend/wlroots/egl_texture.cpp
+++ b/render/backend/wlroots/egl_texture.cpp
@@ -27,6 +27,7 @@ egl_texture::~egl_texture()
     if (m_image != EGL_NO_IMAGE_KHR) {
         eglDestroyImageKHR(m_backend->data.base.display, m_image);
     }
+    wlr_texture_destroy(native);
 }
 
 gl::backend* egl_texture::backend()
diff --git a/render/backend/wlroots/egl_texture.h b/render/backend/wlroots/egl_texture.h
index fa9595354..0a6a4825f 100644
--- a/render/backend/wlroots/egl_texture.h
+++ b/render/backend/wlroots/egl_texture.h
@@ -5,9 +5,9 @@
 */
 #pragma once
 
-#include "render/gl/texture.h"
+#include "wlr_includes.h"
 
-#include <epoxy/egl.h>
+#include "render/gl/texture.h"
 
 namespace KWin::render::backend::wlroots
 {
@@ -24,6 +24,8 @@ public:
     gl::backend* backend() override;
 
     gl::texture* q;
+
+    wlr_texture* native{nullptr};
     EGLImageKHR m_image{EGL_NO_IMAGE_KHR};
     bool m_hasSubImageUnpack{false};
 
diff --git a/render/backend/wlroots/texture_update.h b/render/backend/wlroots/texture_update.h
index 9fa013320..18a380b2f 100644
--- a/render/backend/wlroots/texture_update.h
+++ b/render/backend/wlroots/texture_update.h
@@ -5,6 +5,10 @@
 */
 #pragma once
 
+#include "platform.h"
+#include "wlr_includes.h"
+
+#include "render/extern/drm_fourcc.h"
 #include "render/gl/egl_dmabuf.h"
 #include "render/gl/kwin_eglext.h"
 #include "render/gl/window.h"
@@ -198,67 +202,6 @@ bool update_texture_from_egl(Texture& texture, Wrapland::Server::Buffer* buffer)
     return true;
 }
 
-template<typename Texture>
-void texture_subimage(Texture& texture,
-                      int scale,
-                      Wrapland::Server::ShmImage const& img,
-                      QRegion const& damage)
-{
-    auto prepareSubImage = [&](auto const& img, auto const& rect) {
-        texture.q->bind();
-        glPixelStorei(GL_UNPACK_ROW_LENGTH_EXT, img.stride() / (img.bpp() / 8));
-        glPixelStorei(GL_UNPACK_SKIP_PIXELS_EXT, rect.x());
-        glPixelStorei(GL_UNPACK_SKIP_ROWS_EXT, rect.y());
-    };
-    auto finalizseSubImage = [&]() {
-        glPixelStorei(GL_UNPACK_ROW_LENGTH_EXT, 0);
-        glPixelStorei(GL_UNPACK_SKIP_PIXELS_EXT, 0);
-        glPixelStorei(GL_UNPACK_SKIP_ROWS_EXT, 0);
-        texture.q->unbind();
-    };
-    auto getScaledRect = [scale](auto const& rect) {
-        return QRect(
-            rect.x() * scale, rect.y() * scale, rect.width() * scale, rect.height() * scale);
-    };
-
-    // Currently Wrapland only supports argb8888 and xrgb8888 formats, which both have the same Gl
-    // counter-part. If more formats are added in the future this needs to be checked.
-    auto const glFormat = GL_BGRA;
-
-    if (Texture::s_supportsARGB32
-        && (img.format() == Wrapland::Server::ShmImage::Format::argb8888)) {
-        for (auto const& rect : damage) {
-            auto const scaledRect = getScaledRect(rect);
-            prepareSubImage(img, scaledRect);
-            glTexSubImage2D(texture.m_target,
-                            0,
-                            scaledRect.x(),
-                            scaledRect.y(),
-                            scaledRect.width(),
-                            scaledRect.height(),
-                            glFormat,
-                            GL_UNSIGNED_BYTE,
-                            img.data());
-            finalizseSubImage();
-        }
-    } else {
-        for (auto const& rect : damage) {
-            auto scaledRect = getScaledRect(rect);
-            prepareSubImage(img, scaledRect);
-            glTexSubImage2D(texture.m_target,
-                            0,
-                            scaledRect.x(),
-                            scaledRect.y(),
-                            scaledRect.width(),
-                            scaledRect.height(),
-                            glFormat,
-                            GL_UNSIGNED_BYTE,
-                            img.data());
-            finalizseSubImage();
-        }
-    }
-}
-
 template<typename Texture>
 void texture_subimage_from_qimage(Texture& texture,
                                   int scale,
@@ -342,6 +285,59 @@ bool update_texture_from_dmabuf(Texture& texture, gl::egl_dmabuf_buffer* dmabuf)
     return true;
 }
 
+template<typename Texture>
+bool update_texture_from_data(Texture& texture,
+                              uint32_t format,
+                              uint32_t stride,
+                              QSize const& size,
+                              QRegion const& damage,
+                              int32_t scale,
+                              void const* data)
+{
+    if (size != texture.m_size) {
+        // First time update or size has changed.
+        wlr_texture_destroy(texture.native);
+        texture.native = wlr_texture_from_pixels(texture.m_backend->platform.renderer,
+                                                 format,
+                                                 stride,
+                                                 size.width(),
+                                                 size.height(),
+                                                 data);
+        if (!texture.native) {
+            return false;
+        }
+
+        wlr_gles2_texture_attribs tex_attribs;
+        wlr_gles2_texture_get_attribs(texture.native, &tex_attribs);
+
+        texture.m_texture = tex_attribs.tex;
+        texture.q->unbind();
+        texture.q->setYInverted(true);
+        texture.m_size = size;
+        texture.updateMatrix();
+
+        return true;
+    }
+
+    assert(size == texture.m_size);
+
+    for (auto const& rect : damage) {
+        auto const scaled_rect = QRect(
+            rect.x() * scale, rect.y() * scale, rect.width() * scale, rect.height() * scale);
+        wlr_texture_write_pixels(texture.native,
+                                 stride,
+                                 scaled_rect.width(),
+                                 scaled_rect.height(),
+                                 scaled_rect.x(),
+                                 scaled_rect.y(),
+                                 scaled_rect.x(),
+                                 scaled_rect.y(),
+                                 data);
+    }
+
+    return true;
+}
+
 template<typename Texture>
 bool update_texture_from_shm(Texture& texture,
                              render::wayland::buffer_win_integration const& buffer)
@@ -355,22 +351,15 @@ bool update_texture_from_shm(Texture& texture,
         return false;
     }
 
-    if (extbuf->size() != texture.m_size) {
-        // First time update or buffer size has changed.
-        return load_texture_from_image(texture, image->createQImage());
-    }
-
-    assert(extbuf->size() == texture.m_size);
-    auto const& damage = surface->trackedDamage();
-
-    if (texture.m_hasSubImageUnpack) {
-        texture_subimage(texture, surface->state().scale, image.value(), damage);
-    } else {
-        texture_subimage_from_qimage(
-            texture, surface->state().scale, image->createQImage(), damage);
-    }
-
-    return true;
+    return update_texture_from_data(texture,
+                                    image->format() == Wrapland::Server::ShmImage::Format::argb8888
+                                        ? DRM_FORMAT_ARGB8888
+                                        : DRM_FORMAT_XRGB8888,
+                                    image->stride(),
+                                    extbuf->size(),
+                                    surface->trackedDamage(),
+                                    surface->state().scale,
+                                    image->data());
 }
 
 template<typename Texture>
diff --git a/render/backend/wlroots/wlr_includes.h b/render/backend/wlroots/wlr_includes.h
index ff9eedfaa..512100f77 100644
--- a/render/backend/wlroots/wlr_includes.h
+++ b/render/backend/wlroots/wlr_includes.h
@@ -33,5 +33,6 @@ extern "C" {
 #include <wlr/render/egl.h>
 #include <wlr/render/gles2.h>
 #include <wlr/render/pixman.h>
+#include <wlr/render/wlr_texture.h>
 #undef static
 }
-- 
GitLab


From fb5c8892b3f3156f961d3a04611a4c715841c003 Mon Sep 17 00:00:00 2001
From: Roman Gilg <subdiff@gmail.com>
Date: Fri, 25 Feb 2022 00:18:30 +0100
Subject: [PATCH 2/9] feat: create wlr_texture for internal images

Internal image objects can be composited by processing them with the same
wlroots API we use for SHM buffers, namely that's by creating a wlr_texture
from an image and writing data with wlr_texture_write_pixels on updates.
---
 render/backend/wlroots/texture_update.h | 141 ++++++------------------
 1 file changed, 32 insertions(+), 109 deletions(-)

diff --git a/render/backend/wlroots/texture_update.h b/render/backend/wlroots/texture_update.h
index 18a380b2f..691fb48ef 100644
--- a/render/backend/wlroots/texture_update.h
+++ b/render/backend/wlroots/texture_update.h
@@ -77,65 +77,6 @@ void attach_buffer_to_khr_image(Texture& texture, Wrapland::Server::Buffer* buff
     texture.q->setYInverted(yInverted);
 }
 
-template<typename Texture>
-bool load_texture_from_image(Texture& texture, QImage const& image)
-{
-    if (image.isNull()) {
-        return false;
-    }
-
-    glGenTextures(1, &texture.m_texture);
-    texture.q->setFilter(GL_LINEAR);
-    texture.q->setWrapMode(GL_CLAMP_TO_EDGE);
-
-    auto const& size = image.size();
-    texture.q->bind();
-
-    GLenum format{0};
-    switch (image.format()) {
-    case QImage::Format_ARGB32:
-    case QImage::Format_ARGB32_Premultiplied:
-        format = GL_RGBA8;
-        break;
-    case QImage::Format_RGB32:
-        format = GL_RGB8;
-        break;
-    default:
-        return false;
-    }
-
-    if (Texture::s_supportsARGB32 && format == GL_RGBA8) {
-        auto const im = image.convertToFormat(QImage::Format_ARGB32_Premultiplied);
-        glTexImage2D(texture.m_target,
-                     0,
-                     GL_BGRA_EXT,
-                     im.width(),
-                     im.height(),
-                     0,
-                     GL_BGRA_EXT,
-                     GL_UNSIGNED_BYTE,
-                     im.bits());
-    } else {
-        auto const im = image.convertToFormat(QImage::Format_RGBA8888_Premultiplied);
-        glTexImage2D(texture.m_target,
-                     0,
-                     GL_RGBA,
-                     im.width(),
-                     im.height(),
-                     0,
-                     GL_RGBA,
-                     GL_UNSIGNED_BYTE,
-                     im.bits());
-    }
-
-    texture.q->unbind();
-    texture.q->setYInverted(true);
-    texture.m_size = size;
-    texture.updateMatrix();
-
-    return true;
-}
-
 template<typename Texture>
 bool update_texture_from_fbo(Texture& texture, std::shared_ptr<QOpenGLFramebufferObject> const& fbo)
 {
@@ -165,13 +106,40 @@ bool update_texture_from_internal_image_object(
         return false;
     }
 
-    if (texture.m_size != image.size()) {
-        glDeleteTextures(1, &texture.m_texture);
-        return load_texture_from_image(texture, image);
+    uint32_t format;
+
+    // TODO(romangg): The Qt pixel formats depend on the endianness while DRM is always LE. So on BE
+    //                machines QImage::Format_RGBA8888_Premultiplied would instead correspond to
+    //                DRM_FORMAT_RGBX8888, see [1]. But at the same time Format_ARGB32_Premultiplied
+    //                does not seem to be influenced. Need to test this on an actual BE machine to
+    //                be sure.
+    // [1] https://gitlab.freedesktop.org/wlroots/wlroots/-/merge_requests/3464#note_1277281
+    switch (image.format()) {
+    case QImage::Format_ARGB32:
+    case QImage::Format_ARGB32_Premultiplied:
+        format = DRM_FORMAT_ARGB8888;
+        break;
+    case QImage::Format_RGB32:
+        format = DRM_FORMAT_XBGR8888;
+        break;
+    default:
+        return false;
     }
 
-    texture_subimage_from_qimage(texture, image.devicePixelRatio(), image, buffer.damage());
-    return true;
+    QImage conv_image;
+    if (Texture::s_supportsARGB32 && format == DRM_FORMAT_ARGB8888) {
+        conv_image = image.convertToFormat(QImage::Format_ARGB32_Premultiplied);
+    } else {
+        conv_image = image.convertToFormat(QImage::Format_RGBA8888_Premultiplied);
+    }
+
+    return update_texture_from_data(texture,
+                                    format,
+                                    image.bytesPerLine(),
+                                    image.size(),
+                                    buffer.buffer.toplevel()->damage_region,
+                                    image.devicePixelRatio(),
+                                    conv_image.bits());
 }
 
 template<typename Texture>
@@ -202,51 +170,6 @@ bool update_texture_from_egl(Texture& texture, Wrapland::Server::Buffer* buffer)
     return true;
 }
 
-template<typename Texture>
-void texture_subimage_from_qimage(Texture& texture,
-                                  int scale,
-                                  QImage const& image,
-                                  QRegion const& damage)
-{
-    texture.q->bind();
-
-    if (Texture::s_supportsARGB32
-        && (image.format() == QImage::Format_ARGB32
-            || image.format() == QImage::Format_ARGB32_Premultiplied)) {
-        auto const im = image.convertToFormat(QImage::Format_ARGB32_Premultiplied);
-        for (auto const& rect : damage) {
-            auto scaledRect = QRect(
-                rect.x() * scale, rect.y() * scale, rect.width() * scale, rect.height() * scale);
-            glTexSubImage2D(texture.m_target,
-                            0,
-                            scaledRect.x(),
-                            scaledRect.y(),
-                            scaledRect.width(),
-                            scaledRect.height(),
-                            GL_BGRA_EXT,
-                            GL_UNSIGNED_BYTE,
-                            im.copy(scaledRect).constBits());
-        }
-    } else {
-        auto const im = image.convertToFormat(QImage::Format_RGBA8888_Premultiplied);
-        for (auto const& rect : damage) {
-            auto scaledRect = QRect(
-                rect.x() * scale, rect.y() * scale, rect.width() * scale, rect.height() * scale);
-            glTexSubImage2D(texture.m_target,
-                            0,
-                            scaledRect.x(),
-                            scaledRect.y(),
-                            scaledRect.width(),
-                            scaledRect.height(),
-                            GL_RGBA,
-                            GL_UNSIGNED_BYTE,
-                            im.copy(scaledRect).constBits());
-        }
-    }
-
-    texture.q->unbind();
-}
-
 template<typename Texture>
 bool update_texture_from_dmabuf(Texture& texture, gl::egl_dmabuf_buffer* dmabuf)
 {
-- 
GitLab


From 0894a1dcc7b0e5fca62af2b73d881ffd8b791baa Mon Sep 17 00:00:00 2001
From: Roman Gilg <subdiff@gmail.com>
Date: Fri, 25 Feb 2022 00:31:35 +0100
Subject: [PATCH 3/9] feat: create wlr_texture for dmabuf buffers

Make use of the wlr_texture type for dmabuf buffers by creating one and
getting the GLuint texture from that.
---
 render/backend/wlroots/texture_update.h | 45 ++++++++++++++++---------
 1 file changed, 29 insertions(+), 16 deletions(-)

diff --git a/render/backend/wlroots/texture_update.h b/render/backend/wlroots/texture_update.h
index 691fb48ef..4b01d7a81 100644
--- a/render/backend/wlroots/texture_update.h
+++ b/render/backend/wlroots/texture_update.h
@@ -176,31 +176,44 @@ bool update_texture_from_dmabuf(Texture& texture, gl::egl_dmabuf_buffer* dmabuf)
     assert(dmabuf);
     assert(texture.m_image == EGL_NO_IMAGE_KHR);
 
-    if (dmabuf->images().empty() || dmabuf->images().at(0) == EGL_NO_IMAGE_KHR) {
-        qCritical(KWIN_WL) << "Invalid dmabuf-based wl_buffer";
-        texture.q->discard();
-        return false;
-    }
+    if (texture.m_size != dmabuf->size) {
+        // First time update or size has changed.
+        // TODO(romangg): Should we also recreate the texture on other param changes?
+        wlr_dmabuf_attributes dmabuf_attribs;
+        auto const& planes = dmabuf->planes;
+        dmabuf_attribs.width = dmabuf->size.width();
+        dmabuf_attribs.height = dmabuf->size.height();
+        dmabuf_attribs.format = dmabuf->format;
+        dmabuf_attribs.modifier = dmabuf->modifier;
+        dmabuf_attribs.n_planes = planes.size();
+
+        auto planes_count = std::min(planes.size(), static_cast<size_t>(WLR_DMABUF_MAX_PLANES));
+        for (size_t i = 0; i < planes_count; i++) {
+            auto plane = planes.at(i);
+            dmabuf_attribs.offset[i] = plane.offset;
+            dmabuf_attribs.stride[i] = plane.stride;
+            dmabuf_attribs.fd[i] = plane.fd;
+        }
 
-    texture.q->bind();
+        wlr_texture_destroy(texture.native);
+        texture.native
+            = wlr_texture_from_dmabuf(texture.m_backend->platform.renderer, &dmabuf_attribs);
+        if (!texture.native) {
+            return false;
+        }
 
-    if (!texture.m_texture) {
-        // Recreate the texture.
-        glGenTextures(1, &texture.m_texture);
+        wlr_gles2_texture_attribs tex_attribs;
+        wlr_gles2_texture_get_attribs(texture.native, &tex_attribs);
 
+        texture.m_texture = tex_attribs.tex;
         texture.q->setWrapMode(GL_CLAMP_TO_EDGE);
         texture.q->setFilter(GL_NEAREST);
-    }
-
-    // TODO
-    glEGLImageTargetTexture2DOES(GL_TEXTURE_2D, (GLeglImageOES)dmabuf->images().at(0));
-    texture.q->unbind();
-
-    if (texture.m_size != dmabuf->size) {
         texture.m_size = dmabuf->size;
         texture.updateMatrix();
     }
 
+    assert(texture.native);
+
     // The origin in a dmabuf-buffer is at the upper-left corner, so the meaning
     // of Y-inverted is the inverse of OpenGL.
     texture.q->setYInverted(!(dmabuf->flags & Wrapland::Server::linux_dmabuf_flag_v1::y_inverted));
-- 
GitLab


From 794a9cfc45cef35c2895f5eee80d52931754e0fe Mon Sep 17 00:00:00 2001
From: Roman Gilg <subdiff@gmail.com>
Date: Fri, 25 Feb 2022 01:15:14 +0100
Subject: [PATCH 4/9] refactor: omit dmabuf image creation

We now let wlroots handle the processing of client dmabuf buffers.
---
 render/gl/egl_dmabuf.cpp | 204 +--------------------------------------
 render/gl/egl_dmabuf.h   |  40 +-------
 2 files changed, 6 insertions(+), 238 deletions(-)

diff --git a/render/gl/egl_dmabuf.cpp b/render/gl/egl_dmabuf.cpp
index f6871818d..09f958387 100644
--- a/render/gl/egl_dmabuf.cpp
+++ b/render/gl/egl_dmabuf.cpp
@@ -32,161 +32,16 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 namespace KWin::render::gl
 {
 
-struct YuvPlane {
-    int widthDivisor = 0;
-    int heightDivisor = 0;
-    uint32_t format = 0;
-    int planeIndex = 0;
-};
-
-struct YuvFormat {
-    uint32_t format = 0;
-    int inputPlanes = 0;
-    int outputPlanes = 0;
-    int textureType = 0;
-    struct YuvPlane planes[3];
-};
-
-YuvFormat yuvFormats[]
-    = {{DRM_FORMAT_YUYV,
-        1,
-        2,
-        EGL_TEXTURE_Y_XUXV_WL,
-        {{1, 1, DRM_FORMAT_GR88, 0}, {2, 1, DRM_FORMAT_ARGB8888, 0}}},
-       {DRM_FORMAT_NV12,
-        2,
-        2,
-        EGL_TEXTURE_Y_UV_WL,
-        {{1, 1, DRM_FORMAT_R8, 0}, {2, 2, DRM_FORMAT_GR88, 1}}},
-       {DRM_FORMAT_YUV420,
-        3,
-        3,
-        EGL_TEXTURE_Y_U_V_WL,
-        {{1, 1, DRM_FORMAT_R8, 0}, {2, 2, DRM_FORMAT_R8, 1}, {2, 2, DRM_FORMAT_R8, 2}}},
-       {DRM_FORMAT_YUV444,
-        3,
-        3,
-        EGL_TEXTURE_Y_U_V_WL,
-        {{1, 1, DRM_FORMAT_R8, 0}, {1, 1, DRM_FORMAT_R8, 1}, {1, 1, DRM_FORMAT_R8, 2}}}};
-
-egl_dmabuf_buffer::egl_dmabuf_buffer(EGLImage image,
-                                     std::vector<Plane> planes,
-                                     uint32_t format,
-                                     uint64_t modifier,
-                                     const QSize& size,
-                                     Flags flags,
-                                     egl_dmabuf* interfaceImpl)
-    : egl_dmabuf_buffer(std::move(planes), format, modifier, size, flags, interfaceImpl)
-{
-    m_importType = ImportType::Direct;
-    addImage(image);
-}
+using Plane = Wrapland::Server::linux_dmabuf_plane_v1;
+using Flags = Wrapland::Server::linux_dmabuf_flags_v1;
 
 egl_dmabuf_buffer::egl_dmabuf_buffer(std::vector<Plane> planes,
                                      uint32_t format,
                                      uint64_t modifier,
                                      const QSize& size,
-                                     Flags flags,
-                                     egl_dmabuf* interfaceImpl)
+                                     Flags flags)
     : Wrapland::Server::linux_dmabuf_buffer_v1(std::move(planes), format, modifier, size, flags)
-    , m_interfaceImpl(interfaceImpl)
-{
-    m_importType = ImportType::Conversion;
-}
-
-egl_dmabuf_buffer::~egl_dmabuf_buffer()
-{
-    removeImages();
-}
-
-std::vector<EGLImage> const& egl_dmabuf_buffer::images() const
 {
-    return m_images;
-}
-
-void egl_dmabuf_buffer::addImage(EGLImage image)
-{
-    m_images.push_back(image);
-}
-
-void egl_dmabuf_buffer::removeImages()
-{
-    if (m_interfaceImpl) {
-        for (auto image : m_images) {
-            m_interfaceImpl->data.base.destroy_image_khr(m_interfaceImpl->data.base.display, image);
-        }
-    }
-    m_images.clear();
-}
-
-using Plane = Wrapland::Server::linux_dmabuf_plane_v1;
-using Flags = Wrapland::Server::linux_dmabuf_flags_v1;
-
-EGLImage egl_dmabuf::createImage(std::vector<Plane> const& planes,
-                                 uint32_t format,
-                                 uint64_t modifier,
-                                 const QSize& size)
-{
-    const bool hasModifiers
-        = eglQueryDmaBufModifiersEXT != nullptr && modifier != DRM_FORMAT_MOD_INVALID;
-
-    QVector<EGLint> attribs;
-    attribs << EGL_WIDTH << size.width() << EGL_HEIGHT << size.height() << EGL_LINUX_DRM_FOURCC_EXT
-            << EGLint(format)
-
-            << EGL_DMA_BUF_PLANE0_FD_EXT << planes[0].fd << EGL_DMA_BUF_PLANE0_OFFSET_EXT
-            << EGLint(planes[0].offset) << EGL_DMA_BUF_PLANE0_PITCH_EXT << EGLint(planes[0].stride);
-
-    if (hasModifiers) {
-        attribs << EGL_DMA_BUF_PLANE0_MODIFIER_LO_EXT << EGLint(modifier & 0xffffffff)
-                << EGL_DMA_BUF_PLANE0_MODIFIER_HI_EXT << EGLint(modifier >> 32);
-    }
-
-    if (planes.size() > 1) {
-        attribs << EGL_DMA_BUF_PLANE1_FD_EXT << planes[1].fd << EGL_DMA_BUF_PLANE1_OFFSET_EXT
-                << EGLint(planes[1].offset) << EGL_DMA_BUF_PLANE1_PITCH_EXT
-                << EGLint(planes[1].stride);
-
-        if (hasModifiers) {
-            attribs << EGL_DMA_BUF_PLANE1_MODIFIER_LO_EXT << EGLint(modifier & 0xffffffff)
-                    << EGL_DMA_BUF_PLANE1_MODIFIER_HI_EXT << EGLint(modifier >> 32);
-        }
-    }
-
-    if (planes.size() > 2) {
-        attribs << EGL_DMA_BUF_PLANE2_FD_EXT << planes[2].fd << EGL_DMA_BUF_PLANE2_OFFSET_EXT
-                << EGLint(planes[2].offset) << EGL_DMA_BUF_PLANE2_PITCH_EXT
-                << EGLint(planes[2].stride);
-
-        if (hasModifiers) {
-            attribs << EGL_DMA_BUF_PLANE2_MODIFIER_LO_EXT << EGLint(modifier & 0xffffffff)
-                    << EGL_DMA_BUF_PLANE2_MODIFIER_HI_EXT << EGLint(modifier >> 32);
-        }
-    }
-
-    if (eglQueryDmaBufModifiersEXT != nullptr && planes.size() > 3) {
-        attribs << EGL_DMA_BUF_PLANE3_FD_EXT << planes[3].fd << EGL_DMA_BUF_PLANE3_OFFSET_EXT
-                << EGLint(planes[3].offset) << EGL_DMA_BUF_PLANE3_PITCH_EXT
-                << EGLint(planes[3].stride);
-
-        if (hasModifiers) {
-            attribs << EGL_DMA_BUF_PLANE3_MODIFIER_LO_EXT << EGLint(modifier & 0xffffffff)
-                    << EGL_DMA_BUF_PLANE3_MODIFIER_HI_EXT << EGLint(modifier >> 32);
-        }
-    }
-
-    attribs << EGL_NONE;
-
-    auto image = data.base.create_image_khr(data.base.display,
-                                            EGL_NO_CONTEXT,
-                                            EGL_LINUX_DMA_BUF_EXT,
-                                            (EGLClientBuffer) nullptr,
-                                            attribs.data());
-    if (image == EGL_NO_IMAGE_KHR) {
-        return nullptr;
-    }
-
-    return image;
 }
 
 std::unique_ptr<Wrapland::Server::linux_dmabuf_buffer_v1>
@@ -197,58 +52,7 @@ egl_dmabuf::import_buffer(std::vector<Plane> const& planes,
                           Flags flags)
 {
     Q_ASSERT(planes.size() > 0);
-
-    // Try first to import as a single image
-    if (auto* img = createImage(planes, format, modifier, size)) {
-        return std::make_unique<egl_dmabuf_buffer>(
-            img, planes, format, modifier, size, flags, this);
-    }
-
-    // TODO: to enable this we must be able to store multiple textures per window pixmap
-    //       and when on window draw do yuv to rgb transformation per shader (see Weston)
-    //    // not a single image, try yuv import
-    //    return yuvImport(planes, format, size, flags);
-
-    return nullptr;
-}
-
-Wrapland::Server::linux_dmabuf_buffer_v1* egl_dmabuf::yuvImport(std::vector<Plane> const& planes,
-                                                                uint32_t format,
-                                                                uint64_t modifier,
-                                                                const QSize& size,
-                                                                Flags flags)
-{
-    YuvFormat yuvFormat;
-    for (YuvFormat f : yuvFormats) {
-        if (f.format == format) {
-            yuvFormat = f;
-            break;
-        }
-    }
-    if (yuvFormat.format == 0) {
-        return nullptr;
-    }
-    if (static_cast<int>(planes.size()) != yuvFormat.inputPlanes) {
-        return nullptr;
-    }
-
-    auto* buf = new egl_dmabuf_buffer(planes, format, modifier, size, flags, this);
-
-    for (int i = 0; i < yuvFormat.outputPlanes; i++) {
-        int planeIndex = yuvFormat.planes[i].planeIndex;
-        Plane plane{planes[planeIndex].fd, planes[planeIndex].offset, planes[planeIndex].stride};
-        const auto planeFormat = yuvFormat.planes[i].format;
-        const auto planeSize = QSize(size.width() / yuvFormat.planes[i].widthDivisor,
-                                     size.height() / yuvFormat.planes[i].heightDivisor);
-        auto* image = createImage(std::vector<Plane>(1, plane), planeFormat, modifier, planeSize);
-        if (!image) {
-            delete buf;
-            return nullptr;
-        }
-        buf->addImage(image);
-    }
-    // TODO: add buf import properties
-    return buf;
+    return std::make_unique<egl_dmabuf_buffer>(planes, format, modifier, size, flags);
 }
 
 egl_dmabuf::egl_dmabuf(egl_dmabuf_data const& data)
diff --git a/render/gl/egl_dmabuf.h b/render/gl/egl_dmabuf.h
index 9b1551228..a7624adbb 100644
--- a/render/gl/egl_dmabuf.h
+++ b/render/gl/egl_dmabuf.h
@@ -34,37 +34,11 @@ class egl_dmabuf;
 class egl_dmabuf_buffer : public Wrapland::Server::linux_dmabuf_buffer_v1
 {
 public:
-    using Plane = Wrapland::Server::linux_dmabuf_plane_v1;
-    using Flags = Wrapland::Server::linux_dmabuf_flags_v1;
-
-    enum class ImportType { Direct, Conversion };
-
-    egl_dmabuf_buffer(EGLImage image,
-                      std::vector<Plane> planes,
+    egl_dmabuf_buffer(std::vector<Wrapland::Server::linux_dmabuf_plane_v1> planes,
                       uint32_t format,
                       uint64_t modifier,
                       const QSize& size,
-                      Flags flags,
-                      egl_dmabuf* interfaceImpl);
-
-    egl_dmabuf_buffer(std::vector<Plane> planes,
-                      uint32_t format,
-                      uint64_t modifier,
-                      const QSize& size,
-                      Flags flags,
-                      egl_dmabuf* interfaceImpl);
-
-    ~egl_dmabuf_buffer() override;
-
-    void addImage(EGLImage image);
-    void removeImages();
-
-    std::vector<EGLImage> const& images() const;
-
-private:
-    std::vector<EGLImage> m_images;
-    egl_dmabuf* m_interfaceImpl;
-    ImportType m_importType;
+                      Wrapland::Server::linux_dmabuf_flags_v1 flags);
 };
 
 struct egl_dmabuf_data {
@@ -101,16 +75,6 @@ public:
     egl_dmabuf_data data;
 
 private:
-    EGLImage createImage(std::vector<Plane> const& planes,
-                         uint32_t format,
-                         uint64_t modifier,
-                         const QSize& size);
-
-    Wrapland::Server::linux_dmabuf_buffer_v1* yuvImport(std::vector<Plane> const& planes,
-                                                        uint32_t format,
-                                                        uint64_t modifier,
-                                                        const QSize& size,
-                                                        Flags flags);
     QVector<uint32_t> queryFormats();
     void setSupportedFormatsAndModifiers();
 
-- 
GitLab


From b68d7e8c4a9c0ff4c2302007b5ad4338b78f44c2 Mon Sep 17 00:00:00 2001
From: Roman Gilg <subdiff@gmail.com>
Date: Fri, 25 Feb 2022 12:52:38 +0100
Subject: [PATCH 5/9] feat: get supported dmabuf formats from wlroots

Replace our own logic to find supported formats and modifiers with a call to
wlroots. This enables us to advertise support for multi-plane formats and all
modifiers that wlroots supports.
---
 render/backend/wlroots/egl_backend.cpp |  4 ++
 render/backend/wlroots/wlr_helpers.h   | 22 ++++++
 render/gl/egl_dmabuf.cpp               | 97 --------------------------
 render/gl/egl_dmabuf.h                 |  6 --
 4 files changed, 26 insertions(+), 103 deletions(-)

diff --git a/render/backend/wlroots/egl_backend.cpp b/render/backend/wlroots/egl_backend.cpp
index 7fe0c9e56..98e3969aa 100644
--- a/render/backend/wlroots/egl_backend.cpp
+++ b/render/backend/wlroots/egl_backend.cpp
@@ -96,6 +96,10 @@ egl_backend::egl_backend(wlroots::platform& platform)
     gl::init_gl(EglPlatformInterface, get_proc_address);
     gl::init_buffer_age(*this);
     wayland::init_egl(*this, data);
+
+    auto formats_set = wlr_renderer_get_dmabuf_texture_formats(platform.renderer);
+    auto formats_map = get_drm_formats<Wrapland::Server::drm_format>(formats_set);
+    waylandServer()->linux_dmabuf()->set_formats(formats_map);
 }
 
 egl_backend::~egl_backend()
diff --git a/render/backend/wlroots/wlr_helpers.h b/render/backend/wlroots/wlr_helpers.h
index 4fae81d8b..4f561fdbe 100644
--- a/render/backend/wlroots/wlr_helpers.h
+++ b/render/backend/wlroots/wlr_helpers.h
@@ -55,4 +55,26 @@ pixman_region32_t create_pixman_region(Region const& src_region)
     return region;
 }
 
+template<typename Format>
+std::vector<Format> get_drm_formats(wlr_drm_format_set const* set)
+{
+    if (!set) {
+        return {};
+    }
+
+    std::vector<Format> formats;
+
+    for (size_t fmt_index = 0; fmt_index < set->len; fmt_index++) {
+        auto fmt = set->formats[fmt_index];
+        Format format;
+        format.format = fmt->format;
+        for (size_t mod_index = 0; mod_index < fmt->len; mod_index++) {
+            format.modifiers.insert(fmt->modifiers[mod_index]);
+        }
+        formats.push_back(std::move(format));
+    }
+
+    return formats;
+}
+
 }
diff --git a/render/gl/egl_dmabuf.cpp b/render/gl/egl_dmabuf.cpp
index 09f958387..1c5d89d9e 100644
--- a/render/gl/egl_dmabuf.cpp
+++ b/render/gl/egl_dmabuf.cpp
@@ -66,103 +66,6 @@ egl_dmabuf::egl_dmabuf(egl_dmabuf_data const& data)
         [this](auto const& planes, auto format, auto modifier, auto const& size, auto flags) {
             return import_buffer(planes, format, modifier, size, flags);
         });
-
-    setSupportedFormatsAndModifiers();
-}
-
-const uint32_t s_multiPlaneFormats[] = {
-    DRM_FORMAT_XRGB8888_A8, DRM_FORMAT_XBGR8888_A8, DRM_FORMAT_RGBX8888_A8, DRM_FORMAT_BGRX8888_A8,
-    DRM_FORMAT_RGB888_A8,   DRM_FORMAT_BGR888_A8,   DRM_FORMAT_RGB565_A8,   DRM_FORMAT_BGR565_A8,
-
-    DRM_FORMAT_NV12,        DRM_FORMAT_NV21,        DRM_FORMAT_NV16,        DRM_FORMAT_NV61,
-    DRM_FORMAT_NV24,        DRM_FORMAT_NV42,
-
-    DRM_FORMAT_YUV410,      DRM_FORMAT_YVU410,      DRM_FORMAT_YUV411,      DRM_FORMAT_YVU411,
-    DRM_FORMAT_YUV420,      DRM_FORMAT_YVU420,      DRM_FORMAT_YUV422,      DRM_FORMAT_YVU422,
-    DRM_FORMAT_YUV444,      DRM_FORMAT_YVU444};
-
-// Following formats are in Weston as a fallback. XYUV8888 is the only one not in our drm_fourcc.h
-// Weston does define it itself for older kernels. But for now just use the other ones.
-uint32_t const s_fallbackFormats[] = {
-    DRM_FORMAT_ARGB8888,
-    DRM_FORMAT_XRGB8888,
-    DRM_FORMAT_YUYV,
-    DRM_FORMAT_NV12,
-    DRM_FORMAT_YUV420,
-    DRM_FORMAT_YUV444,
-    //    DRM_FORMAT_XYUV8888,
-};
-
-void filterFormatsWithMultiplePlanes(QVector<uint32_t>& formats)
-{
-    QVector<uint32_t>::iterator it = formats.begin();
-    while (it != formats.end()) {
-        for (auto linuxFormat : s_multiPlaneFormats) {
-            if (*it == linuxFormat) {
-                qDebug() << "Filter multi-plane format" << *it;
-                it = formats.erase(it);
-                it--;
-                break;
-            }
-        }
-        it++;
-    }
-}
-
-QVector<uint32_t> egl_dmabuf::queryFormats()
-{
-    if (!eglQueryDmaBufFormatsEXT) {
-        return QVector<uint32_t>();
-    }
-
-    EGLint count = 0;
-    EGLBoolean success = eglQueryDmaBufFormatsEXT(data.base.display, 0, nullptr, &count);
-    if (!success || count == 0) {
-        return QVector<uint32_t>();
-    }
-
-    QVector<uint32_t> formats(count);
-    if (!eglQueryDmaBufFormatsEXT(
-            data.base.display, count, reinterpret_cast<EGLint*>(formats.data()), &count)) {
-        return QVector<uint32_t>();
-    }
-    return formats;
-}
-
-void egl_dmabuf::setSupportedFormatsAndModifiers()
-{
-    auto formats = queryFormats();
-    if (formats.count() == 0) {
-        for (auto format : s_fallbackFormats) {
-            formats << format;
-        }
-    }
-    filterFormatsWithMultiplePlanes(formats);
-
-    std::vector<Wrapland::Server::drm_format> drm_formats;
-
-    for (auto format : qAsConst(formats)) {
-        Wrapland::Server::drm_format drm_format;
-        drm_format.format = format;
-        if (eglQueryDmaBufModifiersEXT != nullptr) {
-            EGLint count = 0;
-            EGLBoolean success = eglQueryDmaBufModifiersEXT(
-                data.base.display, format, 0, nullptr, nullptr, &count);
-
-            if (success && count > 0) {
-                QVector<uint64_t> modifiers(count);
-                if (eglQueryDmaBufModifiersEXT(
-                        data.base.display, format, count, modifiers.data(), nullptr, &count)) {
-                    for (auto mod : qAsConst(modifiers)) {
-                        drm_format.modifiers.insert(mod);
-                    }
-                }
-            }
-        }
-        drm_formats.push_back(drm_format);
-    }
-
-    waylandServer()->linux_dmabuf()->set_formats(drm_formats);
 }
 
 }
diff --git a/render/gl/egl_dmabuf.h b/render/gl/egl_dmabuf.h
index a7624adbb..323f93a44 100644
--- a/render/gl/egl_dmabuf.h
+++ b/render/gl/egl_dmabuf.h
@@ -73,12 +73,6 @@ public:
                   Flags flags);
 
     egl_dmabuf_data data;
-
-private:
-    QVector<uint32_t> queryFormats();
-    void setSupportedFormatsAndModifiers();
-
-    friend class egl_dmabuf_buffer;
 };
 
 template<typename Backend>
-- 
GitLab


From 1ae83e28ea43fd9a20f23c8cf952ae6b4582d194 Mon Sep 17 00:00:00 2001
From: Roman Gilg <subdiff@gmail.com>
Date: Mon, 28 Feb 2022 15:18:22 +0100
Subject: [PATCH 6/9] refactor: remove EGL dmabuf data struct

We do not use any of its fields anymore. Querying formats and modifiers has
been delegated to the wlroots library.
---
 render/gl/egl_dmabuf.cpp |  3 +--
 render/gl/egl_dmabuf.h   | 32 ++------------------------------
 2 files changed, 3 insertions(+), 32 deletions(-)

diff --git a/render/gl/egl_dmabuf.cpp b/render/gl/egl_dmabuf.cpp
index 1c5d89d9e..c668d56b1 100644
--- a/render/gl/egl_dmabuf.cpp
+++ b/render/gl/egl_dmabuf.cpp
@@ -55,8 +55,7 @@ egl_dmabuf::import_buffer(std::vector<Plane> const& planes,
     return std::make_unique<egl_dmabuf_buffer>(planes, format, modifier, size, flags);
 }
 
-egl_dmabuf::egl_dmabuf(egl_dmabuf_data const& data)
-    : data{data}
+egl_dmabuf::egl_dmabuf()
 {
     // TODO(romangg): Could we just reset it? I.e. recreate the global.
     auto& dmabuf = waylandServer()->globals->linux_dmabuf_v1;
diff --git a/render/gl/egl_dmabuf.h b/render/gl/egl_dmabuf.h
index 323f93a44..17de54a7b 100644
--- a/render/gl/egl_dmabuf.h
+++ b/render/gl/egl_dmabuf.h
@@ -41,29 +41,13 @@ public:
                       Wrapland::Server::linux_dmabuf_flags_v1 flags);
 };
 
-struct egl_dmabuf_data {
-    egl_data base;
-
-    using query_formats_ext_func
-        = EGLBoolean (*)(EGLDisplay dpy, EGLint max_formats, EGLint* formats, EGLint* num_formats);
-    using query_modifiers_ext_func = EGLBoolean (*)(EGLDisplay dpy,
-                                                    EGLint format,
-                                                    EGLint max_modifiers,
-                                                    EGLuint64KHR* modifiers,
-                                                    EGLBoolean* external_only,
-                                                    EGLint* num_modifiers);
-
-    query_formats_ext_func query_formats_ext{nullptr};
-    query_modifiers_ext_func query_modifiers_ext{nullptr};
-};
-
 class egl_dmabuf
 {
 public:
     using Plane = Wrapland::Server::linux_dmabuf_plane_v1;
     using Flags = Wrapland::Server::linux_dmabuf_flags_v1;
 
-    explicit egl_dmabuf(egl_dmabuf_data const& data);
+    egl_dmabuf();
 
     std::unique_ptr<Wrapland::Server::linux_dmabuf_buffer_v1>
     import_buffer(std::vector<Plane> const& planes,
@@ -71,8 +55,6 @@ public:
                   uint64_t modifier,
                   const QSize& size,
                   Flags flags);
-
-    egl_dmabuf_data data;
 };
 
 template<typename Backend>
@@ -84,17 +66,7 @@ static egl_dmabuf* egl_dmabuf_factory(Backend& backend)
         return nullptr;
     }
 
-    egl_dmabuf_data data;
-    data.base = backend.data.base;
-
-    if (backend.hasExtension(QByteArrayLiteral("EGL_EXT_image_dma_buf_import_modifiers"))) {
-        data.query_formats_ext = reinterpret_cast<egl_dmabuf_data::query_formats_ext_func>(
-            eglGetProcAddress("eglQueryDmaBufFormatsEXT"));
-        data.query_modifiers_ext = reinterpret_cast<egl_dmabuf_data::query_modifiers_ext_func>(
-            eglGetProcAddress("eglQueryDmaBufModifiersEXT"));
-    }
-
-    return new egl_dmabuf(data);
+    return new egl_dmabuf;
 }
 
 }
-- 
GitLab


From c32a4d45ead0402a7059f8f0aec6231dca7804ac Mon Sep 17 00:00:00 2001
From: Roman Gilg <subdiff@gmail.com>
Date: Mon, 28 Feb 2022 15:35:36 +0100
Subject: [PATCH 7/9] refactor: remove EGL dmabuf factory

We can simply check on the extension and create the class from within the
backend class.
---
 render/backend/wlroots/egl_backend.cpp | 10 +++++--
 render/gl/egl_dmabuf.cpp               |  1 +
 render/gl/egl_dmabuf.h                 | 17 -----------
 render/gl/kwin_eglext.h                |  3 ++
 render/wayland/egl.h                   | 39 +++++++++++++-------------
 5 files changed, 30 insertions(+), 40 deletions(-)

diff --git a/render/backend/wlroots/egl_backend.cpp b/render/backend/wlroots/egl_backend.cpp
index 98e3969aa..5265d7b23 100644
--- a/render/backend/wlroots/egl_backend.cpp
+++ b/render/backend/wlroots/egl_backend.cpp
@@ -97,9 +97,13 @@ egl_backend::egl_backend(wlroots::platform& platform)
     gl::init_buffer_age(*this);
     wayland::init_egl(*this, data);
 
-    auto formats_set = wlr_renderer_get_dmabuf_texture_formats(platform.renderer);
-    auto formats_map = get_drm_formats<Wrapland::Server::drm_format>(formats_set);
-    waylandServer()->linux_dmabuf()->set_formats(formats_map);
+    if (hasExtension(QByteArrayLiteral("EGL_EXT_image_dma_buf_import"))) {
+        dmabuf = new gl::egl_dmabuf;
+
+        auto formats_set = wlr_renderer_get_dmabuf_texture_formats(platform.renderer);
+        auto formats_map = get_drm_formats<Wrapland::Server::drm_format>(formats_set);
+        waylandServer()->linux_dmabuf()->set_formats(formats_map);
+    }
 }
 
 egl_backend::~egl_backend()
diff --git a/render/gl/egl_dmabuf.cpp b/render/gl/egl_dmabuf.cpp
index c668d56b1..9ec31ea2a 100644
--- a/render/gl/egl_dmabuf.cpp
+++ b/render/gl/egl_dmabuf.cpp
@@ -27,6 +27,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "render/extern/drm_fourcc.h"
 
 #include <Wrapland/Server/globals.h>
+#include <cassert>
 #include <unistd.h>
 
 namespace KWin::render::gl
diff --git a/render/gl/egl_dmabuf.h b/render/gl/egl_dmabuf.h
index 17de54a7b..7c003549b 100644
--- a/render/gl/egl_dmabuf.h
+++ b/render/gl/egl_dmabuf.h
@@ -20,12 +20,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *********************************************************************/
 #pragma once
 
-#include "egl_data.h"
-
-#include <QVector>
 #include <Wrapland/Server/linux_dmabuf_v1.h>
-#include <cassert>
-#include <epoxy/egl.h>
 
 namespace KWin::render::gl
 {
@@ -57,16 +52,4 @@ public:
                   Flags flags);
 };
 
-template<typename Backend>
-static egl_dmabuf* egl_dmabuf_factory(Backend& backend)
-{
-    assert(backend.data.base.display != EGL_NO_DISPLAY);
-
-    if (!backend.hasExtension(QByteArrayLiteral("EGL_EXT_image_dma_buf_import"))) {
-        return nullptr;
-    }
-
-    return new egl_dmabuf;
-}
-
 }
diff --git a/render/gl/kwin_eglext.h b/render/gl/kwin_eglext.h
index c818a0715..b3fc13479 100644
--- a/render/gl/kwin_eglext.h
+++ b/render/gl/kwin_eglext.h
@@ -22,6 +22,9 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #ifndef KWINEGLEXT_H
 #define KWINEGLEXT_H
 
+// Must be included before the EGL header.
+#include <epoxy/egl.h>
+
 #include <EGL/eglext.h>
 
 #ifndef EGL_WL_bind_wayland_display
diff --git a/render/wayland/egl.h b/render/wayland/egl.h
index 3c149882d..fe60d6609 100644
--- a/render/wayland/egl.h
+++ b/render/wayland/egl.h
@@ -21,28 +21,27 @@ void init_egl(Backend& backend, egl_data& egl)
 {
     assert(kwinApp()->get_wayland_server());
 
-    if (backend.hasExtension(QByteArrayLiteral("EGL_WL_bind_wayland_display"))) {
-        egl.bind_wl_display = reinterpret_cast<egl_data::bind_wl_display_func>(
-            eglGetProcAddress("eglBindWaylandDisplayWL"));
-        egl.unbind_wl_display = reinterpret_cast<egl_data::unbind_wl_display_func>(
-            eglGetProcAddress("eglUnbindWaylandDisplayWL"));
-        egl.query_wl_buffer = reinterpret_cast<egl_data::query_wl_buffer_func>(
-            eglGetProcAddress("eglQueryWaylandBufferWL"));
-
-        // only bind if not already done
-        if (auto&& display = waylandServer()->display;
-            display->eglDisplay() != backend.data.base.display) {
-            if (!egl.bind_wl_display(backend.data.base.display, display->native())) {
-                egl.unbind_wl_display = nullptr;
-                egl.query_wl_buffer = nullptr;
-            } else {
-                display->setEglDisplay(backend.data.base.display);
-            }
-        }
+    if (!backend.hasExtension(QByteArrayLiteral("EGL_WL_bind_wayland_display"))) {
+        return;
     }
 
-    assert(!backend.dmabuf);
-    backend.dmabuf = gl::egl_dmabuf_factory(backend);
+    egl.bind_wl_display = reinterpret_cast<egl_data::bind_wl_display_func>(
+        eglGetProcAddress("eglBindWaylandDisplayWL"));
+    egl.unbind_wl_display = reinterpret_cast<egl_data::unbind_wl_display_func>(
+        eglGetProcAddress("eglUnbindWaylandDisplayWL"));
+    egl.query_wl_buffer = reinterpret_cast<egl_data::query_wl_buffer_func>(
+        eglGetProcAddress("eglQueryWaylandBufferWL"));
+
+    // only bind if not already done
+    if (auto&& display = waylandServer()->display;
+        display->eglDisplay() != backend.data.base.display) {
+        if (!egl.bind_wl_display(backend.data.base.display, display->native())) {
+            egl.unbind_wl_display = nullptr;
+            egl.query_wl_buffer = nullptr;
+        } else {
+            display->setEglDisplay(backend.data.base.display);
+        }
+    }
 }
 
 template<typename Backend>
-- 
GitLab


From 8374c24401e8015bea0e6d640c3a4c58c4e7ecaa Mon Sep 17 00:00:00 2001
From: Roman Gilg <subdiff@gmail.com>
Date: Wed, 15 Jun 2022 22:04:09 +0200
Subject: [PATCH 8/9] refactor: remove dmabuf buffer child class

The egl_dmabuf_buffer class has become unnecessary. We can simply use the
Wrapland class directly instead.
---
 render/backend/wlroots/texture_update.h |  6 +++---
 render/gl/egl_dmabuf.cpp                | 12 ++----------
 render/gl/egl_dmabuf.h                  | 11 -----------
 3 files changed, 5 insertions(+), 24 deletions(-)

diff --git a/render/backend/wlroots/texture_update.h b/render/backend/wlroots/texture_update.h
index 4b01d7a81..168f81c90 100644
--- a/render/backend/wlroots/texture_update.h
+++ b/render/backend/wlroots/texture_update.h
@@ -170,8 +170,8 @@ bool update_texture_from_egl(Texture& texture, Wrapland::Server::Buffer* buffer)
     return true;
 }
 
-template<typename Texture>
-bool update_texture_from_dmabuf(Texture& texture, gl::egl_dmabuf_buffer* dmabuf)
+template<typename Texture, typename Dmabuf>
+bool update_texture_from_dmabuf(Texture& texture, Dmabuf* dmabuf)
 {
     assert(dmabuf);
     assert(texture.m_image == EGL_NO_IMAGE_KHR);
@@ -307,7 +307,7 @@ bool update_texture_from_external(Texture& texture,
     assert(extbuf);
 
     if (auto dmabuf = extbuf->linuxDmabufBuffer()) {
-        ret = update_texture_from_dmabuf(texture, static_cast<gl::egl_dmabuf_buffer*>(dmabuf));
+        ret = update_texture_from_dmabuf(texture, dmabuf);
     } else if (auto shm = extbuf->shmBuffer()) {
         ret = update_texture_from_shm(texture, buffer);
     } else {
diff --git a/render/gl/egl_dmabuf.cpp b/render/gl/egl_dmabuf.cpp
index 9ec31ea2a..0d3df5029 100644
--- a/render/gl/egl_dmabuf.cpp
+++ b/render/gl/egl_dmabuf.cpp
@@ -36,15 +36,6 @@ namespace KWin::render::gl
 using Plane = Wrapland::Server::linux_dmabuf_plane_v1;
 using Flags = Wrapland::Server::linux_dmabuf_flags_v1;
 
-egl_dmabuf_buffer::egl_dmabuf_buffer(std::vector<Plane> planes,
-                                     uint32_t format,
-                                     uint64_t modifier,
-                                     const QSize& size,
-                                     Flags flags)
-    : Wrapland::Server::linux_dmabuf_buffer_v1(std::move(planes), format, modifier, size, flags)
-{
-}
-
 std::unique_ptr<Wrapland::Server::linux_dmabuf_buffer_v1>
 egl_dmabuf::import_buffer(std::vector<Plane> const& planes,
                           uint32_t format,
@@ -53,7 +44,8 @@ egl_dmabuf::import_buffer(std::vector<Plane> const& planes,
                           Flags flags)
 {
     Q_ASSERT(planes.size() > 0);
-    return std::make_unique<egl_dmabuf_buffer>(planes, format, modifier, size, flags);
+    return std::make_unique<Wrapland::Server::linux_dmabuf_buffer_v1>(
+        planes, format, modifier, size, flags);
 }
 
 egl_dmabuf::egl_dmabuf()
diff --git a/render/gl/egl_dmabuf.h b/render/gl/egl_dmabuf.h
index 7c003549b..7ff079303 100644
--- a/render/gl/egl_dmabuf.h
+++ b/render/gl/egl_dmabuf.h
@@ -24,17 +24,6 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
 namespace KWin::render::gl
 {
-class egl_dmabuf;
-
-class egl_dmabuf_buffer : public Wrapland::Server::linux_dmabuf_buffer_v1
-{
-public:
-    egl_dmabuf_buffer(std::vector<Wrapland::Server::linux_dmabuf_plane_v1> planes,
-                      uint32_t format,
-                      uint64_t modifier,
-                      const QSize& size,
-                      Wrapland::Server::linux_dmabuf_flags_v1 flags);
-};
 
 class egl_dmabuf
 {
-- 
GitLab


From 85ed29b95a19b20e6688759dbf08f75761e7f974 Mon Sep 17 00:00:00 2001
From: Roman Gilg <subdiff@gmail.com>
Date: Wed, 15 Jun 2022 22:11:35 +0200
Subject: [PATCH 9/9] refactor: remove egl dmabuf class

Instead we can create the Wrapland global directly in the wlroots backend.
---
 CMakeLists.txt                          |  1 -
 render/backend/wlroots/egl_backend.cpp  | 18 ++++---
 render/backend/wlroots/egl_backend.h    |  8 +---
 render/backend/wlroots/texture_update.h |  1 -
 render/gl/egl_dmabuf.cpp                | 63 -------------------------
 render/gl/egl_dmabuf.h                  | 44 -----------------
 render/wayland/egl.h                    |  1 -
 7 files changed, 13 insertions(+), 123 deletions(-)
 delete mode 100644 render/gl/egl_dmabuf.cpp
 delete mode 100644 render/gl/egl_dmabuf.h

diff --git a/CMakeLists.txt b/CMakeLists.txt
index 8e1a03c7e..026ecb939 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -841,7 +841,6 @@ set(kwin_WAYLAND_SRCS
    input/touch.cpp
    input/xkb/layout_manager.cpp
    input/xkb/layout_policies.cpp
-   render/gl/egl_dmabuf.cpp
    render/qpainter/buffer.cpp
    render/qpainter/deco_renderer.cpp
    render/qpainter/scene.cpp
diff --git a/render/backend/wlroots/egl_backend.cpp b/render/backend/wlroots/egl_backend.cpp
index 5265d7b23..160b81bf3 100644
--- a/render/backend/wlroots/egl_backend.cpp
+++ b/render/backend/wlroots/egl_backend.cpp
@@ -98,11 +98,16 @@ egl_backend::egl_backend(wlroots::platform& platform)
     wayland::init_egl(*this, data);
 
     if (hasExtension(QByteArrayLiteral("EGL_EXT_image_dma_buf_import"))) {
-        dmabuf = new gl::egl_dmabuf;
-
-        auto formats_set = wlr_renderer_get_dmabuf_texture_formats(platform.renderer);
-        auto formats_map = get_drm_formats<Wrapland::Server::drm_format>(formats_set);
-        waylandServer()->linux_dmabuf()->set_formats(formats_map);
+        auto const formats_set = wlr_renderer_get_dmabuf_texture_formats(platform.renderer);
+        auto const formats_map = get_drm_formats<Wrapland::Server::drm_format>(formats_set);
+
+        dmabuf = std::make_unique<Wrapland::Server::linux_dmabuf_v1>(
+            waylandServer()->display.get(),
+            [this](auto const& planes, auto format, auto modifier, auto const& size, auto flags) {
+                return std::make_unique<Wrapland::Server::linux_dmabuf_buffer_v1>(
+                    planes, format, modifier, size, flags);
+            });
+        dmabuf->set_formats(formats_map);
     }
 }
 
@@ -135,8 +140,7 @@ void egl_backend::cleanup()
     doneCurrent();
     cleanupSurfaces();
 
-    delete dmabuf;
-    dmabuf = nullptr;
+    dmabuf.reset();
 }
 
 void egl_backend::cleanupSurfaces()
diff --git a/render/backend/wlroots/egl_backend.h b/render/backend/wlroots/egl_backend.h
index 73332c1b6..abd7a154b 100644
--- a/render/backend/wlroots/egl_backend.h
+++ b/render/backend/wlroots/egl_backend.h
@@ -10,6 +10,7 @@
 
 #include <kwingl/utils.h>
 
+#include <Wrapland/Server/linux_dmabuf_v1.h>
 #include <memory>
 
 struct wlr_egl;
@@ -17,11 +18,6 @@ struct wlr_egl;
 namespace KWin::render
 {
 
-namespace gl
-{
-class egl_dmabuf;
-}
-
 namespace backend::wlroots
 {
 
@@ -60,7 +56,7 @@ public:
 
     wlroots::platform& platform;
 
-    gl::egl_dmabuf* dmabuf{nullptr};
+    std::unique_ptr<Wrapland::Server::linux_dmabuf_v1> dmabuf;
     wayland::egl_data data;
 
     GLRenderTarget native_fbo;
diff --git a/render/backend/wlroots/texture_update.h b/render/backend/wlroots/texture_update.h
index 168f81c90..97e96e02b 100644
--- a/render/backend/wlroots/texture_update.h
+++ b/render/backend/wlroots/texture_update.h
@@ -9,7 +9,6 @@
 #include "wlr_includes.h"
 
 #include "render/extern/drm_fourcc.h"
-#include "render/gl/egl_dmabuf.h"
 #include "render/gl/kwin_eglext.h"
 #include "render/gl/window.h"
 #include "render/wayland/buffer.h"
diff --git a/render/gl/egl_dmabuf.cpp b/render/gl/egl_dmabuf.cpp
deleted file mode 100644
index 0d3df5029..000000000
--- a/render/gl/egl_dmabuf.cpp
+++ /dev/null
@@ -1,63 +0,0 @@
-/********************************************************************
- KWin - the KDE window manager
- This file is part of the KDE project.
-
-Copyright  2019 Roman Gilg <subdiff@gmail.com>
-Copyright  2018 Fredrik Hglund <fredrik@kde.org>
-
-This program is free software; you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation; either version 2 of the License, or
-(at your option) any later version.
-
-This program is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with this program.  If not, see <http://www.gnu.org/licenses/>.
-*********************************************************************/
-#include "egl_dmabuf.h"
-
-#include "kwin_eglext.h"
-
-#include "base/wayland/server.h"
-#include "main.h"
-#include "render/extern/drm_fourcc.h"
-
-#include <Wrapland/Server/globals.h>
-#include <cassert>
-#include <unistd.h>
-
-namespace KWin::render::gl
-{
-
-using Plane = Wrapland::Server::linux_dmabuf_plane_v1;
-using Flags = Wrapland::Server::linux_dmabuf_flags_v1;
-
-std::unique_ptr<Wrapland::Server::linux_dmabuf_buffer_v1>
-egl_dmabuf::import_buffer(std::vector<Plane> const& planes,
-                          uint32_t format,
-                          uint64_t modifier,
-                          const QSize& size,
-                          Flags flags)
-{
-    Q_ASSERT(planes.size() > 0);
-    return std::make_unique<Wrapland::Server::linux_dmabuf_buffer_v1>(
-        planes, format, modifier, size, flags);
-}
-
-egl_dmabuf::egl_dmabuf()
-{
-    // TODO(romangg): Could we just reset it? I.e. recreate the global.
-    auto& dmabuf = waylandServer()->globals->linux_dmabuf_v1;
-    assert(!dmabuf);
-    dmabuf = std::make_unique<Wrapland::Server::linux_dmabuf_v1>(
-        waylandServer()->display.get(),
-        [this](auto const& planes, auto format, auto modifier, auto const& size, auto flags) {
-            return import_buffer(planes, format, modifier, size, flags);
-        });
-}
-
-}
diff --git a/render/gl/egl_dmabuf.h b/render/gl/egl_dmabuf.h
deleted file mode 100644
index 7ff079303..000000000
--- a/render/gl/egl_dmabuf.h
+++ /dev/null
@@ -1,44 +0,0 @@
-/********************************************************************
- KWin - the KDE window manager
- This file is part of the KDE project.
-
-Copyright  2019 Roman Gilg <subdiff@gmail.com>
-Copyright  2018 Fredrik Hglund <fredrik@kde.org>
-
-This program is free software; you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation; either version 2 of the License, or
-(at your option) any later version.
-
-This program is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with this program.  If not, see <http://www.gnu.org/licenses/>.
-*********************************************************************/
-#pragma once
-
-#include <Wrapland/Server/linux_dmabuf_v1.h>
-
-namespace KWin::render::gl
-{
-
-class egl_dmabuf
-{
-public:
-    using Plane = Wrapland::Server::linux_dmabuf_plane_v1;
-    using Flags = Wrapland::Server::linux_dmabuf_flags_v1;
-
-    egl_dmabuf();
-
-    std::unique_ptr<Wrapland::Server::linux_dmabuf_buffer_v1>
-    import_buffer(std::vector<Plane> const& planes,
-                  uint32_t format,
-                  uint64_t modifier,
-                  const QSize& size,
-                  Flags flags);
-};
-
-}
diff --git a/render/wayland/egl.h b/render/wayland/egl.h
index fe60d6609..bdc54c55e 100644
--- a/render/wayland/egl.h
+++ b/render/wayland/egl.h
@@ -9,7 +9,6 @@
 
 #include "base/wayland/server.h"
 #include "main.h"
-#include "render/gl/egl_dmabuf.h"
 
 #include <Wrapland/Server/display.h>
 
-- 
GitLab

