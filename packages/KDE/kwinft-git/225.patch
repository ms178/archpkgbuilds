From 14d1c9267c12823a4c02073de44f61009dd709d1 Mon Sep 17 00:00:00 2001
From: Tom Englund <tomenglund26@gmail.com>
Date: Fri, 8 Jul 2022 19:51:37 +0200
Subject: [PATCH 1/9] refactor: use a bool for transformation

use a bool for transformation in the backend instead, makes things
easier to understand what its doing. and with that use
matrix.flipcordinates() instead on the projection matrix instead of the
calculation on the combined matrix.
---
 render/backend/wlroots/egl_backend.cpp | 6 +++---
 render/effects.cpp                     | 5 -----
 render/gl/backend.h                    | 2 +-
 render/gl/scene.cpp                    | 7 ++++++-
 4 files changed, 10 insertions(+), 10 deletions(-)

diff --git a/render/backend/wlroots/egl_backend.cpp b/render/backend/wlroots/egl_backend.cpp
index 7fe0c9e56..594ba4983 100644
--- a/render/backend/wlroots/egl_backend.cpp
+++ b/render/backend/wlroots/egl_backend.cpp
@@ -193,9 +193,9 @@ QRegion egl_backend::prepareRenderingForScreen(base::output* output)
         = GLRenderTarget(wlr_gles2_renderer_get_current_fbo(platform.renderer), get_viewport(*out));
     GLRenderTarget::pushRenderTarget(&native_fbo);
 
-    QMatrix4x4 flip_180;
-    flip_180(1, 1) = -1;
-    transformation = flip_180;
+    // Wlroots gives us flipped and rotated view, set this to true to later use when calculating
+    // projections.
+    flip_180 = true;
 
     prepareRenderFramebuffer(*out);
 
diff --git a/render/effects.cpp b/render/effects.cpp
index 6f3e2c734..267471119 100644
--- a/render/effects.cpp
+++ b/render/effects.cpp
@@ -1843,11 +1843,6 @@ QImage effects_handler_impl::blit_from_framebuffer(QRect const& geometry, double
                      static_cast<GLvoid*>(image.bits()));
     }
 
-    auto gl_backend = static_cast<render::gl::scene*>(m_scene)->backend();
-    QMatrix4x4 flip_vert;
-    flip_vert(1, 1) = -1;
-
-    image = image.transformed((flip_vert * gl_backend->transformation).toTransform());
     image.setDevicePixelRatio(scale);
     return image;
 }
diff --git a/render/gl/backend.h b/render/gl/backend.h
index 5192a8bab..eaf5846ed 100644
--- a/render/gl/backend.h
+++ b/render/gl/backend.h
@@ -206,7 +206,7 @@ public:
     /**
      * For final backend-specific corrections to the scene projection matrix. Defaults to identity.
      */
-    QMatrix4x4 transformation;
+    bool flip_180{false};
 
 protected:
     /**
diff --git a/render/gl/scene.cpp b/render/gl/scene.cpp
index 31bff347b..fc79744bb 100644
--- a/render/gl/scene.cpp
+++ b/render/gl/scene.cpp
@@ -862,6 +862,11 @@ QMatrix4x4 scene::createProjectionMatrix() const
     const float xMax = yMax * aspect;
 
     QMatrix4x4 projection;
+
+    if (m_backend->flip_180) {
+        projection.flipCoordinates();
+    }
+
     projection.frustum(xMin, xMax, yMin, yMax, zNear, zFar);
 
     // Create a second matrix that transforms screen coordinates
@@ -876,7 +881,7 @@ QMatrix4x4 scene::createProjectionMatrix() const
                  0.001);
 
     // Combine the matrices
-    return m_backend->transformation * projection * matrix;
+    return projection * matrix;
 }
 
 void scene::updateProjectionMatrix()
-- 
GitLab


From 9b5601d4adceb60acf5719174bf1d941c7264be7 Mon Sep 17 00:00:00 2001
From: Tom Englund <tomenglund26@gmail.com>
Date: Fri, 8 Jul 2022 19:53:27 +0200
Subject: [PATCH 2/9] fix: fix blit_to_framebuffer coloring

on wayland we use rgba colors, so set QImage::rgba8888 instead of
::argb32. fixes weird color distortions.
---
 render/effects.cpp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/render/effects.cpp b/render/effects.cpp
index 267471119..72857ec4b 100644
--- a/render/effects.cpp
+++ b/render/effects.cpp
@@ -1833,7 +1833,7 @@ QImage effects_handler_impl::blit_from_framebuffer(QRect const& geometry, double
             GL_TEXTURE_2D, 0, GL_RGBA, GL_UNSIGNED_BYTE, static_cast<GLvoid*>(image.bits()));
         texture.unbind();
     } else {
-        image = QImage(nativeSize.width(), nativeSize.height(), QImage::Format_ARGB32);
+        image = QImage(nativeSize.width(), nativeSize.height(), QImage::Format_RGBA8888);
         glReadPixels(0,
                      0,
                      nativeSize.width(),
-- 
GitLab


From 356568dc4109004feaf5b31abd91adb82403bd87 Mon Sep 17 00:00:00 2001
From: Tom Englund <tomenglund26@gmail.com>
Date: Fri, 8 Jul 2022 21:45:51 +0200
Subject: [PATCH 3/9] fix: make a copy of slide registry

slide effects might delete themself while iterating, and iterating in a
for ranges loop that gets modified is undefined behaviour.
---
 render/wayland/effect/slide_integration.h | 3 ++-
 render/x11/effect/slide_integration.h     | 3 ++-
 2 files changed, 4 insertions(+), 2 deletions(-)

diff --git a/render/wayland/effect/slide_integration.h b/render/wayland/effect/slide_integration.h
index 35afb86bf..35f8e972c 100644
--- a/render/wayland/effect/slide_integration.h
+++ b/render/wayland/effect/slide_integration.h
@@ -74,7 +74,8 @@ public:
             return;
         }
 
-        for (auto const& [effect, update_call] : registry) {
+        auto const reg_cp = registry;
+        for (auto const& [effect, update_call] : reg_cp) {
             update_call(upd);
         }
     }
diff --git a/render/x11/effect/slide_integration.h b/render/x11/effect/slide_integration.h
index 5a30e980e..f5274d411 100644
--- a/render/x11/effect/slide_integration.h
+++ b/render/x11/effect/slide_integration.h
@@ -55,7 +55,8 @@ public:
         if (!upd.base.window) {
             return;
         }
-        for (auto const& [effect, update_call] : registry) {
+        auto const reg_cp = registry;
+        for (auto const& [effect, update_call] : reg_cp) {
             update_call(upd);
         }
     }
-- 
GitLab


From bd2d54d4bd91d6c0f76f2e6b2a449ca13ac410da Mon Sep 17 00:00:00 2001
From: Tom Englund <tomenglund26@gmail.com>
Date: Sat, 9 Jul 2022 14:50:41 +0200
Subject: [PATCH 4/9] fix: add missing includes

add missing includes.
---
 render/wayland/shadow.h | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/render/wayland/shadow.h b/render/wayland/shadow.h
index 5ae6e8acc..3cb533781 100644
--- a/render/wayland/shadow.h
+++ b/render/wayland/shadow.h
@@ -9,7 +9,9 @@
 #include "render/compositor.h"
 #include "render/scene.h"
 #include "render/types.h"
+#include "utils/algorithm.h"
 
+#include <QPixmap>
 #include <QPointer>
 #include <Wrapland/Server/buffer.h>
 #include <Wrapland/Server/shadow.h>
-- 
GitLab


From 0bb0a61fdcb9547f17f5e0e0b72b7f880371feb9 Mon Sep 17 00:00:00 2001
From: Tom Englund <tomenglund26@gmail.com>
Date: Sun, 10 Jul 2022 01:40:49 +0200
Subject: [PATCH 5/9] feat: add render_target_flip180

add a way to retrieve if backend has set the flip to true to be able to
to recalculate X and Y axis in effects.
---
 effect/lib/kwineffects/effects_handler.h |  4 ++++
 render/effects.cpp                       |  5 +++++
 render/effects.h                         |  1 +
 render/gl/scene.cpp                      |  3 ++-
 render/gl/scene.h                        |  2 +-
 render/scene.cpp                         | 10 ++++++++++
 render/scene.h                           |  3 +++
 7 files changed, 26 insertions(+), 2 deletions(-)

diff --git a/effect/lib/kwineffects/effects_handler.h b/effect/lib/kwineffects/effects_handler.h
index 14a61abcd..a2991c624 100644
--- a/effect/lib/kwineffects/effects_handler.h
+++ b/effect/lib/kwineffects/effects_handler.h
@@ -686,6 +686,10 @@ public:
      * Returns the device pixel ratio of the current render target.
      */
     virtual qreal renderTargetScale() const = 0;
+    /**
+     * Returns if the backend is flipped and rotated 180 degrees.
+     */
+    virtual bool render_target_flip180() const = 0;
 
     /**
      * Maps the given @a rect from the global screen cordinates to the render
diff --git a/render/effects.cpp b/render/effects.cpp
index 72857ec4b..2df3fbd07 100644
--- a/render/effects.cpp
+++ b/render/effects.cpp
@@ -1867,6 +1867,11 @@ qreal effects_handler_impl::renderTargetScale() const
     return m_scene->renderTargetScale();
 }
 
+bool effects_handler_impl::render_target_flip180() const
+{
+    return m_scene->render_target_flip180();
+}
+
 //****************************************
 // effect_screen_impl
 //****************************************
diff --git a/render/effects.h b/render/effects.h
index 579120d0f..3f7fa2906 100644
--- a/render/effects.h
+++ b/render/effects.h
@@ -316,6 +316,7 @@ public:
 
     QRect renderTargetRect() const override;
     qreal renderTargetScale() const override;
+    bool render_target_flip180() const override;
 
     using PropertyEffectMap = QHash<QByteArray, QList<Effect*>>;
     PropertyEffectMap m_propertiesForEffects;
diff --git a/render/gl/scene.cpp b/render/gl/scene.cpp
index fc79744bb..efe6f08ca 100644
--- a/render/gl/scene.cpp
+++ b/render/gl/scene.cpp
@@ -847,7 +847,7 @@ bool scene::supported(render::gl::backend* backend)
     return true;
 }
 
-QMatrix4x4 scene::createProjectionMatrix() const
+QMatrix4x4 scene::createProjectionMatrix()
 {
     // Create a perspective projection with a 60Â° field-of-view,
     // and an aspect ratio of 1.0.
@@ -865,6 +865,7 @@ QMatrix4x4 scene::createProjectionMatrix() const
 
     if (m_backend->flip_180) {
         projection.flipCoordinates();
+        set_render_target_flip180(m_backend->flip_180);
     }
 
     projection.frustum(xMin, xMax, yMin, yMax, zNear, zFar);
diff --git a/render/gl/scene.h b/render/gl/scene.h
index fe6515b70..7c574162b 100644
--- a/render/gl/scene.h
+++ b/render/gl/scene.h
@@ -125,7 +125,7 @@ private:
                             paint_type mask,
                             QRegion region,
                             WindowPaintData& data);
-    QMatrix4x4 createProjectionMatrix() const;
+    QMatrix4x4 createProjectionMatrix();
 
     render::gl::backend* m_backend;
     SyncManager* m_syncManager{nullptr};
diff --git a/render/scene.cpp b/render/scene.cpp
index da253f390..63a33c45a 100644
--- a/render/scene.cpp
+++ b/render/scene.cpp
@@ -695,6 +695,16 @@ void scene::setRenderTargetScale(qreal scale)
     m_renderTargetScale = scale;
 }
 
+bool scene::render_target_flip180() const
+{
+    return m_render_target_flip180;
+}
+
+void scene::set_render_target_flip180(bool flip)
+{
+    m_render_target_flip180 = flip;
+}
+
 QRegion scene::mapToRenderTarget(const QRegion& region) const
 {
     QRegion result;
diff --git a/render/scene.h b/render/scene.h
index 0b143b393..533a1a726 100644
--- a/render/scene.h
+++ b/render/scene.h
@@ -154,6 +154,8 @@ public:
     void setRenderTargetRect(const QRect& rect);
     qreal renderTargetScale() const;
     void setRenderTargetScale(qreal scale);
+    bool render_target_flip180() const;
+    void set_render_target_flip180(bool flip);
 
     QRegion mapToRenderTarget(const QRegion& region) const;
 
@@ -247,6 +249,7 @@ private:
 
     QRect m_renderTargetRect;
     qreal m_renderTargetScale = 1;
+    bool m_render_target_flip180{false};
 };
 
 }
-- 
GitLab


From 9cf79430b67b1e52ae473d64ab877c7a00f3d0fe Mon Sep 17 00:00:00 2001
From: Tom Englund <tomenglund26@gmail.com>
Date: Sat, 9 Jul 2022 15:59:00 +0200
Subject: [PATCH 6/9] fix: calculate region depending on flip

sliding popups calculates region to repaint depending on how far the
slide animation has progressed, repaint the entire X/Y width+height
region if render_target_flip180 is set as is on wlroots where we have
flipped and rotated view.
---
 effect/effects/slidingpopups/slidingpopups.cpp | 11 ++++++++++-
 1 file changed, 10 insertions(+), 1 deletion(-)

diff --git a/effect/effects/slidingpopups/slidingpopups.cpp b/effect/effects/slidingpopups/slidingpopups.cpp
index 17fcf7170..26f9d0a3c 100644
--- a/effect/effects/slidingpopups/slidingpopups.cpp
+++ b/effect/effects/slidingpopups/slidingpopups.cpp
@@ -195,6 +195,7 @@ void SlidingPopupsEffect::paintWindow(EffectWindow* win,
         = effects->clientArea(FullScreenArea, win->screen(), effects->currentDesktop());
     auto const geo = win->expandedGeometry();
     auto const time = (*animationIt).timeline.value();
+    auto old_region = region;
 
     switch (animData.location) {
     case effect::position::left:
@@ -231,7 +232,15 @@ void SlidingPopupsEffect::paintWindow(EffectWindow* win,
         region &= QRegion(geo.x(), geo.y(), geo.width(), split_point);
     }
 
-    effects->paintWindow(win, mask, region, data);
+    if (effects->render_target_flip180()) {
+        // TODO: calculate animData offset and split_point and region on a flipped and rotated view
+        // as wlroots gives us, for now this makes us repaint the entire X/Y width+height instead of
+        // just the "animated rectangle" at a miniscule performance loss meanwhile the effect is
+        // animating.
+        effects->paintWindow(win, mask, old_region, data);
+    } else {
+        effects->paintWindow(win, mask, region, data);
+    }
 }
 
 void SlidingPopupsEffect::postPaintWindow(EffectWindow* win)
-- 
GitLab


From 0abc9040202900bf13edd114d01557d84578edb4 Mon Sep 17 00:00:00 2001
From: Tom Englund <tomenglund26@gmail.com>
Date: Sun, 10 Jul 2022 12:22:14 +0200
Subject: [PATCH 7/9] fix: update popup layers

fixes popups sometimes being in the wrong stacking order and also the
situation when the dock has an popup and setshowingdesktop gets called
which iterates over the stackingorder and calls update_layer and then
belong_to_layer, now without this it means its entering
win->layer_for_dock() because this popup has windowtype of net::dock but
is an xdgxshell popup without control and hits the assert in there.
---
 win/layers.h | 3 +++
 win/types.h  | 1 +
 2 files changed, 4 insertions(+)

diff --git a/win/layers.h b/win/layers.h
index 333ee563c..3cfdff3f7 100644
--- a/win/layers.h
+++ b/win/layers.h
@@ -56,6 +56,9 @@ layer belong_to_layer(Win* win)
     if (is_splash(win)) {
         return win::layer::normal;
     }
+    if (is_popup(win)) {
+        return win::layer::popup;
+    }
     if (is_dock(win)) {
         if (win->space.showingDesktop()) {
             return win::layer::notification;
diff --git a/win/types.h b/win/types.h
index 2e3480858..897ee2f16 100644
--- a/win/types.h
+++ b/win/types.h
@@ -54,6 +54,7 @@ enum class layer {
     above,
     notification,          // layer for windows of type notification
     active,                // active fullscreen, or active dialog
+    popup,                 // layer for popups, xdg shell popups, etc
     critical_notification, // layer for notifications that should be shown even on top of fullscreen
     on_screen_display,     // layer for On Screen Display windows such as volume feedback
     unmanaged,             // layer for override redirect windows.
-- 
GitLab

From 15c074ea8d35c83b79b5e79e53203a1d15274620 Mon Sep 17 00:00:00 2001
From: Tom Englund <tomenglund26@gmail.com>
Date: Mon, 11 Jul 2022 03:31:12 +0200
Subject: [PATCH 9/9] fix: flip contrast projection on wayland

flip the calculations for contrast projection when rendering on the
flipped and 180 degree rotated wlroots/wayland output.
---
 .../effects/backgroundcontrast/contrast.cpp   | 67 ++++++++++++-------
 1 file changed, 42 insertions(+), 25 deletions(-)

diff --git a/effect/effects/backgroundcontrast/contrast.cpp b/effect/effects/backgroundcontrast/contrast.cpp
index 06d38dfab..979a21e32 100644
--- a/effect/effects/backgroundcontrast/contrast.cpp
+++ b/effect/effects/backgroundcontrast/contrast.cpp
@@ -24,6 +24,7 @@
 #include <kwineffects/effect_window.h>
 #include <kwineffects/effects_handler.h>
 #include <kwineffects/paint_data.h>
+#include <kwingl/utils.h>
 
 #include <QMatrix4x4>
 
@@ -254,8 +255,9 @@ void ContrastEffect::doContrast(EffectWindow* w,
 {
     const QRegion actualShape = shape & screen;
     const QRect r = actualShape.boundingRect();
-
     auto const scale = effects->renderTargetScale();
+    auto const sg = effects->renderTargetRect();
+    QMatrix4x4 textureMatrix;
 
     // Upload geometry for the horizontal and vertical passes
     GLVertexBuffer* vbo = GLVertexBuffer::streamingBuffer();
@@ -263,42 +265,57 @@ void ContrastEffect::doContrast(EffectWindow* w,
     uploadGeometry(vbo, actualShape);
     vbo->bindArrays();
 
-    // Create a scratch texture and copy the area in the back buffer that we're
+    // Create a texture and copy the area in the back buffer that we're
     // going to blur into it
-    GLTexture scratch(GL_RGBA8, r.width() * scale, r.height() * scale);
-    scratch.setFilter(GL_LINEAR);
-    scratch.setWrapMode(GL_CLAMP_TO_EDGE);
-    scratch.bind();
+    auto m_texture = GLTexture(GL_RGBA8, r.width() * scale, r.height() * scale);
+    m_texture.setYInverted(true);
+    m_texture.setFilter(GL_LINEAR);
+    m_texture.setWrapMode(GL_CLAMP_TO_EDGE);
+
+    m_texture.bind();
+    if (effects->render_target_flip180()) {
+        // Set up the texture matrix to transform from screen coordinates
+        // to texture coordinates.
+        textureMatrix.scale(1.0 / r.width(), 1.0 / r.height(), 1);
+        textureMatrix.translate(-r.x(), -r.y(), 0);
+
+        // copy a two-dimensional texture subimage
+        glCopyTexSubImage2D(GL_TEXTURE_2D,
+                            0,
+                            0,
+                            0,
+                            (r.x() - sg.x()) * scale,
+                            (r.y() - sg.y()) * scale,
+                            m_texture.width(),
+                            m_texture.height());
 
-    auto const sg = effects->renderTargetRect();
-    glCopyTexSubImage2D(GL_TEXTURE_2D,
-                        0,
-                        0,
-                        0,
-                        (r.x() - sg.x()) * scale,
-                        (sg.height() - (r.y() - sg.y() + r.height())) * scale,
-                        scratch.width(),
-                        scratch.height());
+    } else {
+        // Set up the texture matrix to transform from screen coordinates
+        // to texture coordinates.
+        textureMatrix.scale(1.0 / r.width(), -1.0 / r.height(), 1);
+        textureMatrix.translate(-r.x(), -r.height() - r.y(), 0);
+
+        // copy a two-dimensional texture subimage
+        glCopyTexSubImage2D(GL_TEXTURE_2D,
+                            0,
+                            0,
+                            0,
+                            (r.x() - sg.x()) * scale,
+                            (sg.height() - (r.y() - sg.y() + r.height())) * scale,
+                            m_texture.width(),
+                            m_texture.height());
+    }
 
     // Draw the texture on the offscreen framebuffer object, while blurring it horizontally
-
     shader->setColorMatrix(m_colorMatrices.value(w));
     shader->bind();
-
     shader->setOpacity(opacity);
-    // Set up the texture matrix to transform from screen coordinates
-    // to texture coordinates.
-    QMatrix4x4 textureMatrix;
-    textureMatrix.scale(1.0 / r.width(), -1.0 / r.height(), 1);
-    textureMatrix.translate(-r.x(), -r.height() - r.y(), 0);
     shader->setTextureMatrix(textureMatrix);
     shader->setModelViewProjectionMatrix(screenProjection);
 
     vbo->draw(GL_TRIANGLES, 0, actualShape.rectCount() * 6);
 
-    scratch.unbind();
-    scratch.discard();
-
+    m_texture.unbind();
     vbo->unbindArrays();
 
     if (opacity < 1.0) {
-- 
GitLab

