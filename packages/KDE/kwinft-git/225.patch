From 59b1e7b6e3f98f95f78a04b036e01c1270052e9f Mon Sep 17 00:00:00 2001
From: Tom Englund <tomenglund26@gmail.com>
Date: Fri, 8 Jul 2022 19:51:37 +0200
Subject: [PATCH 1/4] refactor: use a bool for transformation

use a bool for transformation in the backend instead, makes things
easier to understand what its doing. and with that use
matrix.flipcordinates() instead on the projection matrix instead of the
calculation on the combined matrix.
---
 render/backend/wlroots/egl_backend.cpp | 6 +++---
 render/effects.cpp                     | 5 -----
 render/gl/backend.h                    | 2 +-
 render/gl/scene.cpp                    | 7 ++++++-
 4 files changed, 10 insertions(+), 10 deletions(-)

diff --git a/render/backend/wlroots/egl_backend.cpp b/render/backend/wlroots/egl_backend.cpp
index 7fe0c9e56..594ba4983 100644
--- a/render/backend/wlroots/egl_backend.cpp
+++ b/render/backend/wlroots/egl_backend.cpp
@@ -193,9 +193,9 @@ QRegion egl_backend::prepareRenderingForScreen(base::output* output)
         = GLRenderTarget(wlr_gles2_renderer_get_current_fbo(platform.renderer), get_viewport(*out));
     GLRenderTarget::pushRenderTarget(&native_fbo);
 
-    QMatrix4x4 flip_180;
-    flip_180(1, 1) = -1;
-    transformation = flip_180;
+    // Wlroots gives us flipped and rotated view, set this to true to later use when calculating
+    // projections.
+    flip_180 = true;
 
     prepareRenderFramebuffer(*out);
 
diff --git a/render/gl/backend.h b/render/gl/backend.h
index 5192a8bab..eaf5846ed 100644
--- a/render/gl/backend.h
+++ b/render/gl/backend.h
@@ -206,7 +206,7 @@ public:
     /**
      * For final backend-specific corrections to the scene projection matrix. Defaults to identity.
      */
-    QMatrix4x4 transformation;
+    bool flip_180{false};
 
 protected:
     /**
diff --git a/render/gl/scene.cpp b/render/gl/scene.cpp
index 31bff347b..fc79744bb 100644
--- a/render/gl/scene.cpp
+++ b/render/gl/scene.cpp
@@ -862,6 +862,11 @@ QMatrix4x4 scene::createProjectionMatrix() const
     const float xMax = yMax * aspect;
 
     QMatrix4x4 projection;
+
+    if (m_backend->flip_180) {
+        projection.flipCoordinates();
+    }
+
     projection.frustum(xMin, xMax, yMin, yMax, zNear, zFar);
 
     // Create a second matrix that transforms screen coordinates
@@ -876,7 +881,7 @@ QMatrix4x4 scene::createProjectionMatrix() const
                  0.001);
 
     // Combine the matrices
-    return m_backend->transformation * projection * matrix;
+    return projection * matrix;
 }
 
 void scene::updateProjectionMatrix()
-- 
GitLab


From 494eee0d0338b625c64a2704b18f96a3fe4cc3fb Mon Sep 17 00:00:00 2001
From: Tom Englund <tomenglund26@gmail.com>
Date: Sun, 10 Jul 2022 01:40:49 +0200
Subject: [PATCH 2/4] feat: add render_target_flip180

add a way to retrieve if backend has set the flip to true to be able to
to recalculate X and Y axis in effects.
---
 effect/lib/kwineffects/effects_handler.h |  4 ++++
 render/effects.cpp                       |  5 +++++
 render/effects.h                         |  1 +
 render/gl/scene.cpp                      |  3 ++-
 render/gl/scene.h                        |  2 +-
 render/scene.cpp                         | 10 ++++++++++
 render/scene.h                           |  3 +++
 7 files changed, 26 insertions(+), 2 deletions(-)

diff --git a/effect/lib/kwineffects/effects_handler.h b/effect/lib/kwineffects/effects_handler.h
index 14a61abcd..a2991c624 100644
--- a/effect/lib/kwineffects/effects_handler.h
+++ b/effect/lib/kwineffects/effects_handler.h
@@ -686,6 +686,10 @@ public:
      * Returns the device pixel ratio of the current render target.
      */
     virtual qreal renderTargetScale() const = 0;
+    /**
+     * Returns if the backend is flipped and rotated 180 degrees.
+     */
+    virtual bool render_target_flip180() const = 0;
 
     /**
      * Maps the given @a rect from the global screen cordinates to the render
diff --git a/render/effects.cpp b/render/effects.cpp
index 37bab0aa8..bcbe66532 100644
--- a/render/effects.cpp
+++ b/render/effects.cpp
@@ -1874,6 +1874,11 @@ qreal effects_handler_impl::renderTargetScale() const
     return m_scene->renderTargetScale();
 }
 
+bool effects_handler_impl::render_target_flip180() const
+{
+    return m_scene->render_target_flip180();
+}
+
 //****************************************
 // effect_screen_impl
 //****************************************
diff --git a/render/effects.h b/render/effects.h
index 579120d0f..3f7fa2906 100644
--- a/render/effects.h
+++ b/render/effects.h
@@ -316,6 +316,7 @@ public:
 
     QRect renderTargetRect() const override;
     qreal renderTargetScale() const override;
+    bool render_target_flip180() const override;
 
     using PropertyEffectMap = QHash<QByteArray, QList<Effect*>>;
     PropertyEffectMap m_propertiesForEffects;
diff --git a/render/gl/scene.cpp b/render/gl/scene.cpp
index fc79744bb..efe6f08ca 100644
--- a/render/gl/scene.cpp
+++ b/render/gl/scene.cpp
@@ -847,7 +847,7 @@ bool scene::supported(render::gl::backend* backend)
     return true;
 }
 
-QMatrix4x4 scene::createProjectionMatrix() const
+QMatrix4x4 scene::createProjectionMatrix()
 {
     // Create a perspective projection with a 60Â° field-of-view,
     // and an aspect ratio of 1.0.
@@ -865,6 +865,7 @@ QMatrix4x4 scene::createProjectionMatrix() const
 
     if (m_backend->flip_180) {
         projection.flipCoordinates();
+        set_render_target_flip180(m_backend->flip_180);
     }
 
     projection.frustum(xMin, xMax, yMin, yMax, zNear, zFar);
diff --git a/render/gl/scene.h b/render/gl/scene.h
index fe6515b70..7c574162b 100644
--- a/render/gl/scene.h
+++ b/render/gl/scene.h
@@ -125,7 +125,7 @@ private:
                             paint_type mask,
                             QRegion region,
                             WindowPaintData& data);
-    QMatrix4x4 createProjectionMatrix() const;
+    QMatrix4x4 createProjectionMatrix();
 
     render::gl::backend* m_backend;
     SyncManager* m_syncManager{nullptr};
diff --git a/render/scene.cpp b/render/scene.cpp
index 411fd1b1f..0a85c059b 100644
--- a/render/scene.cpp
+++ b/render/scene.cpp
@@ -698,6 +698,16 @@ void scene::setRenderTargetScale(qreal scale)
     m_renderTargetScale = scale;
 }
 
+bool scene::render_target_flip180() const
+{
+    return m_render_target_flip180;
+}
+
+void scene::set_render_target_flip180(bool flip)
+{
+    m_render_target_flip180 = flip;
+}
+
 QRegion scene::mapToRenderTarget(const QRegion& region) const
 {
     QRegion result;
diff --git a/render/scene.h b/render/scene.h
index 0b143b393..533a1a726 100644
--- a/render/scene.h
+++ b/render/scene.h
@@ -154,6 +154,8 @@ public:
     void setRenderTargetRect(const QRect& rect);
     qreal renderTargetScale() const;
     void setRenderTargetScale(qreal scale);
+    bool render_target_flip180() const;
+    void set_render_target_flip180(bool flip);
 
     QRegion mapToRenderTarget(const QRegion& region) const;
 
@@ -247,6 +249,7 @@ private:
 
     QRect m_renderTargetRect;
     qreal m_renderTargetScale = 1;
+    bool m_render_target_flip180{false};
 };
 
 }
-- 
GitLab


From 3e90cdd3b8a51347492975da182bf50e386b468c Mon Sep 17 00:00:00 2001
From: Tom Englund <tomenglund26@gmail.com>
Date: Sat, 9 Jul 2022 15:59:00 +0200
Subject: [PATCH 3/4] fix: calculate region depending on flip

sliding popups calculates region to repaint depending on how far the
slide animation has progressed, repaint the entire X/Y width+height
region if render_target_flip180 is set as is on wlroots where we have
flipped and rotated view.
---
 effect/effects/slidingpopups/slidingpopups.cpp | 11 ++++++++++-
 1 file changed, 10 insertions(+), 1 deletion(-)

diff --git a/effect/effects/slidingpopups/slidingpopups.cpp b/effect/effects/slidingpopups/slidingpopups.cpp
index 17fcf7170..26f9d0a3c 100644
--- a/effect/effects/slidingpopups/slidingpopups.cpp
+++ b/effect/effects/slidingpopups/slidingpopups.cpp
@@ -195,6 +195,7 @@ void SlidingPopupsEffect::paintWindow(EffectWindow* win,
         = effects->clientArea(FullScreenArea, win->screen(), effects->currentDesktop());
     auto const geo = win->expandedGeometry();
     auto const time = (*animationIt).timeline.value();
+    auto old_region = region;
 
     switch (animData.location) {
     case effect::position::left:
@@ -231,7 +232,15 @@ void SlidingPopupsEffect::paintWindow(EffectWindow* win,
         region &= QRegion(geo.x(), geo.y(), geo.width(), split_point);
     }
 
-    effects->paintWindow(win, mask, region, data);
+    if (effects->render_target_flip180()) {
+        // TODO: calculate animData offset and split_point and region on a flipped and rotated view
+        // as wlroots gives us, for now this makes us repaint the entire X/Y width+height instead of
+        // just the "animated rectangle" at a miniscule performance loss meanwhile the effect is
+        // animating.
+        effects->paintWindow(win, mask, old_region, data);
+    } else {
+        effects->paintWindow(win, mask, region, data);
+    }
 }
 
 void SlidingPopupsEffect::postPaintWindow(EffectWindow* win)
-- 
GitLab


From 2a6705c21b5eb94195df023d3a58ef19191c13b4 Mon Sep 17 00:00:00 2001
From: Tom Englund <tomenglund26@gmail.com>
Date: Mon, 11 Jul 2022 03:31:12 +0200
Subject: [PATCH 4/4] fix: flip contrast projection on wayland

flip the calculations for contrast projection when rendering on the
flipped and 180 degree rotated wlroots/wayland output.
---
 .../effects/backgroundcontrast/contrast.cpp   | 67 ++++++++++++-------
 1 file changed, 42 insertions(+), 25 deletions(-)

diff --git a/effect/effects/backgroundcontrast/contrast.cpp b/effect/effects/backgroundcontrast/contrast.cpp
index 06d38dfab..979a21e32 100644
--- a/effect/effects/backgroundcontrast/contrast.cpp
+++ b/effect/effects/backgroundcontrast/contrast.cpp
@@ -24,6 +24,7 @@
 #include <kwineffects/effect_window.h>
 #include <kwineffects/effects_handler.h>
 #include <kwineffects/paint_data.h>
+#include <kwingl/utils.h>
 
 #include <QMatrix4x4>
 
@@ -254,8 +255,9 @@ void ContrastEffect::doContrast(EffectWindow* w,
 {
     const QRegion actualShape = shape & screen;
     const QRect r = actualShape.boundingRect();
-
     auto const scale = effects->renderTargetScale();
+    auto const sg = effects->renderTargetRect();
+    QMatrix4x4 textureMatrix;
 
     // Upload geometry for the horizontal and vertical passes
     GLVertexBuffer* vbo = GLVertexBuffer::streamingBuffer();
@@ -263,42 +265,57 @@ void ContrastEffect::doContrast(EffectWindow* w,
     uploadGeometry(vbo, actualShape);
     vbo->bindArrays();
 
-    // Create a scratch texture and copy the area in the back buffer that we're
+    // Create a texture and copy the area in the back buffer that we're
     // going to blur into it
-    GLTexture scratch(GL_RGBA8, r.width() * scale, r.height() * scale);
-    scratch.setFilter(GL_LINEAR);
-    scratch.setWrapMode(GL_CLAMP_TO_EDGE);
-    scratch.bind();
+    auto m_texture = GLTexture(GL_RGBA8, r.width() * scale, r.height() * scale);
+    m_texture.setYInverted(true);
+    m_texture.setFilter(GL_LINEAR);
+    m_texture.setWrapMode(GL_CLAMP_TO_EDGE);
+
+    m_texture.bind();
+    if (effects->render_target_flip180()) {
+        // Set up the texture matrix to transform from screen coordinates
+        // to texture coordinates.
+        textureMatrix.scale(1.0 / r.width(), 1.0 / r.height(), 1);
+        textureMatrix.translate(-r.x(), -r.y(), 0);
+
+        // copy a two-dimensional texture subimage
+        glCopyTexSubImage2D(GL_TEXTURE_2D,
+                            0,
+                            0,
+                            0,
+                            (r.x() - sg.x()) * scale,
+                            (r.y() - sg.y()) * scale,
+                            m_texture.width(),
+                            m_texture.height());
 
-    auto const sg = effects->renderTargetRect();
-    glCopyTexSubImage2D(GL_TEXTURE_2D,
-                        0,
-                        0,
-                        0,
-                        (r.x() - sg.x()) * scale,
-                        (sg.height() - (r.y() - sg.y() + r.height())) * scale,
-                        scratch.width(),
-                        scratch.height());
+    } else {
+        // Set up the texture matrix to transform from screen coordinates
+        // to texture coordinates.
+        textureMatrix.scale(1.0 / r.width(), -1.0 / r.height(), 1);
+        textureMatrix.translate(-r.x(), -r.height() - r.y(), 0);
+
+        // copy a two-dimensional texture subimage
+        glCopyTexSubImage2D(GL_TEXTURE_2D,
+                            0,
+                            0,
+                            0,
+                            (r.x() - sg.x()) * scale,
+                            (sg.height() - (r.y() - sg.y() + r.height())) * scale,
+                            m_texture.width(),
+                            m_texture.height());
+    }
 
     // Draw the texture on the offscreen framebuffer object, while blurring it horizontally
-
     shader->setColorMatrix(m_colorMatrices.value(w));
     shader->bind();
-
     shader->setOpacity(opacity);
-    // Set up the texture matrix to transform from screen coordinates
-    // to texture coordinates.
-    QMatrix4x4 textureMatrix;
-    textureMatrix.scale(1.0 / r.width(), -1.0 / r.height(), 1);
-    textureMatrix.translate(-r.x(), -r.height() - r.y(), 0);
     shader->setTextureMatrix(textureMatrix);
     shader->setModelViewProjectionMatrix(screenProjection);
 
     vbo->draw(GL_TRIANGLES, 0, actualShape.rectCount() * 6);
 
-    scratch.unbind();
-    scratch.discard();
-
+    m_texture.unbind();
     vbo->unbindArrays();
 
     if (opacity < 1.0) {
-- 
GitLab

