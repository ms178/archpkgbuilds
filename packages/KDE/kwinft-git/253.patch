From 94e66ec916d759938f723f3bd7686bdf91abd501 Mon Sep 17 00:00:00 2001
From: Vlad Zahorodnii <vlad.zahorodnii@kde.org>
Date: Mon, 22 Nov 2021 16:19:48 +0200
Subject: [PATCH 01/62] refactor(effect): move WindowHeap in a qml module

The WindowHeap can be useful not only to the Overview effect, but also
other effects, e.g. a desktop grid replacement, etc.
---
 effect/effects/CMakeLists.txt             |   3 +
 effect/effects/private/CMakeLists.txt     |  22 +
 effect/effects/private/expoarea.cpp       |  83 +++
 effect/effects/private/expoarea.h         |  48 ++
 effect/effects/private/expolayout.cpp     | 717 ++++++++++++++++++++++
 effect/effects/private/expolayout.h       | 160 +++++
 effect/effects/private/plugin.cpp         |  18 +
 effect/effects/private/plugin.h           |  18 +
 effect/effects/private/qml/WindowHeap.qml | 542 ++++++++++++++++
 effect/effects/private/qmldir             |  10 +
 10 files changed, 1621 insertions(+)
 create mode 100644 effect/effects/private/CMakeLists.txt
 create mode 100644 effect/effects/private/expoarea.cpp
 create mode 100644 effect/effects/private/expoarea.h
 create mode 100644 effect/effects/private/expolayout.cpp
 create mode 100644 effect/effects/private/expolayout.h
 create mode 100644 effect/effects/private/plugin.cpp
 create mode 100644 effect/effects/private/plugin.h
 create mode 100644 effect/effects/private/qml/WindowHeap.qml
 create mode 100644 effect/effects/private/qmldir

diff --git a/effect/effects/CMakeLists.txt b/effect/effects/CMakeLists.txt
index 4f81a8471..277962b64 100644
--- a/effect/effects/CMakeLists.txt
+++ b/effect/effects/CMakeLists.txt
@@ -3,6 +3,9 @@ add_definitions(-DTRANSLATION_DOMAIN=\"kwin_effects\" -DEFFECT_BUILTINS)
 
 include_directories(${KWIN_SOURCE_DIR})
 
+add_subdirectory(private)
+
+
 function(kwin_add_effect_config name)
     list(REMOVE_ITEM ARGV ${name})
     kcoreaddons_add_plugin(${name} INSTALL_NAMESPACE "kwin/effects/configs" SOURCES ${ARGV})
diff --git a/effect/effects/private/CMakeLists.txt b/effect/effects/private/CMakeLists.txt
new file mode 100644
index 000000000..8a275b02f
--- /dev/null
+++ b/effect/effects/private/CMakeLists.txt
@@ -0,0 +1,22 @@
+# SPDX-FileCopyrightText: 2021 Vlad Zahorodnii <vlad.zahorodnii@kde.org>
+#
+# SPDX-License-Identifier: BSD-3-Clause
+
+add_library(effectsplugin
+    expoarea.cpp
+    expolayout.cpp
+    plugin.cpp
+)
+
+target_link_libraries(effectsplugin
+    kwineffects
+
+    Qt5::Core
+    Qt5::Gui
+    Qt5::Qml
+    Qt5::Quick
+)
+
+install(DIRECTORY qml/ DESTINATION ${KDE_INSTALL_QMLDIR}/org/kde/kwin/private/effects)
+install(TARGETS effectsplugin DESTINATION ${KDE_INSTALL_QMLDIR}/org/kde/kwin/private/effects)
+install(FILES qmldir DESTINATION ${KDE_INSTALL_QMLDIR}/org/kde/kwin/private/effects)
diff --git a/effect/effects/private/expoarea.cpp b/effect/effects/private/expoarea.cpp
new file mode 100644
index 000000000..90d0cab02
--- /dev/null
+++ b/effect/effects/private/expoarea.cpp
@@ -0,0 +1,83 @@
+/*
+    SPDX-FileCopyrightText: 2021 Vlad Zahorodnii <vlad.zahorodnii@kde.org>
+
+    SPDX-License-Identifier: GPL-2.0-or-later
+*/
+
+#include "expoarea.h"
+
+namespace KWin
+{
+
+ExpoArea::ExpoArea(QObject* parent)
+    : QObject(parent)
+{
+}
+
+int ExpoArea::x() const
+{
+    return m_rect.x();
+}
+
+int ExpoArea::y() const
+{
+    return m_rect.y();
+}
+
+int ExpoArea::width() const
+{
+    return m_rect.width();
+}
+
+int ExpoArea::height() const
+{
+    return m_rect.height();
+}
+
+EffectScreen* ExpoArea::screen() const
+{
+    return m_screen;
+}
+
+void ExpoArea::setScreen(EffectScreen* screen)
+{
+    if (m_screen != screen) {
+        if (m_screen) {
+            disconnect(m_screen, &EffectScreen::geometryChanged, this, &ExpoArea::update);
+        }
+        m_screen = screen;
+        if (m_screen) {
+            connect(m_screen, &EffectScreen::geometryChanged, this, &ExpoArea::update);
+        }
+        update();
+        Q_EMIT screenChanged();
+    }
+}
+
+void ExpoArea::update()
+{
+    if (!m_screen) {
+        return;
+    }
+    const QRect oldRect = m_rect;
+
+    m_rect = effects->clientArea(MaximizeArea, m_screen, effects->currentDesktop());
+
+    // Map the area to the output local coordinates.
+    m_rect.translate(-m_screen->geometry().topLeft());
+
+    if (oldRect.x() != m_rect.x()) {
+        Q_EMIT xChanged();
+    }
+    if (oldRect.y() != m_rect.y()) {
+        Q_EMIT yChanged();
+    }
+    if (oldRect.width() != m_rect.width()) {
+        Q_EMIT widthChanged();
+    }
+    if (oldRect.height() != m_rect.height()) {
+        Q_EMIT heightChanged();
+    }
+}
+
+} // namespace KWin
diff --git a/effect/effects/private/expoarea.h b/effect/effects/private/expoarea.h
new file mode 100644
index 000000000..02b613e68
--- /dev/null
+++ b/effect/effects/private/expoarea.h
@@ -0,0 +1,48 @@
+/*
+    SPDX-FileCopyrightText: 2021 Vlad Zahorodnii <vlad.zahorodnii@kde.org>
+
+    SPDX-License-Identifier: GPL-2.0-or-later
+*/
+
+#pragma once
+
+#include <kwineffects.h>
+
+namespace KWin
+{
+
+class ExpoArea : public QObject
+{
+    Q_OBJECT
+    Q_PROPERTY(KWin::EffectScreen* screen READ screen WRITE setScreen NOTIFY screenChanged)
+    Q_PROPERTY(int x READ x NOTIFY xChanged)
+    Q_PROPERTY(int y READ y NOTIFY yChanged)
+    Q_PROPERTY(int width READ width NOTIFY widthChanged)
+    Q_PROPERTY(int height READ height NOTIFY heightChanged)
+
+public:
+    explicit ExpoArea(QObject* parent = nullptr);
+
+    EffectScreen* screen() const;
+    void setScreen(EffectScreen* screen);
+
+    int x() const;
+    int y() const;
+    int width() const;
+    int height() const;
+
+Q_SIGNALS:
+    void screenChanged();
+    void xChanged();
+    void yChanged();
+    void widthChanged();
+    void heightChanged();
+
+private:
+    void update();
+
+    QRect m_rect;
+    EffectScreen* m_screen = nullptr;
+};
+
+} // namespace KWin
diff --git a/effect/effects/private/expolayout.cpp b/effect/effects/private/expolayout.cpp
new file mode 100644
index 000000000..50ca8d2b8
--- /dev/null
+++ b/effect/effects/private/expolayout.cpp
@@ -0,0 +1,717 @@
+/*
+    SPDX-FileCopyrightText: 2021 Vlad Zahorodnii <vlad.zahorodnii@kde.org>
+
+    // The layouting code is taken from the present windows effect.
+    SPDX-FileCopyrightText: 2007 Rivo Laks <rivolaks@hot.ee>
+    SPDX-FileCopyrightText: 2008 Lucas Murray <lmurray@undefinedfire.com>
+
+    SPDX-License-Identifier: GPL-2.0-or-later
+*/
+
+#include "expolayout.h"
+
+#include <cmath>
+
+ExpoCell::ExpoCell(QObject* parent)
+    : QObject(parent)
+{
+}
+
+ExpoCell::~ExpoCell()
+{
+    setLayout(nullptr);
+}
+
+ExpoLayout* ExpoCell::layout() const
+{
+    return m_layout;
+}
+
+void ExpoCell::setLayout(ExpoLayout* layout)
+{
+    if (m_layout == layout) {
+        return;
+    }
+    if (m_layout) {
+        m_layout->removeCell(this);
+    }
+    m_layout = layout;
+    if (m_layout) {
+        m_layout->addCell(this);
+    }
+    Q_EMIT layoutChanged();
+}
+
+void ExpoCell::update()
+{
+    if (m_layout) {
+        m_layout->polish();
+    }
+}
+
+int ExpoCell::naturalX() const
+{
+    return m_naturalX;
+}
+
+void ExpoCell::setNaturalX(int x)
+{
+    if (m_naturalX != x) {
+        m_naturalX = x;
+        update();
+        Q_EMIT naturalXChanged();
+
+        if (!m_x.has_value()) {
+            m_x = x;
+            Q_EMIT xChanged();
+        }
+    }
+}
+
+int ExpoCell::naturalY() const
+{
+    return m_naturalY;
+}
+
+void ExpoCell::setNaturalY(int y)
+{
+    if (m_naturalY != y) {
+        m_naturalY = y;
+        update();
+        Q_EMIT naturalYChanged();
+
+        if (!m_y.has_value()) {
+            m_y = y;
+            Q_EMIT yChanged();
+        }
+    }
+}
+
+int ExpoCell::naturalWidth() const
+{
+    return m_naturalWidth;
+}
+
+void ExpoCell::setNaturalWidth(int width)
+{
+    if (m_naturalWidth != width) {
+        m_naturalWidth = width;
+        update();
+        Q_EMIT naturalWidthChanged();
+
+        if (!m_width.has_value()) {
+            m_width = width;
+            Q_EMIT widthChanged();
+        }
+    }
+}
+
+int ExpoCell::naturalHeight() const
+{
+    return m_naturalHeight;
+}
+
+void ExpoCell::setNaturalHeight(int height)
+{
+    if (m_naturalHeight != height) {
+        m_naturalHeight = height;
+        update();
+        Q_EMIT naturalHeightChanged();
+
+        if (!m_height.has_value()) {
+            m_height = height;
+            Q_EMIT heightChanged();
+        }
+    }
+}
+
+QRect ExpoCell::naturalRect() const
+{
+    return QRect(naturalX(), naturalY(), naturalWidth(), naturalHeight());
+}
+
+QMargins ExpoCell::margins() const
+{
+    return m_margins;
+}
+
+int ExpoCell::x() const
+{
+    return m_x.value_or(0);
+}
+
+void ExpoCell::setX(int x)
+{
+    if (m_x != x) {
+        m_x = x;
+        Q_EMIT xChanged();
+    }
+}
+
+int ExpoCell::y() const
+{
+    return m_y.value_or(0);
+}
+
+void ExpoCell::setY(int y)
+{
+    if (m_y != y) {
+        m_y = y;
+        Q_EMIT yChanged();
+    }
+}
+
+int ExpoCell::width() const
+{
+    return m_width.value_or(0);
+}
+
+void ExpoCell::setWidth(int width)
+{
+    if (m_width != width) {
+        m_width = width;
+        Q_EMIT widthChanged();
+    }
+}
+
+int ExpoCell::height() const
+{
+    return m_height.value_or(0);
+}
+
+void ExpoCell::setHeight(int height)
+{
+    if (m_height != height) {
+        m_height = height;
+        Q_EMIT heightChanged();
+    }
+}
+
+QString ExpoCell::persistentKey() const
+{
+    return m_persistentKey;
+}
+
+void ExpoCell::setPersistentKey(const QString& key)
+{
+    if (m_persistentKey != key) {
+        m_persistentKey = key;
+        update();
+        Q_EMIT persistentKeyChanged();
+    }
+}
+
+int ExpoCell::bottomMargin() const
+{
+    return m_margins.bottom();
+}
+
+void ExpoCell::setBottomMargin(int margin)
+{
+    if (m_margins.bottom() != margin) {
+        m_margins.setBottom(margin);
+        update();
+        Q_EMIT bottomMarginChanged();
+    }
+}
+
+ExpoLayout::ExpoLayout(QQuickItem* parent)
+    : QQuickItem(parent)
+{
+}
+
+ExpoLayout::LayoutMode ExpoLayout::mode() const
+{
+    return m_mode;
+}
+
+void ExpoLayout::setMode(LayoutMode mode)
+{
+    if (m_mode != mode) {
+        m_mode = mode;
+        polish();
+        Q_EMIT modeChanged();
+    }
+}
+
+bool ExpoLayout::fillGaps() const
+{
+    return m_fillGaps;
+}
+
+void ExpoLayout::setFillGaps(bool fill)
+{
+    if (m_fillGaps != fill) {
+        m_fillGaps = fill;
+        polish();
+        Q_EMIT fillGapsChanged();
+    }
+}
+
+int ExpoLayout::spacing() const
+{
+    return m_spacing;
+}
+
+void ExpoLayout::setSpacing(int spacing)
+{
+    if (m_spacing != spacing) {
+        m_spacing = spacing;
+        polish();
+        Q_EMIT spacingChanged();
+    }
+}
+
+bool ExpoLayout::isReady() const
+{
+    return m_ready;
+}
+
+void ExpoLayout::setReady()
+{
+    if (!m_ready) {
+        m_ready = true;
+        Q_EMIT readyChanged();
+    }
+}
+
+void ExpoLayout::updatePolish()
+{
+    if (!m_cells.isEmpty()) {
+        switch (m_mode) {
+        case LayoutClosest:
+            calculateWindowTransformationsClosest();
+            break;
+        case LayoutNatural:
+            calculateWindowTransformationsNatural();
+            break;
+        }
+    }
+
+    setReady();
+}
+
+void ExpoLayout::addCell(ExpoCell* cell)
+{
+    Q_ASSERT(!m_cells.contains(cell));
+    m_cells.append(cell);
+    polish();
+}
+
+void ExpoLayout::removeCell(ExpoCell* cell)
+{
+    m_cells.removeOne(cell);
+    polish();
+}
+
+#if QT_VERSION < QT_VERSION_CHECK(6, 0, 0)
+void ExpoLayout::geometryChanged(const QRectF& newGeometry, const QRectF& oldGeometry)
+#else
+void ExpoLayout::geometryChange(const QRectF& newGeometry, const QRectF& oldGeometry)
+#endif
+{
+    if (newGeometry.size() != oldGeometry.size()) {
+        polish();
+    }
+#if QT_VERSION < QT_VERSION_CHECK(6, 0, 0)
+    QQuickItem::geometryChanged(newGeometry, oldGeometry);
+#else
+    QQuickItem::geometryChange(newGeometry, oldGeometry);
+#endif
+}
+
+static int distance(const QPoint& a, const QPoint& b)
+{
+    const int xdiff = a.x() - b.x();
+    const int ydiff = a.y() - b.y();
+    return int(std::sqrt(qreal(xdiff * xdiff + ydiff * ydiff)));
+}
+
+static QRect centered(ExpoCell* cell, const QRect& bounds)
+{
+    const QSize scaled = QSize(cell->naturalWidth(), cell->naturalHeight())
+                             .scaled(bounds.size(), Qt::KeepAspectRatio);
+
+    return QRect(bounds.center().x() - scaled.width() / 2,
+                 bounds.center().y() - scaled.height() / 2,
+                 scaled.width(),
+                 scaled.height());
+}
+
+void ExpoLayout::calculateWindowTransformationsClosest()
+{
+    QRect area = QRect(0, 0, width(), height());
+    const int columns = int(std::ceil(std::sqrt(qreal(m_cells.count()))));
+    const int rows = int(std::ceil(m_cells.count() / qreal(columns)));
+
+    // Assign slots
+    const int slotWidth = area.width() / columns;
+    const int slotHeight = area.height() / rows;
+    QVector<ExpoCell*> takenSlots;
+    takenSlots.resize(rows * columns);
+    takenSlots.fill(nullptr);
+
+    // precalculate all slot centers
+    QVector<QPoint> slotCenters;
+    slotCenters.resize(rows * columns);
+    for (int x = 0; x < columns; ++x) {
+        for (int y = 0; y < rows; ++y) {
+            slotCenters[x + y * columns] = QPoint(area.x() + slotWidth * x + slotWidth / 2,
+                                                  area.y() + slotHeight * y + slotHeight / 2);
+        }
+    }
+
+    // Assign each window to the closest available slot
+    QList<ExpoCell*> tmpList = m_cells; // use a QLinkedList copy instead?
+    while (!tmpList.isEmpty()) {
+        ExpoCell* cell = tmpList.first();
+        int slotCandidate = -1, slotCandidateDistance = INT_MAX;
+        const QPoint pos = cell->naturalRect().center();
+
+        for (int i = 0; i < columns * rows; ++i) { // all slots
+            const int dist = distance(pos, slotCenters[i]);
+            if (dist < slotCandidateDistance) { // window is interested in this slot
+                ExpoCell* occupier = takenSlots[i];
+                Q_ASSERT(occupier != cell);
+                if (!occupier
+                    || dist < distance(occupier->naturalRect().center(), slotCenters[i])) {
+                    // either nobody lives here, or we're better - takeover the slot if it's our
+                    // best
+                    slotCandidate = i;
+                    slotCandidateDistance = dist;
+                }
+            }
+        }
+        Q_ASSERT(slotCandidate != -1);
+        if (takenSlots[slotCandidate]) {
+            tmpList << takenSlots[slotCandidate]; // occupier needs a new home now :p
+        }
+        tmpList.removeAll(cell);
+        takenSlots[slotCandidate] = cell; // ...and we rumble in =)
+    }
+
+    for (int slot = 0; slot < columns * rows; ++slot) {
+        ExpoCell* cell = takenSlots[slot];
+        if (!cell) { // some slots might be empty
+            continue;
+        }
+
+        // Work out where the slot is
+        QRect target(area.x() + (slot % columns) * slotWidth,
+                     area.y() + (slot / columns) * slotHeight,
+                     slotWidth,
+                     slotHeight);
+        target.adjust(m_spacing, m_spacing, -m_spacing, -m_spacing); // Borders
+        target = target.marginsRemoved(cell->margins());
+
+        qreal scale;
+        if (target.width() / qreal(cell->naturalWidth())
+            < target.height() / qreal(cell->naturalHeight())) {
+            // Center vertically
+            scale = target.width() / qreal(cell->naturalWidth());
+            target.moveTop(target.top()
+                           + (target.height() - int(cell->naturalHeight() * scale)) / 2);
+            target.setHeight(int(cell->naturalHeight() * scale));
+        } else {
+            // Center horizontally
+            scale = target.height() / qreal(cell->naturalHeight());
+            target.moveLeft(target.left()
+                            + (target.width() - int(cell->naturalWidth() * scale)) / 2);
+            target.setWidth(int(cell->naturalWidth() * scale));
+        }
+        // Don't scale the windows too much
+        if (scale > 2.0
+            || (scale > 1.0 && (cell->naturalWidth() > 300 || cell->naturalHeight() > 300))) {
+            scale = (cell->naturalWidth() > 300 || cell->naturalHeight() > 300) ? 1.0 : 2.0;
+            target = QRect(target.center().x() - int(cell->naturalWidth() * scale) / 2,
+                           target.center().y() - int(cell->naturalHeight() * scale) / 2,
+                           scale * cell->naturalWidth(),
+                           scale * cell->naturalHeight());
+        }
+
+        cell->setX(target.x());
+        cell->setY(target.y());
+        cell->setWidth(target.width());
+        cell->setHeight(target.height());
+    }
+}
+
+static inline int heightForWidth(ExpoCell* cell, int width)
+{
+    return int((width / qreal(cell->naturalWidth())) * cell->naturalHeight());
+}
+
+static bool isOverlappingAny(ExpoCell* w,
+                             const QHash<ExpoCell*, QRect>& targets,
+                             const QRegion& border,
+                             int spacing)
+{
+    QHash<ExpoCell*, QRect>::const_iterator winTarget = targets.find(w);
+    if (winTarget == targets.constEnd()) {
+        return false;
+    }
+    if (border.intersects(*winTarget)) {
+        return true;
+    }
+    const QMargins halfSpacing(spacing / 2, spacing / 2, spacing / 2, spacing / 2);
+
+    // Is there a better way to do this?
+    QHash<ExpoCell*, QRect>::const_iterator target;
+    for (target = targets.constBegin(); target != targets.constEnd(); ++target) {
+        if (target == winTarget) {
+            continue;
+        }
+        if (winTarget->marginsAdded(halfSpacing).intersects(target->marginsAdded(halfSpacing))) {
+            return true;
+        }
+    }
+    return false;
+}
+
+void ExpoLayout::calculateWindowTransformationsNatural()
+{
+    const QRect area = QRect(0, 0, width(), height());
+
+    // As we are using pseudo-random movement (See "slot") we need to make sure the list
+    // is always sorted the same way no matter which window is currently active.
+    std::sort(m_cells.begin(), m_cells.end(), [](const ExpoCell* a, const ExpoCell* b) {
+        return a->persistentKey() < b->persistentKey();
+    });
+
+    QRect bounds;
+    int direction = 0;
+    QHash<ExpoCell*, QRect> targets;
+    QHash<ExpoCell*, int> directions;
+
+    for (ExpoCell* cell : qAsConst(m_cells)) {
+        const QRect cellRect(
+            cell->naturalX(), cell->naturalY(), cell->naturalWidth(), cell->naturalHeight());
+        targets[cell] = cellRect;
+        // Reuse the unused "slot" as a preferred direction attribute. This is used when the window
+        // is on the edge of the screen to try to use as much screen real estate as possible.
+        directions[cell] = direction;
+        bounds = bounds.united(cellRect);
+        direction++;
+        if (direction == 4) {
+            direction = 0;
+        }
+    }
+
+    // Iterate over all windows, if two overlap push them apart _slightly_ as we try to
+    // brute-force the most optimal positions over many iterations.
+    const int halfSpacing = m_spacing / 2;
+    bool overlap;
+    do {
+        overlap = false;
+        for (ExpoCell* cell : qAsConst(m_cells)) {
+            QRect* target_w = &targets[cell];
+            for (ExpoCell* e : qAsConst(m_cells)) {
+                if (cell == e) {
+                    continue;
+                }
+
+                QRect* target_e = &targets[e];
+                if (target_w->adjusted(-halfSpacing, -halfSpacing, halfSpacing, halfSpacing)
+                        .intersects(target_e->adjusted(
+                            -halfSpacing, -halfSpacing, halfSpacing, halfSpacing))) {
+                    overlap = true;
+
+                    // Determine pushing direction
+                    QPoint diff(target_e->center() - target_w->center());
+                    // Prevent dividing by zero and non-movement
+                    if (diff.x() == 0 && diff.y() == 0) {
+                        diff.setX(1);
+                    }
+                    // Try to keep screen aspect ratio
+                    // if (bounds.height() / bounds.width() > area.height() / area.width())
+                    //    diff.setY(diff.y() / 2);
+                    // else
+                    //    diff.setX(diff.x() / 2);
+                    // Approximate a vector of between 10px and 20px in magnitude in the same
+                    // direction
+                    diff *= m_accuracy / qreal(diff.manhattanLength());
+                    // Move both windows apart
+                    target_w->translate(-diff);
+                    target_e->translate(diff);
+
+                    // Try to keep the bounding rect the same aspect as the screen so that more
+                    // screen real estate is utilised. We do this by splitting the screen into nine
+                    // equal sections, if the window center is in any of the corner sections pull
+                    // the window towards the outer corner. If it is in any of the other edge
+                    // sections alternate between each corner on that edge. We don't want to
+                    // determine it randomly as it will not produce consistant locations when using
+                    // the filter. Only move one window so we don't cause large amounts of
+                    // unnecessary zooming in some situations. We need to do this even when
+                    // expanding later just in case all windows are the same size. (We are using an
+                    // old bounding rect for this, hopefully it doesn't matter)
+                    int xSection = (target_w->x() - bounds.x()) / (bounds.width() / 3);
+                    int ySection = (target_w->y() - bounds.y()) / (bounds.height() / 3);
+                    diff = QPoint(0, 0);
+                    if (xSection != 1
+                        || ySection != 1) { // Remove this if you want the center to pull as well
+                        if (xSection == 1) {
+                            xSection = (directions[cell] / 2 ? 2 : 0);
+                        }
+                        if (ySection == 1) {
+                            ySection = (directions[cell] % 2 ? 2 : 0);
+                        }
+                    }
+                    if (xSection == 0 && ySection == 0) {
+                        diff = QPoint(bounds.topLeft() - target_w->center());
+                    }
+                    if (xSection == 2 && ySection == 0) {
+                        diff = QPoint(bounds.topRight() - target_w->center());
+                    }
+                    if (xSection == 2 && ySection == 2) {
+                        diff = QPoint(bounds.bottomRight() - target_w->center());
+                    }
+                    if (xSection == 0 && ySection == 2) {
+                        diff = QPoint(bounds.bottomLeft() - target_w->center());
+                    }
+                    if (diff.x() != 0 || diff.y() != 0) {
+                        diff *= m_accuracy / qreal(diff.manhattanLength());
+                        target_w->translate(diff);
+                    }
+
+                    // Update bounding rect
+                    bounds = bounds.united(*target_w);
+                    bounds = bounds.united(*target_e);
+                }
+            }
+        }
+    } while (overlap);
+
+    // Compute the scale factor so the bounding rect fits the target area.
+    qreal scale;
+    if (bounds.width() <= area.width() && bounds.height() <= area.height()) {
+        scale = 1.0;
+    } else if (area.width() / qreal(bounds.width()) < area.height() / qreal(bounds.height())) {
+        scale = area.width() / qreal(bounds.width());
+    } else {
+        scale = area.height() / qreal(bounds.height());
+    }
+    // Make bounding rect fill the screen size for later steps
+    bounds = QRect(bounds.x() - (area.width() / scale - bounds.width()) / 2,
+                   bounds.y() - (area.height() / scale - bounds.height()) / 2,
+                   area.width() / scale,
+                   area.height() / scale);
+
+    // Move all windows back onto the screen and set their scale
+    QHash<ExpoCell*, QRect>::iterator target = targets.begin();
+    while (target != targets.end()) {
+        target->setRect((target->x() - bounds.x()) * scale + area.x(),
+                        (target->y() - bounds.y()) * scale + area.y(),
+                        target->width() * scale,
+                        target->height() * scale);
+        ++target;
+    }
+
+    // Try to fill the gaps by enlarging windows if they have the space
+    if (m_fillGaps) {
+        // Don't expand onto or over the border
+        QRegion borderRegion(area.adjusted(-200, -200, 200, 200));
+        borderRegion ^= area;
+
+        bool moved;
+        do {
+            moved = false;
+            for (ExpoCell* cell : qAsConst(m_cells)) {
+                QRect oldRect;
+                QRect* target = &targets[cell];
+                // This may cause some slight distortion if the windows are enlarged a large amount
+                int widthDiff = m_accuracy;
+                int heightDiff
+                    = heightForWidth(cell, target->width() + widthDiff) - target->height();
+                int xDiff
+                    = widthDiff / 2; // Also move a bit in the direction of the enlarge, allows the
+                int yDiff
+                    = heightDiff / 2; // center windows to be enlarged if there is gaps on the side.
+
+                // heightDiff (and yDiff) will be re-computed after each successful enlargement
+                // attempt so that the error introduced in the window's aspect ratio is minimized
+
+                // Attempt enlarging to the top-right
+                oldRect = *target;
+                target->setRect(target->x() + xDiff,
+                                target->y() - yDiff - heightDiff,
+                                target->width() + widthDiff,
+                                target->height() + heightDiff);
+                if (isOverlappingAny(cell, targets, borderRegion, m_spacing)) {
+                    *target = oldRect;
+                } else {
+                    moved = true;
+                    heightDiff
+                        = heightForWidth(cell, target->width() + widthDiff) - target->height();
+                    yDiff = heightDiff / 2;
+                }
+
+                // Attempt enlarging to the bottom-right
+                oldRect = *target;
+                target->setRect(target->x() + xDiff,
+                                target->y() + yDiff,
+                                target->width() + widthDiff,
+                                target->height() + heightDiff);
+                if (isOverlappingAny(cell, targets, borderRegion, m_spacing)) {
+                    *target = oldRect;
+                } else {
+                    moved = true;
+                    heightDiff
+                        = heightForWidth(cell, target->width() + widthDiff) - target->height();
+                    yDiff = heightDiff / 2;
+                }
+
+                // Attempt enlarging to the bottom-left
+                oldRect = *target;
+                target->setRect(target->x() - xDiff - widthDiff,
+                                target->y() + yDiff,
+                                target->width() + widthDiff,
+                                target->height() + heightDiff);
+                if (isOverlappingAny(cell, targets, borderRegion, m_spacing)) {
+                    *target = oldRect;
+                } else {
+                    moved = true;
+                    heightDiff
+                        = heightForWidth(cell, target->width() + widthDiff) - target->height();
+                    yDiff = heightDiff / 2;
+                }
+
+                // Attempt enlarging to the top-left
+                oldRect = *target;
+                target->setRect(target->x() - xDiff - widthDiff,
+                                target->y() - yDiff - heightDiff,
+                                target->width() + widthDiff,
+                                target->height() + heightDiff);
+                if (isOverlappingAny(cell, targets, borderRegion, m_spacing)) {
+                    *target = oldRect;
+                } else {
+                    moved = true;
+                }
+            }
+        } while (moved);
+
+        // The expanding code above can actually enlarge windows over 1.0/2.0 scale, we don't like
+        // this We can't add this to the loop above as it would cause a never-ending loop so we have
+        // to make do with the less-than-optimal space usage with using this method.
+        for (ExpoCell* cell : qAsConst(m_cells)) {
+            QRect* target = &targets[cell];
+            qreal scale = target->width() / qreal(cell->naturalWidth());
+            if (scale > 2.0
+                || (scale > 1.0 && (cell->naturalWidth() > 300 || cell->naturalHeight() > 300))) {
+                scale = (cell->naturalWidth() > 300 || cell->naturalHeight() > 300) ? 1.0 : 2.0;
+                target->setRect(target->center().x() - int(cell->naturalWidth() * scale) / 2,
+                                target->center().y() - int(cell->naturalHeight() * scale) / 2,
+                                cell->naturalWidth() * scale,
+                                cell->naturalHeight() * scale);
+            }
+        }
+    }
+
+    for (ExpoCell* cell : qAsConst(m_cells)) {
+        const QRect rect = centered(cell, targets.value(cell).marginsRemoved(cell->margins()));
+
+        cell->setX(rect.x());
+        cell->setY(rect.y());
+        cell->setWidth(rect.width());
+        cell->setHeight(rect.height());
+    }
+}
diff --git a/effect/effects/private/expolayout.h b/effect/effects/private/expolayout.h
new file mode 100644
index 000000000..1ce41633a
--- /dev/null
+++ b/effect/effects/private/expolayout.h
@@ -0,0 +1,160 @@
+/*
+    SPDX-FileCopyrightText: 2021 Vlad Zahorodnii <vlad.zahorodnii@kde.org>
+
+    SPDX-License-Identifier: GPL-2.0-or-later
+*/
+
+#pragma once
+
+#include <QObject>
+#include <QQuickItem>
+#include <QRect>
+
+#include <optional>
+
+class ExpoCell;
+
+class ExpoLayout : public QQuickItem
+{
+    Q_OBJECT
+    Q_PROPERTY(LayoutMode mode READ mode WRITE setMode NOTIFY modeChanged)
+    Q_PROPERTY(bool fillGaps READ fillGaps WRITE setFillGaps NOTIFY fillGapsChanged)
+    Q_PROPERTY(int spacing READ spacing WRITE setSpacing NOTIFY spacingChanged)
+    Q_PROPERTY(bool ready READ isReady NOTIFY readyChanged)
+
+public:
+    enum LayoutMode : uint {
+        LayoutClosest = 0,
+        LayoutNatural = 1,
+    };
+    Q_ENUM(LayoutMode)
+
+    explicit ExpoLayout(QQuickItem* parent = nullptr);
+
+    LayoutMode mode() const;
+    void setMode(LayoutMode mode);
+
+    bool fillGaps() const;
+    void setFillGaps(bool fill);
+
+    int spacing() const;
+    void setSpacing(int spacing);
+
+    void addCell(ExpoCell* cell);
+    void removeCell(ExpoCell* cell);
+
+    bool isReady() const;
+    void setReady();
+
+protected:
+#if QT_VERSION < QT_VERSION_CHECK(6, 0, 0)
+    void geometryChanged(const QRectF& newGeometry, const QRectF& oldGeometry) override;
+#else
+    void geometryChange(const QRectF& newGeometry, const QRectF& oldGeometry) override;
+#endif
+    void updatePolish() override;
+
+Q_SIGNALS:
+    void modeChanged();
+    void fillGapsChanged();
+    void spacingChanged();
+    void readyChanged();
+
+private:
+    void calculateWindowTransformationsClosest();
+    void calculateWindowTransformationsNatural();
+
+    QList<ExpoCell*> m_cells;
+    LayoutMode m_mode = LayoutNatural;
+    int m_accuracy = 20;
+    int m_spacing = 10;
+    bool m_ready = false;
+    bool m_fillGaps = false;
+};
+
+class ExpoCell : public QObject
+{
+    Q_OBJECT
+    Q_PROPERTY(ExpoLayout* layout READ layout WRITE setLayout NOTIFY layoutChanged)
+    Q_PROPERTY(int naturalX READ naturalX WRITE setNaturalX NOTIFY naturalXChanged)
+    Q_PROPERTY(int naturalY READ naturalY WRITE setNaturalY NOTIFY naturalYChanged)
+    Q_PROPERTY(int naturalWidth READ naturalWidth WRITE setNaturalWidth NOTIFY naturalWidthChanged)
+    Q_PROPERTY(
+        int naturalHeight READ naturalHeight WRITE setNaturalHeight NOTIFY naturalHeightChanged)
+    Q_PROPERTY(int x READ x NOTIFY xChanged)
+    Q_PROPERTY(int y READ y NOTIFY yChanged)
+    Q_PROPERTY(int width READ width NOTIFY widthChanged)
+    Q_PROPERTY(int height READ height NOTIFY heightChanged)
+    Q_PROPERTY(
+        QString persistentKey READ persistentKey WRITE setPersistentKey NOTIFY persistentKeyChanged)
+    Q_PROPERTY(int bottomMargin READ bottomMargin WRITE setBottomMargin NOTIFY bottomMarginChanged)
+
+public:
+    explicit ExpoCell(QObject* parent = nullptr);
+    ~ExpoCell() override;
+
+    ExpoLayout* layout() const;
+    void setLayout(ExpoLayout* layout);
+
+    int naturalX() const;
+    void setNaturalX(int x);
+
+    int naturalY() const;
+    void setNaturalY(int y);
+
+    int naturalWidth() const;
+    void setNaturalWidth(int width);
+
+    int naturalHeight() const;
+    void setNaturalHeight(int height);
+
+    QRect naturalRect() const;
+    QMargins margins() const;
+
+    int x() const;
+    void setX(int x);
+
+    int y() const;
+    void setY(int y);
+
+    int width() const;
+    void setWidth(int width);
+
+    int height() const;
+    void setHeight(int height);
+
+    QString persistentKey() const;
+    void setPersistentKey(const QString& key);
+
+    int bottomMargin() const;
+    void setBottomMargin(int margin);
+
+public Q_SLOTS:
+    void update();
+
+Q_SIGNALS:
+    void layoutChanged();
+    void naturalXChanged();
+    void naturalYChanged();
+    void naturalWidthChanged();
+    void naturalHeightChanged();
+    void xChanged();
+    void yChanged();
+    void widthChanged();
+    void heightChanged();
+    void persistentKeyChanged();
+    void bottomMarginChanged();
+
+private:
+    QString m_persistentKey;
+    int m_naturalX = 0;
+    int m_naturalY = 0;
+    int m_naturalWidth = 0;
+    int m_naturalHeight = 0;
+    QMargins m_margins;
+    std::optional<int> m_x;
+    std::optional<int> m_y;
+    std::optional<int> m_width;
+    std::optional<int> m_height;
+    QPointer<ExpoLayout> m_layout;
+};
diff --git a/effect/effects/private/plugin.cpp b/effect/effects/private/plugin.cpp
new file mode 100644
index 000000000..0230b2f33
--- /dev/null
+++ b/effect/effects/private/plugin.cpp
@@ -0,0 +1,18 @@
+/*
+    SPDX-FileCopyrightText: 2021 Vlad Zahorodnii <vlad.zahorodnii@kde.org>
+
+    SPDX-License-Identifier: GPL-2.0-or-later
+*/
+
+#include "plugin.h"
+#include "expoarea.h"
+#include "expolayout.h"
+
+#include <QQmlEngine>
+
+void EffectKitExtensionPlugin::registerTypes(const char* uri)
+{
+    qmlRegisterType<KWin::ExpoArea>(uri, 1, 0, "ExpoArea");
+    qmlRegisterType<ExpoLayout>(uri, 1, 0, "ExpoLayout");
+    qmlRegisterType<ExpoCell>(uri, 1, 0, "ExpoCell");
+}
diff --git a/effect/effects/private/plugin.h b/effect/effects/private/plugin.h
new file mode 100644
index 000000000..f22ca3cf7
--- /dev/null
+++ b/effect/effects/private/plugin.h
@@ -0,0 +1,18 @@
+/*
+    SPDX-FileCopyrightText: 2021 Vlad Zahorodnii <vlad.zahorodnii@kde.org>
+
+    SPDX-License-Identifier: GPL-3.0-or-later
+*/
+
+#pragma once
+
+#include <QQmlExtensionPlugin>
+
+class EffectKitExtensionPlugin : public QQmlExtensionPlugin
+{
+    Q_OBJECT
+    Q_PLUGIN_METADATA(IID "org.qt-project.Qt.QQmlExtensionInterface")
+
+public:
+    void registerTypes(const char* uri) override;
+};
diff --git a/effect/effects/private/qml/WindowHeap.qml b/effect/effects/private/qml/WindowHeap.qml
new file mode 100644
index 000000000..869eb5df7
--- /dev/null
+++ b/effect/effects/private/qml/WindowHeap.qml
@@ -0,0 +1,542 @@
+/*
+    SPDX-FileCopyrightText: 2021 Vlad Zahorodnii <vlad.zahorodnii@kde.org>
+
+    SPDX-License-Identifier: GPL-2.0-or-later
+*/
+
+import QtQuick 2.12
+import org.kde.kirigami 2.12 as Kirigami
+import org.kde.kwin 3.0 as KWinComponents
+import org.kde.kwin.private.effects 1.0
+import org.kde.plasma.components 3.0 as PC3
+import org.kde.plasma.core 2.0 as PlasmaCore
+
+FocusScope {
+    id: heap
+
+    enum Direction {
+        Left,
+        Right,
+        Up,
+        Down
+    }
+
+    property alias model: windowsRepeater.model
+    property alias layout: expoLayout.mode
+    property int selectedIndex: -1
+    property int animationDuration: PlasmaCore.Units.longDuration
+    property bool animationEnabled: false
+    property real padding: 0
+
+    required property bool organized
+    readonly property bool effectiveOrganized: expoLayout.ready && organized
+
+    signal activated()
+
+    ExpoLayout {
+        id: expoLayout
+        x: heap.padding
+        y: heap.padding
+        width: parent.width - 2 * heap.padding
+        height: parent.height - 2 * heap.padding
+        spacing: PlasmaCore.Units.largeSpacing
+
+        Repeater {
+            id: windowsRepeater
+
+            Item {
+                id: thumb
+
+                required property QtObject client
+                required property int index
+
+                readonly property bool selected: heap.selectedIndex == index
+
+                state: {
+                    if (effect.gestureInProgress) {
+                        return "partial";
+                    }
+                    if (heap.effectiveOrganized) {
+                        return "active";
+                    }
+                    return client.minimized ? "initial-minimized" : "initial";
+                }
+
+                visible: opacity > 0
+                z: thumb.activeDragHandler.active ? 100 : client.stackingOrder
+
+                component TweenBehavior : Behavior {
+                    enabled: thumb.state !== "partial" && heap.animationEnabled && !thumb.activeDragHandler.active
+                    NumberAnimation {
+                        duration: effect.animationDuration
+                        easing.type: Easing.OutCubic
+                    }
+                }
+
+                TweenBehavior on x {}
+                TweenBehavior on y {}
+                TweenBehavior on width {}
+                TweenBehavior on height {}
+
+                KWinComponents.WindowThumbnailItem {
+                    id: thumbSource
+                    wId: thumb.client.internalId
+                    state: thumb.activeDragHandler.active ? "drag" : "normal"
+
+                    Drag.active: thumb.activeDragHandler.active
+                    Drag.source: thumb.client
+                    Drag.hotSpot: Qt.point(width * 0.5, height * 0.5)
+
+                    states: [
+                        State {
+                            name: "normal"
+                            PropertyChanges {
+                                target: thumbSource
+                                x: 0
+                                y: 0
+                                width: thumb.width
+                                height: thumb.height
+                            }
+                        },
+                        State {
+                            name: "drag"
+                            PropertyChanges {
+                                target: thumbSource
+                                x: -thumb.activeDragHandler.centroid.pressPosition.x * thumb.activeDragHandler.targetScale +
+                                        thumb.activeDragHandler.centroid.position.x
+                                y: -thumb.activeDragHandler.centroid.pressPosition.y * thumb.activeDragHandler.targetScale +
+                                        thumb.activeDragHandler.centroid.position.y
+                                width: cell.width * thumb.activeDragHandler.targetScale
+                                height: cell.height * thumb.activeDragHandler.targetScale
+                                opacity: thumb.activeDragHandler.targetOpacity
+                            }
+                        }
+                    ]
+                    transitions: Transition {
+                        to: "normal"
+                        enabled: heap.animationEnabled
+                        NumberAnimation {
+                            duration: effect.animationDuration
+                            properties: "x, y, width, height, opacity"
+                            easing.type: Easing.OutCubic
+                        }
+                    }
+
+                    MouseArea {
+                        anchors.fill: parent
+                        acceptedButtons: Qt.NoButton
+                        cursorShape: thumb.activeDragHandler.active ? Qt.ClosedHandCursor : Qt.ArrowCursor
+                    }
+                }
+
+                PC3.Label {
+                    anchors.fill: thumbSource
+                    horizontalAlignment: Text.AlignHCenter
+                    verticalAlignment: Text.AlignVCenter
+                    text: i18nd("kwin_effects", "Drag Down To Close")
+                    opacity: 1 - thumbSource.opacity
+                }
+
+                PlasmaCore.IconItem {
+                    id: icon
+                    width: PlasmaCore.Units.iconSizes.large
+                    height: width
+                    source: thumb.client.icon
+                    anchors.horizontalCenter: thumbSource.horizontalCenter
+                    anchors.bottom: thumbSource.bottom
+                    anchors.bottomMargin: -height / 4
+                    visible: !activeDragHandler.active
+
+
+                    PC3.Label {
+                        id: caption
+                        width: Math.min(implicitWidth, thumbSource.width)
+                        anchors.top: parent.bottom
+                        anchors.horizontalCenter: parent.horizontalCenter
+                        elide: Text.ElideRight
+                        text: thumb.client.caption
+                        horizontalAlignment: Text.AlignHCenter
+                        verticalAlignment: Text.AlignVCenter
+                    }
+                }
+
+                ExpoCell {
+                    id: cell
+                    layout: expoLayout
+                    naturalX: thumb.client.x
+                    naturalY: thumb.client.y
+                    naturalWidth: thumb.client.width
+                    naturalHeight: thumb.client.height
+                    persistentKey: thumb.client.internalId
+                    bottomMargin: icon.height / 4 + caption.height
+                }
+
+                states: [
+                    State {
+                        name: "initial"
+                        PropertyChanges {
+                            target: thumb
+                            x: thumb.client.x - targetScreen.geometry.x - expoLayout.Kirigami.ScenePosition.x
+                            y: thumb.client.y - targetScreen.geometry.y - expoLayout.Kirigami.ScenePosition.y
+                            width: thumb.client.width
+                            height: thumb.client.height
+                        }
+                        PropertyChanges {
+                            target: icon
+                            opacity: 0
+                        }
+                        PropertyChanges {
+                            target: closeButton
+                            opacity: 0
+                        }
+                    },
+                    State {
+                        name: "partial"
+                        PropertyChanges {
+                            target: thumb
+                            x: (thumb.client.x - targetScreen.geometry.x - expoLayout.Kirigami.ScenePosition.x) * (1 - effect.partialActivationFactor) + cell.x * effect.partialActivationFactor
+                            y: (thumb.client.y - targetScreen.geometry.y - expoLayout.Kirigami.ScenePosition.y) * (1 - effect.partialActivationFactor) + cell.y * effect.partialActivationFactor
+                            width: thumb.client.width * (1 - effect.partialActivationFactor) + cell.width * effect.partialActivationFactor
+                            height: thumb.client.height * (1 - effect.partialActivationFactor) + cell.height * effect.partialActivationFactor
+                            opacity: thumb.client.minimized ? effect.partialActivationFactor : 1
+                        }
+                        PropertyChanges {
+                            target: icon
+                            opacity: effect.partialActivationFactor
+                        }
+                        PropertyChanges {
+                            target: closeButton
+                            opacity: effect.partialActivationFactor
+                        }
+                    },
+                    State {
+                        name: "initial-minimized"
+                        extend: "initial"
+                        PropertyChanges {
+                            target: thumb
+                            opacity: 0
+                        }
+                        PropertyChanges {
+                            target: icon
+                            opacity: 0
+                        }
+                        PropertyChanges {
+                            target: closeButton
+                            opacity: 0
+                        }
+                    },
+                    State {
+                        name: "active"
+                        PropertyChanges {
+                            target: thumb
+                            x: cell.x
+                            y: cell.y
+                            width: cell.width
+                            height: cell.height
+                        }
+                        PropertyChanges {
+                            target: icon
+                            opacity: 1
+                        }
+                        PropertyChanges {
+                            target: closeButton
+                            opacity: 1
+                        }
+                    }
+                ]
+
+                transitions: Transition {
+                    to: "initial, active"
+                    enabled: heap.animationEnabled
+                    NumberAnimation {
+                        duration: heap.animationDuration
+                        properties: "x, y, width, height, opacity"
+                        easing.type: Easing.InOutCubic
+                    }
+                }
+
+
+                PlasmaCore.FrameSvgItem {
+                    anchors.fill: parent
+                    anchors.margins: -PlasmaCore.Units.smallSpacing
+                    imagePath: "widgets/viewitem"
+                    prefix: "hover"
+                    z: -1
+                    visible: !thumb.activeDragHandler.active && (hoverHandler.hovered || selected)
+                }
+
+                HoverHandler {
+                    id: hoverHandler
+                    onHoveredChanged: if (hovered != selected) {
+                        heap.resetSelected();
+                    }
+                }
+
+                TapHandler {
+                    acceptedButtons: Qt.LeftButton
+                    onTapped: {
+                        KWinComponents.Workspace.activeClient = thumb.client;
+                        heap.activated();
+                    }
+                }
+
+                TapHandler {
+                    acceptedPointerTypes: PointerDevice.GenericPointer | PointerDevice.Pen
+                    acceptedButtons: Qt.MiddleButton
+                    onTapped: thumb.client.closeWindow()
+                }
+
+                component DragManager : DragHandler {
+                    id: dragHandler
+                    target: null
+
+                    readonly property double targetScale: {
+                        const localPressPosition = centroid.scenePressPosition.y - expoLayout.Kirigami.ScenePosition.y;
+                        if (localPressPosition == 0) {
+                            return 0.1
+                        } else {
+                            const localPosition = centroid.scenePosition.y - expoLayout.Kirigami.ScenePosition.y;
+                            return Math.max(0.1, Math.min(localPosition / localPressPosition, 1))
+                        }
+                    }
+
+                    onActiveChanged: {
+                        if (active) {
+                            thumb.activeDragHandler = dragHandler;
+                        } else {
+                            thumbSource.Drag.drop();
+                        }
+                    }
+                }
+                property DragManager activeDragHandler: dragHandler
+                DragManager {
+                    id: dragHandler
+                    readonly property double targetOpacity: 1
+                    acceptedDevices: PointerDevice.Mouse | PointerDevice.TouchPad | PointerDevice.Stylus
+                }
+                DragManager {
+                    id: touchDragHandler
+                    acceptedDevices: PointerDevice.TouchScreen
+                    readonly property double targetOpacity: {
+                        const startDistance = heap.Kirigami.ScenePosition.y + heap.height - centroid.scenePressPosition.y;
+                        const localPosition = heap.Kirigami.ScenePosition.y + heap.height - centroid.scenePosition.y;
+                        return Math.min(localPosition / startDistance, 1);
+                    }
+
+                    onActiveChanged: {
+                        if (!active) {
+                            if (targetOpacity < 0.4) {
+                                thumb.client.closeWindow();
+                            }
+                        }
+                    }
+                }
+
+                PC3.Button {
+                    id: closeButton
+                    visible: (hoverHandler.hovered || Kirigami.Settings.tabletMode || Kirigami.Settings.hasTransientTouchInput) && thumb.client.closeable && !dragHandler.active
+                    anchors {
+                        right: thumbSource.right
+                        rightMargin: PlasmaCore.Units.smallSpacing
+                        top: thumbSource.top
+                        topMargin: PlasmaCore.Units.smallSpacing
+                    }
+                    LayoutMirroring.enabled: Qt.application.layoutDirection === Qt.RightToLeft
+                    icon.name: "window-close"
+                    implicitWidth: PlasmaCore.Units.iconSizes.medium
+                    implicitHeight: implicitWidth
+                    onClicked: thumb.client.closeWindow();
+                }
+
+                Component.onDestruction: {
+                    if (selected) {
+                        heap.resetSelected();
+                    }
+                }
+            }
+        }
+    }
+
+    function findNextItem(selectedIndex, direction) {
+        if (selectedIndex == -1) {
+            return 0;
+        }
+
+        const selectedItem = windowsRepeater.itemAt(selectedIndex);
+        let nextIndex = -1;
+
+        switch (direction) {
+        case WindowHeap.Direction.Left:
+            for (let candidateIndex = 0; candidateIndex < windowsRepeater.count; ++candidateIndex) {
+                const candidateItem = windowsRepeater.itemAt(candidateIndex);
+
+                if (candidateItem.y + candidateItem.height <= selectedItem.y) {
+                    continue;
+                } else if (selectedItem.y + selectedItem.height <= candidateItem.y) {
+                    continue;
+                }
+
+                if (candidateItem.x + candidateItem.width < selectedItem.x + selectedItem.width) {
+                    if (nextIndex == -1) {
+                        nextIndex = candidateIndex;
+                    } else {
+                        const nextItem = windowsRepeater.itemAt(nextIndex);
+                        if (candidateItem.x + candidateItem.width > nextItem.x + nextItem.width) {
+                            nextIndex = candidateIndex;
+                        }
+                    }
+                }
+            }
+            break;
+        case WindowHeap.Direction.Right:
+            for (let candidateIndex = 0; candidateIndex < windowsRepeater.count; ++candidateIndex) {
+                const candidateItem = windowsRepeater.itemAt(candidateIndex);
+
+                if (candidateItem.y + candidateItem.height <= selectedItem.y) {
+                    continue;
+                } else if (selectedItem.y + selectedItem.height <= candidateItem.y) {
+                    continue;
+                }
+
+                if (selectedItem.x < candidateItem.x) {
+                    if (nextIndex == -1) {
+                        nextIndex = candidateIndex;
+                    } else {
+                        const nextItem = windowsRepeater.itemAt(nextIndex);
+                        if (nextIndex == -1 || candidateItem.x < nextItem.x) {
+                            nextIndex = candidateIndex;
+                        }
+                    }
+                }
+            }
+            break;
+        case WindowHeap.Direction.Up:
+            for (let candidateIndex = 0; candidateIndex < windowsRepeater.count; ++candidateIndex) {
+                const candidateItem = windowsRepeater.itemAt(candidateIndex);
+
+                if (candidateItem.x + candidateItem.width <= selectedItem.x) {
+                    continue;
+                } else if (selectedItem.x + selectedItem.width <= candidateItem.x) {
+                    continue;
+                }
+
+                if (candidateItem.y + candidateItem.height < selectedItem.y + selectedItem.height) {
+                    if (nextIndex == -1) {
+                        nextIndex = candidateIndex;
+                    } else {
+                        const nextItem = windowsRepeater.itemAt(nextIndex);
+                        if (nextItem.y + nextItem.height < candidateItem.y + candidateItem.height) {
+                            nextIndex = candidateIndex;
+                        }
+                    }
+                }
+            }
+            break;
+        case WindowHeap.Direction.Down:
+            for (let candidateIndex = 0; candidateIndex < windowsRepeater.count; ++candidateIndex) {
+                const candidateItem = windowsRepeater.itemAt(candidateIndex);
+
+                if (candidateItem.x + candidateItem.width <= selectedItem.x) {
+                    continue;
+                } else if (selectedItem.x + selectedItem.width <= candidateItem.x) {
+                    continue;
+                }
+
+                if (selectedItem.y < candidateItem.y) {
+                    if (nextIndex == -1) {
+                        nextIndex = candidateIndex;
+                    } else {
+                        const nextItem = windowsRepeater.itemAt(nextIndex);
+                        if (candidateItem.y < nextItem.y) {
+                            nextIndex = candidateIndex;
+                        }
+                    }
+                }
+            }
+            break;
+        }
+
+        return nextIndex;
+    }
+
+    function resetSelected() {
+        heap.selectedIndex = -1;
+    }
+
+    function selectNextItem(direction) {
+        const nextIndex = findNextItem(heap.selectedIndex, direction);
+        if (nextIndex != -1) {
+            heap.selectedIndex = nextIndex;
+        }
+    }
+
+    function selectLastItem(direction) {
+        let last = heap.selectedIndex;
+        while (true) {
+            const next = findNextItem(last, direction);
+            if (next == -1) {
+                break;
+            } else {
+                last = next;
+            }
+        }
+        if (last != -1) {
+            heap.selectedIndex = last;
+        }
+    }
+
+    onActiveFocusChanged: resetSelected();
+
+    Keys.onPressed: {
+        switch (event.key) {
+        case Qt.Key_Up:
+            selectNextItem(WindowHeap.Direction.Up);
+            break;
+        case Qt.Key_Down:
+            selectNextItem(WindowHeap.Direction.Down);
+            break;
+        case Qt.Key_Left:
+            selectNextItem(WindowHeap.Direction.Left);
+            break;
+        case Qt.Key_Right:
+            selectNextItem(WindowHeap.Direction.Right);
+            break;
+        case Qt.Key_Home:
+            selectLastItem(WindowHeap.Direction.Left);
+            break;
+        case Qt.Key_End:
+            selectLastItem(WindowHeap.Direction.Right);
+            break;
+        case Qt.Key_PageUp:
+            selectLastItem(WindowHeap.Direction.Up);
+            break;
+        case Qt.Key_PageDown:
+            selectLastItem(WindowHeap.Direction.Down);
+            break;
+        case Qt.Key_Return:
+        case Qt.Key_Space:
+            let selectedItem = null;
+            if (heap.selectedIndex != -1) {
+                selectedItem = windowsRepeater.itemAt(heap.selectedIndex);
+            } else {
+                // If the window heap has only one visible window, activate it.
+                for (let i = 0; i < windowsRepeater.count; ++i) {
+                    const candidateItem = windowsRepeater.itemAt(i);
+                    if (selectedItem) {
+                        selectedItem = null;
+                        break;
+                    }
+                    selectedItem = candidateItem;
+                }
+            }
+            if (selectedItem) {
+                KWinComponents.Workspace.activeClient = selectedItem.client;
+                heap.activated();
+            }
+            break;
+        default:
+            return;
+        }
+        event.accepted = true;
+    }
+}
diff --git a/effect/effects/private/qmldir b/effect/effects/private/qmldir
new file mode 100644
index 000000000..ee0ffb03a
--- /dev/null
+++ b/effect/effects/private/qmldir
@@ -0,0 +1,10 @@
+# SPDX-FileCopyrightText: 2021 Vlad Zahorodnii <vlad.zahorodnii@kde.org>
+#
+# SPDX-License-Identifier: CC0-1.0
+
+module org.kde.kwin.private.effects
+
+plugin effectsplugin
+classname EffectKitExtensionPlugin
+
+WindowHeap 1.0 WindowHeap.qml
-- 
GitLab


From abdee5efbf4433cba952e4af9eef1d4904f68c91 Mon Sep 17 00:00:00 2001
From: Vlad Zahorodnii <vlad.zahorodnii@kde.org>
Date: Mon, 22 Nov 2021 16:41:59 +0200
Subject: [PATCH 02/62] refactor(effect): re-introduce support for client
 filtering in WindowHeap

---
 effect/effects/private/qml/WindowHeap.qml | 43 ++++++++++++++++++++---
 1 file changed, 39 insertions(+), 4 deletions(-)

diff --git a/effect/effects/private/qml/WindowHeap.qml b/effect/effects/private/qml/WindowHeap.qml
index 869eb5df7..8aff5b2eb 100644
--- a/effect/effects/private/qml/WindowHeap.qml
+++ b/effect/effects/private/qml/WindowHeap.qml
@@ -27,6 +27,7 @@ FocusScope {
     property int animationDuration: PlasmaCore.Units.longDuration
     property bool animationEnabled: false
     property real padding: 0
+    property var showOnly: []
 
     required property bool organized
     readonly property bool effectiveOrganized: expoLayout.ready && organized
@@ -51,13 +52,16 @@ FocusScope {
                 required property int index
 
                 readonly property bool selected: heap.selectedIndex == index
+                readonly property bool hidden: {
+                    return heap.showOnly.length && heap.showOnly.indexOf(client.internalId) == -1;
+                }
 
                 state: {
                     if (effect.gestureInProgress) {
                         return "partial";
                     }
                     if (heap.effectiveOrganized) {
-                        return "active";
+                        return hidden ? "active-hidden" : "active";
                     }
                     return client.minimized ? "initial-minimized" : "initial";
                 }
@@ -241,12 +245,19 @@ FocusScope {
                         PropertyChanges {
                             target: closeButton
                             opacity: 1
+                    },
+                    State {
+                        name: "active-hidden"
+                        extend: "active"
+                        PropertyChanges {
+                            target: thumb
+                            opacity: 0
                         }
                     }
                 ]
 
                 transitions: Transition {
-                    to: "initial, active"
+                    to: "initial, active, active-hidden"
                     enabled: heap.animationEnabled
                     NumberAnimation {
                         duration: heap.animationDuration
@@ -357,9 +368,19 @@ FocusScope {
         }
     }
 
+    function findFirstItem() {
+        for (let candidateIndex = 0; candidateIndex < windowsRepeater.count; ++candidateIndex) {
+            const candidateItem = windowsRepeater.itemAt(candidateIndex);
+            if (!candidateItem.hidden) {
+                return candidateIndex;
+            }
+        }
+        return -1;
+    }
+
     function findNextItem(selectedIndex, direction) {
         if (selectedIndex == -1) {
-            return 0;
+            return findFirstItem();
         }
 
         const selectedItem = windowsRepeater.itemAt(selectedIndex);
@@ -369,6 +390,9 @@ FocusScope {
         case WindowHeap.Direction.Left:
             for (let candidateIndex = 0; candidateIndex < windowsRepeater.count; ++candidateIndex) {
                 const candidateItem = windowsRepeater.itemAt(candidateIndex);
+                if (candidateItem.hidden) {
+                    continue;
+                }
 
                 if (candidateItem.y + candidateItem.height <= selectedItem.y) {
                     continue;
@@ -391,6 +415,9 @@ FocusScope {
         case WindowHeap.Direction.Right:
             for (let candidateIndex = 0; candidateIndex < windowsRepeater.count; ++candidateIndex) {
                 const candidateItem = windowsRepeater.itemAt(candidateIndex);
+                if (candidateItem.hidden) {
+                    continue;
+                }
 
                 if (candidateItem.y + candidateItem.height <= selectedItem.y) {
                     continue;
@@ -413,6 +440,9 @@ FocusScope {
         case WindowHeap.Direction.Up:
             for (let candidateIndex = 0; candidateIndex < windowsRepeater.count; ++candidateIndex) {
                 const candidateItem = windowsRepeater.itemAt(candidateIndex);
+                if (candidateItem.hidden) {
+                    continue;
+                }
 
                 if (candidateItem.x + candidateItem.width <= selectedItem.x) {
                     continue;
@@ -435,6 +465,9 @@ FocusScope {
         case WindowHeap.Direction.Down:
             for (let candidateIndex = 0; candidateIndex < windowsRepeater.count; ++candidateIndex) {
                 const candidateItem = windowsRepeater.itemAt(candidateIndex);
+                if (candidateItem.hidden) {
+                    continue;
+                }
 
                 if (candidateItem.x + candidateItem.width <= selectedItem.x) {
                     continue;
@@ -522,7 +555,9 @@ FocusScope {
                 // If the window heap has only one visible window, activate it.
                 for (let i = 0; i < windowsRepeater.count; ++i) {
                     const candidateItem = windowsRepeater.itemAt(i);
-                    if (selectedItem) {
+                    if (candidateItem.hidden) {
+                        continue;
+                    } else if (selectedItem) {
                         selectedItem = null;
                         break;
                     }
-- 
GitLab


From 5f92d1cffc22998441e26331f1c604459f48153b Mon Sep 17 00:00:00 2001
From: Vlad Zahorodnii <vlad.zahorodnii@kde.org>
Date: Mon, 22 Nov 2021 18:16:01 +0200
Subject: [PATCH 03/62] refactor(effect): allow disabling expo cells

This allows making specific windows in a WindowHeap static.
---
 effect/effects/private/expolayout.cpp     | 24 ++++++++++++++++++++++-
 effect/effects/private/expolayout.h       |  6 ++++++
 effect/effects/private/qml/WindowHeap.qml |  1 +
 3 files changed, 30 insertions(+), 1 deletion(-)

diff --git a/effect/effects/private/expolayout.cpp b/effect/effects/private/expolayout.cpp
index 50ca8d2b8..5a37a55e6 100644
--- a/effect/effects/private/expolayout.cpp
+++ b/effect/effects/private/expolayout.cpp
@@ -36,12 +36,34 @@ void ExpoCell::setLayout(ExpoLayout* layout)
         m_layout->removeCell(this);
     }
     m_layout = layout;
-    if (m_layout) {
+    if (m_layout && m_enabled) {
         m_layout->addCell(this);
     }
     Q_EMIT layoutChanged();
 }
 
+bool ExpoCell::isEnabled() const
+{
+    return m_enabled;
+}
+
+void ExpoCell::setEnabled(bool enabled)
+{
+    if (m_enabled != enabled) {
+        m_enabled = enabled;
+        if (enabled) {
+            if (m_layout) {
+                m_layout->addCell(this);
+            }
+        } else {
+            if (m_layout) {
+                m_layout->removeCell(this);
+            }
+        }
+        Q_EMIT enabledChanged();
+    }
+}
+
 void ExpoCell::update()
 {
     if (m_layout) {
diff --git a/effect/effects/private/expolayout.h b/effect/effects/private/expolayout.h
index 1ce41633a..48ae7b907 100644
--- a/effect/effects/private/expolayout.h
+++ b/effect/effects/private/expolayout.h
@@ -76,6 +76,7 @@ class ExpoCell : public QObject
 {
     Q_OBJECT
     Q_PROPERTY(ExpoLayout* layout READ layout WRITE setLayout NOTIFY layoutChanged)
+    Q_PROPERTY(bool enabled READ isEnabled WRITE setEnabled NOTIFY enabledChanged)
     Q_PROPERTY(int naturalX READ naturalX WRITE setNaturalX NOTIFY naturalXChanged)
     Q_PROPERTY(int naturalY READ naturalY WRITE setNaturalY NOTIFY naturalYChanged)
     Q_PROPERTY(int naturalWidth READ naturalWidth WRITE setNaturalWidth NOTIFY naturalWidthChanged)
@@ -93,6 +94,9 @@ public:
     explicit ExpoCell(QObject* parent = nullptr);
     ~ExpoCell() override;
 
+    bool isEnabled() const;
+    void setEnabled(bool enabled);
+
     ExpoLayout* layout() const;
     void setLayout(ExpoLayout* layout);
 
@@ -134,6 +138,7 @@ public Q_SLOTS:
 
 Q_SIGNALS:
     void layoutChanged();
+    void enabledChanged();
     void naturalXChanged();
     void naturalYChanged();
     void naturalWidthChanged();
@@ -147,6 +152,7 @@ Q_SIGNALS:
 
 private:
     QString m_persistentKey;
+    bool m_enabled = true;
     int m_naturalX = 0;
     int m_naturalY = 0;
     int m_naturalWidth = 0;
diff --git a/effect/effects/private/qml/WindowHeap.qml b/effect/effects/private/qml/WindowHeap.qml
index 8aff5b2eb..d35faca3f 100644
--- a/effect/effects/private/qml/WindowHeap.qml
+++ b/effect/effects/private/qml/WindowHeap.qml
@@ -167,6 +167,7 @@ FocusScope {
                 ExpoCell {
                     id: cell
                     layout: expoLayout
+                    enabled: !thumb.hidden
                     naturalX: thumb.client.x
                     naturalY: thumb.client.y
                     naturalWidth: thumb.client.width
-- 
GitLab


From 7f63246f0b6a50d4c28cbff38cde3f0655f398e4 Mon Sep 17 00:00:00 2001
From: Vlad Zahorodnii <vlad.zahorodnii@kde.org>
Date: Tue, 23 Nov 2021 17:12:45 +0200
Subject: [PATCH 04/62] refactor(effect): effectkit, allow disabling dnd in
 WindowHeap

---
 effect/effects/private/qml/WindowHeap.qml | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/effect/effects/private/qml/WindowHeap.qml b/effect/effects/private/qml/WindowHeap.qml
index d35faca3f..763790dbf 100644
--- a/effect/effects/private/qml/WindowHeap.qml
+++ b/effect/effects/private/qml/WindowHeap.qml
@@ -26,6 +26,7 @@ FocusScope {
     property int selectedIndex: -1
     property int animationDuration: PlasmaCore.Units.longDuration
     property bool animationEnabled: false
+    property bool dragEnabled: true
     property real padding: 0
     property var showOnly: []
 
@@ -300,6 +301,7 @@ FocusScope {
 
                 component DragManager : DragHandler {
                     id: dragHandler
+                    enabled: heap.dragEnabled
                     target: null
 
                     readonly property double targetScale: {
-- 
GitLab


From e7a494e4169b52a78bb9f76fb50952b00addda22 Mon Sep 17 00:00:00 2001
From: Marco Martin <notmart@gmail.com>
Date: Mon, 4 Apr 2022 14:37:34 +0200
Subject: [PATCH 05/62] refactor(effect): rebase and adapt to changes in master

---
 effect/effects/private/qml/WindowHeap.qml | 1 +
 1 file changed, 1 insertion(+)

diff --git a/effect/effects/private/qml/WindowHeap.qml b/effect/effects/private/qml/WindowHeap.qml
index 763790dbf..7c3ef0aae 100644
--- a/effect/effects/private/qml/WindowHeap.qml
+++ b/effect/effects/private/qml/WindowHeap.qml
@@ -247,6 +247,7 @@ FocusScope {
                         PropertyChanges {
                             target: closeButton
                             opacity: 1
+                        }
                     },
                     State {
                         name: "active-hidden"
-- 
GitLab


From d9f55e9e10fd28f6675455eb7f297c11ffea8f6f Mon Sep 17 00:00:00 2001
From: Marco Martin <notmart@gmail.com>
Date: Tue, 19 Apr 2022 14:37:06 +0200
Subject: [PATCH 06/62] refactor(effect): correctly map NaturalX/Y to scene
 coordinates

being naturalx something that needs to map to the actual geometry of the window which is in absolute coordinates but mapped to a view which geometry correspond to the one of one particular screen (plus the layout the thumbnail lives in has its own geometry in the scene)
---
 effect/effects/private/qml/WindowHeap.qml | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/effect/effects/private/qml/WindowHeap.qml b/effect/effects/private/qml/WindowHeap.qml
index 7c3ef0aae..133895e40 100644
--- a/effect/effects/private/qml/WindowHeap.qml
+++ b/effect/effects/private/qml/WindowHeap.qml
@@ -169,8 +169,8 @@ FocusScope {
                     id: cell
                     layout: expoLayout
                     enabled: !thumb.hidden
-                    naturalX: thumb.client.x
-                    naturalY: thumb.client.y
+                    naturalX: thumb.client.x - targetScreen.geometry.x - expoLayout.Kirigami.ScenePosition.x
+                    naturalY: thumb.client.y - targetScreen.geometry.y - expoLayout.Kirigami.ScenePosition.y
                     naturalWidth: thumb.client.width
                     naturalHeight: thumb.client.height
                     persistentKey: thumb.client.internalId
-- 
GitLab


From 2d55ede84cf09ce56bb2001463a9a6d6359b6e09 Mon Sep 17 00:00:00 2001
From: Fushan Wen <qydwhotmail@gmail.com>
Date: Fri, 22 Apr 2022 20:56:47 +0800
Subject: [PATCH 07/62] fix(effect): unable to assign [undefined] to int

animationDuration is not defined in WindowViewEffect. Use
heap.animationDuration instead.
---
 effect/effects/private/qml/WindowHeap.qml | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/effect/effects/private/qml/WindowHeap.qml b/effect/effects/private/qml/WindowHeap.qml
index 133895e40..52fdf5f75 100644
--- a/effect/effects/private/qml/WindowHeap.qml
+++ b/effect/effects/private/qml/WindowHeap.qml
@@ -73,7 +73,7 @@ FocusScope {
                 component TweenBehavior : Behavior {
                     enabled: thumb.state !== "partial" && heap.animationEnabled && !thumb.activeDragHandler.active
                     NumberAnimation {
-                        duration: effect.animationDuration
+                        duration: heap.animationDuration
                         easing.type: Easing.OutCubic
                     }
                 }
@@ -121,7 +121,7 @@ FocusScope {
                         to: "normal"
                         enabled: heap.animationEnabled
                         NumberAnimation {
-                            duration: effect.animationDuration
+                            duration: heap.animationDuration
                             properties: "x, y, width, height, opacity"
                             easing.type: Easing.OutCubic
                         }
-- 
GitLab


From 87d3758edd3c62354d35f267821e79d9118349c8 Mon Sep 17 00:00:00 2001
From: Fushan Wen <qydwhotmail@gmail.com>
Date: Fri, 22 Apr 2022 21:37:02 +0800
Subject: [PATCH 08/62] refactor(effect): hide window icon and label when
 excluded

This makes the opening animation of Window View from task manager less rigid.
---
 effect/effects/private/qml/WindowHeap.qml | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/effect/effects/private/qml/WindowHeap.qml b/effect/effects/private/qml/WindowHeap.qml
index 52fdf5f75..4a5a9b327 100644
--- a/effect/effects/private/qml/WindowHeap.qml
+++ b/effect/effects/private/qml/WindowHeap.qml
@@ -140,6 +140,7 @@ FocusScope {
                     verticalAlignment: Text.AlignVCenter
                     text: i18nd("kwin_effects", "Drag Down To Close")
                     opacity: 1 - thumbSource.opacity
+                    visible: !thumb.hidden
                 }
 
                 PlasmaCore.IconItem {
@@ -150,7 +151,7 @@ FocusScope {
                     anchors.horizontalCenter: thumbSource.horizontalCenter
                     anchors.bottom: thumbSource.bottom
                     anchors.bottomMargin: -height / 4
-                    visible: !activeDragHandler.active
+                    visible: !thumb.hidden && !activeDragHandler.active
 
 
                     PC3.Label {
-- 
GitLab


From ef43626b9c18cb2a08281456f9b96b87d64e5df2 Mon Sep 17 00:00:00 2001
From: Volker Krause <vkrause@kde.org>
Date: Fri, 22 Apr 2022 16:24:30 +0200
Subject: [PATCH 09/62] build(effect): qt6 build regressions

---
 effect/effects/private/CMakeLists.txt | 8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)

diff --git a/effect/effects/private/CMakeLists.txt b/effect/effects/private/CMakeLists.txt
index 8a275b02f..80e9a84e2 100644
--- a/effect/effects/private/CMakeLists.txt
+++ b/effect/effects/private/CMakeLists.txt
@@ -11,10 +11,10 @@ add_library(effectsplugin
 target_link_libraries(effectsplugin
     kwineffects
 
-    Qt5::Core
-    Qt5::Gui
-    Qt5::Qml
-    Qt5::Quick
+    Qt::Core
+    Qt::Gui
+    Qt::Qml
+    Qt::Quick
 )
 
 install(DIRECTORY qml/ DESTINATION ${KDE_INSTALL_QMLDIR}/org/kde/kwin/private/effects)
-- 
GitLab


From 0ced25d95213d822889e02ce2638bdf096bb7c17 Mon Sep 17 00:00:00 2001
From: Marco Martin <notmart@gmail.com>
Date: Thu, 5 May 2022 14:37:52 +0000
Subject: [PATCH 10/62] refactor(effect): make windowview replace present
 windows

* give windowview the ability to show windows from current desktop, all
desktops or current class
* invokable from shortcuts screen edges or gestures
* add a search field to quickly filter
* current present windows effect still present but only internal as is used by desktop grid, which should eventually be ported as well

This can be done either from windowview or overview, tough note that some of the duplication from overview added in windowview is necessary regardless, as WindowHeap, the shared qml part needs some properties exposed from the c++ part.
Implementation wise I'm ok for it being in either place, but i think the functionality of present windows needs to be preserved, otherwise would be a completely unacceptable regression, namely:

* Behavior of what now are the ctrl+f7,f10 and f11 global shortcuts, showing windows of current app (invokable by shoortcut instead of having to use the pointer), windows of current desktop (the only thing overview does atm) or all desktops
* filter on typing, as opposed to invoking krunner. main use case of present windows is quickly switching, and filtering is the most helpful feature, some people do like krunner instead, but is completely out of place for my use case, and i suspect for many other users as well
* also clicking on a taskbar group should be possible to filter
* the view that opens by clicking on a taskbar group should follow the same layout strategy used elsewhere and currently being an effect used only there and not accessible form the list can't even be configured
---
 effect/effects/private/qml/WindowHeap.qml | 27 ++++++++++++++++++++++-
 1 file changed, 26 insertions(+), 1 deletion(-)

diff --git a/effect/effects/private/qml/WindowHeap.qml b/effect/effects/private/qml/WindowHeap.qml
index 4a5a9b327..2e1dba791 100644
--- a/effect/effects/private/qml/WindowHeap.qml
+++ b/effect/effects/private/qml/WindowHeap.qml
@@ -29,12 +29,19 @@ FocusScope {
     property bool dragEnabled: true
     property real padding: 0
     property var showOnly: []
+    property string activeClass
+    readonly property alias count: windowsRepeater.count
 
     required property bool organized
     readonly property bool effectiveOrganized: expoLayout.ready && organized
 
     signal activated()
 
+    function activateIndex(index) {
+        KWinComponents.Workspace.activeClient = windowsRepeater.itemAt(index).client;
+        activated();
+    }
+
     ExpoLayout {
         id: expoLayout
         x: heap.padding
@@ -54,7 +61,25 @@ FocusScope {
 
                 readonly property bool selected: heap.selectedIndex == index
                 readonly property bool hidden: {
-                    return heap.showOnly.length && heap.showOnly.indexOf(client.internalId) == -1;
+                    if (heap.showOnly === "activeClass") {
+                        return heap.activeClass !== String(thumb.client.resourceName); // thumb.client.resourceName is not an actual String as comes from a QByteArray so === would fail
+                    } else {
+                        return heap.showOnly.length && heap.showOnly.indexOf(client.internalId) == -1;
+                    }
+                }
+
+                Component.onCompleted: {
+                    if (thumb.client.active) {
+                        heap.activeClass = thumb.client.resourceName;
+                    }
+                }
+                Connections {
+                    target: thumb.client
+                    function onActiveChanged() {
+                        if (thumb.client.active) {
+                            heap.activeClass = thumb.client.resourceName;
+                        }
+                    }
                 }
 
                 state: {
-- 
GitLab


From e80289854fce2159fdee00a8278b88978fbf8afc Mon Sep 17 00:00:00 2001
From: Marco Martin <notmart@gmail.com>
Date: Fri, 6 May 2022 10:44:38 +0000
Subject: [PATCH 11/62] fix(effect): qML version of the Desktop Grid effect

Replace completely the old desktop grid effect with a QML version.
Aims to feature parity and be a change as transparent as possible for the user.

BUG: 433071
BUG: 452625
BUG: 443971
BUG: 437121
BUG: 452925
BUG: 437928
BUG: 452439
BUG: 288530
BUG: 450254
BUG: 450106
BUG: 447832
BUG: 449960
BUG: 416576
BUG: 441862
BUG: 444859
BUG: 445999
BUG: 422117
BUG: 404627
BUG: 435483
BUG: 420744
BUG: 435482
BUG: 427055
BUG: 333445
BUG: 429120
BUG: 427391
BUG: 409295
BUG: 294322
BUG: 356955
FIXED-IN: 5.25
---
 effect/effects/private/qml/WindowHeap.qml | 27 ++++++++++++++++++-----
 1 file changed, 22 insertions(+), 5 deletions(-)

diff --git a/effect/effects/private/qml/WindowHeap.qml b/effect/effects/private/qml/WindowHeap.qml
index 2e1dba791..0c517af6f 100644
--- a/effect/effects/private/qml/WindowHeap.qml
+++ b/effect/effects/private/qml/WindowHeap.qml
@@ -21,12 +21,16 @@ FocusScope {
         Down
     }
 
+    property bool supportsCloseWindows: false
+    property bool supportsDragUpGesture: false
+    property bool showCaptions: true
     property alias model: windowsRepeater.model
     property alias layout: expoLayout.mode
     property int selectedIndex: -1
     property int animationDuration: PlasmaCore.Units.longDuration
     property bool animationEnabled: false
     property bool dragEnabled: true
+    property bool absolutePositioning: true
     property real padding: 0
     property var showOnly: []
     property string activeClass
@@ -34,6 +38,7 @@ FocusScope {
 
     required property bool organized
     readonly property bool effectiveOrganized: expoLayout.ready && organized
+    property bool dragActive: false
 
     signal activated()
 
@@ -181,6 +186,7 @@ FocusScope {
 
                     PC3.Label {
                         id: caption
+                        visible: heap.showCaptions
                         width: Math.min(implicitWidth, thumbSource.width)
                         anchors.top: parent.bottom
                         anchors.horizontalCenter: parent.horizontalCenter
@@ -208,8 +214,8 @@ FocusScope {
                         name: "initial"
                         PropertyChanges {
                             target: thumb
-                            x: thumb.client.x - targetScreen.geometry.x - expoLayout.Kirigami.ScenePosition.x
-                            y: thumb.client.y - targetScreen.geometry.y - expoLayout.Kirigami.ScenePosition.y
+                            x: thumb.client.x - targetScreen.geometry.x - (heap.absolutePositioning ?  expoLayout.Kirigami.ScenePosition.x : 0)
+                            y: thumb.client.y - targetScreen.geometry.y - (heap.absolutePositioning ?  expoLayout.Kirigami.ScenePosition.y : 0)
                             width: thumb.client.width
                             height: thumb.client.height
                         }
@@ -226,8 +232,8 @@ FocusScope {
                         name: "partial"
                         PropertyChanges {
                             target: thumb
-                            x: (thumb.client.x - targetScreen.geometry.x - expoLayout.Kirigami.ScenePosition.x) * (1 - effect.partialActivationFactor) + cell.x * effect.partialActivationFactor
-                            y: (thumb.client.y - targetScreen.geometry.y - expoLayout.Kirigami.ScenePosition.y) * (1 - effect.partialActivationFactor) + cell.y * effect.partialActivationFactor
+                            x: (thumb.client.x - targetScreen.geometry.x - (heap.absolutePositioning ?  expoLayout.Kirigami.ScenePosition.x : 0)) * (1 - effect.partialActivationFactor) + cell.x * effect.partialActivationFactor
+                            y: (thumb.client.y - targetScreen.geometry.y - (heap.absolutePositioning ?  expoLayout.Kirigami.ScenePosition.y : 0)) * (1 - effect.partialActivationFactor) + cell.y * effect.partialActivationFactor
                             width: thumb.client.width * (1 - effect.partialActivationFactor) + cell.width * effect.partialActivationFactor
                             height: thumb.client.height * (1 - effect.partialActivationFactor) + cell.height * effect.partialActivationFactor
                             opacity: thumb.client.minimized ? effect.partialActivationFactor : 1
@@ -321,6 +327,7 @@ FocusScope {
                 }
 
                 TapHandler {
+                    enabled: heap.supportsCloseWindows
                     acceptedPointerTypes: PointerDevice.GenericPointer | PointerDevice.Pen
                     acceptedButtons: Qt.MiddleButton
                     onTapped: thumb.client.closeWindow()
@@ -332,6 +339,9 @@ FocusScope {
                     target: null
 
                     readonly property double targetScale: {
+                        if (!heap.supportsDragUpGesture) {
+                            return 1;
+                        }
                         const localPressPosition = centroid.scenePressPosition.y - expoLayout.Kirigami.ScenePosition.y;
                         if (localPressPosition == 0) {
                             return 0.1
@@ -342,6 +352,7 @@ FocusScope {
                     }
 
                     onActiveChanged: {
+                        heap.dragActive = active;
                         if (active) {
                             thumb.activeDragHandler = dragHandler;
                         } else {
@@ -359,12 +370,18 @@ FocusScope {
                     id: touchDragHandler
                     acceptedDevices: PointerDevice.TouchScreen
                     readonly property double targetOpacity: {
+                        if (!heap.supportsCloseWindows) {
+                            return 1;
+                        }
                         const startDistance = heap.Kirigami.ScenePosition.y + heap.height - centroid.scenePressPosition.y;
                         const localPosition = heap.Kirigami.ScenePosition.y + heap.height - centroid.scenePosition.y;
                         return Math.min(localPosition / startDistance, 1);
                     }
 
                     onActiveChanged: {
+                        if (!heap.supportsCloseWindows) {
+                            return;
+                        }
                         if (!active) {
                             if (targetOpacity < 0.4) {
                                 thumb.client.closeWindow();
@@ -375,7 +392,7 @@ FocusScope {
 
                 PC3.Button {
                     id: closeButton
-                    visible: (hoverHandler.hovered || Kirigami.Settings.tabletMode || Kirigami.Settings.hasTransientTouchInput) && thumb.client.closeable && !dragHandler.active
+                    visible: heap.supportsCloseWindows && (hoverHandler.hovered || Kirigami.Settings.tabletMode || Kirigami.Settings.hasTransientTouchInput) && thumb.client.closeable && !dragHandler.active
                     anchors {
                         right: thumbSource.right
                         rightMargin: PlasmaCore.Units.smallSpacing
-- 
GitLab


From 504d9bece3764b171a368cf43fd6db2124ae8e6e Mon Sep 17 00:00:00 2001
From: Xaver Hugl <xaver.hugl@gmail.com>
Date: Wed, 11 May 2022 17:04:36 +0200
Subject: [PATCH 12/62] refactor(effect): allow closing windows with touch

---
 effect/effects/private/qml/WindowHeap.qml | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/effect/effects/private/qml/WindowHeap.qml b/effect/effects/private/qml/WindowHeap.qml
index 0c517af6f..b5ac398fc 100644
--- a/effect/effects/private/qml/WindowHeap.qml
+++ b/effect/effects/private/qml/WindowHeap.qml
@@ -335,7 +335,7 @@ FocusScope {
 
                 component DragManager : DragHandler {
                     id: dragHandler
-                    enabled: heap.dragEnabled
+                    enabled: heap.dragEnabled || heap.supportsCloseWindows
                     target: null
 
                     readonly property double targetScale: {
@@ -365,6 +365,7 @@ FocusScope {
                     id: dragHandler
                     readonly property double targetOpacity: 1
                     acceptedDevices: PointerDevice.Mouse | PointerDevice.TouchPad | PointerDevice.Stylus
+                    enabled: heap.dragEnabled
                 }
                 DragManager {
                     id: touchDragHandler
-- 
GitLab


From 842588de8f8630f4117961e9448351449cf895d0 Mon Sep 17 00:00:00 2001
From: Marco Martin <notmart@gmail.com>
Date: Thu, 26 May 2022 14:42:35 +0200
Subject: [PATCH 13/62] fix(effect): toggle all desktop on middle click

Restores the behavior of the old desktop grid which toggled on all desktops on middle
click.

BUG:454001
---
 effect/effects/private/qml/WindowHeap.qml | 9 ++++++---
 1 file changed, 6 insertions(+), 3 deletions(-)

diff --git a/effect/effects/private/qml/WindowHeap.qml b/effect/effects/private/qml/WindowHeap.qml
index b5ac398fc..ac902e97d 100644
--- a/effect/effects/private/qml/WindowHeap.qml
+++ b/effect/effects/private/qml/WindowHeap.qml
@@ -41,6 +41,8 @@ FocusScope {
     property bool dragActive: false
 
     signal activated()
+    //TODO: for 5.26 the delegate will be a separate component instead
+    signal windowClicked(QtObject window, EventPoint eventPoint)
 
     function activateIndex(index) {
         KWinComponents.Workspace.activeClient = windowsRepeater.itemAt(index).client;
@@ -327,10 +329,11 @@ FocusScope {
                 }
 
                 TapHandler {
-                    enabled: heap.supportsCloseWindows
                     acceptedPointerTypes: PointerDevice.GenericPointer | PointerDevice.Pen
-                    acceptedButtons: Qt.MiddleButton
-                    onTapped: thumb.client.closeWindow()
+                    acceptedButtons: Qt.LeftButton | Qt.MiddleButton | Qt.RightButton
+                    onTapped: {
+                        heap.windowClicked(thumb.client, eventPoint)
+                    }
                 }
 
                 component DragManager : DragHandler {
-- 
GitLab


From 84bc73b1a79521edbf699c3b53331aaffb938aa8 Mon Sep 17 00:00:00 2001
From: Marco Martin <notmart@gmail.com>
Date: Mon, 6 Jun 2022 11:39:28 +0000
Subject: [PATCH 14/62] fix(effect): put the hostpot as the press position

we should drop the window on the desktop under the cursor,
not under the center of the thumbnail

BUG:454584
---
 effect/effects/private/qml/WindowHeap.qml | 4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

diff --git a/effect/effects/private/qml/WindowHeap.qml b/effect/effects/private/qml/WindowHeap.qml
index ac902e97d..7715942f2 100644
--- a/effect/effects/private/qml/WindowHeap.qml
+++ b/effect/effects/private/qml/WindowHeap.qml
@@ -122,7 +122,9 @@ FocusScope {
 
                     Drag.active: thumb.activeDragHandler.active
                     Drag.source: thumb.client
-                    Drag.hotSpot: Qt.point(width * 0.5, height * 0.5)
+                    Drag.hotSpot: Qt.point(
+                        thumb.activeDragHandler.centroid.pressPosition.x * thumb.activeDragHandler.targetScale,
+                        thumb.activeDragHandler.centroid.pressPosition.y * thumb.activeDragHandler.targetScale)
 
                     states: [
                         State {
-- 
GitLab


From c298f7f82451be46eed663fd23496b33d8b7b260 Mon Sep 17 00:00:00 2001
From: Marco Martin <notmart@gmail.com>
Date: Mon, 6 Jun 2022 13:48:59 +0000
Subject: [PATCH 15/62] fix(effect): drag windows between screens in WindowHeap

Allow dragging windows between screens, using a placeholder thumbnail item to
render part of the thumbnail on the other screen.

BUG: 283333
BUG: 453996
BUG: 448566
---
 effect/effects/private/qml/WindowHeap.qml | 63 +++++++++++++++++++++--
 1 file changed, 60 insertions(+), 3 deletions(-)

diff --git a/effect/effects/private/qml/WindowHeap.qml b/effect/effects/private/qml/WindowHeap.qml
index 7715942f2..230f86fc7 100644
--- a/effect/effects/private/qml/WindowHeap.qml
+++ b/effect/effects/private/qml/WindowHeap.qml
@@ -5,6 +5,7 @@
 */
 
 import QtQuick 2.12
+import QtQuick.Window 2.12
 import org.kde.kirigami 2.12 as Kirigami
 import org.kde.kwin 3.0 as KWinComponents
 import org.kde.kwin.private.effects 1.0
@@ -29,7 +30,6 @@ FocusScope {
     property int selectedIndex: -1
     property int animationDuration: PlasmaCore.Units.longDuration
     property bool animationEnabled: false
-    property bool dragEnabled: true
     property bool absolutePositioning: true
     property real padding: 0
     property var showOnly: []
@@ -49,6 +49,57 @@ FocusScope {
         activated();
     }
 
+    KWinComponents.WindowThumbnailItem {
+        id: otherScreenThumbnail
+        z: 2
+        property KWinComponents.WindowThumbnailItem cloneOf
+        visible: false
+        wId: cloneOf ? cloneOf.wId : null
+        width: cloneOf ? cloneOf.width : 0
+        height: cloneOf ? cloneOf.height : 0
+        onCloneOfChanged: {
+            if (!cloneOf) {
+                visible = false;
+            }
+        }
+    }
+
+    Connections {
+        target: effect
+        function onItemDraggedOutOfScreen(item, screens) {
+            let found = false;
+
+            // don't put a proxy for item's own screen
+            if (screens.length === 0 || item.screen === targetScreen) {
+                otherScreenThumbnail.visible = false;
+                return;
+            }
+
+            for (let i in screens) {
+                if (targetScreen === screens[i]) {
+                    found = true;
+                    let globalPos = item.screen.mapToGlobal(item.mapToItem(null, 0,0));
+                    let heapRelativePos = targetScreen.mapFromGlobal(globalPos);
+                    heapRelativePos = heap.mapFromItem(null, heapRelativePos.x, heapRelativePos.y);
+                    otherScreenThumbnail.cloneOf = item
+                    otherScreenThumbnail.x = heapRelativePos.x;
+                    otherScreenThumbnail.y = heapRelativePos.y;
+                    otherScreenThumbnail.visible = true;
+                }
+            }
+
+            if (!found) {
+                otherScreenThumbnail.visible = false;
+            }
+        }
+        function onItemDroppedOutOfScreen(pos, item, screen) {
+            if (screen === targetScreen) {
+                // To actually move we neeed a screen number rather than an EffectScreen
+                KWinComponents.Workspace.sendClientToScreen(item.client, KWinComponents.Workspace.screenAt(pos));
+            }
+        }
+    }
+
     ExpoLayout {
         id: expoLayout
         x: heap.padding
@@ -119,6 +170,8 @@ FocusScope {
                     id: thumbSource
                     wId: thumb.client.internalId
                     state: thumb.activeDragHandler.active ? "drag" : "normal"
+                    readonly property QtObject screen: targetScreen
+                    readonly property QtObject client: thumb.client
 
                     Drag.active: thumb.activeDragHandler.active
                     Drag.source: thumb.client
@@ -126,6 +179,9 @@ FocusScope {
                         thumb.activeDragHandler.centroid.pressPosition.x * thumb.activeDragHandler.targetScale,
                         thumb.activeDragHandler.centroid.pressPosition.y * thumb.activeDragHandler.targetScale)
 
+                    onXChanged: effect.checkItemDraggedOutOfScreen(thumbSource)
+                    onYChanged: effect.checkItemDraggedOutOfScreen(thumbSource)
+
                     states: [
                         State {
                             name: "normal"
@@ -340,7 +396,7 @@ FocusScope {
 
                 component DragManager : DragHandler {
                     id: dragHandler
-                    enabled: heap.dragEnabled || heap.supportsCloseWindows
+                    enabled: heap.supportsCloseWindows
                     target: null
 
                     readonly property double targetScale: {
@@ -362,6 +418,8 @@ FocusScope {
                             thumb.activeDragHandler = dragHandler;
                         } else {
                             thumbSource.Drag.drop();
+                            let globalPos = targetScreen.mapToGlobal(centroid.scenePosition);
+                            effect.checkItemDroppedOutOfScreen(globalPos, thumbSource);
                         }
                     }
                 }
@@ -370,7 +428,6 @@ FocusScope {
                     id: dragHandler
                     readonly property double targetOpacity: 1
                     acceptedDevices: PointerDevice.Mouse | PointerDevice.TouchPad | PointerDevice.Stylus
-                    enabled: heap.dragEnabled
                 }
                 DragManager {
                     id: touchDragHandler
-- 
GitLab


From c592b4252170d306bfe086cc6029f71809bf0e39 Mon Sep 17 00:00:00 2001
From: Marco Martin <notmart@gmail.com>
Date: Wed, 15 Jun 2022 11:13:04 +0200
Subject: [PATCH 16/62] fix(effect): windows dragging in desktop grid

Don't disable the main drag handler when canclosewindows is disabled,
that one is not used to close windows but to drag them on other desktops or screens

BUG: 455268
---
 effect/effects/private/qml/WindowHeap.qml | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/effect/effects/private/qml/WindowHeap.qml b/effect/effects/private/qml/WindowHeap.qml
index 230f86fc7..66b45e799 100644
--- a/effect/effects/private/qml/WindowHeap.qml
+++ b/effect/effects/private/qml/WindowHeap.qml
@@ -396,8 +396,8 @@ FocusScope {
 
                 component DragManager : DragHandler {
                     id: dragHandler
-                    enabled: heap.supportsCloseWindows
                     target: null
+                    grabPermissions: PointerHandler.CanTakeOverFromHandlersOfSameType
 
                     readonly property double targetScale: {
                         if (!heap.supportsDragUpGesture) {
@@ -432,6 +432,7 @@ FocusScope {
                 DragManager {
                     id: touchDragHandler
                     acceptedDevices: PointerDevice.TouchScreen
+                    enabled: heap.supportsCloseWindows
                     readonly property double targetOpacity: {
                         if (!heap.supportsCloseWindows) {
                             return 1;
-- 
GitLab


From 6a421fc9f226790f5a6d7697d8da4a21de7b6d1a Mon Sep 17 00:00:00 2001
From: Marco Martin <notmart@gmail.com>
Date: Thu, 16 Jun 2022 15:20:13 +0200
Subject: [PATCH 17/62] fix(effect): don't use the plasma theme for icons in
 overview

don't attempt to use icons meant for the systray

BUG:455368
---
 effect/effects/private/qml/WindowHeap.qml | 1 +
 1 file changed, 1 insertion(+)

diff --git a/effect/effects/private/qml/WindowHeap.qml b/effect/effects/private/qml/WindowHeap.qml
index 66b45e799..303649b15 100644
--- a/effect/effects/private/qml/WindowHeap.qml
+++ b/effect/effects/private/qml/WindowHeap.qml
@@ -235,6 +235,7 @@ FocusScope {
 
                 PlasmaCore.IconItem {
                     id: icon
+                    usesPlasmaTheme: false
                     width: PlasmaCore.Units.iconSizes.large
                     height: width
                     source: thumb.client.icon
-- 
GitLab


From 60c5063b55792329c6f8c3ba68d2f999bc40402f Mon Sep 17 00:00:00 2001
From: Marco Martin <notmart@gmail.com>
Date: Mon, 20 Jun 2022 10:11:04 +0000
Subject: [PATCH 18/62] fix(effect): dragging especially by touch

The drag manager of a window now can take over from anything, so that
the events to initiate a drag are not stolen by the tap handlers
(fixes the drag starts only the second time is tried issue)

On wayland drag by touch was completely broken by the supportsclosewindows check,
now the touch drag handler is always active and the check of the property is done only
when the drag is over

BUG:455268
---
 effect/effects/private/qml/WindowHeap.qml | 8 ++------
 1 file changed, 2 insertions(+), 6 deletions(-)

diff --git a/effect/effects/private/qml/WindowHeap.qml b/effect/effects/private/qml/WindowHeap.qml
index 303649b15..a87d07751 100644
--- a/effect/effects/private/qml/WindowHeap.qml
+++ b/effect/effects/private/qml/WindowHeap.qml
@@ -398,7 +398,7 @@ FocusScope {
                 component DragManager : DragHandler {
                     id: dragHandler
                     target: null
-                    grabPermissions: PointerHandler.CanTakeOverFromHandlersOfSameType
+                    grabPermissions: PointerHandler.CanTakeOverFromAnything
 
                     readonly property double targetScale: {
                         if (!heap.supportsDragUpGesture) {
@@ -433,7 +433,6 @@ FocusScope {
                 DragManager {
                     id: touchDragHandler
                     acceptedDevices: PointerDevice.TouchScreen
-                    enabled: heap.supportsCloseWindows
                     readonly property double targetOpacity: {
                         if (!heap.supportsCloseWindows) {
                             return 1;
@@ -444,11 +443,8 @@ FocusScope {
                     }
 
                     onActiveChanged: {
-                        if (!heap.supportsCloseWindows) {
-                            return;
-                        }
                         if (!active) {
-                            if (targetOpacity < 0.4) {
+                            if (heap.supportsCloseWindows && targetOpacity < 0.4) {
                                 thumb.client.closeWindow();
                             }
                         }
-- 
GitLab


From 59cf5b464fd0292f5fa32c15b57372b24a590d88 Mon Sep 17 00:00:00 2001
From: Marco Martin <notmart@gmail.com>
Date: Wed, 22 Jun 2022 11:24:17 +0000
Subject: [PATCH 19/62] refactor(effect): move WindowHeap delegate to own file

This makes easier for individual effects to personalize it without adding ad-hoc api
in the main WindowHeap class. WindowHeap and WindowHEapDelegate are still quite
coupled and thing can probably still be improved, but the code should be more
readable already
---
 effect/effects/private/qml/WindowHeap.qml     | 369 +----------------
 .../private/qml/WindowHeapDelegate.qml        | 380 ++++++++++++++++++
 effect/effects/private/qmldir                 |   1 +
 3 files changed, 384 insertions(+), 366 deletions(-)
 create mode 100644 effect/effects/private/qml/WindowHeapDelegate.qml

diff --git a/effect/effects/private/qml/WindowHeap.qml b/effect/effects/private/qml/WindowHeap.qml
index a87d07751..9a3f9075f 100644
--- a/effect/effects/private/qml/WindowHeap.qml
+++ b/effect/effects/private/qml/WindowHeap.qml
@@ -22,11 +22,10 @@ FocusScope {
         Down
     }
 
-    property bool supportsCloseWindows: false
-    property bool supportsDragUpGesture: false
-    property bool showCaptions: true
     property alias model: windowsRepeater.model
+    property alias delegate: windowsRepeater.delegate
     property alias layout: expoLayout.mode
+    property alias expoLayout: expoLayout
     property int selectedIndex: -1
     property int animationDuration: PlasmaCore.Units.longDuration
     property bool animationEnabled: false
@@ -110,369 +109,7 @@ FocusScope {
 
         Repeater {
             id: windowsRepeater
-
-            Item {
-                id: thumb
-
-                required property QtObject client
-                required property int index
-
-                readonly property bool selected: heap.selectedIndex == index
-                readonly property bool hidden: {
-                    if (heap.showOnly === "activeClass") {
-                        return heap.activeClass !== String(thumb.client.resourceName); // thumb.client.resourceName is not an actual String as comes from a QByteArray so === would fail
-                    } else {
-                        return heap.showOnly.length && heap.showOnly.indexOf(client.internalId) == -1;
-                    }
-                }
-
-                Component.onCompleted: {
-                    if (thumb.client.active) {
-                        heap.activeClass = thumb.client.resourceName;
-                    }
-                }
-                Connections {
-                    target: thumb.client
-                    function onActiveChanged() {
-                        if (thumb.client.active) {
-                            heap.activeClass = thumb.client.resourceName;
-                        }
-                    }
-                }
-
-                state: {
-                    if (effect.gestureInProgress) {
-                        return "partial";
-                    }
-                    if (heap.effectiveOrganized) {
-                        return hidden ? "active-hidden" : "active";
-                    }
-                    return client.minimized ? "initial-minimized" : "initial";
-                }
-
-                visible: opacity > 0
-                z: thumb.activeDragHandler.active ? 100 : client.stackingOrder
-
-                component TweenBehavior : Behavior {
-                    enabled: thumb.state !== "partial" && heap.animationEnabled && !thumb.activeDragHandler.active
-                    NumberAnimation {
-                        duration: heap.animationDuration
-                        easing.type: Easing.OutCubic
-                    }
-                }
-
-                TweenBehavior on x {}
-                TweenBehavior on y {}
-                TweenBehavior on width {}
-                TweenBehavior on height {}
-
-                KWinComponents.WindowThumbnailItem {
-                    id: thumbSource
-                    wId: thumb.client.internalId
-                    state: thumb.activeDragHandler.active ? "drag" : "normal"
-                    readonly property QtObject screen: targetScreen
-                    readonly property QtObject client: thumb.client
-
-                    Drag.active: thumb.activeDragHandler.active
-                    Drag.source: thumb.client
-                    Drag.hotSpot: Qt.point(
-                        thumb.activeDragHandler.centroid.pressPosition.x * thumb.activeDragHandler.targetScale,
-                        thumb.activeDragHandler.centroid.pressPosition.y * thumb.activeDragHandler.targetScale)
-
-                    onXChanged: effect.checkItemDraggedOutOfScreen(thumbSource)
-                    onYChanged: effect.checkItemDraggedOutOfScreen(thumbSource)
-
-                    states: [
-                        State {
-                            name: "normal"
-                            PropertyChanges {
-                                target: thumbSource
-                                x: 0
-                                y: 0
-                                width: thumb.width
-                                height: thumb.height
-                            }
-                        },
-                        State {
-                            name: "drag"
-                            PropertyChanges {
-                                target: thumbSource
-                                x: -thumb.activeDragHandler.centroid.pressPosition.x * thumb.activeDragHandler.targetScale +
-                                        thumb.activeDragHandler.centroid.position.x
-                                y: -thumb.activeDragHandler.centroid.pressPosition.y * thumb.activeDragHandler.targetScale +
-                                        thumb.activeDragHandler.centroid.position.y
-                                width: cell.width * thumb.activeDragHandler.targetScale
-                                height: cell.height * thumb.activeDragHandler.targetScale
-                                opacity: thumb.activeDragHandler.targetOpacity
-                            }
-                        }
-                    ]
-                    transitions: Transition {
-                        to: "normal"
-                        enabled: heap.animationEnabled
-                        NumberAnimation {
-                            duration: heap.animationDuration
-                            properties: "x, y, width, height, opacity"
-                            easing.type: Easing.OutCubic
-                        }
-                    }
-
-                    MouseArea {
-                        anchors.fill: parent
-                        acceptedButtons: Qt.NoButton
-                        cursorShape: thumb.activeDragHandler.active ? Qt.ClosedHandCursor : Qt.ArrowCursor
-                    }
-                }
-
-                PC3.Label {
-                    anchors.fill: thumbSource
-                    horizontalAlignment: Text.AlignHCenter
-                    verticalAlignment: Text.AlignVCenter
-                    text: i18nd("kwin_effects", "Drag Down To Close")
-                    opacity: 1 - thumbSource.opacity
-                    visible: !thumb.hidden
-                }
-
-                PlasmaCore.IconItem {
-                    id: icon
-                    usesPlasmaTheme: false
-                    width: PlasmaCore.Units.iconSizes.large
-                    height: width
-                    source: thumb.client.icon
-                    anchors.horizontalCenter: thumbSource.horizontalCenter
-                    anchors.bottom: thumbSource.bottom
-                    anchors.bottomMargin: -height / 4
-                    visible: !thumb.hidden && !activeDragHandler.active
-
-
-                    PC3.Label {
-                        id: caption
-                        visible: heap.showCaptions
-                        width: Math.min(implicitWidth, thumbSource.width)
-                        anchors.top: parent.bottom
-                        anchors.horizontalCenter: parent.horizontalCenter
-                        elide: Text.ElideRight
-                        text: thumb.client.caption
-                        horizontalAlignment: Text.AlignHCenter
-                        verticalAlignment: Text.AlignVCenter
-                    }
-                }
-
-                ExpoCell {
-                    id: cell
-                    layout: expoLayout
-                    enabled: !thumb.hidden
-                    naturalX: thumb.client.x - targetScreen.geometry.x - expoLayout.Kirigami.ScenePosition.x
-                    naturalY: thumb.client.y - targetScreen.geometry.y - expoLayout.Kirigami.ScenePosition.y
-                    naturalWidth: thumb.client.width
-                    naturalHeight: thumb.client.height
-                    persistentKey: thumb.client.internalId
-                    bottomMargin: icon.height / 4 + caption.height
-                }
-
-                states: [
-                    State {
-                        name: "initial"
-                        PropertyChanges {
-                            target: thumb
-                            x: thumb.client.x - targetScreen.geometry.x - (heap.absolutePositioning ?  expoLayout.Kirigami.ScenePosition.x : 0)
-                            y: thumb.client.y - targetScreen.geometry.y - (heap.absolutePositioning ?  expoLayout.Kirigami.ScenePosition.y : 0)
-                            width: thumb.client.width
-                            height: thumb.client.height
-                        }
-                        PropertyChanges {
-                            target: icon
-                            opacity: 0
-                        }
-                        PropertyChanges {
-                            target: closeButton
-                            opacity: 0
-                        }
-                    },
-                    State {
-                        name: "partial"
-                        PropertyChanges {
-                            target: thumb
-                            x: (thumb.client.x - targetScreen.geometry.x - (heap.absolutePositioning ?  expoLayout.Kirigami.ScenePosition.x : 0)) * (1 - effect.partialActivationFactor) + cell.x * effect.partialActivationFactor
-                            y: (thumb.client.y - targetScreen.geometry.y - (heap.absolutePositioning ?  expoLayout.Kirigami.ScenePosition.y : 0)) * (1 - effect.partialActivationFactor) + cell.y * effect.partialActivationFactor
-                            width: thumb.client.width * (1 - effect.partialActivationFactor) + cell.width * effect.partialActivationFactor
-                            height: thumb.client.height * (1 - effect.partialActivationFactor) + cell.height * effect.partialActivationFactor
-                            opacity: thumb.client.minimized ? effect.partialActivationFactor : 1
-                        }
-                        PropertyChanges {
-                            target: icon
-                            opacity: effect.partialActivationFactor
-                        }
-                        PropertyChanges {
-                            target: closeButton
-                            opacity: effect.partialActivationFactor
-                        }
-                    },
-                    State {
-                        name: "initial-minimized"
-                        extend: "initial"
-                        PropertyChanges {
-                            target: thumb
-                            opacity: 0
-                        }
-                        PropertyChanges {
-                            target: icon
-                            opacity: 0
-                        }
-                        PropertyChanges {
-                            target: closeButton
-                            opacity: 0
-                        }
-                    },
-                    State {
-                        name: "active"
-                        PropertyChanges {
-                            target: thumb
-                            x: cell.x
-                            y: cell.y
-                            width: cell.width
-                            height: cell.height
-                        }
-                        PropertyChanges {
-                            target: icon
-                            opacity: 1
-                        }
-                        PropertyChanges {
-                            target: closeButton
-                            opacity: 1
-                        }
-                    },
-                    State {
-                        name: "active-hidden"
-                        extend: "active"
-                        PropertyChanges {
-                            target: thumb
-                            opacity: 0
-                        }
-                    }
-                ]
-
-                transitions: Transition {
-                    to: "initial, active, active-hidden"
-                    enabled: heap.animationEnabled
-                    NumberAnimation {
-                        duration: heap.animationDuration
-                        properties: "x, y, width, height, opacity"
-                        easing.type: Easing.InOutCubic
-                    }
-                }
-
-
-                PlasmaCore.FrameSvgItem {
-                    anchors.fill: parent
-                    anchors.margins: -PlasmaCore.Units.smallSpacing
-                    imagePath: "widgets/viewitem"
-                    prefix: "hover"
-                    z: -1
-                    visible: !thumb.activeDragHandler.active && (hoverHandler.hovered || selected)
-                }
-
-                HoverHandler {
-                    id: hoverHandler
-                    onHoveredChanged: if (hovered != selected) {
-                        heap.resetSelected();
-                    }
-                }
-
-                TapHandler {
-                    acceptedButtons: Qt.LeftButton
-                    onTapped: {
-                        KWinComponents.Workspace.activeClient = thumb.client;
-                        heap.activated();
-                    }
-                }
-
-                TapHandler {
-                    acceptedPointerTypes: PointerDevice.GenericPointer | PointerDevice.Pen
-                    acceptedButtons: Qt.LeftButton | Qt.MiddleButton | Qt.RightButton
-                    onTapped: {
-                        heap.windowClicked(thumb.client, eventPoint)
-                    }
-                }
-
-                component DragManager : DragHandler {
-                    id: dragHandler
-                    target: null
-                    grabPermissions: PointerHandler.CanTakeOverFromAnything
-
-                    readonly property double targetScale: {
-                        if (!heap.supportsDragUpGesture) {
-                            return 1;
-                        }
-                        const localPressPosition = centroid.scenePressPosition.y - expoLayout.Kirigami.ScenePosition.y;
-                        if (localPressPosition == 0) {
-                            return 0.1
-                        } else {
-                            const localPosition = centroid.scenePosition.y - expoLayout.Kirigami.ScenePosition.y;
-                            return Math.max(0.1, Math.min(localPosition / localPressPosition, 1))
-                        }
-                    }
-
-                    onActiveChanged: {
-                        heap.dragActive = active;
-                        if (active) {
-                            thumb.activeDragHandler = dragHandler;
-                        } else {
-                            thumbSource.Drag.drop();
-                            let globalPos = targetScreen.mapToGlobal(centroid.scenePosition);
-                            effect.checkItemDroppedOutOfScreen(globalPos, thumbSource);
-                        }
-                    }
-                }
-                property DragManager activeDragHandler: dragHandler
-                DragManager {
-                    id: dragHandler
-                    readonly property double targetOpacity: 1
-                    acceptedDevices: PointerDevice.Mouse | PointerDevice.TouchPad | PointerDevice.Stylus
-                }
-                DragManager {
-                    id: touchDragHandler
-                    acceptedDevices: PointerDevice.TouchScreen
-                    readonly property double targetOpacity: {
-                        if (!heap.supportsCloseWindows) {
-                            return 1;
-                        }
-                        const startDistance = heap.Kirigami.ScenePosition.y + heap.height - centroid.scenePressPosition.y;
-                        const localPosition = heap.Kirigami.ScenePosition.y + heap.height - centroid.scenePosition.y;
-                        return Math.min(localPosition / startDistance, 1);
-                    }
-
-                    onActiveChanged: {
-                        if (!active) {
-                            if (heap.supportsCloseWindows && targetOpacity < 0.4) {
-                                thumb.client.closeWindow();
-                            }
-                        }
-                    }
-                }
-
-                PC3.Button {
-                    id: closeButton
-                    visible: heap.supportsCloseWindows && (hoverHandler.hovered || Kirigami.Settings.tabletMode || Kirigami.Settings.hasTransientTouchInput) && thumb.client.closeable && !dragHandler.active
-                    anchors {
-                        right: thumbSource.right
-                        rightMargin: PlasmaCore.Units.smallSpacing
-                        top: thumbSource.top
-                        topMargin: PlasmaCore.Units.smallSpacing
-                    }
-                    LayoutMirroring.enabled: Qt.application.layoutDirection === Qt.RightToLeft
-                    icon.name: "window-close"
-                    implicitWidth: PlasmaCore.Units.iconSizes.medium
-                    implicitHeight: implicitWidth
-                    onClicked: thumb.client.closeWindow();
-                }
-
-                Component.onDestruction: {
-                    if (selected) {
-                        heap.resetSelected();
-                    }
-                }
-            }
+            delegate: WindowHeapDelegate {}
         }
     }
 
diff --git a/effect/effects/private/qml/WindowHeapDelegate.qml b/effect/effects/private/qml/WindowHeapDelegate.qml
new file mode 100644
index 000000000..e318c9e9f
--- /dev/null
+++ b/effect/effects/private/qml/WindowHeapDelegate.qml
@@ -0,0 +1,380 @@
+/*
+    SPDX-FileCopyrightText: 2021 Vlad Zahorodnii <vlad.zahorodnii@kde.org>
+
+    SPDX-License-Identifier: GPL-2.0-or-later
+*/
+
+import QtQuick 2.12
+import QtQuick.Window 2.12
+import org.kde.kirigami 2.12 as Kirigami
+import org.kde.kwin 3.0 as KWinComponents
+import org.kde.kwin.private.effects 1.0
+import org.kde.plasma.components 3.0 as PC3
+import org.kde.plasma.core 2.0 as PlasmaCore
+
+
+Item {
+    id: thumb
+
+    required property QtObject client
+    required property int index
+    required property Item windowHeap
+
+    readonly property alias dragHandler: thumb.activeDragHandler
+    readonly property bool selected: thumb.windowHeap.selectedIndex == index
+    //TODO: move?
+    readonly property bool hidden: {
+        if (thumb.windowHeap.showOnly === "activeClass") {
+            return thumb.windowHeap.activeClass !== String(thumb.client.resourceName); // thumb.client.resourceName is not an actual String as comes from a QByteArray so === would fail
+        } else {
+            return thumb.windowHeap.showOnly.length && thumb.windowHeap.showOnly.indexOf(client.internalId) == -1;
+        }
+    }
+
+    // Show a close button on this thumbnail
+    property bool closeButtonVisible: true
+    // Show a text label under this thumbnail
+    property bool windowTitleVisible: true
+
+    //scale up and down the whole thumbnail without affecting layouting
+    property real targetScale: 1.0
+
+    // Swipe down gesture by touch, in some effects will close the window
+    readonly property alias downGestureProgress: touchDragHandler.downGestureProgress
+    signal downGestureTriggered()
+
+
+
+    Component.onCompleted: {
+        if (thumb.client.active) {
+            thumb.windowHeap.activeClass = thumb.client.resourceName;
+        }
+    }
+    Connections {
+        target: thumb.client
+        function onActiveChanged() {
+            if (thumb.client.active) {
+                thumb.windowHeap.activeClass = thumb.client.resourceName;
+            }
+        }
+    }
+
+    state: {
+        if (effect.gestureInProgress) {
+            return "partial";
+        }
+        if (thumb.windowHeap.effectiveOrganized) {
+            return hidden ? "active-hidden" : "active";
+        }
+        return client.minimized ? "initial-minimized" : "initial";
+    }
+
+    visible: opacity > 0
+    z: thumb.activeDragHandler.active ? 100 : client.stackingOrder
+
+    component TweenBehavior : Behavior {
+        enabled: thumb.state !== "partial" && thumb.windowHeap.animationEnabled && !thumb.activeDragHandler.active
+        NumberAnimation {
+            duration: thumb.windowHeap.animationDuration
+            easing.type: Easing.OutCubic
+        }
+    }
+
+    TweenBehavior on x {}
+    TweenBehavior on y {}
+    TweenBehavior on width {}
+    TweenBehavior on height {}
+
+    KWinComponents.WindowThumbnailItem {
+        id: thumbSource
+        wId: thumb.client.internalId
+        state: thumb.activeDragHandler.active ? "drag" : "normal"
+        readonly property QtObject screen: targetScreen
+        readonly property QtObject client: thumb.client
+
+        Drag.active: thumb.activeDragHandler.active
+        Drag.source: thumb.client
+        Drag.hotSpot: Qt.point(
+            thumb.activeDragHandler.centroid.pressPosition.x * thumb.targetScale,
+            thumb.activeDragHandler.centroid.pressPosition.y * thumb.targetScale)
+
+        onXChanged: effect.checkItemDraggedOutOfScreen(thumbSource)
+        onYChanged: effect.checkItemDraggedOutOfScreen(thumbSource)
+
+        states: [
+            State {
+                name: "normal"
+                PropertyChanges {
+                    target: thumbSource
+                    x: 0
+                    y: 0
+                    width: thumb.width * thumb.targetScale
+                    height: thumb.height * thumb.targetScale
+                }
+            },
+            State {
+                name: "drag"
+                PropertyChanges {
+                    target: thumbSource
+                    x: -thumb.activeDragHandler.centroid.pressPosition.x * thumb.targetScale +
+                            thumb.activeDragHandler.centroid.position.x
+                    y: -thumb.activeDragHandler.centroid.pressPosition.y * thumb.targetScale +
+                            thumb.activeDragHandler.centroid.position.y
+                    width: cell.width * thumb.targetScale
+                    height: cell.height * thumb.targetScale
+                    opacity: thumb.activeDragHandler.targetOpacity
+                }
+            }
+        ]
+        transitions: Transition {
+            to: "normal"
+            enabled: thumb.windowHeap.animationEnabled
+            NumberAnimation {
+                duration: thumb.windowHeap.animationDuration
+                properties: "x, y, width, height, opacity"
+                easing.type: Easing.OutCubic
+            }
+        }
+
+        MouseArea {
+            anchors.fill: parent
+            acceptedButtons: Qt.NoButton
+            cursorShape: thumb.activeDragHandler.active ? Qt.ClosedHandCursor : Qt.ArrowCursor
+        }
+    }
+
+    PC3.Label {
+        anchors.fill: thumbSource
+        horizontalAlignment: Text.AlignHCenter
+        verticalAlignment: Text.AlignVCenter
+        text: i18nd("kwin_effects", "Drag Down To Close")
+        opacity: 1 - thumbSource.opacity
+        visible: !thumb.hidden
+    }
+
+    PlasmaCore.IconItem {
+        id: icon
+        width: PlasmaCore.Units.iconSizes.large
+        height: width
+        source: thumb.client.icon
+        anchors.horizontalCenter: thumbSource.horizontalCenter
+        anchors.bottom: thumbSource.bottom
+        anchors.bottomMargin: -height / 4
+        visible: !thumb.hidden && !activeDragHandler.active
+
+
+        PC3.Label {
+            id: caption
+            visible: thumb.windowTitleVisible
+            width: Math.min(implicitWidth, thumbSource.width)
+            anchors.top: parent.bottom
+            anchors.horizontalCenter: parent.horizontalCenter
+            elide: Text.ElideRight
+            text: thumb.client.caption
+            horizontalAlignment: Text.AlignHCenter
+            verticalAlignment: Text.AlignVCenter
+        }
+    }
+
+    ExpoCell {
+        id: cell
+        layout: windowHeap.expoLayout
+        enabled: !thumb.hidden
+        naturalX: thumb.client.x - targetScreen.geometry.x - windowHeap.expoLayout.Kirigami.ScenePosition.x
+        naturalY: thumb.client.y - targetScreen.geometry.y - windowHeap.expoLayout.Kirigami.ScenePosition.y
+        naturalWidth: thumb.client.width
+        naturalHeight: thumb.client.height
+        persistentKey: thumb.client.internalId
+        bottomMargin: icon.height / 4 + caption.height
+    }
+
+    states: [
+        State {
+            name: "initial"
+            PropertyChanges {
+                target: thumb
+                x: thumb.client.x - targetScreen.geometry.x - (thumb.windowHeap.absolutePositioning ?  windowHeap.expoLayout.Kirigami.ScenePosition.x : 0)
+                y: thumb.client.y - targetScreen.geometry.y - (thumb.windowHeap.absolutePositioning ?  windowHeap.expoLayout.Kirigami.ScenePosition.y : 0)
+                width: thumb.client.width
+                height: thumb.client.height
+            }
+            PropertyChanges {
+                target: icon
+                opacity: 0
+            }
+            PropertyChanges {
+                target: closeButton
+                opacity: 0
+            }
+        },
+        State {
+            name: "partial"
+            PropertyChanges {
+                target: thumb
+                x: (thumb.client.x - targetScreen.geometry.x - (thumb.windowHeap.absolutePositioning ?  windowHeap.expoLayout.Kirigami.ScenePosition.x : 0)) * (1 - effect.partialActivationFactor) + cell.x * effect.partialActivationFactor
+                y: (thumb.client.y - targetScreen.geometry.y - (thumb.windowHeap.absolutePositioning ?  windowHeap.expoLayout.Kirigami.ScenePosition.y : 0)) * (1 - effect.partialActivationFactor) + cell.y * effect.partialActivationFactor
+                width: thumb.client.width * (1 - effect.partialActivationFactor) + cell.width * effect.partialActivationFactor
+                height: thumb.client.height * (1 - effect.partialActivationFactor) + cell.height * effect.partialActivationFactor
+                opacity: thumb.client.minimized ? effect.partialActivationFactor : 1
+            }
+            PropertyChanges {
+                target: icon
+                opacity: effect.partialActivationFactor
+            }
+            PropertyChanges {
+                target: closeButton
+                opacity: effect.partialActivationFactor
+            }
+        },
+        State {
+            name: "initial-minimized"
+            extend: "initial"
+            PropertyChanges {
+                target: thumb
+                opacity: 0
+            }
+            PropertyChanges {
+                target: icon
+                opacity: 0
+            }
+            PropertyChanges {
+                target: closeButton
+                opacity: 0
+            }
+        },
+        State {
+            name: "active"
+            PropertyChanges {
+                target: thumb
+                x: cell.x
+                y: cell.y
+                width: cell.width
+                height: cell.height
+            }
+            PropertyChanges {
+                target: icon
+                opacity: 1
+            }
+            PropertyChanges {
+                target: closeButton
+                opacity: 1
+            }
+        },
+        State {
+            name: "active-hidden"
+            extend: "active"
+            PropertyChanges {
+                target: thumb
+                opacity: 0
+            }
+        }
+    ]
+
+    transitions: Transition {
+        to: "initial, active, active-hidden"
+        enabled: thumb.windowHeap.animationEnabled
+        NumberAnimation {
+            duration: thumb.windowHeap.animationDuration
+            properties: "x, y, width, height, opacity"
+            easing.type: Easing.InOutCubic
+        }
+    }
+
+
+    PlasmaCore.FrameSvgItem {
+        anchors.fill: parent
+        anchors.margins: -PlasmaCore.Units.smallSpacing
+        imagePath: "widgets/viewitem"
+        prefix: "hover"
+        z: -1
+        visible: !thumb.activeDragHandler.active && (hoverHandler.hovered || selected)
+    }
+
+    HoverHandler {
+        id: hoverHandler
+        onHoveredChanged: if (hovered != selected) {
+            thumb.windowHeap.resetSelected();
+        }
+    }
+
+    TapHandler {
+        acceptedButtons: Qt.LeftButton
+        onTapped: {
+            KWinComponents.Workspace.activeClient = thumb.client;
+            thumb.windowHeap.activated();
+        }
+    }
+
+    TapHandler {
+        acceptedPointerTypes: PointerDevice.GenericPointer | PointerDevice.Pen
+        acceptedButtons: Qt.LeftButton | Qt.MiddleButton | Qt.RightButton
+        onTapped: {
+            thumb.windowHeap.windowClicked(thumb.client, eventPoint)
+        }
+    }
+
+    component DragManager : DragHandler {
+        id: dragHandler
+        target: null
+        grabPermissions: PointerHandler.CanTakeOverFromAnything
+
+        onActiveChanged: {
+            thumb.windowHeap.dragActive = active;
+            if (active) {
+                thumb.activeDragHandler = dragHandler;
+            } else {
+                thumbSource.Drag.drop();
+                var globalPos = targetScreen.mapToGlobal(centroid.scenePosition);
+                effect.checkItemDroppedOutOfScreen(globalPos, thumbSource);
+            }
+        }
+    }
+    property DragManager activeDragHandler: dragHandler
+    DragManager {
+        id: dragHandler
+        acceptedDevices: PointerDevice.Mouse | PointerDevice.TouchPad | PointerDevice.Stylus
+    }
+    DragManager {
+        id: touchDragHandler
+        acceptedDevices: PointerDevice.TouchScreen
+        readonly property double downGestureProgress: {
+            if (!active) {
+                return 0.0;
+            }
+
+            const startDistance = thumb.windowHeap.Kirigami.ScenePosition.y + thumb.windowHeap.height - centroid.scenePressPosition.y;
+            const localPosition = thumb.windowHeap.Kirigami.ScenePosition.y + thumb.windowHeap.height - centroid.scenePosition.y;
+            return Math.min(startDistance / localPosition, 1);
+        }
+
+        onActiveChanged: {
+            if (!active) {
+                if (downGestureProgress > 0.6) {
+                    thumb.downGestureTriggered();
+                }
+            }
+        }
+    }
+
+    PC3.Button {
+        id: closeButton
+        visible: thumb.closeButtonVisible && (hoverHandler.hovered || Kirigami.Settings.tabletMode || Kirigami.Settings.hasTransientTouchInput) && thumb.client.closeable && !dragHandler.active
+        anchors {
+            right: thumbSource.right
+            rightMargin: PlasmaCore.Units.smallSpacing
+            top: thumbSource.top
+            topMargin: PlasmaCore.Units.smallSpacing
+        }
+        LayoutMirroring.enabled: Qt.application.layoutDirection === Qt.RightToLeft
+        icon.name: "window-close"
+        implicitWidth: PlasmaCore.Units.iconSizes.medium
+        implicitHeight: implicitWidth
+        onClicked: thumb.client.closeWindow();
+    }
+
+    Component.onDestruction: {
+        if (selected) {
+            thumb.windowHeap.resetSelected();
+        }
+    }
+}
diff --git a/effect/effects/private/qmldir b/effect/effects/private/qmldir
index ee0ffb03a..4dd3210d4 100644
--- a/effect/effects/private/qmldir
+++ b/effect/effects/private/qmldir
@@ -8,3 +8,4 @@ plugin effectsplugin
 classname EffectKitExtensionPlugin
 
 WindowHeap 1.0 WindowHeap.qml
+WindowHeapDelegate 1.0 WindowHeapDelegate.qml
-- 
GitLab


From 4554efb267e1ee2b57996e4293f23c06b7671072 Mon Sep 17 00:00:00 2001
From: Marco Martin <notmart@gmail.com>
Date: Wed, 22 Jun 2022 17:54:54 +0200
Subject: [PATCH 20/62] fix(effect): the math of the down gesture

---
 effect/effects/private/qml/WindowHeapDelegate.qml | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/effect/effects/private/qml/WindowHeapDelegate.qml b/effect/effects/private/qml/WindowHeapDelegate.qml
index e318c9e9f..6f71b402d 100644
--- a/effect/effects/private/qml/WindowHeapDelegate.qml
+++ b/effect/effects/private/qml/WindowHeapDelegate.qml
@@ -344,7 +344,7 @@ Item {
 
             const startDistance = thumb.windowHeap.Kirigami.ScenePosition.y + thumb.windowHeap.height - centroid.scenePressPosition.y;
             const localPosition = thumb.windowHeap.Kirigami.ScenePosition.y + thumb.windowHeap.height - centroid.scenePosition.y;
-            return Math.min(startDistance / localPosition, 1);
+            return 1 - Math.min(localPosition/startDistance, 1);
         }
 
         onActiveChanged: {
-- 
GitLab


From 38256efcc90bfb625efc9058faf5ddfa2d68c29b Mon Sep 17 00:00:00 2001
From: Vlad Zahorodnii <vlad.zahorodnii@kde.org>
Date: Thu, 23 Jun 2022 12:13:00 +0300
Subject: [PATCH 21/62] fix(effect): a type mismatch warning in WindowHeap

file:///data/projects/usr/lib/qml/org/kde/kwin/private/effects/WindowHeap.qml:55:9:
Unable to assign null to QUuid
---
 effect/effects/private/qml/WindowHeap.qml | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/effect/effects/private/qml/WindowHeap.qml b/effect/effects/private/qml/WindowHeap.qml
index 9a3f9075f..ff2ec1b38 100644
--- a/effect/effects/private/qml/WindowHeap.qml
+++ b/effect/effects/private/qml/WindowHeap.qml
@@ -53,7 +53,7 @@ FocusScope {
         z: 2
         property KWinComponents.WindowThumbnailItem cloneOf
         visible: false
-        wId: cloneOf ? cloneOf.wId : null
+        client: cloneOf ? cloneOf.client : null
         width: cloneOf ? cloneOf.width : 0
         height: cloneOf ? cloneOf.height : 0
         onCloneOfChanged: {
-- 
GitLab


From 11991c1d6148eadad2c5777c57d90d2572d4c3ed Mon Sep 17 00:00:00 2001
From: Vlad Zahorodnii <vlad.zahorodnii@kde.org>
Date: Thu, 23 Jun 2022 12:04:49 +0300
Subject: [PATCH 22/62] refactor(effect): make setting WindowHeap layout mode
 nicer

Expose only the layout object and set its mode using "layout.mode:"
syntax rather than expose the layout object and its properties in the
WindowHeap.
---
 effect/effects/private/qml/WindowHeap.qml         |  3 +--
 effect/effects/private/qml/WindowHeapDelegate.qml | 14 +++++++-------
 2 files changed, 8 insertions(+), 9 deletions(-)

diff --git a/effect/effects/private/qml/WindowHeap.qml b/effect/effects/private/qml/WindowHeap.qml
index ff2ec1b38..ca47ebb8d 100644
--- a/effect/effects/private/qml/WindowHeap.qml
+++ b/effect/effects/private/qml/WindowHeap.qml
@@ -24,8 +24,7 @@ FocusScope {
 
     property alias model: windowsRepeater.model
     property alias delegate: windowsRepeater.delegate
-    property alias layout: expoLayout.mode
-    property alias expoLayout: expoLayout
+    property alias layout: expoLayout
     property int selectedIndex: -1
     property int animationDuration: PlasmaCore.Units.longDuration
     property bool animationEnabled: false
diff --git a/effect/effects/private/qml/WindowHeapDelegate.qml b/effect/effects/private/qml/WindowHeapDelegate.qml
index 6f71b402d..0e17a14fd 100644
--- a/effect/effects/private/qml/WindowHeapDelegate.qml
+++ b/effect/effects/private/qml/WindowHeapDelegate.qml
@@ -178,10 +178,10 @@ Item {
 
     ExpoCell {
         id: cell
-        layout: windowHeap.expoLayout
+        layout: windowHeap.layout
         enabled: !thumb.hidden
-        naturalX: thumb.client.x - targetScreen.geometry.x - windowHeap.expoLayout.Kirigami.ScenePosition.x
-        naturalY: thumb.client.y - targetScreen.geometry.y - windowHeap.expoLayout.Kirigami.ScenePosition.y
+        naturalX: thumb.client.x - targetScreen.geometry.x - windowHeap.layout.Kirigami.ScenePosition.x
+        naturalY: thumb.client.y - targetScreen.geometry.y - windowHeap.layout.Kirigami.ScenePosition.y
         naturalWidth: thumb.client.width
         naturalHeight: thumb.client.height
         persistentKey: thumb.client.internalId
@@ -193,8 +193,8 @@ Item {
             name: "initial"
             PropertyChanges {
                 target: thumb
-                x: thumb.client.x - targetScreen.geometry.x - (thumb.windowHeap.absolutePositioning ?  windowHeap.expoLayout.Kirigami.ScenePosition.x : 0)
-                y: thumb.client.y - targetScreen.geometry.y - (thumb.windowHeap.absolutePositioning ?  windowHeap.expoLayout.Kirigami.ScenePosition.y : 0)
+                x: thumb.client.x - targetScreen.geometry.x - (thumb.windowHeap.absolutePositioning ?  windowHeap.layout.Kirigami.ScenePosition.x : 0)
+                y: thumb.client.y - targetScreen.geometry.y - (thumb.windowHeap.absolutePositioning ?  windowHeap.layout.Kirigami.ScenePosition.y : 0)
                 width: thumb.client.width
                 height: thumb.client.height
             }
@@ -211,8 +211,8 @@ Item {
             name: "partial"
             PropertyChanges {
                 target: thumb
-                x: (thumb.client.x - targetScreen.geometry.x - (thumb.windowHeap.absolutePositioning ?  windowHeap.expoLayout.Kirigami.ScenePosition.x : 0)) * (1 - effect.partialActivationFactor) + cell.x * effect.partialActivationFactor
-                y: (thumb.client.y - targetScreen.geometry.y - (thumb.windowHeap.absolutePositioning ?  windowHeap.expoLayout.Kirigami.ScenePosition.y : 0)) * (1 - effect.partialActivationFactor) + cell.y * effect.partialActivationFactor
+                x: (thumb.client.x - targetScreen.geometry.x - (thumb.windowHeap.absolutePositioning ?  windowHeap.layout.Kirigami.ScenePosition.x : 0)) * (1 - effect.partialActivationFactor) + cell.x * effect.partialActivationFactor
+                y: (thumb.client.y - targetScreen.geometry.y - (thumb.windowHeap.absolutePositioning ?  windowHeap.layout.Kirigami.ScenePosition.y : 0)) * (1 - effect.partialActivationFactor) + cell.y * effect.partialActivationFactor
                 width: thumb.client.width * (1 - effect.partialActivationFactor) + cell.width * effect.partialActivationFactor
                 height: thumb.client.height * (1 - effect.partialActivationFactor) + cell.height * effect.partialActivationFactor
                 opacity: thumb.client.minimized ? effect.partialActivationFactor : 1
-- 
GitLab


From b557c3ad2e9864fe36a029f639f3a7d1dc1e40d9 Mon Sep 17 00:00:00 2001
From: Nate Graham <nate@kde.org>
Date: Tue, 5 Jul 2022 08:25:54 -0600
Subject: [PATCH 23/62] fix(effect): add tooltip and accessibility info to
 close button

BUG: 456242
FIXED-IN: 5.26
---
 effect/effects/private/qml/WindowHeapDelegate.qml | 8 ++++++++
 1 file changed, 8 insertions(+)

diff --git a/effect/effects/private/qml/WindowHeapDelegate.qml b/effect/effects/private/qml/WindowHeapDelegate.qml
index 0e17a14fd..4ef16b620 100644
--- a/effect/effects/private/qml/WindowHeapDelegate.qml
+++ b/effect/effects/private/qml/WindowHeapDelegate.qml
@@ -366,10 +366,18 @@ Item {
             topMargin: PlasmaCore.Units.smallSpacing
         }
         LayoutMirroring.enabled: Qt.application.layoutDirection === Qt.RightToLeft
+        text: i18ndc("kwin_effects", "@info:tooltip as in: 'close this window'", "Close window")
         icon.name: "window-close"
         implicitWidth: PlasmaCore.Units.iconSizes.medium
         implicitHeight: implicitWidth
         onClicked: thumb.client.closeWindow();
+
+        display: PC3.AbstractButton.IconOnly
+
+        PC3.ToolTip.text: text
+        PC3.ToolTip.visible: hovered && display === PC3.AbstractButton.IconOnly
+        PC3.ToolTip.delay: Kirigami.Units.toolTipDelay
+        Accessible.name: text
     }
 
     Component.onDestruction: {
-- 
GitLab


From 1194c354ef823db6d26517badae695780f944136 Mon Sep 17 00:00:00 2001
From: Nate Graham <nate@kde.org>
Date: Tue, 5 Jul 2022 08:43:50 -0600
Subject: [PATCH 24/62] refactor(effect): clean up code for buttons with
 tooltips

---
 effect/effects/private/qml/WindowHeapDelegate.qml | 14 +++++++-------
 1 file changed, 7 insertions(+), 7 deletions(-)

diff --git a/effect/effects/private/qml/WindowHeapDelegate.qml b/effect/effects/private/qml/WindowHeapDelegate.qml
index 4ef16b620..47f813229 100644
--- a/effect/effects/private/qml/WindowHeapDelegate.qml
+++ b/effect/effects/private/qml/WindowHeapDelegate.qml
@@ -358,26 +358,26 @@ Item {
 
     PC3.Button {
         id: closeButton
-        visible: thumb.closeButtonVisible && (hoverHandler.hovered || Kirigami.Settings.tabletMode || Kirigami.Settings.hasTransientTouchInput) && thumb.client.closeable && !dragHandler.active
+
         anchors {
             right: thumbSource.right
-            rightMargin: PlasmaCore.Units.smallSpacing
             top: thumbSource.top
-            topMargin: PlasmaCore.Units.smallSpacing
+            margins: PlasmaCore.Units.smallSpacing
         }
+
+        visible: thumb.closeButtonVisible && (hoverHandler.hovered || Kirigami.Settings.tabletMode || Kirigami.Settings.hasTransientTouchInput) && thumb.client.closeable && !dragHandler.active
         LayoutMirroring.enabled: Qt.application.layoutDirection === Qt.RightToLeft
+
         text: i18ndc("kwin_effects", "@info:tooltip as in: 'close this window'", "Close window")
         icon.name: "window-close"
-        implicitWidth: PlasmaCore.Units.iconSizes.medium
-        implicitHeight: implicitWidth
-        onClicked: thumb.client.closeWindow();
-
         display: PC3.AbstractButton.IconOnly
 
         PC3.ToolTip.text: text
         PC3.ToolTip.visible: hovered && display === PC3.AbstractButton.IconOnly
         PC3.ToolTip.delay: Kirigami.Units.toolTipDelay
         Accessible.name: text
+
+        onClicked: thumb.client.closeWindow();
     }
 
     Component.onDestruction: {
-- 
GitLab


From 93e620f96122f64000e8c801acb671b76b48316e Mon Sep 17 00:00:00 2001
From: Xaver Hugl <xaver.hugl@gmail.com>
Date: Wed, 6 Jul 2022 16:42:37 +0200
Subject: [PATCH 25/62] fix(effect): handle windows from other virtual desktops
 better

Sometimes windows on other desktops are higher in the stacking order,
which causes them to unexpectedly jump above windows from the current
desktop in the effect.

To fix that, the z index is adjusted to be higher for windows on the active
virtual desktop, and windows from other desktops get reduced opacity in the
beginning of the animation
---
 effect/effects/private/qml/WindowHeapDelegate.qml | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/effect/effects/private/qml/WindowHeapDelegate.qml b/effect/effects/private/qml/WindowHeapDelegate.qml
index 47f813229..1690e7173 100644
--- a/effect/effects/private/qml/WindowHeapDelegate.qml
+++ b/effect/effects/private/qml/WindowHeapDelegate.qml
@@ -70,7 +70,7 @@ Item {
     }
 
     visible: opacity > 0
-    z: thumb.activeDragHandler.active ? 100 : client.stackingOrder
+    z: thumb.activeDragHandler.active ? 100 : client.stackingOrder + (thumb.client.desktop == KWinComponents.Workspace.currentDesktop ? 100 : 0)
 
     component TweenBehavior : Behavior {
         enabled: thumb.state !== "partial" && thumb.windowHeap.animationEnabled && !thumb.activeDragHandler.active
@@ -215,7 +215,7 @@ Item {
                 y: (thumb.client.y - targetScreen.geometry.y - (thumb.windowHeap.absolutePositioning ?  windowHeap.layout.Kirigami.ScenePosition.y : 0)) * (1 - effect.partialActivationFactor) + cell.y * effect.partialActivationFactor
                 width: thumb.client.width * (1 - effect.partialActivationFactor) + cell.width * effect.partialActivationFactor
                 height: thumb.client.height * (1 - effect.partialActivationFactor) + cell.height * effect.partialActivationFactor
-                opacity: thumb.client.minimized ? effect.partialActivationFactor : 1
+                opacity: thumb.client.minimized || thumb.client.desktop != KWinComponents.Workspace.currentDesktop ? effect.partialActivationFactor : 1
             }
             PropertyChanges {
                 target: icon
-- 
GitLab


From 3cdbf9a450d08835d2b471ece9a36789fb7ed805 Mon Sep 17 00:00:00 2001
From: Bharadwaj Raju <bharadwaj.raju777@protonmail.com>
Date: Thu, 14 Jul 2022 04:25:31 +0530
Subject: [PATCH 26/62] fix(effect): don't use Plasma-themed icons in Present
 Windows

BUG: 455368
---
 effect/effects/private/qml/WindowHeapDelegate.qml | 1 +
 1 file changed, 1 insertion(+)

diff --git a/effect/effects/private/qml/WindowHeapDelegate.qml b/effect/effects/private/qml/WindowHeapDelegate.qml
index 1690e7173..b41be7f68 100644
--- a/effect/effects/private/qml/WindowHeapDelegate.qml
+++ b/effect/effects/private/qml/WindowHeapDelegate.qml
@@ -157,6 +157,7 @@ Item {
         width: PlasmaCore.Units.iconSizes.large
         height: width
         source: thumb.client.icon
+        usesPlasmaTheme: false
         anchors.horizontalCenter: thumbSource.horizontalCenter
         anchors.bottom: thumbSource.bottom
         anchors.bottomMargin: -height / 4
-- 
GitLab


From 0a1b79ecdaed301f3cf92f996bbda04ea40285e9 Mon Sep 17 00:00:00 2001
From: Nate Graham <nate@kde.org>
Date: Thu, 14 Jul 2022 19:33:55 -0600
Subject: [PATCH 27/62] fix(effect): expand size of highlight

Currently, the highlight effect is not very visible because it only
barely peeks out of the window thumbnail. We can make it bigger by
making it peek out a little bit more, and also by including the window
title and icon (when visible) within it.

BUG: 454842
---
 effect/effects/private/qml/WindowHeap.qml         | 2 +-
 effect/effects/private/qml/WindowHeapDelegate.qml | 9 +++++++--
 2 files changed, 8 insertions(+), 3 deletions(-)

diff --git a/effect/effects/private/qml/WindowHeap.qml b/effect/effects/private/qml/WindowHeap.qml
index ca47ebb8d..b5eeff762 100644
--- a/effect/effects/private/qml/WindowHeap.qml
+++ b/effect/effects/private/qml/WindowHeap.qml
@@ -104,7 +104,7 @@ FocusScope {
         y: heap.padding
         width: parent.width - 2 * heap.padding
         height: parent.height - 2 * heap.padding
-        spacing: PlasmaCore.Units.largeSpacing
+        spacing: PlasmaCore.Units.smallSpacing * 5
 
         Repeater {
             id: windowsRepeater
diff --git a/effect/effects/private/qml/WindowHeapDelegate.qml b/effect/effects/private/qml/WindowHeapDelegate.qml
index b41be7f68..08bb494ae 100644
--- a/effect/effects/private/qml/WindowHeapDelegate.qml
+++ b/effect/effects/private/qml/WindowHeapDelegate.qml
@@ -283,8 +283,13 @@ Item {
 
 
     PlasmaCore.FrameSvgItem {
-        anchors.fill: parent
-        anchors.margins: -PlasmaCore.Units.smallSpacing
+        anchors {
+            fill: parent
+            topMargin: -PlasmaCore.Units.smallSpacing * 2
+            leftMargin: -PlasmaCore.Units.smallSpacing * 2
+            rightMargin: -PlasmaCore.Units.smallSpacing * 2
+            bottomMargin: -(Math.round(icon.height / 4) + caption.height + (PlasmaCore.Units.smallSpacing * 2))
+        }
         imagePath: "widgets/viewitem"
         prefix: "hover"
         z: -1
-- 
GitLab


From 6917141e7ba341f8216a39959042b8d00e8adee1 Mon Sep 17 00:00:00 2001
From: David Edmundson <kde@davidedmundson.co.uk>
Date: Thu, 14 Jul 2022 16:35:29 +0100
Subject: [PATCH 28/62] refactor(effect): accept keys in windowheap
 conditionally

In WindowHeap we currently always accept the keyboard event regardless
of whether the event was handled.

This will allow the event to propagate to other handlers
---
 effect/effects/private/qml/WindowHeap.qml | 24 ++++++++++++++---------
 1 file changed, 15 insertions(+), 9 deletions(-)

diff --git a/effect/effects/private/qml/WindowHeap.qml b/effect/effects/private/qml/WindowHeap.qml
index b5eeff762..b110de265 100644
--- a/effect/effects/private/qml/WindowHeap.qml
+++ b/effect/effects/private/qml/WindowHeap.qml
@@ -244,7 +244,9 @@ FocusScope {
         const nextIndex = findNextItem(heap.selectedIndex, direction);
         if (nextIndex != -1) {
             heap.selectedIndex = nextIndex;
+            return true;
         }
+        return false;
     }
 
     function selectLastItem(direction) {
@@ -259,39 +261,43 @@ FocusScope {
         }
         if (last != -1) {
             heap.selectedIndex = last;
+            return true;
         }
+        return false;
     }
 
     onActiveFocusChanged: resetSelected();
 
     Keys.onPressed: {
+        let handled = false;
         switch (event.key) {
         case Qt.Key_Up:
-            selectNextItem(WindowHeap.Direction.Up);
+            handled = selectNextItem(WindowHeap.Direction.Up);
             break;
         case Qt.Key_Down:
-            selectNextItem(WindowHeap.Direction.Down);
+            handled = selectNextItem(WindowHeap.Direction.Down);
             break;
         case Qt.Key_Left:
-            selectNextItem(WindowHeap.Direction.Left);
+            handled = selectNextItem(WindowHeap.Direction.Left);
             break;
         case Qt.Key_Right:
-            selectNextItem(WindowHeap.Direction.Right);
+            handled = selectNextItem(WindowHeap.Direction.Right);
             break;
         case Qt.Key_Home:
-            selectLastItem(WindowHeap.Direction.Left);
+            handled = selectLastItem(WindowHeap.Direction.Left);
             break;
         case Qt.Key_End:
-            selectLastItem(WindowHeap.Direction.Right);
+            handled = selectLastItem(WindowHeap.Direction.Right);
             break;
         case Qt.Key_PageUp:
-            selectLastItem(WindowHeap.Direction.Up);
+            handled = selectLastItem(WindowHeap.Direction.Up);
             break;
         case Qt.Key_PageDown:
-            selectLastItem(WindowHeap.Direction.Down);
+            handled = selectLastItem(WindowHeap.Direction.Down);
             break;
         case Qt.Key_Return:
         case Qt.Key_Space:
+            handled = true;
             let selectedItem = null;
             if (heap.selectedIndex != -1) {
                 selectedItem = windowsRepeater.itemAt(heap.selectedIndex);
@@ -316,6 +322,6 @@ FocusScope {
         default:
             return;
         }
-        event.accepted = true;
+        event.accepted = handled;
     }
 }
-- 
GitLab


From 8270d7554818240f901305b2bd86c2a170ed04b2 Mon Sep 17 00:00:00 2001
From: David Edmundson <kde@davidedmundson.co.uk>
Date: Thu, 14 Jul 2022 16:35:29 +0100
Subject: [PATCH 29/62] refactor(effect): accept keys in windowheap
 conditionally

In WindowHeap we currently always accept the keyboard event regardless
of whether the event was handled.

This will allow the event to propagate to other handlers
---
 effect/effects/private/qml/WindowHeap.qml | 1 +
 1 file changed, 1 insertion(+)

diff --git a/effect/effects/private/qml/WindowHeap.qml b/effect/effects/private/qml/WindowHeap.qml
index b110de265..977767acf 100644
--- a/effect/effects/private/qml/WindowHeap.qml
+++ b/effect/effects/private/qml/WindowHeap.qml
@@ -315,6 +315,7 @@ FocusScope {
                 }
             }
             if (selectedItem) {
+                handled = true;
                 KWinComponents.Workspace.activeClient = selectedItem.client;
                 heap.activated();
             }
-- 
GitLab


From ee4be10e8f8d75b718a3fd210a53d335cc28e3d4 Mon Sep 17 00:00:00 2001
From: ivan tkachenko <me@ratijas.tk>
Date: Tue, 26 Jul 2022 23:50:30 +0300
Subject: [PATCH 30/62] refactor(effect): private, drop opacity binding inside
 WindowHeapDelegate

This targetOpacity is nowhere to be found. This is a relic of past
development. Currently code that needs to alter opacity based on drag
state does so externally by setting opacity on a delegate as a whole.
---
 effect/effects/private/qml/WindowHeapDelegate.qml | 1 -
 1 file changed, 1 deletion(-)

diff --git a/effect/effects/private/qml/WindowHeapDelegate.qml b/effect/effects/private/qml/WindowHeapDelegate.qml
index 08bb494ae..7ad826444 100644
--- a/effect/effects/private/qml/WindowHeapDelegate.qml
+++ b/effect/effects/private/qml/WindowHeapDelegate.qml
@@ -122,7 +122,6 @@ Item {
                             thumb.activeDragHandler.centroid.position.y
                     width: cell.width * thumb.targetScale
                     height: cell.height * thumb.targetScale
-                    opacity: thumb.activeDragHandler.targetOpacity
                 }
             }
         ]
-- 
GitLab


From a65d15ef031f34e20586bbe55a0fe4d04cdef1c8 Mon Sep 17 00:00:00 2001
From: ivan tkachenko <me@ratijas.tk>
Date: Wed, 27 Jul 2022 03:50:50 +0300
Subject: [PATCH 31/62] fix(effect): private, raise currently dragged window
 higher than anything

BUG: 456936
FIXED-IN: 5.25.4 5.26
---
 effect/effects/private/qml/WindowHeapDelegate.qml | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/effect/effects/private/qml/WindowHeapDelegate.qml b/effect/effects/private/qml/WindowHeapDelegate.qml
index 7ad826444..b0a47f6d6 100644
--- a/effect/effects/private/qml/WindowHeapDelegate.qml
+++ b/effect/effects/private/qml/WindowHeapDelegate.qml
@@ -70,7 +70,8 @@ Item {
     }
 
     visible: opacity > 0
-    z: thumb.activeDragHandler.active ? 100 : client.stackingOrder + (thumb.client.desktop == KWinComponents.Workspace.currentDesktop ? 100 : 0)
+    z: thumb.activeDragHandler.active ? 1000
+        : client.stackingOrder + (thumb.client.desktop == KWinComponents.Workspace.currentDesktop ? 100 : 0)
 
     component TweenBehavior : Behavior {
         enabled: thumb.state !== "partial" && thumb.windowHeap.animationEnabled && !thumb.activeDragHandler.active
-- 
GitLab


From 3aff6a82e9611d4d300efcfe0099042998674c2e Mon Sep 17 00:00:00 2001
From: ivan tkachenko <me@ratijas.tk>
Date: Wed, 27 Jul 2022 03:55:10 +0300
Subject: [PATCH 32/62] fix(effect): private, don't show another window's
 hover/highlight while dragging

This produced really weird impression that if you will drop a window it
will be actually dropped on another window??
---
 effect/effects/private/qml/WindowHeapDelegate.qml | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/effect/effects/private/qml/WindowHeapDelegate.qml b/effect/effects/private/qml/WindowHeapDelegate.qml
index b0a47f6d6..f9ee842bf 100644
--- a/effect/effects/private/qml/WindowHeapDelegate.qml
+++ b/effect/effects/private/qml/WindowHeapDelegate.qml
@@ -293,7 +293,7 @@ Item {
         imagePath: "widgets/viewitem"
         prefix: "hover"
         z: -1
-        visible: !thumb.activeDragHandler.active && (hoverHandler.hovered || selected)
+        visible: !thumb.windowHeap.dragActive && (hoverHandler.hovered || selected)
     }
 
     HoverHandler {
-- 
GitLab


From 0075c06b2908672664752a7539279ccc82613a72 Mon Sep 17 00:00:00 2001
From: ivan tkachenko <me@ratijas.tk>
Date: Tue, 26 Jul 2022 23:40:22 +0300
Subject: [PATCH 33/62] refactor(effect): private, port ExpoLayout to using
 anchors

---
 effect/effects/private/qml/WindowHeap.qml | 7 +++----
 1 file changed, 3 insertions(+), 4 deletions(-)

diff --git a/effect/effects/private/qml/WindowHeap.qml b/effect/effects/private/qml/WindowHeap.qml
index 977767acf..6ff578269 100644
--- a/effect/effects/private/qml/WindowHeap.qml
+++ b/effect/effects/private/qml/WindowHeap.qml
@@ -100,10 +100,9 @@ FocusScope {
 
     ExpoLayout {
         id: expoLayout
-        x: heap.padding
-        y: heap.padding
-        width: parent.width - 2 * heap.padding
-        height: parent.height - 2 * heap.padding
+
+        anchors.fill: parent
+        anchors.margins: heap.padding
         spacing: PlasmaCore.Units.smallSpacing * 5
 
         Repeater {
-- 
GitLab


From ce148fb3d1914ccf9a8ca73d9c70c1db04948549 Mon Sep 17 00:00:00 2001
From: ivan tkachenko <me@ratijas.tk>
Date: Wed, 27 Jul 2022 23:05:06 +0300
Subject: [PATCH 34/62] refactor(effect): private, drop unused properties

---
 effect/effects/private/qml/WindowHeapDelegate.qml | 2 --
 1 file changed, 2 deletions(-)

diff --git a/effect/effects/private/qml/WindowHeapDelegate.qml b/effect/effects/private/qml/WindowHeapDelegate.qml
index f9ee842bf..9b5282a71 100644
--- a/effect/effects/private/qml/WindowHeapDelegate.qml
+++ b/effect/effects/private/qml/WindowHeapDelegate.qml
@@ -90,8 +90,6 @@ Item {
         id: thumbSource
         wId: thumb.client.internalId
         state: thumb.activeDragHandler.active ? "drag" : "normal"
-        readonly property QtObject screen: targetScreen
-        readonly property QtObject client: thumb.client
 
         Drag.active: thumb.activeDragHandler.active
         Drag.source: thumb.client
-- 
GitLab


From b5551ff163c7d990ebb71bc4291135cf31a9ef97 Mon Sep 17 00:00:00 2001
From: ivan tkachenko <me@ratijas.tk>
Date: Tue, 26 Jul 2022 21:12:15 +0300
Subject: [PATCH 35/62] fix(effect): private, set required property for default
 WindowHeapDelegate

Otherwise this WindowHeap type is not usable without custom delegate.

    /usr/lib/qml/org/kde/kwin/private/effects/WindowHeap.qml:111:23:
        QML Component: Cannot create delegate
    /usr/lib/qml/org/kde/kwin/private/effects/WindowHeapDelegate.qml:21:5:
        Required property windowHeap was not initialized
---
 effect/effects/private/qml/WindowHeap.qml | 4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

diff --git a/effect/effects/private/qml/WindowHeap.qml b/effect/effects/private/qml/WindowHeap.qml
index 6ff578269..33d52786a 100644
--- a/effect/effects/private/qml/WindowHeap.qml
+++ b/effect/effects/private/qml/WindowHeap.qml
@@ -107,7 +107,9 @@ FocusScope {
 
         Repeater {
             id: windowsRepeater
-            delegate: WindowHeapDelegate {}
+            delegate: WindowHeapDelegate {
+                windowHeap: heap
+            }
         }
     }
 
-- 
GitLab


From 1ede60e40a521dbb60ae0aebb38616882a47fcf3 Mon Sep 17 00:00:00 2001
From: ivan tkachenko <me@ratijas.tk>
Date: Tue, 26 Jul 2022 20:47:59 +0300
Subject: [PATCH 36/62] refactor(effect): private, make WindowHeapDelegate
 dragHandler less confusing

There were too much `dragHandler` identifiers per square meter of code.
---
 effect/effects/private/qml/WindowHeapDelegate.qml | 3 +--
 1 file changed, 1 insertion(+), 2 deletions(-)

diff --git a/effect/effects/private/qml/WindowHeapDelegate.qml b/effect/effects/private/qml/WindowHeapDelegate.qml
index 9b5282a71..e5d1cd1fb 100644
--- a/effect/effects/private/qml/WindowHeapDelegate.qml
+++ b/effect/effects/private/qml/WindowHeapDelegate.qml
@@ -318,14 +318,13 @@ Item {
     }
 
     component DragManager : DragHandler {
-        id: dragHandler
         target: null
         grabPermissions: PointerHandler.CanTakeOverFromAnything
 
         onActiveChanged: {
             thumb.windowHeap.dragActive = active;
             if (active) {
-                thumb.activeDragHandler = dragHandler;
+                thumb.activeDragHandler = this;
             } else {
                 thumbSource.Drag.drop();
                 var globalPos = targetScreen.mapToGlobal(centroid.scenePosition);
-- 
GitLab


From df21a5854e7f3019566ca7cd1f42d3a7bcf84b4f Mon Sep 17 00:00:00 2001
From: ivan tkachenko <me@ratijas.tk>
Date: Thu, 28 Jul 2022 01:21:26 +0300
Subject: [PATCH 37/62] refactor(effect): private, drop unused property
 dragHandler

---
 effect/effects/private/qml/WindowHeapDelegate.qml | 1 -
 1 file changed, 1 deletion(-)

diff --git a/effect/effects/private/qml/WindowHeapDelegate.qml b/effect/effects/private/qml/WindowHeapDelegate.qml
index e5d1cd1fb..699203e54 100644
--- a/effect/effects/private/qml/WindowHeapDelegate.qml
+++ b/effect/effects/private/qml/WindowHeapDelegate.qml
@@ -20,7 +20,6 @@ Item {
     required property int index
     required property Item windowHeap
 
-    readonly property alias dragHandler: thumb.activeDragHandler
     readonly property bool selected: thumb.windowHeap.selectedIndex == index
     //TODO: move?
     readonly property bool hidden: {
-- 
GitLab


From 1312a81ef76a42793579f07657614c837a9c5ac4 Mon Sep 17 00:00:00 2001
From: ivan tkachenko <me@ratijas.tk>
Date: Tue, 26 Jul 2022 23:47:19 +0300
Subject: [PATCH 38/62] refactor(effect): private, port potential misuse of a
 dragHandler to activeDragHandler

There are two drag handlers, and an `activeDragHandler` property to
switch between them. That's what other code is doing in this component.
---
 effect/effects/private/qml/WindowHeapDelegate.qml | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/effect/effects/private/qml/WindowHeapDelegate.qml b/effect/effects/private/qml/WindowHeapDelegate.qml
index 699203e54..a9596ef83 100644
--- a/effect/effects/private/qml/WindowHeapDelegate.qml
+++ b/effect/effects/private/qml/WindowHeapDelegate.qml
@@ -367,7 +367,7 @@ Item {
             margins: PlasmaCore.Units.smallSpacing
         }
 
-        visible: thumb.closeButtonVisible && (hoverHandler.hovered || Kirigami.Settings.tabletMode || Kirigami.Settings.hasTransientTouchInput) && thumb.client.closeable && !dragHandler.active
+        visible: thumb.closeButtonVisible && (hoverHandler.hovered || Kirigami.Settings.tabletMode || Kirigami.Settings.hasTransientTouchInput) && thumb.client.closeable && !thumb.activeDragHandler.active
         LayoutMirroring.enabled: Qt.application.layoutDirection === Qt.RightToLeft
 
         text: i18ndc("kwin_effects", "@info:tooltip as in: 'close this window'", "Close window")
-- 
GitLab


From d8c9583873c4ad9ac86ab726a0ff92d5d674f92d Mon Sep 17 00:00:00 2001
From: ivan tkachenko <me@ratijas.tk>
Date: Tue, 26 Jul 2022 23:53:00 +0300
Subject: [PATCH 39/62] refactor(effect): private, group Repeater's alias
 properties together

---
 effect/effects/private/qml/WindowHeap.qml | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/effect/effects/private/qml/WindowHeap.qml b/effect/effects/private/qml/WindowHeap.qml
index 33d52786a..9a706427f 100644
--- a/effect/effects/private/qml/WindowHeap.qml
+++ b/effect/effects/private/qml/WindowHeap.qml
@@ -24,6 +24,8 @@ FocusScope {
 
     property alias model: windowsRepeater.model
     property alias delegate: windowsRepeater.delegate
+    readonly property alias count: windowsRepeater.count
+
     property alias layout: expoLayout
     property int selectedIndex: -1
     property int animationDuration: PlasmaCore.Units.longDuration
@@ -32,7 +34,6 @@ FocusScope {
     property real padding: 0
     property var showOnly: []
     property string activeClass
-    readonly property alias count: windowsRepeater.count
 
     required property bool organized
     readonly property bool effectiveOrganized: expoLayout.ready && organized
-- 
GitLab


From b81e6faf162689c722fab834eab2d4fd138415c5 Mon Sep 17 00:00:00 2001
From: Vlad Zahorodnii <vlad.zahorodnii@kde.org>
Date: Thu, 28 Jul 2022 12:34:33 +0300
Subject: [PATCH 40/62] refactor(effect): make clientArea() return a QRectF

Make EffectsHandler::clientArea() return same type as
Workspace::clientArea().
---
 effect/effects/private/expoarea.cpp | 10 +++++-----
 effect/effects/private/expoarea.h   | 18 +++++++++---------
 2 files changed, 14 insertions(+), 14 deletions(-)

diff --git a/effect/effects/private/expoarea.cpp b/effect/effects/private/expoarea.cpp
index 90d0cab02..5c81ce122 100644
--- a/effect/effects/private/expoarea.cpp
+++ b/effect/effects/private/expoarea.cpp
@@ -14,22 +14,22 @@ ExpoArea::ExpoArea(QObject* parent)
 {
 }
 
-int ExpoArea::x() const
+qreal ExpoArea::x() const
 {
     return m_rect.x();
 }
 
-int ExpoArea::y() const
+qreal ExpoArea::y() const
 {
     return m_rect.y();
 }
 
-int ExpoArea::width() const
+qreal ExpoArea::width() const
 {
     return m_rect.width();
 }
 
-int ExpoArea::height() const
+qreal ExpoArea::height() const
 {
     return m_rect.height();
 }
@@ -59,7 +59,7 @@ void ExpoArea::update()
     if (!m_screen) {
         return;
     }
-    const QRect oldRect = m_rect;
+    const QRectF oldRect = m_rect;
 
     m_rect = effects->clientArea(MaximizeArea, m_screen, effects->currentDesktop());
 
diff --git a/effect/effects/private/expoarea.h b/effect/effects/private/expoarea.h
index 02b613e68..e5cb62aad 100644
--- a/effect/effects/private/expoarea.h
+++ b/effect/effects/private/expoarea.h
@@ -15,10 +15,10 @@ class ExpoArea : public QObject
 {
     Q_OBJECT
     Q_PROPERTY(KWin::EffectScreen* screen READ screen WRITE setScreen NOTIFY screenChanged)
-    Q_PROPERTY(int x READ x NOTIFY xChanged)
-    Q_PROPERTY(int y READ y NOTIFY yChanged)
-    Q_PROPERTY(int width READ width NOTIFY widthChanged)
-    Q_PROPERTY(int height READ height NOTIFY heightChanged)
+    Q_PROPERTY(qreal x READ x NOTIFY xChanged)
+    Q_PROPERTY(qreal y READ y NOTIFY yChanged)
+    Q_PROPERTY(qreal width READ width NOTIFY widthChanged)
+    Q_PROPERTY(qreal height READ height NOTIFY heightChanged)
 
 public:
     explicit ExpoArea(QObject* parent = nullptr);
@@ -26,10 +26,10 @@ public:
     EffectScreen* screen() const;
     void setScreen(EffectScreen* screen);
 
-    int x() const;
-    int y() const;
-    int width() const;
-    int height() const;
+    qreal x() const;
+    qreal y() const;
+    qreal width() const;
+    qreal height() const;
 
 Q_SIGNALS:
     void screenChanged();
@@ -41,7 +41,7 @@ Q_SIGNALS:
 private:
     void update();
 
-    QRect m_rect;
+    QRectF m_rect;
     EffectScreen* m_screen = nullptr;
 };
 
-- 
GitLab


From 1850bb3b57eb0f57e9403caee9f5862fb760001b Mon Sep 17 00:00:00 2001
From: ivan tkachenko <me@ratijas.tk>
Date: Thu, 28 Jul 2022 01:02:16 +0300
Subject: [PATCH 41/62] fix(effect): animation of windows scaling back from a
 desktop bar

Due to nondeterministic nature of signal propagation in QML, changing
both targetScale and state depending on dragHandler's activity could
result in targetScale wrongly updating before the state change(and thus
applied property changes and subsequent animated transition).

This fixes a bug when a window dragged to the top (but not onto another
desktop) would animate its position back to its original position on a
heap, but the scale would remain constant until the end of animation
and only then rapidly jump back to a normally scaled state.
---
 effect/effects/private/qml/WindowHeapDelegate.qml | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/effect/effects/private/qml/WindowHeapDelegate.qml b/effect/effects/private/qml/WindowHeapDelegate.qml
index a9596ef83..0e118765c 100644
--- a/effect/effects/private/qml/WindowHeapDelegate.qml
+++ b/effect/effects/private/qml/WindowHeapDelegate.qml
@@ -106,8 +106,8 @@ Item {
                     target: thumbSource
                     x: 0
                     y: 0
-                    width: thumb.width * thumb.targetScale
-                    height: thumb.height * thumb.targetScale
+                    width: thumb.width
+                    height: thumb.height
                 }
             },
             State {
-- 
GitLab


From d267a1fa7cb951ffebdb9d50531dead620134f1e Mon Sep 17 00:00:00 2001
From: ivan tkachenko <me@ratijas.tk>
Date: Thu, 28 Jul 2022 01:12:15 +0300
Subject: [PATCH 42/62] refactor(effect): private, actually fade out minimized
 windows on exit

This is most likely just an oversight/omission from the times when the
component was actively developed. There are five states total, including
one for realtime interactions; four others need to be transitioned to.
---
 effect/effects/private/qml/WindowHeapDelegate.qml | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/effect/effects/private/qml/WindowHeapDelegate.qml b/effect/effects/private/qml/WindowHeapDelegate.qml
index 0e118765c..31efcaeac 100644
--- a/effect/effects/private/qml/WindowHeapDelegate.qml
+++ b/effect/effects/private/qml/WindowHeapDelegate.qml
@@ -269,7 +269,7 @@ Item {
     ]
 
     transitions: Transition {
-        to: "initial, active, active-hidden"
+        to: "initial, initial-minimized, active, active-hidden"
         enabled: thumb.windowHeap.animationEnabled
         NumberAnimation {
             duration: thumb.windowHeap.animationDuration
-- 
GitLab


From aa5c23bdf6057a93907645c705f039b2bec56121 Mon Sep 17 00:00:00 2001
From: Marco Martin <notmart@gmail.com>
Date: Tue, 2 Aug 2022 15:59:26 +0000
Subject: [PATCH 43/62] fix(effect): when an arrow key is not accepted look for
 adjacent views

When no qml items manage the arrow key event, the root item will manage it looking to
give focus to a view in the given direction derived from the arrow key

BUG:455783
---
 effect/effects/private/qml/WindowHeapDelegate.qml | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/effect/effects/private/qml/WindowHeapDelegate.qml b/effect/effects/private/qml/WindowHeapDelegate.qml
index 31efcaeac..cbcb97088 100644
--- a/effect/effects/private/qml/WindowHeapDelegate.qml
+++ b/effect/effects/private/qml/WindowHeapDelegate.qml
@@ -290,7 +290,7 @@ Item {
         imagePath: "widgets/viewitem"
         prefix: "hover"
         z: -1
-        visible: !thumb.windowHeap.dragActive && (hoverHandler.hovered || selected)
+        visible: !thumb.windowHeap.dragActive && (hoverHandler.hovered || selected) && Window.window.activeFocusItem
     }
 
     HoverHandler {
-- 
GitLab


From eb428b86b3d83433350e5be96f5d0e843f023cb8 Mon Sep 17 00:00:00 2001
From: ivan tkachenko <me@ratijas.tk>
Date: Wed, 3 Aug 2022 23:52:33 +0300
Subject: [PATCH 44/62] fix(effect): private, prevent fading windows from
 moving downward in WindowView effect

Inheriting "active" state was meaningless, since "active" state binds
position to a ExpoCell which itself is in a disabled state.

FIXED-IN: 5.25.5 5.26
---
 effect/effects/private/qml/WindowHeapDelegate.qml | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/effect/effects/private/qml/WindowHeapDelegate.qml b/effect/effects/private/qml/WindowHeapDelegate.qml
index cbcb97088..35d0d5894 100644
--- a/effect/effects/private/qml/WindowHeapDelegate.qml
+++ b/effect/effects/private/qml/WindowHeapDelegate.qml
@@ -260,7 +260,7 @@ Item {
         },
         State {
             name: "active-hidden"
-            extend: "active"
+            extend: "initial"
             PropertyChanges {
                 target: thumb
                 opacity: 0
-- 
GitLab


From de36d04a598e6f0fadd7c46f980f2a3956bc3871 Mon Sep 17 00:00:00 2001
From: ivan tkachenko <me@ratijas.tk>
Date: Tue, 2 Aug 2022 17:38:29 +0300
Subject: [PATCH 45/62] fix(effect): private, expoLayout reflowing in Desktop
 Grid while dragging

This fixes makes ExpoLayout independent of its position on a screen,
which in turn stops it from randomly reflowing while dragging a virtual
desktop across desktop grid. It also removes an unwanted animation at
the end of activation of desktop grid: desktops move in place and then
windows proceed to adjust themselves resulting in a double animation.

FIXED-IN: 5.25.5 5.26
---
 effect/effects/private/qml/WindowHeapDelegate.qml | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/effect/effects/private/qml/WindowHeapDelegate.qml b/effect/effects/private/qml/WindowHeapDelegate.qml
index 35d0d5894..6d8552bd6 100644
--- a/effect/effects/private/qml/WindowHeapDelegate.qml
+++ b/effect/effects/private/qml/WindowHeapDelegate.qml
@@ -178,8 +178,8 @@ Item {
         id: cell
         layout: windowHeap.layout
         enabled: !thumb.hidden
-        naturalX: thumb.client.x - targetScreen.geometry.x - windowHeap.layout.Kirigami.ScenePosition.x
-        naturalY: thumb.client.y - targetScreen.geometry.y - windowHeap.layout.Kirigami.ScenePosition.y
+        naturalX: thumb.client.x
+        naturalY: thumb.client.y
         naturalWidth: thumb.client.width
         naturalHeight: thumb.client.height
         persistentKey: thumb.client.internalId
-- 
GitLab


From f303ebabc3535d820b9516e32c0d686090fe88c4 Mon Sep 17 00:00:00 2001
From: ivan tkachenko <me@ratijas.tk>
Date: Thu, 4 Aug 2022 19:39:11 +0300
Subject: [PATCH 46/62] refactor(effect): private, clean up QML/JS code and
 bump imports

---
 effect/effects/private/qml/WindowHeap.qml     | 41 +++++++++---------
 .../private/qml/WindowHeapDelegate.qml        | 42 +++++++++----------
 2 files changed, 42 insertions(+), 41 deletions(-)

diff --git a/effect/effects/private/qml/WindowHeap.qml b/effect/effects/private/qml/WindowHeap.qml
index 9a706427f..f9a8fc422 100644
--- a/effect/effects/private/qml/WindowHeap.qml
+++ b/effect/effects/private/qml/WindowHeap.qml
@@ -4,9 +4,9 @@
     SPDX-License-Identifier: GPL-2.0-or-later
 */
 
-import QtQuick 2.12
-import QtQuick.Window 2.12
-import org.kde.kirigami 2.12 as Kirigami
+import QtQuick 2.15
+import QtQuick.Window 2.15
+import org.kde.kirigami 2.20 as Kirigami
 import org.kde.kwin 3.0 as KWinComponents
 import org.kde.kwin.private.effects 1.0
 import org.kde.plasma.components 3.0 as PC3
@@ -32,6 +32,7 @@ FocusScope {
     property bool animationEnabled: false
     property bool absolutePositioning: true
     property real padding: 0
+    // Either a string "activeClass" or a list internalIds of clients
     property var showOnly: []
     property string activeClass
 
@@ -125,7 +126,7 @@ FocusScope {
     }
 
     function findNextItem(selectedIndex, direction) {
-        if (selectedIndex == -1) {
+        if (selectedIndex === -1) {
             return findFirstItem();
         }
 
@@ -147,7 +148,7 @@ FocusScope {
                 }
 
                 if (candidateItem.x + candidateItem.width < selectedItem.x + selectedItem.width) {
-                    if (nextIndex == -1) {
+                    if (nextIndex === -1) {
                         nextIndex = candidateIndex;
                     } else {
                         const nextItem = windowsRepeater.itemAt(nextIndex);
@@ -172,11 +173,11 @@ FocusScope {
                 }
 
                 if (selectedItem.x < candidateItem.x) {
-                    if (nextIndex == -1) {
+                    if (nextIndex === -1) {
                         nextIndex = candidateIndex;
                     } else {
                         const nextItem = windowsRepeater.itemAt(nextIndex);
-                        if (nextIndex == -1 || candidateItem.x < nextItem.x) {
+                        if (nextIndex === -1 || candidateItem.x < nextItem.x) {
                             nextIndex = candidateIndex;
                         }
                     }
@@ -197,7 +198,7 @@ FocusScope {
                 }
 
                 if (candidateItem.y + candidateItem.height < selectedItem.y + selectedItem.height) {
-                    if (nextIndex == -1) {
+                    if (nextIndex === -1) {
                         nextIndex = candidateIndex;
                     } else {
                         const nextItem = windowsRepeater.itemAt(nextIndex);
@@ -222,7 +223,7 @@ FocusScope {
                 }
 
                 if (selectedItem.y < candidateItem.y) {
-                    if (nextIndex == -1) {
+                    if (nextIndex === -1) {
                         nextIndex = candidateIndex;
                     } else {
                         const nextItem = windowsRepeater.itemAt(nextIndex);
@@ -239,30 +240,30 @@ FocusScope {
     }
 
     function resetSelected() {
-        heap.selectedIndex = -1;
+        selectedIndex = -1;
     }
 
     function selectNextItem(direction) {
-        const nextIndex = findNextItem(heap.selectedIndex, direction);
-        if (nextIndex != -1) {
-            heap.selectedIndex = nextIndex;
+        const nextIndex = findNextItem(selectedIndex, direction);
+        if (nextIndex !== -1) {
+            selectedIndex = nextIndex;
             return true;
         }
         return false;
     }
 
     function selectLastItem(direction) {
-        let last = heap.selectedIndex;
+        let last = selectedIndex;
         while (true) {
             const next = findNextItem(last, direction);
-            if (next == -1) {
+            if (next === -1) {
                 break;
             } else {
                 last = next;
             }
         }
-        if (last != -1) {
-            heap.selectedIndex = last;
+        if (last !== -1) {
+            selectedIndex = last;
             return true;
         }
         return false;
@@ -301,8 +302,8 @@ FocusScope {
         case Qt.Key_Space:
             handled = true;
             let selectedItem = null;
-            if (heap.selectedIndex != -1) {
-                selectedItem = windowsRepeater.itemAt(heap.selectedIndex);
+            if (selectedIndex !== -1) {
+                selectedItem = windowsRepeater.itemAt(selectedIndex);
             } else {
                 // If the window heap has only one visible window, activate it.
                 for (let i = 0; i < windowsRepeater.count; ++i) {
@@ -319,7 +320,7 @@ FocusScope {
             if (selectedItem) {
                 handled = true;
                 KWinComponents.Workspace.activeClient = selectedItem.client;
-                heap.activated();
+                activated();
             }
             break;
         default:
diff --git a/effect/effects/private/qml/WindowHeapDelegate.qml b/effect/effects/private/qml/WindowHeapDelegate.qml
index 6d8552bd6..4f19cc95a 100644
--- a/effect/effects/private/qml/WindowHeapDelegate.qml
+++ b/effect/effects/private/qml/WindowHeapDelegate.qml
@@ -4,15 +4,14 @@
     SPDX-License-Identifier: GPL-2.0-or-later
 */
 
-import QtQuick 2.12
-import QtQuick.Window 2.12
-import org.kde.kirigami 2.12 as Kirigami
+import QtQuick 2.15
+import QtQuick.Window 2.15
+import org.kde.kirigami 2.20 as Kirigami
 import org.kde.kwin 3.0 as KWinComponents
 import org.kde.kwin.private.effects 1.0
 import org.kde.plasma.components 3.0 as PC3
 import org.kde.plasma.core 2.0 as PlasmaCore
 
-
 Item {
     id: thumb
 
@@ -20,13 +19,15 @@ Item {
     required property int index
     required property Item windowHeap
 
-    readonly property bool selected: thumb.windowHeap.selectedIndex == index
+    readonly property bool selected: windowHeap.selectedIndex === index
     //TODO: move?
     readonly property bool hidden: {
-        if (thumb.windowHeap.showOnly === "activeClass") {
-            return thumb.windowHeap.activeClass !== String(thumb.client.resourceName); // thumb.client.resourceName is not an actual String as comes from a QByteArray so === would fail
+        if (windowHeap.showOnly === "activeClass") {
+            // client.resourceName is not an actual String as comes from a QByteArray so === would fail
+            return windowHeap.activeClass !== String(client.resourceName);
         } else {
-            return thumb.windowHeap.showOnly.length && thumb.windowHeap.showOnly.indexOf(client.internalId) == -1;
+            return windowHeap.showOnly.length !== 0
+                && windowHeap.showOnly.indexOf(client.internalId) === -1;
         }
     }
 
@@ -38,15 +39,15 @@ Item {
     //scale up and down the whole thumbnail without affecting layouting
     property real targetScale: 1.0
 
+    property DragManager activeDragHandler: dragHandler
+
     // Swipe down gesture by touch, in some effects will close the window
     readonly property alias downGestureProgress: touchDragHandler.downGestureProgress
     signal downGestureTriggered()
 
-
-
     Component.onCompleted: {
-        if (thumb.client.active) {
-            thumb.windowHeap.activeClass = thumb.client.resourceName;
+        if (client.active) {
+            windowHeap.activeClass = client.resourceName;
         }
     }
     Connections {
@@ -62,15 +63,15 @@ Item {
         if (effect.gestureInProgress) {
             return "partial";
         }
-        if (thumb.windowHeap.effectiveOrganized) {
+        if (windowHeap.effectiveOrganized) {
             return hidden ? "active-hidden" : "active";
         }
         return client.minimized ? "initial-minimized" : "initial";
     }
 
     visible: opacity > 0
-    z: thumb.activeDragHandler.active ? 1000
-        : client.stackingOrder + (thumb.client.desktop == KWinComponents.Workspace.currentDesktop ? 100 : 0)
+    z: activeDragHandler.active ? 1000
+        : client.stackingOrder + (client.desktop === KWinComponents.Workspace.currentDesktop ? 100 : 0)
 
     component TweenBehavior : Behavior {
         enabled: thumb.state !== "partial" && thumb.windowHeap.animationEnabled && !thumb.activeDragHandler.active
@@ -160,7 +161,6 @@ Item {
         anchors.bottomMargin: -height / 4
         visible: !thumb.hidden && !activeDragHandler.active
 
-
         PC3.Label {
             id: caption
             visible: thumb.windowTitleVisible
@@ -213,7 +213,7 @@ Item {
                 y: (thumb.client.y - targetScreen.geometry.y - (thumb.windowHeap.absolutePositioning ?  windowHeap.layout.Kirigami.ScenePosition.y : 0)) * (1 - effect.partialActivationFactor) + cell.y * effect.partialActivationFactor
                 width: thumb.client.width * (1 - effect.partialActivationFactor) + cell.width * effect.partialActivationFactor
                 height: thumb.client.height * (1 - effect.partialActivationFactor) + cell.height * effect.partialActivationFactor
-                opacity: thumb.client.minimized || thumb.client.desktop != KWinComponents.Workspace.currentDesktop ? effect.partialActivationFactor : 1
+                opacity: thumb.client.minimized || thumb.client.desktop !== KWinComponents.Workspace.currentDesktop ? effect.partialActivationFactor : 1
             }
             PropertyChanges {
                 target: icon
@@ -278,7 +278,6 @@ Item {
         }
     }
 
-
     PlasmaCore.FrameSvgItem {
         anchors {
             fill: parent
@@ -295,7 +294,7 @@ Item {
 
     HoverHandler {
         id: hoverHandler
-        onHoveredChanged: if (hovered != selected) {
+        onHoveredChanged: if (hovered !== selected) {
             thumb.windowHeap.resetSelected();
         }
     }
@@ -331,11 +330,12 @@ Item {
             }
         }
     }
-    property DragManager activeDragHandler: dragHandler
+
     DragManager {
         id: dragHandler
         acceptedDevices: PointerDevice.Mouse | PointerDevice.TouchPad | PointerDevice.Stylus
     }
+
     DragManager {
         id: touchDragHandler
         acceptedDevices: PointerDevice.TouchScreen
@@ -384,7 +384,7 @@ Item {
 
     Component.onDestruction: {
         if (selected) {
-            thumb.windowHeap.resetSelected();
+            windowHeap.resetSelected();
         }
     }
 }
-- 
GitLab


From 8972db8f035b78decf3072cd8136aa69a5a8dced Mon Sep 17 00:00:00 2001
From: Blake Sperling <breakingspell@gmail.com>
Date: Tue, 9 Aug 2022 23:54:44 +0000
Subject: [PATCH 47/62] fix(effect): improve animation durations and easing
 curves in Windowheap-based effects

This commit doubles the animation durations for WindowHeap-based effects
(Overview, Present Windows, and Desktop Grid) and uses the OutCubic easing
curve for their opening and closing animations. This makes them feel smoother
and more comfortable.

BUG: 455521
BUG: 448538
FIXED-IN: 5.26
---
 effect/effects/private/qml/WindowHeapDelegate.qml | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/effect/effects/private/qml/WindowHeapDelegate.qml b/effect/effects/private/qml/WindowHeapDelegate.qml
index 4f19cc95a..0d9548f96 100644
--- a/effect/effects/private/qml/WindowHeapDelegate.qml
+++ b/effect/effects/private/qml/WindowHeapDelegate.qml
@@ -274,7 +274,7 @@ Item {
         NumberAnimation {
             duration: thumb.windowHeap.animationDuration
             properties: "x, y, width, height, opacity"
-            easing.type: Easing.InOutCubic
+            easing.type: Easing.OutCubic
         }
     }
 
-- 
GitLab


From 9f21b5cf4276e9ccbce7d6e935740e425babed79 Mon Sep 17 00:00:00 2001
From: ivan tkachenko <me@ratijas.tk>
Date: Tue, 2 Aug 2022 11:44:01 +0300
Subject: [PATCH 48/62] fix(effect): private, guard against function execution
 when component is being destroyed

Accept drop events correctly and use returned value (action) of
Drag.drop() to guard against the situation where the delegate is about
to be destroyed.

This does not fix any bugs per se, except suppressing a warning about
undefined targetScreen being printed to a console on every window dropped
onto a different virtual desktop.
---
 effect/effects/private/qml/WindowHeapDelegate.qml | 9 ++++++++-
 1 file changed, 8 insertions(+), 1 deletion(-)

diff --git a/effect/effects/private/qml/WindowHeapDelegate.qml b/effect/effects/private/qml/WindowHeapDelegate.qml
index 0d9548f96..82d2008c6 100644
--- a/effect/effects/private/qml/WindowHeapDelegate.qml
+++ b/effect/effects/private/qml/WindowHeapDelegate.qml
@@ -92,6 +92,8 @@ Item {
         state: thumb.activeDragHandler.active ? "drag" : "normal"
 
         Drag.active: thumb.activeDragHandler.active
+        Drag.proposedAction: Qt.MoveAction
+        Drag.supportedActions: Qt.MoveAction
         Drag.source: thumb.client
         Drag.hotSpot: Qt.point(
             thumb.activeDragHandler.centroid.pressPosition.x * thumb.targetScale,
@@ -324,7 +326,12 @@ Item {
             if (active) {
                 thumb.activeDragHandler = this;
             } else {
-                thumbSource.Drag.drop();
+                var action = thumbSource.Drag.drop();
+                if (action === Qt.MoveAction) {
+                    // this whole component is in the process of being destroyed due to drop onto
+                    // another virtual desktop (not another screen).
+                    return;
+                }
                 var globalPos = targetScreen.mapToGlobal(centroid.scenePosition);
                 effect.checkItemDroppedOutOfScreen(globalPos, thumbSource);
             }
-- 
GitLab


From 08d28000aa92a23bde88a8479b7173c9d0752fdd Mon Sep 17 00:00:00 2001
From: ivan tkachenko <me@ratijas.tk>
Date: Thu, 4 Aug 2022 15:08:22 +0300
Subject: [PATCH 49/62] fix(effect): stacking order of windows relative to
 panels

Make windows thumbnails use their native stacking order as a 'z' value
for current desktop while lowering windows from other desktops.

By lowering others instead of raising current ones we get to use
stacking order compatible with desktop & dock/panel window types.

For now they are drawn separately, so this change doesn't do much on its
own, but it would become useful during refactoring when putting all
windows (regular and panel types) in a single parent with shared z stack.
---
 effect/effects/private/qml/WindowHeapDelegate.qml | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/effect/effects/private/qml/WindowHeapDelegate.qml b/effect/effects/private/qml/WindowHeapDelegate.qml
index 82d2008c6..11b56e5f6 100644
--- a/effect/effects/private/qml/WindowHeapDelegate.qml
+++ b/effect/effects/private/qml/WindowHeapDelegate.qml
@@ -71,7 +71,7 @@ Item {
 
     visible: opacity > 0
     z: activeDragHandler.active ? 1000
-        : client.stackingOrder + (client.desktop === KWinComponents.Workspace.currentDesktop ? 100 : 0)
+        : client.stackingOrder * (client.desktop === KWinComponents.Workspace.currentDesktop ? 1 : 0.001)
 
     component TweenBehavior : Behavior {
         enabled: thumb.state !== "partial" && thumb.windowHeap.animationEnabled && !thumb.activeDragHandler.active
-- 
GitLab


From 3d290fee3215eedfeafd13a657feea3da521457b Mon Sep 17 00:00:00 2001
From: ivan tkachenko <me@ratijas.tk>
Date: Thu, 4 Aug 2022 15:21:45 +0300
Subject: [PATCH 50/62] fix(effect): initial hidden state: also initially hide
 windows from other desktops

This fixes the case in Show All Windows (F10) and Show Windows of
Current App (F7): non-minimized windows from other desktops suddenly
pop-up at the start of these effects instead of remaining hidden.

Note: don't test this with full-screen/maximized windows open on current
desktop otherwise you probably won't see any difference.
---
 effect/effects/private/qml/WindowHeapDelegate.qml | 11 ++++++-----
 1 file changed, 6 insertions(+), 5 deletions(-)

diff --git a/effect/effects/private/qml/WindowHeapDelegate.qml b/effect/effects/private/qml/WindowHeapDelegate.qml
index 11b56e5f6..3de83f828 100644
--- a/effect/effects/private/qml/WindowHeapDelegate.qml
+++ b/effect/effects/private/qml/WindowHeapDelegate.qml
@@ -20,7 +20,8 @@ Item {
     required property Item windowHeap
 
     readonly property bool selected: windowHeap.selectedIndex === index
-    //TODO: move?
+
+    readonly property bool initialHidden: client.minimized || client.desktop !== KWinComponents.Workspace.currentDesktop
     readonly property bool hidden: {
         if (windowHeap.showOnly === "activeClass") {
             // client.resourceName is not an actual String as comes from a QByteArray so === would fail
@@ -66,7 +67,7 @@ Item {
         if (windowHeap.effectiveOrganized) {
             return hidden ? "active-hidden" : "active";
         }
-        return client.minimized ? "initial-minimized" : "initial";
+        return initialHidden ? "initial-hidden" : "initial";
     }
 
     visible: opacity > 0
@@ -215,7 +216,7 @@ Item {
                 y: (thumb.client.y - targetScreen.geometry.y - (thumb.windowHeap.absolutePositioning ?  windowHeap.layout.Kirigami.ScenePosition.y : 0)) * (1 - effect.partialActivationFactor) + cell.y * effect.partialActivationFactor
                 width: thumb.client.width * (1 - effect.partialActivationFactor) + cell.width * effect.partialActivationFactor
                 height: thumb.client.height * (1 - effect.partialActivationFactor) + cell.height * effect.partialActivationFactor
-                opacity: thumb.client.minimized || thumb.client.desktop !== KWinComponents.Workspace.currentDesktop ? effect.partialActivationFactor : 1
+                opacity: thumb.initialHidden ? effect.partialActivationFactor : 1
             }
             PropertyChanges {
                 target: icon
@@ -227,7 +228,7 @@ Item {
             }
         },
         State {
-            name: "initial-minimized"
+            name: "initial-hidden"
             extend: "initial"
             PropertyChanges {
                 target: thumb
@@ -271,7 +272,7 @@ Item {
     ]
 
     transitions: Transition {
-        to: "initial, initial-minimized, active, active-hidden"
+        to: "initial, initial-hidden, active, active-hidden"
         enabled: thumb.windowHeap.animationEnabled
         NumberAnimation {
             duration: thumb.windowHeap.animationDuration
-- 
GitLab


From 399d281d43ca9e15d0566d3bf3f4a44bbb824f2d Mon Sep 17 00:00:00 2001
From: ivan tkachenko <me@ratijas.tk>
Date: Thu, 4 Aug 2022 17:23:24 +0300
Subject: [PATCH 51/62] refactor(effect): private, rename property 'hidden' to
 'activeHidden'

This is done to better reflect its relation to the
complementary 'initialHidden' property.
---
 effect/effects/private/qml/WindowHeapDelegate.qml | 10 +++++-----
 1 file changed, 5 insertions(+), 5 deletions(-)

diff --git a/effect/effects/private/qml/WindowHeapDelegate.qml b/effect/effects/private/qml/WindowHeapDelegate.qml
index 3de83f828..7bea0106e 100644
--- a/effect/effects/private/qml/WindowHeapDelegate.qml
+++ b/effect/effects/private/qml/WindowHeapDelegate.qml
@@ -22,7 +22,7 @@ Item {
     readonly property bool selected: windowHeap.selectedIndex === index
 
     readonly property bool initialHidden: client.minimized || client.desktop !== KWinComponents.Workspace.currentDesktop
-    readonly property bool hidden: {
+    readonly property bool activeHidden: {
         if (windowHeap.showOnly === "activeClass") {
             // client.resourceName is not an actual String as comes from a QByteArray so === would fail
             return windowHeap.activeClass !== String(client.resourceName);
@@ -65,7 +65,7 @@ Item {
             return "partial";
         }
         if (windowHeap.effectiveOrganized) {
-            return hidden ? "active-hidden" : "active";
+            return activeHidden ? "active-hidden" : "active";
         }
         return initialHidden ? "initial-hidden" : "initial";
     }
@@ -150,7 +150,7 @@ Item {
         verticalAlignment: Text.AlignVCenter
         text: i18nd("kwin_effects", "Drag Down To Close")
         opacity: 1 - thumbSource.opacity
-        visible: !thumb.hidden
+        visible: !thumb.activeHidden
     }
 
     PlasmaCore.IconItem {
@@ -162,7 +162,7 @@ Item {
         anchors.horizontalCenter: thumbSource.horizontalCenter
         anchors.bottom: thumbSource.bottom
         anchors.bottomMargin: -height / 4
-        visible: !thumb.hidden && !activeDragHandler.active
+        visible: !thumb.activeHidden && !activeDragHandler.active
 
         PC3.Label {
             id: caption
@@ -180,7 +180,7 @@ Item {
     ExpoCell {
         id: cell
         layout: windowHeap.layout
-        enabled: !thumb.hidden
+        enabled: !thumb.activeHidden
         naturalX: thumb.client.x
         naturalY: thumb.client.y
         naturalWidth: thumb.client.width
-- 
GitLab


From 8dabf1bfcdf5f78b1de9f535f524e186c1de1b17 Mon Sep 17 00:00:00 2001
From: ivan tkachenko <me@ratijas.tk>
Date: Thu, 4 Aug 2022 17:24:22 +0300
Subject: [PATCH 52/62] refactor(effect): simplify "active-hidden" state by
 inheriting from "initial-hidden"

This does not fix anything per se, just strips some unnecessary lines
and extra ensures zero opacity to other items.
---
 effect/effects/private/qml/WindowHeapDelegate.qml | 6 +-----
 1 file changed, 1 insertion(+), 5 deletions(-)

diff --git a/effect/effects/private/qml/WindowHeapDelegate.qml b/effect/effects/private/qml/WindowHeapDelegate.qml
index 7bea0106e..6f6cc648d 100644
--- a/effect/effects/private/qml/WindowHeapDelegate.qml
+++ b/effect/effects/private/qml/WindowHeapDelegate.qml
@@ -263,11 +263,7 @@ Item {
         },
         State {
             name: "active-hidden"
-            extend: "initial"
-            PropertyChanges {
-                target: thumb
-                opacity: 0
-            }
+            extend: "initial-hidden"
         }
     ]
 
-- 
GitLab


From be8e27f7c8de5a170cdeb54d25fbc7a32e246bfb Mon Sep 17 00:00:00 2001
From: ivan tkachenko <me@ratijas.tk>
Date: Thu, 4 Aug 2022 17:27:45 +0300
Subject: [PATCH 53/62] fix(effect): windows visibility during partial
 activation (realtime gesture)

Makes partial state account for both initial- and active-hidden status.

This fixes the case when activeHidden windows would show up during a
gesture even though they should disappear when the gesture completes.
---
 effect/effects/private/qml/WindowHeapDelegate.qml | 4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

diff --git a/effect/effects/private/qml/WindowHeapDelegate.qml b/effect/effects/private/qml/WindowHeapDelegate.qml
index 6f6cc648d..aed68ed66 100644
--- a/effect/effects/private/qml/WindowHeapDelegate.qml
+++ b/effect/effects/private/qml/WindowHeapDelegate.qml
@@ -216,7 +216,9 @@ Item {
                 y: (thumb.client.y - targetScreen.geometry.y - (thumb.windowHeap.absolutePositioning ?  windowHeap.layout.Kirigami.ScenePosition.y : 0)) * (1 - effect.partialActivationFactor) + cell.y * effect.partialActivationFactor
                 width: thumb.client.width * (1 - effect.partialActivationFactor) + cell.width * effect.partialActivationFactor
                 height: thumb.client.height * (1 - effect.partialActivationFactor) + cell.height * effect.partialActivationFactor
-                opacity: thumb.initialHidden ? effect.partialActivationFactor : 1
+                opacity: thumb.initialHidden
+                    ? (thumb.activeHidden ? 0 : effect.partialActivationFactor)
+                    : (thumb.activeHidden ? 1 - effect.partialActivationFactor : 1)
             }
             PropertyChanges {
                 target: icon
-- 
GitLab


From 91afa30ff9960a527c07348b13a57b49c33f4bd3 Mon Sep 17 00:00:00 2001
From: ivan tkachenko <me@ratijas.tk>
Date: Fri, 26 Aug 2022 23:48:43 +0300
Subject: [PATCH 54/62] fix(effect): stacking order and initial visibility for
 windows pinned to all desktops

---
 effect/effects/private/qml/WindowHeapDelegate.qml | 6 ++++--
 1 file changed, 4 insertions(+), 2 deletions(-)

diff --git a/effect/effects/private/qml/WindowHeapDelegate.qml b/effect/effects/private/qml/WindowHeapDelegate.qml
index aed68ed66..a55a54c66 100644
--- a/effect/effects/private/qml/WindowHeapDelegate.qml
+++ b/effect/effects/private/qml/WindowHeapDelegate.qml
@@ -21,7 +21,9 @@ Item {
 
     readonly property bool selected: windowHeap.selectedIndex === index
 
-    readonly property bool initialHidden: client.minimized || client.desktop !== KWinComponents.Workspace.currentDesktop
+    // -1 is a special value which means "All Desktops"
+    readonly property bool presentOnCurrentDesktop: client.desktop === KWinComponents.Workspace.currentDesktop || client.desktop === -1
+    readonly property bool initialHidden: client.minimized || !presentOnCurrentDesktop
     readonly property bool activeHidden: {
         if (windowHeap.showOnly === "activeClass") {
             // client.resourceName is not an actual String as comes from a QByteArray so === would fail
@@ -72,7 +74,7 @@ Item {
 
     visible: opacity > 0
     z: activeDragHandler.active ? 1000
-        : client.stackingOrder * (client.desktop === KWinComponents.Workspace.currentDesktop ? 1 : 0.001)
+        : client.stackingOrder * (presentOnCurrentDesktop ? 1 : 0.001)
 
     component TweenBehavior : Behavior {
         enabled: thumb.state !== "partial" && thumb.windowHeap.animationEnabled && !thumb.activeDragHandler.active
-- 
GitLab


From b688ee5632d9e4216d319207af201675c763bcb1 Mon Sep 17 00:00:00 2001
From: Vlad Zahorodnii <vlad.zahorodnii@kde.org>
Date: Fri, 9 Sep 2022 10:06:07 +0300
Subject: [PATCH 55/62] refactor(effect): stop highlighting WindowHeapDelegate
 when the effect is deactivated

It makes the deactivation animation look less weird when activating a
window in the overview effect using keyboard.
---
 effect/effects/private/qml/WindowHeapDelegate.qml | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/effect/effects/private/qml/WindowHeapDelegate.qml b/effect/effects/private/qml/WindowHeapDelegate.qml
index a55a54c66..3b6709109 100644
--- a/effect/effects/private/qml/WindowHeapDelegate.qml
+++ b/effect/effects/private/qml/WindowHeapDelegate.qml
@@ -292,7 +292,7 @@ Item {
         imagePath: "widgets/viewitem"
         prefix: "hover"
         z: -1
-        visible: !thumb.windowHeap.dragActive && (hoverHandler.hovered || selected) && Window.window.activeFocusItem
+        visible: !thumb.windowHeap.dragActive && (hoverHandler.hovered || selected) && Window.window.activeFocusItem && windowHeap.effectiveOrganized
     }
 
     HoverHandler {
-- 
GitLab


From aab472580e0d848c47005f7e18c37849e7313c05 Mon Sep 17 00:00:00 2001
From: ivan tkachenko <me@ratijas.tk>
Date: Tue, 13 Sep 2022 01:49:25 +0300
Subject: [PATCH 56/62] fix(effect): private, move highlight inside thumbnail
 component

..so that they always match in size, regardless of different
  combinations of drag&drop and animation states.

And also fix selected property to use id-qualified access.
---
 .../private/qml/WindowHeapDelegate.qml        | 28 +++++++++----------
 1 file changed, 14 insertions(+), 14 deletions(-)

diff --git a/effect/effects/private/qml/WindowHeapDelegate.qml b/effect/effects/private/qml/WindowHeapDelegate.qml
index 3b6709109..07459d86c 100644
--- a/effect/effects/private/qml/WindowHeapDelegate.qml
+++ b/effect/effects/private/qml/WindowHeapDelegate.qml
@@ -139,6 +139,20 @@ Item {
             }
         }
 
+        PlasmaCore.FrameSvgItem {
+            anchors {
+                fill: parent
+                topMargin: -PlasmaCore.Units.smallSpacing * 2
+                leftMargin: -PlasmaCore.Units.smallSpacing * 2
+                rightMargin: -PlasmaCore.Units.smallSpacing * 2
+                bottomMargin: -(Math.round(icon.height / 4) + caption.height + (PlasmaCore.Units.smallSpacing * 2))
+            }
+            imagePath: "widgets/viewitem"
+            prefix: "hover"
+            z: -1
+            visible: !thumb.windowHeap.dragActive && (hoverHandler.hovered || thumb.selected) && Window.window.activeFocusItem && windowHeap.effectiveOrganized
+        }
+
         MouseArea {
             anchors.fill: parent
             acceptedButtons: Qt.NoButton
@@ -281,20 +295,6 @@ Item {
         }
     }
 
-    PlasmaCore.FrameSvgItem {
-        anchors {
-            fill: parent
-            topMargin: -PlasmaCore.Units.smallSpacing * 2
-            leftMargin: -PlasmaCore.Units.smallSpacing * 2
-            rightMargin: -PlasmaCore.Units.smallSpacing * 2
-            bottomMargin: -(Math.round(icon.height / 4) + caption.height + (PlasmaCore.Units.smallSpacing * 2))
-        }
-        imagePath: "widgets/viewitem"
-        prefix: "hover"
-        z: -1
-        visible: !thumb.windowHeap.dragActive && (hoverHandler.hovered || selected) && Window.window.activeFocusItem && windowHeap.effectiveOrganized
-    }
-
     HoverHandler {
         id: hoverHandler
         onHoveredChanged: if (hovered !== selected) {
-- 
GitLab


From 976306d6770de3b501014e4b4cf25dad414c701e Mon Sep 17 00:00:00 2001
From: ivan tkachenko <me@ratijas.tk>
Date: Mon, 8 Aug 2022 13:44:13 +0300
Subject: [PATCH 57/62] refactor(effect): private, expose updatePolish to QML
 via forceLayout()

This is consistent with QtQuick library types like Grid and Flow. It
might come in handy when imperatively adding or removing children.
---
 effect/effects/private/expolayout.cpp | 5 +++++
 effect/effects/private/expolayout.h   | 2 ++
 2 files changed, 7 insertions(+)

diff --git a/effect/effects/private/expolayout.cpp b/effect/effects/private/expolayout.cpp
index 5a37a55e6..a45a88cb3 100644
--- a/effect/effects/private/expolayout.cpp
+++ b/effect/effects/private/expolayout.cpp
@@ -297,6 +297,11 @@ void ExpoLayout::setReady()
     }
 }
 
+void ExpoLayout::forceLayout()
+{
+    updatePolish();
+}
+
 void ExpoLayout::updatePolish()
 {
     if (!m_cells.isEmpty()) {
diff --git a/effect/effects/private/expolayout.h b/effect/effects/private/expolayout.h
index 48ae7b907..ff623f38b 100644
--- a/effect/effects/private/expolayout.h
+++ b/effect/effects/private/expolayout.h
@@ -46,6 +46,8 @@ public:
     bool isReady() const;
     void setReady();
 
+    Q_INVOKABLE void forceLayout();
+
 protected:
 #if QT_VERSION < QT_VERSION_CHECK(6, 0, 0)
     void geometryChanged(const QRectF& newGeometry, const QRectF& oldGeometry) override;
-- 
GitLab


From 689e5b3356643dac623211b6edc5f14824a5bd5f Mon Sep 17 00:00:00 2001
From: ivan tkachenko <me@ratijas.tk>
Date: Tue, 13 Sep 2022 01:32:35 +0300
Subject: [PATCH 58/62] refactor(effect): restore position correctly when
 dropping a window

This required a bit of a magic on the WindowHeap side to store and
restore global position of a WindowHeapDelegates' window thumbnails.

An additional property bool animationEnabled on a delegate level enables
the heap to restore position without playing unneeded initial animation,
just like the heap itself.

Windows that are being dragged or already returning form a drop are
positioned higher than others on a z-stack.

BUG: 453995
---
 effect/effects/private/qml/WindowHeap.qml     | 24 ++++++
 .../private/qml/WindowHeapDelegate.qml        | 82 +++++++++++++++++--
 2 files changed, 98 insertions(+), 8 deletions(-)

diff --git a/effect/effects/private/qml/WindowHeap.qml b/effect/effects/private/qml/WindowHeap.qml
index f9a8fc422..07ccf5411 100644
--- a/effect/effects/private/qml/WindowHeap.qml
+++ b/effect/effects/private/qml/WindowHeap.qml
@@ -1,5 +1,6 @@
 /*
     SPDX-FileCopyrightText: 2021 Vlad Zahorodnii <vlad.zahorodnii@kde.org>
+    SPDX-FileCopyrightText: 2022 ivan tkachenko <me@ratijas.tk>
 
     SPDX-License-Identifier: GPL-2.0-or-later
 */
@@ -49,6 +50,13 @@ FocusScope {
         activated();
     }
 
+    /** @type {{client.internalId: rect}} */
+    property var dndManagerStore: ({})
+
+    function saveDND(key: int, rect: rect) {
+        dndManagerStore[key] = rect;
+    }
+
     KWinComponents.WindowThumbnailItem {
         id: otherScreenThumbnail
         z: 2
@@ -109,6 +117,22 @@ FocusScope {
 
         Repeater {
             id: windowsRepeater
+
+            onItemAdded: (index, item) => {
+                // restore/reparent from drop
+                var key = item.client.internalId;
+                if (key in heap.dndManagerStore) {
+                    expoLayout.forceLayout();
+                    var oldGlobalRect = heap.dndManagerStore[key];
+                    item.restoreDND(oldGlobalRect);
+                    delete heap.dndManagerStore[key];
+                } else if (heap.effectiveOrganized) {
+                    // New window has opened in the middle of a running effect.
+                    // Make sure it is positioned before enabling its animations.
+                    expoLayout.forceLayout();
+                }
+                item.animationEnabled = true;
+            }
             delegate: WindowHeapDelegate {
                 windowHeap: heap
             }
diff --git a/effect/effects/private/qml/WindowHeapDelegate.qml b/effect/effects/private/qml/WindowHeapDelegate.qml
index 07459d86c..fa440e9c3 100644
--- a/effect/effects/private/qml/WindowHeapDelegate.qml
+++ b/effect/effects/private/qml/WindowHeapDelegate.qml
@@ -1,5 +1,6 @@
 /*
     SPDX-FileCopyrightText: 2021 Vlad Zahorodnii <vlad.zahorodnii@kde.org>
+    SPDX-FileCopyrightText: 2022 ivan tkachenko <me@ratijas.tk>
 
     SPDX-License-Identifier: GPL-2.0-or-later
 */
@@ -39,6 +40,9 @@ Item {
     // Show a text label under this thumbnail
     property bool windowTitleVisible: true
 
+    // Same as for window heap
+    property bool animationEnabled: false
+
     //scale up and down the whole thumbnail without affecting layouting
     property real targetScale: 1.0
 
@@ -73,11 +77,15 @@ Item {
     }
 
     visible: opacity > 0
-    z: activeDragHandler.active ? 1000
+    z: (activeDragHandler.active || returning.running) ? 1000
         : client.stackingOrder * (presentOnCurrentDesktop ? 1 : 0.001)
 
+    function restoreDND(oldGlobalRect: rect) {
+        thumbSource.restoreDND(oldGlobalRect);
+    }
+
     component TweenBehavior : Behavior {
-        enabled: thumb.state !== "partial" && thumb.windowHeap.animationEnabled && !thumb.activeDragHandler.active
+        enabled: thumb.state !== "partial" && thumb.windowHeap.animationEnabled && thumb.animationEnabled && !thumb.activeDragHandler.active
         NumberAnimation {
             duration: thumb.windowHeap.animationDuration
             easing.type: Easing.OutCubic
@@ -92,9 +100,7 @@ Item {
     KWinComponents.WindowThumbnailItem {
         id: thumbSource
         wId: thumb.client.internalId
-        state: thumb.activeDragHandler.active ? "drag" : "normal"
 
-        Drag.active: thumb.activeDragHandler.active
         Drag.proposedAction: Qt.MoveAction
         Drag.supportedActions: Qt.MoveAction
         Drag.source: thumb.client
@@ -105,6 +111,23 @@ Item {
         onXChanged: effect.checkItemDraggedOutOfScreen(thumbSource)
         onYChanged: effect.checkItemDraggedOutOfScreen(thumbSource)
 
+        state: "normal"
+        function saveDND() {
+            const oldGlobalRect = mapToItem(null, 0, 0, width, height);
+            thumb.windowHeap.saveDND(thumb.client.internalId, oldGlobalRect);
+        }
+        function restoreDND(oldGlobalRect: rect) {
+            state = "reparenting";
+
+            const newGlobalRect = mapFromItem(null, oldGlobalRect);
+
+            x = newGlobalRect.x;
+            y = newGlobalRect.y;
+            width = newGlobalRect.width;
+            height = newGlobalRect.height;
+
+            state = "normal";
+        }
         states: [
             State {
                 name: "normal"
@@ -116,6 +139,14 @@ Item {
                     height: thumb.height
                 }
             },
+            State {
+                name: "pressed"
+                PropertyChanges {
+                    target: thumbSource
+                    width: thumb.width
+                    height: thumb.height
+                }
+            },
             State {
                 name: "drag"
                 PropertyChanges {
@@ -124,17 +155,25 @@ Item {
                             thumb.activeDragHandler.centroid.position.x
                     y: -thumb.activeDragHandler.centroid.pressPosition.y * thumb.targetScale +
                             thumb.activeDragHandler.centroid.position.y
-                    width: cell.width * thumb.targetScale
-                    height: cell.height * thumb.targetScale
+                    width: thumb.width * thumb.targetScale
+                    height: thumb.height * thumb.targetScale
+                }
+            },
+            State {
+                name: "reparenting"
+                PropertyChanges {
+                    target: thumbSource
                 }
             }
         ]
         transitions: Transition {
+            id: returning
+            from: "drag,reparenting"
             to: "normal"
             enabled: thumb.windowHeap.animationEnabled
             NumberAnimation {
                 duration: thumb.windowHeap.animationDuration
-                properties: "x, y, width, height, opacity"
+                properties: "x, y, width, height"
                 easing.type: Easing.OutCubic
             }
         }
@@ -316,25 +355,52 @@ Item {
         onTapped: {
             thumb.windowHeap.windowClicked(thumb.client, eventPoint)
         }
+        onPressedChanged: {
+            if (pressed) {
+                var saved = Qt.point(thumbSource.x, thumbSource.y);
+                thumbSource.Drag.active = true;
+                thumbSource.state = "pressed";
+                thumbSource.x = saved.x;
+                thumbSource.y = saved.y;
+            } else if (!thumb.activeDragHandler.active) {
+                thumbSource.Drag.active = false;
+                thumbSource.state = "normal";
+            }
+        }
     }
 
     component DragManager : DragHandler {
         target: null
+        dragThreshold: 0
         grabPermissions: PointerHandler.CanTakeOverFromAnything
+        // This does not work when moving pointer fast and pressing along the way
+        // See also QTBUG-105903, QTBUG-105904
+        // enabled: thumbSource.state !== "normal"
 
         onActiveChanged: {
             thumb.windowHeap.dragActive = active;
             if (active) {
                 thumb.activeDragHandler = this;
+                thumbSource.state = "drag";
             } else {
+                thumbSource.saveDND();
+
                 var action = thumbSource.Drag.drop();
                 if (action === Qt.MoveAction) {
-                    // this whole component is in the process of being destroyed due to drop onto
+                    // This whole component is in the process of being destroyed due to drop onto
                     // another virtual desktop (not another screen).
+                    if (typeof thumbSource !== "undefined") {
+                        // Except the case when it was dropped on the same desktop which it's already on, so let's return to normal state anyway.
+                        thumbSource.state = "normal";
+                    }
                     return;
                 }
+
                 var globalPos = targetScreen.mapToGlobal(centroid.scenePosition);
                 effect.checkItemDroppedOutOfScreen(globalPos, thumbSource);
+
+                // else, return to normal without reparenting
+                thumbSource.state = "normal";
             }
         }
     }
-- 
GitLab


From 0bfa103b052b334d6d2a8269ab7767456cf8b4db Mon Sep 17 00:00:00 2001
From: ivan tkachenko <me@ratijas.tk>
Date: Mon, 5 Sep 2022 16:06:37 +0300
Subject: [PATCH 59/62] refactor(effect): encourage developers explore the code
 instead

---
 effect/effects/private/qml/WindowHeap.qml | 1 -
 1 file changed, 1 deletion(-)

diff --git a/effect/effects/private/qml/WindowHeap.qml b/effect/effects/private/qml/WindowHeap.qml
index 07ccf5411..bb471c811 100644
--- a/effect/effects/private/qml/WindowHeap.qml
+++ b/effect/effects/private/qml/WindowHeap.qml
@@ -50,7 +50,6 @@ FocusScope {
         activated();
     }
 
-    /** @type {{client.internalId: rect}} */
     property var dndManagerStore: ({})
 
     function saveDND(key: int, rect: rect) {
-- 
GitLab


From 4e7bc57d7939263b6c6fda58f27d2d3c84090e92 Mon Sep 17 00:00:00 2001
From: Marco Martin <notmart@gmail.com>
Date: Tue, 13 Sep 2022 13:38:55 +0200
Subject: [PATCH 60/62] refactor(effect): manage Drag in a TapHandler which
 accepts also touch

the Drag attached was set to active in a taphandler which didn't
accept touch, breaking drag and drop on wayland+touch
moving the logic on the other handler makes it work everywhere
---
 .../effects/private/qml/WindowHeapDelegate.qml   | 16 ++++++++--------
 1 file changed, 8 insertions(+), 8 deletions(-)

diff --git a/effect/effects/private/qml/WindowHeapDelegate.qml b/effect/effects/private/qml/WindowHeapDelegate.qml
index fa440e9c3..0283c84a3 100644
--- a/effect/effects/private/qml/WindowHeapDelegate.qml
+++ b/effect/effects/private/qml/WindowHeapDelegate.qml
@@ -347,14 +347,6 @@ Item {
             KWinComponents.Workspace.activeClient = thumb.client;
             thumb.windowHeap.activated();
         }
-    }
-
-    TapHandler {
-        acceptedPointerTypes: PointerDevice.GenericPointer | PointerDevice.Pen
-        acceptedButtons: Qt.LeftButton | Qt.MiddleButton | Qt.RightButton
-        onTapped: {
-            thumb.windowHeap.windowClicked(thumb.client, eventPoint)
-        }
         onPressedChanged: {
             if (pressed) {
                 var saved = Qt.point(thumbSource.x, thumbSource.y);
@@ -369,6 +361,14 @@ Item {
         }
     }
 
+    TapHandler {
+        acceptedPointerTypes: PointerDevice.GenericPointer | PointerDevice.Pen
+        acceptedButtons: Qt.LeftButton | Qt.MiddleButton | Qt.RightButton
+        onTapped: {
+            thumb.windowHeap.windowClicked(thumb.client, eventPoint)
+        }
+    }
+
     component DragManager : DragHandler {
         target: null
         dragThreshold: 0
-- 
GitLab


From 98af004ddbb31b62f606f537061ed7a5d033b3ae Mon Sep 17 00:00:00 2001
From: Vlad Zahorodnii <vlad.zahorodnii@kde.org>
Date: Wed, 14 Sep 2022 15:07:54 +0300
Subject: [PATCH 61/62] refactor(effect): set "active class" mode

Each screen has its own WindowHeap. So setting WindowHeap.activeClass
won't be visible on other screens.

In order to address that limitation, we could monitor
Workspace.activeClient property.

BUG: 455974
---
 effect/effects/private/qml/WindowHeap.qml     |  1 -
 .../private/qml/WindowHeapDelegate.qml        | 22 +++++--------------
 2 files changed, 6 insertions(+), 17 deletions(-)

diff --git a/effect/effects/private/qml/WindowHeap.qml b/effect/effects/private/qml/WindowHeap.qml
index bb471c811..d95d3db79 100644
--- a/effect/effects/private/qml/WindowHeap.qml
+++ b/effect/effects/private/qml/WindowHeap.qml
@@ -35,7 +35,6 @@ FocusScope {
     property real padding: 0
     // Either a string "activeClass" or a list internalIds of clients
     property var showOnly: []
-    property string activeClass
 
     required property bool organized
     readonly property bool effectiveOrganized: expoLayout.ready && organized
diff --git a/effect/effects/private/qml/WindowHeapDelegate.qml b/effect/effects/private/qml/WindowHeapDelegate.qml
index 0283c84a3..d6e9f8dc7 100644
--- a/effect/effects/private/qml/WindowHeapDelegate.qml
+++ b/effect/effects/private/qml/WindowHeapDelegate.qml
@@ -27,8 +27,12 @@ Item {
     readonly property bool initialHidden: client.minimized || !presentOnCurrentDesktop
     readonly property bool activeHidden: {
         if (windowHeap.showOnly === "activeClass") {
-            // client.resourceName is not an actual String as comes from a QByteArray so === would fail
-            return windowHeap.activeClass !== String(client.resourceName);
+            if (!KWinComponents.Workspace.activeClient) {
+                return true;
+            } else {
+                // client.resourceName is not an actual String as comes from a QByteArray so === would fail
+                return String(KWinComponents.Workspace.activeClient.resourceName) !== String(client.resourceName);
+            }
         } else {
             return windowHeap.showOnly.length !== 0
                 && windowHeap.showOnly.indexOf(client.internalId) === -1;
@@ -52,20 +56,6 @@ Item {
     readonly property alias downGestureProgress: touchDragHandler.downGestureProgress
     signal downGestureTriggered()
 
-    Component.onCompleted: {
-        if (client.active) {
-            windowHeap.activeClass = client.resourceName;
-        }
-    }
-    Connections {
-        target: thumb.client
-        function onActiveChanged() {
-            if (thumb.client.active) {
-                thumb.windowHeap.activeClass = thumb.client.resourceName;
-            }
-        }
-    }
-
     state: {
         if (effect.gestureInProgress) {
             return "partial";
-- 
GitLab


From 67c2218762641c16c91d2593dbe704c4dc651bf5 Mon Sep 17 00:00:00 2001
From: Sergio Blanco <seral79@gmail.com>
Date: Thu, 20 Oct 2022 20:14:24 -0500
Subject: [PATCH 62/62] feat(effect): introduce plugin
 org.kde.kwin.private.effects

We need to introduce the org.kde.kwin.private.effects plugin,
since plasma 5.26.0 is a dependency of kdeplasma-addons.
---
 effect/effects/private/expoarea.h        | 3 ++-
 effect/lib/kwineffects/effects_handler.h | 1 +
 render/effects.h                         | 7 +++++++
 3 files changed, 10 insertions(+), 1 deletion(-)

diff --git a/effect/effects/private/expoarea.h b/effect/effects/private/expoarea.h
index e5cb62aad..4c9b072d9 100644
--- a/effect/effects/private/expoarea.h
+++ b/effect/effects/private/expoarea.h
@@ -6,7 +6,8 @@
 
 #pragma once
 
-#include <kwineffects.h>
+#include <kwineffects/effect_screen.h>
+#include <kwineffects/effects_handler.h>
 
 namespace KWin
 {
diff --git a/effect/lib/kwineffects/effects_handler.h b/effect/lib/kwineffects/effects_handler.h
index 5331c2cf8..4a5671155 100644
--- a/effect/lib/kwineffects/effects_handler.h
+++ b/effect/lib/kwineffects/effects_handler.h
@@ -328,6 +328,7 @@ public:
     virtual int numScreens() const = 0;                                 // Xinerama
     Q_SCRIPTABLE virtual int screenNumber(const QPoint& pos) const = 0; // Xinerama
     virtual QRect clientArea(clientAreaOption, int screen, int desktop) const = 0;
+    virtual QRect clientArea(clientAreaOption, const EffectScreen* screen, int desktop) const = 0;
     virtual QRect clientArea(clientAreaOption, const EffectWindow* c) const = 0;
     virtual QRect clientArea(clientAreaOption, const QPoint& p, int desktop) const = 0;
 
diff --git a/render/effects.h b/render/effects.h
index bb36323f1..815b545ce 100644
--- a/render/effects.h
+++ b/render/effects.h
@@ -1118,6 +1118,13 @@ public:
         return win::space_window_area(*compositor.space, opt, output, desktop);
     }
 
+    QRect clientArea(clientAreaOption opt, const EffectScreen* screen, int desktop) const override
+    {
+        auto screenImpl = static_cast<effect_screen_impl<base::output> const*>(screen);
+        auto output = static_cast<typename base_t::output_t*>(screenImpl->platformOutput());
+        return win::space_window_area(*compositor.space, opt, output, desktop);
+    }
+
     QRect clientArea(clientAreaOption opt, const EffectWindow* eff_win) const override
     {
         return std::visit(overload{[&, this](auto&& win) {
-- 
GitLab

