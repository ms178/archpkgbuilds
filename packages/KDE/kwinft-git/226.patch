From f2bfb42b5b63b0c263e6be91b27efe2e75e99340 Mon Sep 17 00:00:00 2001
From: Roman Gilg <subdiff@gmail.com>
Date: Mon, 4 Jul 2022 14:32:24 +0200
Subject: [PATCH 01/51] refactor: get support info from free function

Move it out of the space class.
---
 base/dbus/kwin.h     |   3 +-
 debug/support_info.h | 309 +++++++++++++++++++++++++++++++++++++++++++
 scripting/space.h    |   3 +-
 win/space.cpp        | 285 ---------------------------------------
 win/space.h          |   3 -
 5 files changed, 313 insertions(+), 290 deletions(-)
 create mode 100644 debug/support_info.h

diff --git a/base/dbus/kwin.h b/base/dbus/kwin.h
index ad1cc3236..bc115aa7d 100644
--- a/base/dbus/kwin.h
+++ b/base/dbus/kwin.h
@@ -6,6 +6,7 @@
 */
 #pragma once
 
+#include "debug/support_info.h"
 #include "input/platform.h"
 #include "main.h"
 #include "toplevel.h"
@@ -142,7 +143,7 @@ public:
 
     QString support_information_impl() override
     {
-        return space.supportInformation();
+        return debug::get_support_info(space);
     }
 
     int current_desktop_impl() override
diff --git a/debug/support_info.h b/debug/support_info.h
new file mode 100644
index 000000000..cdbd15980
--- /dev/null
+++ b/debug/support_info.h
@@ -0,0 +1,309 @@
+/*
+    SPDX-FileCopyrightText: 2022 Roman Gilg <subdiff@gmail.com>
+
+    SPDX-License-Identifier: GPL-2.0-or-later
+*/
+#pragma once
+
+#include "base/options.h"
+#include "base/platform.h"
+#include "base/x11/xcb/extensions.h"
+#include "main.h"
+#include "win/deco/bridge.h"
+
+#include <config-kwin.h>
+#include <kwingl/platform.h>
+
+#include <KLocalizedString>
+#include <QMetaProperty>
+#include <QString>
+
+namespace KWin::debug
+{
+
+// TODO(romangg): This method should be split up into the seperate modules input, render, win, etc.
+template<typename Space>
+QString get_support_info(Space const& space)
+{
+    QString support;
+    const QString yes = QStringLiteral("yes\n");
+    const QString no = QStringLiteral("no\n");
+
+    support.append(ki18nc("Introductory text shown in the support information.",
+                          "KWinFT Support Information:\n"
+                          "The following information should be provided when openning an issue\n"
+                          "ticket on https://gitlab.com/kwinft/kwinft.\n"
+                          "It gives information about the currently running instance, which\n"
+                          "options are used, what OpenGL driver and which effects are running.\n"
+                          "Please paste the information provided underneath this introductory\n"
+                          "text into a html details header and triple backticks when you\n"
+                          "create an issue ticket:\n"
+                          "\n<details>\n"
+                          "<summary>Support Information</summary>\n"
+                          "\n```\n"
+                          "PASTE GOES HERE...\n"
+                          "```\n"
+                          "\n</details>\n")
+                       .toString());
+
+    support.append(QStringLiteral("\n==========================\n\n"));
+    support.append(QStringLiteral("Version\n"));
+    support.append(QStringLiteral("=======\n"));
+    support.append(QStringLiteral("KWinFT version: "));
+    support.append(QStringLiteral(KWIN_VERSION_STRING));
+    support.append(QStringLiteral("\n"));
+    support.append(QStringLiteral("Qt Version: "));
+    support.append(QString::fromUtf8(qVersion()));
+    support.append(QStringLiteral("\n"));
+    support.append(QStringLiteral("Qt compile version: %1\n").arg(QStringLiteral(QT_VERSION_STR)));
+    support.append(
+        QStringLiteral("XCB compile version: %1\n\n").arg(QStringLiteral(XCB_VERSION_STRING)));
+    support.append(QStringLiteral("Operation Mode: "));
+    switch (kwinApp()->operationMode()) {
+    case Application::OperationModeX11:
+        support.append(QStringLiteral("X11 only"));
+        break;
+    case Application::OperationModeWaylandOnly:
+        support.append(QStringLiteral("Wayland Only"));
+        break;
+    case Application::OperationModeXwayland:
+        support.append(QStringLiteral("Xwayland"));
+        break;
+    }
+    support.append(QStringLiteral("\n\n"));
+
+    support.append(QStringLiteral("Build Options\n"));
+    support.append(QStringLiteral("=============\n"));
+
+    support.append(QStringLiteral("KWIN_BUILD_DECORATIONS: "));
+    support.append(KWIN_BUILD_DECORATIONS ? yes : no);
+    support.append(QStringLiteral("KWIN_BUILD_TABBOX: "));
+    support.append(KWIN_BUILD_TABBOX ? yes : no);
+    support.append(QStringLiteral("KWIN_BUILD_ACTIVITIES (deprecated): "));
+    support.append(no);
+    support.append(QStringLiteral("HAVE_PERF: "));
+    support.append(HAVE_PERF ? yes : no);
+    support.append(QStringLiteral("HAVE_EPOXY_GLX: "));
+    support.append(HAVE_EPOXY_GLX ? yes : no);
+    support.append(QStringLiteral("\n"));
+
+    if (auto c = kwinApp()->x11Connection()) {
+        support.append(QStringLiteral("X11\n"));
+        support.append(QStringLiteral("===\n"));
+        auto x11setup = xcb_get_setup(c);
+        support.append(QStringLiteral("Vendor: %1\n")
+                           .arg(QString::fromUtf8(QByteArray::fromRawData(
+                               xcb_setup_vendor(x11setup), xcb_setup_vendor_length(x11setup)))));
+        support.append(QStringLiteral("Vendor Release: %1\n").arg(x11setup->release_number));
+        support.append(QStringLiteral("Protocol Version/Revision: %1/%2\n")
+                           .arg(x11setup->protocol_major_version)
+                           .arg(x11setup->protocol_minor_version));
+        auto const extensions = base::x11::xcb::extensions::self()->get_data();
+        for (const auto& e : extensions) {
+            support.append(QStringLiteral("%1: %2; Version: 0x%3\n")
+                               .arg(QString::fromUtf8(e.name))
+                               .arg(e.present ? yes.trimmed() : no.trimmed())
+                               .arg(QString::number(e.version, 16)));
+        }
+        support.append(QStringLiteral("\n"));
+    }
+
+    if (space.deco) {
+        support.append(QStringLiteral("Decoration\n"));
+        support.append(QStringLiteral("==========\n"));
+        support.append(space.deco->supportInformation());
+        support.append(QStringLiteral("\n"));
+    }
+
+    support.append(QStringLiteral("Options\n"));
+    support.append(QStringLiteral("=======\n"));
+
+    auto const metaOptions = kwinApp()->options->metaObject();
+    auto printProperty = [](const QVariant& variant) {
+        if (variant.type() == QVariant::Size) {
+            const QSize& s = variant.toSize();
+            return QStringLiteral("%1x%2")
+                .arg(QString::number(s.width()))
+                .arg(QString::number(s.height()));
+        }
+        if (QLatin1String(variant.typeName()) == QLatin1String("KWin::OpenGLPlatformInterface")
+            || QLatin1String(variant.typeName())
+                == QLatin1String("KWin::base::options::WindowOperation")) {
+            return QString::number(variant.toInt());
+        }
+        return variant.toString();
+    };
+    for (int i = 0; i < metaOptions->propertyCount(); ++i) {
+        const QMetaProperty property = metaOptions->property(i);
+        if (QLatin1String(property.name()) == QLatin1String("objectName")) {
+            continue;
+        }
+        support.append(QStringLiteral("%1: %2\n")
+                           .arg(property.name())
+                           .arg(printProperty(kwinApp()->options->property(property.name()))));
+    }
+
+    support.append(QStringLiteral("\nScreen Edges\n"));
+    support.append(QStringLiteral("============\n"));
+    auto const metaScreenEdges = space.edges->metaObject();
+    for (int i = 0; i < metaScreenEdges->propertyCount(); ++i) {
+        const QMetaProperty property = metaScreenEdges->property(i);
+        if (QLatin1String(property.name()) == QLatin1String("objectName")) {
+            continue;
+        }
+        support.append(QStringLiteral("%1: %2\n")
+                           .arg(property.name())
+                           .arg(printProperty(space.edges->property(property.name()))));
+    }
+    support.append(QStringLiteral("\nScreens\n"));
+    support.append(QStringLiteral("=======\n"));
+    support.append(QStringLiteral("Multi-Head: "));
+    support.append(QStringLiteral("not supported anymore\n"));
+    support.append(QStringLiteral("Active screen follows mouse: "));
+    support.append(kwinApp()->options->get_current_output_follows_mouse() ? yes : no);
+
+    auto const& outputs = kwinApp()->get_base().get_outputs();
+    support.append(QStringLiteral("Number of Screens: %1\n\n").arg(outputs.size()));
+    for (size_t i = 0; i < outputs.size(); ++i) {
+        auto const output = outputs.at(i);
+        auto const geo = output->geometry();
+        support.append(QStringLiteral("Screen %1:\n").arg(i));
+        support.append(QStringLiteral("---------\n"));
+        support.append(QStringLiteral("Name: %1\n").arg(output->name()));
+        support.append(QStringLiteral("Geometry: %1,%2,%3x%4\n")
+                           .arg(geo.x())
+                           .arg(geo.y())
+                           .arg(geo.width())
+                           .arg(geo.height()));
+        support.append(QStringLiteral("Scale: %1\n").arg(output->scale()));
+        support.append(QStringLiteral("Refresh Rate: %1\n\n").arg(output->refresh_rate()));
+    }
+
+    support.append(QStringLiteral("\nCompositing\n"));
+    support.append(QStringLiteral("===========\n"));
+    if (auto& effects = space.render.effects) {
+        support.append(QStringLiteral("Compositing is active\n"));
+        switch (effects->compositingType()) {
+        case OpenGLCompositing: {
+            auto platform = GLPlatform::instance();
+            if (platform->isGLES()) {
+                support.append(QStringLiteral("Compositing Type: OpenGL ES 2.0\n"));
+            } else {
+                support.append(QStringLiteral("Compositing Type: OpenGL\n"));
+            }
+            support.append(QStringLiteral("OpenGL vendor string: ")
+                           + QString::fromUtf8(platform->glVendorString()) + QStringLiteral("\n"));
+            support.append(QStringLiteral("OpenGL renderer string: ")
+                           + QString::fromUtf8(platform->glRendererString())
+                           + QStringLiteral("\n"));
+            support.append(QStringLiteral("OpenGL version string: ")
+                           + QString::fromUtf8(platform->glVersionString()) + QStringLiteral("\n"));
+            support.append(QStringLiteral("OpenGL platform interface: "));
+            switch (platform->platformInterface()) {
+            case GlxPlatformInterface:
+                support.append(QStringLiteral("GLX"));
+                break;
+            case EglPlatformInterface:
+                support.append(QStringLiteral("EGL"));
+                break;
+            default:
+                support.append(QStringLiteral("UNKNOWN"));
+            }
+            support.append(QStringLiteral("\n"));
+
+            if (platform->supports(LimitedGLSL) || platform->supports(GLSL))
+                support.append(QStringLiteral("OpenGL shading language version string: ")
+                               + QString::fromUtf8(platform->glShadingLanguageVersionString())
+                               + QStringLiteral("\n"));
+
+            support.append(QStringLiteral("Driver: ")
+                           + GLPlatform::driverToString(platform->driver()) + QStringLiteral("\n"));
+            if (!platform->isMesaDriver())
+                support.append(QStringLiteral("Driver version: ")
+                               + GLPlatform::versionToString(platform->driverVersion())
+                               + QStringLiteral("\n"));
+
+            support.append(QStringLiteral("GPU class: ")
+                           + GLPlatform::chipClassToString(platform->chipClass())
+                           + QStringLiteral("\n"));
+
+            support.append(QStringLiteral("OpenGL version: ")
+                           + GLPlatform::versionToString(platform->glVersion())
+                           + QStringLiteral("\n"));
+
+            if (platform->supports(LimitedGLSL) || platform->supports(GLSL))
+                support.append(QStringLiteral("GLSL version: ")
+                               + GLPlatform::versionToString(platform->glslVersion())
+                               + QStringLiteral("\n"));
+
+            if (platform->isMesaDriver())
+                support.append(QStringLiteral("Mesa version: ")
+                               + GLPlatform::versionToString(platform->mesaVersion())
+                               + QStringLiteral("\n"));
+            if (platform->serverVersion() > 0)
+                support.append(QStringLiteral("X server version: ")
+                               + GLPlatform::versionToString(platform->serverVersion())
+                               + QStringLiteral("\n"));
+            if (platform->kernelVersion() > 0)
+                support.append(QStringLiteral("Linux kernel version: ")
+                               + GLPlatform::versionToString(platform->kernelVersion())
+                               + QStringLiteral("\n"));
+
+            support.append(QStringLiteral("Direct rendering: "));
+            support.append(QStringLiteral("Requires strict binding: "));
+            support.append(!platform->isLooseBinding() ? yes : no);
+            support.append(QStringLiteral("GLSL shaders: "));
+            if (platform->supports(GLSL)) {
+                support.append(platform->supports(LimitedGLSL) ? QStringLiteral("limited\n") : yes);
+            } else {
+                support.append(no);
+            }
+            support.append(QStringLiteral("Texture NPOT support: "));
+            if (platform->supports(TextureNPOT)) {
+                support.append(platform->supports(LimitedNPOT) ? QStringLiteral("limited\n") : yes);
+            } else {
+                support.append(no);
+            }
+            support.append(QStringLiteral("Virtual Machine: "));
+            support.append(platform->isVirtualMachine() ? yes : no);
+            support.append(QStringLiteral("Timer query support: "));
+            support.append(platform->supports(GLFeature::TimerQuery) ? yes : no);
+            support.append(QStringLiteral("OpenGL 2 Shaders are used\n"));
+            break;
+        }
+        case XRenderCompositing:
+            support.append(QStringLiteral("Compositing Type: XRender\n"));
+            break;
+        case QPainterCompositing:
+            support.append("Compositing Type: QPainter\n");
+            break;
+        case NoCompositing:
+        default:
+            support.append(
+                QStringLiteral("Something is really broken, neither OpenGL nor XRender is used"));
+        }
+        support.append(QStringLiteral("\nLoaded Effects:\n"));
+        support.append(QStringLiteral("---------------\n"));
+        auto const& loaded_effects = effects->loadedEffects();
+        for (auto const& effect : qAsConst(loaded_effects)) {
+            support.append(effect + QStringLiteral("\n"));
+        }
+        support.append(QStringLiteral("\nCurrently Active Effects:\n"));
+        support.append(QStringLiteral("-------------------------\n"));
+        auto const& active_effects = effects->activeEffects();
+        for (auto const& effect : qAsConst(active_effects)) {
+            support.append(effect + QStringLiteral("\n"));
+        }
+        support.append(QStringLiteral("\nEffect Settings:\n"));
+        support.append(QStringLiteral("----------------\n"));
+        for (auto const& effect : qAsConst(loaded_effects)) {
+            support.append(effects->supportInformation(effect));
+            support.append(QStringLiteral("\n"));
+        }
+    } else {
+        support.append(QStringLiteral("Compositing is not active\n"));
+    }
+    return support;
+}
+
+}
diff --git a/scripting/space.h b/scripting/space.h
index 9fb7f8ce4..118010679 100644
--- a/scripting/space.h
+++ b/scripting/space.h
@@ -24,6 +24,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
 #include "base/output_helpers.h"
 #include "base/platform.h"
+#include "debug/support_info.h"
 #include "main.h"
 #include "win/move.h"
 #include "win/screen.h"
@@ -826,7 +827,7 @@ protected:
 
     QString supportInformation() const override
     {
-        return ref_space->supportInformation();
+        return debug::get_support_info(*ref_space);
     }
 
     window* get_client_impl(qulonglong windowId) override
diff --git a/win/space.cpp b/win/space.cpp
index 52c1efa89..c7e6bb74d 100644
--- a/win/space.cpp
+++ b/win/space.cpp
@@ -72,8 +72,6 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "tabbox/tabbox.h"
 #endif
 
-#include <kwingl/platform.h>
-
 #include <KConfig>
 #include <KConfigGroup>
 #include <KGlobalAccel>
@@ -589,289 +587,6 @@ void space::disableGlobalShortcutsForClient(bool disable)
     }
 }
 
-QString space::supportInformation() const
-{
-    QString support;
-    const QString yes = QStringLiteral("yes\n");
-    const QString no = QStringLiteral("no\n");
-
-    support.append(ki18nc("Introductory text shown in the support information.",
-                          "KWinFT Support Information:\n"
-                          "The following information should be provided when openning an issue\n"
-                          "ticket on https://gitlab.com/kwinft/kwinft.\n"
-                          "It gives information about the currently running instance, which\n"
-                          "options are used, what OpenGL driver and which effects are running.\n"
-                          "Please paste the information provided underneath this introductory\n"
-                          "text into a html details header and triple backticks when you\n"
-                          "create an issue ticket:\n"
-                          "\n<details>\n"
-                          "<summary>Support Information</summary>\n"
-                          "\n```\n"
-                          "PASTE GOES HERE...\n"
-                          "```\n"
-                          "\n</details>\n")
-                       .toString());
-
-    support.append(QStringLiteral("\n==========================\n\n"));
-    support.append(QStringLiteral("Version\n"));
-    support.append(QStringLiteral("=======\n"));
-    support.append(QStringLiteral("KWinFT version: "));
-    support.append(QStringLiteral(KWIN_VERSION_STRING));
-    support.append(QStringLiteral("\n"));
-    support.append(QStringLiteral("Qt Version: "));
-    support.append(QString::fromUtf8(qVersion()));
-    support.append(QStringLiteral("\n"));
-    support.append(QStringLiteral("Qt compile version: %1\n").arg(QStringLiteral(QT_VERSION_STR)));
-    support.append(
-        QStringLiteral("XCB compile version: %1\n\n").arg(QStringLiteral(XCB_VERSION_STRING)));
-    support.append(QStringLiteral("Operation Mode: "));
-    switch (kwinApp()->operationMode()) {
-    case Application::OperationModeX11:
-        support.append(QStringLiteral("X11 only"));
-        break;
-    case Application::OperationModeWaylandOnly:
-        support.append(QStringLiteral("Wayland Only"));
-        break;
-    case Application::OperationModeXwayland:
-        support.append(QStringLiteral("Xwayland"));
-        break;
-    }
-    support.append(QStringLiteral("\n\n"));
-
-    support.append(QStringLiteral("Build Options\n"));
-    support.append(QStringLiteral("=============\n"));
-
-    support.append(QStringLiteral("KWIN_BUILD_DECORATIONS: "));
-    support.append(KWIN_BUILD_DECORATIONS ? yes : no);
-    support.append(QStringLiteral("KWIN_BUILD_TABBOX: "));
-    support.append(KWIN_BUILD_TABBOX ? yes : no);
-    support.append(QStringLiteral("KWIN_BUILD_ACTIVITIES (deprecated): "));
-    support.append(no);
-    support.append(QStringLiteral("HAVE_PERF: "));
-    support.append(HAVE_PERF ? yes : no);
-    support.append(QStringLiteral("HAVE_EPOXY_GLX: "));
-    support.append(HAVE_EPOXY_GLX ? yes : no);
-    support.append(QStringLiteral("\n"));
-
-    if (auto c = kwinApp()->x11Connection()) {
-        support.append(QStringLiteral("X11\n"));
-        support.append(QStringLiteral("===\n"));
-        auto x11setup = xcb_get_setup(c);
-        support.append(QStringLiteral("Vendor: %1\n")
-                           .arg(QString::fromUtf8(QByteArray::fromRawData(
-                               xcb_setup_vendor(x11setup), xcb_setup_vendor_length(x11setup)))));
-        support.append(QStringLiteral("Vendor Release: %1\n").arg(x11setup->release_number));
-        support.append(QStringLiteral("Protocol Version/Revision: %1/%2\n")
-                           .arg(x11setup->protocol_major_version)
-                           .arg(x11setup->protocol_minor_version));
-        auto const extensions = base::x11::xcb::extensions::self()->get_data();
-        for (const auto& e : extensions) {
-            support.append(QStringLiteral("%1: %2; Version: 0x%3\n")
-                               .arg(QString::fromUtf8(e.name))
-                               .arg(e.present ? yes.trimmed() : no.trimmed())
-                               .arg(QString::number(e.version, 16)));
-        }
-        support.append(QStringLiteral("\n"));
-    }
-
-    if (deco) {
-        support.append(QStringLiteral("Decoration\n"));
-        support.append(QStringLiteral("==========\n"));
-        support.append(deco->supportInformation());
-        support.append(QStringLiteral("\n"));
-    }
-
-    support.append(QStringLiteral("Options\n"));
-    support.append(QStringLiteral("=======\n"));
-
-    auto const metaOptions = kwinApp()->options->metaObject();
-    auto printProperty = [](const QVariant& variant) {
-        if (variant.type() == QVariant::Size) {
-            const QSize& s = variant.toSize();
-            return QStringLiteral("%1x%2")
-                .arg(QString::number(s.width()))
-                .arg(QString::number(s.height()));
-        }
-        if (QLatin1String(variant.typeName()) == QLatin1String("KWin::OpenGLPlatformInterface")
-            || QLatin1String(variant.typeName())
-                == QLatin1String("KWin::base::options::WindowOperation")) {
-            return QString::number(variant.toInt());
-        }
-        return variant.toString();
-    };
-    for (int i = 0; i < metaOptions->propertyCount(); ++i) {
-        const QMetaProperty property = metaOptions->property(i);
-        if (QLatin1String(property.name()) == QLatin1String("objectName")) {
-            continue;
-        }
-        support.append(QStringLiteral("%1: %2\n")
-                           .arg(property.name())
-                           .arg(printProperty(kwinApp()->options->property(property.name()))));
-    }
-
-    support.append(QStringLiteral("\nScreen Edges\n"));
-    support.append(QStringLiteral("============\n"));
-    auto const metaScreenEdges = edges->metaObject();
-    for (int i = 0; i < metaScreenEdges->propertyCount(); ++i) {
-        const QMetaProperty property = metaScreenEdges->property(i);
-        if (QLatin1String(property.name()) == QLatin1String("objectName")) {
-            continue;
-        }
-        support.append(QStringLiteral("%1: %2\n")
-                           .arg(property.name())
-                           .arg(printProperty(edges->property(property.name()))));
-    }
-    support.append(QStringLiteral("\nScreens\n"));
-    support.append(QStringLiteral("=======\n"));
-    support.append(QStringLiteral("Multi-Head: "));
-    support.append(QStringLiteral("not supported anymore\n"));
-    support.append(QStringLiteral("Active screen follows mouse: "));
-    support.append(kwinApp()->options->get_current_output_follows_mouse() ? yes : no);
-
-    auto const& outputs = kwinApp()->get_base().get_outputs();
-    support.append(QStringLiteral("Number of Screens: %1\n\n").arg(outputs.size()));
-    for (size_t i = 0; i < outputs.size(); ++i) {
-        auto const output = outputs.at(i);
-        auto const geo = output->geometry();
-        support.append(QStringLiteral("Screen %1:\n").arg(i));
-        support.append(QStringLiteral("---------\n"));
-        support.append(QStringLiteral("Name: %1\n").arg(output->name()));
-        support.append(QStringLiteral("Geometry: %1,%2,%3x%4\n")
-                           .arg(geo.x())
-                           .arg(geo.y())
-                           .arg(geo.width())
-                           .arg(geo.height()));
-        support.append(QStringLiteral("Scale: %1\n").arg(output->scale()));
-        support.append(QStringLiteral("Refresh Rate: %1\n\n").arg(output->refresh_rate()));
-    }
-
-    support.append(QStringLiteral("\nCompositing\n"));
-    support.append(QStringLiteral("===========\n"));
-    if (auto& effects = render.effects) {
-        support.append(QStringLiteral("Compositing is active\n"));
-        switch (effects->compositingType()) {
-        case OpenGLCompositing: {
-            GLPlatform* platform = GLPlatform::instance();
-            if (platform->isGLES()) {
-                support.append(QStringLiteral("Compositing Type: OpenGL ES 2.0\n"));
-            } else {
-                support.append(QStringLiteral("Compositing Type: OpenGL\n"));
-            }
-            support.append(QStringLiteral("OpenGL vendor string: ")
-                           + QString::fromUtf8(platform->glVendorString()) + QStringLiteral("\n"));
-            support.append(QStringLiteral("OpenGL renderer string: ")
-                           + QString::fromUtf8(platform->glRendererString())
-                           + QStringLiteral("\n"));
-            support.append(QStringLiteral("OpenGL version string: ")
-                           + QString::fromUtf8(platform->glVersionString()) + QStringLiteral("\n"));
-            support.append(QStringLiteral("OpenGL platform interface: "));
-            switch (platform->platformInterface()) {
-            case GlxPlatformInterface:
-                support.append(QStringLiteral("GLX"));
-                break;
-            case EglPlatformInterface:
-                support.append(QStringLiteral("EGL"));
-                break;
-            default:
-                support.append(QStringLiteral("UNKNOWN"));
-            }
-            support.append(QStringLiteral("\n"));
-
-            if (platform->supports(LimitedGLSL) || platform->supports(GLSL))
-                support.append(QStringLiteral("OpenGL shading language version string: ")
-                               + QString::fromUtf8(platform->glShadingLanguageVersionString())
-                               + QStringLiteral("\n"));
-
-            support.append(QStringLiteral("Driver: ")
-                           + GLPlatform::driverToString(platform->driver()) + QStringLiteral("\n"));
-            if (!platform->isMesaDriver())
-                support.append(QStringLiteral("Driver version: ")
-                               + GLPlatform::versionToString(platform->driverVersion())
-                               + QStringLiteral("\n"));
-
-            support.append(QStringLiteral("GPU class: ")
-                           + GLPlatform::chipClassToString(platform->chipClass())
-                           + QStringLiteral("\n"));
-
-            support.append(QStringLiteral("OpenGL version: ")
-                           + GLPlatform::versionToString(platform->glVersion())
-                           + QStringLiteral("\n"));
-
-            if (platform->supports(LimitedGLSL) || platform->supports(GLSL))
-                support.append(QStringLiteral("GLSL version: ")
-                               + GLPlatform::versionToString(platform->glslVersion())
-                               + QStringLiteral("\n"));
-
-            if (platform->isMesaDriver())
-                support.append(QStringLiteral("Mesa version: ")
-                               + GLPlatform::versionToString(platform->mesaVersion())
-                               + QStringLiteral("\n"));
-            if (platform->serverVersion() > 0)
-                support.append(QStringLiteral("X server version: ")
-                               + GLPlatform::versionToString(platform->serverVersion())
-                               + QStringLiteral("\n"));
-            if (platform->kernelVersion() > 0)
-                support.append(QStringLiteral("Linux kernel version: ")
-                               + GLPlatform::versionToString(platform->kernelVersion())
-                               + QStringLiteral("\n"));
-
-            support.append(QStringLiteral("Direct rendering: "));
-            support.append(QStringLiteral("Requires strict binding: "));
-            support.append(!platform->isLooseBinding() ? yes : no);
-            support.append(QStringLiteral("GLSL shaders: "));
-            if (platform->supports(GLSL)) {
-                support.append(platform->supports(LimitedGLSL) ? QStringLiteral("limited\n") : yes);
-            } else {
-                support.append(no);
-            }
-            support.append(QStringLiteral("Texture NPOT support: "));
-            if (platform->supports(TextureNPOT)) {
-                support.append(platform->supports(LimitedNPOT) ? QStringLiteral("limited\n") : yes);
-            } else {
-                support.append(no);
-            }
-            support.append(QStringLiteral("Virtual Machine: "));
-            support.append(platform->isVirtualMachine() ? yes : no);
-            support.append(QStringLiteral("Timer query support: "));
-            support.append(platform->supports(GLFeature::TimerQuery) ? yes : no);
-            support.append(QStringLiteral("OpenGL 2 Shaders are used\n"));
-            break;
-        }
-        case XRenderCompositing:
-            support.append(QStringLiteral("Compositing Type: XRender\n"));
-            break;
-        case QPainterCompositing:
-            support.append("Compositing Type: QPainter\n");
-            break;
-        case NoCompositing:
-        default:
-            support.append(
-                QStringLiteral("Something is really broken, neither OpenGL nor XRender is used"));
-        }
-        support.append(QStringLiteral("\nLoaded Effects:\n"));
-        support.append(QStringLiteral("---------------\n"));
-        auto const& loaded_effects = effects->loadedEffects();
-        for (auto const& effect : qAsConst(loaded_effects)) {
-            support.append(effect + QStringLiteral("\n"));
-        }
-        support.append(QStringLiteral("\nCurrently Active Effects:\n"));
-        support.append(QStringLiteral("-------------------------\n"));
-        auto const& active_effects = effects->activeEffects();
-        for (auto const& effect : qAsConst(active_effects)) {
-            support.append(effect + QStringLiteral("\n"));
-        }
-        support.append(QStringLiteral("\nEffect Settings:\n"));
-        support.append(QStringLiteral("----------------\n"));
-        for (auto const& effect : qAsConst(loaded_effects)) {
-            support.append(effects->supportInformation(effect));
-            support.append(QStringLiteral("\n"));
-        }
-    } else {
-        support.append(QStringLiteral("Compositing is not active\n"));
-    }
-    return support;
-}
-
 bool space::compositing() const
 {
     return static_cast<bool>(render.scene);
diff --git a/win/space.h b/win/space.h
index 2309fe8e2..b8d591d20 100644
--- a/win/space.h
+++ b/win/space.h
@@ -353,9 +353,6 @@ public:
 
     win::session_info* takeSessionInfo(win::x11::window*);
 
-    // D-Bus interface
-    QString supportInformation() const;
-
     void setCurrentScreen(base::output const& output);
 
     void setShowingDesktop(bool showing);
-- 
GitLab


From 37dd1752247e10fed16a73ca4ceb3747d4276786 Mon Sep 17 00:00:00 2001
From: Roman Gilg <subdiff@gmail.com>
Date: Mon, 4 Jul 2022 14:37:23 +0200
Subject: [PATCH 02/51] refactor: move tool windows functionality out of space

Put the functionality into free function templates instead.
---
 win/space.cpp          | 17 +----------------
 win/space.h            |  9 ++-------
 win/x11/hide.h         |  5 +++--
 win/x11/tool_windows.h | 17 +++++++++++++++++
 win/x11/transient.h    |  3 ++-
 5 files changed, 25 insertions(+), 26 deletions(-)
 create mode 100644 win/x11/tool_windows.h

diff --git a/win/space.cpp b/win/space.cpp
index c7e6bb74d..9e36eb074 100644
--- a/win/space.cpp
+++ b/win/space.cpp
@@ -218,7 +218,7 @@ space::space(render::compositor& render)
     QObject::connect(
         &reconfigureTimer, &QTimer::timeout, qobject.get(), [this] { slotReconfigure(); });
     QObject::connect(&updateToolWindowsTimer, &QTimer::timeout, qobject.get(), [this] {
-        slotUpdateToolWindows();
+        x11::update_tool_windows_visibility(this, true);
     });
 
     // TODO: do we really need to reconfigure everything when fonts change?
@@ -285,21 +285,6 @@ space::~space()
     singleton_interface::space = nullptr;
 }
 
-void space::stopUpdateToolWindowsTimer()
-{
-    updateToolWindowsTimer.stop();
-}
-
-void space::resetUpdateToolWindowsTimer()
-{
-    updateToolWindowsTimer.start(200);
-}
-
-void space::slotUpdateToolWindows()
-{
-    x11::update_tool_windows_visibility(this, true);
-}
-
 void space::reconfigure()
 {
     reconfigureTimer.start(200);
diff --git a/win/space.h b/win/space.h
index b8d591d20..3313820b0 100644
--- a/win/space.h
+++ b/win/space.h
@@ -211,6 +211,8 @@ public:
 
     QPoint focusMousePos;
 
+    QTimer updateToolWindowsTimer;
+
     explicit space(render::compositor& render);
     virtual ~space();
 
@@ -292,9 +294,6 @@ public:
     std::unique_ptr<base::dbus::kwin_impl<space>> dbus;
     std::unique_ptr<win::session_manager> session_manager;
 
-    void stopUpdateToolWindowsTimer();
-    void resetUpdateToolWindowsTimer();
-
     void clientHidden(Toplevel* window);
     void clientAttentionChanged(Toplevel* window, bool set);
 
@@ -481,8 +480,6 @@ protected:
                                                 std::vector<QRect> const& screens_geos,
                                                 win::space_areas& areas);
 
-    void slotUpdateToolWindows();
-
 private:
     void delayFocus();
 
@@ -544,8 +541,6 @@ private:
     // Timer to collect requests for 'reconfigure'
     QTimer reconfigureTimer;
 
-    QTimer updateToolWindowsTimer;
-
     win::space_areas areas;
 
     // Array of the previous restricted areas that window cannot be moved into
diff --git a/win/x11/hide.h b/win/x11/hide.h
index 9d61bdfc6..61c42bd8a 100644
--- a/win/x11/hide.h
+++ b/win/x11/hide.h
@@ -7,6 +7,7 @@
 
 #include "client.h"
 #include "input.h"
+#include "tool_windows.h"
 #include "window.h"
 
 #include "base/options.h"
@@ -304,11 +305,11 @@ void update_tool_windows_visibility(Space* space, bool also_hide)
         for (auto const& window : to_hide) {
             window->hideClient(true);
         }
-        space->stopUpdateToolWindowsTimer();
+        space->updateToolWindowsTimer.stop();
     } else {
         // Workspace::setActiveClient(..) is afterwards called with NULL client, quickly followed
         // by setting a new client, which would result in flickering.
-        space->resetUpdateToolWindowsTimer();
+        reset_update_tool_windows_timer(*space);
     }
 }
 
diff --git a/win/x11/tool_windows.h b/win/x11/tool_windows.h
new file mode 100644
index 000000000..c3e82e462
--- /dev/null
+++ b/win/x11/tool_windows.h
@@ -0,0 +1,17 @@
+/*
+    SPDX-FileCopyrightText: 2022 Roman Gilg <subdiff@gmail.com>
+
+    SPDX-License-Identifier: GPL-2.0-or-later
+*/
+#pragma once
+
+namespace KWin::win::x11
+{
+
+template<typename Space>
+void reset_update_tool_windows_timer(Space& space)
+{
+    space.updateToolWindowsTimer.start(200);
+}
+
+}
diff --git a/win/x11/transient.h b/win/x11/transient.h
index 1137dbccc..8c485ce0d 100644
--- a/win/x11/transient.h
+++ b/win/x11/transient.h
@@ -5,6 +5,7 @@
 */
 #pragma once
 
+#include "tool_windows.h"
 #include "window.h"
 #include "window_find.h"
 
@@ -150,7 +151,7 @@ void set_transient_lead(Win* win, xcb_window_t lead_id)
 
     check_group(win, nullptr);
     update_layer(win);
-    win->space.resetUpdateToolWindowsTimer();
+    reset_update_tool_windows_timer(win->space);
 }
 
 template<typename Win>
-- 
GitLab


From a1da9d1533b8f72a90a6f5344c6a78d4221a6e7b Mon Sep 17 00:00:00 2001
From: Roman Gilg <subdiff@gmail.com>
Date: Mon, 4 Jul 2022 16:45:03 +0200
Subject: [PATCH 03/51] style: move tool windows functions together

Move the update_tool_windows_visibility function to the tool windows header to
have it in the same place as other functions about tool windows and reduce the
size of the often included hide header.
---
 win/space.cpp          |   1 +
 win/x11/hide.h         |  98 --------------------------------------
 win/x11/tool_windows.h | 104 +++++++++++++++++++++++++++++++++++++++++
 3 files changed, 105 insertions(+), 98 deletions(-)

diff --git a/win/space.cpp b/win/space.cpp
index 9e36eb074..885e85abb 100644
--- a/win/space.cpp
+++ b/win/space.cpp
@@ -23,6 +23,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
 #include "deco/bridge.h"
 #include "singleton_interface.h"
+#include "x11/tool_windows.h"
 
 #include "base/dbus/kwin.h"
 #include "base/output_helpers.h"
diff --git a/win/x11/hide.h b/win/x11/hide.h
index 61c42bd8a..d863fcb20 100644
--- a/win/x11/hide.h
+++ b/win/x11/hide.h
@@ -7,7 +7,6 @@
 
 #include "client.h"
 #include "input.h"
-#include "tool_windows.h"
 #include "window.h"
 
 #include "base/options.h"
@@ -216,101 +215,4 @@ void update_visibility(Win* win)
     internal_show(win);
 }
 
-/**
- * Relevant for windows of type NET::Utility, NET::Menu or NET::Toolbar.
- */
-template<typename Space>
-void update_tool_windows_visibility(Space* space, bool also_hide)
-{
-    if (!kwinApp()->options->isHideUtilityWindowsForInactive()) {
-        for (auto const& window : space->m_windows) {
-            if (window->control) {
-                window->hideClient(false);
-            }
-        }
-        return;
-    }
-
-    x11::group const* active_group = nullptr;
-    auto active_window = space->active_client;
-
-    // Go up in transiency hiearchy, if the top is found, only tool transients for the top
-    // window will be shown; if a group transient is group, all tools in the group will be shown.
-    while (active_window) {
-        if (!active_window->transient()->lead()) {
-            break;
-        }
-        if (active_window->groupTransient()) {
-            active_group = active_window->group();
-            break;
-        }
-        active_window = active_window->transient()->lead();
-    }
-
-    // Use stacking order only to reduce flicker, it doesn't matter if block_stacking_updates == 0,
-    // i.e. if it's not up to date.
-
-    // TODO(SELI): But maybe it should - what if a new window has been added that's not in stacking
-    // order yet?
-    std::vector<Toplevel*> to_show;
-    std::vector<Toplevel*> to_hide;
-
-    for (auto const& window : space->stacking_order->stack) {
-        if (!window->control) {
-            continue;
-        }
-
-        if (!is_utility(window) && !is_menu(window) && !is_toolbar(window)) {
-            continue;
-        }
-
-        auto show{true};
-
-        if (window->transient()->lead()) {
-            auto const in_active_group = active_group && window->group() == active_group;
-            auto const has_active_lead
-                = active_window && window->transient()->is_follower_of(active_window);
-            show = in_active_group || has_active_lead;
-        } else {
-            auto const is_individual = !window->group() || window->group()->members.size() == 1;
-            auto const in_active_group = active_window && active_window->group() == window->group();
-            show = is_individual || in_active_group;
-        }
-
-        if (!show && also_hide) {
-            auto const& leads = window->transient()->leads();
-            // Don't hide utility windows which are standalone(?) or have e.g. kicker as lead.
-            show = leads.empty()
-                || std::any_of(leads.cbegin(), leads.cend(), is_special_window<Toplevel>);
-            if (!show) {
-                to_hide.push_back(window);
-            }
-        }
-
-        if (show) {
-            to_show.push_back(window);
-        }
-    }
-
-    // First show new ones, then hide.
-    // Show from topmost.
-    for (int i = to_show.size() - 1; i >= 0; --i) {
-        // TODO(unknown author): Since this is in stacking order, the order of taskbar entries
-        //                       changes :(
-        to_show.at(i)->hideClient(false);
-    }
-
-    if (also_hide) {
-        // Hide from bottom-most.
-        for (auto const& window : to_hide) {
-            window->hideClient(true);
-        }
-        space->updateToolWindowsTimer.stop();
-    } else {
-        // Workspace::setActiveClient(..) is afterwards called with NULL client, quickly followed
-        // by setting a new client, which would result in flickering.
-        reset_update_tool_windows_timer(*space);
-    }
-}
-
 }
diff --git a/win/x11/tool_windows.h b/win/x11/tool_windows.h
index c3e82e462..f8df76a18 100644
--- a/win/x11/tool_windows.h
+++ b/win/x11/tool_windows.h
@@ -5,6 +5,13 @@
 */
 #pragma once
 
+#include "group.h"
+
+#include "base/options.h"
+#include "main.h"
+#include "toplevel.h"
+#include "win/meta.h"
+
 namespace KWin::win::x11
 {
 
@@ -14,4 +21,101 @@ void reset_update_tool_windows_timer(Space& space)
     space.updateToolWindowsTimer.start(200);
 }
 
+/**
+ * Relevant for windows of type NET::Utility, NET::Menu or NET::Toolbar.
+ */
+template<typename Space>
+void update_tool_windows_visibility(Space* space, bool also_hide)
+{
+    if (!kwinApp()->options->isHideUtilityWindowsForInactive()) {
+        for (auto const& window : space->m_windows) {
+            if (window->control) {
+                window->hideClient(false);
+            }
+        }
+        return;
+    }
+
+    x11::group const* active_group = nullptr;
+    auto active_window = space->active_client;
+
+    // Go up in transiency hiearchy, if the top is found, only tool transients for the top
+    // window will be shown; if a group transient is group, all tools in the group will be shown.
+    while (active_window) {
+        if (!active_window->transient()->lead()) {
+            break;
+        }
+        if (active_window->groupTransient()) {
+            active_group = active_window->group();
+            break;
+        }
+        active_window = active_window->transient()->lead();
+    }
+
+    // Use stacking order only to reduce flicker, it doesn't matter if block_stacking_updates == 0,
+    // i.e. if it's not up to date.
+
+    // TODO(SELI): But maybe it should - what if a new window has been added that's not in stacking
+    // order yet?
+    std::vector<Toplevel*> to_show;
+    std::vector<Toplevel*> to_hide;
+
+    for (auto const& window : space->stacking_order->stack) {
+        if (!window->control) {
+            continue;
+        }
+
+        if (!is_utility(window) && !is_menu(window) && !is_toolbar(window)) {
+            continue;
+        }
+
+        auto show{true};
+
+        if (window->transient()->lead()) {
+            auto const in_active_group = active_group && window->group() == active_group;
+            auto const has_active_lead
+                = active_window && window->transient()->is_follower_of(active_window);
+            show = in_active_group || has_active_lead;
+        } else {
+            auto const is_individual = !window->group() || window->group()->members.size() == 1;
+            auto const in_active_group = active_window && active_window->group() == window->group();
+            show = is_individual || in_active_group;
+        }
+
+        if (!show && also_hide) {
+            auto const& leads = window->transient()->leads();
+            // Don't hide utility windows which are standalone(?) or have e.g. kicker as lead.
+            show = leads.empty()
+                || std::any_of(leads.cbegin(), leads.cend(), is_special_window<Toplevel>);
+            if (!show) {
+                to_hide.push_back(window);
+            }
+        }
+
+        if (show) {
+            to_show.push_back(window);
+        }
+    }
+
+    // First show new ones, then hide.
+    // Show from topmost.
+    for (int i = to_show.size() - 1; i >= 0; --i) {
+        // TODO(unknown author): Since this is in stacking order, the order of taskbar entries
+        //                       changes :(
+        to_show.at(i)->hideClient(false);
+    }
+
+    if (also_hide) {
+        // Hide from bottom-most.
+        for (auto const& window : to_hide) {
+            window->hideClient(true);
+        }
+        space->updateToolWindowsTimer.stop();
+    } else {
+        // Workspace::setActiveClient(..) is afterwards called with NULL client, quickly followed
+        // by setting a new client, which would result in flickering.
+        reset_update_tool_windows_timer(*space);
+    }
+}
+
 }
-- 
GitLab


From 85df62983c72bb9cb6a5fecd56d19d02a23a6b0a Mon Sep 17 00:00:00 2001
From: Roman Gilg <subdiff@gmail.com>
Date: Mon, 4 Jul 2022 14:58:46 +0200
Subject: [PATCH 04/51] refactor: configure space from free functions

Move reconfigure logic out of space into free function templates.
---
 .../integration/decoration_input_test.cpp     |  12 +-
 .../dont_crash_aurorae_destroy_deco.cpp       |   3 +-
 autotests/integration/internal_window.cpp     |   5 +-
 autotests/integration/maximize_test.cpp       |  12 +-
 .../modifier_only_shortcut_test.cpp           |  11 +-
 .../integration/no_global_shortcuts_test.cpp  |   3 +-
 autotests/integration/placement_test.cpp      |   9 +-
 .../integration/pointer_constraints_test.cpp  |   3 +-
 autotests/integration/pointer_input.cpp       |  28 ++--
 .../integration/scene_opengl_shadow_test.cpp  |   3 +-
 .../scene_qpainter_shadow_test.cpp            |   3 +-
 .../integration/scripting/screenedge_test.cpp |   3 +-
 autotests/integration/struts_test.cpp         |   3 +-
 autotests/integration/window_rules_test.cpp   |   3 +-
 .../integration/xdgshellclient_rules_test.cpp | 149 +++++++++---------
 win/space.cpp                                 |  52 +-----
 win/space.h                                   |   9 +-
 win/space_reconfigure.h                       |  58 +++++++
 18 files changed, 196 insertions(+), 173 deletions(-)
 create mode 100644 win/space_reconfigure.h

diff --git a/autotests/integration/decoration_input_test.cpp b/autotests/integration/decoration_input_test.cpp
index 5f71416e7..5986e2b2e 100644
--- a/autotests/integration/decoration_input_test.cpp
+++ b/autotests/integration/decoration_input_test.cpp
@@ -24,15 +24,15 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "input/pointer_redirect.h"
 #include "input/touch_redirect.h"
 #include "toplevel.h"
-#include "win/screen_edges.h"
-#include "win/space.h"
-
 #include "win/deco.h"
 #include "win/deco/bridge.h"
 #include "win/deco/client_impl.h"
 #include "win/deco/settings.h"
 #include "win/internal_window.h"
 #include "win/move.h"
+#include "win/screen_edges.h"
+#include "win/space.h"
+#include "win/space_reconfigure.h"
 #include "win/wayland/window.h"
 
 #include <Wrapland/Client/compositor.h>
@@ -559,7 +559,7 @@ void DecorationInputTest::testResizeOutsideWindow()
         ->group("org.kde.kdecoration2")
         .writeEntry("BorderSize", QStringLiteral("None"));
     kwinApp()->config()->sync();
-    Test::app()->workspace->slotReconfigure();
+    win::space_reconfigure(*Test::app()->workspace);
 
     // now create window
     auto c = showWindow();
@@ -659,7 +659,7 @@ void DecorationInputTest::testModifierClickUnrestrictedMove()
     group.writeEntry("CommandAll2", "Move");
     group.writeEntry("CommandAll3", "Move");
     group.sync();
-    Test::app()->workspace->slotReconfigure();
+    win::space_reconfigure(*Test::app()->workspace);
     QCOMPARE(kwinApp()->options->commandAllModifier(),
              modKey == QStringLiteral("Alt") ? Qt::AltModifier : Qt::MetaModifier);
     QCOMPARE(kwinApp()->options->commandAll1(), base::options::MouseUnrestrictedMove);
@@ -731,7 +731,7 @@ void DecorationInputTest::testModifierScrollOpacity()
     group.writeEntry("CommandAllKey", modKey);
     group.writeEntry("CommandAllWheel", "change opacity");
     group.sync();
-    Test::app()->workspace->slotReconfigure();
+    win::space_reconfigure(*Test::app()->workspace);
 
     auto c = showWindow();
     QVERIFY(c);
diff --git a/autotests/integration/dont_crash_aurorae_destroy_deco.cpp b/autotests/integration/dont_crash_aurorae_destroy_deco.cpp
index 3b4c7b1cb..1b9f24646 100644
--- a/autotests/integration/dont_crash_aurorae_destroy_deco.cpp
+++ b/autotests/integration/dont_crash_aurorae_destroy_deco.cpp
@@ -26,6 +26,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "win/deco.h"
 #include "win/screen_edges.h"
 #include "win/space.h"
+#include "win/space_reconfigure.h"
 #include "win/wayland/window.h"
 #include "win/x11/window.h"
 
@@ -91,7 +92,7 @@ void DontCrashAuroraeDestroyDecoTest::testBorderlessMaximizedWindows()
     KConfigGroup group = kwinApp()->config()->group("Windows");
     group.writeEntry("BorderlessMaximizedWindows", true);
     group.sync();
-    Test::app()->workspace->slotReconfigure();
+    win::space_reconfigure(*Test::app()->workspace);
     QCOMPARE(kwinApp()->options->borderlessMaximizedWindows(), true);
 
     // create an xcb window
diff --git a/autotests/integration/internal_window.cpp b/autotests/integration/internal_window.cpp
index 28018a376..33d8c750b 100644
--- a/autotests/integration/internal_window.cpp
+++ b/autotests/integration/internal_window.cpp
@@ -27,6 +27,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "win/move.h"
 #include "win/net.h"
 #include "win/space.h"
+#include "win/space_reconfigure.h"
 
 #include <QPainter>
 #include <QRasterWindow>
@@ -618,7 +619,7 @@ void InternalWindowTest::testModifierClickUnrestrictedMove()
     group.writeEntry("CommandAll2", "Move");
     group.writeEntry("CommandAll3", "Move");
     group.sync();
-    Test::app()->workspace->slotReconfigure();
+    win::space_reconfigure(*Test::app()->workspace);
     QCOMPARE(kwinApp()->options->commandAllModifier(), Qt::MetaModifier);
     QCOMPARE(kwinApp()->options->commandAll1(), base::options::MouseUnrestrictedMove);
     QCOMPARE(kwinApp()->options->commandAll2(), base::options::MouseUnrestrictedMove);
@@ -659,7 +660,7 @@ void InternalWindowTest::testModifierScroll()
     group.writeEntry("CommandAllKey", "Meta");
     group.writeEntry("CommandAllWheel", "change opacity");
     group.sync();
-    Test::app()->workspace->slotReconfigure();
+    win::space_reconfigure(*Test::app()->workspace);
 
     // move cursor on window
     input::get_cursor()->set_pos(internalClient->frameGeometry().center());
diff --git a/autotests/integration/maximize_test.cpp b/autotests/integration/maximize_test.cpp
index db7767a74..bc7e70335 100644
--- a/autotests/integration/maximize_test.cpp
+++ b/autotests/integration/maximize_test.cpp
@@ -21,11 +21,11 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
 #include "base/wayland/server.h"
 #include "input/cursor.h"
+#include "win/deco.h"
 #include "win/deco/bridge.h"
 #include "win/deco/settings.h"
 #include "win/space.h"
-
-#include "win/deco.h"
+#include "win/space_reconfigure.h"
 #include "win/wayland/window.h"
 
 #include <Wrapland/Client/compositor.h>
@@ -91,7 +91,7 @@ void TestMaximized::cleanup()
     auto group = kwinApp()->config()->group("Windows");
     group.writeEntry("BorderlessMaximizedWindows", false);
     group.sync();
-    Test::app()->workspace->slotReconfigure();
+    win::space_reconfigure(*Test::app()->workspace);
     QCOMPARE(kwinApp()->options->borderlessMaximizedWindows(), false);
 }
 
@@ -222,7 +222,7 @@ void TestMaximized::testInitiallyMaximizedBorderless()
     auto group = kwinApp()->config()->group("Windows");
     group.writeEntry("BorderlessMaximizedWindows", true);
     group.sync();
-    Test::app()->workspace->slotReconfigure();
+    win::space_reconfigure(*Test::app()->workspace);
     QCOMPARE(kwinApp()->options->borderlessMaximizedWindows(), true);
 
     // Create the test client.
@@ -276,7 +276,7 @@ void TestMaximized::testBorderlessMaximizedWindow()
     auto group = kwinApp()->config()->group("Windows");
     group.writeEntry("BorderlessMaximizedWindows", true);
     group.sync();
-    Test::app()->workspace->slotReconfigure();
+    win::space_reconfigure(*Test::app()->workspace);
     QCOMPARE(kwinApp()->options->borderlessMaximizedWindows(), true);
 
     // Create the test client.
@@ -368,7 +368,7 @@ void TestMaximized::testBorderlessMaximizedWindowNoClientSideDecoration()
     auto group = kwinApp()->config()->group("Windows");
     group.writeEntry("BorderlessMaximizedWindows", true);
     group.sync();
-    Test::app()->workspace->slotReconfigure();
+    win::space_reconfigure(*Test::app()->workspace);
     QCOMPARE(kwinApp()->options->borderlessMaximizedWindows(), true);
 
     std::unique_ptr<Surface> surface(Test::create_surface());
diff --git a/autotests/integration/modifier_only_shortcut_test.cpp b/autotests/integration/modifier_only_shortcut_test.cpp
index 85b0d731e..e214087dc 100644
--- a/autotests/integration/modifier_only_shortcut_test.cpp
+++ b/autotests/integration/modifier_only_shortcut_test.cpp
@@ -24,6 +24,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "input/keyboard_redirect.h"
 #include "input/xkb/helpers.h"
 #include "win/space.h"
+#include "win/space_reconfigure.h"
 
 #include <KConfigGroup>
 
@@ -195,7 +196,7 @@ void ModifierOnlyShortcutTest::testTrigger()
     group.writeEntry("Shift", shiftConfig);
     group.writeEntry("Control", controlConfig);
     group.sync();
-    Test::app()->workspace->slotReconfigure();
+    win::space_reconfigure(*Test::app()->workspace);
 
     // configured shortcut should trigger
     quint32 timestamp = 1;
@@ -315,7 +316,7 @@ void ModifierOnlyShortcutTest::testCapsLock()
                      QStringList{s_serviceName, s_path, s_serviceName, QStringLiteral("shortcut")});
     group.writeEntry("Control", QStringList());
     group.sync();
-    Test::app()->workspace->slotReconfigure();
+    win::space_reconfigure(*Test::app()->workspace);
 
     // first test that the normal shortcut triggers
     quint32 timestamp = 1;
@@ -344,7 +345,7 @@ void ModifierOnlyShortcutTest::testCapsLock()
     group.writeEntry("Shift", QStringList{});
     group.writeEntry("Control", QStringList());
     group.sync();
-    Test::app()->workspace->slotReconfigure();
+    win::space_reconfigure(*Test::app()->workspace);
 
     Test::keyboard_key_pressed(KEY_LEFTMETA, timestamp++);
     QTRY_COMPARE(input::xkb::get_active_keyboard_modifiers(kwinApp()->input),
@@ -363,7 +364,7 @@ void ModifierOnlyShortcutTest::testCapsLock()
                      QStringList{s_serviceName, s_path, s_serviceName, QStringLiteral("shortcut")});
     group.writeEntry("Control", QStringList());
     group.sync();
-    Test::app()->workspace->slotReconfigure();
+    win::space_reconfigure(*Test::app()->workspace);
 
     // release caps lock
     Test::keyboard_key_pressed(KEY_CAPSLOCK, timestamp++);
@@ -412,7 +413,7 @@ void ModifierOnlyShortcutTest::testGlobalShortcutsDisabled()
     group.writeEntry("Shift", shiftConfig);
     group.writeEntry("Control", controlConfig);
     group.sync();
-    Test::app()->workspace->slotReconfigure();
+    win::space_reconfigure(*Test::app()->workspace);
 
     // trigger once to verify the shortcut works
     quint32 timestamp = 1;
diff --git a/autotests/integration/no_global_shortcuts_test.cpp b/autotests/integration/no_global_shortcuts_test.cpp
index 58a29bf4f..7f20f55ce 100644
--- a/autotests/integration/no_global_shortcuts_test.cpp
+++ b/autotests/integration/no_global_shortcuts_test.cpp
@@ -25,6 +25,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "input/xkb/helpers.h"
 #include "win/screen_edges.h"
 #include "win/space.h"
+#include "win/space_reconfigure.h"
 
 #include <KConfigGroup>
 #include <KGlobalAccel>
@@ -204,7 +205,7 @@ void NoGlobalShortcutsTest::testTrigger()
     group.writeEntry("Shift", shiftConfig);
     group.writeEntry("Control", controlConfig);
     group.sync();
-    Test::app()->workspace->slotReconfigure();
+    win::space_reconfigure(*Test::app()->workspace);
 
     // configured shortcut should trigger
     quint32 timestamp = 1;
diff --git a/autotests/integration/placement_test.cpp b/autotests/integration/placement_test.cpp
index 75db806f5..0ea119641 100644
--- a/autotests/integration/placement_test.cpp
+++ b/autotests/integration/placement_test.cpp
@@ -24,6 +24,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "input/cursor.h"
 #include "win/placement.h"
 #include "win/space.h"
+#include "win/space_reconfigure.h"
 #include "win/wayland/space.h"
 #include "win/wayland/window.h"
 
@@ -123,7 +124,7 @@ void TestPlacement::setPlacementPolicy(win::placement policy)
     auto group = kwinApp()->config()->group("Windows");
     group.writeEntry("Placement", policy_to_string(policy));
     group.sync();
-    Test::app()->workspace->slotReconfigure();
+    win::space_reconfigure(*Test::app()->workspace);
 }
 
 PlaceWindowResult TestPlacement::createAndPlaceWindow(QSize const& defaultSize)
@@ -272,7 +273,7 @@ void TestPlacement::testPlaceCentered()
     KConfigGroup group = kwinApp()->config()->group("Windows");
     group.writeEntry("Placement", policy_to_string(win::placement::centered));
     group.sync();
-    Test::app()->workspace->slotReconfigure();
+    win::space_reconfigure(*Test::app()->workspace);
 
     std::unique_ptr<Surface> surface(Test::create_surface());
     std::unique_ptr<XdgShellToplevel> shellSurface(Test::create_xdg_shell_toplevel(surface));
@@ -291,7 +292,7 @@ void TestPlacement::testPlaceUnderMouse()
     KConfigGroup group = kwinApp()->config()->group("Windows");
     group.writeEntry("Placement", policy_to_string(win::placement::under_mouse));
     group.sync();
-    Test::app()->workspace->slotReconfigure();
+    win::space_reconfigure(*Test::app()->workspace);
 
     input::get_cursor()->set_pos(QPoint(200, 300));
     QCOMPARE(input::get_cursor()->pos(), QPoint(200, 300));
@@ -313,7 +314,7 @@ void TestPlacement::testPlaceRandom()
     KConfigGroup group = kwinApp()->config()->group("Windows");
     group.writeEntry("Placement", policy_to_string(win::placement::random));
     group.sync();
-    Test::app()->workspace->slotReconfigure();
+    win::space_reconfigure(*Test::app()->workspace);
 
     std::unique_ptr<Surface> surface1(Test::create_surface());
     std::unique_ptr<XdgShellToplevel> shellSurface1(Test::create_xdg_shell_toplevel(surface1));
diff --git a/autotests/integration/pointer_constraints_test.cpp b/autotests/integration/pointer_constraints_test.cpp
index c6088b3a6..275a45fa3 100644
--- a/autotests/integration/pointer_constraints_test.cpp
+++ b/autotests/integration/pointer_constraints_test.cpp
@@ -26,6 +26,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "input/redirect.h"
 #include "win/move.h"
 #include "win/space.h"
+#include "win/space_reconfigure.h"
 
 #include <Wrapland/Client/compositor.h>
 #include <Wrapland/Client/keyboard.h>
@@ -181,7 +182,7 @@ void TestPointerConstraints::testConfinedPointer()
     group.writeEntry("CommandAll3", "Move");
     group.writeEntry("CommandAllWheel", "change opacity");
     group.sync();
-    Test::app()->workspace->slotReconfigure();
+    win::space_reconfigure(*Test::app()->workspace);
     QCOMPARE(kwinApp()->options->commandAllModifier(), Qt::MetaModifier);
     QCOMPARE(kwinApp()->options->commandAll1(), base::options::MouseUnrestrictedMove);
     QCOMPARE(kwinApp()->options->commandAll2(), base::options::MouseUnrestrictedMove);
diff --git a/autotests/integration/pointer_input.cpp b/autotests/integration/pointer_input.cpp
index 2fde6cde4..3a5cab1ca 100644
--- a/autotests/integration/pointer_input.cpp
+++ b/autotests/integration/pointer_input.cpp
@@ -26,13 +26,13 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "input/wayland/cursor_theme.h"
 #include "render/effects.h"
 #include "toplevel.h"
-#include "win/space.h"
-#include "win/stacking_order.h"
-#include "win/transient.h"
-
 #include "win/move.h"
 #include "win/screen_edges.h"
+#include "win/space.h"
+#include "win/space_reconfigure.h"
 #include "win/stacking.h"
+#include "win/stacking_order.h"
+#include "win/transient.h"
 #include "win/wayland/space.h"
 #include "win/wayland/window.h"
 
@@ -444,7 +444,7 @@ void PointerInputTest::testModifierClickUnrestrictedMove()
     group.writeEntry("CommandAll2", "Move");
     group.writeEntry("CommandAll3", "Move");
     group.sync();
-    Test::app()->workspace->slotReconfigure();
+    win::space_reconfigure(*Test::app()->workspace);
     QCOMPARE(kwinApp()->options->commandAllModifier(),
              modKey == QStringLiteral("Alt") ? Qt::AltModifier : Qt::MetaModifier);
     QCOMPARE(kwinApp()->options->commandAll1(), base::options::MouseUnrestrictedMove);
@@ -513,7 +513,7 @@ void PointerInputTest::testModifierClickUnrestrictedMoveGlobalShortcutsDisabled(
     group.writeEntry("CommandAll2", "Move");
     group.writeEntry("CommandAll3", "Move");
     group.sync();
-    Test::app()->workspace->slotReconfigure();
+    win::space_reconfigure(*Test::app()->workspace);
     QCOMPARE(kwinApp()->options->commandAllModifier(), Qt::MetaModifier);
     QCOMPARE(kwinApp()->options->commandAll1(), base::options::MouseUnrestrictedMove);
     QCOMPARE(kwinApp()->options->commandAll2(), base::options::MouseUnrestrictedMove);
@@ -591,7 +591,7 @@ void PointerInputTest::testModifierScrollOpacity()
     group.writeEntry("CommandAllKey", modKey);
     group.writeEntry("CommandAllWheel", "change opacity");
     group.sync();
-    Test::app()->workspace->slotReconfigure();
+    win::space_reconfigure(*Test::app()->workspace);
 
     // create a window
     QSignalSpy clientAddedSpy(Test::app()->workspace->qobject.get(),
@@ -651,7 +651,7 @@ void PointerInputTest::testModifierScrollOpacityGlobalShortcutsDisabled()
     group.writeEntry("CommandAllKey", "Meta");
     group.writeEntry("CommandAllWheel", "change opacity");
     group.sync();
-    Test::app()->workspace->slotReconfigure();
+    win::space_reconfigure(*Test::app()->workspace);
 
     // create a window
     QSignalSpy clientAddedSpy(Test::app()->workspace->qobject.get(),
@@ -703,7 +703,7 @@ void PointerInputTest::testScrollAction()
     KConfigGroup group = kwinApp()->config()->group("MouseBindings");
     group.writeEntry("CommandWindowWheel", "activate and scroll");
     group.sync();
-    Test::app()->workspace->slotReconfigure();
+    win::space_reconfigure(*Test::app()->workspace);
     // create two windows
     QSignalSpy clientAddedSpy(Test::app()->workspace->qobject.get(),
                               &win::space::qobject_t::wayland_window_added);
@@ -758,7 +758,7 @@ void PointerInputTest::testFocusFollowsMouse()
     group.writeEntry("DelayFocusInterval", 200);
     group.writeEntry("FocusPolicy", "FocusFollowsMouse");
     group.sync();
-    Test::app()->workspace->slotReconfigure();
+    win::space_reconfigure(*Test::app()->workspace);
     // verify the settings
     QCOMPARE(kwinApp()->options->focusPolicy(), base::options::FocusFollowsMouse);
     QVERIFY(kwinApp()->options->isAutoRaise());
@@ -852,7 +852,7 @@ void PointerInputTest::testMouseActionInactiveWindow()
     group.writeEntry("CommandWindow2", "Activate, raise and pass click");
     group.writeEntry("CommandWindow3", "Activate, raise and pass click");
     group.sync();
-    Test::app()->workspace->slotReconfigure();
+    win::space_reconfigure(*Test::app()->workspace);
 
     // Create two windows.
     QSignalSpy clientAddedSpy(Test::app()->workspace->qobject.get(),
@@ -953,7 +953,7 @@ void PointerInputTest::testMouseActionActiveWindow()
     KConfigGroup group = kwinApp()->config()->group("Windows");
     group.writeEntry("ClickRaise", clickRaise);
     group.sync();
-    Test::app()->workspace->slotReconfigure();
+    win::space_reconfigure(*Test::app()->workspace);
     QCOMPARE(kwinApp()->options->isClickRaise(), clickRaise);
 
     // Create two windows.
@@ -1649,7 +1649,7 @@ void PointerInputTest::testResizeCursor()
     group.writeEntry("CommandAllKey", "Meta");
     group.writeEntry("CommandAll3", "Resize");
     group.sync();
-    Test::app()->workspace->slotReconfigure();
+    win::space_reconfigure(*Test::app()->workspace);
     QCOMPARE(kwinApp()->options->commandAllModifier(), Qt::MetaModifier);
     QCOMPARE(kwinApp()->options->commandAll3(), base::options::MouseUnrestrictedResize);
 
@@ -1719,7 +1719,7 @@ void PointerInputTest::testMoveCursor()
     group.writeEntry("CommandAllKey", "Meta");
     group.writeEntry("CommandAll1", "Move");
     group.sync();
-    Test::app()->workspace->slotReconfigure();
+    win::space_reconfigure(*Test::app()->workspace);
     QCOMPARE(kwinApp()->options->commandAllModifier(), Qt::MetaModifier);
     QCOMPARE(kwinApp()->options->commandAll1(), base::options::MouseUnrestrictedMove);
 
diff --git a/autotests/integration/scene_opengl_shadow_test.cpp b/autotests/integration/scene_opengl_shadow_test.cpp
index 333d94b5b..bc0ff440e 100644
--- a/autotests/integration/scene_opengl_shadow_test.cpp
+++ b/autotests/integration/scene_opengl_shadow_test.cpp
@@ -27,6 +27,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "render/window.h"
 #include "win/deco.h"
 #include "win/space.h"
+#include "win/space_reconfigure.h"
 
 #include <KDecoration2/Decoration>
 #include <KDecoration2/DecorationShadow>
@@ -138,7 +139,7 @@ void SceneOpenGLShadowTest::initTestCase()
     KConfigGroup group = kwinApp()->config()->group("org.kde.kdecoration2");
     group.writeEntry("library", "org.kde.test.fakedecowithshadows");
     group.sync();
-    Test::app()->workspace->slotReconfigure();
+    win::space_reconfigure(*Test::app()->workspace);
 
     auto& scene = Test::app()->base.render->compositor->scene;
     QVERIFY(scene);
diff --git a/autotests/integration/scene_qpainter_shadow_test.cpp b/autotests/integration/scene_qpainter_shadow_test.cpp
index 96dbd51d1..5110aedec 100644
--- a/autotests/integration/scene_qpainter_shadow_test.cpp
+++ b/autotests/integration/scene_qpainter_shadow_test.cpp
@@ -28,6 +28,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "shadow.h"
 #include "win/deco.h"
 #include "win/space.h"
+#include "win/space_reconfigure.h"
 
 #include <algorithm>
 #include <cmath>
@@ -154,7 +155,7 @@ void SceneQPainterShadowTest::initTestCase()
     KConfigGroup group = kwinApp()->config()->group("org.kde.kdecoration2");
     group.writeEntry("library", "org.kde.test.fakedecowithshadows");
     group.sync();
-    Test::app()->workspace->slotReconfigure();
+    win::space_reconfigure(*Test::app()->workspace);
 }
 
 void SceneQPainterShadowTest::cleanup()
diff --git a/autotests/integration/scripting/screenedge_test.cpp b/autotests/integration/scripting/screenedge_test.cpp
index 2b251c901..c166d8e9b 100644
--- a/autotests/integration/scripting/screenedge_test.cpp
+++ b/autotests/integration/scripting/screenedge_test.cpp
@@ -25,6 +25,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "scripting/platform.h"
 #include "scripting/script.h"
 #include "win/space.h"
+#include "win/space_reconfigure.h"
 
 #define private public
 #include "win/screen_edges.h"
@@ -222,7 +223,7 @@ void ScreenEdgeTest::testTouchEdge()
 
 void ScreenEdgeTest::triggerConfigReload()
 {
-    Test::app()->workspace->slotReconfigure();
+    win::space_reconfigure(*Test::app()->workspace);
 }
 
 void ScreenEdgeTest::testEdgeUnregister()
diff --git a/autotests/integration/struts_test.cpp b/autotests/integration/struts_test.cpp
index 26dc1292a..88722eb6b 100644
--- a/autotests/integration/struts_test.cpp
+++ b/autotests/integration/struts_test.cpp
@@ -25,6 +25,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "win/input.h"
 #include "win/screen_edges.h"
 #include "win/space.h"
+#include "win/space_reconfigure.h"
 #include "win/wayland/space.h"
 #include "win/wayland/window.h"
 #include "win/x11/window.h"
@@ -357,7 +358,7 @@ void StrutsTest::testWaylandMobilePanel()
     KConfigGroup group = kwinApp()->config()->group("Windows");
     group.writeEntry("Placement", "maximizing");
     group.sync();
-    Test::app()->workspace->slotReconfigure();
+    win::space_reconfigure(*Test::app()->workspace);
 
     // create first top panel
     const QRect windowGeometry(0, 0, 1280, 60);
diff --git a/autotests/integration/window_rules_test.cpp b/autotests/integration/window_rules_test.cpp
index 73c6b7026..7dd362206 100644
--- a/autotests/integration/window_rules_test.cpp
+++ b/autotests/integration/window_rules_test.cpp
@@ -27,6 +27,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "win/deco.h"
 #include "win/screen_edges.h"
 #include "win/space.h"
+#include "win/space_reconfigure.h"
 #include "win/wayland/space.h"
 #include "win/x11/window.h"
 
@@ -186,7 +187,7 @@ void WindowRuleTest::testWindowClassChange()
     group.sync();
 
     Test::app()->workspace->rule_book->config = config;
-    Test::app()->workspace->slotReconfigure();
+    win::space_reconfigure(*Test::app()->workspace);
 
     // create the test window
     auto c = create_xcb_connection();
diff --git a/autotests/integration/xdgshellclient_rules_test.cpp b/autotests/integration/xdgshellclient_rules_test.cpp
index 3c7845b2c..1010f1af9 100644
--- a/autotests/integration/xdgshellclient_rules_test.cpp
+++ b/autotests/integration/xdgshellclient_rules_test.cpp
@@ -28,6 +28,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "win/input.h"
 #include "win/setup.h"
 #include "win/space.h"
+#include "win/space_reconfigure.h"
 #include "win/virtual_desktops.h"
 #include "win/wayland/space.h"
 #include "win/wayland/window.h"
@@ -173,7 +174,7 @@ void TestXdgShellClientRules::cleanup()
 
     // Unreference the previous config.
     Test::app()->workspace->rule_book->config = {};
-    Test::app()->workspace->slotReconfigure();
+    win::space_reconfigure(*Test::app()->workspace);
 
     // Restore virtual desktops to the initial state.
     auto& vd_manager = Test::app()->workspace->virtual_desktop_manager;
@@ -229,7 +230,7 @@ void TestXdgShellClientRules::testPositionDontAffect()
     group.writeEntry("wmclassmatch", int(Rules::ExactMatch));
     group.sync();
     Test::app()->workspace->rule_book->config = config;
-    Test::app()->workspace->slotReconfigure();
+    win::space_reconfigure(*Test::app()->workspace);
 
     // Create the test client.
     win::wayland::window* client;
@@ -264,7 +265,7 @@ void TestXdgShellClientRules::testPositionApply()
     group.writeEntry("wmclassmatch", int(Rules::ExactMatch));
     group.sync();
     Test::app()->workspace->rule_book->config = config;
-    Test::app()->workspace->slotReconfigure();
+    win::space_reconfigure(*Test::app()->workspace);
 
     // Create the test client.
     win::wayland::window* client;
@@ -340,7 +341,7 @@ void TestXdgShellClientRules::testPositionRemember()
     group.writeEntry("wmclassmatch", int(Rules::ExactMatch));
     group.sync();
     Test::app()->workspace->rule_book->config = config;
-    Test::app()->workspace->slotReconfigure();
+    win::space_reconfigure(*Test::app()->workspace);
 
     // Create the test client.
     win::wayland::window* client;
@@ -416,7 +417,7 @@ void TestXdgShellClientRules::testPositionForce()
     group.writeEntry("wmclassmatch", int(Rules::ExactMatch));
     group.sync();
     Test::app()->workspace->rule_book->config = config;
-    Test::app()->workspace->slotReconfigure();
+    win::space_reconfigure(*Test::app()->workspace);
 
     // Create the test client.
     win::wayland::window* client;
@@ -491,7 +492,7 @@ void TestXdgShellClientRules::testPositionApplyNow()
     // The client should be moved to the position specified by the rule.
     QSignalSpy geometryChangedSpy(client, &Toplevel::frame_geometry_changed);
     QVERIFY(geometryChangedSpy.isValid());
-    Test::app()->workspace->slotReconfigure();
+    win::space_reconfigure(*Test::app()->workspace);
     QCOMPARE(geometryChangedSpy.count(), 1);
     QCOMPARE(client->pos(), QPoint(42, 42));
 
@@ -551,7 +552,7 @@ void TestXdgShellClientRules::testPositionForceTemporarily()
     group.writeEntry("wmclassmatch", int(Rules::ExactMatch));
     group.sync();
     Test::app()->workspace->rule_book->config = config;
-    Test::app()->workspace->slotReconfigure();
+    win::space_reconfigure(*Test::app()->workspace);
 
     // Create the test client.
     win::wayland::window* client;
@@ -608,7 +609,7 @@ void TestXdgShellClientRules::testSizeDontAffect()
     group.writeEntry("wmclassmatch", int(Rules::ExactMatch));
     group.sync();
     Test::app()->workspace->rule_book->config = config;
-    Test::app()->workspace->slotReconfigure();
+    win::space_reconfigure(*Test::app()->workspace);
 
     // Create the test client.
     std::unique_ptr<Surface> surface = Test::create_surface();
@@ -656,7 +657,7 @@ void TestXdgShellClientRules::testSizeApply()
     group.writeEntry("wmclassmatch", int(Rules::ExactMatch));
     group.sync();
     Test::app()->workspace->rule_book->config = config;
-    Test::app()->workspace->slotReconfigure();
+    win::space_reconfigure(*Test::app()->workspace);
 
     // Create the test client.
     auto surface = Test::create_surface();
@@ -792,7 +793,7 @@ void TestXdgShellClientRules::testSizeRemember()
     group.writeEntry("wmclassmatch", int(Rules::ExactMatch));
     group.sync();
     Test::app()->workspace->rule_book->config = config;
-    Test::app()->workspace->slotReconfigure();
+    win::space_reconfigure(*Test::app()->workspace);
 
     // Create the test client.
     auto surface = Test::create_surface();
@@ -927,7 +928,7 @@ void TestXdgShellClientRules::testSizeForce()
     group.writeEntry("wmclassmatch", int(Rules::ExactMatch));
     group.sync();
     Test::app()->workspace->rule_book->config = config;
-    Test::app()->workspace->slotReconfigure();
+    win::space_reconfigure(*Test::app()->workspace);
 
     // Create the test client.
     auto surface = Test::create_surface();
@@ -1038,7 +1039,7 @@ void TestXdgShellClientRules::testSizeApplyNow()
     group.writeEntry("wmclassmatch", int(Rules::ExactMatch));
     group.sync();
     Test::app()->workspace->rule_book->config = config;
-    Test::app()->workspace->slotReconfigure();
+    win::space_reconfigure(*Test::app()->workspace);
 
     // The compositor should send a configure event with a new size.
     QVERIFY(configureRequestedSpy->wait());
@@ -1077,7 +1078,7 @@ void TestXdgShellClientRules::testSizeForceTemporarily()
     group.writeEntry("wmclassmatch", int(Rules::ExactMatch));
     group.sync();
     Test::app()->workspace->rule_book->config = config;
-    Test::app()->workspace->slotReconfigure();
+    win::space_reconfigure(*Test::app()->workspace);
 
     // Create the test client.
     auto surface = Test::create_surface();
@@ -1164,7 +1165,7 @@ void TestXdgShellClientRules::testMaximizeDontAffect()
     group.writeEntry("wmclassmatch", int(Rules::ExactMatch));
     group.sync();
     Test::app()->workspace->rule_book->config = config;
-    Test::app()->workspace->slotReconfigure();
+    win::space_reconfigure(*Test::app()->workspace);
 
     // Create the test client.
     auto surface = Test::create_surface();
@@ -1222,7 +1223,7 @@ void TestXdgShellClientRules::testMaximizeApply()
     group.writeEntry("wmclassmatch", int(Rules::ExactMatch));
     group.sync();
     Test::app()->workspace->rule_book->config = config;
-    Test::app()->workspace->slotReconfigure();
+    win::space_reconfigure(*Test::app()->workspace);
 
     // Create the test client.
     auto surface = Test::create_surface();
@@ -1334,7 +1335,7 @@ void TestXdgShellClientRules::testMaximizeRemember()
     group.writeEntry("wmclassmatch", int(Rules::ExactMatch));
     group.sync();
     Test::app()->workspace->rule_book->config = config;
-    Test::app()->workspace->slotReconfigure();
+    win::space_reconfigure(*Test::app()->workspace);
 
     // Create the test client.
     auto surface = Test::create_surface();
@@ -1446,7 +1447,7 @@ void TestXdgShellClientRules::testMaximizeForce()
     group.writeEntry("wmclassmatch", int(Rules::ExactMatch));
     group.sync();
     Test::app()->workspace->rule_book->config = config;
-    Test::app()->workspace->slotReconfigure();
+    win::space_reconfigure(*Test::app()->workspace);
 
     // Create the test client.
     auto surface = Test::create_surface();
@@ -1580,7 +1581,7 @@ void TestXdgShellClientRules::testMaximizeApplyNow()
     group.writeEntry("wmclassmatch", int(Rules::ExactMatch));
     group.sync();
     Test::app()->workspace->rule_book->config = config;
-    Test::app()->workspace->slotReconfigure();
+    win::space_reconfigure(*Test::app()->workspace);
 
     // We should receive a configure event with a new surface size.
     QVERIFY(configureRequestedSpy->wait());
@@ -1648,7 +1649,7 @@ void TestXdgShellClientRules::testMaximizeForceTemporarily()
     group.writeEntry("wmclassmatch", int(Rules::ExactMatch));
     group.sync();
     Test::app()->workspace->rule_book->config = config;
-    Test::app()->workspace->slotReconfigure();
+    win::space_reconfigure(*Test::app()->workspace);
 
     // Create the test client.
     auto surface = Test::create_surface();
@@ -1745,7 +1746,7 @@ void TestXdgShellClientRules::testDesktopDontAffect()
     group.writeEntry("wmclassmatch", int(Rules::ExactMatch));
     group.sync();
     Test::app()->workspace->rule_book->config = config;
-    Test::app()->workspace->slotReconfigure();
+    win::space_reconfigure(*Test::app()->workspace);
 
     // We need at least two virtual desktop for this test.
     auto& vd_manager = Test::app()->workspace->virtual_desktop_manager;
@@ -1784,7 +1785,7 @@ void TestXdgShellClientRules::testDesktopApply()
     group.writeEntry("wmclassmatch", int(Rules::ExactMatch));
     group.sync();
     Test::app()->workspace->rule_book->config = config;
-    Test::app()->workspace->slotReconfigure();
+    win::space_reconfigure(*Test::app()->workspace);
 
     // We need at least two virtual desktop for this test.
     auto& vd_manager = Test::app()->workspace->virtual_desktop_manager;
@@ -1839,7 +1840,7 @@ void TestXdgShellClientRules::testDesktopRemember()
     group.writeEntry("wmclassmatch", int(Rules::ExactMatch));
     group.sync();
     Test::app()->workspace->rule_book->config = config;
-    Test::app()->workspace->slotReconfigure();
+    win::space_reconfigure(*Test::app()->workspace);
 
     // We need at least two virtual desktop for this test.
     auto& vd_manager = Test::app()->workspace->virtual_desktop_manager;
@@ -1890,7 +1891,7 @@ void TestXdgShellClientRules::testDesktopForce()
     group.writeEntry("wmclassmatch", int(Rules::ExactMatch));
     group.sync();
     Test::app()->workspace->rule_book->config = config;
-    Test::app()->workspace->slotReconfigure();
+    win::space_reconfigure(*Test::app()->workspace);
 
     // We need at least two virtual desktop for this test.
     auto& vd_manager = Test::app()->workspace->virtual_desktop_manager;
@@ -1961,7 +1962,7 @@ void TestXdgShellClientRules::testDesktopApplyNow()
     group.writeEntry("wmclassmatch", int(Rules::ExactMatch));
     group.sync();
     Test::app()->workspace->rule_book->config = config;
-    Test::app()->workspace->slotReconfigure();
+    win::space_reconfigure(*Test::app()->workspace);
 
     // The client should have been moved to the second virtual desktop.
     QCOMPARE(client->desktop(), 2);
@@ -1996,7 +1997,7 @@ void TestXdgShellClientRules::testDesktopForceTemporarily()
     group.writeEntry("wmclassmatch", int(Rules::ExactMatch));
     group.sync();
     Test::app()->workspace->rule_book->config = config;
-    Test::app()->workspace->slotReconfigure();
+    win::space_reconfigure(*Test::app()->workspace);
 
     // We need at least two virtual desktop for this test.
     auto& vd_manager = Test::app()->workspace->virtual_desktop_manager;
@@ -2059,7 +2060,7 @@ void TestXdgShellClientRules::testMinimizeDontAffect()
     group.writeEntry("wmclassmatch", int(Rules::ExactMatch));
     group.sync();
     Test::app()->workspace->rule_book->config = config;
-    Test::app()->workspace->slotReconfigure();
+    win::space_reconfigure(*Test::app()->workspace);
 
     // Create the test client.
     win::wayland::window* client;
@@ -2091,7 +2092,7 @@ void TestXdgShellClientRules::testMinimizeApply()
     group.writeEntry("wmclassmatch", int(Rules::ExactMatch));
     group.sync();
     Test::app()->workspace->rule_book->config = config;
-    Test::app()->workspace->slotReconfigure();
+    win::space_reconfigure(*Test::app()->workspace);
 
     // Create the test client.
     win::wayland::window* client;
@@ -2147,7 +2148,7 @@ void TestXdgShellClientRules::testMinimizeRemember()
     group.writeEntry("wmclassmatch", int(Rules::ExactMatch));
     group.sync();
     Test::app()->workspace->rule_book->config = config;
-    Test::app()->workspace->slotReconfigure();
+    win::space_reconfigure(*Test::app()->workspace);
 
     // Create the test client.
     win::wayland::window* client;
@@ -2198,7 +2199,7 @@ void TestXdgShellClientRules::testMinimizeForce()
     group.writeEntry("wmclassmatch", int(Rules::ExactMatch));
     group.sync();
     Test::app()->workspace->rule_book->config = config;
-    Test::app()->workspace->slotReconfigure();
+    win::space_reconfigure(*Test::app()->workspace);
 
     // Create the test client.
     win::wayland::window* client;
@@ -2252,7 +2253,7 @@ void TestXdgShellClientRules::testMinimizeApplyNow()
     group.writeEntry("wmclassmatch", int(Rules::ExactMatch));
     group.sync();
     Test::app()->workspace->rule_book->config = config;
-    Test::app()->workspace->slotReconfigure();
+    win::space_reconfigure(*Test::app()->workspace);
 
     // The client should be minimized now.
     QVERIFY(client->isMinimizable());
@@ -2286,7 +2287,7 @@ void TestXdgShellClientRules::testMinimizeForceTemporarily()
     group.writeEntry("wmclassmatch", int(Rules::ExactMatch));
     group.sync();
     Test::app()->workspace->rule_book->config = config;
-    Test::app()->workspace->slotReconfigure();
+    win::space_reconfigure(*Test::app()->workspace);
 
     // Create the test client.
     win::wayland::window* client;
@@ -2331,7 +2332,7 @@ void TestXdgShellClientRules::testSkipTaskbarDontAffect()
     group.writeEntry("wmclassmatch", int(Rules::ExactMatch));
     group.sync();
     Test::app()->workspace->rule_book->config = config;
-    Test::app()->workspace->slotReconfigure();
+    win::space_reconfigure(*Test::app()->workspace);
 
     // Create the test client.
     win::wayland::window* client;
@@ -2362,7 +2363,7 @@ void TestXdgShellClientRules::testSkipTaskbarApply()
     group.writeEntry("wmclassmatch", int(Rules::ExactMatch));
     group.sync();
     Test::app()->workspace->rule_book->config = config;
-    Test::app()->workspace->slotReconfigure();
+    win::space_reconfigure(*Test::app()->workspace);
 
     // Create the test client.
     win::wayland::window* client;
@@ -2405,7 +2406,7 @@ void TestXdgShellClientRules::testSkipTaskbarRemember()
     group.writeEntry("wmclassmatch", int(Rules::ExactMatch));
     group.sync();
     Test::app()->workspace->rule_book->config = config;
-    Test::app()->workspace->slotReconfigure();
+    win::space_reconfigure(*Test::app()->workspace);
 
     // Create the test client.
     win::wayland::window* client;
@@ -2450,7 +2451,7 @@ void TestXdgShellClientRules::testSkipTaskbarForce()
     group.writeEntry("wmclassmatch", int(Rules::ExactMatch));
     group.sync();
     Test::app()->workspace->rule_book->config = config;
-    Test::app()->workspace->slotReconfigure();
+    win::space_reconfigure(*Test::app()->workspace);
 
     // Create the test client.
     win::wayland::window* client;
@@ -2503,7 +2504,7 @@ void TestXdgShellClientRules::testSkipTaskbarApplyNow()
     group.writeEntry("wmclassmatch", int(Rules::ExactMatch));
     group.sync();
     Test::app()->workspace->rule_book->config = config;
-    Test::app()->workspace->slotReconfigure();
+    win::space_reconfigure(*Test::app()->workspace);
 
     // The client should not be on a taskbar now.
     QVERIFY(client->control->skip_taskbar());
@@ -2535,7 +2536,7 @@ void TestXdgShellClientRules::testSkipTaskbarForceTemporarily()
     group.writeEntry("wmclassmatch", int(Rules::ExactMatch));
     group.sync();
     Test::app()->workspace->rule_book->config = config;
-    Test::app()->workspace->slotReconfigure();
+    win::space_reconfigure(*Test::app()->workspace);
 
     // Create the test client.
     win::wayland::window* client;
@@ -2582,7 +2583,7 @@ void TestXdgShellClientRules::testSkipPagerDontAffect()
     group.writeEntry("wmclassmatch", int(Rules::ExactMatch));
     group.sync();
     Test::app()->workspace->rule_book->config = config;
-    Test::app()->workspace->slotReconfigure();
+    win::space_reconfigure(*Test::app()->workspace);
 
     // Create the test client.
     win::wayland::window* client;
@@ -2613,7 +2614,7 @@ void TestXdgShellClientRules::testSkipPagerApply()
     group.writeEntry("wmclassmatch", int(Rules::ExactMatch));
     group.sync();
     Test::app()->workspace->rule_book->config = config;
-    Test::app()->workspace->slotReconfigure();
+    win::space_reconfigure(*Test::app()->workspace);
 
     // Create the test client.
     win::wayland::window* client;
@@ -2656,7 +2657,7 @@ void TestXdgShellClientRules::testSkipPagerRemember()
     group.writeEntry("wmclassmatch", int(Rules::ExactMatch));
     group.sync();
     Test::app()->workspace->rule_book->config = config;
-    Test::app()->workspace->slotReconfigure();
+    win::space_reconfigure(*Test::app()->workspace);
 
     // Create the test client.
     win::wayland::window* client;
@@ -2701,7 +2702,7 @@ void TestXdgShellClientRules::testSkipPagerForce()
     group.writeEntry("wmclassmatch", int(Rules::ExactMatch));
     group.sync();
     Test::app()->workspace->rule_book->config = config;
-    Test::app()->workspace->slotReconfigure();
+    win::space_reconfigure(*Test::app()->workspace);
 
     // Create the test client.
     win::wayland::window* client;
@@ -2754,7 +2755,7 @@ void TestXdgShellClientRules::testSkipPagerApplyNow()
     group.writeEntry("wmclassmatch", int(Rules::ExactMatch));
     group.sync();
     Test::app()->workspace->rule_book->config = config;
-    Test::app()->workspace->slotReconfigure();
+    win::space_reconfigure(*Test::app()->workspace);
 
     // The client should not be on a pager now.
     QVERIFY(client->control->skip_pager());
@@ -2786,7 +2787,7 @@ void TestXdgShellClientRules::testSkipPagerForceTemporarily()
     group.writeEntry("wmclassmatch", int(Rules::ExactMatch));
     group.sync();
     Test::app()->workspace->rule_book->config = config;
-    Test::app()->workspace->slotReconfigure();
+    win::space_reconfigure(*Test::app()->workspace);
 
     // Create the test client.
     win::wayland::window* client;
@@ -2833,7 +2834,7 @@ void TestXdgShellClientRules::testSkipSwitcherDontAffect()
     group.writeEntry("wmclassmatch", int(Rules::ExactMatch));
     group.sync();
     Test::app()->workspace->rule_book->config = config;
-    Test::app()->workspace->slotReconfigure();
+    win::space_reconfigure(*Test::app()->workspace);
 
     // Create the test client.
     win::wayland::window* client;
@@ -2864,7 +2865,7 @@ void TestXdgShellClientRules::testSkipSwitcherApply()
     group.writeEntry("wmclassmatch", int(Rules::ExactMatch));
     group.sync();
     Test::app()->workspace->rule_book->config = config;
-    Test::app()->workspace->slotReconfigure();
+    win::space_reconfigure(*Test::app()->workspace);
 
     // Create the test client.
     win::wayland::window* client;
@@ -2907,7 +2908,7 @@ void TestXdgShellClientRules::testSkipSwitcherRemember()
     group.writeEntry("wmclassmatch", int(Rules::ExactMatch));
     group.sync();
     Test::app()->workspace->rule_book->config = config;
-    Test::app()->workspace->slotReconfigure();
+    win::space_reconfigure(*Test::app()->workspace);
 
     // Create the test client.
     win::wayland::window* client;
@@ -2952,7 +2953,7 @@ void TestXdgShellClientRules::testSkipSwitcherForce()
     group.writeEntry("wmclassmatch", int(Rules::ExactMatch));
     group.sync();
     Test::app()->workspace->rule_book->config = config;
-    Test::app()->workspace->slotReconfigure();
+    win::space_reconfigure(*Test::app()->workspace);
 
     // Create the test client.
     win::wayland::window* client;
@@ -3005,7 +3006,7 @@ void TestXdgShellClientRules::testSkipSwitcherApplyNow()
     group.writeEntry("wmclassmatch", int(Rules::ExactMatch));
     group.sync();
     Test::app()->workspace->rule_book->config = config;
-    Test::app()->workspace->slotReconfigure();
+    win::space_reconfigure(*Test::app()->workspace);
 
     // The client should be excluded from window switching effects now.
     QVERIFY(client->control->skip_switcher());
@@ -3037,7 +3038,7 @@ void TestXdgShellClientRules::testSkipSwitcherForceTemporarily()
     group.writeEntry("wmclassmatch", int(Rules::ExactMatch));
     group.sync();
     Test::app()->workspace->rule_book->config = config;
-    Test::app()->workspace->slotReconfigure();
+    win::space_reconfigure(*Test::app()->workspace);
 
     // Create the test client.
     win::wayland::window* client;
@@ -3084,7 +3085,7 @@ void TestXdgShellClientRules::testKeepAboveDontAffect()
     group.writeEntry("wmclassmatch", int(Rules::ExactMatch));
     group.sync();
     Test::app()->workspace->rule_book->config = config;
-    Test::app()->workspace->slotReconfigure();
+    win::space_reconfigure(*Test::app()->workspace);
 
     // Create the test client.
     win::wayland::window* client;
@@ -3115,7 +3116,7 @@ void TestXdgShellClientRules::testKeepAboveApply()
     group.writeEntry("wmclassmatch", int(Rules::ExactMatch));
     group.sync();
     Test::app()->workspace->rule_book->config = config;
-    Test::app()->workspace->slotReconfigure();
+    win::space_reconfigure(*Test::app()->workspace);
 
     // Create the test client.
     win::wayland::window* client;
@@ -3158,7 +3159,7 @@ void TestXdgShellClientRules::testKeepAboveRemember()
     group.writeEntry("wmclassmatch", int(Rules::ExactMatch));
     group.sync();
     Test::app()->workspace->rule_book->config = config;
-    Test::app()->workspace->slotReconfigure();
+    win::space_reconfigure(*Test::app()->workspace);
 
     // Create the test client.
     win::wayland::window* client;
@@ -3201,7 +3202,7 @@ void TestXdgShellClientRules::testKeepAboveForce()
     group.writeEntry("wmclassmatch", int(Rules::ExactMatch));
     group.sync();
     Test::app()->workspace->rule_book->config = config;
-    Test::app()->workspace->slotReconfigure();
+    win::space_reconfigure(*Test::app()->workspace);
 
     // Create the test client.
     win::wayland::window* client;
@@ -3252,7 +3253,7 @@ void TestXdgShellClientRules::testKeepAboveApplyNow()
     group.writeEntry("wmclassmatch", int(Rules::ExactMatch));
     group.sync();
     Test::app()->workspace->rule_book->config = config;
-    Test::app()->workspace->slotReconfigure();
+    win::space_reconfigure(*Test::app()->workspace);
 
     // The client should now be kept above other clients.
     QVERIFY(client->control->keep_above());
@@ -3284,7 +3285,7 @@ void TestXdgShellClientRules::testKeepAboveForceTemporarily()
     group.writeEntry("wmclassmatch", int(Rules::ExactMatch));
     group.sync();
     Test::app()->workspace->rule_book->config = config;
-    Test::app()->workspace->slotReconfigure();
+    win::space_reconfigure(*Test::app()->workspace);
 
     // Create the test client.
     win::wayland::window* client;
@@ -3333,7 +3334,7 @@ void TestXdgShellClientRules::testKeepBelowDontAffect()
     group.writeEntry("wmclassmatch", int(Rules::ExactMatch));
     group.sync();
     Test::app()->workspace->rule_book->config = config;
-    Test::app()->workspace->slotReconfigure();
+    win::space_reconfigure(*Test::app()->workspace);
 
     // Create the test client.
     win::wayland::window* client;
@@ -3364,7 +3365,7 @@ void TestXdgShellClientRules::testKeepBelowApply()
     group.writeEntry("wmclassmatch", int(Rules::ExactMatch));
     group.sync();
     Test::app()->workspace->rule_book->config = config;
-    Test::app()->workspace->slotReconfigure();
+    win::space_reconfigure(*Test::app()->workspace);
 
     // Create the test client.
     win::wayland::window* client;
@@ -3407,7 +3408,7 @@ void TestXdgShellClientRules::testKeepBelowRemember()
     group.writeEntry("wmclassmatch", int(Rules::ExactMatch));
     group.sync();
     Test::app()->workspace->rule_book->config = config;
-    Test::app()->workspace->slotReconfigure();
+    win::space_reconfigure(*Test::app()->workspace);
 
     // Create the test client.
     win::wayland::window* client;
@@ -3450,7 +3451,7 @@ void TestXdgShellClientRules::testKeepBelowForce()
     group.writeEntry("wmclassmatch", int(Rules::ExactMatch));
     group.sync();
     Test::app()->workspace->rule_book->config = config;
-    Test::app()->workspace->slotReconfigure();
+    win::space_reconfigure(*Test::app()->workspace);
 
     // Create the test client.
     win::wayland::window* client;
@@ -3501,7 +3502,7 @@ void TestXdgShellClientRules::testKeepBelowApplyNow()
     group.writeEntry("wmclassmatch", int(Rules::ExactMatch));
     group.sync();
     Test::app()->workspace->rule_book->config = config;
-    Test::app()->workspace->slotReconfigure();
+    win::space_reconfigure(*Test::app()->workspace);
 
     // The client should now be kept below other clients.
     QVERIFY(client->control->keep_below());
@@ -3533,7 +3534,7 @@ void TestXdgShellClientRules::testKeepBelowForceTemporarily()
     group.writeEntry("wmclassmatch", int(Rules::ExactMatch));
     group.sync();
     Test::app()->workspace->rule_book->config = config;
-    Test::app()->workspace->slotReconfigure();
+    win::space_reconfigure(*Test::app()->workspace);
 
     // Create the test client.
     win::wayland::window* client;
@@ -3582,7 +3583,7 @@ void TestXdgShellClientRules::testShortcutDontAffect()
     group.writeEntry("wmclassmatch", int(Rules::ExactMatch));
     group.sync();
     Test::app()->workspace->rule_book->config = config;
-    Test::app()->workspace->slotReconfigure();
+    win::space_reconfigure(*Test::app()->workspace);
 
     // Create the test client.
     win::wayland::window* client;
@@ -3626,7 +3627,7 @@ void TestXdgShellClientRules::testShortcutApply()
     group.writeEntry("wmclassmatch", int(Rules::ExactMatch));
     group.sync();
     Test::app()->workspace->rule_book->config = config;
-    Test::app()->workspace->slotReconfigure();
+    win::space_reconfigure(*Test::app()->workspace);
 
     // Create the test client.
     win::wayland::window* client;
@@ -3708,7 +3709,7 @@ void TestXdgShellClientRules::testShortcutRemember()
     group.writeEntry("wmclassmatch", int(Rules::ExactMatch));
     group.sync();
     Test::app()->workspace->rule_book->config = config;
-    Test::app()->workspace->slotReconfigure();
+    win::space_reconfigure(*Test::app()->workspace);
 
     // Create the test client.
     win::wayland::window* client;
@@ -3778,7 +3779,7 @@ void TestXdgShellClientRules::testShortcutForce()
     group.writeEntry("wmclassmatch", int(Rules::ExactMatch));
     group.sync();
     Test::app()->workspace->rule_book->config = config;
-    Test::app()->workspace->slotReconfigure();
+    win::space_reconfigure(*Test::app()->workspace);
 
     // Create the test client.
     win::wayland::window* client;
@@ -3854,7 +3855,7 @@ void TestXdgShellClientRules::testShortcutApplyNow()
     group.writeEntry("wmclassmatch", int(Rules::ExactMatch));
     group.sync();
     Test::app()->workspace->rule_book->config = config;
-    Test::app()->workspace->slotReconfigure();
+    win::space_reconfigure(*Test::app()->workspace);
 
     // The client should now have a window shortcut assigned.
     QCOMPARE(client->control->shortcut(), (QKeySequence{Qt::CTRL + Qt::ALT + Qt::Key_1}));
@@ -3911,7 +3912,7 @@ void TestXdgShellClientRules::testShortcutForceTemporarily()
     group.writeEntry("wmclassmatch", int(Rules::ExactMatch));
     group.sync();
     Test::app()->workspace->rule_book->config = config;
-    Test::app()->workspace->slotReconfigure();
+    win::space_reconfigure(*Test::app()->workspace);
 
     // Create the test client.
     win::wayland::window* client;
@@ -4025,7 +4026,7 @@ void TestXdgShellClientRules::testActiveOpacityDontAffect()
     group.writeEntry("wmclassmatch", int(Rules::ExactMatch));
     group.sync();
     Test::app()->workspace->rule_book->config = config;
-    Test::app()->workspace->slotReconfigure();
+    win::space_reconfigure(*Test::app()->workspace);
 
     // Create the test client.
     win::wayland::window* client;
@@ -4057,7 +4058,7 @@ void TestXdgShellClientRules::testActiveOpacityForce()
     group.writeEntry("wmclassmatch", int(Rules::ExactMatch));
     group.sync();
     Test::app()->workspace->rule_book->config = config;
-    Test::app()->workspace->slotReconfigure();
+    win::space_reconfigure(*Test::app()->workspace);
 
     // Create the test client.
     win::wayland::window* client;
@@ -4087,7 +4088,7 @@ void TestXdgShellClientRules::testActiveOpacityForceTemporarily()
     group.writeEntry("wmclassmatch", int(Rules::ExactMatch));
     group.sync();
     Test::app()->workspace->rule_book->config = config;
-    Test::app()->workspace->slotReconfigure();
+    win::space_reconfigure(*Test::app()->workspace);
 
     // Create the test client.
     win::wayland::window* client;
@@ -4126,7 +4127,7 @@ void TestXdgShellClientRules::testInactiveOpacityDontAffect()
     group.writeEntry("wmclassmatch", int(Rules::ExactMatch));
     group.sync();
     Test::app()->workspace->rule_book->config = config;
-    Test::app()->workspace->slotReconfigure();
+    win::space_reconfigure(*Test::app()->workspace);
 
     // Create the test client.
     win::wayland::window* client;
@@ -4162,7 +4163,7 @@ void TestXdgShellClientRules::testInactiveOpacityForce()
     group.writeEntry("wmclassmatch", int(Rules::ExactMatch));
     group.sync();
     Test::app()->workspace->rule_book->config = config;
-    Test::app()->workspace->slotReconfigure();
+    win::space_reconfigure(*Test::app()->workspace);
 
     // Create the test client.
     win::wayland::window* client;
@@ -4199,7 +4200,7 @@ void TestXdgShellClientRules::testInactiveOpacityForceTemporarily()
     group.writeEntry("wmclassmatch", int(Rules::ExactMatch));
     group.sync();
     Test::app()->workspace->rule_book->config = config;
-    Test::app()->workspace->slotReconfigure();
+    win::space_reconfigure(*Test::app()->workspace);
 
     // Create the test client.
     win::wayland::window* client;
@@ -4248,7 +4249,7 @@ void TestXdgShellClientRules::testMatchAfterNameChange()
     group.sync();
 
     Test::app()->workspace->rule_book->config = config;
-    Test::app()->workspace->slotReconfigure();
+    win::space_reconfigure(*Test::app()->workspace);
 
     auto surface = Test::create_surface();
     auto shellSurface = Test::create_xdg_shell_toplevel(surface);
diff --git a/win/space.cpp b/win/space.cpp
index 885e85abb..026184338 100644
--- a/win/space.cpp
+++ b/win/space.cpp
@@ -73,6 +73,9 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "tabbox/tabbox.h"
 #endif
 
+// TODO(romangg): For now this needs to be included late because of some conflict with Qt libraries.
+#include "space_reconfigure.h"
+
 #include <KConfig>
 #include <KConfigGroup>
 #include <KGlobalAccel>
@@ -99,7 +102,7 @@ void space_qobject::reconfigure()
 }
 
 space::space(render::compositor& render)
-    : qobject{std::make_unique<space_qobject>([this] { reconfigure(); })}
+    : qobject{std::make_unique<space_qobject>([this] { space_start_reconfigure_timer(*this); })}
     , outline{std::make_unique<render::outline>(render)}
     , render{render}
     , deco{std::make_unique<deco::bridge<space>>(*this)}
@@ -217,7 +220,7 @@ space::space(render::compositor& render)
     updateToolWindowsTimer.setSingleShot(true);
 
     QObject::connect(
-        &reconfigureTimer, &QTimer::timeout, qobject.get(), [this] { slotReconfigure(); });
+        &reconfigureTimer, &QTimer::timeout, qobject.get(), [this] { space_reconfigure(*this); });
     QObject::connect(&updateToolWindowsTimer, &QTimer::timeout, qobject.get(), [this] {
         x11::update_tool_windows_visibility(this, true);
     });
@@ -286,51 +289,6 @@ space::~space()
     singleton_interface::space = nullptr;
 }
 
-void space::reconfigure()
-{
-    reconfigureTimer.start(200);
-}
-
-/**
- * Reread settings
- */
-
-void space::slotReconfigure()
-{
-    qCDebug(KWIN_CORE) << "space::slotReconfigure()";
-    reconfigureTimer.stop();
-
-    bool borderlessMaximizedWindows = kwinApp()->options->borderlessMaximizedWindows();
-
-    kwinApp()->config()->reparseConfiguration();
-    kwinApp()->options->updateSettings();
-    scripting->start();
-
-    Q_EMIT qobject->configChanged();
-
-    user_actions_menu->discard();
-    x11::update_tool_windows_visibility(this, true);
-
-    rule_book->load();
-    for (auto window : m_windows) {
-        if (window->supportsWindowRules()) {
-            win::evaluate_rules(window);
-            rule_book->discardUsed(window, false);
-        }
-    }
-
-    if (borderlessMaximizedWindows != kwinApp()->options->borderlessMaximizedWindows()
-        && !kwinApp()->options->borderlessMaximizedWindows()) {
-        // in case borderless maximized windows option changed and new option
-        // is to have borders, we need to unset the borders for all maximized windows
-        for (auto window : m_windows) {
-            if (window->maximizeMode() == win::maximize_mode::full) {
-                window->checkNoBorder();
-            }
-        }
-    }
-}
-
 void space::slotCurrentDesktopChanged(uint oldDesktop, uint newDesktop)
 {
     closeActivePopup();
diff --git a/win/space.h b/win/space.h
index 3313820b0..c4c80d95a 100644
--- a/win/space.h
+++ b/win/space.h
@@ -211,6 +211,8 @@ public:
 
     QPoint focusMousePos;
 
+    // Timer to collect requests for 'reconfigure'
+    QTimer reconfigureTimer;
     QTimer updateToolWindowsTimer;
 
     explicit space(render::compositor& render);
@@ -464,8 +466,6 @@ public:
     void slotWindowToDesktopUp();
     void slotWindowToDesktopDown();
 
-    void slotReconfigure();
-
     void slotKillWindow();
 
     void slotSetupWindowShortcut();
@@ -473,8 +473,6 @@ public:
 
     void updateClientArea();
 
-    void reconfigure();
-
 protected:
     virtual void update_space_area_from_windows(QRect const& desktop_area,
                                                 std::vector<QRect> const& screens_geos,
@@ -538,9 +536,6 @@ private:
     win::shortcut_dialog* client_keys_dialog{nullptr};
     bool global_shortcuts_disabled_for_client{false};
 
-    // Timer to collect requests for 'reconfigure'
-    QTimer reconfigureTimer;
-
     win::space_areas areas;
 
     // Array of the previous restricted areas that window cannot be moved into
diff --git a/win/space_reconfigure.h b/win/space_reconfigure.h
new file mode 100644
index 000000000..aa31b3d03
--- /dev/null
+++ b/win/space_reconfigure.h
@@ -0,0 +1,58 @@
+/*
+    SPDX-FileCopyrightText: 2022 Roman Gilg <subdiff@gmail.com>
+
+    SPDX-License-Identifier: GPL-2.0-or-later
+*/
+#pragma once
+
+#include "setup.h"
+#include "x11/hide.h"
+
+#include "main.h"
+
+namespace KWin::win
+{
+
+template<typename Space>
+void space_start_reconfigure_timer(Space& space)
+{
+    space.reconfigureTimer.start(200);
+}
+
+template<typename Space>
+void space_reconfigure(Space& space)
+{
+    space.reconfigureTimer.stop();
+
+    bool borderlessMaximizedWindows = kwinApp()->options->borderlessMaximizedWindows();
+
+    kwinApp()->config()->reparseConfiguration();
+    kwinApp()->options->updateSettings();
+    space.scripting->start();
+
+    Q_EMIT space.qobject->configChanged();
+
+    space.user_actions_menu->discard();
+    x11::update_tool_windows_visibility(&space, true);
+
+    space.rule_book->load();
+    for (auto window : space.m_windows) {
+        if (window->supportsWindowRules()) {
+            win::evaluate_rules(window);
+            space.rule_book->discardUsed(window, false);
+        }
+    }
+
+    if (borderlessMaximizedWindows != kwinApp()->options->borderlessMaximizedWindows()
+        && !kwinApp()->options->borderlessMaximizedWindows()) {
+        // in case borderless maximized windows option changed and new option
+        // is to have borders, we need to unset the borders for all maximized windows
+        for (auto window : space.m_windows) {
+            if (window->maximizeMode() == win::maximize_mode::full) {
+                window->checkNoBorder();
+            }
+        }
+    }
+}
+
+}
-- 
GitLab


From 295c909374059da0c5a94356013ded893128f57d Mon Sep 17 00:00:00 2001
From: Roman Gilg <subdiff@gmail.com>
Date: Tue, 5 Jul 2022 00:08:48 +0200
Subject: [PATCH 05/51] refactor: split up X11 control header into multiple
 headers

Split up the large x11::control header into other and multiple new headers.
This reduces the risk of issues due to cyclic inclusions.
---
 scripting/window.cpp           |   1 +
 win/activation.h               |  30 ++
 win/space_reconfigure.h        |   4 +
 win/stacking.h                 |  19 -
 win/wayland/setup.h            |   1 +
 win/x11/actions.h              |  69 +++
 win/x11/activation.h           |  29 ++
 win/x11/appmenu.h              |  57 +++
 win/x11/control.h              | 884 +--------------------------------
 win/x11/event.h                |   7 +-
 win/x11/geo.h                  |   1 -
 win/x11/moving_window_filter.h |   1 +
 win/x11/netinfo.cpp            |   1 +
 win/x11/placement.h            | 356 +++++++++++++
 win/x11/scene.h                |   1 +
 win/x11/session.h              |  36 ++
 win/x11/space.h                |  25 -
 win/x11/space_event.h          |   1 +
 win/x11/space_setup.h          |   1 +
 win/x11/stacking.h             | 193 +++++++
 win/x11/startup_info.h         |  54 ++
 win/x11/user_time.h            |  77 +++
 win/x11/window.cpp             |   3 +
 win/x11/window_release.h       |   1 +
 win/x11/xcb.h                  | 114 +++++
 25 files changed, 1042 insertions(+), 924 deletions(-)
 create mode 100644 win/activation.h
 create mode 100644 win/x11/actions.h
 create mode 100644 win/x11/activation.h
 create mode 100644 win/x11/appmenu.h
 create mode 100644 win/x11/placement.h
 create mode 100644 win/x11/session.h
 create mode 100644 win/x11/startup_info.h
 create mode 100644 win/x11/user_time.h

diff --git a/scripting/window.cpp b/scripting/window.cpp
index 9f4c8d6a8..ce89cf1fd 100644
--- a/scripting/window.cpp
+++ b/scripting/window.cpp
@@ -8,6 +8,7 @@
 #include "space.h"
 
 #include "toplevel.h"
+#include "win/activation.h"
 #include "win/controlling.h"
 #include "win/meta.h"
 #include "win/screen.h"
diff --git a/win/activation.h b/win/activation.h
new file mode 100644
index 000000000..c3471e5e6
--- /dev/null
+++ b/win/activation.h
@@ -0,0 +1,30 @@
+/*
+    SPDX-FileCopyrightText: 2022 Roman Gilg <subdiff@gmail.com>
+
+    SPDX-License-Identifier: GPL-2.0-or-later
+*/
+#pragma once
+
+namespace KWin::win
+{
+
+template<typename Win>
+void set_demands_attention(Win* win, bool demand)
+{
+    if (win->control->active()) {
+        demand = false;
+    }
+    if (win->control->demands_attention() == demand) {
+        return;
+    }
+    win->control->set_demands_attention(demand);
+
+    if (win->info) {
+        win->info->setState(demand ? NET::DemandsAttention : NET::States(), NET::DemandsAttention);
+    }
+
+    win->space.clientAttentionChanged(win, demand);
+    Q_EMIT win->demandsAttentionChanged();
+}
+
+}
diff --git a/win/space_reconfigure.h b/win/space_reconfigure.h
index aa31b3d03..03fe45ea9 100644
--- a/win/space_reconfigure.h
+++ b/win/space_reconfigure.h
@@ -5,8 +5,12 @@
 */
 #pragma once
 
+// TODO(romangg): It's member of the templated space, so shouldn't be necessary to include.
+#include "user_actions_menu.h"
+
 #include "setup.h"
 #include "x11/hide.h"
+#include "x11/tool_windows.h"
 
 #include "main.h"
 
diff --git a/win/stacking.h b/win/stacking.h
index 26201bbd2..aec7408b2 100644
--- a/win/stacking.h
+++ b/win/stacking.h
@@ -519,25 +519,6 @@ void set_active(Win* win, bool active)
     win->control->update_mouse_grab();
 }
 
-template<typename Win>
-void set_demands_attention(Win* win, bool demand)
-{
-    if (win->control->active()) {
-        demand = false;
-    }
-    if (win->control->demands_attention() == demand) {
-        return;
-    }
-    win->control->set_demands_attention(demand);
-
-    if (win->info) {
-        win->info->setState(demand ? NET::DemandsAttention : NET::States(), NET::DemandsAttention);
-    }
-
-    win->space.clientAttentionChanged(win, demand);
-    Q_EMIT win->demandsAttentionChanged();
-}
-
 template<typename Win>
 void set_minimized(Win* win, bool set, bool avoid_animation = false)
 {
diff --git a/win/wayland/setup.h b/win/wayland/setup.h
index 88fce115d..db49b1bdc 100644
--- a/win/wayland/setup.h
+++ b/win/wayland/setup.h
@@ -5,6 +5,7 @@
 */
 #pragma once
 
+#include "win/activation.h"
 #include "win/control.h"
 #include "win/meta.h"
 #include "win/move.h"
diff --git a/win/x11/actions.h b/win/x11/actions.h
new file mode 100644
index 000000000..eb1ffa698
--- /dev/null
+++ b/win/x11/actions.h
@@ -0,0 +1,69 @@
+/*
+    SPDX-FileCopyrightText: 2022 Roman Gilg <subdiff@gmail.com>
+
+    SPDX-License-Identifier: GPL-2.0-or-later
+*/
+#pragma once
+
+#include <NETWM>
+
+namespace KWin::win::x11
+{
+
+template<typename Win>
+void update_allowed_actions(Win* win, bool force = false)
+{
+    if (!win->control && !force) {
+        return;
+    }
+
+    auto old_allowed_actions = NET::Actions(win->allowed_actions);
+    win->allowed_actions = NET::Actions();
+
+    if (win->isMovable()) {
+        win->allowed_actions |= NET::ActionMove;
+    }
+    if (win->isResizable()) {
+        win->allowed_actions |= NET::ActionResize;
+    }
+    if (win->isMinimizable()) {
+        win->allowed_actions |= NET::ActionMinimize;
+    }
+
+    // Sticky state not supported
+    if (win->isMaximizable()) {
+        win->allowed_actions |= NET::ActionMax;
+    }
+    if (win->userCanSetFullScreen()) {
+        win->allowed_actions |= NET::ActionFullScreen;
+    }
+
+    // Always (Pagers shouldn't show Docks etc.)
+    win->allowed_actions |= NET::ActionChangeDesktop;
+
+    if (win->isCloseable()) {
+        win->allowed_actions |= NET::ActionClose;
+    }
+    if (old_allowed_actions == win->allowed_actions) {
+        return;
+    }
+
+    // TODO: This could be delayed and compressed - It's only for pagers etc. anyway
+    win->info->setAllowedActions(win->allowed_actions);
+
+    // ONLY if relevant features have changed (and the window didn't just get/loose moveresize for
+    // maximization state changes)
+    auto const relevant = ~(NET::ActionMove | NET::ActionResize);
+
+    if ((win->allowed_actions & relevant) != (old_allowed_actions & relevant)) {
+        if ((win->allowed_actions & NET::ActionMinimize)
+            != (old_allowed_actions & NET::ActionMinimize)) {
+            Q_EMIT win->minimizeableChanged(win->allowed_actions & NET::ActionMinimize);
+        }
+        if ((win->allowed_actions & NET::ActionMax) != (old_allowed_actions & NET::ActionMax)) {
+            Q_EMIT win->maximizeableChanged(win->allowed_actions & NET::ActionMax);
+        }
+    }
+}
+
+}
diff --git a/win/x11/activation.h b/win/x11/activation.h
new file mode 100644
index 000000000..4687d843a
--- /dev/null
+++ b/win/x11/activation.h
@@ -0,0 +1,29 @@
+/*
+    SPDX-FileCopyrightText: 2022 Roman Gilg <subdiff@gmail.com>
+
+    SPDX-License-Identifier: GPL-2.0-or-later
+*/
+#pragma once
+
+#include "win/activation.h"
+
+namespace KWin::win::x11
+{
+
+template<typename Win>
+void update_urgency(Win* win)
+{
+    if (win->info->urgency()) {
+        set_demands_attention(win, true);
+    }
+}
+
+template<typename Win>
+void cancel_focus_out_timer(Win* win)
+{
+    if (win->focus_out_timer) {
+        win->focus_out_timer->stop();
+    }
+}
+
+}
diff --git a/win/x11/appmenu.h b/win/x11/appmenu.h
new file mode 100644
index 000000000..0699f546a
--- /dev/null
+++ b/win/x11/appmenu.h
@@ -0,0 +1,57 @@
+/*
+    SPDX-FileCopyrightText: 2022 Roman Gilg <subdiff@gmail.com>
+
+    SPDX-License-Identifier: GPL-2.0-or-later
+*/
+#pragma once
+
+#include "base/x11/xcb/property.h"
+
+namespace KWin::win::x11
+{
+
+template<typename Win>
+base::x11::xcb::string_property fetch_application_menu_service_name(Win* win)
+{
+    return base::x11::xcb::string_property(win->xcb_windows.client,
+                                           win->space.atoms->kde_net_wm_appmenu_service_name);
+}
+
+template<typename Win>
+void read_application_menu_service_name(Win* win, base::x11::xcb::string_property& property)
+{
+    auto const appmenu = win->control->application_menu();
+    win->control->update_application_menu(
+        {QString::fromUtf8(property).toStdString(), appmenu.address.path});
+}
+
+template<typename Win>
+void check_application_menu_service_name(Win* win)
+{
+    auto property = fetch_application_menu_service_name(win);
+    read_application_menu_service_name(win, property);
+}
+
+template<typename Win>
+base::x11::xcb::string_property fetch_application_menu_object_path(Win* win)
+{
+    return base::x11::xcb::string_property(win->xcb_windows.client,
+                                           win->space.atoms->kde_net_wm_appmenu_object_path);
+}
+
+template<typename Win>
+void read_application_menu_object_path(Win* win, base::x11::xcb::string_property& property)
+{
+    auto const appmenu = win->control->application_menu();
+    win->control->update_application_menu(
+        {appmenu.address.name, QString::fromUtf8(property).toStdString()});
+}
+
+template<typename Win>
+void check_application_menu_object_path(Win* win)
+{
+    auto property = fetch_application_menu_object_path(win);
+    read_application_menu_object_path(win, property);
+}
+
+}
diff --git a/win/x11/control.h b/win/x11/control.h
index 6537eefec..1610c60b7 100644
--- a/win/x11/control.h
+++ b/win/x11/control.h
@@ -5,35 +5,21 @@
 */
 #pragma once
 
+#include "actions.h"
+#include "activation.h"
+#include "appmenu.h"
 #include "client_machine.h"
 #include "command.h"
 #include "deco.h"
-#include "geo.h"
-#include "meta.h"
-#include "netinfo.h"
-#include "space.h"
-#include "window.h"
+#include "placement.h"
+#include "session.h"
+#include "user_time.h"
 #include "window_create.h"
-#include "window_find.h"
 #include "xcb.h"
 
 #include "base/logging.h"
-#include "base/x11/xcb/proto.h"
-#include "rules/rule_book.h"
-#include "utils/blocker.h"
-#include "utils/geo.h"
-#include "win/control.h"
-#include "win/controlling.h"
 #include "win/input.h"
 #include "win/layers.h"
-#include "win/meta.h"
-#include "win/placement.h"
-#include "win/screen.h"
-#include "win/setup.h"
-#include "win/space_helpers.h"
-#include "win/stacking.h"
-#include "win/stacking_order.h"
-#include "win/util.h"
 
 #if KWIN_BUILD_TABBOX
 #include "win/tabbox/tabbox.h"
@@ -170,12 +156,6 @@ private:
     Win* m_window;
 };
 
-template<typename Win>
-bool has_user_time_support(Win* win)
-{
-    return win->info->userTime() != -1U;
-}
-
 template<typename Win>
 void embed_client(Win* win, xcb_visualid_t visualid, xcb_colormap_t colormap, uint8_t depth)
 {
@@ -269,46 +249,6 @@ void embed_client(Win* win, xcb_visualid_t visualid, xcb_colormap_t colormap, ui
     win->control->update_mouse_grab();
 }
 
-/**
- * Checks if the window provides its own placement via geometry hint and we want to use it or if
- * this is overriden by us (via window rule).
- */
-template<typename Win>
-bool position_via_hint(Win* win, QRect const& geo, bool ignore_default, QRect& place_area)
-{
-    if (win->control->rules().checkIgnoreGeometry(ignore_default, true)) {
-        // Hint is to be ignored via rule.
-        return false;
-    }
-    if (!win->geometry_hints.has_position()) {
-        return false;
-    }
-
-    // Window provides its own placement via geometry hint.
-
-    // Disobey xinerama placement option for now (#70943)
-    place_area = win->space.clientArea(PlacementArea, geo.center(), win->desktop());
-
-    return true;
-}
-
-template<typename Win>
-bool move_with_force_rule(Win* win, QRect& frame_geo, bool is_inital_placement, QRect& area)
-{
-    auto forced_pos = win->control->rules().checkPosition(geo::invalid_point, is_inital_placement);
-
-    if (forced_pos == geo::invalid_point) {
-        return false;
-    }
-
-    move(win, forced_pos);
-    frame_geo = pending_frame_geometry(win);
-
-    // Don't keep inside workarea if the window has specially configured position
-    area = win->space.clientArea(FullArea, frame_geo.center(), win->desktop());
-    return true;
-}
-
 template<typename Win>
 void prepare_decoration(Win* win)
 {
@@ -325,304 +265,6 @@ void prepare_decoration(Win* win)
     win->updateDecoration(false);
 }
 
-template<typename Win>
-void resize_on_taking_control(Win* win, QRect& frame_geo, bool mapped)
-{
-    // TODO: Is CentralGravity right here, when resizing is done after gravitating?
-    auto const adj_frame_size = adjusted_frame_size(win, frame_geo.size(), size_mode::any);
-    auto const rule_checked_size = win->control->rules().checkSize(adj_frame_size, !mapped);
-    win->setFrameGeometry(QRect(win->pos(), rule_checked_size));
-    frame_geo = pending_frame_geometry(win);
-}
-
-template<typename Win>
-QRect keep_in_placement_area(Win* win, QRect const& area, bool partial)
-{
-    auto impl = [&]() {
-        if (is_special_window(win) || is_toolbar(win)) {
-            return;
-        }
-        if (!win->isMovable()) {
-            return;
-        }
-        keep_in_area(win, area, partial);
-    };
-
-    impl();
-    return pending_frame_geometry(win);
-}
-
-template<typename Win>
-void place_max_fs(Win* win,
-                  QRect& frame_geo,
-                  QRect const& area,
-                  bool keep_in_area,
-                  bool partial_keep_in_area)
-{
-    if (!win->isMaximizable()) {
-        frame_geo = keep_in_placement_area(win, area, partial_keep_in_area);
-        return;
-    }
-    if (win->size().width() < area.width() && win->size().height() < area.height()) {
-        // Window smaller than the screen, do not maximize.
-        frame_geo = keep_in_placement_area(win, area, partial_keep_in_area);
-        return;
-    }
-
-    auto const screen_area
-        = win->space.clientArea(ScreenArea, area.center(), win->desktop()).size();
-    auto const full_area = win->space.clientArea(FullArea, frame_geo.center(), win->desktop());
-    auto const client_size = frame_to_client_size(win, win->size());
-
-    auto pseudo_max{maximize_mode::restore};
-
-    if (win->info->state() & NET::MaxVert) {
-        pseudo_max |= maximize_mode::vertical;
-    }
-    if (win->info->state() & NET::MaxHoriz) {
-        pseudo_max |= maximize_mode::horizontal;
-    }
-
-    if (win->size().width() >= area.width()) {
-        pseudo_max |= maximize_mode::horizontal;
-    }
-    if (win->size().height() >= area.height()) {
-        pseudo_max |= maximize_mode::vertical;
-    }
-
-    // Heuristic: If a decorated client is smaller than the entire screen, the user might want to
-    // move it around (multiscreen) in this case, if the decorated client is bigger than the screen
-    // (+1), we don't take this as an attempt for maximization, but just constrain the size
-    // (the window simply wants to be bigger).
-    auto keep_in_fullscreen_area{false};
-
-    if (win->size().width() < full_area.width()
-        && (client_size.width() > screen_area.width() + 1)) {
-        pseudo_max = pseudo_max & ~maximize_mode::horizontal;
-        keep_in_fullscreen_area = true;
-    }
-    if (win->size().height() < full_area.height()
-        && (client_size.height() > screen_area.height() + 1)) {
-        pseudo_max = pseudo_max & ~maximize_mode::vertical;
-        keep_in_fullscreen_area = true;
-    }
-
-    if (pseudo_max != maximize_mode::restore) {
-        maximize(win, pseudo_max);
-        assert(win->geometry_update.max_mode == pseudo_max);
-
-        // from now on, care about maxmode, since the maximization call will override mode
-        // for fix aspects
-        keep_in_area &= pseudo_max != maximize_mode::full;
-
-        if (pseudo_max == maximize_mode::full) {
-            // Unset restore geometry. On unmaximize we set to a default size and placement.
-            win->restore_geometries.maximize = QRect();
-        } else if (flags(pseudo_max & maximize_mode::vertical)) {
-            // Only vertically maximized. Restore horizontal axis only and choose some default
-            // restoration for the vertical axis.
-            assert(!(pseudo_max & maximize_mode::horizontal));
-            auto restore_height = screen_area.height() * 2 / 3.;
-            auto restore_y = (screen_area.height() - restore_height) / 2;
-            win->restore_geometries.maximize.setY(restore_y);
-            win->restore_geometries.maximize.setHeight(restore_height);
-        } else {
-            // Horizontally maximized only.
-            assert(flags(pseudo_max & maximize_mode::horizontal));
-            auto restore_width = screen_area.width() * 2 / 3.;
-            auto restore_x = (screen_area.width() - restore_width) / 2;
-            win->restore_geometries.maximize.setX(restore_x);
-            win->restore_geometries.maximize.setWidth(restore_width);
-        }
-    }
-
-    if (keep_in_fullscreen_area) {
-        win::keep_in_area(win, full_area, partial_keep_in_area);
-    }
-    if (keep_in_area) {
-        keep_in_placement_area(win, area, partial_keep_in_area);
-    }
-    frame_geo = pending_frame_geometry(win);
-}
-
-template<typename Win>
-bool must_correct_position(Win* win, QRect const& geo, QRect const& area)
-{
-    return win->isMovable() && (geo.x() > area.right() || geo.y() > area.bottom());
-}
-
-template<typename Win>
-QRect place_mapped(Win* win, QRect& frame_geo)
-{
-    auto must_place{false};
-
-    auto area = win->space.clientArea(FullArea, frame_geo.center(), win->desktop());
-    check_offscreen_position(frame_geo, area);
-
-    if (must_correct_position(win, frame_geo, area)) {
-        must_place = true;
-    }
-
-    if (!must_place) {
-        // No standard placement required, just move and optionally force placement and return.
-        move(win, frame_geo.topLeft());
-        resize_on_taking_control(win, frame_geo, true);
-        move_with_force_rule(win, frame_geo, false, area);
-        place_max_fs(win, frame_geo, area, false, true);
-        return area;
-    }
-
-    resize_on_taking_control(win, frame_geo, true);
-
-    if (move_with_force_rule(win, frame_geo, false, area)) {
-        // Placement overriden with force rule.
-        place_max_fs(win, frame_geo, area, true, true);
-        return area;
-    }
-
-    win::place(win, area);
-    frame_geo = pending_frame_geometry(win);
-
-    // The client may have been moved to another screen, update placement area.
-    area = win->space.clientArea(PlacementArea, win);
-
-    place_max_fs(win, frame_geo, area, false, true);
-    return area;
-}
-
-template<typename Win>
-QRect place_session(Win* win, QRect& frame_geo)
-{
-    auto must_place{false};
-
-    auto area = win->space.clientArea(FullArea, frame_geo.center(), win->desktop());
-    check_offscreen_position(frame_geo, area);
-
-    if (must_correct_position(win, frame_geo, area)) {
-        must_place = true;
-    }
-
-    if (!must_place) {
-        // Move instead of further placement.
-        // Session contains the position of the frame geometry before gravitating.
-        move(win, frame_geo.topLeft());
-        resize_on_taking_control(win, frame_geo, true);
-        move_with_force_rule(win, frame_geo, true, area);
-        frame_geo = keep_in_placement_area(win, area, true);
-        return area;
-    }
-
-    resize_on_taking_control(win, frame_geo, true);
-
-    if (move_with_force_rule(win, frame_geo, true, area)) {
-        // Placement overriden with force rule.
-        frame_geo = keep_in_placement_area(win, area, true);
-        return area;
-    }
-
-    win::place(win, area);
-    frame_geo = pending_frame_geometry(win);
-
-    // The client may have been moved to another screen, update placement area.
-    area = win->space.clientArea(PlacementArea, win);
-    frame_geo = keep_in_placement_area(win, area, true);
-    return area;
-}
-
-template<typename Win>
-bool ignore_position_default(Win* win)
-{
-    // TODO(romangg): This function flow can surely be radically simplified.
-    if (win->transient()->lead()) {
-        if (!is_utility(win) && !is_dialog(win) && !is_splash(win)) {
-            return false;
-        }
-        if (!win->info->hasNETSupport()) {
-            return false;
-        }
-        // TODO(romangg): Should we return false here?
-    }
-    if (is_dialog(win) && win->info->hasNETSupport()) {
-        return false;
-    }
-    if (is_on_screen_display(win)) {
-        return true;
-    }
-    if (is_splash(win)) {
-        return true;
-    }
-    return false;
-}
-
-template<typename Win>
-QRect place_unmapped(Win* win, QRect& frame_geo, KStartupInfoData const& asn_data)
-{
-    auto const& base = kwinApp()->get_base();
-    auto output = asn_data.xinerama() == -1
-        ? get_current_output(win->space)
-        : base::get_output(base.get_outputs(), asn_data.xinerama());
-
-    QPoint center;
-    if (output) {
-        output = win->control->rules().checkScreen(output, true);
-        center = output->geometry().center();
-    }
-
-    auto area = win->space.clientArea(PlacementArea, center, win->desktop());
-
-    // Desktop windows' positions are not placed by us.
-    auto must_place = !is_desktop(win);
-
-    if (position_via_hint(win, frame_geo, ignore_position_default(win), area)) {
-        must_place = false;
-    }
-
-    if (!must_place) {
-        move(win, frame_geo.topLeft());
-    }
-
-    resize_on_taking_control(win, frame_geo, false);
-
-    if (move_with_force_rule(win, frame_geo, true, area)) {
-        // Placement overriden with force rule.
-        place_max_fs(win, frame_geo, area, true, false);
-        return area;
-    }
-
-    if (must_place) {
-        win::place(win, area);
-        frame_geo = pending_frame_geometry(win);
-
-        // The client may have been moved to another screen, update placement area.
-        area = win->space.clientArea(PlacementArea, win);
-    }
-
-    place_max_fs(win, frame_geo, area, false, false);
-
-    return area;
-}
-
-template<typename Win>
-QRect place_on_taking_control(Win* win,
-                              QRect& frame_geo,
-                              bool mapped,
-                              win::session_info* session,
-                              KStartupInfoData const& asn_data)
-{
-    if (session) {
-        if (mapped) {
-            qCWarning(KWIN_CORE)
-                << "Unexpected client behavior: session info provided for already mapped client.";
-        }
-        return place_session(win, frame_geo);
-    }
-    if (mapped) {
-        return place_mapped(win, frame_geo);
-    }
-
-    return place_unmapped(win, frame_geo, asn_data);
-}
-
 /**
  * Manages the clients. This means handling the very first maprequest:
  * reparenting, initial geometry, initial state, placement, etc.
@@ -1137,289 +779,6 @@ auto create_controlled_window(xcb_window_t xcb_win, bool isMapped, Space& space)
     return win;
 }
 
-template<typename Space, typename Win>
-void lower_client_within_application(Space* space, Win* window)
-{
-    if (!window) {
-        return;
-    }
-
-    window->control->cancel_auto_raise();
-
-    blocker block(space->stacking_order);
-
-    remove_all(space->stacking_order->pre_stack, window);
-
-    bool lowered = false;
-    // first try to put it below the bottom-most window of the application
-    for (auto it = space->stacking_order->pre_stack.begin();
-         it != space->stacking_order->pre_stack.end();
-         ++it) {
-        auto const& client = *it;
-        if (!client) {
-            continue;
-        }
-        if (win::belong_to_same_client(client, window)) {
-            space->stacking_order->pre_stack.insert(it, window);
-            lowered = true;
-            break;
-        }
-    }
-    if (!lowered)
-        space->stacking_order->pre_stack.push_front(window);
-    // ignore mainwindows
-}
-
-template<typename Space, typename Win>
-void raise_client_within_application(Space* space, Win* window)
-{
-    if (!window) {
-        return;
-    }
-
-    window->control->cancel_auto_raise();
-
-    blocker block(space->stacking_order);
-    // ignore mainwindows
-
-    // first try to put it above the top-most window of the application
-    for (int i = space->stacking_order->pre_stack.size() - 1; i > -1; --i) {
-        auto other = space->stacking_order->pre_stack.at(i);
-        if (!other) {
-            continue;
-        }
-        if (other == window) {
-            // Don't lower it just because it asked to be raised.
-            return;
-        }
-        if (belong_to_same_client(other, window)) {
-            remove_all(space->stacking_order->pre_stack, window);
-            auto it = find(space->stacking_order->pre_stack, other);
-            assert(it != space->stacking_order->pre_stack.end());
-            // Insert after the found one.
-            space->stacking_order->pre_stack.insert(it + 1, window);
-            break;
-        }
-    }
-}
-
-template<typename Space, typename Win>
-void raise_client_request(Space* space,
-                          Win* c,
-                          NET::RequestSource src = NET::FromApplication,
-                          xcb_timestamp_t timestamp = 0)
-{
-    if (src == NET::FromTool || space->allowFullClientRaising(c, timestamp)) {
-        raise_window(space, c);
-    } else {
-        raise_client_within_application(space, c);
-        set_demands_attention(c, true);
-    }
-}
-
-template<typename Space, typename Win>
-void lower_client_request(Space* space,
-                          Win* c,
-                          NET::RequestSource src,
-                          [[maybe_unused]] xcb_timestamp_t /*timestamp*/)
-{
-    // If the client has support for all this focus stealing prevention stuff,
-    // do only lowering within the application, as that's the more logical
-    // variant of lowering when application requests it.
-    // No demanding of attention here of course.
-    if (src == NET::FromTool || !has_user_time_support(c)) {
-        lower_window(space, c);
-    } else {
-        lower_client_within_application(space, c);
-    }
-}
-
-template<typename Win>
-void restack_window(Win* win,
-                    xcb_window_t above,
-                    int detail,
-                    NET::RequestSource src,
-                    xcb_timestamp_t timestamp,
-                    bool send_event = false)
-{
-    Win* other = nullptr;
-    if (detail == XCB_STACK_MODE_OPPOSITE) {
-        other
-            = find_controlled_window<win::x11::window>(win->space, predicate_match::window, above);
-        if (!other) {
-            raise_or_lower_client(&win->space, win);
-            return;
-        }
-
-        auto it = win->space.stacking_order->stack.cbegin();
-        auto end = win->space.stacking_order->stack.cend();
-
-        while (it != end) {
-            if (*it == win) {
-                detail = XCB_STACK_MODE_ABOVE;
-                break;
-            } else if (*it == other) {
-                detail = XCB_STACK_MODE_BELOW;
-                break;
-            }
-            ++it;
-        }
-    } else if (detail == XCB_STACK_MODE_TOP_IF) {
-        other
-            = find_controlled_window<win::x11::window>(win->space, predicate_match::window, above);
-        if (other && other->frameGeometry().intersects(win->frameGeometry())) {
-            raise_client_request(&win->space, win, src, timestamp);
-        }
-        return;
-    } else if (detail == XCB_STACK_MODE_BOTTOM_IF) {
-        other
-            = find_controlled_window<win::x11::window>(win->space, predicate_match::window, above);
-        if (other && other->frameGeometry().intersects(win->frameGeometry())) {
-            lower_client_request(&win->space, win, src, timestamp);
-        }
-        return;
-    }
-
-    if (!other)
-        other
-            = find_controlled_window<win::x11::window>(win->space, predicate_match::window, above);
-
-    if (other && detail == XCB_STACK_MODE_ABOVE) {
-        auto it = win->space.stacking_order->stack.cend();
-        auto begin = win->space.stacking_order->stack.cbegin();
-
-        while (--it != begin) {
-            if (*it == other) {
-                // the other one is top on stack
-                // invalidate and force
-                it = begin;
-                src = NET::FromTool;
-                break;
-            }
-            auto c = qobject_cast<Win*>(*it);
-
-            if (!c
-                || !(is_normal(*it) && c->isShown() && (*it)->isOnCurrentDesktop()
-                     && on_screen(*it, win->central_output))) {
-                continue;
-            }
-
-            if (*(it - 1) == other)
-                break; // "it" is the one above the target one, stack below "it"
-        }
-
-        if (it != begin && (*(it - 1) == other)) {
-            other = qobject_cast<Win*>(*it);
-        } else {
-            other = nullptr;
-        }
-    }
-
-    if (other) {
-        restack(&win->space, win, other);
-    } else if (detail == XCB_STACK_MODE_BELOW) {
-        lower_client_request(&win->space, win, src, timestamp);
-    } else if (detail == XCB_STACK_MODE_ABOVE) {
-        raise_client_request(&win->space, win, src, timestamp);
-    }
-
-    if (send_event) {
-        send_synthetic_configure_notify(win, frame_to_client_rect(win, win->frameGeometry()));
-    }
-}
-
-template<typename Win>
-void update_allowed_actions(Win* win, bool force = false)
-{
-    if (!win->control && !force) {
-        return;
-    }
-
-    auto old_allowed_actions = NET::Actions(win->allowed_actions);
-    win->allowed_actions = NET::Actions();
-
-    if (win->isMovable()) {
-        win->allowed_actions |= NET::ActionMove;
-    }
-    if (win->isResizable()) {
-        win->allowed_actions |= NET::ActionResize;
-    }
-    if (win->isMinimizable()) {
-        win->allowed_actions |= NET::ActionMinimize;
-    }
-
-    // Sticky state not supported
-    if (win->isMaximizable()) {
-        win->allowed_actions |= NET::ActionMax;
-    }
-    if (win->userCanSetFullScreen()) {
-        win->allowed_actions |= NET::ActionFullScreen;
-    }
-
-    // Always (Pagers shouldn't show Docks etc.)
-    win->allowed_actions |= NET::ActionChangeDesktop;
-
-    if (win->isCloseable()) {
-        win->allowed_actions |= NET::ActionClose;
-    }
-    if (old_allowed_actions == win->allowed_actions) {
-        return;
-    }
-
-    // TODO: This could be delayed and compressed - It's only for pagers etc. anyway
-    win->info->setAllowedActions(win->allowed_actions);
-
-    // ONLY if relevant features have changed (and the window didn't just get/loose moveresize for
-    // maximization state changes)
-    auto const relevant = ~(NET::ActionMove | NET::ActionResize);
-
-    if ((win->allowed_actions & relevant) != (old_allowed_actions & relevant)) {
-        if ((win->allowed_actions & NET::ActionMinimize)
-            != (old_allowed_actions & NET::ActionMinimize)) {
-            Q_EMIT win->minimizeableChanged(win->allowed_actions & NET::ActionMinimize);
-        }
-        if ((win->allowed_actions & NET::ActionMax) != (old_allowed_actions & NET::ActionMax)) {
-            Q_EMIT win->maximizeableChanged(win->allowed_actions & NET::ActionMax);
-        }
-    }
-}
-
-/**
- * Updates the user time (time of last action in the active window).
- * This is called inside  kwin for every action with the window
- * that qualifies for user interaction (clicking on it, activate it
- * externally, etc.).
- */
-template<typename Win>
-void update_user_time(Win* win, xcb_timestamp_t time = XCB_TIME_CURRENT_TIME)
-{
-    // copied in Group::updateUserTime
-    if (time == XCB_TIME_CURRENT_TIME) {
-        kwinApp()->update_x11_time_from_clock();
-        time = xTime();
-    }
-    if (time != -1U
-        && (win->user_time == XCB_TIME_CURRENT_TIME
-            || NET::timestampCompare(time, win->user_time) > 0)) {
-        // time > user_time
-        win->user_time = time;
-    }
-
-    win->group()->updateUserTime(win->user_time);
-}
-
-template<typename Win>
-xcb_timestamp_t read_user_creation_time(Win* win)
-{
-    base::x11::xcb::property prop(false,
-                                  win->xcb_window,
-                                  win->space.atoms->kde_net_wm_user_creation_time,
-                                  XCB_ATOM_CARDINAL,
-                                  0,
-                                  1);
-    return prop.value<xcb_timestamp_t>(-1);
-}
-
 template<typename Win>
 xcb_timestamp_t read_user_time_map_timestamp(Win* win,
                                              const KStartupInfoId* asn_id,
@@ -1513,235 +872,4 @@ xcb_timestamp_t read_user_time_map_timestamp(Win* win,
     return time;
 }
 
-template<typename Win>
-xcb_timestamp_t user_time(Win* win)
-{
-    auto time = win->user_time;
-    if (time == 0) {
-        // doesn't want focus after showing
-        return 0;
-    }
-
-    auto group = win->group();
-    assert(group);
-
-    if (time == -1U
-        || (group->user_time != -1U && NET::timestampCompare(group->user_time, time) > 0)) {
-        time = group->user_time;
-    }
-    return time;
-}
-
-template<typename Win>
-void startup_id_changed(Win* win)
-{
-    KStartupInfoId asn_id;
-    KStartupInfoData asn_data;
-    bool asn_valid = win->space.checkStartupNotification(win->xcb_window, asn_id, asn_data);
-    if (!asn_valid)
-        return;
-    // If the ASN contains desktop, move it to the desktop, otherwise move it to the current
-    // desktop (since the new ASN should make the window act like if it's a new application
-    // launched). However don't affect the window's desktop if it's set to be on all desktops.
-    int desktop = win->space.virtual_desktop_manager->current();
-    if (asn_data.desktop() != 0)
-        desktop = asn_data.desktop();
-    if (!win->isOnAllDesktops()) {
-        win->space.sendClientToDesktop(win, desktop, true);
-    }
-    if (asn_data.xinerama() != -1) {
-        auto output = base::get_output(kwinApp()->get_base().get_outputs(), asn_data.xinerama());
-        if (output) {
-            send_to_screen(win->space, win, *output);
-        }
-    }
-    auto const timestamp = asn_id.timestamp();
-    if (timestamp != 0) {
-        auto activate = win->space.allowClientActivation(win, timestamp);
-        if (asn_data.desktop() != 0 && !win->isOnCurrentDesktop()) {
-            // it was started on different desktop than current one
-            activate = false;
-        }
-        if (activate) {
-            win->space.activateClient(win);
-        } else {
-            set_demands_attention(win, true);
-        }
-    }
-}
-
-template<typename Win>
-void update_urgency(Win* win)
-{
-    if (win->info->urgency()) {
-        set_demands_attention(win, true);
-    }
-}
-
-template<typename Win>
-base::x11::xcb::property fetch_first_in_tabbox(Win* win)
-{
-    auto& atoms = win->space.atoms;
-    return base::x11::xcb::property(false,
-                                    win->xcb_windows.client,
-                                    atoms->kde_first_in_window_list,
-                                    atoms->kde_first_in_window_list,
-                                    0,
-                                    1);
-}
-
-template<typename Win>
-void read_first_in_tabbox(Win* win, base::x11::xcb::property& property)
-{
-    win->control->set_first_in_tabbox(
-        property.to_bool(32, win->space.atoms->kde_first_in_window_list));
-}
-
-template<typename Win>
-void update_first_in_tabbox(Win* win)
-{
-    // TODO: move into KWindowInfo
-    auto property = fetch_first_in_tabbox(win);
-    read_first_in_tabbox(win, property);
-}
-
-template<typename Win>
-void cancel_focus_out_timer(Win* win)
-{
-    if (win->focus_out_timer) {
-        win->focus_out_timer->stop();
-    }
-}
-
-template<typename Win>
-base::x11::xcb::property fetch_show_on_screen_edge(Win* win)
-{
-    return base::x11::xcb::property(
-        false, win->xcb_window, win->space.atoms->kde_screen_edge_show, XCB_ATOM_CARDINAL, 0, 1);
-}
-
-template<typename Win>
-void read_show_on_screen_edge(Win* win, base::x11::xcb::property& property)
-{
-    // value comes in two parts, edge in the lower byte
-    // then the type in the upper byte
-    // 0 = autohide
-    // 1 = raise in front on activate
-
-    auto const value = property.value<uint32_t>(ElectricNone);
-    auto border = ElectricNone;
-
-    switch (value & 0xFF) {
-    case 0:
-        border = ElectricTop;
-        break;
-    case 1:
-        border = ElectricRight;
-        break;
-    case 2:
-        border = ElectricBottom;
-        break;
-    case 3:
-        border = ElectricLeft;
-        break;
-    }
-
-    if (border != ElectricNone) {
-        QObject::disconnect(win->connections.edge_remove);
-        QObject::disconnect(win->connections.edge_geometry);
-        auto successfullyHidden = false;
-
-        if (((value >> 8) & 0xFF) == 1) {
-            set_keep_below(win, true);
-
-            // request could have failed due to user kwin rules
-            successfullyHidden = win->control->keep_below();
-
-            win->connections.edge_remove
-                = QObject::connect(win, &Win::keepBelowChanged, win, [win]() {
-                      if (!win->control->keep_below()) {
-                          win->space.edges->reserve(win, ElectricNone);
-                      }
-                  });
-        } else {
-            win->hideClient(true);
-            successfullyHidden = win->isHiddenInternal();
-
-            win->connections.edge_geometry
-                = QObject::connect(win, &Win::frame_geometry_changed, win, [win, border]() {
-                      win->hideClient(true);
-                      win->space.edges->reserve(win, border);
-                  });
-        }
-
-        if (successfullyHidden) {
-            win->space.edges->reserve(win, border);
-        } else {
-            win->space.edges->reserve(win, ElectricNone);
-        }
-    } else if (!property.is_null() && property->type != XCB_ATOM_NONE) {
-        // property value is incorrect, delete the property
-        // so that the client knows that it is not hidden
-        xcb_delete_property(connection(), win->xcb_window, win->space.atoms->kde_screen_edge_show);
-    } else {
-        // restore
-        // TODO: add proper unreserve
-
-        // this will call showOnScreenEdge to reset the state
-        QObject::disconnect(win->connections.edge_geometry);
-        win->space.edges->reserve(win, ElectricNone);
-    }
-}
-
-template<typename Win>
-void update_show_on_screen_edge(Win* win)
-{
-    auto property = fetch_show_on_screen_edge(win);
-    read_show_on_screen_edge(win, property);
-}
-
-template<typename Win>
-base::x11::xcb::string_property fetch_application_menu_service_name(Win* win)
-{
-    return base::x11::xcb::string_property(win->xcb_windows.client,
-                                           win->space.atoms->kde_net_wm_appmenu_service_name);
-}
-
-template<typename Win>
-void read_application_menu_service_name(Win* win, base::x11::xcb::string_property& property)
-{
-    auto const appmenu = win->control->application_menu();
-    win->control->update_application_menu(
-        {QString::fromUtf8(property).toStdString(), appmenu.address.path});
-}
-
-template<typename Win>
-void check_application_menu_service_name(Win* win)
-{
-    auto property = fetch_application_menu_service_name(win);
-    read_application_menu_service_name(win, property);
-}
-
-template<typename Win>
-base::x11::xcb::string_property fetch_application_menu_object_path(Win* win)
-{
-    return base::x11::xcb::string_property(win->xcb_windows.client,
-                                           win->space.atoms->kde_net_wm_appmenu_object_path);
-}
-
-template<typename Win>
-void read_application_menu_object_path(Win* win, base::x11::xcb::string_property& property)
-{
-    auto const appmenu = win->control->application_menu();
-    win->control->update_application_menu(
-        {appmenu.address.name, QString::fromUtf8(property).toStdString()});
-}
-
-template<typename Win>
-void check_application_menu_object_path(Win* win)
-{
-    auto property = fetch_application_menu_object_path(win);
-    read_application_menu_object_path(win, property);
-}
-
 }
diff --git a/win/x11/event.h b/win/x11/event.h
index 19f15db3f..7a493dda1 100644
--- a/win/x11/event.h
+++ b/win/x11/event.h
@@ -5,14 +5,19 @@
 */
 #pragma once
 
+#include "actions.h"
+#include "activation.h"
 #include "client.h"
-#include "control.h"
 #include "geo.h"
 #include "meta.h"
+#include "stacking.h"
+#include "startup_info.h"
 #include "transient.h"
+#include "user_time.h"
 #include "window_release.h"
 
 #include "base/x11/xcb/qt_types.h"
+#include "win/activation.h"
 #include "win/input.h"
 #include "win/meta.h"
 #include "win/space.h"
diff --git a/win/x11/geo.h b/win/x11/geo.h
index 9055e87eb..b347fb9ab 100644
--- a/win/x11/geo.h
+++ b/win/x11/geo.h
@@ -5,7 +5,6 @@
 */
 #pragma once
 
-#include "control.h"
 #include "scene.h"
 
 #include "win/setup.h"
diff --git a/win/x11/moving_window_filter.h b/win/x11/moving_window_filter.h
index 6c8c62152..63d5b83eb 100644
--- a/win/x11/moving_window_filter.h
+++ b/win/x11/moving_window_filter.h
@@ -8,6 +8,7 @@
 #include "base/x11/event_filter.h"
 
 #include "win/x11/event.h"
+#include "win/x11/stacking.h"
 #include "win/x11/window.h"
 
 #include <KKeyServer>
diff --git a/win/x11/netinfo.cpp b/win/x11/netinfo.cpp
index 4be723420..96112944d 100644
--- a/win/x11/netinfo.cpp
+++ b/win/x11/netinfo.cpp
@@ -31,6 +31,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "win/virtual_desktops.h"
 #include "win/x11/event.h"
 #include "win/x11/geo.h"
+#include "win/x11/stacking.h"
 #include "win/x11/window.h"
 
 #include <QDebug>
diff --git a/win/x11/placement.h b/win/x11/placement.h
new file mode 100644
index 000000000..3fc343260
--- /dev/null
+++ b/win/x11/placement.h
@@ -0,0 +1,356 @@
+/*
+    SPDX-FileCopyrightText: 2022 Roman Gilg <subdiff@gmail.com>
+
+    SPDX-License-Identifier: GPL-2.0-or-later
+*/
+#pragma once
+
+#include "base/x11/xcb/property.h"
+#include "utils/geo.h"
+#include "win/geo.h"
+#include "win/placement.h"
+
+#include <KStartupInfo>
+
+namespace KWin::win::x11
+{
+
+/**
+ * Checks if the window provides its own placement via geometry hint and we want to use it or if
+ * this is overriden by us (via window rule).
+ */
+template<typename Win>
+bool position_via_hint(Win* win, QRect const& geo, bool ignore_default, QRect& place_area)
+{
+    if (win->control->rules().checkIgnoreGeometry(ignore_default, true)) {
+        // Hint is to be ignored via rule.
+        return false;
+    }
+    if (!win->geometry_hints.has_position()) {
+        return false;
+    }
+
+    // Window provides its own placement via geometry hint.
+
+    // Disobey xinerama placement option for now (#70943)
+    place_area = win->space.clientArea(PlacementArea, geo.center(), win->desktop());
+
+    return true;
+}
+
+template<typename Win>
+bool move_with_force_rule(Win* win, QRect& frame_geo, bool is_inital_placement, QRect& area)
+{
+    auto forced_pos = win->control->rules().checkPosition(geo::invalid_point, is_inital_placement);
+
+    if (forced_pos == geo::invalid_point) {
+        return false;
+    }
+
+    move(win, forced_pos);
+    frame_geo = pending_frame_geometry(win);
+
+    // Don't keep inside workarea if the window has specially configured position
+    area = win->space.clientArea(FullArea, frame_geo.center(), win->desktop());
+    return true;
+}
+
+template<typename Win>
+void resize_on_taking_control(Win* win, QRect& frame_geo, bool mapped)
+{
+    // TODO: Is CentralGravity right here, when resizing is done after gravitating?
+    auto const adj_frame_size = adjusted_frame_size(win, frame_geo.size(), size_mode::any);
+    auto const rule_checked_size = win->control->rules().checkSize(adj_frame_size, !mapped);
+    win->setFrameGeometry(QRect(win->pos(), rule_checked_size));
+    frame_geo = pending_frame_geometry(win);
+}
+
+template<typename Win>
+QRect keep_in_placement_area(Win* win, QRect const& area, bool partial)
+{
+    auto impl = [&]() {
+        if (is_special_window(win) || is_toolbar(win)) {
+            return;
+        }
+        if (!win->isMovable()) {
+            return;
+        }
+        keep_in_area(win, area, partial);
+    };
+
+    impl();
+    return pending_frame_geometry(win);
+}
+
+template<typename Win>
+void place_max_fs(Win* win,
+                  QRect& frame_geo,
+                  QRect const& area,
+                  bool keep_in_area,
+                  bool partial_keep_in_area)
+{
+    if (!win->isMaximizable()) {
+        frame_geo = keep_in_placement_area(win, area, partial_keep_in_area);
+        return;
+    }
+    if (win->size().width() < area.width() && win->size().height() < area.height()) {
+        // Window smaller than the screen, do not maximize.
+        frame_geo = keep_in_placement_area(win, area, partial_keep_in_area);
+        return;
+    }
+
+    auto const screen_area
+        = win->space.clientArea(ScreenArea, area.center(), win->desktop()).size();
+    auto const full_area = win->space.clientArea(FullArea, frame_geo.center(), win->desktop());
+    auto const client_size = frame_to_client_size(win, win->size());
+
+    auto pseudo_max{maximize_mode::restore};
+
+    if (win->info->state() & NET::MaxVert) {
+        pseudo_max |= maximize_mode::vertical;
+    }
+    if (win->info->state() & NET::MaxHoriz) {
+        pseudo_max |= maximize_mode::horizontal;
+    }
+
+    if (win->size().width() >= area.width()) {
+        pseudo_max |= maximize_mode::horizontal;
+    }
+    if (win->size().height() >= area.height()) {
+        pseudo_max |= maximize_mode::vertical;
+    }
+
+    // Heuristic: If a decorated client is smaller than the entire screen, the user might want to
+    // move it around (multiscreen) in this case, if the decorated client is bigger than the screen
+    // (+1), we don't take this as an attempt for maximization, but just constrain the size
+    // (the window simply wants to be bigger).
+    auto keep_in_fullscreen_area{false};
+
+    if (win->size().width() < full_area.width()
+        && (client_size.width() > screen_area.width() + 1)) {
+        pseudo_max = pseudo_max & ~maximize_mode::horizontal;
+        keep_in_fullscreen_area = true;
+    }
+    if (win->size().height() < full_area.height()
+        && (client_size.height() > screen_area.height() + 1)) {
+        pseudo_max = pseudo_max & ~maximize_mode::vertical;
+        keep_in_fullscreen_area = true;
+    }
+
+    if (pseudo_max != maximize_mode::restore) {
+        maximize(win, pseudo_max);
+        assert(win->geometry_update.max_mode == pseudo_max);
+
+        // from now on, care about maxmode, since the maximization call will override mode
+        // for fix aspects
+        keep_in_area &= pseudo_max != maximize_mode::full;
+
+        if (pseudo_max == maximize_mode::full) {
+            // Unset restore geometry. On unmaximize we set to a default size and placement.
+            win->restore_geometries.maximize = QRect();
+        } else if (flags(pseudo_max & maximize_mode::vertical)) {
+            // Only vertically maximized. Restore horizontal axis only and choose some default
+            // restoration for the vertical axis.
+            assert(!(pseudo_max & maximize_mode::horizontal));
+            auto restore_height = screen_area.height() * 2 / 3.;
+            auto restore_y = (screen_area.height() - restore_height) / 2;
+            win->restore_geometries.maximize.setY(restore_y);
+            win->restore_geometries.maximize.setHeight(restore_height);
+        } else {
+            // Horizontally maximized only.
+            assert(flags(pseudo_max & maximize_mode::horizontal));
+            auto restore_width = screen_area.width() * 2 / 3.;
+            auto restore_x = (screen_area.width() - restore_width) / 2;
+            win->restore_geometries.maximize.setX(restore_x);
+            win->restore_geometries.maximize.setWidth(restore_width);
+        }
+    }
+
+    if (keep_in_fullscreen_area) {
+        win::keep_in_area(win, full_area, partial_keep_in_area);
+    }
+    if (keep_in_area) {
+        keep_in_placement_area(win, area, partial_keep_in_area);
+    }
+    frame_geo = pending_frame_geometry(win);
+}
+
+template<typename Win>
+bool must_correct_position(Win* win, QRect const& geo, QRect const& area)
+{
+    return win->isMovable() && (geo.x() > area.right() || geo.y() > area.bottom());
+}
+
+template<typename Win>
+QRect place_mapped(Win* win, QRect& frame_geo)
+{
+    auto must_place{false};
+
+    auto area = win->space.clientArea(FullArea, frame_geo.center(), win->desktop());
+    check_offscreen_position(frame_geo, area);
+
+    if (must_correct_position(win, frame_geo, area)) {
+        must_place = true;
+    }
+
+    if (!must_place) {
+        // No standard placement required, just move and optionally force placement and return.
+        move(win, frame_geo.topLeft());
+        resize_on_taking_control(win, frame_geo, true);
+        move_with_force_rule(win, frame_geo, false, area);
+        place_max_fs(win, frame_geo, area, false, true);
+        return area;
+    }
+
+    resize_on_taking_control(win, frame_geo, true);
+
+    if (move_with_force_rule(win, frame_geo, false, area)) {
+        // Placement overriden with force rule.
+        place_max_fs(win, frame_geo, area, true, true);
+        return area;
+    }
+
+    win::place(win, area);
+    frame_geo = pending_frame_geometry(win);
+
+    // The client may have been moved to another screen, update placement area.
+    area = win->space.clientArea(PlacementArea, win);
+
+    place_max_fs(win, frame_geo, area, false, true);
+    return area;
+}
+
+template<typename Win>
+QRect place_session(Win* win, QRect& frame_geo)
+{
+    auto must_place{false};
+
+    auto area = win->space.clientArea(FullArea, frame_geo.center(), win->desktop());
+    check_offscreen_position(frame_geo, area);
+
+    if (must_correct_position(win, frame_geo, area)) {
+        must_place = true;
+    }
+
+    if (!must_place) {
+        // Move instead of further placement.
+        // Session contains the position of the frame geometry before gravitating.
+        move(win, frame_geo.topLeft());
+        resize_on_taking_control(win, frame_geo, true);
+        move_with_force_rule(win, frame_geo, true, area);
+        frame_geo = keep_in_placement_area(win, area, true);
+        return area;
+    }
+
+    resize_on_taking_control(win, frame_geo, true);
+
+    if (move_with_force_rule(win, frame_geo, true, area)) {
+        // Placement overriden with force rule.
+        frame_geo = keep_in_placement_area(win, area, true);
+        return area;
+    }
+
+    win::place(win, area);
+    frame_geo = pending_frame_geometry(win);
+
+    // The client may have been moved to another screen, update placement area.
+    area = win->space.clientArea(PlacementArea, win);
+    frame_geo = keep_in_placement_area(win, area, true);
+    return area;
+}
+
+template<typename Win>
+bool ignore_position_default(Win* win)
+{
+    // TODO(romangg): This function flow can surely be radically simplified.
+    if (win->transient()->lead()) {
+        if (!is_utility(win) && !is_dialog(win) && !is_splash(win)) {
+            return false;
+        }
+        if (!win->info->hasNETSupport()) {
+            return false;
+        }
+        // TODO(romangg): Should we return false here?
+    }
+    if (is_dialog(win) && win->info->hasNETSupport()) {
+        return false;
+    }
+    if (is_on_screen_display(win)) {
+        return true;
+    }
+    if (is_splash(win)) {
+        return true;
+    }
+    return false;
+}
+
+template<typename Win>
+QRect place_unmapped(Win* win, QRect& frame_geo, KStartupInfoData const& asn_data)
+{
+    auto const& base = kwinApp()->get_base();
+    auto output = asn_data.xinerama() == -1
+        ? get_current_output(win->space)
+        : base::get_output(base.get_outputs(), asn_data.xinerama());
+
+    QPoint center;
+    if (output) {
+        output = win->control->rules().checkScreen(output, true);
+        center = output->geometry().center();
+    }
+
+    auto area = win->space.clientArea(PlacementArea, center, win->desktop());
+
+    // Desktop windows' positions are not placed by us.
+    auto must_place = !is_desktop(win);
+
+    if (position_via_hint(win, frame_geo, ignore_position_default(win), area)) {
+        must_place = false;
+    }
+
+    if (!must_place) {
+        move(win, frame_geo.topLeft());
+    }
+
+    resize_on_taking_control(win, frame_geo, false);
+
+    if (move_with_force_rule(win, frame_geo, true, area)) {
+        // Placement overriden with force rule.
+        place_max_fs(win, frame_geo, area, true, false);
+        return area;
+    }
+
+    if (must_place) {
+        win::place(win, area);
+        frame_geo = pending_frame_geometry(win);
+
+        // The client may have been moved to another screen, update placement area.
+        area = win->space.clientArea(PlacementArea, win);
+    }
+
+    place_max_fs(win, frame_geo, area, false, false);
+
+    return area;
+}
+
+template<typename Win>
+QRect place_on_taking_control(Win* win,
+                              QRect& frame_geo,
+                              bool mapped,
+                              win::session_info* session,
+                              KStartupInfoData const& asn_data)
+{
+    if (session) {
+        if (mapped) {
+            qCWarning(KWIN_CORE)
+                << "Unexpected client behavior: session info provided for already mapped client.";
+        }
+        return place_session(win, frame_geo);
+    }
+    if (mapped) {
+        return place_mapped(win, frame_geo);
+    }
+
+    return place_unmapped(win, frame_geo, asn_data);
+}
+
+}
diff --git a/win/x11/scene.h b/win/x11/scene.h
index 30028221b..1533847b9 100644
--- a/win/x11/scene.h
+++ b/win/x11/scene.h
@@ -9,6 +9,7 @@
 
 #include "base/x11/grabs.h"
 #include "base/x11/xcb/proto.h"
+#include "win/geo.h"
 #include "win/scene.h"
 
 namespace KWin::win::x11
diff --git a/win/x11/session.h b/win/x11/session.h
new file mode 100644
index 000000000..a093b40ca
--- /dev/null
+++ b/win/x11/session.h
@@ -0,0 +1,36 @@
+/*
+    SPDX-FileCopyrightText: 2022 Roman Gilg <subdiff@gmail.com>
+
+    SPDX-License-Identifier: GPL-2.0-or-later
+*/
+#pragma once
+
+namespace KWin::win::x11
+{
+
+template<typename Space, typename Window>
+void restore_session_stacking_order(Space space, Window* c)
+{
+    if (c->sm_stacking_order < 0) {
+        return;
+    }
+
+    blocker block(space->stacking_order);
+    remove_all(space->stacking_order->pre_stack, c);
+
+    for (auto it = space->stacking_order->pre_stack.begin(); // from bottom
+         it != space->stacking_order->pre_stack.end();
+         ++it) {
+        auto current = qobject_cast<Window*>(*it);
+        if (!current) {
+            continue;
+        }
+        if (current->sm_stacking_order > c->sm_stacking_order) {
+            space->stacking_order->pre_stack.insert(it, c);
+            return;
+        }
+    }
+    space->stacking_order->pre_stack.push_back(c);
+}
+
+}
diff --git a/win/x11/space.h b/win/x11/space.h
index 4d221b860..f2e9e3adf 100644
--- a/win/x11/space.h
+++ b/win/x11/space.h
@@ -40,31 +40,6 @@ private:
     std::unique_ptr<base::x11::event_filter> edges_filter;
 };
 
-template<typename Space, typename Window>
-void restore_session_stacking_order(Space space, Window* c)
-{
-    if (c->sm_stacking_order < 0) {
-        return;
-    }
-
-    blocker block(space->stacking_order);
-    remove_all(space->stacking_order->pre_stack, c);
-
-    for (auto it = space->stacking_order->pre_stack.begin(); // from bottom
-         it != space->stacking_order->pre_stack.end();
-         ++it) {
-        auto current = qobject_cast<Window*>(*it);
-        if (!current) {
-            continue;
-        }
-        if (current->sm_stacking_order > c->sm_stacking_order) {
-            space->stacking_order->pre_stack.insert(it, c);
-            return;
-        }
-    }
-    space->stacking_order->pre_stack.push_back(c);
-}
-
 /**
  * Some fullscreen effects have to raise the screenedge on top of an input window, thus all windows
  * this function puts them back where they belong for regular use and is some cheap variant of
diff --git a/win/x11/space_event.h b/win/x11/space_event.h
index e18079e7d..a362ee966 100644
--- a/win/x11/space_event.h
+++ b/win/x11/space_event.h
@@ -5,6 +5,7 @@
 */
 #pragma once
 
+#include "control.h"
 #include "event.h"
 #include "unmanaged.h"
 
diff --git a/win/x11/space_setup.h b/win/x11/space_setup.h
index 2c229ba5e..bfbd0a0ed 100644
--- a/win/x11/space_setup.h
+++ b/win/x11/space_setup.h
@@ -6,6 +6,7 @@
 #pragma once
 
 #include "color_mapper.h"
+#include "control.h"
 #include "moving_window_filter.h"
 #include "space_event.h"
 #include "sync_alarm_filter.h"
diff --git a/win/x11/stacking.h b/win/x11/stacking.h
index 6bd2f142e..6a6ae5171 100644
--- a/win/x11/stacking.h
+++ b/win/x11/stacking.h
@@ -9,11 +9,13 @@
 #include "hide.h"
 #include "netinfo.h"
 #include "window.h"
+#include "window_find.h"
 
 #include "base/output_helpers.h"
 #include "base/platform.h"
 #include "main.h"
 #include "toplevel.h"
+#include "win/activation.h"
 
 #include <deque>
 
@@ -157,4 +159,195 @@ void propagate_clients(Space& space, bool propagate_new_clients)
     rootInfo()->setClientListStacking(stacked_clients.data(), stacked_clients.size());
 }
 
+template<typename Space, typename Win>
+void lower_client_within_application(Space* space, Win* window)
+{
+    if (!window) {
+        return;
+    }
+
+    window->control->cancel_auto_raise();
+
+    blocker block(space->stacking_order);
+
+    remove_all(space->stacking_order->pre_stack, window);
+
+    bool lowered = false;
+    // first try to put it below the bottom-most window of the application
+    for (auto it = space->stacking_order->pre_stack.begin();
+         it != space->stacking_order->pre_stack.end();
+         ++it) {
+        auto const& client = *it;
+        if (!client) {
+            continue;
+        }
+        if (win::belong_to_same_client(client, window)) {
+            space->stacking_order->pre_stack.insert(it, window);
+            lowered = true;
+            break;
+        }
+    }
+    if (!lowered)
+        space->stacking_order->pre_stack.push_front(window);
+    // ignore mainwindows
+}
+
+template<typename Space, typename Win>
+void raise_client_within_application(Space* space, Win* window)
+{
+    if (!window) {
+        return;
+    }
+
+    window->control->cancel_auto_raise();
+
+    blocker block(space->stacking_order);
+    // ignore mainwindows
+
+    // first try to put it above the top-most window of the application
+    for (int i = space->stacking_order->pre_stack.size() - 1; i > -1; --i) {
+        auto other = space->stacking_order->pre_stack.at(i);
+        if (!other) {
+            continue;
+        }
+        if (other == window) {
+            // Don't lower it just because it asked to be raised.
+            return;
+        }
+        if (belong_to_same_client(other, window)) {
+            remove_all(space->stacking_order->pre_stack, window);
+            auto it = find(space->stacking_order->pre_stack, other);
+            assert(it != space->stacking_order->pre_stack.end());
+            // Insert after the found one.
+            space->stacking_order->pre_stack.insert(it + 1, window);
+            break;
+        }
+    }
+}
+
+template<typename Space, typename Win>
+void raise_client_request(Space* space,
+                          Win* c,
+                          NET::RequestSource src = NET::FromApplication,
+                          xcb_timestamp_t timestamp = 0)
+{
+    if (src == NET::FromTool || space->allowFullClientRaising(c, timestamp)) {
+        raise_window(space, c);
+    } else {
+        raise_client_within_application(space, c);
+        set_demands_attention(c, true);
+    }
+}
+
+template<typename Space, typename Win>
+void lower_client_request(Space* space,
+                          Win* c,
+                          NET::RequestSource src,
+                          [[maybe_unused]] xcb_timestamp_t /*timestamp*/)
+{
+    // If the client has support for all this focus stealing prevention stuff,
+    // do only lowering within the application, as that's the more logical
+    // variant of lowering when application requests it.
+    // No demanding of attention here of course.
+    if (src == NET::FromTool || !has_user_time_support(c)) {
+        lower_window(space, c);
+    } else {
+        lower_client_within_application(space, c);
+    }
+}
+
+template<typename Win>
+void restack_window(Win* win,
+                    xcb_window_t above,
+                    int detail,
+                    NET::RequestSource src,
+                    xcb_timestamp_t timestamp,
+                    bool send_event = false)
+{
+    Win* other = nullptr;
+    if (detail == XCB_STACK_MODE_OPPOSITE) {
+        other
+            = find_controlled_window<win::x11::window>(win->space, predicate_match::window, above);
+        if (!other) {
+            raise_or_lower_client(&win->space, win);
+            return;
+        }
+
+        auto it = win->space.stacking_order->stack.cbegin();
+        auto end = win->space.stacking_order->stack.cend();
+
+        while (it != end) {
+            if (*it == win) {
+                detail = XCB_STACK_MODE_ABOVE;
+                break;
+            } else if (*it == other) {
+                detail = XCB_STACK_MODE_BELOW;
+                break;
+            }
+            ++it;
+        }
+    } else if (detail == XCB_STACK_MODE_TOP_IF) {
+        other
+            = find_controlled_window<win::x11::window>(win->space, predicate_match::window, above);
+        if (other && other->frameGeometry().intersects(win->frameGeometry())) {
+            raise_client_request(&win->space, win, src, timestamp);
+        }
+        return;
+    } else if (detail == XCB_STACK_MODE_BOTTOM_IF) {
+        other
+            = find_controlled_window<win::x11::window>(win->space, predicate_match::window, above);
+        if (other && other->frameGeometry().intersects(win->frameGeometry())) {
+            lower_client_request(&win->space, win, src, timestamp);
+        }
+        return;
+    }
+
+    if (!other)
+        other
+            = find_controlled_window<win::x11::window>(win->space, predicate_match::window, above);
+
+    if (other && detail == XCB_STACK_MODE_ABOVE) {
+        auto it = win->space.stacking_order->stack.cend();
+        auto begin = win->space.stacking_order->stack.cbegin();
+
+        while (--it != begin) {
+            if (*it == other) {
+                // the other one is top on stack
+                // invalidate and force
+                it = begin;
+                src = NET::FromTool;
+                break;
+            }
+            auto c = qobject_cast<Win*>(*it);
+
+            if (!c
+                || !(is_normal(*it) && c->isShown() && (*it)->isOnCurrentDesktop()
+                     && on_screen(*it, win->central_output))) {
+                continue;
+            }
+
+            if (*(it - 1) == other)
+                break; // "it" is the one above the target one, stack below "it"
+        }
+
+        if (it != begin && (*(it - 1) == other)) {
+            other = qobject_cast<Win*>(*it);
+        } else {
+            other = nullptr;
+        }
+    }
+
+    if (other) {
+        restack(&win->space, win, other);
+    } else if (detail == XCB_STACK_MODE_BELOW) {
+        lower_client_request(&win->space, win, src, timestamp);
+    } else if (detail == XCB_STACK_MODE_ABOVE) {
+        raise_client_request(&win->space, win, src, timestamp);
+    }
+
+    if (send_event) {
+        send_synthetic_configure_notify(win, frame_to_client_rect(win, win->frameGeometry()));
+    }
+}
+
 }
diff --git a/win/x11/startup_info.h b/win/x11/startup_info.h
new file mode 100644
index 000000000..2c71b07ab
--- /dev/null
+++ b/win/x11/startup_info.h
@@ -0,0 +1,54 @@
+/*
+    SPDX-FileCopyrightText: 2022 Roman Gilg <subdiff@gmail.com>
+
+    SPDX-License-Identifier: GPL-2.0-or-later
+*/
+#pragma once
+
+#include "base/output_helpers.h"
+#include "main.h"
+
+#include <KStartupInfo>
+
+namespace KWin::win::x11
+{
+
+template<typename Win>
+void startup_id_changed(Win* win)
+{
+    KStartupInfoId asn_id;
+    KStartupInfoData asn_data;
+    bool asn_valid = win->space.checkStartupNotification(win->xcb_window, asn_id, asn_data);
+    if (!asn_valid)
+        return;
+    // If the ASN contains desktop, move it to the desktop, otherwise move it to the current
+    // desktop (since the new ASN should make the window act like if it's a new application
+    // launched). However don't affect the window's desktop if it's set to be on all desktops.
+    int desktop = win->space.virtual_desktop_manager->current();
+    if (asn_data.desktop() != 0)
+        desktop = asn_data.desktop();
+    if (!win->isOnAllDesktops()) {
+        win->space.sendClientToDesktop(win, desktop, true);
+    }
+    if (asn_data.xinerama() != -1) {
+        auto output = base::get_output(kwinApp()->get_base().get_outputs(), asn_data.xinerama());
+        if (output) {
+            send_to_screen(win->space, win, *output);
+        }
+    }
+    auto const timestamp = asn_id.timestamp();
+    if (timestamp != 0) {
+        auto activate = win->space.allowClientActivation(win, timestamp);
+        if (asn_data.desktop() != 0 && !win->isOnCurrentDesktop()) {
+            // it was started on different desktop than current one
+            activate = false;
+        }
+        if (activate) {
+            win->space.activateClient(win);
+        } else {
+            set_demands_attention(win, true);
+        }
+    }
+}
+
+}
diff --git a/win/x11/user_time.h b/win/x11/user_time.h
new file mode 100644
index 000000000..c1504159f
--- /dev/null
+++ b/win/x11/user_time.h
@@ -0,0 +1,77 @@
+/*
+    SPDX-FileCopyrightText: 2022 Roman Gilg <subdiff@gmail.com>
+
+    SPDX-License-Identifier: GPL-2.0-or-later
+*/
+#pragma once
+
+#include "base/x11/xcb/proto.h"
+#include "main.h"
+
+#include <NETWM>
+
+namespace KWin::win::x11
+{
+
+template<typename Win>
+bool has_user_time_support(Win* win)
+{
+    return win->info->userTime() != -1U;
+}
+
+/**
+ * Updates the user time (time of last action in the active window).
+ * This is called inside  kwin for every action with the window
+ * that qualifies for user interaction (clicking on it, activate it
+ * externally, etc.).
+ */
+template<typename Win>
+void update_user_time(Win* win, xcb_timestamp_t time = XCB_TIME_CURRENT_TIME)
+{
+    // copied in Group::updateUserTime
+    if (time == XCB_TIME_CURRENT_TIME) {
+        kwinApp()->update_x11_time_from_clock();
+        time = xTime();
+    }
+    if (time != -1U
+        && (win->user_time == XCB_TIME_CURRENT_TIME
+            || NET::timestampCompare(time, win->user_time) > 0)) {
+        // time > user_time
+        win->user_time = time;
+    }
+
+    win->group()->updateUserTime(win->user_time);
+}
+
+template<typename Win>
+xcb_timestamp_t read_user_creation_time(Win* win)
+{
+    base::x11::xcb::property prop(false,
+                                  win->xcb_window,
+                                  win->space.atoms->kde_net_wm_user_creation_time,
+                                  XCB_ATOM_CARDINAL,
+                                  0,
+                                  1);
+    return prop.value<xcb_timestamp_t>(-1);
+}
+
+template<typename Win>
+xcb_timestamp_t user_time(Win* win)
+{
+    auto time = win->user_time;
+    if (time == 0) {
+        // doesn't want focus after showing
+        return 0;
+    }
+
+    auto group = win->group();
+    assert(group);
+
+    if (time == -1U
+        || (group->user_time != -1U && NET::timestampCompare(group->user_time, time) > 0)) {
+        time = group->user_time;
+    }
+    return time;
+}
+
+}
diff --git a/win/x11/window.cpp b/win/x11/window.cpp
index 3a32c657d..160132488 100644
--- a/win/x11/window.cpp
+++ b/win/x11/window.cpp
@@ -5,6 +5,7 @@
 */
 #include "window.h"
 
+#include "activation.h"
 #include "client.h"
 #include "deco.h"
 #include "fullscreen.h"
@@ -15,11 +16,13 @@
 #include "transient.h"
 #include "unmanaged.h"
 #include "window_release.h"
+#include "xcb.h"
 
 #include "base/x11/grabs.h"
 #include "render/x11/buffer.h"
 #include "render/x11/shadow.h"
 #include "rules/rules.h"
+#include "utils/geo.h"
 #include "win/deco.h"
 #include "win/deco/window.h"
 #include "win/layers.h"
diff --git a/win/x11/window_release.h b/win/x11/window_release.h
index f92029085..4bb2a62c4 100644
--- a/win/x11/window_release.h
+++ b/win/x11/window_release.h
@@ -8,6 +8,7 @@
 #include "base/x11/grabs.h"
 #include "toplevel.h"
 #include "utils/blocker.h"
+#include "win/input.h"
 #include "win/rules.h"
 #include "win/space_helpers.h"
 #include "win/window_release.h"
diff --git a/win/x11/xcb.h b/win/x11/xcb.h
index 5b4d0bfb9..f3d590ea2 100644
--- a/win/x11/xcb.h
+++ b/win/x11/xcb.h
@@ -17,4 +17,118 @@ base::x11::xcb::property fetch_skip_close_animation(Win&& win)
         false, win.xcb_window, win.space.atoms->kde_skip_close_animation, XCB_ATOM_CARDINAL, 0, 1);
 }
 
+template<typename Win>
+base::x11::xcb::property fetch_first_in_tabbox(Win* win)
+{
+    auto& atoms = win->space.atoms;
+    return base::x11::xcb::property(false,
+                                    win->xcb_windows.client,
+                                    atoms->kde_first_in_window_list,
+                                    atoms->kde_first_in_window_list,
+                                    0,
+                                    1);
+}
+
+template<typename Win>
+void read_first_in_tabbox(Win* win, base::x11::xcb::property& property)
+{
+    win->control->set_first_in_tabbox(
+        property.to_bool(32, win->space.atoms->kde_first_in_window_list));
+}
+
+template<typename Win>
+void update_first_in_tabbox(Win* win)
+{
+    // TODO: move into KWindowInfo
+    auto property = fetch_first_in_tabbox(win);
+    read_first_in_tabbox(win, property);
+}
+
+template<typename Win>
+base::x11::xcb::property fetch_show_on_screen_edge(Win* win)
+{
+    return base::x11::xcb::property(
+        false, win->xcb_window, win->space.atoms->kde_screen_edge_show, XCB_ATOM_CARDINAL, 0, 1);
+}
+
+template<typename Win>
+void read_show_on_screen_edge(Win* win, base::x11::xcb::property& property)
+{
+    // value comes in two parts, edge in the lower byte
+    // then the type in the upper byte
+    // 0 = autohide
+    // 1 = raise in front on activate
+
+    auto const value = property.value<uint32_t>(ElectricNone);
+    auto border = ElectricNone;
+
+    switch (value & 0xFF) {
+    case 0:
+        border = ElectricTop;
+        break;
+    case 1:
+        border = ElectricRight;
+        break;
+    case 2:
+        border = ElectricBottom;
+        break;
+    case 3:
+        border = ElectricLeft;
+        break;
+    }
+
+    if (border != ElectricNone) {
+        QObject::disconnect(win->connections.edge_remove);
+        QObject::disconnect(win->connections.edge_geometry);
+        auto successfullyHidden = false;
+
+        if (((value >> 8) & 0xFF) == 1) {
+            set_keep_below(win, true);
+
+            // request could have failed due to user kwin rules
+            successfullyHidden = win->control->keep_below();
+
+            win->connections.edge_remove
+                = QObject::connect(win, &Win::keepBelowChanged, win, [win]() {
+                      if (!win->control->keep_below()) {
+                          win->space.edges->reserve(win, ElectricNone);
+                      }
+                  });
+        } else {
+            win->hideClient(true);
+            successfullyHidden = win->isHiddenInternal();
+
+            win->connections.edge_geometry
+                = QObject::connect(win, &Win::frame_geometry_changed, win, [win, border]() {
+                      win->hideClient(true);
+                      win->space.edges->reserve(win, border);
+                  });
+        }
+
+        if (successfullyHidden) {
+            win->space.edges->reserve(win, border);
+        } else {
+            win->space.edges->reserve(win, ElectricNone);
+        }
+    } else if (!property.is_null() && property->type != XCB_ATOM_NONE) {
+        // property value is incorrect, delete the property
+        // so that the client knows that it is not hidden
+        xcb_delete_property(connection(), win->xcb_window, win->space.atoms->kde_screen_edge_show);
+    } else {
+        // restore
+        // TODO: add proper unreserve
+
+        // this will call showOnScreenEdge to reset the state
+        QObject::disconnect(win->connections.edge_geometry);
+        win->space.edges->reserve(win, ElectricNone);
+    }
+}
+
+template<typename Win>
+void update_show_on_screen_edge(Win* win)
+{
+    auto property = fetch_show_on_screen_edge(win);
+    read_show_on_screen_edge(win, property);
+}
+
 }
-- 
GitLab


From 047aae1f53f9056d416aebb674995a29027c9a01 Mon Sep 17 00:00:00 2001
From: Roman Gilg <subdiff@gmail.com>
Date: Tue, 5 Jul 2022 01:53:32 +0200
Subject: [PATCH 06/51] refactor: split up stacking header into multiple
 headers

This reduces the risk of issues due to cyclic inclusions.
---
 autotests/integration/dbus_interface_test.cpp |   2 +-
 .../effects/minimize_animation_test.cpp       |   2 +-
 .../effects/scripted_effects_test.cpp         |   2 +-
 .../integration/idle_inhibition_test.cpp      |   2 +-
 autotests/integration/screen_edges.cpp        |   3 +-
 autotests/integration/screens.cpp             |   2 +-
 autotests/integration/stacking_order_test.cpp |   2 +-
 scripting/window.cpp                          |   1 +
 win/actions.h                                 |  99 +++++++
 win/activation.h                              |  55 ++++
 win/controlling.h                             |   7 -
 win/deco/client_impl.cpp                      |   2 +-
 win/desktop_space.h                           |  38 +++
 win/focus_chain_helpers.h                     |  52 ++++
 win/input.h                                   |   3 +-
 win/net.h                                     |   7 +
 win/stacking.h                                | 280 ------------------
 win/stacking_order.cpp                        |   1 +
 win/transient_stacking.h                      |  83 ++++++
 win/wayland/setup.h                           |   2 +-
 win/x11/event.h                               |   1 +
 win/x11/space_setup.h                         |   1 +
 win/x11/xcb.h                                 |   1 +
 23 files changed, 350 insertions(+), 298 deletions(-)
 create mode 100644 win/actions.h
 create mode 100644 win/desktop_space.h
 create mode 100644 win/transient_stacking.h

diff --git a/autotests/integration/dbus_interface_test.cpp b/autotests/integration/dbus_interface_test.cpp
index af231079c..fe8dac87f 100644
--- a/autotests/integration/dbus_interface_test.cpp
+++ b/autotests/integration/dbus_interface_test.cpp
@@ -25,10 +25,10 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "base/wayland/server.h"
 #include "base/x11/atoms.h"
 #include "rules/rules.h"
+#include "win/actions.h"
 #include "win/controlling.h"
 #include "win/move.h"
 #include "win/space.h"
-#include "win/stacking.h"
 #include "win/virtual_desktops.h"
 #include "win/wayland/space.h"
 #include "win/x11/window.h"
diff --git a/autotests/integration/effects/minimize_animation_test.cpp b/autotests/integration/effects/minimize_animation_test.cpp
index 8e31506b6..68ad44ef1 100644
--- a/autotests/integration/effects/minimize_animation_test.cpp
+++ b/autotests/integration/effects/minimize_animation_test.cpp
@@ -25,9 +25,9 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "render/effects.h"
 #include "render/scene.h"
 #include "toplevel.h"
+#include "win/actions.h"
 #include "win/net.h"
 #include "win/space.h"
-#include "win/stacking.h"
 #include "win/wayland/window.h"
 
 #include <Wrapland/Client/plasmashell.h>
diff --git a/autotests/integration/effects/scripted_effects_test.cpp b/autotests/integration/effects/scripted_effects_test.cpp
index 084ff075d..0271666af 100644
--- a/autotests/integration/effects/scripted_effects_test.cpp
+++ b/autotests/integration/effects/scripted_effects_test.cpp
@@ -25,8 +25,8 @@ along with this program.  If not, see <https://www.gnu.org/licenses/>.
 #include "render/effect_loader.h"
 #include "render/effects.h"
 #include "scripting/effect.h"
+#include "win/actions.h"
 #include "win/space.h"
-#include "win/stacking.h"
 #include "win/virtual_desktops.h"
 
 #include <QJSValue>
diff --git a/autotests/integration/idle_inhibition_test.cpp b/autotests/integration/idle_inhibition_test.cpp
index f3c4b90e4..d2a671726 100644
--- a/autotests/integration/idle_inhibition_test.cpp
+++ b/autotests/integration/idle_inhibition_test.cpp
@@ -19,9 +19,9 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *********************************************************************/
 #include "lib/app.h"
 
+#include "win/actions.h"
 #include "win/screen.h"
 #include "win/space.h"
-#include "win/stacking.h"
 #include "win/wayland/window.h"
 
 #include <Wrapland/Client/idleinhibit.h>
diff --git a/autotests/integration/screen_edges.cpp b/autotests/integration/screen_edges.cpp
index 6bcbfe94c..1a288cd5b 100644
--- a/autotests/integration/screen_edges.cpp
+++ b/autotests/integration/screen_edges.cpp
@@ -25,9 +25,10 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "input/cursor.h"
 #include "input/gestures.h"
 #include "toplevel.h"
+#include "win/actions.h"
+#include "win/activation.h"
 #include "win/screen_edges.h"
 #include "win/space.h"
-#include "win/stacking.h"
 #include "win/wayland/space.h"
 #include "win/wayland/window.h"
 
diff --git a/autotests/integration/screens.cpp b/autotests/integration/screens.cpp
index ffe259d1a..9fe4e0cd2 100644
--- a/autotests/integration/screens.cpp
+++ b/autotests/integration/screens.cpp
@@ -26,9 +26,9 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "input/cursor.h"
 #include "lib/app.h"
 
+#include "win/activation.h"
 #include "win/move.h"
 #include "win/screen.h"
-#include "win/stacking.h"
 #include "win/wayland/space.h"
 
 #include <Wrapland/Client/compositor.h>
diff --git a/autotests/integration/stacking_order_test.cpp b/autotests/integration/stacking_order_test.cpp
index fa8e3f940..b78e20b98 100644
--- a/autotests/integration/stacking_order_test.cpp
+++ b/autotests/integration/stacking_order_test.cpp
@@ -24,8 +24,8 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "main.h"
 #include "toplevel.h"
 #include "utils/blocker.h"
+#include "win/actions.h"
 #include "win/space.h"
-#include "win/stacking.h"
 #include "win/stacking_order.h"
 #include "win/transient.h"
 #include "win/wayland/window.h"
diff --git a/scripting/window.cpp b/scripting/window.cpp
index ce89cf1fd..73a122e52 100644
--- a/scripting/window.cpp
+++ b/scripting/window.cpp
@@ -8,6 +8,7 @@
 #include "space.h"
 
 #include "toplevel.h"
+#include "win/actions.h"
 #include "win/activation.h"
 #include "win/controlling.h"
 #include "win/meta.h"
diff --git a/win/actions.h b/win/actions.h
new file mode 100644
index 000000000..03f4f2854
--- /dev/null
+++ b/win/actions.h
@@ -0,0 +1,99 @@
+/*
+    SPDX-FileCopyrightText: 2022 Roman Gilg <subdiff@gmail.com>
+
+    SPDX-License-Identifier: GPL-2.0-or-later
+*/
+#pragma once
+
+#include "layers.h"
+#include "scene.h"
+
+namespace KWin::win
+{
+
+template<typename Win>
+void set_keep_below(Win* win, bool keep);
+
+template<typename Win>
+void set_keep_above(Win* win, bool keep)
+{
+    keep = win->control->rules().checkKeepAbove(keep);
+    if (keep && !win->control->rules().checkKeepBelow(false)) {
+        set_keep_below(win, false);
+    }
+    if (keep == win->control->keep_above()) {
+        // force hint change if different
+        if (win->info && bool(win->info->state() & NET::KeepAbove) != keep) {
+            win->info->setState(keep ? NET::KeepAbove : NET::States(), NET::KeepAbove);
+        }
+        return;
+    }
+    win->control->set_keep_above(keep);
+    if (win->info) {
+        win->info->setState(keep ? NET::KeepAbove : NET::States(), NET::KeepAbove);
+    }
+    update_layer(win);
+    win->updateWindowRules(Rules::Above);
+
+    win->doSetKeepAbove();
+    Q_EMIT win->keepAboveChanged(keep);
+}
+
+template<typename Win>
+void set_keep_below(Win* win, bool keep)
+{
+    keep = win->control->rules().checkKeepBelow(keep);
+    if (keep && !win->control->rules().checkKeepAbove(false)) {
+        set_keep_above(win, false);
+    }
+    if (keep == win->control->keep_below()) {
+        // force hint change if different
+        if (win->info && bool(win->info->state() & NET::KeepBelow) != keep)
+            win->info->setState(keep ? NET::KeepBelow : NET::States(), NET::KeepBelow);
+        return;
+    }
+    win->control->set_keep_below(keep);
+    if (win->info) {
+        win->info->setState(keep ? NET::KeepBelow : NET::States(), NET::KeepBelow);
+    }
+    update_layer(win);
+    win->updateWindowRules(Rules::Below);
+
+    win->doSetKeepBelow();
+    Q_EMIT win->keepBelowChanged(keep);
+}
+
+template<typename Win>
+void set_minimized(Win* win, bool set, bool avoid_animation = false)
+{
+    if (set) {
+        if (!win->isMinimizable() || win->control->minimized())
+            return;
+
+        win->control->set_minimized(true);
+        win->doMinimize();
+
+        win->updateWindowRules(Rules::Minimize);
+        win->space.render.addRepaint(visible_rect(win));
+
+        // TODO: merge signal with s_minimized
+        Q_EMIT win->clientMinimized(win, !avoid_animation);
+        Q_EMIT win->minimizedChanged();
+    } else {
+        if (!win->control->minimized()) {
+            return;
+        }
+        if (win->control->rules().checkMinimize(false)) {
+            return;
+        }
+
+        win->control->set_minimized(false);
+        win->doMinimize();
+
+        win->updateWindowRules(Rules::Minimize);
+        Q_EMIT win->clientUnminimized(win, !avoid_animation);
+        Q_EMIT win->minimizedChanged();
+    }
+}
+
+}
diff --git a/win/activation.h b/win/activation.h
index c3471e5e6..775142723 100644
--- a/win/activation.h
+++ b/win/activation.h
@@ -5,6 +5,11 @@
 */
 #pragma once
 
+#include "layers.h"
+#include "stacking_order.h"
+
+#include "utils/blocker.h"
+
 namespace KWin::win
 {
 
@@ -27,4 +32,54 @@ void set_demands_attention(Win* win, bool demand)
     Q_EMIT win->demandsAttentionChanged();
 }
 
+/**
+ * Sets the client's active state to \a act.
+ *
+ * This function does only change the visual appearance of the client,
+ * it does not change the focus setting. Use
+ * Workspace::activateClient() or Workspace::requestFocus() instead.
+ *
+ * If a client receives or looses the focus, it calls setActive() on
+ * its own.
+ */
+template<typename Win>
+void set_active(Win* win, bool active)
+{
+    if (win->control->active() == active) {
+        return;
+    }
+    win->control->set_active(active);
+
+    auto const ruledOpacity = active
+        ? win->control->rules().checkOpacityActive(qRound(win->opacity() * 100.0))
+        : win->control->rules().checkOpacityInactive(qRound(win->opacity() * 100.0));
+    win->setOpacity(ruledOpacity / 100.0);
+
+    win->space.setActiveClient(active ? win : nullptr);
+
+    if (!active) {
+        win->control->cancel_auto_raise();
+    }
+
+    blocker block(win->space.stacking_order);
+
+    // active windows may get different layer
+    update_layer(win);
+
+    auto leads = win->transient()->leads();
+    for (auto lead : leads) {
+        if (lead->remnant) {
+            continue;
+        }
+        if (lead->control->fullscreen()) {
+            // Fullscreens go high even if their transient is active.
+            update_layer(lead);
+        }
+    }
+
+    win->doSetActive();
+    Q_EMIT win->activeChanged();
+    win->control->update_mouse_grab();
+}
+
 }
diff --git a/win/controlling.h b/win/controlling.h
index d6b1d0e10..4900efcf8 100644
--- a/win/controlling.h
+++ b/win/controlling.h
@@ -15,13 +15,6 @@
 namespace KWin::win
 {
 
-template<typename Win>
-bool wants_tab_focus(Win* win)
-{
-    auto const suitable_type = is_normal(win) || is_dialog(win);
-    return suitable_type && win->wantsInput();
-}
-
 /**
  * @brief Updates the position of the @p window according to the requested @p change in the
  * focus chain.
diff --git a/win/deco/client_impl.cpp b/win/deco/client_impl.cpp
index 9f7839c18..3a75fdbf5 100644
--- a/win/deco/client_impl.cpp
+++ b/win/deco/client_impl.cpp
@@ -29,11 +29,11 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "render/compositor.h"
 #include "render/platform.h"
 #include "toplevel.h"
+#include "win/actions.h"
 #include "win/control.h"
 #include "win/geo.h"
 #include "win/meta.h"
 #include "win/space.h"
-#include "win/stacking.h"
 #include "win/transient.h"
 
 #include <KDecoration2/DecoratedClient>
diff --git a/win/desktop_space.h b/win/desktop_space.h
new file mode 100644
index 000000000..da7d4d80b
--- /dev/null
+++ b/win/desktop_space.h
@@ -0,0 +1,38 @@
+/*
+    SPDX-FileCopyrightText: 2022 Roman Gilg <subdiff@gmail.com>
+
+    SPDX-License-Identifier: GPL-2.0-or-later
+*/
+#pragma once
+
+#include "toplevel.h"
+
+namespace KWin::win
+{
+
+template<typename Space>
+Toplevel* find_desktop(Space* space, bool topmost, int desktop)
+{
+    // TODO(fsorr): use C++20 std::ranges::reverse_view
+    auto const& list = space->stacking_order->stack;
+    auto is_desktop = [desktop](auto window) {
+        return window->control && window->isOnDesktop(desktop) && win::is_desktop(window)
+            && window->isShown();
+    };
+
+    if (topmost) {
+        auto it = std::find_if(list.rbegin(), list.rend(), is_desktop);
+        if (it != list.rend()) {
+            return *it;
+        }
+    } else {
+        // bottom-most
+        auto it = std::find_if(list.begin(), list.end(), is_desktop);
+        if (it != list.end()) {
+            return *it;
+        }
+    }
+
+    return nullptr;
+}
+}
diff --git a/win/focus_chain_helpers.h b/win/focus_chain_helpers.h
index f795a65fd..c02c1ba6e 100644
--- a/win/focus_chain_helpers.h
+++ b/win/focus_chain_helpers.h
@@ -5,7 +5,9 @@
 */
 #pragma once
 
+#include "net.h"
 #include "types.h"
+#include "util.h"
 
 #include "utils/algorithm.h"
 
@@ -152,4 +154,54 @@ Win* focus_chain_next_latest_use(Manager& manager, Win* reference)
     return *std::prev(it);
 }
 
+template<typename Chain, typename Win>
+void focus_chain_move_window_after_in_chain(Chain& chain, Win* window, Win* reference)
+{
+    if (!contains(chain, reference)) {
+        // TODO(romangg): better assert?
+        return;
+    }
+
+    remove_all(chain, window);
+
+    if (belong_to_same_client(reference, window)) {
+        // Simple case, just put it directly behind the reference window of the same client.
+        // TODO(romangg): can this special case be explained better?
+        auto it = find(chain, reference);
+        chain.insert(it, window);
+        return;
+    }
+
+    for (auto it = chain.rbegin(); it != chain.rend(); ++it) {
+        if (belong_to_same_client(reference, *it)) {
+            chain.insert(std::next(it).base(), window);
+            return;
+        }
+    }
+}
+
+/**
+ * @brief Moves @p window behind the @p reference in all focus chains.
+ *
+ * @param client The Client to move in the chains
+ * @param reference The Client behind which the @p client should be moved
+ * @return void
+ */
+template<typename Manager>
+void focus_chain_move_window_after(Manager& manager, Toplevel* window, Toplevel* reference)
+{
+    if (!wants_tab_focus(window)) {
+        return;
+    }
+
+    for (auto& [key, chain] : manager.chains.desktops) {
+        if (!window->isOnDesktop(key)) {
+            continue;
+        }
+        focus_chain_move_window_after_in_chain(chain, window, reference);
+    }
+
+    focus_chain_move_window_after_in_chain(manager.chains.latest_use, window, reference);
+}
+
 }
diff --git a/win/input.h b/win/input.h
index c5159c8a3..6b46f30dc 100644
--- a/win/input.h
+++ b/win/input.h
@@ -5,13 +5,12 @@
 */
 #pragma once
 
+#include "actions.h"
 #include "control.h"
-#include "layers.h"
 #include "move.h"
 #include "net.h"
 #include "screen.h"
 #include "space.h"
-#include "stacking.h"
 #include "stacking_order.h"
 #include "toplevel.h"
 #include "types.h"
diff --git a/win/net.h b/win/net.h
index 73141962e..321e1b6e2 100644
--- a/win/net.h
+++ b/win/net.h
@@ -120,4 +120,11 @@ bool is_dnd_icon(Win* win)
     return win->windowType() == NET::DNDIcon;
 }
 
+template<typename Win>
+bool wants_tab_focus(Win* win)
+{
+    auto const suitable_type = is_normal(win) || is_dialog(win);
+    return suitable_type && win->wantsInput();
+}
+
 }
diff --git a/win/stacking.h b/win/stacking.h
index aec7408b2..e1b330ea2 100644
--- a/win/stacking.h
+++ b/win/stacking.h
@@ -5,17 +5,12 @@
 */
 #pragma once
 
-#include "control.h"
 #include "controlling.h"
 #include "focus_chain.h"
 #include "focus_chain_helpers.h"
 #include "geo.h"
 #include "layers.h"
-#include "meta.h"
-#include "net.h"
-#include "space.h"
 #include "stacking_order.h"
-#include "transient.h"
 #include "util.h"
 #include "x11/group.h"
 
@@ -122,32 +117,6 @@ Toplevel* top_client_on_desktop(Space* space,
     return nullptr;
 }
 
-template<typename Space>
-Toplevel* find_desktop(Space* space, bool topmost, int desktop)
-{
-    // TODO(fsorr): use C++20 std::ranges::reverse_view
-    auto const& list = space->stacking_order->stack;
-    auto is_desktop = [desktop](auto window) {
-        return window->control && window->isOnDesktop(desktop) && win::is_desktop(window)
-            && window->isShown();
-    };
-
-    if (topmost) {
-        auto it = std::find_if(list.rbegin(), list.rend(), is_desktop);
-        if (it != list.rend()) {
-            return *it;
-        }
-    } else {
-        // bottom-most
-        auto it = std::find_if(list.begin(), list.end(), is_desktop);
-        if (it != list.end()) {
-            return *it;
-        }
-    }
-
-    return nullptr;
-}
-
 template<class T, class R = T>
 std::deque<R*> ensure_stacking_order_in_list(std::deque<Toplevel*> const& stackingOrder,
                                              std::vector<T*> const& list)
@@ -315,56 +284,6 @@ void raise_or_lower_client(Space* space, Window* window)
     }
 }
 
-template<typename Chain, typename Win>
-void focus_chain_move_window_after_in_chain(Chain& chain, Win* window, Win* reference)
-{
-    if (!contains(chain, reference)) {
-        // TODO(romangg): better assert?
-        return;
-    }
-
-    remove_all(chain, window);
-
-    if (belong_to_same_client(reference, window)) {
-        // Simple case, just put it directly behind the reference window of the same client.
-        // TODO(romangg): can this special case be explained better?
-        auto it = find(chain, reference);
-        chain.insert(it, window);
-        return;
-    }
-
-    for (auto it = chain.rbegin(); it != chain.rend(); ++it) {
-        if (belong_to_same_client(reference, *it)) {
-            chain.insert(std::next(it).base(), window);
-            return;
-        }
-    }
-}
-
-/**
- * @brief Moves @p window behind the @p reference in all focus chains.
- *
- * @param client The Client to move in the chains
- * @param reference The Client behind which the @p client should be moved
- * @return void
- */
-template<typename Manager>
-void focus_chain_move_window_after(Manager& manager, Toplevel* window, Toplevel* reference)
-{
-    if (!wants_tab_focus(window)) {
-        return;
-    }
-
-    for (auto& [key, chain] : manager.chains.desktops) {
-        if (!window->isOnDesktop(key)) {
-            continue;
-        }
-        focus_chain_move_window_after_in_chain(chain, window, reference);
-    }
-
-    focus_chain_move_window_after_in_chain(manager.chains.latest_use, window, reference);
-}
-
 template<typename Space, typename Window>
 void restack(Space* space, Window* window, Toplevel* under, bool force = false)
 {
@@ -417,205 +336,6 @@ void auto_raise(Win* win)
     win->control->cancel_auto_raise();
 }
 
-template<typename Win>
-void set_keep_below(Win* win, bool keep);
-
-template<typename Win>
-void set_keep_above(Win* win, bool keep)
-{
-    keep = win->control->rules().checkKeepAbove(keep);
-    if (keep && !win->control->rules().checkKeepBelow(false)) {
-        set_keep_below(win, false);
-    }
-    if (keep == win->control->keep_above()) {
-        // force hint change if different
-        if (win->info && bool(win->info->state() & NET::KeepAbove) != keep) {
-            win->info->setState(keep ? NET::KeepAbove : NET::States(), NET::KeepAbove);
-        }
-        return;
-    }
-    win->control->set_keep_above(keep);
-    if (win->info) {
-        win->info->setState(keep ? NET::KeepAbove : NET::States(), NET::KeepAbove);
-    }
-    update_layer(win);
-    win->updateWindowRules(Rules::Above);
-
-    win->doSetKeepAbove();
-    Q_EMIT win->keepAboveChanged(keep);
-}
-
-template<typename Win>
-void set_keep_below(Win* win, bool keep)
-{
-    keep = win->control->rules().checkKeepBelow(keep);
-    if (keep && !win->control->rules().checkKeepAbove(false)) {
-        set_keep_above(win, false);
-    }
-    if (keep == win->control->keep_below()) {
-        // force hint change if different
-        if (win->info && bool(win->info->state() & NET::KeepBelow) != keep)
-            win->info->setState(keep ? NET::KeepBelow : NET::States(), NET::KeepBelow);
-        return;
-    }
-    win->control->set_keep_below(keep);
-    if (win->info) {
-        win->info->setState(keep ? NET::KeepBelow : NET::States(), NET::KeepBelow);
-    }
-    update_layer(win);
-    win->updateWindowRules(Rules::Below);
-
-    win->doSetKeepBelow();
-    Q_EMIT win->keepBelowChanged(keep);
-}
-
-/**
- * Sets the client's active state to \a act.
- *
- * This function does only change the visual appearance of the client,
- * it does not change the focus setting. Use
- * Workspace::activateClient() or Workspace::requestFocus() instead.
- *
- * If a client receives or looses the focus, it calls setActive() on
- * its own.
- */
-template<typename Win>
-void set_active(Win* win, bool active)
-{
-    if (win->control->active() == active) {
-        return;
-    }
-    win->control->set_active(active);
-
-    auto const ruledOpacity = active
-        ? win->control->rules().checkOpacityActive(qRound(win->opacity() * 100.0))
-        : win->control->rules().checkOpacityInactive(qRound(win->opacity() * 100.0));
-    win->setOpacity(ruledOpacity / 100.0);
-
-    win->space.setActiveClient(active ? win : nullptr);
-
-    if (!active) {
-        win->control->cancel_auto_raise();
-    }
-
-    blocker block(win->space.stacking_order);
-
-    // active windows may get different layer
-    update_layer(win);
-
-    auto leads = win->transient()->leads();
-    for (auto lead : leads) {
-        if (lead->remnant) {
-            continue;
-        }
-        if (lead->control->fullscreen()) {
-            // Fullscreens go high even if their transient is active.
-            update_layer(lead);
-        }
-    }
-
-    win->doSetActive();
-    Q_EMIT win->activeChanged();
-    win->control->update_mouse_grab();
-}
-
-template<typename Win>
-void set_minimized(Win* win, bool set, bool avoid_animation = false)
-{
-    if (set) {
-        if (!win->isMinimizable() || win->control->minimized())
-            return;
-
-        win->control->set_minimized(true);
-        win->doMinimize();
-
-        win->updateWindowRules(Rules::Minimize);
-        win->space.render.addRepaint(visible_rect(win));
-
-        // TODO: merge signal with s_minimized
-        Q_EMIT win->clientMinimized(win, !avoid_animation);
-        Q_EMIT win->minimizedChanged();
-    } else {
-        if (!win->control->minimized()) {
-            return;
-        }
-        if (win->control->rules().checkMinimize(false)) {
-            return;
-        }
-
-        win->control->set_minimized(false);
-        win->doMinimize();
-
-        win->updateWindowRules(Rules::Minimize);
-        Q_EMIT win->clientUnminimized(win, !avoid_animation);
-        Q_EMIT win->minimizedChanged();
-    }
-}
-
-// check whether a transient should be actually kept above its mainwindow
-// there may be some special cases where this rule shouldn't be enfored
-template<typename Win1, typename Win2>
-bool keep_transient_above(Win1 const* mainwindow, Win2 const* transient)
-{
-    if (transient->transient()->annexed) {
-        return true;
-    }
-    // #93832 - don't keep splashscreens above dialogs
-    if (win::is_splash(transient) && win::is_dialog(mainwindow))
-        return false;
-    // This is rather a hack for #76026. Don't keep non-modal dialogs above
-    // the mainwindow, but only if they're group transient (since only such dialogs
-    // have taskbar entry in Kicker). A proper way of doing this (both kwin and kicker)
-    // needs to be found.
-    if (win::is_dialog(transient) && !transient->transient()->modal()
-        && transient->groupTransient())
-        return false;
-    // #63223 - don't keep transients above docks, because the dock is kept high,
-    // and e.g. dialogs for them would be too high too
-    // ignore this if the transient has a placement hint which indicates it should go above it's
-    // parent
-    if (win::is_dock(mainwindow))
-        return false;
-    return true;
-}
-
-template<typename Win1, typename Win2>
-bool keep_deleted_transient_above(Win1 const* mainWindow, Win2 const* transient)
-{
-    assert(transient->remnant);
-
-    // #93832 - Don't keep splashscreens above dialogs.
-    if (win::is_splash(transient) && win::is_dialog(mainWindow)) {
-        return false;
-    }
-
-    if (transient->remnant->data.was_x11_client) {
-        // If a group transient was active, we should keep it above no matter
-        // what, because at the time when the transient was closed, it was above
-        // the main window.
-        if (transient->remnant->data.was_group_transient && transient->remnant->data.was_active) {
-            return true;
-        }
-
-        // This is rather a hack for #76026. Don't keep non-modal dialogs above
-        // the mainwindow, but only if they're group transient (since only such
-        // dialogs have taskbar entry in Kicker). A proper way of doing this
-        // (both kwin and kicker) needs to be found.
-        if (transient->remnant->data.was_group_transient && win::is_dialog(transient)
-            && !transient->transient()->modal()) {
-            return false;
-        }
-
-        // #63223 - Don't keep transients above docks, because the dock is kept
-        // high, and e.g. dialogs for them would be too high too.
-        if (win::is_dock(mainWindow)) {
-            return false;
-        }
-    }
-
-    return true;
-}
-
 /**
  * Group windows by layer, than flatten to a list.
  * @param list container of windows to sort
diff --git a/win/stacking_order.cpp b/win/stacking_order.cpp
index aa1d3ab33..65b0d1dc3 100644
--- a/win/stacking_order.cpp
+++ b/win/stacking_order.cpp
@@ -10,6 +10,7 @@
 #include "screen_edges.h"
 #include "stacking.h"
 #include "transient.h"
+#include "transient_stacking.h"
 #include "x11/group.h"
 #include "x11/hide.h"
 #include "x11/netinfo.h"
diff --git a/win/transient_stacking.h b/win/transient_stacking.h
new file mode 100644
index 000000000..6fc05b52b
--- /dev/null
+++ b/win/transient_stacking.h
@@ -0,0 +1,83 @@
+/*
+    SPDX-FileCopyrightText: 2022 Roman Gilg <subdiff@gmail.com>
+
+    SPDX-License-Identifier: GPL-2.0-or-later
+*/
+#pragma once
+
+#include "net.h"
+
+namespace KWin::win
+{
+
+// check whether a transient should be actually kept above its mainwindow
+// there may be some special cases where this rule shouldn't be enfored
+template<typename Win1, typename Win2>
+bool keep_transient_above(Win1 const* mainwindow, Win2 const* transient)
+{
+    if (transient->transient()->annexed) {
+        return true;
+    }
+
+    // #93832 - don't keep splashscreens above dialogs
+    if (win::is_splash(transient) && win::is_dialog(mainwindow)) {
+        return false;
+    }
+
+    // This is rather a hack for #76026. Don't keep non-modal dialogs above
+    // the mainwindow, but only if they're group transient (since only such dialogs
+    // have taskbar entry in Kicker). A proper way of doing this (both kwin and kicker)
+    // needs to be found.
+    if (win::is_dialog(transient) && !transient->transient()->modal()
+        && transient->groupTransient()) {
+        return false;
+    }
+
+    // #63223 - don't keep transients above docks, because the dock is kept high,
+    // and e.g. dialogs for them would be too high too
+    // ignore this if the transient has a placement hint which indicates it should go above it's
+    // parent
+    if (win::is_dock(mainwindow)) {
+        return false;
+    }
+    return true;
+}
+
+template<typename Win1, typename Win2>
+bool keep_deleted_transient_above(Win1 const* mainWindow, Win2 const* transient)
+{
+    assert(transient->remnant);
+
+    // #93832 - Don't keep splashscreens above dialogs.
+    if (win::is_splash(transient) && win::is_dialog(mainWindow)) {
+        return false;
+    }
+
+    if (transient->remnant->data.was_x11_client) {
+        // If a group transient was active, we should keep it above no matter
+        // what, because at the time when the transient was closed, it was above
+        // the main window.
+        if (transient->remnant->data.was_group_transient && transient->remnant->data.was_active) {
+            return true;
+        }
+
+        // This is rather a hack for #76026. Don't keep non-modal dialogs above
+        // the mainwindow, but only if they're group transient (since only such
+        // dialogs have taskbar entry in Kicker). A proper way of doing this
+        // (both kwin and kicker) needs to be found.
+        if (transient->remnant->data.was_group_transient && win::is_dialog(transient)
+            && !transient->transient()->modal()) {
+            return false;
+        }
+
+        // #63223 - Don't keep transients above docks, because the dock is kept
+        // high, and e.g. dialogs for them would be too high too.
+        if (win::is_dock(mainWindow)) {
+            return false;
+        }
+    }
+
+    return true;
+}
+
+}
diff --git a/win/wayland/setup.h b/win/wayland/setup.h
index db49b1bdc..38f7ba4cc 100644
--- a/win/wayland/setup.h
+++ b/win/wayland/setup.h
@@ -5,12 +5,12 @@
 */
 #pragma once
 
+#include "win/actions.h"
 #include "win/activation.h"
 #include "win/control.h"
 #include "win/meta.h"
 #include "win/move.h"
 #include "win/screen.h"
-#include "win/stacking.h"
 #include "win/types.h"
 #include "win/virtual_desktops.h"
 
diff --git a/win/x11/event.h b/win/x11/event.h
index 7a493dda1..bf9022fcc 100644
--- a/win/x11/event.h
+++ b/win/x11/event.h
@@ -18,6 +18,7 @@
 
 #include "base/x11/xcb/qt_types.h"
 #include "win/activation.h"
+#include "win/desktop_space.h"
 #include "win/input.h"
 #include "win/meta.h"
 #include "win/space.h"
diff --git a/win/x11/space_setup.h b/win/x11/space_setup.h
index bfbd0a0ed..901350613 100644
--- a/win/x11/space_setup.h
+++ b/win/x11/space_setup.h
@@ -14,6 +14,7 @@
 #include "base/x11/user_interaction_filter.h"
 #include "main.h"
 #include "utils/blocker.h"
+#include "win/desktop_space.h"
 
 #include <KStartupInfo>
 
diff --git a/win/x11/xcb.h b/win/x11/xcb.h
index f3d590ea2..2620cd3f6 100644
--- a/win/x11/xcb.h
+++ b/win/x11/xcb.h
@@ -6,6 +6,7 @@
 #pragma once
 
 #include "base/x11/xcb/property.h"
+#include "win/actions.h"
 
 namespace KWin::win::x11
 {
-- 
GitLab


From a0157c6165873a43570aebac4cfae161ce1289e5 Mon Sep 17 00:00:00 2001
From: Roman Gilg <subdiff@gmail.com>
Date: Mon, 4 Jul 2022 22:32:06 +0200
Subject: [PATCH 07/51] refactor: reimplement space activation functions as
 free functions

Implement functionality to activate and focus windows in free function
templates so it can be reused by different types of spaces.
---
 autotests/integration/dbus_interface_test.cpp |   3 +-
 .../integration/effects/translucency_test.cpp |   3 +-
 .../integration/globalshortcuts_test.cpp      |   4 +-
 autotests/integration/keyboard_keymap.cpp     |   3 +-
 .../integration/keyboard_layout_test.cpp      |  13 +-
 .../integration/pointer_constraints_test.cpp  |  15 +-
 autotests/integration/screen_edges.cpp        |   2 +-
 autotests/integration/screens.cpp             |   6 +-
 autotests/integration/stacking_order_test.cpp |  37 +-
 autotests/integration/x11_client_test.cpp     |  19 +-
 .../integration/xdgshellclient_rules_test.cpp |  22 +-
 autotests/integration/xdgshellclient_test.cpp |   4 +-
 .../integration/xwayland_selections_test.cpp  |   5 +-
 input/filters/drag_and_drop.cpp               |   5 +-
 render/effects.cpp                            |   6 +-
 rules/window_rules.cpp                        |   6 +-
 scripting/space.h                             |   3 +-
 win/activation.h                              | 503 +++++++++++-
 win/desktop_space.h                           | 150 +++-
 win/input.h                                   |  23 +-
 win/internal_window.cpp                       |   7 +-
 win/layers.h                                  |  13 +-
 win/output_space.h                            |  41 +
 win/space.cpp                                 | 777 +-----------------
 win/space.h                                   |  67 +-
 win/space_areas_helpers.h                     | 123 +++
 win/stacking.h                                |   2 +
 win/stacking_order.h                          |   1 +
 win/tabbox/tabbox.cpp                         |  16 +-
 win/user_actions_menu.h                       |   3 +-
 win/wayland/layer_shell.h                     |   6 +-
 win/wayland/setup.h                           |   2 +-
 win/wayland/space.cpp                         |  21 +-
 win/wayland/space.h                           |   9 +-
 win/wayland/window.cpp                        |   5 +-
 win/wayland/xdg_activation.h                  |   3 +-
 win/wayland/xdg_shell.h                       |   5 +-
 win/window_find.h                             |  39 +
 win/x11/control.h                             |   4 +-
 win/x11/event.h                               |   6 +-
 win/x11/hide.h                                |   3 +-
 win/x11/netinfo.cpp                           |  14 +-
 win/x11/space.cpp                             |   4 +-
 win/x11/space.h                               |   1 -
 win/x11/space_event.h                         |   8 +-
 win/x11/space_setup.h                         |   7 +-
 win/x11/startup_info.h                        |   5 +-
 win/x11/transient.h                           |   5 +-
 win/x11/window.cpp                            |   3 +-
 win/x11/window_create.h                       |  10 +-
 win/x11/window_release.h                      |  10 +-
 xwl/drag_wl.cpp                               |   3 +-
 xwl/drag_x.cpp                                |   5 +-
 53 files changed, 1089 insertions(+), 971 deletions(-)
 create mode 100644 win/output_space.h
 create mode 100644 win/space_areas_helpers.h
 create mode 100644 win/window_find.h

diff --git a/autotests/integration/dbus_interface_test.cpp b/autotests/integration/dbus_interface_test.cpp
index fe8dac87f..af4945d74 100644
--- a/autotests/integration/dbus_interface_test.cpp
+++ b/autotests/integration/dbus_interface_test.cpp
@@ -27,6 +27,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "rules/rules.h"
 #include "win/actions.h"
 #include "win/controlling.h"
+#include "win/desktop_space.h"
 #include "win/move.h"
 #include "win/space.h"
 #include "win/virtual_desktops.h"
@@ -203,7 +204,7 @@ void TestDbusInterface::testGetWindowInfoXdgShellClient()
     // window geometry changes
 
     QCOMPARE(client->desktop(), 1);
-    Test::app()->workspace->sendClientToDesktop(client, 2, false);
+    win::send_window_to_desktop(*Test::app()->workspace, client, 2, false);
     QCOMPARE(client->desktop(), 2);
     reply = getWindowInfo(client->internal_id);
     reply.waitForFinished();
diff --git a/autotests/integration/effects/translucency_test.cpp b/autotests/integration/effects/translucency_test.cpp
index 7af11756f..7c922afea 100644
--- a/autotests/integration/effects/translucency_test.cpp
+++ b/autotests/integration/effects/translucency_test.cpp
@@ -24,6 +24,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "render/compositor.h"
 #include "render/effect_loader.h"
 #include "render/effects.h"
+#include "win/desktop_space.h"
 #include "win/move.h"
 #include "win/space.h"
 #include "win/x11/window.h"
@@ -171,7 +172,7 @@ void TranslucencyTest::testMoveAfterDesktopChange()
     // let's send the window to desktop 2
     effects->setNumberOfDesktops(2);
     QCOMPARE(effects->numberOfDesktops(), 2);
-    Test::app()->workspace->sendClientToDesktop(client, 2, false);
+    win::send_window_to_desktop(*Test::app()->workspace, client, 2, false);
     effects->setCurrentDesktop(2);
     QVERIFY(!m_translucencyEffect->isActive());
     input::get_cursor()->set_pos(client->frameGeometry().center());
diff --git a/autotests/integration/globalshortcuts_test.cpp b/autotests/integration/globalshortcuts_test.cpp
index d949df527..5cf7238ed 100644
--- a/autotests/integration/globalshortcuts_test.cpp
+++ b/autotests/integration/globalshortcuts_test.cpp
@@ -383,7 +383,7 @@ void GlobalShortcutsTest::testX11ClientShortcut()
     // it's delayed
     QCoreApplication::processEvents();
 
-    Test::app()->workspace->activateClient(nullptr);
+    win::activate_window(*Test::app()->workspace, nullptr);
     QVERIFY(!Test::app()->workspace->active_client);
     QVERIFY(!client->control->active());
 
@@ -422,7 +422,7 @@ void GlobalShortcutsTest::testWaylandClientShortcut()
     QVERIFY(!Test::app()->workspace->shortcutAvailable(seq));
     QCOMPARE(win::caption(client), QStringLiteral(" {Meta+Shift+Y}"));
 
-    Test::app()->workspace->activateClient(nullptr);
+    win::activate_window(*Test::app()->workspace, nullptr);
     QVERIFY(!Test::app()->workspace->active_client);
     QVERIFY(!client->control->active());
 
diff --git a/autotests/integration/keyboard_keymap.cpp b/autotests/integration/keyboard_keymap.cpp
index d8ec5b206..3d1771d9b 100644
--- a/autotests/integration/keyboard_keymap.cpp
+++ b/autotests/integration/keyboard_keymap.cpp
@@ -6,6 +6,7 @@
 #include "lib/app.h"
 
 #include "input/cursor.h"
+#include "win/activation.h"
 #include "win/space.h"
 #include "win/wayland/window.h"
 
@@ -172,7 +173,7 @@ void keyboard_keymap_test::test_focus()
     QCOMPARE(client2_keymap_spy.size(), 1);
 
     // We switch back and don't get a new keymap.
-    Test::app()->workspace->activateClient(window1.window);
+    win::activate_window(*Test::app()->workspace, window1.window);
     QCOMPARE(Test::app()->workspace->active_client, window1.window);
 
     QVERIFY(!client1_keymap_spy.wait(500));
diff --git a/autotests/integration/keyboard_layout_test.cpp b/autotests/integration/keyboard_layout_test.cpp
index 3c0f5a286..fd867edc2 100644
--- a/autotests/integration/keyboard_layout_test.cpp
+++ b/autotests/integration/keyboard_layout_test.cpp
@@ -12,6 +12,7 @@
 #include "input/keyboard_redirect.h"
 #include "input/xkb/helpers.h"
 #include "input/xkb/layout_manager.h"
+#include "win/activation.h"
 #include "win/space.h"
 #include "win/virtual_desktops.h"
 #include "win/wayland/window.h"
@@ -757,9 +758,9 @@ void keyboard_layout_test::test_window_policy()
     QCOMPARE(xkb->layout_name(), "German (Neo 2)");
 
     // Activate other window.
-    Test::app()->workspace->activateClient(c1);
+    win::activate_window(*Test::app()->workspace, c1);
     QCOMPARE(xkb->layout_name(), "German");
-    Test::app()->workspace->activateClient(c2);
+    win::activate_window(*Test::app()->workspace, c2);
     QCOMPARE(xkb->layout_name(), "German (Neo 2)");
 }
 
@@ -802,19 +803,19 @@ void keyboard_layout_test::test_application_policy()
     reset_layouts();
 
     // Resetting layouts should trigger layout application for current client.
-    Test::app()->workspace->activateClient(c1);
-    Test::app()->workspace->activateClient(c2);
+    win::activate_window(*Test::app()->workspace, c1);
+    win::activate_window(*Test::app()->workspace, c2);
     QVERIFY(spies->v1.layout_changed.wait());
     QCOMPARE(spies->v1.layout_changed.count(), 1);
     QCOMPARE(xkb->layout_name(), "German (Neo 2)");
 
     // Activate other window.
-    Test::app()->workspace->activateClient(c1);
+    win::activate_window(*Test::app()->workspace, c1);
 
     // It is the same application and should not switch the layout.
     QVERIFY(!spies->v1.layout_changed.wait(1000));
     QCOMPARE(xkb->layout_name(), "German (Neo 2)");
-    Test::app()->workspace->activateClient(c2);
+    win::activate_window(*Test::app()->workspace, c2);
     QVERIFY(!spies->v1.layout_changed.wait(1000));
     QCOMPARE(xkb->layout_name(), "German (Neo 2)");
 
diff --git a/autotests/integration/pointer_constraints_test.cpp b/autotests/integration/pointer_constraints_test.cpp
index 275a45fa3..1f755a71a 100644
--- a/autotests/integration/pointer_constraints_test.cpp
+++ b/autotests/integration/pointer_constraints_test.cpp
@@ -207,7 +207,7 @@ void TestPointerConstraints::testConfinedPointer()
     Test::keyboard_key_released(KEY_LEFTALT, timestamp++);
 
     // deactivate the client, this should unconfine
-    Test::app()->workspace->activateClient(nullptr);
+    win::activate_window(*Test::app()->workspace, nullptr);
     QVERIFY(unconfinedSpy.wait());
     QCOMPARE(kwinApp()->input->redirect->pointer()->isConstrained(), false);
 
@@ -220,17 +220,19 @@ void TestPointerConstraints::testConfinedPointer()
     QVERIFY(unconfinedSpy2.isValid());
 
     // activate it again, this confines again
-    Test::app()->workspace->activateClient(kwinApp()->input->redirect->pointer()->focus.window);
+    win::activate_window(*Test::app()->workspace,
+                         kwinApp()->input->redirect->pointer()->focus.window);
     QVERIFY(confinedSpy2.wait());
     QCOMPARE(kwinApp()->input->redirect->pointer()->isConstrained(), true);
 
     // deactivate the client one more time with the persistent life time constraint, this should
     // unconfine
-    Test::app()->workspace->activateClient(nullptr);
+    win::activate_window(*Test::app()->workspace, nullptr);
     QVERIFY(unconfinedSpy2.wait());
     QCOMPARE(kwinApp()->input->redirect->pointer()->isConstrained(), false);
     // activate it again, this confines again
-    Test::app()->workspace->activateClient(kwinApp()->input->redirect->pointer()->focus.window);
+    win::activate_window(*Test::app()->workspace,
+                         kwinApp()->input->redirect->pointer()->focus.window);
     QVERIFY(confinedSpy2.wait());
     QCOMPARE(kwinApp()->input->redirect->pointer()->isConstrained(), true);
 
@@ -318,7 +320,7 @@ void TestPointerConstraints::testLockedPointer()
     QCOMPARE(input::get_cursor()->pos(), c->frameGeometry().center());
 
     // deactivate the client, this should unlock
-    Test::app()->workspace->activateClient(nullptr);
+    win::activate_window(*Test::app()->workspace, nullptr);
     QCOMPARE(kwinApp()->input->redirect->pointer()->isConstrained(), false);
     QVERIFY(unlockedSpy.wait());
 
@@ -332,7 +334,8 @@ void TestPointerConstraints::testLockedPointer()
     QVERIFY(lockedSpy2.isValid());
 
     // activate the client again, this should lock again
-    Test::app()->workspace->activateClient(kwinApp()->input->redirect->pointer()->focus.window);
+    win::activate_window(*Test::app()->workspace,
+                         kwinApp()->input->redirect->pointer()->focus.window);
     QVERIFY(lockedSpy2.wait());
     QCOMPARE(kwinApp()->input->redirect->pointer()->isConstrained(), true);
 
diff --git a/autotests/integration/screen_edges.cpp b/autotests/integration/screen_edges.cpp
index 1a288cd5b..24e6a0345 100644
--- a/autotests/integration/screen_edges.cpp
+++ b/autotests/integration/screen_edges.cpp
@@ -709,7 +709,7 @@ void TestScreenEdges::testFullScreenBlocking()
     client->setFrameGeometry(QRect({}, Test::app()->base.topology.size));
     win::set_active(client, true);
     client->setFullScreen(true);
-    Test::app()->workspace->setActiveClient(client);
+    win::set_active_window(*Test::app()->workspace, client);
     Q_EMIT screenEdges->checkBlocking();
 
     // the signal doesn't trigger for corners, let's go over all windows just to be sure that it
diff --git a/autotests/integration/screens.cpp b/autotests/integration/screens.cpp
index 9fe4e0cd2..e535f7abd 100644
--- a/autotests/integration/screens.cpp
+++ b/autotests/integration/screens.cpp
@@ -311,7 +311,7 @@ void TestScreens::testCurrentClient()
 
     win::move(client, QPoint(101, 0));
     QCOMPARE(Test::app()->workspace->active_client, client);
-    Test::app()->workspace->setActiveClient(nullptr);
+    win::set_active_window(*Test::app()->workspace, nullptr);
     QCOMPARE(Test::app()->workspace->active_client, nullptr);
 
     QCOMPARE(win::get_current_output(*Test::app()->workspace),
@@ -327,7 +327,7 @@ void TestScreens::testCurrentClient()
 
     // making the client active should affect things
     win::set_active(client, true);
-    Test::app()->workspace->setActiveClient(client);
+    win::set_active_window(*Test::app()->workspace, client);
 
     // first of all current should be changed just by the fact that there is an active client
     output = base::get_output(Test::app()->base.get_outputs(), 1);
@@ -347,7 +347,7 @@ void TestScreens::testCurrentClient()
     QCOMPARE(changedSpy.count(), 1);
 
     // and it should even still be on screen 1 if we make the client non-current again
-    Test::app()->workspace->setActiveClient(nullptr);
+    win::set_active_window(*Test::app()->workspace, nullptr);
     win::set_active(client, false);
 
     output = base::get_output(Test::app()->base.get_outputs(), 1);
diff --git a/autotests/integration/stacking_order_test.cpp b/autotests/integration/stacking_order_test.cpp
index b78e20b98..c1f658fad 100644
--- a/autotests/integration/stacking_order_test.cpp
+++ b/autotests/integration/stacking_order_test.cpp
@@ -25,6 +25,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "toplevel.h"
 #include "utils/blocker.h"
 #include "win/actions.h"
+#include "win/activation.h"
 #include "win/space.h"
 #include "win/stacking_order.h"
 #include "win/transient.h"
@@ -189,7 +190,7 @@ void StackingOrderTest::testTransientIsAboveParent()
              (std::deque<Toplevel*>{parent, transient}));
 
     // The transient still stays above the parent if we activate the latter.
-    Test::app()->workspace->activateClient(parent);
+    win::activate_window(*Test::app()->workspace, parent);
     QTRY_VERIFY(parent->control->active());
     QTRY_VERIFY(!transient->control->active());
 
@@ -246,7 +247,7 @@ void StackingOrderTest::testRaiseTransient()
              (std::deque<Toplevel*>{parent, transient, anotherClient}));
 
     // If we activate the parent, the transient should be raised too.
-    Test::app()->workspace->activateClient(parent);
+    win::activate_window(*Test::app()->workspace, parent);
     QTRY_VERIFY(parent->control->active());
     QTRY_VERIFY(!transient->control->active());
     QTRY_VERIFY(!anotherClient->control->active());
@@ -254,7 +255,7 @@ void StackingOrderTest::testRaiseTransient()
              (std::deque<Toplevel*>{anotherClient, parent, transient}));
 
     // Go back to the initial setup.
-    Test::app()->workspace->activateClient(anotherClient);
+    win::activate_window(*Test::app()->workspace, anotherClient);
     QTRY_VERIFY(!parent->control->active());
     QTRY_VERIFY(!transient->control->active());
     QTRY_VERIFY(anotherClient->control->active());
@@ -262,7 +263,7 @@ void StackingOrderTest::testRaiseTransient()
              (std::deque<Toplevel*>{parent, transient, anotherClient}));
 
     // If we activate the transient, the parent should be raised too.
-    Test::app()->workspace->activateClient(transient);
+    win::activate_window(*Test::app()->workspace, transient);
     QTRY_VERIFY(!parent->control->active());
     QTRY_VERIFY(transient->control->active());
     QTRY_VERIFY(!anotherClient->control->active());
@@ -322,7 +323,7 @@ void StackingOrderTest::testDeletedTransient()
              (std::deque<Toplevel*>{parent, transient1, transient2}));
 
     // Activate the parent, both transients have to be above it.
-    Test::app()->workspace->activateClient(parent);
+    win::activate_window(*Test::app()->workspace, parent);
     QTRY_VERIFY(parent->control->active());
     QTRY_VERIFY(!transient1->control->active());
     QTRY_VERIFY(!transient2->control->active());
@@ -454,22 +455,22 @@ void StackingOrderTest::testGroupTransientIsAboveWindowGroup()
              (std::deque<Toplevel*>{leader, member1, member2, transient}));
 
     // If we activate any member of the window group, the transient will be above it.
-    Test::app()->workspace->activateClient(leader);
+    win::activate_window(*Test::app()->workspace, leader);
     QTRY_VERIFY(leader->control->active());
     QCOMPARE(Test::app()->workspace->stacking_order->stack,
              (std::deque<Toplevel*>{member1, member2, leader, transient}));
 
-    Test::app()->workspace->activateClient(member1);
+    win::activate_window(*Test::app()->workspace, member1);
     QTRY_VERIFY(member1->control->active());
     QCOMPARE(Test::app()->workspace->stacking_order->stack,
              (std::deque<Toplevel*>{member2, leader, member1, transient}));
 
-    Test::app()->workspace->activateClient(member2);
+    win::activate_window(*Test::app()->workspace, member2);
     QTRY_VERIFY(member2->control->active());
     QCOMPARE(Test::app()->workspace->stacking_order->stack,
              (std::deque<Toplevel*>{leader, member1, member2, transient}));
 
-    Test::app()->workspace->activateClient(transient);
+    win::activate_window(*Test::app()->workspace, transient);
     QTRY_VERIFY(transient->control->active());
     QCOMPARE(Test::app()->workspace->stacking_order->stack,
              (std::deque<Toplevel*>{leader, member1, member2, transient}));
@@ -588,25 +589,25 @@ void StackingOrderTest::testRaiseGroupTransient()
              (std::deque<Toplevel*>{leader, member1, member2, transient, anotherClient}));
 
     // If we activate the leader, then only it and the transient have to be raised.
-    Test::app()->workspace->activateClient(leader);
+    win::activate_window(*Test::app()->workspace, leader);
     QTRY_VERIFY(leader->control->active());
     QCOMPARE(Test::app()->workspace->stacking_order->stack,
              (std::deque<Toplevel*>{member1, member2, anotherClient, leader, transient}));
 
     // If another member of the window group is activated, then the transient will
     // be above that member and the leader.
-    Test::app()->workspace->activateClient(member2);
+    win::activate_window(*Test::app()->workspace, member2);
     QTRY_VERIFY(member2->control->active());
     QCOMPARE(Test::app()->workspace->stacking_order->stack,
              (std::deque<Toplevel*>{member1, anotherClient, leader, member2, transient}));
 
     // FIXME: If we activate the transient, only it will be raised.
-    Test::app()->workspace->activateClient(anotherClient);
+    win::activate_window(*Test::app()->workspace, anotherClient);
     QTRY_VERIFY(anotherClient->control->active());
     QCOMPARE(Test::app()->workspace->stacking_order->stack,
              (std::deque<Toplevel*>{member1, leader, member2, transient, anotherClient}));
 
-    Test::app()->workspace->activateClient(transient);
+    win::activate_window(*Test::app()->workspace, transient);
     QTRY_VERIFY(transient->control->active());
     QCOMPARE(Test::app()->workspace->stacking_order->stack,
              (std::deque<Toplevel*>{anotherClient, member1, leader, member2, transient}));
@@ -819,22 +820,22 @@ void StackingOrderTest::testDontKeepAboveNonModalDialogGroupTransients()
     QCOMPARE(Test::app()->workspace->stacking_order->stack,
              (std::deque<Toplevel*>{leader, member1, member2, transient}));
 
-    Test::app()->workspace->activateClient(leader);
+    win::activate_window(*Test::app()->workspace, leader);
     QTRY_VERIFY(leader->control->active());
     QCOMPARE(Test::app()->workspace->stacking_order->stack,
              (std::deque<Toplevel*>{member1, member2, transient, leader}));
 
-    Test::app()->workspace->activateClient(member1);
+    win::activate_window(*Test::app()->workspace, member1);
     QTRY_VERIFY(member1->control->active());
     QCOMPARE(Test::app()->workspace->stacking_order->stack,
              (std::deque<Toplevel*>{member2, transient, leader, member1}));
 
-    Test::app()->workspace->activateClient(member2);
+    win::activate_window(*Test::app()->workspace, member2);
     QTRY_VERIFY(member2->control->active());
     QCOMPARE(Test::app()->workspace->stacking_order->stack,
              (std::deque<Toplevel*>{transient, leader, member1, member2}));
 
-    Test::app()->workspace->activateClient(transient);
+    win::activate_window(*Test::app()->workspace, transient);
     QTRY_VERIFY(transient->control->active());
     QCOMPARE(Test::app()->workspace->stacking_order->stack,
              (std::deque<Toplevel*>{leader, member1, member2, transient}));
@@ -870,7 +871,7 @@ void StackingOrderTest::testKeepAbove()
              (std::deque<Toplevel*>{clientA, clientB}));
 
     // Go to the initial test position.
-    Test::app()->workspace->activateClient(clientA);
+    win::activate_window(*Test::app()->workspace, clientA);
     QTRY_VERIFY(clientA->control->active());
     QCOMPARE(Test::app()->workspace->stacking_order->stack,
              (std::deque<Toplevel*>{clientB, clientA}));
diff --git a/autotests/integration/x11_client_test.cpp b/autotests/integration/x11_client_test.cpp
index 1f1851a46..fd73979da 100644
--- a/autotests/integration/x11_client_test.cpp
+++ b/autotests/integration/x11_client_test.cpp
@@ -24,6 +24,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "render/compositor.h"
 #include "render/effect_loader.h"
 #include "render/effects.h"
+#include "win/activation.h"
 #include "win/meta.h"
 #include "win/space.h"
 #include "win/stacking_order.h"
@@ -231,20 +232,20 @@ void X11ClientTest::testFullscreenLayerWithActiveWaylandWindow()
     QCOMPARE(client->layer(), win::layer::normal);
 
     // now activate fullscreen again
-    Test::app()->workspace->activateClient(client);
+    win::activate_window(*Test::app()->workspace, client);
     QTRY_VERIFY(client->control->active());
     QCOMPARE(client->layer(), win::layer::active);
     QCOMPARE(Test::app()->workspace->stacking_order->stack.back(), client);
     QCOMPARE(win::render_stack(*Test::app()->workspace->stacking_order).back(), client);
 
     // activate wayland window again
-    Test::app()->workspace->activateClient(waylandClient);
+    win::activate_window(*Test::app()->workspace, waylandClient);
     QTRY_VERIFY(waylandClient->control->active());
     QCOMPARE(Test::app()->workspace->stacking_order->stack.back(), waylandClient);
     QCOMPARE(win::render_stack(*Test::app()->workspace->stacking_order).back(), waylandClient);
 
     // back to x window
-    Test::app()->workspace->activateClient(client);
+    win::activate_window(*Test::app()->workspace, client);
     QTRY_VERIFY(client->control->active());
     // remove fullscreen
     QVERIFY(client->control->fullscreen());
@@ -257,13 +258,13 @@ void X11ClientTest::testFullscreenLayerWithActiveWaylandWindow()
     QCOMPARE(win::render_stack(*Test::app()->workspace->stacking_order).back(), client);
 
     // activate wayland window again
-    Test::app()->workspace->activateClient(waylandClient);
+    win::activate_window(*Test::app()->workspace, waylandClient);
     QTRY_VERIFY(waylandClient->control->active());
     QCOMPARE(Test::app()->workspace->stacking_order->stack.back(), waylandClient);
     QCOMPARE(win::render_stack(*Test::app()->workspace->stacking_order).back(), waylandClient);
 
     // back to X11 window
-    Test::app()->workspace->activateClient(client);
+    win::activate_window(*Test::app()->workspace, client);
     QTRY_VERIFY(client->control->active());
 
     // remove fullscreen
@@ -292,7 +293,7 @@ void X11ClientTest::testFullscreenLayerWithActiveWaylandWindow()
     QCOMPARE(win::render_stack(*Test::app()->workspace->stacking_order).back(), client);
 
     // activate wayland window again
-    Test::app()->workspace->activateClient(waylandClient);
+    win::activate_window(*Test::app()->workspace, waylandClient);
     QTRY_VERIFY(waylandClient->control->active());
     QCOMPARE(Test::app()->workspace->stacking_order->stack.back(), waylandClient);
     QCOMPARE(win::render_stack(*Test::app()->workspace->stacking_order).back(), waylandClient);
@@ -357,10 +358,12 @@ void X11ClientTest::testFocusInWithWaylandLastActiveWindow()
     auto waylandClient = Test::render_and_wait_for_shown(surface, QSize(100, 50), Qt::blue);
     QVERIFY(waylandClient);
     QVERIFY(waylandClient->control->active());
+
     // activate no window
-    Test::app()->workspace->setActiveClient(nullptr);
+    win::set_active_window(*Test::app()->workspace, nullptr);
     QVERIFY(!waylandClient->control->active());
     QVERIFY(!Test::app()->workspace->active_client);
+
     // and close Wayland window again
     shellSurface.reset();
     surface.reset();
@@ -739,7 +742,7 @@ void X11ClientTest::testFullscreenWindowGroups()
     QCOMPARE(client->layer(), win::layer::normal);
 
     // activating the fullscreen window again, should move it to active layer
-    Test::app()->workspace->activateClient(client);
+    win::activate_window(*Test::app()->workspace, client);
     QTRY_COMPARE(client->layer(), win::layer::active);
 }
 
diff --git a/autotests/integration/xdgshellclient_rules_test.cpp b/autotests/integration/xdgshellclient_rules_test.cpp
index 1010f1af9..ca4023504 100644
--- a/autotests/integration/xdgshellclient_rules_test.cpp
+++ b/autotests/integration/xdgshellclient_rules_test.cpp
@@ -1806,7 +1806,7 @@ void TestXdgShellClientRules::testDesktopApply()
     QCOMPARE(vd_manager->current(), 2);
 
     // We still should be able to move the client between desktops.
-    Test::app()->workspace->sendClientToDesktop(client, 1, true);
+    win::send_window_to_desktop(*Test::app()->workspace, client, 1, true);
     QCOMPARE(client->desktop(), 1);
     QCOMPARE(vd_manager->current(), 2);
 
@@ -1859,7 +1859,7 @@ void TestXdgShellClientRules::testDesktopRemember()
     QCOMPARE(vd_manager->current(), 2);
 
     // Move the client to the first virtual desktop.
-    Test::app()->workspace->sendClientToDesktop(client, 1, true);
+    win::send_window_to_desktop(*Test::app()->workspace, client, 1, true);
     QCOMPARE(client->desktop(), 1);
     QCOMPARE(vd_manager->current(), 2);
 
@@ -1912,7 +1912,7 @@ void TestXdgShellClientRules::testDesktopForce()
     QCOMPARE(vd_manager->current(), 2);
 
     // Any attempt to move the client to another virtual desktop should fail.
-    Test::app()->workspace->sendClientToDesktop(client, 1, true);
+    win::send_window_to_desktop(*Test::app()->workspace, client, 1, true);
     QCOMPARE(client->desktop(), 2);
     QCOMPARE(vd_manager->current(), 2);
 
@@ -1969,7 +1969,7 @@ void TestXdgShellClientRules::testDesktopApplyNow()
     QCOMPARE(vd_manager->current(), 1);
 
     // One should still be able to move the client between desktops.
-    Test::app()->workspace->sendClientToDesktop(client, 1, true);
+    win::send_window_to_desktop(*Test::app()->workspace, client, 1, true);
     QCOMPARE(client->desktop(), 1);
     QCOMPARE(vd_manager->current(), 1);
 
@@ -2018,7 +2018,7 @@ void TestXdgShellClientRules::testDesktopForceTemporarily()
     QCOMPARE(vd_manager->current(), 2);
 
     // Any attempt to move the client to another virtual desktop should fail.
-    Test::app()->workspace->sendClientToDesktop(client, 1, true);
+    win::send_window_to_desktop(*Test::app()->workspace, client, 1, true);
     QCOMPARE(client->desktop(), 2);
     QCOMPARE(vd_manager->current(), 2);
 
@@ -2034,10 +2034,10 @@ void TestXdgShellClientRules::testDesktopForceTemporarily()
     QCOMPARE(vd_manager->current(), 1);
 
     // One should be able to move the client between desktops.
-    Test::app()->workspace->sendClientToDesktop(client, 2, true);
+    win::send_window_to_desktop(*Test::app()->workspace, client, 2, true);
     QCOMPARE(client->desktop(), 2);
     QCOMPARE(vd_manager->current(), 1);
-    Test::app()->workspace->sendClientToDesktop(client, 1, true);
+    win::send_window_to_desktop(*Test::app()->workspace, client, 1, true);
     QCOMPARE(client->desktop(), 1);
     QCOMPARE(vd_manager->current(), 1);
 
@@ -4138,7 +4138,7 @@ void TestXdgShellClientRules::testInactiveOpacityDontAffect()
     QVERIFY(client->control->active());
 
     // Make the client inactive.
-    Test::app()->workspace->setActiveClient(nullptr);
+    win::set_active_window(*Test::app()->workspace, nullptr);
     QVERIFY(!client->control->active());
 
     // The opacity of the client should not be affected by the rule.
@@ -4175,7 +4175,7 @@ void TestXdgShellClientRules::testInactiveOpacityForce()
     QCOMPARE(client->opacity(), 1.0);
 
     // Make the client inactive.
-    Test::app()->workspace->setActiveClient(nullptr);
+    win::set_active_window(*Test::app()->workspace, nullptr);
     QVERIFY(!client->control->active());
 
     // The opacity should be forced by the rule.
@@ -4212,7 +4212,7 @@ void TestXdgShellClientRules::testInactiveOpacityForceTemporarily()
     QCOMPARE(client->opacity(), 1.0);
 
     // Make the client inactive.
-    Test::app()->workspace->setActiveClient(nullptr);
+    win::set_active_window(*Test::app()->workspace, nullptr);
     QVERIFY(!client->control->active());
 
     // The opacity should be forced by the rule.
@@ -4225,7 +4225,7 @@ void TestXdgShellClientRules::testInactiveOpacityForceTemporarily()
     QVERIFY(client);
     QVERIFY(client->control->active());
     QCOMPARE(client->opacity(), 1.0);
-    Test::app()->workspace->setActiveClient(nullptr);
+    win::set_active_window(*Test::app()->workspace, nullptr);
     QVERIFY(!client->control->active());
     QCOMPARE(client->opacity(), 1.0);
 
diff --git a/autotests/integration/xdgshellclient_test.cpp b/autotests/integration/xdgshellclient_test.cpp
index 30c506e14..c0384ecb5 100644
--- a/autotests/integration/xdgshellclient_test.cpp
+++ b/autotests/integration/xdgshellclient_test.cpp
@@ -266,7 +266,7 @@ void TestXdgShellClient::testDesktopPresenceChanged()
     QVERIFY(desktopPresenceChangedEffectsSpy.isValid());
 
     // let's change the desktop
-    Test::app()->workspace->sendClientToDesktop(c, 2, false);
+    win::send_window_to_desktop(*Test::app()->workspace, c, 2, false);
     QCOMPARE(c->desktop(), 2);
     QCOMPARE(desktopPresenceChangedClientSpy.count(), 1);
     QCOMPARE(desktopPresenceChangedWorkspaceSpy.count(), 1);
@@ -1085,7 +1085,7 @@ void TestXdgShellClient::testSendClientWithTransientToDesktop()
     QCOMPARE(transient->desktop(), 2);
 
     // activate c
-    Test::app()->workspace->activateClient(c);
+    win::activate_window(*Test::app()->workspace, c);
     QCOMPARE(Test::app()->workspace->active_client, c);
     QVERIFY(c->control->active());
 
diff --git a/autotests/integration/xwayland_selections_test.cpp b/autotests/integration/xwayland_selections_test.cpp
index 287b2fe5d..bc4a16e20 100644
--- a/autotests/integration/xwayland_selections_test.cpp
+++ b/autotests/integration/xwayland_selections_test.cpp
@@ -21,6 +21,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "lib/app.h"
 
 #include "base/wayland/server.h"
+#include "win/activation.h"
 #include "win/space.h"
 #include "win/wayland/space.h"
 #include "win/wayland/window.h"
@@ -146,7 +147,7 @@ void XwaylandSelectionsTest::testSync()
     }
     QVERIFY(copyClient);
     if (Test::app()->workspace->active_client != copyClient) {
-        Test::app()->workspace->activateClient(copyClient);
+        win::activate_window(*Test::app()->workspace, copyClient);
     }
     QCOMPARE(Test::app()->workspace->active_client, copyClient);
     if (copyPlatform == QLatin1String("xcb")) {
@@ -190,7 +191,7 @@ void XwaylandSelectionsTest::testSync()
         QSignalSpy clientActivatedSpy(Test::app()->workspace->qobject.get(),
                                       &win::space::qobject_t::clientActivated);
         QVERIFY(clientActivatedSpy.isValid());
-        Test::app()->workspace->activateClient(pasteClient);
+        win::activate_window(*Test::app()->workspace, pasteClient);
         QVERIFY(clientActivatedSpy.wait());
     }
     QTRY_COMPARE(Test::app()->workspace->active_client, pasteClient);
diff --git a/input/filters/drag_and_drop.cpp b/input/filters/drag_and_drop.cpp
index d69dcaacb..e020a4c47 100644
--- a/input/filters/drag_and_drop.cpp
+++ b/input/filters/drag_and_drop.cpp
@@ -11,6 +11,7 @@
 #include "input/touch_redirect.h"
 #include "main.h"
 #include "toplevel.h"
+#include "win/activation.h"
 #include "win/space.h"
 #include "xwl/xwayland_interface.h"
 
@@ -76,7 +77,7 @@ bool drag_and_drop_filter::motion(motion_event const& event)
         // TODO: consider decorations
         if (window->surface != seat->drags().get_target().surface) {
             if (window->control) {
-                redirect.space.activateClient(window);
+                win::activate_window(redirect.space, window);
             }
             seat->drags().set_target(window->surface, window->input_transform());
         }
@@ -135,7 +136,7 @@ bool drag_and_drop_filter::touch_motion(touch_motion_event const& event)
         // TODO: consider decorations
         if (t->surface != seat->drags().get_target().surface) {
             if (t->control) {
-                redirect.space.activateClient(t);
+                win::activate_window(redirect.space, t);
             }
             seat->drags().set_target(t->surface, event.pos, t->input_transform());
         }
diff --git a/render/effects.cpp b/render/effects.cpp
index 6f3e2c734..43546f15e 100644
--- a/render/effects.cpp
+++ b/render/effects.cpp
@@ -37,8 +37,10 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "input/cursor.h"
 #include "input/pointer_redirect.h"
 #include "scripting/effect.h"
+#include "win/activation.h"
 #include "win/control.h"
 #include "win/deco/bridge.h"
+#include "win/desktop_space.h"
 #include "win/internal_window.h"
 #include "win/meta.h"
 #include "win/osd.h"
@@ -896,7 +898,7 @@ void effects_handler_impl::activateWindow(EffectWindow* c)
 {
     auto window = static_cast<effects_window_impl*>(c)->window();
     if (window && window->control) {
-        m_compositor->space->activateClient(window, true);
+        win::force_activate_window(*m_compositor->space, window);
     }
 }
 
@@ -927,7 +929,7 @@ void effects_handler_impl::windowToDesktop(EffectWindow* w, int desktop)
 {
     auto window = static_cast<effects_window_impl*>(w)->window();
     if (window && window->control && !win::is_desktop(window) && !win::is_dock(window)) {
-        m_compositor->space->sendClientToDesktop(window, desktop, true);
+        win::send_window_to_desktop(*m_compositor->space, window, desktop, true);
     }
 }
 
diff --git a/rules/window_rules.cpp b/rules/window_rules.cpp
index 364add084..ceda0304b 100644
--- a/rules/window_rules.cpp
+++ b/rules/window_rules.cpp
@@ -308,8 +308,10 @@ void Toplevel::applyWindowRules()
 
     // FSP
     // AcceptFocus :
-    if (space.mostRecentlyActivatedClient() == this && !client_rules.checkAcceptFocus(true))
-        space.activateNextClient(this);
+    if (win::most_recently_activated_window(space) == this
+        && !client_rules.checkAcceptFocus(true)) {
+        win::activate_next_window(space, this);
+    }
 
     // Closeable
     if (auto s = size(); s != size() && s.isValid()) {
diff --git a/scripting/space.h b/scripting/space.h
index 118010679..e1ddf9a53 100644
--- a/scripting/space.h
+++ b/scripting/space.h
@@ -26,6 +26,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "base/platform.h"
 #include "debug/support_info.h"
 #include "main.h"
+#include "win/activation.h"
 #include "win/move.h"
 #include "win/screen.h"
 #include "win/virtual_desktops.h"
@@ -641,7 +642,7 @@ public:
 
     void setActiveClient(window* win) override
     {
-        ref_space->activateClient(win->client());
+        win::activate_window(*ref_space, win->client());
     }
 
     QSize desktopGridSize() const override
diff --git a/win/activation.h b/win/activation.h
index 775142723..641cd0924 100644
--- a/win/activation.h
+++ b/win/activation.h
@@ -5,14 +5,275 @@
 */
 #pragma once
 
+#include "actions.h"
 #include "layers.h"
+#include "screen.h"
 #include "stacking_order.h"
+#include "user_actions_menu.h"
+#include "window_find.h"
+#include "x11/user_time.h"
 
 #include "utils/blocker.h"
 
 namespace KWin::win
 {
 
+/**
+ Prevention of focus stealing:
+
+ KWin tries to prevent unwanted changes of focus, that would result
+ from mapping a new window. Also, some nasty applications may try
+ to force focus change even in cases when ICCCM 4.2.7 doesn't allow it
+ (e.g. they may try to activate their main window because the user
+ definitely "needs" to see something happened - misusing
+ of QWidget::setActiveWindow() may be such case).
+
+ There are 4 ways how a window may become active:
+ - the user changes the active window (e.g. focus follows mouse, clicking
+   on some window's titlebar) - the change of focus will
+   be done by KWin, so there's nothing to solve in this case
+ - the change of active window will be requested using the _NET_ACTIVE_WINDOW
+   message (handled in RootInfo::changeActiveWindow()) - such requests
+   will be obeyed, because this request is meant mainly for e.g. taskbar
+   asking the WM to change the active window as a result of some user action.
+   Normal applications should use this request only rarely in special cases.
+   See also below the discussion of _NET_ACTIVE_WINDOW_TRANSFER.
+ - the change of active window will be done by performing XSetInputFocus()
+   on a window that's not currently active. ICCCM 4.2.7 describes when
+   the application may perform change of input focus. In order to handle
+   misbehaving applications, KWin will try to detect focus changes to
+   windows that don't belong to currently active application, and restore
+   focus back to the currently active window, instead of activating the window
+   that got focus (unfortunately there's no way to FocusChangeRedirect similar
+   to e.g. SubstructureRedirect, so there will be short time when the focus
+   will be changed). The check itself that's done is
+   space::allowClientActivation() (see below).
+ - a new window will be mapped - this is the most complicated case. If
+   the new window belongs to the currently active application, it may be safely
+   mapped on top and activated. The same if there's no active window,
+   or the active window is the desktop. These checks are done by
+   space::allowClientActivation().
+    Following checks need to compare times. One time is the timestamp
+   of last user action in the currently active window, the other time is
+   the timestamp of the action that originally caused mapping of the new window
+   (e.g. when the application was started). If the first time is newer than
+   the second one, the window will not be activated, as that indicates
+   futher user actions took place after the action leading to this new
+   mapped window. This check is done by space::allowClientActivation().
+    There are several ways how to get the timestamp of action that caused
+   the new mapped window (done in x11::window::readUserTimeMapTimestamp()) :
+     - the window may have the _NET_WM_USER_TIME property. This way
+       the application may either explicitly request that the window is not
+       activated (by using 0 timestamp), or the property contains the time
+       of last user action in the application.
+     - KWin itself tries to detect time of last user action in every window,
+       by watching KeyPress and ButtonPress events on windows. This way some
+       events may be missed (if they don't propagate to the toplevel window),
+       but it's good as a fallback for applications that don't provide
+       _NET_WM_USER_TIME, and missing some events may at most lead
+       to unwanted focus stealing.
+     - the timestamp may come from application startup notification.
+       Application startup notification, if it exists for the new mapped window,
+       should include time of the user action that caused it.
+     - if there's no timestamp available, it's checked whether the new window
+       belongs to some already running application - if yes, the timestamp
+       will be 0 (i.e. refuse activation)
+     - if the window is from session restored window, the timestamp will
+       be 0 too, unless this application was the active one at the time
+       when the session was saved, in which case the window will be
+       activated if there wasn't any user interaction since the time
+       KWin was started.
+     - as the last resort, the _KDE_NET_USER_CREATION_TIME timestamp
+       is used. For every toplevel window that is created (see CreateNotify
+       handling), this property is set to the at that time current time.
+       Since at this time it's known that the new window doesn't belong
+       to any existing application (better said, the application doesn't
+       have any other window mapped), it is either the very first window
+       of the application, or it is the only window of the application
+       that was hidden before. The latter case is handled by removing
+       the property from windows before withdrawing them, making
+       the timestamp empty for next mapping of the window. In the sooner
+       case, the timestamp will be used. This helps in case when
+       an application is launched without application startup notification,
+       it creates its mainwindow, and starts its initialization (that
+       may possibly take long time). The timestamp used will be older
+       than any user action done after launching this application.
+     - if no timestamp is found at all, the window is activated.
+    The check whether two windows belong to the same application (same
+   process) is done in x11::window::belongToSameApplication(). Not 100% reliable,
+   but hopefully 99,99% reliable.
+
+ As a somewhat special case, window activation is always enabled when
+ session saving is in progress. When session saving, the session
+ manager allows only one application to interact with the user.
+ Not allowing window activation in such case would result in e.g. dialogs
+ not becoming active, so focus stealing prevention would cause here
+ more harm than good.
+
+ Windows that attempted to become active but KWin prevented this will
+ be marked as demanding user attention. They'll get
+ the _NET_WM_STATE_DEMANDS_ATTENTION state, and the taskbar should mark
+ them specially (blink, etc.). The state will be reset when the window
+ eventually really becomes active.
+
+ There are two more ways how a window can become obtrusive, window stealing
+ focus: By showing above the active window, by either raising itself,
+ or by moving itself on the active desktop.
+     - KWin will refuse raising non-active window above the active one,
+         unless they belong to the same application. Applications shouldn't
+         raise their windows anyway (unless the app wants to raise one
+         of its windows above another of its windows).
+     - KWin activates windows moved to the current desktop (as that seems
+         logical from the user's point of view, after sending the window
+         there directly from KWin, or e.g. using pager). This means
+         applications shouldn't send their windows to another desktop
+         (SELI TODO - but what if they do?)
+
+ Special cases I can think of:
+    - konqueror reusing, i.e. kfmclient tells running Konqueror instance
+        to open new window
+        - without focus stealing prevention - no problem
+        - with ASN (application startup notification) - ASN is forwarded,
+            and because it's newer than the instance's user timestamp,
+            it takes precedence
+        - without ASN - user timestamp needs to be reset, otherwise it would
+            be used, and it's old; moreover this new window mustn't be detected
+            as window belonging to already running application, or it wouldn't
+            be activated - see x11::window::sameAppWindowRoleMatch() for the (rather ugly)
+            hack
+    - konqueror preloading, i.e. window is created in advance, and kfmclient
+        tells this Konqueror instance to show it later
+        - without focus stealing prevention - no problem
+        - with ASN - ASN is forwarded, and because it's newer than the instance's
+            user timestamp, it takes precedence
+        - without ASN - user timestamp needs to be reset, otherwise it would
+            be used, and it's old; also, creation timestamp is changed to
+            the time the instance starts (re-)initializing the window,
+            this ensures creation timestamp will still work somewhat even in this case
+    - KUniqueApplication - when the window is already visible, and the new instance
+        wants it to activate
+        - without focus stealing prevention - _NET_ACTIVE_WINDOW - no problem
+        - with ASN - ASN is forwarded, and set on the already visible window, KWin
+            treats the window as new with that ASN
+        - without ASN - _NET_ACTIVE_WINDOW as application request is used,
+                and there's no really usable timestamp, only timestamp
+                from the time the (new) application instance was started,
+                so KWin will activate the window *sigh*
+                - the bad thing here is that there's absolutely no chance to recognize
+                    the case of starting this KUniqueApp from Konsole (and thus wanting
+                    the already visible window to become active) from the case
+                    when something started this KUniqueApp without ASN (in which case
+                    the already visible window shouldn't become active)
+                - the only solution is using ASN for starting applications, at least silent
+                    (i.e. without feedback)
+    - when one application wants to activate another application's window (e.g. KMail
+        activating already running KAddressBook window ?)
+        - without focus stealing prevention - _NET_ACTIVE_WINDOW - no problem
+        - with ASN - can't be here, it's the KUniqueApp case then
+        - without ASN - _NET_ACTIVE_WINDOW as application request should be used,
+            KWin will activate the new window depending on the timestamp and
+            whether it belongs to the currently active application
+
+ _NET_ACTIVE_WINDOW usage:
+ data.l[0]= 1 ->app request
+          = 2 ->pager request
+          = 0 - backwards compatibility
+ data.l[1]= timestamp
+*/
+
+template<typename Space>
+bool is_focus_change_allowed(Space& space)
+{
+    return space.block_focus == 0;
+}
+
+template<typename Space>
+void cancel_delay_focus(Space& space)
+{
+    delete space.delayFocusTimer;
+    space.delayFocusTimer = nullptr;
+}
+
+/**
+ * Request focus and optionally try raising the window.
+ *
+ * Tries to activate the client by asking X for the input focus. This
+ * function does not perform any show, raise or desktop switching. See
+ * activate_window() instead.
+ *
+ * @see activate_window
+ */
+template<typename Space>
+void request_focus(Space& space, Toplevel* window, bool raise = false, bool force_focus = false)
+{
+    auto take_focus = is_focus_change_allowed(space) || window == space.active_client;
+
+    if (!window) {
+        focus_to_null(space);
+        return;
+    }
+
+    if (take_focus) {
+        auto modal = window->findModal();
+        if (modal && modal->control && modal != window) {
+            if (!modal->isOnDesktop(window->desktop())) {
+                set_desktop(modal, window->desktop());
+            }
+            if (!modal->isShown() && !modal->control->minimized()) {
+                // forced desktop or utility window
+                // activating a minimized blocked window will unminimize its modal implicitly
+                activate_window(space, modal);
+            }
+            // if the click was inside the window (i.e. handled is set),
+            // but it has a modal, there's no need to use handled mode, because
+            // the modal doesn't get the click anyway
+            // raising of the original window needs to be still done
+            if (raise) {
+                raise_window(&space, window);
+            }
+            window = modal;
+        }
+        cancel_delay_focus(space);
+    }
+
+    if (!force_focus && (is_dock(window) || is_splash(window))) {
+        // toplevel menus and dock windows don't take focus if not forced
+        // and don't have a flag that they take focus
+        if (!window->dockWantsInput()) {
+            take_focus = false;
+        }
+    }
+
+    if (!window->isShown()) {
+        // Shouldn't happen, call activate_window() if needed.
+        qCWarning(KWIN_CORE) << "request_focus: not shown";
+        return;
+    }
+
+    if (take_focus) {
+        window->takeFocus();
+    }
+    if (raise) {
+        raise_window(&space, window);
+    }
+
+    if (!on_active_screen(window)) {
+        base::set_current_output(kwinApp()->get_base(), window->central_output);
+    }
+}
+
+/**
+ * Puts the focus on a dummy window
+ * Just using XSetInputFocus() with None would block keyboard input
+ */
+template<typename Space>
+void focus_to_null(Space& space)
+{
+    if (space.m_nullFocus) {
+        space.m_nullFocus->focus();
+    }
+}
+
 template<typename Win>
 void set_demands_attention(Win* win, bool demand)
 {
@@ -55,7 +316,7 @@ void set_active(Win* win, bool active)
         : win->control->rules().checkOpacityInactive(qRound(win->opacity() * 100.0));
     win->setOpacity(ruledOpacity / 100.0);
 
-    win->space.setActiveClient(active ? win : nullptr);
+    set_active_window(win->space, active ? win : nullptr);
 
     if (!active) {
         win->control->cancel_auto_raise();
@@ -82,4 +343,244 @@ void set_active(Win* win, bool active)
     win->control->update_mouse_grab();
 }
 
+/**
+ * Informs the space:: about the active client, i.e. the client that
+ * has the focus (or None if no client has the focus). This functions
+ * is called by the client itself that gets focus. It has no other
+ * effect than fixing the focus chain and the return value of
+ * activeClient(). And of course, to propagate the active client to the
+ * world.
+ */
+template<typename Space>
+void set_active_window(Space& space, Toplevel* window)
+{
+    if (space.active_client == window)
+        return;
+
+    if (space.active_popup && space.active_popup_client != window
+        && space.set_active_client_recursion == 0) {
+        close_active_popup(space);
+    }
+    if (space.user_actions_menu->hasClient() && !space.user_actions_menu->isMenuClient(window)
+        && space.set_active_client_recursion == 0) {
+        space.user_actions_menu->close();
+    }
+
+    blocker block(space.stacking_order);
+    ++space.set_active_client_recursion;
+    space.focusMousePos = input::get_cursor()->pos();
+
+    if (space.active_client != nullptr) {
+        // note that this may call setActiveClient( NULL ), therefore the recursion counter
+        set_active(space.active_client, false);
+    }
+
+    space.active_client = window;
+    assert(!window || window->control->active());
+
+    if (space.active_client) {
+        space.last_active_client = space.active_client;
+        focus_chain_update(space.focus_chain, space.active_client, focus_chain_change::make_first);
+        set_demands_attention(space.active_client, false);
+
+        // activating a client can cause a non active fullscreen window to loose the ActiveLayer
+        // status on > 1 screens
+        if (kwinApp()->get_base().get_outputs().size() > 1) {
+            for (auto win : space.m_windows) {
+                if (win->control && win != space.active_client && win->layer() == win::layer::active
+                    && win->central_output == space.active_client->central_output) {
+                    update_layer(win);
+                }
+            }
+        }
+    }
+
+    x11::update_tool_windows_visibility(&space, false);
+    if (window) {
+        space.disableGlobalShortcutsForClient(
+            window->control->rules().checkDisableGlobalShortcuts(false));
+    } else {
+        space.disableGlobalShortcutsForClient(false);
+    }
+
+    // e.g. fullscreens have different layer when active/not-active
+    space.stacking_order->update_order();
+
+    if (win::x11::rootInfo()) {
+        win::x11::rootInfo()->setActiveClient(space.active_client);
+    }
+
+    Q_EMIT space.qobject->clientActivated(space.active_client);
+    --space.set_active_client_recursion;
+}
+
+template<typename Space, typename Win>
+void activate_window_impl(Space& space, Win* window, bool force)
+{
+    if (window == nullptr) {
+        focus_to_null(space);
+        set_active_window(space, nullptr);
+        return;
+    }
+    raise_window(&space, window);
+    if (!window->isOnCurrentDesktop()) {
+        ++space.block_focus;
+        space.virtual_desktop_manager->setCurrent(window->desktop());
+        --space.block_focus;
+    }
+    if (window->control->minimized()) {
+        set_minimized(window, false);
+    }
+
+    // ensure the window is really visible - could eg. be a hidden utility window, see bug
+    // #348083
+    window->hideClient(false);
+
+    // TODO force should perhaps allow this only if the window already contains the mouse
+    if (kwinApp()->options->focusPolicyIsReasonable() || force) {
+        request_focus(space, window, false, force);
+    }
+
+    // Don't update user time for clients that have focus stealing workaround.
+    // As they usually belong to the current active window but fail to provide
+    // this information, updating their user time would make the user time
+    // of the currently active window old, and reject further activation for it.
+    // E.g. typing URL in minicli which will show kio_uiserver dialog (with workaround),
+    // and then kdesktop shows dialog about SSL certificate.
+    // This needs also avoiding user creation time in x11::window::readUserTimeMapTimestamp().
+    if (auto client = dynamic_cast<x11::window*>(window)) {
+        // updateUserTime is X11 specific
+        x11::update_user_time(client);
+    }
+}
+
+template<typename Space>
+void activate_window(Space& space, Toplevel* window)
+{
+    activate_window_impl(space, window, false);
+}
+
+template<typename Space, typename Win>
+void force_activate_window(Space& space, Win* window)
+{
+    activate_window_impl(space, window, true);
+}
+
+/// Deactivates 'window' and activates next one.
+template<typename Space>
+bool activate_next_window(Space& space, Toplevel* window)
+{
+    // If 'window' is not the active or the to-become active one, do nothing.
+    if (!(window == space.active_client
+          || (space.should_get_focus.size() > 0 && window == space.should_get_focus.back()))) {
+        return false;
+    }
+
+    close_active_popup(space);
+
+    if (window != nullptr) {
+        if (window == space.active_client) {
+            set_active_window(space, nullptr);
+        }
+        space.should_get_focus.erase(
+            std::remove(space.should_get_focus.begin(), space.should_get_focus.end(), window),
+            space.should_get_focus.end());
+    }
+
+    // if blocking focus, move focus to the desktop later if needed
+    // in order to avoid flickering
+    if (!is_focus_change_allowed(space)) {
+        focus_to_null(space);
+        return true;
+    }
+
+    if (!kwinApp()->options->focusPolicyIsReasonable())
+        return false;
+
+    Toplevel* get_focus = nullptr;
+
+    int const desktop = space.virtual_desktop_manager->current();
+
+    if (!get_focus && space.showingDesktop()) {
+        // to not break the state
+        get_focus = find_desktop(&space, true, desktop);
+    }
+
+    if (!get_focus && kwinApp()->options->isNextFocusPrefersMouse()) {
+        get_focus
+            = space.clientUnderMouse(window ? window->central_output : get_current_output(space));
+        if (get_focus && (get_focus == window || is_desktop(get_focus))) {
+            // should rather not happen, but it cannot get the focus. rest of usability is tested
+            // above
+            get_focus = nullptr;
+        }
+    }
+
+    if (!get_focus) { // no suitable window under the mouse -> find sth. else
+        // first try to pass the focus to the (former) active clients leader
+        if (window && window->transient()->lead()) {
+            auto leaders = window->transient()->leads();
+            if (leaders.size() == 1
+                && focus_chain_is_usable_focus_candidate(
+                    space.focus_chain, leaders.at(0), window)) {
+                get_focus = leaders.at(0);
+
+                // also raise - we don't know where it came from
+                win::raise_window(&space, get_focus);
+            }
+        }
+        if (!get_focus) {
+            // nope, ask the focus chain for the next candidate
+            get_focus = focus_chain_next_for_desktop(space.focus_chain, window, desktop);
+        }
+    }
+
+    if (!get_focus) {
+        // last chance: focus the desktop
+        get_focus = find_desktop(&space, true, desktop);
+    }
+
+    if (get_focus) {
+        request_focus(space, get_focus);
+    } else {
+        focus_to_null(space);
+    }
+
+    return true;
+}
+
+template<typename Space>
+void delay_focus(Space& space)
+{
+    request_focus(space, space.delayfocus_client);
+    cancel_delay_focus(space);
+}
+
+template<typename Space>
+void request_delay_focus(Space& space, Toplevel* c)
+{
+    space.delayfocus_client = c;
+
+    delete space.delayFocusTimer;
+    space.delayFocusTimer = new QTimer(space.qobject.get());
+
+    QObject::connect(space.delayFocusTimer, &QTimer::timeout, space.qobject.get(), [&space] {
+        delay_focus(space);
+    });
+    space.delayFocusTimer->setSingleShot(true);
+    space.delayFocusTimer->start(kwinApp()->options->delayFocusInterval());
+}
+
+template<typename Space>
+void close_active_popup(Space& space)
+{
+    if (space.active_popup) {
+        space.active_popup->close();
+        space.active_popup = nullptr;
+        space.active_popup_client = nullptr;
+    }
+
+    space.user_actions_menu->close();
+}
+
 }
diff --git a/win/desktop_space.h b/win/desktop_space.h
index da7d4d80b..1dc32b968 100644
--- a/win/desktop_space.h
+++ b/win/desktop_space.h
@@ -5,34 +5,150 @@
 */
 #pragma once
 
+#include "activation.h"
+#include "space_areas_helpers.h"
+#include "space_helpers.h"
 #include "toplevel.h"
 
+#include "utils/blocker.h"
+
 namespace KWin::win
 {
 
 template<typename Space>
-Toplevel* find_desktop(Space* space, bool topmost, int desktop)
+void send_window_to_desktop(Space& space, Toplevel* window, int desk, bool dont_activate)
 {
-    // TODO(fsorr): use C++20 std::ranges::reverse_view
-    auto const& list = space->stacking_order->stack;
-    auto is_desktop = [desktop](auto window) {
-        return window->control && window->isOnDesktop(desktop) && win::is_desktop(window)
-            && window->isShown();
-    };
-
-    if (topmost) {
-        auto it = std::find_if(list.rbegin(), list.rend(), is_desktop);
-        if (it != list.rend()) {
-            return *it;
+    if ((desk < 1 && desk != NET::OnAllDesktops)
+        || desk > static_cast<int>(space.virtual_desktop_manager->count())) {
+        return;
+    }
+
+    auto old_desktop = window->desktop();
+    auto was_on_desktop = window->isOnDesktop(desk) || window->isOnAllDesktops();
+    set_desktop(window, desk);
+
+    if (window->desktop() != desk) {
+        // No change or desktop forced
+        return;
+    }
+
+    // window did range checking.
+    desk = window->desktop();
+
+    if (window->isOnDesktop(space.virtual_desktop_manager->current())) {
+        if (win::wants_tab_focus(window) && kwinApp()->options->focusPolicyIsReasonable()
+            && !was_on_desktop && // for stickyness changes
+            !dont_activate) {
+            request_focus(space, window);
+        } else {
+            restack_client_under_active(&space, window);
         }
     } else {
-        // bottom-most
-        auto it = std::find_if(list.begin(), list.end(), is_desktop);
-        if (it != list.end()) {
-            return *it;
+        raise_window(&space, window);
+    }
+
+    check_workspace_position(window, QRect(), old_desktop);
+
+    auto const transients_stacking_order
+        = restacked_by_space_stacking_order(&space, window->transient()->children);
+    for (auto const& transient : transients_stacking_order) {
+        if (transient->control) {
+            send_window_to_desktop(space, transient, desk, dont_activate);
+        }
+    }
+
+    update_space_areas(space);
+}
+
+template<typename Space>
+Toplevel* find_window_to_activate_on_desktop(Space& space, unsigned int desktop)
+{
+    if (space.movingClient != nullptr && space.active_client == space.movingClient
+        && focus_chain_at_desktop_contains(space.focus_chain, space.active_client, desktop)
+        && space.active_client->isShown() && space.active_client->isOnCurrentDesktop()) {
+        // A requestFocus call will fail, as the client is already active
+        return space.active_client;
+    }
+
+    // from actiavtion.cpp
+    if (kwinApp()->options->isNextFocusPrefersMouse()) {
+        auto it = space.stacking_order->stack.cend();
+        while (it != space.stacking_order->stack.cbegin()) {
+            auto client = qobject_cast<win::x11::window*>(*(--it));
+            if (!client) {
+                continue;
+            }
+
+            if (!(client->isShown() && client->isOnDesktop(desktop) && on_active_screen(client)))
+                continue;
+
+            if (client->frameGeometry().contains(input::get_cursor()->pos())) {
+                if (!is_desktop(client)) {
+                    return client;
+                }
+                // Unconditional break, we don't pass focus to some client below an unusable one.
+                break;
+            }
         }
     }
 
-    return nullptr;
+    return focus_chain_get_for_activation_on_current_output<Toplevel>(space.focus_chain, desktop);
+}
+
+template<typename Space>
+void activate_window_on_new_desktop(Space& space, unsigned int desktop)
+{
+    Toplevel* c = nullptr;
+
+    if (kwinApp()->options->focusPolicyIsReasonable()) {
+        c = find_window_to_activate_on_desktop(space, desktop);
+    }
+
+    // If "unreasonable focus policy" and active_client is on_all_desktops and
+    // under mouse (Hence == old_active_client), conserve focus.
+    // (Thanks to Volker Schatz <V.Schatz at thphys.uni-heidelberg.de>)
+    else if (space.active_client && space.active_client->isShown()
+             && space.active_client->isOnCurrentDesktop()) {
+        c = space.active_client;
+    }
+
+    if (!c) {
+        c = find_desktop(&space, true, desktop);
+    }
+
+    if (c != space.active_client) {
+        set_active_window(space, nullptr);
+    }
+
+    if (c) {
+        request_focus(space, c);
+    } else if (auto desktop_client = find_desktop(&space, true, desktop)) {
+        request_focus(space, desktop_client);
+    } else {
+        focus_to_null(space);
+    }
+}
+
+template<typename Space>
+void handle_current_desktop_changed(Space& space, unsigned int oldDesktop, unsigned int newDesktop)
+{
+    close_active_popup(space);
+
+    ++space.block_focus;
+    blocker block(space.stacking_order);
+    update_client_visibility_on_desktop_change(&space, newDesktop);
+
+    // Restore the focus on this desktop
+    --space.block_focus;
+
+    activate_window_on_new_desktop(space, newDesktop);
+    Q_EMIT space.qobject->currentDesktopChanged(oldDesktop, space.movingClient);
+}
+
+template<typename Space>
+void handle_desktop_count_changed(Space& space, unsigned int /*prev*/, unsigned int next)
+{
+    reset_space_areas(space, next);
 }
+
 }
diff --git a/win/input.h b/win/input.h
index 6b46f30dc..31f734eb6 100644
--- a/win/input.h
+++ b/win/input.h
@@ -97,8 +97,9 @@ bool perform_mouse_command(Win& win, base::options::MouseCommand cmd, QPoint con
         // since win is a mouseOp it's however safe to use the client under the mouse instead.
         if (win.control->active() && kwinApp()->options->focusPolicyIsReasonable()) {
             auto next = space.clientUnderMouse(win.central_output);
-            if (next && next != &win)
-                space.request_focus(next);
+            if (next && next != &win) {
+                request_focus(space, next);
+            }
         }
         break;
     }
@@ -132,13 +133,13 @@ bool perform_mouse_command(Win& win, base::options::MouseCommand cmd, QPoint con
             }
         }
 
-        space.request_focus(&win, true);
+        request_focus(space, &win, true);
         base::set_current_output_by_position(base, globalPos);
         replay = replay || mustReplay;
         break;
     }
     case base::options::MouseActivateAndLower:
-        space.request_focus(&win);
+        request_focus(space, &win);
         lower_window(&space, &win);
         base::set_current_output_by_position(base, globalPos);
         replay = replay || !win.control->rules().checkAcceptFocus(win.acceptsFocus());
@@ -146,17 +147,17 @@ bool perform_mouse_command(Win& win, base::options::MouseCommand cmd, QPoint con
     case base::options::MouseActivate:
         // For clickraise mode.
         replay = win.control->active();
-        space.request_focus(&win);
+        request_focus(space, &win);
         base::set_current_output_by_position(base, globalPos);
         replay = replay || !win.control->rules().checkAcceptFocus(win.acceptsFocus());
         break;
     case base::options::MouseActivateRaiseAndPassClick:
-        space.request_focus(&win, true);
+        request_focus(space, &win, true);
         base::set_current_output_by_position(base, globalPos);
         replay = true;
         break;
     case base::options::MouseActivateAndPassClick:
-        space.request_focus(&win);
+        request_focus(space, &win);
         base::set_current_output_by_position(base, globalPos);
         replay = true;
         break;
@@ -210,7 +211,7 @@ bool perform_mouse_command(Win& win, base::options::MouseCommand cmd, QPoint con
     case base::options::MouseActivateRaiseAndMove:
     case base::options::MouseActivateRaiseAndUnrestrictedMove:
         raise_window(&space, &win);
-        space.request_focus(&win);
+        request_focus(space, &win);
         base::set_current_output_by_position(base, globalPos);
         // Fallthrough
     case base::options::MouseMove:
@@ -301,7 +302,7 @@ void enter_event(Win* win, const QPoint& globalPos)
     }
 
     if (kwinApp()->options->isAutoRaise() && !win::is_desktop(win) && !win::is_dock(win)
-        && space->focusChangeEnabled() && globalPos != space->focusMousePos
+        && is_focus_change_allowed(*space) && globalPos != space->focusMousePos
         && top_client_on_desktop(space,
                                  win->space.virtual_desktop_manager->current(),
                                  kwinApp()->options->isSeparateScreenFocus() ? win->central_output
@@ -318,7 +319,7 @@ void enter_event(Win* win, const QPoint& globalPos)
     // focus change came because of window changes (e.g. closing a window) - #92290
     if (kwinApp()->options->focusPolicy() != base::options::FocusFollowsMouse
         || globalPos != space->focusMousePos) {
-        space->requestDelayFocus(win);
+        request_delay_focus(*space, win);
     }
 }
 
@@ -326,7 +327,7 @@ template<typename Win>
 void leave_event(Win* win)
 {
     win->control->cancel_auto_raise();
-    win->space.cancelDelayFocus();
+    cancel_delay_focus(win->space);
     // TODO: send hover leave to deco
     // TODO: handle base::options::FocusStrictlyUnderMouse
 }
diff --git a/win/internal_window.cpp b/win/internal_window.cpp
index 2d54efa67..596bf6aa6 100644
--- a/win/internal_window.cpp
+++ b/win/internal_window.cpp
@@ -30,6 +30,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "scene.h"
 #include "setup.h"
 #include "space.h"
+#include "space_areas_helpers.h"
 #include "space_helpers.h"
 #include "window_release.h"
 
@@ -162,7 +163,7 @@ bool internal_window::eventFilter(QObject* watched, QEvent* event)
         }
         if (pe->propertyName() == "kwin_windowType") {
             m_windowType = m_internalWindow->property("kwin_windowType").value<NET::WindowType>();
-            space.updateClientArea();
+            update_space_areas(space);
         }
     }
     return false;
@@ -457,7 +458,7 @@ void internal_window::destroyClient()
 
     remove_window_from_lists(space, this);
     space.stacking_order->update_count();
-    space.updateClientArea();
+    update_space_areas(space);
     Q_EMIT space.qobject->internalClientRemoved(this);
 
     if (deleted) {
@@ -627,7 +628,7 @@ void internal_window::markAsMapped()
     }
 
     space.stacking_order->update_count();
-    space.updateClientArea();
+    update_space_areas(space);
 
     Q_EMIT space.qobject->internalClientAdded(this);
 }
diff --git a/win/layers.h b/win/layers.h
index 333ee563c..0148d38aa 100644
--- a/win/layers.h
+++ b/win/layers.h
@@ -19,6 +19,17 @@ class Toplevel;
 namespace win
 {
 
+/**
+ * Window that was activated, but it's not yet really active_client, because
+ * we didn't process yet the matching FocusIn event. Used mostly in focus
+ * stealing prevention code.
+ */
+template<typename Space>
+Toplevel* most_recently_activated_window(Space const& space)
+{
+    return space.should_get_focus.size() > 0 ? space.should_get_focus.back() : space.active_client;
+}
+
 template<typename Win>
 bool is_active_fullscreen(Win const* win)
 {
@@ -27,7 +38,7 @@ bool is_active_fullscreen(Win const* win)
     }
 
     // Instead of activeClient() - avoids flicker.
-    auto const ac = win->space.mostRecentlyActivatedClient();
+    auto const ac = most_recently_activated_window(win->space);
 
     // According to NETWM spec implementation notes suggests "focused windows having state
     // _NET_WM_STATE_FULLSCREEN" to be on the highest layer. Also take the screen into account.
diff --git a/win/output_space.h b/win/output_space.h
new file mode 100644
index 000000000..cda01e35e
--- /dev/null
+++ b/win/output_space.h
@@ -0,0 +1,41 @@
+/*
+    SPDX-FileCopyrightText: 2022 Roman Gilg <subdiff@gmail.com>
+
+    SPDX-License-Identifier: GPL-2.0-or-later
+*/
+#pragma once
+
+#include "activation.h"
+#include "screen.h"
+#include "stacking.h"
+
+#include "base/output_helpers.h"
+#include "main.h"
+
+namespace KWin::win
+{
+
+template<typename Space>
+void set_current_output(Space& space, base::output const& output)
+{
+    if (!kwinApp()->options->focusPolicyIsReasonable()) {
+        return;
+    }
+
+    close_active_popup(space);
+
+    int const desktop = space.virtual_desktop_manager->current();
+    auto get_focus = focus_chain_get_for_activation<Toplevel>(space.focus_chain, desktop, &output);
+
+    if (get_focus == nullptr) {
+        get_focus = find_desktop(&space, true, desktop);
+    }
+
+    if (get_focus != nullptr && get_focus != most_recently_activated_window(space)) {
+        request_focus(space, get_focus);
+    }
+
+    base::set_current_output(kwinApp()->get_base(), &output);
+}
+
+}
diff --git a/win/space.cpp b/win/space.cpp
index 026184338..00ed4d88e 100644
--- a/win/space.cpp
+++ b/win/space.cpp
@@ -21,8 +21,12 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *********************************************************************/
 #include "space.h"
 
+#include "activation.h"
 #include "deco/bridge.h"
+#include "desktop_space.h"
+#include "output_space.h"
 #include "singleton_interface.h"
+#include "space_areas_helpers.h"
 #include "x11/tool_windows.h"
 
 #include "base/dbus/kwin.h"
@@ -186,14 +190,16 @@ space::space(render::compositor& render)
     focus_chain.has_separate_screen_focus = kwinApp()->options->isSeparateScreenFocus();
 
     auto vds = virtual_desktop_manager.get();
-    QObject::connect(vds,
-                     &win::virtual_desktop_manager::countChanged,
-                     qobject.get(),
-                     [this](auto prev, auto next) { slotDesktopCountChanged(prev, next); });
-    QObject::connect(vds,
-                     &win::virtual_desktop_manager::currentChanged,
-                     qobject.get(),
-                     [this](auto prev, auto next) { slotCurrentDesktopChanged(prev, next); });
+    QObject::connect(
+        vds,
+        &win::virtual_desktop_manager::countChanged,
+        qobject.get(),
+        [this](auto prev, auto next) { handle_desktop_count_changed(*this, prev, next); });
+    QObject::connect(
+        vds,
+        &win::virtual_desktop_manager::currentChanged,
+        qobject.get(),
+        [this](auto prev, auto next) { handle_current_desktop_changed(*this, prev, next); });
     vds->setNavigationWrappingAround(kwinApp()->options->isRollOverDesktops());
     QObject::connect(kwinApp()->options.get(),
                      &base::options::rollOverDesktopsChanged,
@@ -289,182 +295,11 @@ space::~space()
     singleton_interface::space = nullptr;
 }
 
-void space::slotCurrentDesktopChanged(uint oldDesktop, uint newDesktop)
-{
-    closeActivePopup();
-    ++block_focus;
-    blocker block(stacking_order);
-    win::update_client_visibility_on_desktop_change(this, newDesktop);
-    // Restore the focus on this desktop
-    --block_focus;
-
-    activateClientOnNewDesktop(newDesktop);
-    Q_EMIT qobject->currentDesktopChanged(oldDesktop, movingClient);
-}
-
-void space::activateClientOnNewDesktop(uint desktop)
-{
-    Toplevel* c = nullptr;
-    if (kwinApp()->options->focusPolicyIsReasonable()) {
-        c = findClientToActivateOnDesktop(desktop);
-    }
-    // If "unreasonable focus policy" and active_client is on_all_desktops and
-    // under mouse (Hence == old_active_client), conserve focus.
-    // (Thanks to Volker Schatz <V.Schatz at thphys.uni-heidelberg.de>)
-    else if (active_client && active_client->isShown() && active_client->isOnCurrentDesktop())
-        c = active_client;
-
-    if (!c) {
-        c = win::find_desktop(this, true, desktop);
-    }
-
-    if (c != active_client) {
-        setActiveClient(nullptr);
-    }
-
-    if (c) {
-        request_focus(c);
-    } else if (auto desktop_client = win::find_desktop(this, true, desktop)) {
-        request_focus(desktop_client);
-    } else {
-        focusToNull();
-    }
-}
-
-Toplevel* space::findClientToActivateOnDesktop(uint desktop)
-{
-    if (movingClient != nullptr && active_client == movingClient
-        && focus_chain_at_desktop_contains(focus_chain, active_client, desktop)
-        && active_client->isShown() && active_client->isOnCurrentDesktop()) {
-        // A requestFocus call will fail, as the client is already active
-        return active_client;
-    }
-    // from actiavtion.cpp
-    if (kwinApp()->options->isNextFocusPrefersMouse()) {
-        auto it = stacking_order->stack.cend();
-        while (it != stacking_order->stack.cbegin()) {
-            auto client = qobject_cast<win::x11::window*>(*(--it));
-            if (!client) {
-                continue;
-            }
-
-            if (!(client->isShown() && client->isOnDesktop(desktop)
-                  && win::on_active_screen(client)))
-                continue;
-
-            if (client->frameGeometry().contains(input::get_cursor()->pos())) {
-                if (!win::is_desktop(client))
-                    return client;
-                break; // unconditional break  - we do not pass the focus to some client below an
-                       // unusable one
-            }
-        }
-    }
-    return focus_chain_get_for_activation_on_current_output<Toplevel>(focus_chain, desktop);
-}
-
-void space::slotDesktopCountChanged(uint previousCount, uint newCount)
-{
-    Q_UNUSED(previousCount)
-    resetClientAreas(newCount);
-}
-
-void space::resetClientAreas(uint desktopCount)
-{
-    // Make it +1, so that it can be accessed as [1..numberofdesktops]
-    areas.work.clear();
-    areas.work.resize(desktopCount + 1);
-    areas.restrictedmove.clear();
-    areas.restrictedmove.resize(desktopCount + 1);
-    areas.screen.clear();
-
-    updateClientArea(true);
-}
-
-/**
- * Sends client \a c to desktop \a desk.
- *
- * Takes care of transients as well.
- */
-void space::sendClientToDesktop(Toplevel* window, int desk, bool dont_activate)
-{
-    if ((desk < 1 && desk != NET::OnAllDesktops)
-        || desk > static_cast<int>(virtual_desktop_manager->count())) {
-        return;
-    }
-    auto old_desktop = window->desktop();
-    auto was_on_desktop = window->isOnDesktop(desk) || window->isOnAllDesktops();
-    win::set_desktop(window, desk);
-    if (window->desktop() != desk) {
-        // No change or desktop forced
-        return;
-    }
-    desk = window->desktop(); // Client did range checking
-
-    if (window->isOnDesktop(virtual_desktop_manager->current())) {
-        if (win::wants_tab_focus(window) && kwinApp()->options->focusPolicyIsReasonable()
-            && !was_on_desktop && // for stickyness changes
-            !dont_activate) {
-            request_focus(window);
-        } else {
-            win::restack_client_under_active(this, window);
-        }
-    } else
-        win::raise_window(this, window);
-
-    win::check_workspace_position(window, QRect(), old_desktop);
-
-    auto transients_stacking_order
-        = win::restacked_by_space_stacking_order(this, window->transient()->children);
-    for (auto const& transient : transients_stacking_order) {
-        if (transient->control) {
-            sendClientToDesktop(transient, desk, dont_activate);
-        }
-    }
-    updateClientArea();
-}
-
-/**
- * Delayed focus functions
- */
-void space::delayFocus()
-{
-    request_focus(delayfocus_client);
-    cancelDelayFocus();
-}
-
-void space::requestDelayFocus(Toplevel* c)
-{
-    delayfocus_client = c;
-    delete delayFocusTimer;
-    delayFocusTimer = new QTimer(qobject.get());
-    QObject::connect(delayFocusTimer, &QTimer::timeout, qobject.get(), [this] { delayFocus(); });
-    delayFocusTimer->setSingleShot(true);
-    delayFocusTimer->start(kwinApp()->options->delayFocusInterval());
-}
-
-void space::cancelDelayFocus()
-{
-    delete delayFocusTimer;
-    delayFocusTimer = nullptr;
-}
-
 bool space::checkStartupNotification(xcb_window_t w, KStartupInfoId& id, KStartupInfoData& data)
 {
     return startup->checkStartup(w, id, data) == KStartupInfo::Match;
 }
 
-/**
- * Puts the focus on a dummy window
- * Just using XSetInputFocus() with None would block keyboard input
- */
-void space::focusToNull()
-{
-    if (m_nullFocus) {
-        m_nullFocus->focus();
-    }
-}
-
 void space::setShowingDesktop(bool showing)
 {
     const bool changed = showing != showing_desktop;
@@ -498,12 +333,12 @@ void space::setShowingDesktop(bool showing)
     } // ~Blocker
 
     if (showing_desktop && topDesk) {
-        request_focus(topDesk);
+        request_focus(*this, topDesk);
     } else if (!showing_desktop && changed) {
         const auto client = focus_chain_get_for_activation_on_current_output<Toplevel>(
             focus_chain, virtual_desktop_manager->current());
         if (client) {
-            activateClient(client);
+            activate_window(*this, client);
         }
     }
     if (changed) {
@@ -645,7 +480,7 @@ void space::desktopResized()
         win::x11::rootInfo()->setDesktopGeometry(desktop_geometry);
     }
 
-    updateClientArea();
+    update_space_areas(*this);
     saveOldScreenSizes(); // after updateClientArea(), so that one still uses the previous one
 
     // TODO: emit a signal instead and remove the deep function calls into edges and effects
@@ -669,89 +504,6 @@ void space::saveOldScreenSizes()
     }
 }
 
-/**
- * Updates the current client areas according to the current clients.
- *
- * If the area changes or force is @c true, the new areas are propagated to the world.
- *
- * The client area is the area that is available for clients (that
- * which is not taken by windows like panels, the top-of-screen menu
- * etc).
- *
- * @see clientArea()
- */
-void space::updateClientArea(bool force)
-{
-    auto&& base = kwinApp()->get_base();
-    auto const& outputs = base.get_outputs();
-    auto const screens_count = outputs.size();
-    auto const desktops_count = static_cast<int>(virtual_desktop_manager->count());
-
-    // To be determined are new:
-    // * work areas,
-    // * restricted-move areas,
-    // * screen areas.
-    win::space_areas new_areas(desktops_count + 1);
-
-    std::vector<QRect> screens_geos(screens_count);
-    QRect desktop_area;
-
-    for (size_t screen = 0; screen < screens_count; screen++) {
-        desktop_area |= outputs.at(screen)->geometry();
-    }
-
-    for (size_t screen = 0; screen < screens_count; screen++) {
-        screens_geos[screen] = outputs.at(screen)->geometry();
-    }
-
-    for (auto desktop = 1; desktop <= desktops_count; ++desktop) {
-        new_areas.work[desktop] = desktop_area;
-        new_areas.screen[desktop].resize(screens_count);
-        for (size_t screen = 0; screen < screens_count; screen++) {
-            new_areas.screen[desktop][screen] = screens_geos[screen];
-        }
-    }
-
-    update_space_area_from_windows(desktop_area, screens_geos, new_areas);
-
-    auto changed = force || areas.screen.empty();
-
-    for (int desktop = 1; !changed && desktop <= desktops_count; ++desktop) {
-        changed |= areas.work[desktop] != new_areas.work[desktop];
-        changed |= areas.restrictedmove[desktop] != new_areas.restrictedmove[desktop];
-        changed |= areas.screen[desktop].size() != new_areas.screen[desktop].size();
-
-        for (size_t screen = 0; !changed && screen < screens_count; screen++) {
-            changed |= new_areas.screen[desktop][screen] != areas.screen[desktop][screen];
-        }
-    }
-
-    if (changed) {
-        oldrestrictedmovearea = areas.restrictedmove;
-        areas = new_areas;
-
-        if (win::x11::rootInfo()) {
-            NETRect rect;
-            for (int desktop = 1; desktop <= desktops_count; desktop++) {
-                rect.pos.x = areas.work[desktop].x();
-                rect.pos.y = areas.work[desktop].y();
-                rect.size.width = areas.work[desktop].width();
-                rect.size.height = areas.work[desktop].height();
-                win::x11::rootInfo()->setWorkArea(desktop, rect);
-            }
-        }
-
-        for (auto win : m_windows) {
-            if (win->control) {
-                check_workspace_position(win);
-            }
-        }
-
-        // Reset, no longer valid or needed.
-        oldrestrictedmovearea.clear();
-    }
-}
-
 void space::update_space_area_from_windows(QRect const& /*desktop_area*/,
                                            std::vector<QRect> const& /*screens_geos*/,
                                            win::space_areas& /*areas*/)
@@ -759,11 +511,6 @@ void space::update_space_area_from_windows(QRect const& /*desktop_area*/,
     // Can't be pure virtual because the function might be called from the ctor.
 }
 
-void space::updateClientArea()
-{
-    updateClientArea(false);
-}
-
 /**
  * Returns the area available for clients. This is the desktop
  * geometry minus windows on the dock. Placement algorithms should
@@ -1670,351 +1417,6 @@ int space::packPositionDown(Toplevel const* window, int oldY, bool bottomEdge) c
 
 #endif
 
-/*
- Prevention of focus stealing:
-
- KWin tries to prevent unwanted changes of focus, that would result
- from mapping a new window. Also, some nasty applications may try
- to force focus change even in cases when ICCCM 4.2.7 doesn't allow it
- (e.g. they may try to activate their main window because the user
- definitely "needs" to see something happened - misusing
- of QWidget::setActiveWindow() may be such case).
-
- There are 4 ways how a window may become active:
- - the user changes the active window (e.g. focus follows mouse, clicking
-   on some window's titlebar) - the change of focus will
-   be done by KWin, so there's nothing to solve in this case
- - the change of active window will be requested using the _NET_ACTIVE_WINDOW
-   message (handled in RootInfo::changeActiveWindow()) - such requests
-   will be obeyed, because this request is meant mainly for e.g. taskbar
-   asking the WM to change the active window as a result of some user action.
-   Normal applications should use this request only rarely in special cases.
-   See also below the discussion of _NET_ACTIVE_WINDOW_TRANSFER.
- - the change of active window will be done by performing XSetInputFocus()
-   on a window that's not currently active. ICCCM 4.2.7 describes when
-   the application may perform change of input focus. In order to handle
-   misbehaving applications, KWin will try to detect focus changes to
-   windows that don't belong to currently active application, and restore
-   focus back to the currently active window, instead of activating the window
-   that got focus (unfortunately there's no way to FocusChangeRedirect similar
-   to e.g. SubstructureRedirect, so there will be short time when the focus
-   will be changed). The check itself that's done is
-   space::allowClientActivation() (see below).
- - a new window will be mapped - this is the most complicated case. If
-   the new window belongs to the currently active application, it may be safely
-   mapped on top and activated. The same if there's no active window,
-   or the active window is the desktop. These checks are done by
-   space::allowClientActivation().
-    Following checks need to compare times. One time is the timestamp
-   of last user action in the currently active window, the other time is
-   the timestamp of the action that originally caused mapping of the new window
-   (e.g. when the application was started). If the first time is newer than
-   the second one, the window will not be activated, as that indicates
-   futher user actions took place after the action leading to this new
-   mapped window. This check is done by space::allowClientActivation().
-    There are several ways how to get the timestamp of action that caused
-   the new mapped window (done in win::x11::window::readUserTimeMapTimestamp()) :
-     - the window may have the _NET_WM_USER_TIME property. This way
-       the application may either explicitly request that the window is not
-       activated (by using 0 timestamp), or the property contains the time
-       of last user action in the application.
-     - KWin itself tries to detect time of last user action in every window,
-       by watching KeyPress and ButtonPress events on windows. This way some
-       events may be missed (if they don't propagate to the toplevel window),
-       but it's good as a fallback for applications that don't provide
-       _NET_WM_USER_TIME, and missing some events may at most lead
-       to unwanted focus stealing.
-     - the timestamp may come from application startup notification.
-       Application startup notification, if it exists for the new mapped window,
-       should include time of the user action that caused it.
-     - if there's no timestamp available, it's checked whether the new window
-       belongs to some already running application - if yes, the timestamp
-       will be 0 (i.e. refuse activation)
-     - if the window is from session restored window, the timestamp will
-       be 0 too, unless this application was the active one at the time
-       when the session was saved, in which case the window will be
-       activated if there wasn't any user interaction since the time
-       KWin was started.
-     - as the last resort, the _KDE_NET_USER_CREATION_TIME timestamp
-       is used. For every toplevel window that is created (see CreateNotify
-       handling), this property is set to the at that time current time.
-       Since at this time it's known that the new window doesn't belong
-       to any existing application (better said, the application doesn't
-       have any other window mapped), it is either the very first window
-       of the application, or it is the only window of the application
-       that was hidden before. The latter case is handled by removing
-       the property from windows before withdrawing them, making
-       the timestamp empty for next mapping of the window. In the sooner
-       case, the timestamp will be used. This helps in case when
-       an application is launched without application startup notification,
-       it creates its mainwindow, and starts its initialization (that
-       may possibly take long time). The timestamp used will be older
-       than any user action done after launching this application.
-     - if no timestamp is found at all, the window is activated.
-    The check whether two windows belong to the same application (same
-   process) is done in win::x11::window::belongToSameApplication(). Not 100% reliable,
-   but hopefully 99,99% reliable.
-
- As a somewhat special case, window activation is always enabled when
- session saving is in progress. When session saving, the session
- manager allows only one application to interact with the user.
- Not allowing window activation in such case would result in e.g. dialogs
- not becoming active, so focus stealing prevention would cause here
- more harm than good.
-
- Windows that attempted to become active but KWin prevented this will
- be marked as demanding user attention. They'll get
- the _NET_WM_STATE_DEMANDS_ATTENTION state, and the taskbar should mark
- them specially (blink, etc.). The state will be reset when the window
- eventually really becomes active.
-
- There are two more ways how a window can become obtrusive, window stealing
- focus: By showing above the active window, by either raising itself,
- or by moving itself on the active desktop.
-     - KWin will refuse raising non-active window above the active one,
-         unless they belong to the same application. Applications shouldn't
-         raise their windows anyway (unless the app wants to raise one
-         of its windows above another of its windows).
-     - KWin activates windows moved to the current desktop (as that seems
-         logical from the user's point of view, after sending the window
-         there directly from KWin, or e.g. using pager). This means
-         applications shouldn't send their windows to another desktop
-         (SELI TODO - but what if they do?)
-
- Special cases I can think of:
-    - konqueror reusing, i.e. kfmclient tells running Konqueror instance
-        to open new window
-        - without focus stealing prevention - no problem
-        - with ASN (application startup notification) - ASN is forwarded,
-            and because it's newer than the instance's user timestamp,
-            it takes precedence
-        - without ASN - user timestamp needs to be reset, otherwise it would
-            be used, and it's old; moreover this new window mustn't be detected
-            as window belonging to already running application, or it wouldn't
-            be activated - see win::x11::window::sameAppWindowRoleMatch() for the (rather ugly)
-            hack
-    - konqueror preloading, i.e. window is created in advance, and kfmclient
-        tells this Konqueror instance to show it later
-        - without focus stealing prevention - no problem
-        - with ASN - ASN is forwarded, and because it's newer than the instance's
-            user timestamp, it takes precedence
-        - without ASN - user timestamp needs to be reset, otherwise it would
-            be used, and it's old; also, creation timestamp is changed to
-            the time the instance starts (re-)initializing the window,
-            this ensures creation timestamp will still work somewhat even in this case
-    - KUniqueApplication - when the window is already visible, and the new instance
-        wants it to activate
-        - without focus stealing prevention - _NET_ACTIVE_WINDOW - no problem
-        - with ASN - ASN is forwarded, and set on the already visible window, KWin
-            treats the window as new with that ASN
-        - without ASN - _NET_ACTIVE_WINDOW as application request is used,
-                and there's no really usable timestamp, only timestamp
-                from the time the (new) application instance was started,
-                so KWin will activate the window *sigh*
-                - the bad thing here is that there's absolutely no chance to recognize
-                    the case of starting this KUniqueApp from Konsole (and thus wanting
-                    the already visible window to become active) from the case
-                    when something started this KUniqueApp without ASN (in which case
-                    the already visible window shouldn't become active)
-                - the only solution is using ASN for starting applications, at least silent
-                    (i.e. without feedback)
-    - when one application wants to activate another application's window (e.g. KMail
-        activating already running KAddressBook window ?)
-        - without focus stealing prevention - _NET_ACTIVE_WINDOW - no problem
-        - with ASN - can't be here, it's the KUniqueApp case then
-        - without ASN - _NET_ACTIVE_WINDOW as application request should be used,
-            KWin will activate the new window depending on the timestamp and
-            whether it belongs to the currently active application
-
- _NET_ACTIVE_WINDOW usage:
- data.l[0]= 1 ->app request
-          = 2 ->pager request
-          = 0 - backwards compatibility
- data.l[1]= timestamp
-*/
-
-/**
- * Informs the space:: about the active client, i.e. the client that
- * has the focus (or None if no client has the focus). This functions
- * is called by the client itself that gets focus. It has no other
- * effect than fixing the focus chain and the return value of
- * activeClient(). And of course, to propagate the active client to the
- * world.
- */
-void space::setActiveClient(Toplevel* window)
-{
-    if (active_client == window)
-        return;
-
-    if (active_popup && active_popup_client != window && set_active_client_recursion == 0)
-        closeActivePopup();
-    if (user_actions_menu->hasClient() && !user_actions_menu->isMenuClient(window)
-        && set_active_client_recursion == 0) {
-        user_actions_menu->close();
-    }
-
-    blocker block(stacking_order);
-    ++set_active_client_recursion;
-    focusMousePos = input::get_cursor()->pos();
-
-    if (active_client != nullptr) {
-        // note that this may call setActiveClient( NULL ), therefore the recursion counter
-        win::set_active(active_client, false);
-    }
-
-    active_client = window;
-    Q_ASSERT(window == nullptr || window->control->active());
-
-    if (active_client) {
-        last_active_client = active_client;
-        focus_chain_update(focus_chain, active_client, focus_chain_change::make_first);
-        win::set_demands_attention(active_client, false);
-
-        // activating a client can cause a non active fullscreen window to loose the ActiveLayer
-        // status on > 1 screens
-        if (kwinApp()->get_base().get_outputs().size() > 1) {
-            for (auto win : m_windows) {
-                if (win->control && win != active_client && win->layer() == win::layer::active
-                    && win->central_output == active_client->central_output) {
-                    update_layer(win);
-                }
-            }
-        }
-    }
-
-    x11::update_tool_windows_visibility(this, false);
-    if (window)
-        disableGlobalShortcutsForClient(
-            window->control->rules().checkDisableGlobalShortcuts(false));
-    else
-        disableGlobalShortcutsForClient(false);
-
-    // e.g. fullscreens have different layer when active/not-active
-    stacking_order->update_order();
-
-    if (win::x11::rootInfo()) {
-        win::x11::rootInfo()->setActiveClient(active_client);
-    }
-
-    Q_EMIT qobject->clientActivated(active_client);
-    --set_active_client_recursion;
-}
-
-/**
- * Tries to activate the client \a c. This function performs what you
- * expect when clicking the respective entry in a taskbar: showing and
- * raising the client (this may imply switching to the another virtual
- * desktop) and putting the focus onto it. Once X really gave focus to
- * the client window as requested, the client itself will call
- * setActiveClient() and the operation is complete. This may not happen
- * with certain focus policies, though.
- *
- * @see setActiveClient
- * @see requestFocus
- */
-void space::activateClient(Toplevel* window, bool force)
-{
-    if (window == nullptr) {
-        focusToNull();
-        setActiveClient(nullptr);
-        return;
-    }
-    win::raise_window(this, window);
-    if (!window->isOnCurrentDesktop()) {
-        ++block_focus;
-        virtual_desktop_manager->setCurrent(window->desktop());
-        --block_focus;
-    }
-    if (window->control->minimized()) {
-        win::set_minimized(window, false);
-    }
-
-    // ensure the window is really visible - could eg. be a hidden utility window, see bug #348083
-    window->hideClient(false);
-
-    // TODO force should perhaps allow this only if the window already contains the mouse
-    if (kwinApp()->options->focusPolicyIsReasonable() || force) {
-        request_focus(window, false, force);
-    }
-
-    // Don't update user time for clients that have focus stealing workaround.
-    // As they usually belong to the current active window but fail to provide
-    // this information, updating their user time would make the user time
-    // of the currently active window old, and reject further activation for it.
-    // E.g. typing URL in minicli which will show kio_uiserver dialog (with workaround),
-    // and then kdesktop shows dialog about SSL certificate.
-    // This needs also avoiding user creation time in win::x11::window::readUserTimeMapTimestamp().
-    if (auto client = dynamic_cast<win::x11::window*>(window)) {
-        // updateUserTime is X11 specific
-        win::x11::update_user_time(client);
-    }
-}
-
-/**
- * Tries to activate the client by asking X for the input focus. This
- * function does not perform any show, raise or desktop switching. See
- * space::activateClient() instead.
- *
- * @see activateClient
- */
-void space::request_focus(Toplevel* window, bool raise, bool force_focus)
-{
-    auto take_focus = focusChangeEnabled() || window == active_client;
-
-    if (!window) {
-        focusToNull();
-        return;
-    }
-
-    if (take_focus) {
-        auto modal = window->findModal();
-        if (modal && modal->control && modal != window) {
-            if (!modal->isOnDesktop(window->desktop())) {
-                win::set_desktop(modal, window->desktop());
-            }
-            if (!modal->isShown() && !modal->control->minimized()) {
-                // forced desktop or utility window
-                // activating a minimized blocked window will unminimize its modal implicitly
-                activateClient(modal);
-            }
-            // if the click was inside the window (i.e. handled is set),
-            // but it has a modal, there's no need to use handled mode, because
-            // the modal doesn't get the click anyway
-            // raising of the original window needs to be still done
-            if (raise) {
-                win::raise_window(this, window);
-            }
-            window = modal;
-        }
-        cancelDelayFocus();
-    }
-
-    if (!force_focus && (win::is_dock(window) || win::is_splash(window))) {
-        // toplevel menus and dock windows don't take focus if not forced
-        // and don't have a flag that they take focus
-        if (!window->dockWantsInput()) {
-            take_focus = false;
-        }
-    }
-
-    if (!window->isShown()) {
-        // Shouldn't happen, call activateClient() if needed.
-        qCWarning(KWIN_CORE) << "request_focus: not shown";
-        return;
-    }
-
-    if (take_focus) {
-        window->takeFocus();
-    }
-    if (raise) {
-        win::raise_window(this, window);
-    }
-
-    if (!win::on_active_screen(window)) {
-        base::set_current_output(kwinApp()->get_base(), window->central_output);
-    }
-}
-
 /**
  * Informs the space:: that the client \a c has been hidden. If it
  * was the active client (or to-become the active client),
@@ -2025,7 +1427,7 @@ void space::request_focus(Toplevel* window, bool raise, bool force_focus)
 void space::clientHidden(Toplevel* window)
 {
     Q_ASSERT(!window->isShown() || !window->isOnCurrentDesktop());
-    activateNextClient(window);
+    activate_next_window(*this, window);
 }
 
 Toplevel* space::clientUnderMouse(base::output const* output) const
@@ -2050,103 +1452,6 @@ Toplevel* space::clientUnderMouse(base::output const* output) const
     return nullptr;
 }
 
-// deactivates 'c' and activates next client
-bool space::activateNextClient(Toplevel* window)
-{
-    // if 'c' is not the active or the to-become active one, do nothing
-    if (!(window == active_client
-          || (should_get_focus.size() > 0 && window == should_get_focus.back()))) {
-        return false;
-    }
-
-    closeActivePopup();
-
-    if (window != nullptr) {
-        if (window == active_client) {
-            setActiveClient(nullptr);
-        }
-        should_get_focus.erase(
-            std::remove(should_get_focus.begin(), should_get_focus.end(), window),
-            should_get_focus.end());
-    }
-
-    // if blocking focus, move focus to the desktop later if needed
-    // in order to avoid flickering
-    if (!focusChangeEnabled()) {
-        focusToNull();
-        return true;
-    }
-
-    if (!kwinApp()->options->focusPolicyIsReasonable())
-        return false;
-
-    Toplevel* get_focus = nullptr;
-
-    const int desktop = virtual_desktop_manager->current();
-
-    if (!get_focus && showingDesktop())
-        get_focus = win::find_desktop(this, true, desktop); // to not break the state
-
-    if (!get_focus && kwinApp()->options->isNextFocusPrefersMouse()) {
-        get_focus = clientUnderMouse(window ? window->central_output : get_current_output(*this));
-        if (get_focus && (get_focus == window || win::is_desktop(get_focus))) {
-            // should rather not happen, but it cannot get the focus. rest of usability is tested
-            // above
-            get_focus = nullptr;
-        }
-    }
-
-    if (!get_focus) { // no suitable window under the mouse -> find sth. else
-        // first try to pass the focus to the (former) active clients leader
-        if (window && window->transient()->lead()) {
-            auto leaders = window->transient()->leads();
-            if (leaders.size() == 1
-                && focus_chain_is_usable_focus_candidate(focus_chain, leaders.at(0), window)) {
-                get_focus = leaders.at(0);
-
-                // also raise - we don't know where it came from
-                win::raise_window(this, get_focus);
-            }
-        }
-        if (!get_focus) {
-            // nope, ask the focus chain for the next candidate
-            get_focus = focus_chain_next_for_desktop(focus_chain, window, desktop);
-        }
-    }
-
-    if (get_focus == nullptr) // last chance: focus the desktop
-        get_focus = win::find_desktop(this, true, desktop);
-
-    if (get_focus != nullptr) {
-        request_focus(get_focus);
-    } else {
-        focusToNull();
-    }
-
-    return true;
-}
-
-void space::setCurrentScreen(base::output const& output)
-{
-    if (!kwinApp()->options->focusPolicyIsReasonable()) {
-        return;
-    }
-
-    closeActivePopup();
-
-    const int desktop = virtual_desktop_manager->current();
-    auto get_focus = focus_chain_get_for_activation<Toplevel>(focus_chain, desktop, &output);
-    if (get_focus == nullptr) {
-        get_focus = win::find_desktop(this, true, desktop);
-    }
-
-    if (get_focus != nullptr && get_focus != mostRecentlyActivatedClient()) {
-        request_focus(get_focus);
-    }
-
-    base::set_current_output(kwinApp()->get_base(), &output);
-}
-
 void space::gotFocusIn(Toplevel const* window)
 {
     if (std::find(should_get_focus.cbegin(), should_get_focus.cend(), const_cast<Toplevel*>(window))
@@ -2198,7 +1503,7 @@ bool space::allowClientActivation(Toplevel const* window,
     if (session_manager->state() == SessionState::Saving && level <= FSP::Medium) { // <= normal
         return true;
     }
-    auto ac = mostRecentlyActivatedClient();
+    auto ac = most_recently_activated_window(*this);
     if (focus_in) {
         if (std::find(
                 should_get_focus.cbegin(), should_get_focus.cend(), const_cast<Toplevel*>(window))
@@ -2285,7 +1590,7 @@ bool space::allowFullClientRaising(Toplevel const* window, xcb_timestamp_t time)
     if (session_manager->state() == SessionState::Saving && level <= 2) { // <= normal
         return true;
     }
-    auto ac = mostRecentlyActivatedClient();
+    auto ac = most_recently_activated_window(*this);
     if (level == 0) // none
         return true;
     if (level == 4) // extreme
@@ -2317,9 +1622,9 @@ void space::restoreFocus()
     // the attempt to restore the focus would fail due to old timestamp
     kwinApp()->update_x11_time_from_clock();
     if (should_get_focus.size() > 0) {
-        request_focus(should_get_focus.back());
+        request_focus(*this, should_get_focus.back());
     } else if (last_active_client) {
-        request_focus(last_active_client);
+        request_focus(*this, last_active_client);
     }
 }
 
@@ -2377,16 +1682,6 @@ void space::slotLowerWindowOpacity()
     active_client->setOpacity(qMax(active_client->opacity() - 0.05, 0.05));
 }
 
-void space::closeActivePopup()
-{
-    if (active_popup) {
-        active_popup->close();
-        active_popup = nullptr;
-        active_popup_client = nullptr;
-    }
-    user_actions_menu->close();
-}
-
 QAction* prepare_shortcut_action(win::space& space,
                                  QString const& actionName,
                                  QString const& description,
@@ -2691,7 +1986,7 @@ void space::setupWindowShortcutDone(bool ok)
     //    client_keys->setEnabled( true );
     if (ok)
         win::set_shortcut(client_keys_client, client_keys_dialog->shortcut().toString());
-    closeActivePopup();
+    close_active_popup(*this);
     client_keys_dialog->deleteLater();
     client_keys_dialog = nullptr;
     client_keys_client = nullptr;
@@ -2710,10 +2005,9 @@ void space::clientShortcutUpdated(Toplevel* window)
             action->setProperty("componentName", QStringLiteral(KWIN_NAME));
             action->setObjectName(key);
             action->setText(i18n("Activate Window (%1)", win::caption(window)));
-            QObject::connect(action,
-                             &QAction::triggered,
-                             window,
-                             std::bind(&space::activateClient, this, window, true));
+            QObject::connect(action, &QAction::triggered, window, [this, window] {
+                force_activate_window(*this, window);
+            });
         }
 
         // no autoloading, since it's configured explicitly here and is not meant to be reused
@@ -2825,7 +2119,7 @@ void space::performWindowOperation(Toplevel* window, base::options::WindowOperat
 void space::slotActivateAttentionWindow()
 {
     if (attention_chain.size() > 0) {
-        activateClient(attention_chain.front());
+        activate_window(*this, attention_chain.front());
     }
 }
 
@@ -2850,7 +2144,7 @@ void space::slotWindowToDesktop(uint i)
             return;
 
         if (i >= 1 && i <= virtual_desktop_manager->count())
-            sendClientToDesktop(active_client, i, true);
+            send_window_to_desktop(*this, active_client, i, true);
     }
 }
 
@@ -2880,7 +2174,7 @@ void space::slotSwitchToScreen(QAction* action)
     auto output = base::get_output(kwinApp()->get_base().get_outputs(), screen);
 
     if (output) {
-        setCurrentScreen(*output);
+        set_current_output(*this, *output);
     }
 }
 
@@ -2903,7 +2197,7 @@ void space::slotSwitchToNextScreen()
         return;
     }
     if (auto output = get_derivated_output(*this, 1)) {
-        setCurrentScreen(*output);
+        set_current_output(*this, *output);
     }
 }
 
@@ -2913,7 +2207,7 @@ void space::slotSwitchToPrevScreen()
         return;
     }
     if (auto output = get_derivated_output(*this, -1)) {
-        setCurrentScreen(*output);
+        set_current_output(*this, *output);
     }
 }
 
@@ -3008,10 +2302,11 @@ void space::slotWindowLower()
             if (kwinApp()->options->isNextFocusPrefersMouse()) {
                 auto next = clientUnderMouse(active_client->central_output);
                 if (next && next != active_client)
-                    request_focus(next);
+                    request_focus(*this, next);
             } else {
-                activateClient(
-                    win::top_client_on_desktop(this, virtual_desktop_manager->current(), nullptr));
+                activate_window(
+                    *this,
+                    top_client_on_desktop(this, virtual_desktop_manager->current(), nullptr));
             }
         }
     }
@@ -3251,7 +2546,7 @@ bool space::switchWindow(Toplevel* c, Direction direction, QPoint curPos, int d)
         }
     }
     if (switchTo) {
-        activateClient(switchTo);
+        activate_window(*this, switchTo);
     }
 
     return switchTo;
diff --git a/win/space.h b/win/space.h
index c4c80d95a..3b1e14605 100644
--- a/win/space.h
+++ b/win/space.h
@@ -171,6 +171,8 @@ public:
     std::vector<Toplevel*> m_windows;
     std::vector<win::x11::group*> groups;
 
+    win::space_areas areas;
+
     std::unique_ptr<scripting::platform> scripting;
     std::unique_ptr<render::outline> outline;
     std::unique_ptr<win::screen_edger> edges;
@@ -215,6 +217,11 @@ public:
     QTimer reconfigureTimer;
     QTimer updateToolWindowsTimer;
 
+    Toplevel* movingClient{nullptr};
+
+    // Array of the previous restricted areas that window cannot be moved into
+    std::vector<win::strut_rects> oldrestrictedmovearea;
+
     explicit space(render::compositor& render);
     virtual ~space();
 
@@ -239,25 +246,8 @@ public:
     void initShortcuts();
     bool initializing() const;
 
-    /**
-     * Client that was activated, but it's not yet really activeClient(), because
-     * we didn't process yet the matching FocusIn event. Used mostly in focus
-     * stealing prevention code.
-     */
-    Toplevel* mostRecentlyActivatedClient() const;
-
     Toplevel* clientUnderMouse(base::output const* output) const;
 
-    void activateClient(Toplevel* window, bool force = false);
-
-    /**
-     * Request focus and optionally try raising the window.
-     * @param window The window to focus.
-     * @param raise Should additionally raise the window.
-     * @param force_focus Focus even if panel, dock and so on.
-     */
-    void request_focus(Toplevel* window, bool raise = false, bool force_focus = false);
-
     bool allowClientActivation(Toplevel const* window,
                                xcb_timestamp_t time = -1U,
                                bool focus_in = false,
@@ -265,11 +255,6 @@ public:
     void restoreFocus();
     void gotFocusIn(Toplevel const* window);
     void setShouldGetFocus(Toplevel* window);
-    bool activateNextClient(Toplevel* window);
-    bool focusChangeEnabled()
-    {
-        return block_focus == 0;
-    }
 
     /**
      * Indicates that the client c is being moved or resized by the user.
@@ -331,7 +316,6 @@ public:
 
     Toplevel* active_client{nullptr};
 
-    void sendClientToDesktop(Toplevel* window, int desktop, bool dont_activate);
     void windowToPreviousDesktop(Toplevel& window);
     void windowToNextDesktop(Toplevel& window);
 
@@ -354,17 +338,11 @@ public:
 
     win::session_info* takeSessionInfo(win::x11::window*);
 
-    void setCurrentScreen(base::output const& output);
-
     void setShowingDesktop(bool showing);
     bool showingDesktop() const;
 
-    void setActiveClient(Toplevel* window);
-
     bool checkStartupNotification(xcb_window_t w, KStartupInfoId& id, KStartupInfoData& data);
 
-    void focusToNull(); // SELI TODO: Public?
-
     void clientShortcutUpdated(Toplevel* window);
     bool shortcutAvailable(const QKeySequence& cut, Toplevel* ignore = nullptr) const;
     bool globalShortcutsDisabled() const;
@@ -378,9 +356,6 @@ public:
     int packPositionUp(Toplevel const* window, int oldY, bool topEdge) const;
     int packPositionDown(Toplevel const* window, int oldY, bool bottomEdge) const;
 
-    void cancelDelayFocus();
-    void requestDelayFocus(Toplevel*);
-
     /**
      * Returns a client that is currently being moved or resized by the user.
      *
@@ -412,7 +387,6 @@ public:
     void fixPositionAfterCrash(xcb_window_t w, const xcb_get_geometry_reply_t* geom);
     void saveOldScreenSizes();
     void desktopResized();
-    void closeActivePopup();
 
     void performWindowOperation(KWin::Toplevel* window, base::options::WindowOperation op);
 
@@ -471,20 +445,10 @@ public:
     void slotSetupWindowShortcut();
     void setupWindowShortcutDone(bool);
 
-    void updateClientArea();
-
-protected:
     virtual void update_space_area_from_windows(QRect const& desktop_area,
                                                 std::vector<QRect> const& screens_geos,
                                                 win::space_areas& areas);
 
-private:
-    void delayFocus();
-
-    // virtual desktop handling
-    void slotDesktopCountChanged(uint previousCount, uint newCount);
-    void slotCurrentDesktopChanged(uint oldDesktop, uint newDesktop);
-
     template<typename Slot>
     void initShortcut(const QString& actionName,
                       const QString& description,
@@ -508,11 +472,6 @@ private:
     void setupWindowShortcut(Toplevel* window);
     bool switchWindow(Toplevel* c, Direction direction, QPoint curPos, int desktop);
 
-    void updateClientArea(bool force);
-    void resetClientAreas(uint desktopCount);
-    void activateClientOnNewDesktop(uint desktop);
-    Toplevel* findClientToActivateOnDesktop(uint desktop);
-
     QWidget* active_popup{nullptr};
 
     void loadSessionInfo(const QString& sessionName);
@@ -520,8 +479,6 @@ private:
 
     std::vector<win::session_info*> session;
 
-    Toplevel* movingClient{nullptr};
-
     // Delay(ed) window focus timer and client
     QTimer* delayFocusTimer{nullptr};
 
@@ -536,11 +493,6 @@ private:
     win::shortcut_dialog* client_keys_dialog{nullptr};
     bool global_shortcuts_disabled_for_client{false};
 
-    win::space_areas areas;
-
-    // Array of the previous restricted areas that window cannot be moved into
-    std::vector<win::strut_rects> oldrestrictedmovearea;
-
     // array of previous sizes of xinerama screens
     std::vector<QRect> oldscreensizes;
 
@@ -555,11 +507,6 @@ private:
     friend bool performTransiencyCheck();
 };
 
-inline Toplevel* space::mostRecentlyActivatedClient() const
-{
-    return should_get_focus.size() > 0 ? should_get_focus.back() : active_client;
-}
-
 inline bool space::wasUserInteraction() const
 {
     return was_user_interaction;
diff --git a/win/space_areas_helpers.h b/win/space_areas_helpers.h
new file mode 100644
index 000000000..b35fb39a1
--- /dev/null
+++ b/win/space_areas_helpers.h
@@ -0,0 +1,123 @@
+/*
+    SPDX-FileCopyrightText: 2021 Roman Gilg <subdiff@gmail.com>
+
+    SPDX-License-Identifier: GPL-2.0-or-later
+*/
+#pragma once
+
+#include "move.h"
+#include "space_areas.h"
+#include "x11/netinfo.h"
+
+#include "base/platform.h"
+#include "main.h"
+
+namespace KWin::win
+{
+
+/**
+ * Updates the current client areas according to the current clients.
+ *
+ * If the area changes or force is @c true, the new areas are propagated to the world.
+ *
+ * The client area is the area that is available for clients (that
+ * which is not taken by windows like panels, the top-of-screen menu
+ * etc).
+ *
+ * @see clientArea()
+ */
+template<typename Space>
+void update_space_areas_impl(Space& space, bool force)
+{
+    auto&& base = kwinApp()->get_base();
+    auto const& outputs = base.get_outputs();
+    auto const screens_count = outputs.size();
+    auto const desktops_count = static_cast<int>(space.virtual_desktop_manager->count());
+
+    // To be determined are new:
+    // * work areas,
+    // * restricted-move areas,
+    // * screen areas.
+    win::space_areas new_areas(desktops_count + 1);
+
+    std::vector<QRect> screens_geos(screens_count);
+    QRect desktop_area;
+
+    for (size_t screen = 0; screen < screens_count; screen++) {
+        desktop_area |= outputs.at(screen)->geometry();
+    }
+
+    for (size_t screen = 0; screen < screens_count; screen++) {
+        screens_geos[screen] = outputs.at(screen)->geometry();
+    }
+
+    for (auto desktop = 1; desktop <= desktops_count; ++desktop) {
+        new_areas.work[desktop] = desktop_area;
+        new_areas.screen[desktop].resize(screens_count);
+        for (size_t screen = 0; screen < screens_count; screen++) {
+            new_areas.screen[desktop][screen] = screens_geos[screen];
+        }
+    }
+
+    space.update_space_area_from_windows(desktop_area, screens_geos, new_areas);
+
+    auto changed = force || space.areas.screen.empty();
+
+    for (int desktop = 1; !changed && desktop <= desktops_count; ++desktop) {
+        changed |= space.areas.work[desktop] != new_areas.work[desktop];
+        changed |= space.areas.restrictedmove[desktop] != new_areas.restrictedmove[desktop];
+        changed |= space.areas.screen[desktop].size() != new_areas.screen[desktop].size();
+
+        for (size_t screen = 0; !changed && screen < screens_count; screen++) {
+            changed |= new_areas.screen[desktop][screen] != space.areas.screen[desktop][screen];
+        }
+    }
+
+    if (changed) {
+        space.oldrestrictedmovearea = space.areas.restrictedmove;
+        space.areas = new_areas;
+
+        if (win::x11::rootInfo()) {
+            NETRect rect;
+            for (int desktop = 1; desktop <= desktops_count; desktop++) {
+                rect.pos.x = space.areas.work[desktop].x();
+                rect.pos.y = space.areas.work[desktop].y();
+                rect.size.width = space.areas.work[desktop].width();
+                rect.size.height = space.areas.work[desktop].height();
+                x11::rootInfo()->setWorkArea(desktop, rect);
+            }
+        }
+
+        for (auto win : space.m_windows) {
+            if (win->control) {
+                check_workspace_position(win);
+            }
+        }
+
+        // Reset, no longer valid or needed.
+        space.oldrestrictedmovearea.clear();
+    }
+}
+
+template<typename Space>
+void update_space_areas(Space& space)
+{
+    update_space_areas_impl(space, false);
+}
+
+template<typename Space>
+void reset_space_areas(Space& space, uint desktop_count)
+{
+    auto& areas = space.areas;
+
+    // Make it +1, so that it can be accessed as [1..numberofdesktops]
+    areas.work.clear();
+    areas.work.resize(desktop_count + 1);
+    areas.restrictedmove.clear();
+    areas.restrictedmove.resize(desktop_count + 1);
+    areas.screen.clear();
+
+    update_space_areas_impl(space, true);
+}
+
+}
diff --git a/win/stacking.h b/win/stacking.h
index e1b330ea2..e5f9e0afe 100644
--- a/win/stacking.h
+++ b/win/stacking.h
@@ -13,6 +13,8 @@
 #include "stacking_order.h"
 #include "util.h"
 #include "x11/group.h"
+#include "x11/netinfo.h"
+#include "x11/tool_windows.h"
 
 // Required for casts between Toplevel and window in some template functions.
 // TODO(romangg): Remove these casts and this include to make the functions truly generic.
diff --git a/win/stacking_order.h b/win/stacking_order.h
index 5806b6db1..fd7d36cae 100644
--- a/win/stacking_order.h
+++ b/win/stacking_order.h
@@ -8,6 +8,7 @@
 #pragma once
 
 #include "kwin_export.h"
+#include "net.h"
 
 #include <qobject.h>
 #include <qobjectdefs.h>
diff --git a/win/tabbox/tabbox.cpp b/win/tabbox/tabbox.cpp
index 49ce3162d..9ab2e7c4e 100644
--- a/win/tabbox/tabbox.cpp
+++ b/win/tabbox/tabbox.cpp
@@ -36,18 +36,18 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "input/redirect.h"
 #include "input/xkb/helpers.h"
 #include "render/effects.h"
-#include "win/screen.h"
-#include "win/screen_edges.h"
-#include "win/space.h"
-#include "win/virtual_desktops.h"
-
+#include "win/activation.h"
 #include "win/controlling.h"
 #include "win/focus_chain.h"
 #include "win/meta.h"
 #include "win/scene.h"
+#include "win/screen.h"
+#include "win/screen_edges.h"
+#include "win/space.h"
 #include "win/stacking.h"
 #include "win/stacking_order.h"
 #include "win/util.h"
+#include "win/virtual_desktops.h"
 #include "win/x11/window.h"
 
 #include <QAction>
@@ -1262,7 +1262,7 @@ void tabbox::cde_walk_through_windows(bool forward)
         if (c && c != nc)
             win::lower_window(&space, c);
         if (kwinApp()->options->focusPolicyIsReasonable()) {
-            space.activateClient(nc);
+            activate_window(space, nc);
         } else {
             if (!nc->isOnDesktop(current_desktop()))
                 set_current_desktop(nc->desktop());
@@ -1277,7 +1277,7 @@ void tabbox::kde_one_step_through_windows(bool forward, TabBoxMode mode)
     reset();
     next_prev(forward);
     if (auto c = current_client()) {
-        space.activateClient(c);
+        activate_window(space, c);
     }
 }
 
@@ -1437,7 +1437,7 @@ void tabbox::accept(bool closeTabBox)
     if (closeTabBox)
         close();
     if (c) {
-        space.activateClient(c);
+        activate_window(space, c);
         if (win::is_desktop(c))
             space.setShowingDesktop(!space.showingDesktop());
     }
diff --git a/win/user_actions_menu.h b/win/user_actions_menu.h
index 68d6847d8..ff1369ff6 100644
--- a/win/user_actions_menu.h
+++ b/win/user_actions_menu.h
@@ -8,6 +8,7 @@
 
 #include "config-kwin.h"
 
+#include "desktop_space.h"
 #include "move.h"
 #include "net.h"
 #include "screen.h"
@@ -417,7 +418,7 @@ private:
             vds->setCount(desk);
         }
 
-        space.sendClientToDesktop(m_client.data(), desk, false);
+        send_window_to_desktop(space, m_client.data(), desk, false);
     }
 
     /**
diff --git a/win/wayland/layer_shell.h b/win/wayland/layer_shell.h
index 55ee5768d..d5b4114b0 100644
--- a/win/wayland/layer_shell.h
+++ b/win/wayland/layer_shell.h
@@ -8,8 +8,10 @@
 #include "space.h"
 #include "window_release.h"
 
+#include "win/activation.h"
 #include "win/geo.h"
 #include "win/screen.h"
+#include "win/space_areas_helpers.h"
 #include "win/stacking.h"
 #include "win/transient.h"
 
@@ -241,7 +243,7 @@ void layer_surface_handle_keyboard_interactivity(Win* win)
     auto interactivity = win->layer_surface->keyboard_interactivity();
     if (interactivity != inter::OnDemand) {
         // With interactivity None or Exclusive just reset control.
-        win->space.activateNextClient(win);
+        activate_next_window(win->space, win);
     }
     kwinApp()->input->redirect->keyboard()->update();
 }
@@ -335,7 +337,7 @@ void process_layer_surface_commit(Win* win)
 
     // TODO(romangg): update client area also on size change?
     if (win->layer_surface->exclusive_zone() > 0) {
-        win->space.updateClientArea();
+        update_space_areas(win->space);
     }
 }
 
diff --git a/win/wayland/setup.h b/win/wayland/setup.h
index 38f7ba4cc..5c958e4d2 100644
--- a/win/wayland/setup.h
+++ b/win/wayland/setup.h
@@ -164,7 +164,7 @@ void setup_plasma_management(Space* space, Win* win)
     QObject::connect(
         plasma_win, &Wrapland::Server::PlasmaWindow::activeRequested, win, [win](bool set) {
             if (set) {
-                win->space.activateClient(win, true);
+                force_activate_window(win->space, win);
             }
         });
 
diff --git a/win/wayland/space.cpp b/win/wayland/space.cpp
index 8dbbcbbba..fe94f5ecd 100644
--- a/win/wayland/space.cpp
+++ b/win/wayland/space.cpp
@@ -242,10 +242,10 @@ void space::handle_window_added(wayland::window* window)
     stacking_order->update_order();
 
     if (window->control) {
-        updateClientArea();
+        win::update_space_areas(*this);
 
         if (window->wantsInput() && !window->control->minimized()) {
-            activateClient(window);
+            activate_window(*this, window);
         }
 
         updateTabbox();
@@ -253,15 +253,15 @@ void space::handle_window_added(wayland::window* window)
         QObject::connect(window, &win::wayland::window::windowShown, qobject.get(), [this, window] {
             win::update_layer(window);
             stacking_order->update_count();
-            updateClientArea();
+            win::update_space_areas(*this);
             if (window->wantsInput()) {
-                activateClient(window);
+                activate_window(*this, window);
             }
         });
         QObject::connect(window, &win::wayland::window::windowHidden, qobject.get(), [this] {
             // TODO: update tabbox if it's displayed
             stacking_order->update_count();
-            updateClientArea();
+            win::update_space_areas(*this);
         });
 
         idle_setup(*kde_idle, *window);
@@ -280,7 +280,7 @@ void space::handle_window_removed(wayland::window* window)
             most_recently_raised = nullptr;
         }
         if (window == delayfocus_client) {
-            cancelDelayFocus();
+            cancel_delay_focus(*this);
         }
         if (window == last_active_client) {
             last_active_client = nullptr;
@@ -299,7 +299,7 @@ void space::handle_window_removed(wayland::window* window)
     stacking_order->update_count();
 
     if (window->control) {
-        updateClientArea();
+        win::update_space_areas(*this);
         updateTabbox();
     }
 
@@ -330,8 +330,11 @@ void space::handle_desktop_removed(virtual_desktop* desktop)
         if (client->desktops().count() > 1) {
             win::leave_desktop(client, desktop);
         } else {
-            sendClientToDesktop(
-                client, qMin(desktop->x11DesktopNumber(), virtual_desktop_manager->count()), true);
+            send_window_to_desktop(
+                *this,
+                client,
+                qMin(desktop->x11DesktopNumber(), virtual_desktop_manager->count()),
+                true);
         }
     }
 }
diff --git a/win/wayland/space.h b/win/wayland/space.h
index fea085c3a..55bfb4259 100644
--- a/win/wayland/space.h
+++ b/win/wayland/space.h
@@ -69,6 +69,10 @@ public:
     void handle_window_added(wayland::window* window);
     void handle_window_removed(wayland::window* window);
 
+    void update_space_area_from_windows(QRect const& desktop_area,
+                                        std::vector<QRect> const& screens_geos,
+                                        win::space_areas& areas) override;
+
     base::wayland::server* server;
 
     std::unique_ptr<Wrapland::Server::Compositor> compositor;
@@ -95,11 +99,6 @@ public:
 
     QVector<Wrapland::Server::PlasmaShellSurface*> plasma_shell_surfaces;
 
-protected:
-    void update_space_area_from_windows(QRect const& desktop_area,
-                                        std::vector<QRect> const& screens_geos,
-                                        win::space_areas& areas) override;
-
 private:
     void handle_x11_window_added(x11::window* window);
     void handle_desktop_removed(virtual_desktop* desktop);
diff --git a/win/wayland/window.cpp b/win/wayland/window.cpp
index 796a7d4a6..f218319d6 100644
--- a/win/wayland/window.cpp
+++ b/win/wayland/window.cpp
@@ -29,6 +29,7 @@
 #include "win/geo.h"
 #include "win/layers.h"
 #include "win/remnant.h"
+#include "win/space_areas_helpers.h"
 #include "win/stacking.h"
 #include "win/stacking_order.h"
 #include "win/transient.h"
@@ -363,7 +364,7 @@ void window::doSetActive()
         return;
     }
     blocker block(space.stacking_order);
-    space.focusToNull();
+    focus_to_null(space);
 }
 
 bool window::userCanSetFullScreen() const
@@ -763,7 +764,7 @@ void window::do_set_geometry(QRect const& frame_geo)
 
     // Must be done after signal is emitted so the screen margins are updated.
     if (hasStrut()) {
-        space.updateClientArea();
+        update_space_areas(space);
     }
 }
 
diff --git a/win/wayland/xdg_activation.h b/win/wayland/xdg_activation.h
index b89ac0c94..8579727f9 100644
--- a/win/wayland/xdg_activation.h
+++ b/win/wayland/xdg_activation.h
@@ -8,6 +8,7 @@
 #include "base/logging.h"
 #include "base/wayland/server.h"
 #include "wayland_logging.h"
+#include "win/activation.h"
 #include "win/stacking.h"
 
 #include <inttypes.h>
@@ -155,7 +156,7 @@ void xdg_activation_activate(Space* space, Window* win, std::string const& token
     }
 
     space->activation->clear();
-    space->activateClient(win);
+    activate_window(*space, win);
 }
 
 template<typename Space>
diff --git a/win/wayland/xdg_shell.h b/win/wayland/xdg_shell.h
index c94f1189d..838e24a14 100644
--- a/win/wayland/xdg_shell.h
+++ b/win/wayland/xdg_shell.h
@@ -19,6 +19,7 @@
 #include "win/input.h"
 #include "win/meta.h"
 #include "win/setup.h"
+#include "win/space_areas_helpers.h"
 #include "win/transient.h"
 
 #include <KScreenLocker/KsldApp>
@@ -469,7 +470,7 @@ void install_plasma_shell_surface(Win* win, Wrapland::Server::PlasmaShellSurface
                 || type == NET::CriticalNotification) {
                 set_on_all_desktops(win, true);
             }
-            win->space.updateClientArea();
+            win::update_space_areas(win->space);
         }
     };
 
@@ -485,7 +486,7 @@ void install_plasma_shell_surface(Win* win, Wrapland::Server::PlasmaShellSurface
     QObject::connect(surface, &PSS::roleChanged, win, update_role);
     QObject::connect(surface, &PSS::panelBehaviorChanged, win, [win] {
         update_screen_edge(win);
-        win->space.updateClientArea();
+        win::update_space_areas(win->space);
     });
     QObject::connect(win, &window::frame_geometry_changed, win, [win] { update_screen_edge(win); });
 
diff --git a/win/window_find.h b/win/window_find.h
new file mode 100644
index 000000000..bdc5b3ad8
--- /dev/null
+++ b/win/window_find.h
@@ -0,0 +1,39 @@
+/*
+    SPDX-FileCopyrightText: 2022 Roman Gilg <subdiff@gmail.com>
+
+    SPDX-License-Identifier: GPL-2.0-or-later
+*/
+#pragma once
+
+#include "toplevel.h"
+
+namespace KWin::win
+{
+
+template<typename Space>
+Toplevel* find_desktop(Space* space, bool topmost, int desktop)
+{
+    // TODO(fsorr): use C++20 std::ranges::reverse_view
+    auto const& list = space->stacking_order->stack;
+    auto is_desktop = [desktop](auto window) {
+        return window->control && window->isOnDesktop(desktop) && win::is_desktop(window)
+            && window->isShown();
+    };
+
+    if (topmost) {
+        auto it = std::find_if(list.rbegin(), list.rend(), is_desktop);
+        if (it != list.rend()) {
+            return *it;
+        }
+    } else {
+        // bottom-most
+        auto it = std::find_if(list.begin(), list.end(), is_desktop);
+        if (it != list.end()) {
+            return *it;
+        }
+    }
+
+    return nullptr;
+}
+
+}
diff --git a/win/x11/control.h b/win/x11/control.h
index 1610c60b7..5cb1b080c 100644
--- a/win/x11/control.h
+++ b/win/x11/control.h
@@ -717,7 +717,7 @@ auto create_controlled_window(xcb_window_t xcb_win, bool isMapped, Space& space)
             if (allow && win->isOnCurrentDesktop()) {
                 if (!is_special_window(win)) {
                     if (kwinApp()->options->focusPolicyIsReasonable() && wants_tab_focus(win)) {
-                        space.request_focus(win);
+                        request_focus(space, win);
                     }
                 }
             } else if (!session && !is_special_window(win)) {
@@ -804,7 +804,7 @@ xcb_timestamp_t read_user_time_map_timestamp(Win* win,
         // Otherwise, refuse activation of a window
         // from already running application if this application
         // is not the active one (unless focus stealing prevention is turned off).
-        auto act = dynamic_cast<Win*>(win->space.mostRecentlyActivatedClient());
+        auto act = dynamic_cast<Win*>(most_recently_activated_window(win->space));
         if (act != nullptr
             && !belong_to_same_application(act, win, same_client_check::relaxed_for_active)) {
             bool first_window = true;
diff --git a/win/x11/event.h b/win/x11/event.h
index bf9022fcc..cd1d7296a 100644
--- a/win/x11/event.h
+++ b/win/x11/event.h
@@ -118,7 +118,7 @@ bool window_event(Win* win, xcb_generic_event_t* e)
         }
         if ((dirtyProperties & NET::WMStrut) != 0
             || (dirtyProperties2 & NET::WM2ExtendedStrut) != 0) {
-            win->space.updateClientArea();
+            update_space_areas(win->space);
         }
         if ((dirtyProperties & NET::WMIcon) != 0) {
             get_icons(win);
@@ -355,7 +355,7 @@ bool map_request_event(Win* win, xcb_map_request_event_t* e)
     }
     if (!win->isOnCurrentDesktop()) {
         if (win->space.allowClientActivation(win)) {
-            win->space.activateClient(win);
+            activate_window(win->space, win);
         } else {
             win::set_demands_attention(win, true);
         }
@@ -602,7 +602,7 @@ void leave_notify_event(Win* win, xcb_leave_notify_event_t* e)
         }
         if (kwinApp()->options->focusPolicy() == base::options::FocusStrictlyUnderMouse
             && win->control->active() && lostMouse) {
-            win->space.requestDelayFocus(nullptr);
+            request_delay_focus(win->space, nullptr);
         }
         return;
     }
diff --git a/win/x11/hide.h b/win/x11/hide.h
index d863fcb20..22ee85d0b 100644
--- a/win/x11/hide.h
+++ b/win/x11/hide.h
@@ -10,6 +10,7 @@
 #include "window.h"
 
 #include "base/options.h"
+#include "win/activation.h"
 #include "win/controlling.h"
 #include "win/scene.h"
 #include "win/stacking_order.h"
@@ -160,7 +161,7 @@ void internal_keep(Win* win)
     win->xcb_windows.input.unmap();
     if (win->control->active()) {
         // get rid of input focus, bug #317484
-        win->space.focusToNull();
+        focus_to_null(win->space);
     }
 
     update_hidden_preview(win);
diff --git a/win/x11/netinfo.cpp b/win/x11/netinfo.cpp
index 96112944d..2a1cb110a 100644
--- a/win/x11/netinfo.cpp
+++ b/win/x11/netinfo.cpp
@@ -25,6 +25,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "window_find.h"
 
 #include "win/controlling.h"
+#include "win/desktop_space.h"
 #include "win/move.h"
 #include "win/space.h"
 #include "win/stacking.h"
@@ -201,14 +202,15 @@ void root_info::changeActiveWindow(xcb_window_t w,
             timestamp = c->userTime();
         if (src != NET::FromApplication && src != FromTool)
             src = NET::FromTool;
-        if (src == NET::FromTool)
-            space.activateClient(c, true); // force
-        else if (c == space.mostRecentlyActivatedClient()) {
+
+        if (src == NET::FromTool) {
+            force_activate_window(space, c);
+        } else if (c == most_recently_activated_window(space)) {
             return; // WORKAROUND? With > 1 plasma activities, we cause this ourselves. bug #240673
         } else {    // NET::FromApplication
             x11::window* c2;
             if (space.allowClientActivation(c, timestamp, false, true))
-                space.activateClient(c);
+                activate_window(space, c);
             // if activation of the requestor's window would be allowed, allow activation too
             else if (active_window != XCB_WINDOW_NONE
                      && (c2 = find_controlled_window<x11::window>(
@@ -220,7 +222,7 @@ void root_info::changeActiveWindow(xcb_window_t w,
                                           c2->userTime() > 0 ? timestamp : c2->userTime()),
                          false,
                          true)) {
-                space.activateClient(c);
+                activate_window(space, c);
             } else
                 win::set_demands_attention(c, true);
         }
@@ -304,7 +306,7 @@ win_info::win_info(win::x11::window* c,
 
 void win_info::changeDesktop(int desktop)
 {
-    m_client->space.sendClientToDesktop(m_client, desktop, true);
+    send_window_to_desktop(m_client->space, m_client, desktop, true);
 }
 
 void win_info::changeFullscreenMonitors(NETFullscreenMonitors topology)
diff --git a/win/x11/space.cpp b/win/x11/space.cpp
index c02489373..861a2813a 100644
--- a/win/x11/space.cpp
+++ b/win/x11/space.cpp
@@ -11,6 +11,8 @@
 #include "space_setup.h"
 #include "window.h"
 
+#include "win/desktop_space.h"
+
 namespace KWin::win::x11
 {
 
@@ -36,7 +38,7 @@ space::space(render::compositor& render)
                              if (window->desktop() <= desktop_count) {
                                  continue;
                              }
-                             sendClientToDesktop(window, desktop_count, true);
+                             send_window_to_desktop(*this, window, desktop_count, true);
                          }
                      });
 
diff --git a/win/x11/space.h b/win/x11/space.h
index f2e9e3adf..51c2b7469 100644
--- a/win/x11/space.h
+++ b/win/x11/space.h
@@ -31,7 +31,6 @@ public:
     Toplevel* findInternal(QWindow* window) const override;
     win::screen_edge* create_screen_edge(win::screen_edger& edger) override;
 
-protected:
     void update_space_area_from_windows(QRect const& desktop_area,
                                         std::vector<QRect> const& screens_geos,
                                         win::space_areas& areas) override;
diff --git a/win/x11/space_event.h b/win/x11/space_event.h
index a362ee966..ef49c6a68 100644
--- a/win/x11/space_event.h
+++ b/win/x11/space_event.h
@@ -304,13 +304,13 @@ bool space_event(Space& space, xcb_generic_event_t* event)
                     || currentInput->focus == XCB_INPUT_FOCUS_POINTER_ROOT
                     || lostFocusPointerToRoot)) {
                 // kWarning( 1212 ) << "X focus set to None/PointerRoot, reseting focus" ;
-                auto window = space.mostRecentlyActivatedClient();
+                auto window = most_recently_activated_window(space);
                 if (window != nullptr) {
-                    space.request_focus(window, false, true);
-                } else if (space.activateNextClient(nullptr)) {
+                    request_focus(space, window, false, true);
+                } else if (activate_next_window(space, nullptr)) {
                     ; // ok, activated
                 } else {
-                    space.focusToNull();
+                    focus_to_null(space);
                 }
             }
         }
diff --git a/win/x11/space_setup.h b/win/x11/space_setup.h
index 901350613..ca1068e00 100644
--- a/win/x11/space_setup.h
+++ b/win/x11/space_setup.h
@@ -15,6 +15,7 @@
 #include "main.h"
 #include "utils/blocker.h"
 #include "win/desktop_space.h"
+#include "win/space_areas_helpers.h"
 
 #include <KStartupInfo>
 
@@ -95,7 +96,7 @@ void init_space(Space& space)
 
     // TODO: better value
     rootInfo->setActiveWindow(XCB_WINDOW_NONE);
-    space.focusToNull();
+    focus_to_null(space);
 
     if (!qApp->isSessionRestored())
         ++space.block_focus; // Because it will be set below
@@ -143,7 +144,7 @@ void init_space(Space& space)
         space.stacking_order->update_count();
 
         space.saveOldScreenSizes();
-        space.updateClientArea();
+        update_space_areas(space);
 
         // NETWM spec says we have to set it to (0,0) if we don't support it
         NETPoint* viewports = new NETPoint[vds->count()];
@@ -179,7 +180,7 @@ void init_space(Space& space)
         }
     }
     if (new_active_client != nullptr)
-        space.activateClient(new_active_client);
+        activate_window(space, new_active_client);
 }
 
 template<typename Space>
diff --git a/win/x11/startup_info.h b/win/x11/startup_info.h
index 2c71b07ab..6809220fa 100644
--- a/win/x11/startup_info.h
+++ b/win/x11/startup_info.h
@@ -7,6 +7,7 @@
 
 #include "base/output_helpers.h"
 #include "main.h"
+#include "win/desktop_space.h"
 
 #include <KStartupInfo>
 
@@ -28,7 +29,7 @@ void startup_id_changed(Win* win)
     if (asn_data.desktop() != 0)
         desktop = asn_data.desktop();
     if (!win->isOnAllDesktops()) {
-        win->space.sendClientToDesktop(win, desktop, true);
+        send_window_to_desktop(win->space, win, desktop, true);
     }
     if (asn_data.xinerama() != -1) {
         auto output = base::get_output(kwinApp()->get_base().get_outputs(), asn_data.xinerama());
@@ -44,7 +45,7 @@ void startup_id_changed(Win* win)
             activate = false;
         }
         if (activate) {
-            win->space.activateClient(win);
+            activate_window(win->space, win);
         } else {
             set_demands_attention(win, true);
         }
diff --git a/win/x11/transient.h b/win/x11/transient.h
index 8c485ce0d..91d1af612 100644
--- a/win/x11/transient.h
+++ b/win/x11/transient.h
@@ -11,6 +11,7 @@
 
 #include "base/logging.h"
 #include "base/x11/xcb/proto.h"
+#include "win/activation.h"
 #include "win/stacking.h"
 #include "win/transient.h"
 
@@ -342,7 +343,7 @@ template<typename Win, typename Space>
 void check_active_modal(Space& space)
 {
     // If the active window got new modal transient, activate it.
-    auto win = qobject_cast<Win*>(space.mostRecentlyActivatedClient());
+    auto win = qobject_cast<Win*>(most_recently_activated_window(space));
     if (!win) {
         return;
     }
@@ -354,7 +355,7 @@ void check_active_modal(Space& space)
             // postpone check until end of manage()
             return;
         }
-        space.activateClient(new_modal);
+        activate_window(space, new_modal);
     }
 }
 
diff --git a/win/x11/window.cpp b/win/x11/window.cpp
index 160132488..4e176c5fe 100644
--- a/win/x11/window.cpp
+++ b/win/x11/window.cpp
@@ -27,6 +27,7 @@
 #include "win/deco/window.h"
 #include "win/layers.h"
 #include "win/remnant.h"
+#include "win/space_areas_helpers.h"
 #include "win/stacking.h"
 #include "win/stacking_order.h"
 
@@ -768,7 +769,7 @@ void window::do_set_geometry(QRect const& frame_geo)
 
     // Must be done after signal is emitted so the screen margins are update.
     if (hasStrut()) {
-        space.updateClientArea();
+        update_space_areas(space);
     }
 }
 
diff --git a/win/x11/window_create.h b/win/x11/window_create.h
index 0e6c7e773..9422c4421 100644
--- a/win/x11/window_create.h
+++ b/win/x11/window_create.h
@@ -8,6 +8,8 @@
 #include "hide.h"
 #include "transient.h"
 
+#include "win/space_areas_helpers.h"
+
 namespace KWin::win::x11
 {
 
@@ -26,7 +28,7 @@ void add_controlled_window_to_space(Space& space, Win* win)
     if (is_desktop(win)) {
         if (!space.active_client && space.should_get_focus.empty() && win->isOnCurrentDesktop()) {
             // TODO: Make sure desktop is active after startup if there's no other window active
-            space.request_focus(win);
+            request_focus(space, win);
         }
     } else {
         focus_chain_update(space.focus_chain, win, focus_chain_change::update);
@@ -42,15 +44,15 @@ void add_controlled_window_to_space(Space& space, Win* win)
     }
 
     // This cannot be in manage(), because the client got added only now
-    space.updateClientArea();
+    update_space_areas(space);
     update_layer(win);
 
     if (is_desktop(win)) {
         raise_window(&space, win);
         // If there's no active client, make this desktop the active one
         if (!space.active_client && space.should_get_focus.size() == 0)
-            space.activateClient(
-                find_desktop(&space, true, space.virtual_desktop_manager->current()));
+            activate_window(space,
+                            find_desktop(&space, true, space.virtual_desktop_manager->current()));
     }
 
     check_active_modal<Win>(space);
diff --git a/win/x11/window_release.h b/win/x11/window_release.h
index 4bb2a62c4..97a020ffd 100644
--- a/win/x11/window_release.h
+++ b/win/x11/window_release.h
@@ -10,6 +10,7 @@
 #include "utils/blocker.h"
 #include "win/input.h"
 #include "win/rules.h"
+#include "win/space_areas_helpers.h"
 #include "win/space_helpers.h"
 #include "win/window_release.h"
 
@@ -24,7 +25,7 @@ template<typename Space, typename Win>
 void remove_controlled_window_from_space(Space& space, Win* win)
 {
     if (win == space.active_popup_client) {
-        space.closeActivePopup();
+        close_active_popup(space);
     }
 
     if (space.user_actions_menu->isMenuClient(win)) {
@@ -64,13 +65,14 @@ void remove_controlled_window_from_space(Space& space, Win* win)
     if (win == space.last_active_client) {
         space.last_active_client = nullptr;
     }
-    if (win == space.delayfocus_client)
-        space.cancelDelayFocus();
+    if (win == space.delayfocus_client) {
+        cancel_delay_focus(space);
+    }
 
     Q_EMIT space.qobject->clientRemoved(win);
 
     space.stacking_order->update_count();
-    space.updateClientArea();
+    update_space_areas(space);
     space.updateTabbox();
 }
 
diff --git a/xwl/drag_wl.cpp b/xwl/drag_wl.cpp
index 6c413e7d1..09e6e32e1 100644
--- a/xwl/drag_wl.cpp
+++ b/xwl/drag_wl.cpp
@@ -23,6 +23,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "mime.h"
 
 #include "base/wayland/server.h"
+#include "win/activation.h"
 #include "win/space.h"
 #include "win/x11/window.h"
 
@@ -63,7 +64,7 @@ drag_event_reply wl_drag::move_filter(Toplevel* target, QPoint const& pos)
 
     // We have a new target.
 
-    source.x11.space->activateClient(target, false);
+    win::activate_window(*source.x11.space, target);
     seat->drags().set_target(target->surface, pos, target->input_transform());
 
     visit.reset(new x11_visit(target, source, proxy_window));
diff --git a/xwl/drag_x.cpp b/xwl/drag_x.cpp
index 482e5db3a..6032c04bb 100644
--- a/xwl/drag_x.cpp
+++ b/xwl/drag_x.cpp
@@ -26,6 +26,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
 #include "base/wayland/server.h"
 #include "toplevel.h"
+#include "win/activation.h"
 #include "win/space.h"
 #include "win/stacking_order.h"
 
@@ -114,7 +115,7 @@ drag_event_reply x11_drag::move_filter(Toplevel* target, QPoint const& pos)
         // Handled here and by X directly.
         if (target && target->surface && target->control) {
             if (source.x11.space->active_client != target) {
-                source.x11.space->activateClient(target);
+                win::activate_window(*source.x11.space, target);
             }
         }
 
@@ -198,7 +199,7 @@ void x11_drag::set_offers(mime_atoms const& offers)
 void x11_drag::set_drag_target()
 {
     auto ac = visit->get_target();
-    source.x11.space->activateClient(ac);
+    win::activate_window(*source.x11.space, ac);
     waylandServer()->seat()->drags().set_target(ac->surface, ac->input_transform());
 }
 
-- 
GitLab


From 154ad620dc6a19b5e6c91856f2cd8d1eba17287b Mon Sep 17 00:00:00 2001
From: Roman Gilg <subdiff@gmail.com>
Date: Tue, 5 Jul 2022 23:37:32 +0200
Subject: [PATCH 08/51] refactor: split desktop functions into multiple headers

This reduces the risk of issues due to cyclic inclusions.
---
 .../integration/idle_inhibition_test.cpp      |   1 +
 .../integration/virtual_desktop_test.cpp      |   1 +
 render/effects.cpp                            |   2 +-
 scripting/window.cpp                          |   1 +
 win/activation.h                              |  70 +++++++
 win/desktop_get.h                             |  54 ++++++
 win/desktop_set.h                             | 151 +++++++++++++++
 win/desktop_space.h                           |  83 +++------
 win/internal_window.cpp                       |   2 +-
 win/screen.h                                  | 175 ------------------
 win/space.cpp                                 |   1 -
 win/space_helpers.h                           |  61 ------
 win/wayland/subsurface.h                      |   4 +-
 win/wayland/window_release.h                  |   1 -
 win/window_release.h                          |   4 +-
 win/x11/geo.h                                 |   1 -
 win/x11/unmanaged.h                           |   1 -
 win/x11/window_release.h                      |   1 -
 18 files changed, 312 insertions(+), 302 deletions(-)
 create mode 100644 win/desktop_get.h
 create mode 100644 win/desktop_set.h
 delete mode 100644 win/space_helpers.h

diff --git a/autotests/integration/idle_inhibition_test.cpp b/autotests/integration/idle_inhibition_test.cpp
index d2a671726..6f72f7f86 100644
--- a/autotests/integration/idle_inhibition_test.cpp
+++ b/autotests/integration/idle_inhibition_test.cpp
@@ -20,6 +20,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "lib/app.h"
 
 #include "win/actions.h"
+#include "win/desktop_set.h"
 #include "win/screen.h"
 #include "win/space.h"
 #include "win/wayland/window.h"
diff --git a/autotests/integration/virtual_desktop_test.cpp b/autotests/integration/virtual_desktop_test.cpp
index 834a98db2..155741fb6 100644
--- a/autotests/integration/virtual_desktop_test.cpp
+++ b/autotests/integration/virtual_desktop_test.cpp
@@ -8,6 +8,7 @@
 
 #include "base/wayland/server.h"
 #include "main.h"
+#include "win/desktop_set.h"
 #include "win/screen.h"
 #include "win/virtual_desktops.h"
 #include "win/wayland/window.h"
diff --git a/render/effects.cpp b/render/effects.cpp
index 43546f15e..9f423e7d3 100644
--- a/render/effects.cpp
+++ b/render/effects.cpp
@@ -40,7 +40,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "win/activation.h"
 #include "win/control.h"
 #include "win/deco/bridge.h"
-#include "win/desktop_space.h"
+#include "win/desktop_get.h"
 #include "win/internal_window.h"
 #include "win/meta.h"
 #include "win/osd.h"
diff --git a/scripting/window.cpp b/scripting/window.cpp
index 73a122e52..55b86ba46 100644
--- a/scripting/window.cpp
+++ b/scripting/window.cpp
@@ -11,6 +11,7 @@
 #include "win/actions.h"
 #include "win/activation.h"
 #include "win/controlling.h"
+#include "win/desktop_get.h"
 #include "win/meta.h"
 #include "win/screen.h"
 #include "win/transient.h"
diff --git a/win/activation.h b/win/activation.h
index 641cd0924..4eeb8cccb 100644
--- a/win/activation.h
+++ b/win/activation.h
@@ -6,6 +6,7 @@
 #pragma once
 
 #include "actions.h"
+#include "desktop_set.h"
 #include "layers.h"
 #include "screen.h"
 #include "stacking_order.h"
@@ -549,6 +550,75 @@ bool activate_next_window(Space& space, Toplevel* window)
     return true;
 }
 
+template<typename Space>
+Toplevel* find_window_to_activate_on_desktop(Space& space, unsigned int desktop)
+{
+    if (space.movingClient != nullptr && space.active_client == space.movingClient
+        && focus_chain_at_desktop_contains(space.focus_chain, space.active_client, desktop)
+        && space.active_client->isShown() && space.active_client->isOnCurrentDesktop()) {
+        // A requestFocus call will fail, as the client is already active
+        return space.active_client;
+    }
+
+    // from actiavtion.cpp
+    if (kwinApp()->options->isNextFocusPrefersMouse()) {
+        auto it = space.stacking_order->stack.cend();
+        while (it != space.stacking_order->stack.cbegin()) {
+            auto client = qobject_cast<win::x11::window*>(*(--it));
+            if (!client) {
+                continue;
+            }
+
+            if (!(client->isShown() && client->isOnDesktop(desktop) && on_active_screen(client)))
+                continue;
+
+            if (client->frameGeometry().contains(input::get_cursor()->pos())) {
+                if (!is_desktop(client)) {
+                    return client;
+                }
+                // Unconditional break, we don't pass focus to some client below an unusable one.
+                break;
+            }
+        }
+    }
+
+    return focus_chain_get_for_activation_on_current_output<Toplevel>(space.focus_chain, desktop);
+}
+
+template<typename Space>
+void activate_window_on_new_desktop(Space& space, unsigned int desktop)
+{
+    Toplevel* c = nullptr;
+
+    if (kwinApp()->options->focusPolicyIsReasonable()) {
+        c = find_window_to_activate_on_desktop(space, desktop);
+    }
+
+    // If "unreasonable focus policy" and active_client is on_all_desktops and
+    // under mouse (Hence == old_active_client), conserve focus.
+    // (Thanks to Volker Schatz <V.Schatz at thphys.uni-heidelberg.de>)
+    else if (space.active_client && space.active_client->isShown()
+             && space.active_client->isOnCurrentDesktop()) {
+        c = space.active_client;
+    }
+
+    if (!c) {
+        c = find_desktop(&space, true, desktop);
+    }
+
+    if (c != space.active_client) {
+        set_active_window(space, nullptr);
+    }
+
+    if (c) {
+        request_focus(space, c);
+    } else if (auto desktop_client = find_desktop(&space, true, desktop)) {
+        request_focus(space, desktop_client);
+    } else {
+        focus_to_null(space);
+    }
+}
+
 template<typename Space>
 void delay_focus(Space& space)
 {
diff --git a/win/desktop_get.h b/win/desktop_get.h
new file mode 100644
index 000000000..75347a167
--- /dev/null
+++ b/win/desktop_get.h
@@ -0,0 +1,54 @@
+/*
+    SPDX-FileCopyrightText: 2022 Roman Gilg <subdiff@gmail.com>
+
+    SPDX-License-Identifier: GPL-2.0-or-later
+*/
+#pragma once
+
+#include "main.h"
+
+#include <NETWM>
+
+namespace KWin::win
+{
+
+template<typename Win>
+bool on_all_desktops(Win* win)
+{
+    return kwinApp()->operationMode() == Application::OperationModeWaylandOnly
+            || kwinApp()->operationMode() == Application::OperationModeXwayland
+        // Wayland
+        ? win->desktops().isEmpty()
+        // X11
+        : win->desktop() == NET::OnAllDesktops;
+}
+
+template<typename Win>
+bool on_desktop(Win* win, int d)
+{
+    return (kwinApp()->operationMode() == Application::OperationModeWaylandOnly
+                    || kwinApp()->operationMode() == Application::OperationModeXwayland
+                ? win->desktops().contains(win->space.virtual_desktop_manager->desktopForX11Id(d))
+                : win->desktop() == d)
+        || on_all_desktops(win);
+}
+
+template<typename Win>
+bool on_current_desktop(Win* win)
+{
+    return on_desktop(win, win->space.virtual_desktop_manager->current());
+}
+
+template<typename Win>
+QVector<unsigned int> x11_desktop_ids(Win* win)
+{
+    auto const desks = win->desktops();
+    QVector<unsigned int> x11_ids;
+    x11_ids.reserve(desks.count());
+    std::transform(desks.constBegin(), desks.constEnd(), std::back_inserter(x11_ids), [](auto vd) {
+        return vd->x11DesktopNumber();
+    });
+    return x11_ids;
+}
+
+}
diff --git a/win/desktop_set.h b/win/desktop_set.h
new file mode 100644
index 000000000..f157356b2
--- /dev/null
+++ b/win/desktop_set.h
@@ -0,0 +1,151 @@
+/*
+    SPDX-FileCopyrightText: 2022 Roman Gilg <subdiff@gmail.com>
+
+    SPDX-License-Identifier: GPL-2.0-or-later
+*/
+#pragma once
+
+#include "desktop_get.h"
+
+#include "main.h"
+
+namespace KWin::win
+{
+
+template<typename Win>
+void set_desktops(Win* win, QVector<virtual_desktop*> desktops)
+{
+    // On x11 we can have only one desktop at a time.
+    if (kwinApp()->operationMode() == Application::OperationModeX11 && desktops.size() > 1) {
+        desktops = QVector<virtual_desktop*>({desktops.last()});
+    }
+
+    if (desktops == win->desktops()) {
+        return;
+    }
+
+    auto was_desk = win->desktop();
+    auto const wasOnCurrentDesktop = on_current_desktop(win) && was_desk >= 0;
+
+    win->set_desktops(desktops);
+
+    if (auto management = win->control->wayland_management()) {
+        if (desktops.isEmpty()) {
+            management->setOnAllDesktops(true);
+        } else {
+            management->setOnAllDesktops(false);
+            auto currentDesktops = management->plasmaVirtualDesktops();
+            for (auto desktop : desktops) {
+                auto id = desktop->id().toStdString();
+                if (!contains(currentDesktops, id)) {
+                    management->addPlasmaVirtualDesktop(id);
+                } else {
+                    remove_all(currentDesktops, id);
+                }
+            }
+            for (auto desktop : currentDesktops) {
+                management->removePlasmaVirtualDesktop(desktop);
+            }
+        }
+    }
+    if (win->info) {
+        win->info->setDesktop(win->desktop());
+    }
+
+    if ((was_desk == NET::OnAllDesktops) != (win->desktop() == NET::OnAllDesktops)) {
+        // OnAllDesktops changed
+        win->space.updateOnAllDesktopsOfTransients(win);
+    }
+
+    auto transients_stacking_order
+        = restacked_by_space_stacking_order(&win->space, win->transient()->children);
+    for (auto const& child : transients_stacking_order) {
+        if (!child->transient()->annexed) {
+            set_desktops(child, desktops);
+        }
+    }
+
+    if (win->transient()->modal()) {
+        // When a modal dialog is moved move the parent window with it as otherwise the just moved
+        // modal dialog will return to the parent window with the next desktop change.
+        for (auto client : win->transient()->leads()) {
+            set_desktops(client, desktops);
+        }
+    }
+
+    win->doSetDesktop(win->desktop(), was_desk);
+
+    focus_chain_update(win->space.focus_chain, win, focus_chain_change::make_first);
+    win->updateWindowRules(Rules::Desktop);
+
+    Q_EMIT win->desktopChanged();
+    if (wasOnCurrentDesktop != on_current_desktop(win)) {
+        Q_EMIT win->desktopPresenceChanged(win, was_desk);
+    }
+    Q_EMIT win->x11DesktopIdsChanged();
+}
+
+/**
+ * Deprecated, use x11_desktop_ids.
+ */
+template<typename Win>
+void set_desktop(Win* win, int desktop)
+{
+    auto const desktops_count = static_cast<int>(win->space.virtual_desktop_manager->count());
+    if (desktop != NET::OnAllDesktops) {
+        // Check range.
+        desktop = std::max(1, std::min(desktops_count, desktop));
+    }
+    desktop = std::min(desktops_count, win->control->rules().checkDesktop(desktop));
+
+    QVector<virtual_desktop*> desktops;
+    if (desktop != NET::OnAllDesktops) {
+        desktops << win->space.virtual_desktop_manager->desktopForX11Id(desktop);
+    }
+    set_desktops(win, desktops);
+}
+
+template<typename Win>
+void set_on_all_desktops(Win* win, bool set)
+{
+    if (set == on_all_desktops(win)) {
+        return;
+    }
+
+    if (set) {
+        set_desktop(win, NET::OnAllDesktops);
+    } else {
+        set_desktop(win, win->space.virtual_desktop_manager->current());
+    }
+}
+
+template<typename Win>
+void enter_desktop(Win* win, virtual_desktop* virtualDesktop)
+{
+    if (win->desktops().contains(virtualDesktop)) {
+        return;
+    }
+    auto desktops = win->desktops();
+    desktops.append(virtualDesktop);
+    set_desktops(win, desktops);
+}
+
+template<typename Win>
+void leave_desktop(Win* win, virtual_desktop* virtualDesktop)
+{
+    QVector<virtual_desktop*> currentDesktops;
+    if (win->desktops().isEmpty()) {
+        currentDesktops = win->space.virtual_desktop_manager->desktops();
+    } else {
+        currentDesktops = win->desktops();
+    }
+
+    if (!currentDesktops.contains(virtualDesktop)) {
+        return;
+    }
+    auto desktops = currentDesktops;
+    desktops.removeOne(virtualDesktop);
+    set_desktops(win, desktops);
+}
+
+}
diff --git a/win/desktop_space.h b/win/desktop_space.h
index 1dc32b968..d17827b1b 100644
--- a/win/desktop_space.h
+++ b/win/desktop_space.h
@@ -6,8 +6,8 @@
 #pragma once
 
 #include "activation.h"
+#include "desktop_set.h"
 #include "space_areas_helpers.h"
-#include "space_helpers.h"
 #include "toplevel.h"
 
 #include "utils/blocker.h"
@@ -61,71 +61,44 @@ void send_window_to_desktop(Space& space, Toplevel* window, int desk, bool dont_
 }
 
 template<typename Space>
-Toplevel* find_window_to_activate_on_desktop(Space& space, unsigned int desktop)
+void update_client_visibility_on_desktop_change(Space* space, uint newDesktop)
 {
-    if (space.movingClient != nullptr && space.active_client == space.movingClient
-        && focus_chain_at_desktop_contains(space.focus_chain, space.active_client, desktop)
-        && space.active_client->isShown() && space.active_client->isOnCurrentDesktop()) {
-        // A requestFocus call will fail, as the client is already active
-        return space.active_client;
-    }
-
-    // from actiavtion.cpp
-    if (kwinApp()->options->isNextFocusPrefersMouse()) {
-        auto it = space.stacking_order->stack.cend();
-        while (it != space.stacking_order->stack.cbegin()) {
-            auto client = qobject_cast<win::x11::window*>(*(--it));
-            if (!client) {
-                continue;
-            }
-
-            if (!(client->isShown() && client->isOnDesktop(desktop) && on_active_screen(client)))
-                continue;
-
-            if (client->frameGeometry().contains(input::get_cursor()->pos())) {
-                if (!is_desktop(client)) {
-                    return client;
-                }
-                // Unconditional break, we don't pass focus to some client below an unusable one.
-                break;
-            }
+    for (auto const& toplevel : space->stacking_order->stack) {
+        auto client = qobject_cast<x11::window*>(toplevel);
+        if (!client || !client->control) {
+            continue;
         }
-    }
 
-    return focus_chain_get_for_activation_on_current_output<Toplevel>(space.focus_chain, desktop);
-}
-
-template<typename Space>
-void activate_window_on_new_desktop(Space& space, unsigned int desktop)
-{
-    Toplevel* c = nullptr;
-
-    if (kwinApp()->options->focusPolicyIsReasonable()) {
-        c = find_window_to_activate_on_desktop(space, desktop);
+        if (!client->isOnDesktop(newDesktop) && client != space->moveResizeClient()) {
+            update_visibility(client);
+        }
     }
 
-    // If "unreasonable focus policy" and active_client is on_all_desktops and
-    // under mouse (Hence == old_active_client), conserve focus.
-    // (Thanks to Volker Schatz <V.Schatz at thphys.uni-heidelberg.de>)
-    else if (space.active_client && space.active_client->isShown()
-             && space.active_client->isOnCurrentDesktop()) {
-        c = space.active_client;
+    // Now propagate the change, after hiding, before showing.
+    if (x11::rootInfo()) {
+        x11::rootInfo()->setCurrentDesktop(space->virtual_desktop_manager->current());
     }
 
-    if (!c) {
-        c = find_desktop(&space, true, desktop);
+    if (auto move_resize_client = space->moveResizeClient()) {
+        if (!move_resize_client->isOnDesktop(newDesktop)) {
+            win::set_desktop(move_resize_client, newDesktop);
+        }
     }
 
-    if (c != space.active_client) {
-        set_active_window(space, nullptr);
+    auto const& list = space->stacking_order->stack;
+    for (int i = list.size() - 1; i >= 0; --i) {
+        auto client = qobject_cast<x11::window*>(list.at(i));
+        if (!client || !client->control) {
+            continue;
+        }
+        if (client->isOnDesktop(newDesktop)) {
+            update_visibility(client);
+        }
     }
 
-    if (c) {
-        request_focus(space, c);
-    } else if (auto desktop_client = find_desktop(&space, true, desktop)) {
-        request_focus(space, desktop_client);
-    } else {
-        focus_to_null(space);
+    if (space->showingDesktop()) {
+        // Do this only after desktop change to avoid flicker.
+        space->setShowingDesktop(false);
     }
 }
 
diff --git a/win/internal_window.cpp b/win/internal_window.cpp
index 596bf6aa6..0a10387d5 100644
--- a/win/internal_window.cpp
+++ b/win/internal_window.cpp
@@ -23,6 +23,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "control.h"
 #include "deco/bridge.h"
 #include "deco/window.h"
+#include "desktop_set.h"
 #include "geo.h"
 #include "meta.h"
 #include "remnant.h"
@@ -31,7 +32,6 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "setup.h"
 #include "space.h"
 #include "space_areas_helpers.h"
-#include "space_helpers.h"
 #include "window_release.h"
 
 #include <KDecoration2/Decoration>
diff --git a/win/screen.h b/win/screen.h
index bd46027a7..3ad21d261 100644
--- a/win/screen.h
+++ b/win/screen.h
@@ -165,179 +165,4 @@ bool on_active_screen(Win* win)
     return on_screen(win, get_current_output(win->space));
 }
 
-template<typename Win>
-bool on_all_desktops(Win* win)
-{
-    return kwinApp()->operationMode() == Application::OperationModeWaylandOnly
-            || kwinApp()->operationMode() == Application::OperationModeXwayland
-        // Wayland
-        ? win->desktops().isEmpty()
-        // X11
-        : win->desktop() == NET::OnAllDesktops;
-}
-
-template<typename Win>
-bool on_desktop(Win* win, int d)
-{
-    return (kwinApp()->operationMode() == Application::OperationModeWaylandOnly
-                    || kwinApp()->operationMode() == Application::OperationModeXwayland
-                ? win->desktops().contains(win->space.virtual_desktop_manager->desktopForX11Id(d))
-                : win->desktop() == d)
-        || on_all_desktops(win);
-}
-
-template<typename Win>
-bool on_current_desktop(Win* win)
-{
-    return on_desktop(win, win->space.virtual_desktop_manager->current());
-}
-
-template<typename Win>
-void set_desktops(Win* win, QVector<virtual_desktop*> desktops)
-{
-    // On x11 we can have only one desktop at a time.
-    if (kwinApp()->operationMode() == Application::OperationModeX11 && desktops.size() > 1) {
-        desktops = QVector<virtual_desktop*>({desktops.last()});
-    }
-
-    if (desktops == win->desktops()) {
-        return;
-    }
-
-    auto was_desk = win->desktop();
-    auto const wasOnCurrentDesktop = on_current_desktop(win) && was_desk >= 0;
-
-    win->set_desktops(desktops);
-
-    if (auto management = win->control->wayland_management()) {
-        if (desktops.isEmpty()) {
-            management->setOnAllDesktops(true);
-        } else {
-            management->setOnAllDesktops(false);
-            auto currentDesktops = management->plasmaVirtualDesktops();
-            for (auto desktop : desktops) {
-                auto id = desktop->id().toStdString();
-                if (!contains(currentDesktops, id)) {
-                    management->addPlasmaVirtualDesktop(id);
-                } else {
-                    remove_all(currentDesktops, id);
-                }
-            }
-            for (auto desktop : currentDesktops) {
-                management->removePlasmaVirtualDesktop(desktop);
-            }
-        }
-    }
-    if (win->info) {
-        win->info->setDesktop(win->desktop());
-    }
-
-    if ((was_desk == NET::OnAllDesktops) != (win->desktop() == NET::OnAllDesktops)) {
-        // OnAllDesktops changed
-        win->space.updateOnAllDesktopsOfTransients(win);
-    }
-
-    auto transients_stacking_order
-        = restacked_by_space_stacking_order(&win->space, win->transient()->children);
-    for (auto const& child : transients_stacking_order) {
-        if (!child->transient()->annexed) {
-            set_desktops(child, desktops);
-        }
-    }
-
-    if (win->transient()->modal()) {
-        // When a modal dialog is moved move the parent window with it as otherwise the just moved
-        // modal dialog will return to the parent window with the next desktop change.
-        for (auto client : win->transient()->leads()) {
-            set_desktops(client, desktops);
-        }
-    }
-
-    win->doSetDesktop(win->desktop(), was_desk);
-
-    focus_chain_update(win->space.focus_chain, win, focus_chain_change::make_first);
-    win->updateWindowRules(Rules::Desktop);
-
-    Q_EMIT win->desktopChanged();
-    if (wasOnCurrentDesktop != on_current_desktop(win)) {
-        Q_EMIT win->desktopPresenceChanged(win, was_desk);
-    }
-    Q_EMIT win->x11DesktopIdsChanged();
-}
-
-/**
- * Deprecated, use x11_desktop_ids.
- */
-template<typename Win>
-void set_desktop(Win* win, int desktop)
-{
-    auto const desktops_count = static_cast<int>(win->space.virtual_desktop_manager->count());
-    if (desktop != NET::OnAllDesktops) {
-        // Check range.
-        desktop = std::max(1, std::min(desktops_count, desktop));
-    }
-    desktop = std::min(desktops_count, win->control->rules().checkDesktop(desktop));
-
-    QVector<virtual_desktop*> desktops;
-    if (desktop != NET::OnAllDesktops) {
-        desktops << win->space.virtual_desktop_manager->desktopForX11Id(desktop);
-    }
-    set_desktops(win, desktops);
-}
-
-template<typename Win>
-void set_on_all_desktops(Win* win, bool set)
-{
-    if (set == on_all_desktops(win)) {
-        return;
-    }
-
-    if (set) {
-        set_desktop(win, NET::OnAllDesktops);
-    } else {
-        set_desktop(win, win->space.virtual_desktop_manager->current());
-    }
-}
-
-template<typename Win>
-QVector<uint> x11_desktop_ids(Win* win)
-{
-    auto const desks = win->desktops();
-    QVector<uint> x11_ids;
-    x11_ids.reserve(desks.count());
-    std::transform(desks.constBegin(), desks.constEnd(), std::back_inserter(x11_ids), [](auto vd) {
-        return vd->x11DesktopNumber();
-    });
-    return x11_ids;
-}
-
-template<typename Win>
-void enter_desktop(Win* win, virtual_desktop* virtualDesktop)
-{
-    if (win->desktops().contains(virtualDesktop)) {
-        return;
-    }
-    auto desktops = win->desktops();
-    desktops.append(virtualDesktop);
-    set_desktops(win, desktops);
-}
-
-template<typename Win>
-void leave_desktop(Win* win, virtual_desktop* virtualDesktop)
-{
-    QVector<virtual_desktop*> currentDesktops;
-    if (win->desktops().isEmpty()) {
-        currentDesktops = win->space.virtual_desktop_manager->desktops();
-    } else {
-        currentDesktops = win->desktops();
-    }
-
-    if (!currentDesktops.contains(virtualDesktop)) {
-        return;
-    }
-    auto desktops = currentDesktops;
-    desktops.removeOne(virtualDesktop);
-    set_desktops(win, desktops);
-}
-
 }
diff --git a/win/space.cpp b/win/space.cpp
index 00ed4d88e..710f2ce11 100644
--- a/win/space.cpp
+++ b/win/space.cpp
@@ -54,7 +54,6 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "win/screen_edges.h"
 #include "win/setup.h"
 #include "win/shortcut_dialog.h"
-#include "win/space_helpers.h"
 #include "win/stacking.h"
 #include "win/stacking_order.h"
 #include "win/user_actions_menu.h"
diff --git a/win/space_helpers.h b/win/space_helpers.h
deleted file mode 100644
index 55c61d794..000000000
--- a/win/space_helpers.h
+++ /dev/null
@@ -1,61 +0,0 @@
-/*
-    SPDX-FileCopyrightText: 2020 Roman Gilg <subdiff@gmail.com>
-
-    SPDX-License-Identifier: GPL-2.0-or-later
-*/
-#pragma once
-
-#include "meta.h"
-#include "net.h"
-#include "screen.h"
-#include "stacking_order.h"
-#include "transient.h"
-#include "types.h"
-#include "x11/netinfo.h"
-
-namespace KWin::win
-{
-
-template<typename Space>
-void update_client_visibility_on_desktop_change(Space* space, uint newDesktop)
-{
-    for (auto const& toplevel : space->stacking_order->stack) {
-        auto client = qobject_cast<x11::window*>(toplevel);
-        if (!client || !client->control) {
-            continue;
-        }
-
-        if (!client->isOnDesktop(newDesktop) && client != space->moveResizeClient()) {
-            update_visibility(client);
-        }
-    }
-
-    // Now propagate the change, after hiding, before showing.
-    if (x11::rootInfo()) {
-        x11::rootInfo()->setCurrentDesktop(space->virtual_desktop_manager->current());
-    }
-
-    if (auto move_resize_client = space->moveResizeClient()) {
-        if (!move_resize_client->isOnDesktop(newDesktop)) {
-            win::set_desktop(move_resize_client, newDesktop);
-        }
-    }
-
-    auto const& list = space->stacking_order->stack;
-    for (int i = list.size() - 1; i >= 0; --i) {
-        auto client = qobject_cast<x11::window*>(list.at(i));
-        if (!client || !client->control) {
-            continue;
-        }
-        if (client->isOnDesktop(newDesktop)) {
-            update_visibility(client);
-        }
-    }
-
-    if (space->showingDesktop()) {
-        // Do this only after desktop change to avoid flicker.
-        space->setShowingDesktop(false);
-    }
-}
-
-}
diff --git a/win/wayland/subsurface.h b/win/wayland/subsurface.h
index cf4d49719..9a8c90e48 100644
--- a/win/wayland/subsurface.h
+++ b/win/wayland/subsurface.h
@@ -5,13 +5,11 @@
 */
 #pragma once
 
-#include "window.h"
-
 #include "transient.h"
+#include "window.h"
 #include "window_release.h"
 
 #include "render/compositor.h"
-#include "win/space_helpers.h"
 #include "win/transient.h"
 
 #include <Wrapland/Server/subcompositor.h>
diff --git a/win/wayland/window_release.h b/win/wayland/window_release.h
index 87e3a0517..324676dfe 100644
--- a/win/wayland/window_release.h
+++ b/win/wayland/window_release.h
@@ -12,7 +12,6 @@
 #include "rules/rule_book.h"
 #include "utils/blocker.h"
 #include "win/remnant.h"
-#include "win/space_helpers.h"
 #include "win/stacking_order.h"
 #include "win/transient.h"
 #include "win/window_release.h"
diff --git a/win/window_release.h b/win/window_release.h
index 6eead8cc7..de2ce81e0 100644
--- a/win/window_release.h
+++ b/win/window_release.h
@@ -5,9 +5,11 @@
 */
 #pragma once
 
+#include "geo.h"
 #include "remnant.h"
-#include "space_helpers.h"
 #include "space_window_release.h"
+#include "x11/netinfo.h"
+
 #include "toplevel.h"
 
 namespace KWin::win
diff --git a/win/x11/geo.h b/win/x11/geo.h
index b347fb9ab..6011e7030 100644
--- a/win/x11/geo.h
+++ b/win/x11/geo.h
@@ -8,7 +8,6 @@
 #include "scene.h"
 
 #include "win/setup.h"
-#include "win/space_helpers.h"
 
 #include <xcb/xcb_icccm.h>
 
diff --git a/win/x11/unmanaged.h b/win/x11/unmanaged.h
index f761668c2..5bc012198 100644
--- a/win/x11/unmanaged.h
+++ b/win/x11/unmanaged.h
@@ -12,7 +12,6 @@
 #include "base/x11/xcb/proto.h"
 #include "render/effects.h"
 #include "win/remnant.h"
-#include "win/space_helpers.h"
 
 namespace KWin::win::x11
 {
diff --git a/win/x11/window_release.h b/win/x11/window_release.h
index 97a020ffd..93181e840 100644
--- a/win/x11/window_release.h
+++ b/win/x11/window_release.h
@@ -11,7 +11,6 @@
 #include "win/input.h"
 #include "win/rules.h"
 #include "win/space_areas_helpers.h"
-#include "win/space_helpers.h"
 #include "win/window_release.h"
 
 #if KWIN_BUILD_TABBOX
-- 
GitLab


From 9064cd57546ccb94af46db816e13f62c003831b9 Mon Sep 17 00:00:00 2001
From: Roman Gilg <subdiff@gmail.com>
Date: Wed, 6 Jul 2022 00:50:53 +0200
Subject: [PATCH 09/51] refactor: split geo functions into multiple headers

This reduces the risk of issues due to cyclic inclusions.
---
 autotests/integration/lib/helpers.h           |   7 +-
 autotests/integration/scene_qpainter_test.cpp |   7 +-
 input/filters/decoration_event.cpp            |   1 +
 input/filters/internal_window.cpp             |   1 +
 input/filters/popup.cpp                       |   1 +
 input/redirect.cpp                            |   1 +
 input/wayland/device_redirect.h               |   1 +
 render/buffer.cpp                             |   2 +-
 render/deco_shadow.h                          |   1 +
 render/gl/window.cpp                          |   3 +
 render/qpainter/window.cpp                    |   1 +
 render/scene.cpp                              |   3 +
 render/shadow.cpp                             |   1 +
 render/wayland/presentation.cpp               |   1 +
 render/xrender/window.cpp                     |   1 +
 rules/window_rules.cpp                        |   1 +
 win/control.cpp                               |   1 +
 win/deco.h                                    |   2 -
 win/geo.h                                     | 254 +-----------------
 win/geo_block.h                               |  45 ++++
 win/geo_change.h                              | 154 +++++++++++
 win/geo_electric.h                            |  89 ++++++
 win/move.h                                    |   4 +-
 win/placement.h                               |   4 +-
 win/screen_edges.cpp                          |   2 +
 win/transient.cpp                             |   4 +-
 26 files changed, 323 insertions(+), 269 deletions(-)
 create mode 100644 win/geo_block.h
 create mode 100644 win/geo_change.h
 create mode 100644 win/geo_electric.h

diff --git a/autotests/integration/lib/helpers.h b/autotests/integration/lib/helpers.h
index d0a5cf8f5..21a8b009c 100644
--- a/autotests/integration/lib/helpers.h
+++ b/autotests/integration/lib/helpers.h
@@ -11,6 +11,7 @@
 #include "base/output.h"
 #include "base/wayland/server.h"
 #include "main.h"
+#include "win/wayland/window.h"
 
 #include <QtTest>
 #include <Wrapland/Client/xdg_shell.h>
@@ -30,12 +31,8 @@ class Surface;
 
 namespace KWin
 {
-class WaylandTestApplication;
 
-namespace win::wayland
-{
-class window;
-}
+class WaylandTestApplication;
 
 class Toplevel;
 
diff --git a/autotests/integration/scene_qpainter_test.cpp b/autotests/integration/scene_qpainter_test.cpp
index 2e408c70e..7133562a7 100644
--- a/autotests/integration/scene_qpainter_test.cpp
+++ b/autotests/integration/scene_qpainter_test.cpp
@@ -28,16 +28,15 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "win/space.h"
 #include "win/x11/window.h"
 
-#include <KConfigGroup>
+#include <kwineffects/effects_handler.h>
 
+#include <KConfigGroup>
+#include <QPainter>
 #include <Wrapland/Client/pointer.h>
 #include <Wrapland/Client/seat.h>
 #include <Wrapland/Client/surface.h>
 #include <Wrapland/Server/buffer.h>
 #include <Wrapland/Server/surface.h>
-
-#include <QPainter>
-
 #include <netwm.h>
 #include <xcb/xcb_icccm.h>
 
diff --git a/input/filters/decoration_event.cpp b/input/filters/decoration_event.cpp
index 770aa4c45..8c2c1ecb4 100644
--- a/input/filters/decoration_event.cpp
+++ b/input/filters/decoration_event.cpp
@@ -19,6 +19,7 @@
 #include "win/deco.h"
 #include "win/input.h"
 
+#include <Wrapland/Server/seat.h>
 #include <Wrapland/Server/touch_pool.h>
 
 namespace KWin::input
diff --git a/input/filters/internal_window.cpp b/input/filters/internal_window.cpp
index a0e56dfb9..7425b09b0 100644
--- a/input/filters/internal_window.cpp
+++ b/input/filters/internal_window.cpp
@@ -22,6 +22,7 @@
 #include "win/space.h"
 
 #include <QWindow>
+#include <Wrapland/Server/seat.h>
 #include <Wrapland/Server/touch_pool.h>
 
 namespace KWin::input
diff --git a/input/filters/popup.cpp b/input/filters/popup.cpp
index 0e2c7246c..db40323f5 100644
--- a/input/filters/popup.cpp
+++ b/input/filters/popup.cpp
@@ -11,6 +11,7 @@
 #include "base/wayland/server.h"
 #include "input/event.h"
 #include "input/redirect.h"
+#include "main.h"
 #include "win/deco.h"
 #include "win/geo.h"
 #include "win/transient.h"
diff --git a/input/redirect.cpp b/input/redirect.cpp
index 4b51a7252..16166b858 100644
--- a/input/redirect.cpp
+++ b/input/redirect.cpp
@@ -18,6 +18,7 @@
 #include "touch_redirect.h"
 
 #include "main.h"
+#include "render/compositor.h"
 #include "render/effects.h"
 #include "render/platform.h"
 #include "toplevel.h"
diff --git a/input/wayland/device_redirect.h b/input/wayland/device_redirect.h
index dab34777d..4833c094e 100644
--- a/input/wayland/device_redirect.h
+++ b/input/wayland/device_redirect.h
@@ -9,6 +9,7 @@
 #pragma once
 
 #include "input/redirect.h"
+#include "main.h"
 #include "toplevel.h"
 #include "win/geo.h"
 #include "win/internal_window.h"
diff --git a/render/buffer.cpp b/render/buffer.cpp
index 6e835e69a..956dc4e3f 100644
--- a/render/buffer.cpp
+++ b/render/buffer.cpp
@@ -7,7 +7,7 @@
 #include "buffer.h"
 
 #include "base/logging.h"
-
+#include "render/window.h"
 #include "toplevel.h"
 #include "win/geo.h"
 
diff --git a/render/deco_shadow.h b/render/deco_shadow.h
index 59c8b3be0..e0ce23074 100644
--- a/render/deco_shadow.h
+++ b/render/deco_shadow.h
@@ -12,6 +12,7 @@
 
 #include "win/deco.h"
 #include "win/scene.h"
+#include "win/space.h"
 
 #include <KDecoration2/Decoration>
 #include <KDecoration2/DecorationShadow>
diff --git a/render/gl/window.cpp b/render/gl/window.cpp
index 9388c2d67..4fc921cc9 100644
--- a/render/gl/window.cpp
+++ b/render/gl/window.cpp
@@ -14,6 +14,9 @@
 #include "shadow.h"
 #include "texture.h"
 
+#include "main.h"
+#include "toplevel.h"
+#include "utils/algorithm.h"
 #include "win/geo.h"
 
 #include <cmath>
diff --git a/render/qpainter/window.cpp b/render/qpainter/window.cpp
index 08b076142..8d3708ae2 100644
--- a/render/qpainter/window.cpp
+++ b/render/qpainter/window.cpp
@@ -12,6 +12,7 @@
 #include "shadow.h"
 
 #include "win/geo.h"
+#include "win/scene.h"
 #include "win/x11/window.h"
 
 #include <QPainter>
diff --git a/render/scene.cpp b/render/scene.cpp
index da253f390..411fd1b1f 100644
--- a/render/scene.cpp
+++ b/render/scene.cpp
@@ -67,6 +67,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
 #include "scene.h"
 
+#include "compositor.h"
 #include "effects.h"
 #include "shadow.h"
 #include "thumbnail_item.h"
@@ -75,7 +76,9 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "base/logging.h"
 #include "base/output.h"
 #include "base/platform.h"
+#include "main.h"
 #include "win/geo.h"
+#include "win/scene.h"
 
 #include <kwineffects/paint_clipper.h>
 
diff --git a/render/shadow.cpp b/render/shadow.cpp
index a8ea34ee7..36682ec0b 100644
--- a/render/shadow.cpp
+++ b/render/shadow.cpp
@@ -24,6 +24,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "effects.h"
 
 #include "toplevel.h"
+#include "utils/algorithm.h"
 #include "win/deco.h"
 #include "win/scene.h"
 
diff --git a/render/wayland/presentation.cpp b/render/wayland/presentation.cpp
index 2af41acb8..65c24bea7 100644
--- a/render/wayland/presentation.cpp
+++ b/render/wayland/presentation.cpp
@@ -15,6 +15,7 @@
 #include "wayland_logging.h"
 
 #include <QElapsedTimer>
+#include <Wrapland/Server/display.h>
 #include <Wrapland/Server/output.h>
 #include <Wrapland/Server/presentation_time.h>
 #include <Wrapland/Server/surface.h>
diff --git a/render/xrender/window.cpp b/render/xrender/window.cpp
index 3047c0bbc..1baec8426 100644
--- a/render/xrender/window.cpp
+++ b/render/xrender/window.cpp
@@ -13,6 +13,7 @@
 #include "shadow.h"
 
 #include "win/geo.h"
+#include "win/scene.h"
 #include "win/x11/window.h"
 
 #include <kwineffects/paint_clipper.h>
diff --git a/rules/window_rules.cpp b/rules/window_rules.cpp
index ceda0304b..53f529719 100644
--- a/rules/window_rules.cpp
+++ b/rules/window_rules.cpp
@@ -10,6 +10,7 @@
 
 #ifndef KCMRULES
 #include "win/controlling.h"
+#include "win/geo_change.h"
 #include "win/input.h"
 #include "win/meta.h"
 #include "win/rules.h"
diff --git a/win/control.cpp b/win/control.cpp
index 2850ff53e..a6e7b9971 100644
--- a/win/control.cpp
+++ b/win/control.cpp
@@ -17,6 +17,7 @@
 #include "tabbox/tabbox.h"
 #endif
 
+#include "render/compositor.h"
 #include "render/effects.h"
 #include "toplevel.h"
 
diff --git a/win/deco.h b/win/deco.h
index 3e7caeb49..5b56864c2 100644
--- a/win/deco.h
+++ b/win/deco.h
@@ -6,9 +6,7 @@
 #pragma once
 
 #include "control.h"
-#include "space.h"
 #include "structs.h"
-#include "wayland/window.h"
 
 #include <KDecoration2/Decoration>
 #include <QObject>
diff --git a/win/geo.h b/win/geo.h
index 29491ae9b..555bfdf49 100644
--- a/win/geo.h
+++ b/win/geo.h
@@ -6,14 +6,9 @@
 #pragma once
 
 #include "deco.h"
-#include "remnant.h"
-#include "scene.h"
-#include "shadow.h"
-#include "space.h"
 #include "types.h"
 
-#include "render/outline.h"
-
+#include <QMargins>
 #include <QRect>
 
 namespace KWin::win
@@ -160,251 +155,4 @@ QSize adjusted_frame_size(Win* win, QSize const& frame_size, size_mode mode)
     return win->control->adjusted_frame_size(frame_size, mode);
 }
 
-template<typename Win>
-QSize constrain_and_adjust_size(Win* win, QSize const& size)
-{
-    auto width = size.width();
-    auto height = size.height();
-
-    auto const area = win->space.clientArea(WorkArea, win);
-
-    width = std::min(width, area.width());
-    height = std::min(height, area.height());
-
-    // checks size constraints, including min/max size
-    return adjusted_frame_size(win, QSize(width, height), win::size_mode::any);
-}
-
-template<typename Win>
-void constrained_resize(Win* win, QSize const& size)
-{
-    win->setFrameGeometry(
-        QRect(win->geometry_update.frame.topLeft(), constrain_and_adjust_size(win, size)));
-}
-
-template<typename Win>
-void grow_horizontal(Win* win)
-{
-    if (!win->isResizable()) {
-        return;
-    }
-
-    auto frame_geo = win->frameGeometry();
-    frame_geo.setRight(win->space.packPositionRight(win, frame_geo.right(), true));
-    auto const adjsize = adjusted_frame_size(win, frame_geo.size(), size_mode::fixed_width);
-
-    if (win->frameGeometry().size() == adjsize && frame_geo.size() != adjsize
-        && win->resizeIncrements().width() > 1) {
-        // Grow by increment.
-        auto const grown_right = win->space.packPositionRight(
-            win, frame_geo.right() + win->resizeIncrements().width() - 1, true);
-
-        // Check that it hasn't grown outside of the area, due to size increments.
-        // TODO this may be wrong?
-        auto const area = win->space.clientArea(
-            MovementArea,
-            QPoint((win->pos().x() + grown_right) / 2, win->frameGeometry().center().y()),
-            win->desktop());
-        if (area.right() >= grown_right) {
-            frame_geo.setRight(grown_right);
-        }
-    }
-
-    frame_geo.setSize(adjusted_frame_size(win, frame_geo.size(), size_mode::fixed_width));
-    frame_geo.setSize(adjusted_frame_size(win, frame_geo.size(), size_mode::fixed_height));
-
-    // May cause leave event.
-    win->space.focusMousePos = input::get_cursor()->pos();
-    win->setFrameGeometry(frame_geo);
-}
-
-template<typename Win>
-void shrink_horizontal(Win* win)
-{
-    if (!win->isResizable()) {
-        return;
-    }
-
-    auto geom = win->frameGeometry();
-    geom.setRight(win->space.packPositionLeft(win, geom.right(), false));
-
-    if (geom.width() <= 1) {
-        return;
-    }
-
-    geom.setSize(adjusted_frame_size(win, geom.size(), size_mode::fixed_width));
-
-    // TODO(romangg): Magic number 20. Why?
-    if (geom.width() > 20) {
-        // May cause leave event.
-        win->space.focusMousePos = input::get_cursor()->pos();
-        win->setFrameGeometry(geom);
-    }
-}
-
-template<typename Win>
-void grow_vertical(Win* win)
-{
-    if (!win->isResizable()) {
-        return;
-    }
-
-    auto frame_geo = win->frameGeometry();
-    frame_geo.setBottom(win->space.packPositionDown(win, frame_geo.bottom(), true));
-    auto adjsize = adjusted_frame_size(win, frame_geo.size(), size_mode::fixed_height);
-
-    if (win->frameGeometry().size() == adjsize && frame_geo.size() != adjsize
-        && win->resizeIncrements().height() > 1) {
-        // Grow by increment.
-        auto const newbottom = win->space.packPositionDown(
-            win, frame_geo.bottom() + win->resizeIncrements().height() - 1, true);
-
-        // check that it hasn't grown outside of the area, due to size increments
-        auto const area = win->space.clientArea(
-            MovementArea,
-            QPoint(win->frameGeometry().center().x(), (win->pos().y() + newbottom) / 2),
-            win->desktop());
-        if (area.bottom() >= newbottom) {
-            frame_geo.setBottom(newbottom);
-        }
-    }
-
-    frame_geo.setSize(adjusted_frame_size(win, frame_geo.size(), size_mode::fixed_height));
-
-    // May cause leave event.
-    win->space.focusMousePos = input::get_cursor()->pos();
-    win->setFrameGeometry(frame_geo);
-}
-
-template<typename Win>
-void shrink_vertical(Win* win)
-{
-    if (!win->isResizable()) {
-        return;
-    }
-
-    auto frame_geo = win->frameGeometry();
-    frame_geo.setBottom(win->space.packPositionUp(win, frame_geo.bottom(), false));
-    if (frame_geo.height() <= 1) {
-        return;
-    }
-
-    frame_geo.setSize(adjusted_frame_size(win, frame_geo.size(), size_mode::fixed_height));
-
-    // TODO(romangg): Magic number 20. Why?
-    if (frame_geo.height() > 20) {
-        // May cause leave event.
-        win->space.focusMousePos = input::get_cursor()->pos();
-        win->setFrameGeometry(frame_geo);
-    }
-}
-
-template<typename Win>
-void block_geometry_updates(Win* win, bool block)
-{
-    if (block) {
-        win->geometry_update.block++;
-        return;
-    }
-
-    win->geometry_update.block--;
-    if (!win->geometry_update.block && win->geometry_update.pending != pending_geometry::none) {
-        win->setFrameGeometry(win->geometry_update.frame);
-    }
-}
-
-template<typename Win>
-class geometry_updates_blocker
-{
-public:
-    explicit geometry_updates_blocker(Win* c)
-        : cl(c)
-    {
-        block_geometry_updates(cl, true);
-    }
-    ~geometry_updates_blocker()
-    {
-        block_geometry_updates(cl, false);
-    }
-
-private:
-    Win* cl;
-};
-
-template<typename Win>
-QRect electric_border_maximize_geometry(Win const* win, QPoint pos, int desktop)
-{
-    if (win->control->electric() == win::quicktiles::maximize) {
-        if (win->maximizeMode() == maximize_mode::full) {
-            return win->restore_geometries.maximize;
-        } else {
-            return win->space.clientArea(MaximizeArea, pos, desktop);
-        }
-    }
-
-    auto ret = win->space.clientArea(MaximizeArea, pos, desktop);
-
-    if (flags(win->control->electric() & win::quicktiles::left)) {
-        ret.setRight(ret.left() + ret.width() / 2 - 1);
-    } else if (flags(win->control->electric() & win::quicktiles::right)) {
-        ret.setLeft(ret.right() - (ret.width() - ret.width() / 2) + 1);
-    }
-
-    if (flags(win->control->electric() & win::quicktiles::top)) {
-        ret.setBottom(ret.top() + ret.height() / 2 - 1);
-    } else if (flags(win->control->electric() & win::quicktiles::bottom)) {
-        ret.setTop(ret.bottom() - (ret.height() - ret.height() / 2) + 1);
-    }
-
-    return ret;
-}
-
-template<typename Win>
-void set_electric_maximizing(Win* win, bool maximizing)
-{
-    win->control->set_electric_maximizing(maximizing);
-
-    if (maximizing) {
-        win->space.outline->show(
-            electric_border_maximize_geometry(win, input::get_cursor()->pos(), win->desktop()),
-            win->control->move_resize().geometry);
-    } else {
-        win->space.outline->hide();
-    }
-
-    elevate(win, maximizing);
-}
-
-template<typename Win>
-void delayed_electric_maximize(Win* win)
-{
-    auto timer = win->control->electric_maximizing_timer();
-    if (!timer) {
-        timer = new QTimer(win);
-        timer->setInterval(250);
-        timer->setSingleShot(true);
-        QObject::connect(timer, &QTimer::timeout, [win]() {
-            if (is_move(win)) {
-                set_electric_maximizing(win, win->control->electric() != quicktiles::none);
-            }
-        });
-    }
-    timer->start();
-}
-
-template<typename Win>
-void set_electric(Win* win, quicktiles tiles)
-{
-    if (tiles != quicktiles::maximize) {
-        // sanitize the mode, ie. simplify "invalid" combinations
-        if ((tiles & quicktiles::horizontal) == quicktiles::horizontal) {
-            tiles &= ~quicktiles::horizontal;
-        }
-        if ((tiles & quicktiles::vertical) == quicktiles::vertical) {
-            tiles &= ~quicktiles::vertical;
-        }
-    }
-    win->control->set_electric(tiles);
-}
-
 }
diff --git a/win/geo_block.h b/win/geo_block.h
new file mode 100644
index 000000000..40fbd7b04
--- /dev/null
+++ b/win/geo_block.h
@@ -0,0 +1,45 @@
+/*
+    SPDX-FileCopyrightText: 2022 Roman Gilg <subdiff@gmail.com>
+
+    SPDX-License-Identifier: GPL-2.0-or-later
+*/
+#pragma once
+
+#include "types.h"
+
+namespace KWin::win
+{
+
+template<typename Win>
+void block_geometry_updates(Win* win, bool block)
+{
+    if (block) {
+        win->geometry_update.block++;
+        return;
+    }
+
+    win->geometry_update.block--;
+    if (!win->geometry_update.block && win->geometry_update.pending != pending_geometry::none) {
+        win->setFrameGeometry(win->geometry_update.frame);
+    }
+}
+
+template<typename Win>
+class geometry_updates_blocker
+{
+public:
+    explicit geometry_updates_blocker(Win* c)
+        : cl(c)
+    {
+        block_geometry_updates(cl, true);
+    }
+    ~geometry_updates_blocker()
+    {
+        block_geometry_updates(cl, false);
+    }
+
+private:
+    Win* cl;
+};
+
+}
diff --git a/win/geo_change.h b/win/geo_change.h
new file mode 100644
index 000000000..3a62350a3
--- /dev/null
+++ b/win/geo_change.h
@@ -0,0 +1,154 @@
+/*
+    SPDX-FileCopyrightText: 2020 Roman Gilg <subdiff@gmail.com>
+
+    SPDX-License-Identifier: GPL-2.0-or-later
+*/
+#pragma once
+
+#include "geo.h"
+#include "scene.h"
+#include "types.h"
+
+namespace KWin::win
+{
+
+template<typename Win>
+QSize constrain_and_adjust_size(Win* win, QSize const& size)
+{
+    auto width = size.width();
+    auto height = size.height();
+
+    auto const area = win->space.clientArea(WorkArea, win);
+
+    width = std::min(width, area.width());
+    height = std::min(height, area.height());
+
+    // checks size constraints, including min/max size
+    return adjusted_frame_size(win, QSize(width, height), win::size_mode::any);
+}
+
+template<typename Win>
+void constrained_resize(Win* win, QSize const& size)
+{
+    win->setFrameGeometry(
+        QRect(win->geometry_update.frame.topLeft(), constrain_and_adjust_size(win, size)));
+}
+
+template<typename Win>
+void grow_horizontal(Win* win)
+{
+    if (!win->isResizable()) {
+        return;
+    }
+
+    auto frame_geo = win->frameGeometry();
+    frame_geo.setRight(win->space.packPositionRight(win, frame_geo.right(), true));
+    auto const adjsize = adjusted_frame_size(win, frame_geo.size(), size_mode::fixed_width);
+
+    if (win->frameGeometry().size() == adjsize && frame_geo.size() != adjsize
+        && win->resizeIncrements().width() > 1) {
+        // Grow by increment.
+        auto const grown_right = win->space.packPositionRight(
+            win, frame_geo.right() + win->resizeIncrements().width() - 1, true);
+
+        // Check that it hasn't grown outside of the area, due to size increments.
+        // TODO this may be wrong?
+        auto const area = win->space.clientArea(
+            MovementArea,
+            QPoint((win->pos().x() + grown_right) / 2, win->frameGeometry().center().y()),
+            win->desktop());
+        if (area.right() >= grown_right) {
+            frame_geo.setRight(grown_right);
+        }
+    }
+
+    frame_geo.setSize(adjusted_frame_size(win, frame_geo.size(), size_mode::fixed_width));
+    frame_geo.setSize(adjusted_frame_size(win, frame_geo.size(), size_mode::fixed_height));
+
+    // May cause leave event.
+    win->space.focusMousePos = input::get_cursor()->pos();
+    win->setFrameGeometry(frame_geo);
+}
+
+template<typename Win>
+void shrink_horizontal(Win* win)
+{
+    if (!win->isResizable()) {
+        return;
+    }
+
+    auto geom = win->frameGeometry();
+    geom.setRight(win->space.packPositionLeft(win, geom.right(), false));
+
+    if (geom.width() <= 1) {
+        return;
+    }
+
+    geom.setSize(adjusted_frame_size(win, geom.size(), size_mode::fixed_width));
+
+    // TODO(romangg): Magic number 20. Why?
+    if (geom.width() > 20) {
+        // May cause leave event.
+        win->space.focusMousePos = input::get_cursor()->pos();
+        win->setFrameGeometry(geom);
+    }
+}
+
+template<typename Win>
+void grow_vertical(Win* win)
+{
+    if (!win->isResizable()) {
+        return;
+    }
+
+    auto frame_geo = win->frameGeometry();
+    frame_geo.setBottom(win->space.packPositionDown(win, frame_geo.bottom(), true));
+    auto adjsize = adjusted_frame_size(win, frame_geo.size(), size_mode::fixed_height);
+
+    if (win->frameGeometry().size() == adjsize && frame_geo.size() != adjsize
+        && win->resizeIncrements().height() > 1) {
+        // Grow by increment.
+        auto const newbottom = win->space.packPositionDown(
+            win, frame_geo.bottom() + win->resizeIncrements().height() - 1, true);
+
+        // check that it hasn't grown outside of the area, due to size increments
+        auto const area = win->space.clientArea(
+            MovementArea,
+            QPoint(win->frameGeometry().center().x(), (win->pos().y() + newbottom) / 2),
+            win->desktop());
+        if (area.bottom() >= newbottom) {
+            frame_geo.setBottom(newbottom);
+        }
+    }
+
+    frame_geo.setSize(adjusted_frame_size(win, frame_geo.size(), size_mode::fixed_height));
+
+    // May cause leave event.
+    win->space.focusMousePos = input::get_cursor()->pos();
+    win->setFrameGeometry(frame_geo);
+}
+
+template<typename Win>
+void shrink_vertical(Win* win)
+{
+    if (!win->isResizable()) {
+        return;
+    }
+
+    auto frame_geo = win->frameGeometry();
+    frame_geo.setBottom(win->space.packPositionUp(win, frame_geo.bottom(), false));
+    if (frame_geo.height() <= 1) {
+        return;
+    }
+
+    frame_geo.setSize(adjusted_frame_size(win, frame_geo.size(), size_mode::fixed_height));
+
+    // TODO(romangg): Magic number 20. Why?
+    if (frame_geo.height() > 20) {
+        // May cause leave event.
+        win->space.focusMousePos = input::get_cursor()->pos();
+        win->setFrameGeometry(frame_geo);
+    }
+}
+
+}
diff --git a/win/geo_electric.h b/win/geo_electric.h
new file mode 100644
index 000000000..d369f8689
--- /dev/null
+++ b/win/geo_electric.h
@@ -0,0 +1,89 @@
+/*
+    SPDX-FileCopyrightText: 2020 Roman Gilg <subdiff@gmail.com>
+
+    SPDX-License-Identifier: GPL-2.0-or-later
+*/
+#pragma once
+
+#include "types.h"
+
+namespace KWin::win
+{
+
+template<typename Win>
+QRect electric_border_maximize_geometry(Win const* win, QPoint pos, int desktop)
+{
+    if (win->control->electric() == win::quicktiles::maximize) {
+        if (win->maximizeMode() == maximize_mode::full) {
+            return win->restore_geometries.maximize;
+        } else {
+            return win->space.clientArea(MaximizeArea, pos, desktop);
+        }
+    }
+
+    auto ret = win->space.clientArea(MaximizeArea, pos, desktop);
+
+    if (flags(win->control->electric() & win::quicktiles::left)) {
+        ret.setRight(ret.left() + ret.width() / 2 - 1);
+    } else if (flags(win->control->electric() & win::quicktiles::right)) {
+        ret.setLeft(ret.right() - (ret.width() - ret.width() / 2) + 1);
+    }
+
+    if (flags(win->control->electric() & win::quicktiles::top)) {
+        ret.setBottom(ret.top() + ret.height() / 2 - 1);
+    } else if (flags(win->control->electric() & win::quicktiles::bottom)) {
+        ret.setTop(ret.bottom() - (ret.height() - ret.height() / 2) + 1);
+    }
+
+    return ret;
+}
+
+template<typename Win>
+void set_electric_maximizing(Win* win, bool maximizing)
+{
+    win->control->set_electric_maximizing(maximizing);
+
+    if (maximizing) {
+        win->space.outline->show(
+            electric_border_maximize_geometry(win, input::get_cursor()->pos(), win->desktop()),
+            win->control->move_resize().geometry);
+    } else {
+        win->space.outline->hide();
+    }
+
+    elevate(win, maximizing);
+}
+
+template<typename Win>
+void delayed_electric_maximize(Win* win)
+{
+    auto timer = win->control->electric_maximizing_timer();
+    if (!timer) {
+        timer = new QTimer(win);
+        timer->setInterval(250);
+        timer->setSingleShot(true);
+        QObject::connect(timer, &QTimer::timeout, [win]() {
+            if (is_move(win)) {
+                set_electric_maximizing(win, win->control->electric() != quicktiles::none);
+            }
+        });
+    }
+    timer->start();
+}
+
+template<typename Win>
+void set_electric(Win* win, quicktiles tiles)
+{
+    if (tiles != quicktiles::maximize) {
+        // sanitize the mode, ie. simplify "invalid" combinations
+        if ((tiles & quicktiles::horizontal) == quicktiles::horizontal) {
+            tiles &= ~quicktiles::horizontal;
+        }
+        if ((tiles & quicktiles::vertical) == quicktiles::vertical) {
+            tiles &= ~quicktiles::vertical;
+        }
+    }
+    win->control->set_electric(tiles);
+}
+
+}
diff --git a/win/move.h b/win/move.h
index c565eac29..8f4b6c85f 100644
--- a/win/move.h
+++ b/win/move.h
@@ -6,7 +6,9 @@
 #pragma once
 
 #include "deco.h"
-#include "geo.h"
+#include "geo_block.h"
+#include "geo_change.h"
+#include "geo_electric.h"
 #include "net.h"
 #include "space.h"
 #include "stacking.h"
diff --git a/win/placement.h b/win/placement.h
index 83d9515cb..523b9e8e9 100644
--- a/win/placement.h
+++ b/win/placement.h
@@ -26,10 +26,10 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #ifndef KCMRULES
 #include "base/options.h"
 #include "input/cursor.h"
+#include "kwinglobals.h"
 #include "rules/rules.h"
 
-#include "geo.h"
-#include "kwinglobals.h"
+#include "geo_change.h"
 #include "meta.h"
 #include "move.h"
 #include "net.h"
diff --git a/win/screen_edges.cpp b/win/screen_edges.cpp
index f0b99967b..17275c2ad 100644
--- a/win/screen_edges.cpp
+++ b/win/screen_edges.cpp
@@ -16,6 +16,8 @@
 #include "input/cursor.h"
 #include "input/gestures.h"
 #include "main.h"
+#include "render/compositor.h"
+#include "render/effects.h"
 
 // DBus generated
 #include "screenlocker_interface.h"
diff --git a/win/transient.cpp b/win/transient.cpp
index 5990d06b7..2d4c3407d 100644
--- a/win/transient.cpp
+++ b/win/transient.cpp
@@ -5,10 +5,12 @@
 */
 #include "transient.h"
 
-#include "geo.h"
 #include "remnant.h"
+#include "scene.h"
 #include "toplevel.h"
 
+#include "utils/algorithm.h"
+
 #include <cassert>
 
 namespace KWin::win
-- 
GitLab


From b00a7bc6d5211d78425c16177a40fdfd9845e9f3 Mon Sep 17 00:00:00 2001
From: Roman Gilg <subdiff@gmail.com>
Date: Wed, 6 Jul 2022 01:51:20 +0200
Subject: [PATCH 10/51] refactor: consolidate free focus chain functions

Move the functions into two separate headers only about focus chain handling.
In particular this minimizes the screen header.
---
 autotests/integration/layer_shell.cpp         |   2 +
 win/activation.h                              |   4 +
 win/controlling.h                             |  66 +----------
 win/desktop_set.h                             |   5 +
 ...cus_chain_helpers.h => focus_chain_edit.h} |  63 +++++++++++
 win/focus_chain_find.h                        | 105 ++++++++++++++++++
 win/screen.h                                  | 104 +----------------
 win/stacking.h                                |   4 +-
 8 files changed, 184 insertions(+), 169 deletions(-)
 rename win/{focus_chain_helpers.h => focus_chain_edit.h} (68%)
 create mode 100644 win/focus_chain_find.h

diff --git a/autotests/integration/layer_shell.cpp b/autotests/integration/layer_shell.cpp
index 4839b9191..c57136101 100644
--- a/autotests/integration/layer_shell.cpp
+++ b/autotests/integration/layer_shell.cpp
@@ -6,6 +6,8 @@
 #include "lib/app.h"
 
 #include "base/wayland/server.h"
+#include "render/effects.h"
+#include "render/window.h"
 #include "win/screen.h"
 #include "win/wayland/space.h"
 #include "win/wayland/window.h"
diff --git a/win/activation.h b/win/activation.h
index 4eeb8cccb..3ac9d69d0 100644
--- a/win/activation.h
+++ b/win/activation.h
@@ -7,11 +7,15 @@
 
 #include "actions.h"
 #include "desktop_set.h"
+#include "focus_chain_find.h"
 #include "layers.h"
 #include "screen.h"
+#include "stacking.h"
 #include "stacking_order.h"
 #include "user_actions_menu.h"
 #include "window_find.h"
+#include "x11/netinfo.h"
+#include "x11/tool_windows.h"
 #include "x11/user_time.h"
 
 #include "utils/blocker.h"
diff --git a/win/controlling.h b/win/controlling.h
index 4900efcf8..a2aeb2cf7 100644
--- a/win/controlling.h
+++ b/win/controlling.h
@@ -6,8 +6,7 @@
 #pragma once
 
 #include "control.h"
-#include "focus_chain.h"
-#include "focus_chain_helpers.h"
+#include "focus_chain_edit.h"
 #include "net.h"
 
 #include "rules/rules.h"
@@ -15,69 +14,6 @@
 namespace KWin::win
 {
 
-/**
- * @brief Updates the position of the @p window according to the requested @p change in the
- * focus chain.
- *
- * This method affects both the most recently used focus chain and the per virtual desktop focus
- * chain.
- *
- * In case the client does no longer want to get focus, it is removed from all chains. In case
- * the client is on all virtual desktops it is ensured that it is present in each of the virtual
- * desktops focus chain. In case it's on exactly one virtual desktop it is ensured that it is
- * only in the focus chain for that virtual desktop.
- *
- * Depending on @p change the window is inserted at different positions in the focus chain. In
- * case of @c focus_chain_change::make_first it is moved to the first position of the chain, in case
- * of @c focus_chain_change::make_last it is moved to the last position of the chain. In all other
- * cases it depends on whether the @p window is the currently active window. If it is the active
- * window it becomes the first Client in the chain, otherwise it is inserted at the second position
- * that is directly after the currently active window.
- *
- * @param window The window which should be moved inside the chains.
- * @param change Where to move the window
- */
-template<typename Manager, typename Win>
-void focus_chain_update(Manager& manager, Win* window, focus_chain_change change)
-{
-    if (!wants_tab_focus(window)) {
-        // Doesn't want tab focus, remove.
-        focus_chain_remove(manager, window);
-        return;
-    }
-
-    if (window->isOnAllDesktops()) {
-        // Now on all desktops, add it to focus chains it is not already in.
-        for (auto& [key, chain] : manager.chains.desktops) {
-            // Making first/last works only on current desktop, don't affect all desktops
-            if (key == manager.current_desktop
-                && (change == focus_chain_change::make_first
-                    || change == focus_chain_change::make_last)) {
-                if (change == focus_chain_change::make_first) {
-                    focus_chain_make_first_in_chain(window, chain);
-                } else {
-                    focus_chain_make_last_in_chain(window, chain);
-                }
-            } else {
-                focus_chain_insert_window_into_chain(window, chain, manager.active_window);
-            }
-        }
-    } else {
-        // Now only on desktop, remove it anywhere else
-        for (auto& [key, chain] : manager.chains.desktops) {
-            if (window->isOnDesktop(key)) {
-                focus_chain_update_window_in_chain(window, change, chain, manager.active_window);
-            } else {
-                remove_all(chain, window);
-            }
-        }
-    }
-
-    // add for most recently used chain
-    focus_chain_update_window_in_chain(
-        window, change, manager.chains.latest_use, manager.active_window);
-}
-
 template<typename Win>
 void set_skip_pager(Win* win, bool set)
 {
diff --git a/win/desktop_set.h b/win/desktop_set.h
index f157356b2..f9c56b41c 100644
--- a/win/desktop_set.h
+++ b/win/desktop_set.h
@@ -6,9 +6,14 @@
 #pragma once
 
 #include "desktop_get.h"
+#include "focus_chain_edit.h"
+#include "stacking.h"
+#include "transient.h"
 
 #include "main.h"
 
+#include <Wrapland/Server/plasma_window.h>
+
 namespace KWin::win
 {
 
diff --git a/win/focus_chain_helpers.h b/win/focus_chain_edit.h
similarity index 68%
rename from win/focus_chain_helpers.h
rename to win/focus_chain_edit.h
index c02c1ba6e..8068f0210 100644
--- a/win/focus_chain_helpers.h
+++ b/win/focus_chain_edit.h
@@ -104,6 +104,69 @@ void focus_chain_update_window_in_chain(Win* window,
     }
 }
 
+/**
+ * @brief Updates the position of the @p window according to the requested @p change in the
+ * focus chain.
+ *
+ * This method affects both the most recently used focus chain and the per virtual desktop focus
+ * chain.
+ *
+ * In case the client does no longer want to get focus, it is removed from all chains. In case
+ * the client is on all virtual desktops it is ensured that it is present in each of the virtual
+ * desktops focus chain. In case it's on exactly one virtual desktop it is ensured that it is
+ * only in the focus chain for that virtual desktop.
+ *
+ * Depending on @p change the window is inserted at different positions in the focus chain. In
+ * case of @c focus_chain_change::make_first it is moved to the first position of the chain, in case
+ * of @c focus_chain_change::make_last it is moved to the last position of the chain. In all other
+ * cases it depends on whether the @p window is the currently active window. If it is the active
+ * window it becomes the first Client in the chain, otherwise it is inserted at the second position
+ * that is directly after the currently active window.
+ *
+ * @param window The window which should be moved inside the chains.
+ * @param change Where to move the window
+ */
+template<typename Manager, typename Win>
+void focus_chain_update(Manager& manager, Win* window, focus_chain_change change)
+{
+    if (!wants_tab_focus(window)) {
+        // Doesn't want tab focus, remove.
+        focus_chain_remove(manager, window);
+        return;
+    }
+
+    if (window->isOnAllDesktops()) {
+        // Now on all desktops, add it to focus chains it is not already in.
+        for (auto& [key, chain] : manager.chains.desktops) {
+            // Making first/last works only on current desktop, don't affect all desktops
+            if (key == manager.current_desktop
+                && (change == focus_chain_change::make_first
+                    || change == focus_chain_change::make_last)) {
+                if (change == focus_chain_change::make_first) {
+                    focus_chain_make_first_in_chain(window, chain);
+                } else {
+                    focus_chain_make_last_in_chain(window, chain);
+                }
+            } else {
+                focus_chain_insert_window_into_chain(window, chain, manager.active_window);
+            }
+        }
+    } else {
+        // Now only on desktop, remove it anywhere else
+        for (auto& [key, chain] : manager.chains.desktops) {
+            if (window->isOnDesktop(key)) {
+                focus_chain_update_window_in_chain(window, change, chain, manager.active_window);
+            } else {
+                remove_all(chain, window);
+            }
+        }
+    }
+
+    // add for most recently used chain
+    focus_chain_update_window_in_chain(
+        window, change, manager.chains.latest_use, manager.active_window);
+}
+
 /**
  * @brief Returns the first window in the most recently used focus chain. First window in this
  * case means really the first window in the chain and not the most recently used window.
diff --git a/win/focus_chain_find.h b/win/focus_chain_find.h
new file mode 100644
index 000000000..9d120562d
--- /dev/null
+++ b/win/focus_chain_find.h
@@ -0,0 +1,105 @@
+/*
+    SPDX-FileCopyrightText: 2022 Roman Gilg <subdiff@gmail.com>
+
+    SPDX-License-Identifier: GPL-2.0-or-later
+*/
+#pragma once
+
+#include "screen.h"
+
+namespace KWin::win
+{
+
+/**
+ * @brief Finds the best window to become the new active window in the focus chain for the given
+ * virtual @p desktop on the given @p output.
+ *
+ * This method makes only sense to use if separate output focus is used. If separate output
+ * focus is disabled the @p output is ignored. If no window for activation is found @c null is
+ * returned.
+ *
+ * @param desktop The virtual desktop to look for a window for activation
+ * @param output The output to constrain the search on with separate output focus
+ * @return The window which could be activated or @c null if there is none.
+ */
+template<typename Win, typename Manager>
+Win* focus_chain_get_for_activation(Manager& manager, uint desktop, base::output const* output)
+{
+    auto desk_it = manager.chains.desktops.find(desktop);
+    if (desk_it == manager.chains.desktops.end()) {
+        return nullptr;
+    }
+
+    auto const& chain = desk_it->second;
+
+    // TODO(romangg): reverse-range with C++20
+    for (auto it = chain.rbegin(); it != chain.rend(); ++it) {
+        // TODO: move the check into Client
+        auto win = *it;
+        if (!win->isShown()) {
+            continue;
+        }
+        if (manager.has_separate_screen_focus && win->central_output != output) {
+            continue;
+        }
+        return win;
+    }
+
+    return nullptr;
+}
+
+template<typename Win, typename Manager>
+Win* focus_chain_get_for_activation_on_current_output(Manager& manager, uint desktop)
+{
+    return focus_chain_get_for_activation<Win>(manager, desktop, get_current_output(manager.space));
+}
+
+template<typename Manager>
+bool focus_chain_is_usable_focus_candidate(Manager& manager, Toplevel* window, Toplevel* prev)
+{
+    if (window == prev) {
+        return false;
+    }
+    if (!window->isShown() || !window->isOnCurrentDesktop()) {
+        return false;
+    }
+
+    if (!manager.has_separate_screen_focus) {
+        return true;
+    }
+
+    return on_screen(window, prev ? prev->central_output : get_current_output(manager.space));
+}
+
+/**
+ * @brief Queries the focus chain for @p desktop for the next window in relation to the given
+ * @p reference.
+ *
+ * The method finds the first usable window which is not the @p reference Client. If no Client
+ * can be found @c null is returned
+ *
+ * @param reference The reference window which should not be returned
+ * @param desktop The virtual desktop whose focus chain should be used
+ * @return *The next usable window or @c null if none can be found.
+ */
+template<typename Manager, typename Win>
+Toplevel* focus_chain_next_for_desktop(Manager& manager, Win* reference, uint desktop)
+{
+    auto desk_it = manager.chains.desktops.find(desktop);
+    if (desk_it == manager.chains.desktops.end()) {
+        return nullptr;
+    }
+
+    auto const& chain = desk_it->second;
+
+    // TODO(romangg): reverse-range with C++20
+    for (auto it = chain.rbegin(); it != chain.rend(); ++it) {
+        if (focus_chain_is_usable_focus_candidate(manager, *it, reference)) {
+            return *it;
+        }
+    }
+
+    return nullptr;
+}
+
+}
diff --git a/win/screen.h b/win/screen.h
index 3ad21d261..60938f741 100644
--- a/win/screen.h
+++ b/win/screen.h
@@ -5,18 +5,10 @@
 */
 #pragma once
 
-#include "focus_chain.h"
-#include "move.h"
-#include "net.h"
-#include "stacking.h"
-#include "transient.h"
-#include "types.h"
-#include "virtual_desktops.h"
-
 #include "base/output_helpers.h"
+#include "base/platform.h"
 #include "main.h"
-
-#include <Wrapland/Server/plasma_window.h>
+#include "toplevel.h"
 
 namespace KWin::win
 {
@@ -56,98 +48,6 @@ base::output const* get_current_output(Space const& space)
     return cur;
 }
 
-/**
- * @brief Finds the best window to become the new active window in the focus chain for the given
- * virtual @p desktop on the given @p output.
- *
- * This method makes only sense to use if separate output focus is used. If separate output
- * focus is disabled the @p output is ignored. If no window for activation is found @c null is
- * returned.
- *
- * @param desktop The virtual desktop to look for a window for activation
- * @param output The output to constrain the search on with separate output focus
- * @return The window which could be activated or @c null if there is none.
- */
-template<typename Win, typename Manager>
-Win* focus_chain_get_for_activation(Manager& manager, uint desktop, base::output const* output)
-{
-    auto desk_it = manager.chains.desktops.find(desktop);
-    if (desk_it == manager.chains.desktops.end()) {
-        return nullptr;
-    }
-
-    auto const& chain = desk_it->second;
-
-    // TODO(romangg): reverse-range with C++20
-    for (auto it = chain.rbegin(); it != chain.rend(); ++it) {
-        // TODO: move the check into Client
-        auto win = *it;
-        if (!win->isShown()) {
-            continue;
-        }
-        if (manager.has_separate_screen_focus && win->central_output != output) {
-            continue;
-        }
-        return win;
-    }
-
-    return nullptr;
-}
-
-template<typename Win, typename Manager>
-Win* focus_chain_get_for_activation_on_current_output(Manager& manager, uint desktop)
-{
-    return focus_chain_get_for_activation<Win>(manager, desktop, get_current_output(manager.space));
-}
-
-template<typename Manager>
-bool focus_chain_is_usable_focus_candidate(Manager& manager, Toplevel* window, Toplevel* prev)
-{
-    if (window == prev) {
-        return false;
-    }
-    if (!window->isShown() || !window->isOnCurrentDesktop()) {
-        return false;
-    }
-
-    if (!manager.has_separate_screen_focus) {
-        return true;
-    }
-
-    return on_screen(window, prev ? prev->central_output : get_current_output(manager.space));
-}
-
-/**
- * @brief Queries the focus chain for @p desktop for the next window in relation to the given
- * @p reference.
- *
- * The method finds the first usable window which is not the @p reference Client. If no Client
- * can be found @c null is returned
- *
- * @param reference The reference window which should not be returned
- * @param desktop The virtual desktop whose focus chain should be used
- * @return *The next usable window or @c null if none can be found.
- */
-template<typename Manager, typename Win>
-Toplevel* focus_chain_next_for_desktop(Manager& manager, Win* reference, uint desktop)
-{
-    auto desk_it = manager.chains.desktops.find(desktop);
-    if (desk_it == manager.chains.desktops.end()) {
-        return nullptr;
-    }
-
-    auto const& chain = desk_it->second;
-
-    // TODO(romangg): reverse-range with C++20
-    for (auto it = chain.rbegin(); it != chain.rend(); ++it) {
-        if (focus_chain_is_usable_focus_candidate(manager, *it, reference)) {
-            return *it;
-        }
-    }
-
-    return nullptr;
-}
-
 template<typename Base, typename Win>
 void set_current_output_by_window(Base& base, Win const& window)
 {
diff --git a/win/stacking.h b/win/stacking.h
index e5f9e0afe..f372c794b 100644
--- a/win/stacking.h
+++ b/win/stacking.h
@@ -7,14 +7,13 @@
 
 #include "controlling.h"
 #include "focus_chain.h"
-#include "focus_chain_helpers.h"
+#include "focus_chain_edit.h"
 #include "geo.h"
 #include "layers.h"
 #include "stacking_order.h"
 #include "util.h"
 #include "x11/group.h"
 #include "x11/netinfo.h"
-#include "x11/tool_windows.h"
 
 // Required for casts between Toplevel and window in some template functions.
 // TODO(romangg): Remove these casts and this include to make the functions truly generic.
@@ -22,6 +21,7 @@
 
 #include "base/output_helpers.h"
 #include "base/platform.h"
+#include "main.h"
 #include "utils/algorithm.h"
 #include "utils/blocker.h"
 
-- 
GitLab


From ffd819effa3791b4c4cedffa69e68199d5c24cf9 Mon Sep 17 00:00:00 2001
From: Roman Gilg <subdiff@gmail.com>
Date: Tue, 5 Jul 2022 21:34:00 +0200
Subject: [PATCH 11/51] refactor: implement window area functions as free
 functions

This way the functionality can be reused by different types of spaces.
---
 autotests/integration/plasma_surface_test.cpp |   5 +-
 autotests/integration/struts_test.cpp         | 222 +++++++++---------
 autotests/integration/transient_placement.cpp |  11 +-
 input/wayland/input_method.cpp                |   7 +-
 render/effects.cpp                            |  13 +-
 render/gl/lanczos_filter.cpp                  |   5 +-
 scripting/space.h                             |   8 +-
 win/fullscreen.h                              |   4 +-
 win/geo_change.h                              |   9 +-
 win/geo_electric.h                            |   5 +-
 win/internal_window.cpp                       |   3 +-
 win/maximize.h                                |   5 +-
 win/move.h                                    |  43 ++--
 win/placement.h                               |   9 +-
 win/screen_edges.cpp                          |   2 +-
 win/setup.h                                   |   9 +-
 win/space.cpp                                 | 132 +++--------
 win/space.h                                   |   4 -
 win/wayland/layer_shell.h                     |   2 +-
 win/wayland/space.cpp                         |   4 +-
 win/wayland/window.cpp                        |  11 +-
 win/window_area.h                             |  96 ++++++++
 win/x11/control.h                             |   2 +-
 win/x11/geo.h                                 |  12 +-
 win/x11/placement.h                           |  21 +-
 win/x11/window.cpp                            |   2 +-
 26 files changed, 359 insertions(+), 287 deletions(-)
 create mode 100644 win/window_area.h

diff --git a/autotests/integration/plasma_surface_test.cpp b/autotests/integration/plasma_surface_test.cpp
index c3d96f3f2..7ea887413 100644
--- a/autotests/integration/plasma_surface_test.cpp
+++ b/autotests/integration/plasma_surface_test.cpp
@@ -311,7 +311,7 @@ void PlasmaSurfaceTest::testPanelTypeHasStrut()
     QVERIFY(win::is_dock(c));
     QCOMPARE(c->frameGeometry(), QRect(0, 0, 100, 50));
     QTEST(c->hasStrut(), "expectedStrut");
-    QTEST(Test::app()->workspace->clientArea(MaximizeArea, 0, 0), "expectedMaxArea");
+    QTEST(win::space_window_area(*Test::app()->workspace, MaximizeArea, 0, 0), "expectedMaxArea");
     QTEST(c->layer(), "expectedLayer");
 }
 
@@ -370,7 +370,8 @@ void PlasmaSurfaceTest::testPanelWindowsCanCover()
     QVERIFY(win::is_dock(panel));
     QCOMPARE(panel->frameGeometry(), panelGeometry);
     QCOMPARE(panel->hasStrut(), false);
-    QCOMPARE(Test::app()->workspace->clientArea(MaximizeArea, 0, 0), QRect(0, 0, 1280, 1024));
+    QCOMPARE(win::space_window_area(*Test::app()->workspace, MaximizeArea, 0, 0),
+             QRect(0, 0, 1280, 1024));
     QCOMPARE(panel->layer(), KWin::win::layer::normal);
 
     // create a Window
diff --git a/autotests/integration/struts_test.cpp b/autotests/integration/struts_test.cpp
index 88722eb6b..9c5231b5d 100644
--- a/autotests/integration/struts_test.cpp
+++ b/autotests/integration/struts_test.cpp
@@ -189,37 +189,37 @@ void StrutsTest::testWaylandStruts()
     using namespace Wrapland::Client;
 
     auto const& outputs = Test::app()->base.get_outputs();
-    QCOMPARE(Test::app()->workspace->clientArea(PlacementArea, outputs.at(0), 1),
+    QCOMPARE(win::space_window_area(*Test::app()->workspace, PlacementArea, outputs.at(0), 1),
              QRect(0, 0, 1280, 1024));
-    QCOMPARE(Test::app()->workspace->clientArea(MovementArea, outputs.at(0), 1),
+    QCOMPARE(win::space_window_area(*Test::app()->workspace, MovementArea, outputs.at(0), 1),
              QRect(0, 0, 1280, 1024));
-    QCOMPARE(Test::app()->workspace->clientArea(MaximizeArea, outputs.at(0), 1),
+    QCOMPARE(win::space_window_area(*Test::app()->workspace, MaximizeArea, outputs.at(0), 1),
              QRect(0, 0, 1280, 1024));
-    QCOMPARE(Test::app()->workspace->clientArea(MaximizeFullArea, outputs.at(0), 1),
+    QCOMPARE(win::space_window_area(*Test::app()->workspace, MaximizeFullArea, outputs.at(0), 1),
              QRect(0, 0, 1280, 1024));
-    QCOMPARE(Test::app()->workspace->clientArea(FullScreenArea, outputs.at(0), 1),
+    QCOMPARE(win::space_window_area(*Test::app()->workspace, FullScreenArea, outputs.at(0), 1),
              QRect(0, 0, 1280, 1024));
-    QCOMPARE(Test::app()->workspace->clientArea(ScreenArea, outputs.at(0), 1),
+    QCOMPARE(win::space_window_area(*Test::app()->workspace, ScreenArea, outputs.at(0), 1),
              QRect(0, 0, 1280, 1024));
 
     // second screen
-    QCOMPARE(Test::app()->workspace->clientArea(PlacementArea, outputs.at(1), 1),
+    QCOMPARE(win::space_window_area(*Test::app()->workspace, PlacementArea, outputs.at(1), 1),
              QRect(1280, 0, 1280, 1024));
-    QCOMPARE(Test::app()->workspace->clientArea(MovementArea, outputs.at(1), 1),
+    QCOMPARE(win::space_window_area(*Test::app()->workspace, MovementArea, outputs.at(1), 1),
              QRect(1280, 0, 1280, 1024));
-    QCOMPARE(Test::app()->workspace->clientArea(MaximizeArea, outputs.at(1), 1),
+    QCOMPARE(win::space_window_area(*Test::app()->workspace, MaximizeArea, outputs.at(1), 1),
              QRect(1280, 0, 1280, 1024));
-    QCOMPARE(Test::app()->workspace->clientArea(MaximizeFullArea, outputs.at(1), 1),
+    QCOMPARE(win::space_window_area(*Test::app()->workspace, MaximizeFullArea, outputs.at(1), 1),
              QRect(1280, 0, 1280, 1024));
-    QCOMPARE(Test::app()->workspace->clientArea(FullScreenArea, outputs.at(1), 1),
+    QCOMPARE(win::space_window_area(*Test::app()->workspace, FullScreenArea, outputs.at(1), 1),
              QRect(1280, 0, 1280, 1024));
-    QCOMPARE(Test::app()->workspace->clientArea(ScreenArea, outputs.at(1), 1),
+    QCOMPARE(win::space_window_area(*Test::app()->workspace, ScreenArea, outputs.at(1), 1),
              QRect(1280, 0, 1280, 1024));
 
     // combined
-    QCOMPARE(Test::app()->workspace->clientArea(WorkArea, outputs.at(0), 1),
+    QCOMPARE(win::space_window_area(*Test::app()->workspace, WorkArea, outputs.at(0), 1),
              QRect(0, 0, 2560, 1024));
-    QCOMPARE(Test::app()->workspace->clientArea(FullArea, outputs.at(0), 1),
+    QCOMPARE(win::space_window_area(*Test::app()->workspace, FullArea, outputs.at(0), 1),
              QRect(0, 0, 2560, 1024));
     QCOMPARE(Test::app()->workspace->restrictedMoveArea(-1), QRegion());
 
@@ -259,35 +259,39 @@ void StrutsTest::testWaylandStruts()
     }
 
     // some props are independent of struts - those first
-    QCOMPARE(Test::app()->workspace->clientArea(MovementArea, outputs.at(0), 1),
+    QCOMPARE(win::space_window_area(*Test::app()->workspace, MovementArea, outputs.at(0), 1),
              QRect(0, 0, 1280, 1024));
-    QCOMPARE(Test::app()->workspace->clientArea(MaximizeFullArea, outputs.at(0), 1),
+    QCOMPARE(win::space_window_area(*Test::app()->workspace, MaximizeFullArea, outputs.at(0), 1),
              QRect(0, 0, 1280, 1024));
-    QCOMPARE(Test::app()->workspace->clientArea(FullScreenArea, outputs.at(0), 1),
+    QCOMPARE(win::space_window_area(*Test::app()->workspace, FullScreenArea, outputs.at(0), 1),
              QRect(0, 0, 1280, 1024));
-    QCOMPARE(Test::app()->workspace->clientArea(ScreenArea, outputs.at(0), 1),
+    QCOMPARE(win::space_window_area(*Test::app()->workspace, ScreenArea, outputs.at(0), 1),
              QRect(0, 0, 1280, 1024));
 
     // screen 1
-    QCOMPARE(Test::app()->workspace->clientArea(MovementArea, outputs.at(1), 1),
+    QCOMPARE(win::space_window_area(*Test::app()->workspace, MovementArea, outputs.at(1), 1),
              QRect(1280, 0, 1280, 1024));
-    QCOMPARE(Test::app()->workspace->clientArea(MaximizeFullArea, outputs.at(1), 1),
+    QCOMPARE(win::space_window_area(*Test::app()->workspace, MaximizeFullArea, outputs.at(1), 1),
              QRect(1280, 0, 1280, 1024));
-    QCOMPARE(Test::app()->workspace->clientArea(FullScreenArea, outputs.at(1), 1),
+    QCOMPARE(win::space_window_area(*Test::app()->workspace, FullScreenArea, outputs.at(1), 1),
              QRect(1280, 0, 1280, 1024));
-    QCOMPARE(Test::app()->workspace->clientArea(ScreenArea, outputs.at(1), 1),
+    QCOMPARE(win::space_window_area(*Test::app()->workspace, ScreenArea, outputs.at(1), 1),
              QRect(1280, 0, 1280, 1024));
 
     // combined
-    QCOMPARE(Test::app()->workspace->clientArea(FullArea, outputs.at(0), 1),
+    QCOMPARE(win::space_window_area(*Test::app()->workspace, FullArea, outputs.at(0), 1),
              QRect(0, 0, 2560, 1024));
 
     // now verify the actual updated client areas
-    QTEST(Test::app()->workspace->clientArea(PlacementArea, outputs.at(0), 1), "screen0Maximized");
-    QTEST(Test::app()->workspace->clientArea(MaximizeArea, outputs.at(0), 1), "screen0Maximized");
-    QTEST(Test::app()->workspace->clientArea(PlacementArea, outputs.at(1), 1), "screen1Maximized");
-    QTEST(Test::app()->workspace->clientArea(MaximizeArea, outputs.at(1), 1), "screen1Maximized");
-    QTEST(Test::app()->workspace->clientArea(WorkArea, outputs.at(0), 1), "workArea");
+    QTEST(win::space_window_area(*Test::app()->workspace, PlacementArea, outputs.at(0), 1),
+          "screen0Maximized");
+    QTEST(win::space_window_area(*Test::app()->workspace, MaximizeArea, outputs.at(0), 1),
+          "screen0Maximized");
+    QTEST(win::space_window_area(*Test::app()->workspace, PlacementArea, outputs.at(1), 1),
+          "screen1Maximized");
+    QTEST(win::space_window_area(*Test::app()->workspace, MaximizeArea, outputs.at(1), 1),
+          "screen1Maximized");
+    QTEST(win::space_window_area(*Test::app()->workspace, WorkArea, outputs.at(0), 1), "workArea");
     QTEST(Test::app()->workspace->restrictedMoveArea(-1), "restrictedMoveArea");
 
     // delete all surfaces
@@ -322,15 +326,15 @@ void StrutsTest::testMoveWaylandPanel()
     QVERIFY(c->hasStrut());
 
     auto const& outputs = Test::app()->base.get_outputs();
-    QCOMPARE(Test::app()->workspace->clientArea(PlacementArea, outputs.at(0), 1),
+    QCOMPARE(win::space_window_area(*Test::app()->workspace, PlacementArea, outputs.at(0), 1),
              QRect(0, 0, 1280, 1000));
-    QCOMPARE(Test::app()->workspace->clientArea(MaximizeArea, outputs.at(0), 1),
+    QCOMPARE(win::space_window_area(*Test::app()->workspace, MaximizeArea, outputs.at(0), 1),
              QRect(0, 0, 1280, 1000));
-    QCOMPARE(Test::app()->workspace->clientArea(PlacementArea, outputs.at(1), 1),
+    QCOMPARE(win::space_window_area(*Test::app()->workspace, PlacementArea, outputs.at(1), 1),
              QRect(1280, 0, 1280, 1024));
-    QCOMPARE(Test::app()->workspace->clientArea(MaximizeArea, outputs.at(1), 1),
+    QCOMPARE(win::space_window_area(*Test::app()->workspace, MaximizeArea, outputs.at(1), 1),
              QRect(1280, 0, 1280, 1024));
-    QCOMPARE(Test::app()->workspace->clientArea(WorkArea, outputs.at(0), 1),
+    QCOMPARE(win::space_window_area(*Test::app()->workspace, WorkArea, outputs.at(0), 1),
              QRect(0, 0, 2560, 1000));
 
     QSignalSpy geometryChangedSpy(c, &win::wayland::window::frame_geometry_changed);
@@ -338,15 +342,15 @@ void StrutsTest::testMoveWaylandPanel()
     plasmaSurface->setPosition(QPoint(1280, 1000));
     QVERIFY(geometryChangedSpy.wait());
     QCOMPARE(c->frameGeometry(), QRect(1280, 1000, 1280, 24));
-    QCOMPARE(Test::app()->workspace->clientArea(PlacementArea, outputs.at(0), 1),
+    QCOMPARE(win::space_window_area(*Test::app()->workspace, PlacementArea, outputs.at(0), 1),
              QRect(0, 0, 1280, 1024));
-    QCOMPARE(Test::app()->workspace->clientArea(MaximizeArea, outputs.at(0), 1),
+    QCOMPARE(win::space_window_area(*Test::app()->workspace, MaximizeArea, outputs.at(0), 1),
              QRect(0, 0, 1280, 1024));
-    QCOMPARE(Test::app()->workspace->clientArea(PlacementArea, outputs.at(1), 1),
+    QCOMPARE(win::space_window_area(*Test::app()->workspace, PlacementArea, outputs.at(1), 1),
              QRect(1280, 0, 1280, 1000));
-    QCOMPARE(Test::app()->workspace->clientArea(MaximizeArea, outputs.at(1), 1),
+    QCOMPARE(win::space_window_area(*Test::app()->workspace, MaximizeArea, outputs.at(1), 1),
              QRect(1280, 0, 1280, 1000));
-    QCOMPARE(Test::app()->workspace->clientArea(WorkArea, outputs.at(0), 1),
+    QCOMPARE(win::space_window_area(*Test::app()->workspace, WorkArea, outputs.at(0), 1),
              QRect(0, 0, 2560, 1000));
 }
 
@@ -379,15 +383,15 @@ void StrutsTest::testWaylandMobilePanel()
     QVERIFY(c->hasStrut());
 
     auto const& outputs = Test::app()->base.get_outputs();
-    QCOMPARE(Test::app()->workspace->clientArea(PlacementArea, outputs.at(0), 1),
+    QCOMPARE(win::space_window_area(*Test::app()->workspace, PlacementArea, outputs.at(0), 1),
              QRect(0, 60, 1280, 964));
-    QCOMPARE(Test::app()->workspace->clientArea(MaximizeArea, outputs.at(0), 1),
+    QCOMPARE(win::space_window_area(*Test::app()->workspace, MaximizeArea, outputs.at(0), 1),
              QRect(0, 60, 1280, 964));
-    QCOMPARE(Test::app()->workspace->clientArea(PlacementArea, outputs.at(1), 1),
+    QCOMPARE(win::space_window_area(*Test::app()->workspace, PlacementArea, outputs.at(1), 1),
              QRect(1280, 0, 1280, 1024));
-    QCOMPARE(Test::app()->workspace->clientArea(MaximizeArea, outputs.at(1), 1),
+    QCOMPARE(win::space_window_area(*Test::app()->workspace, MaximizeArea, outputs.at(1), 1),
              QRect(1280, 0, 1280, 1024));
-    QCOMPARE(Test::app()->workspace->clientArea(WorkArea, outputs.at(0), 1),
+    QCOMPARE(win::space_window_area(*Test::app()->workspace, WorkArea, outputs.at(0), 1),
              QRect(0, 60, 2560, 964));
 
     // create another bottom panel
@@ -410,15 +414,15 @@ void StrutsTest::testWaylandMobilePanel()
     QVERIFY(win::is_dock(c1));
     QVERIFY(c1->hasStrut());
 
-    QCOMPARE(Test::app()->workspace->clientArea(PlacementArea, outputs.at(0), 1),
+    QCOMPARE(win::space_window_area(*Test::app()->workspace, PlacementArea, outputs.at(0), 1),
              QRect(0, 60, 1280, 814));
-    QCOMPARE(Test::app()->workspace->clientArea(MaximizeArea, outputs.at(0), 1),
+    QCOMPARE(win::space_window_area(*Test::app()->workspace, MaximizeArea, outputs.at(0), 1),
              QRect(0, 60, 1280, 814));
-    QCOMPARE(Test::app()->workspace->clientArea(PlacementArea, outputs.at(1), 1),
+    QCOMPARE(win::space_window_area(*Test::app()->workspace, PlacementArea, outputs.at(1), 1),
              QRect(1280, 0, 1280, 1024));
-    QCOMPARE(Test::app()->workspace->clientArea(MaximizeArea, outputs.at(1), 1),
+    QCOMPARE(win::space_window_area(*Test::app()->workspace, MaximizeArea, outputs.at(1), 1),
              QRect(1280, 0, 1280, 1024));
-    QCOMPARE(Test::app()->workspace->clientArea(WorkArea, outputs.at(0), 1),
+    QCOMPARE(win::space_window_area(*Test::app()->workspace, WorkArea, outputs.at(0), 1),
              QRect(0, 60, 2560, 814));
 
     // Destroy test clients.
@@ -526,37 +530,37 @@ void StrutsTest::testX11Struts()
 
     // no, struts yet
     auto const& outputs = Test::app()->base.get_outputs();
-    QCOMPARE(Test::app()->workspace->clientArea(PlacementArea, outputs.at(0), 1),
+    QCOMPARE(win::space_window_area(*Test::app()->workspace, PlacementArea, outputs.at(0), 1),
              QRect(0, 0, 1280, 1024));
-    QCOMPARE(Test::app()->workspace->clientArea(MovementArea, outputs.at(0), 1),
+    QCOMPARE(win::space_window_area(*Test::app()->workspace, MovementArea, outputs.at(0), 1),
              QRect(0, 0, 1280, 1024));
-    QCOMPARE(Test::app()->workspace->clientArea(MaximizeArea, outputs.at(0), 1),
+    QCOMPARE(win::space_window_area(*Test::app()->workspace, MaximizeArea, outputs.at(0), 1),
              QRect(0, 0, 1280, 1024));
-    QCOMPARE(Test::app()->workspace->clientArea(MaximizeFullArea, outputs.at(0), 1),
+    QCOMPARE(win::space_window_area(*Test::app()->workspace, MaximizeFullArea, outputs.at(0), 1),
              QRect(0, 0, 1280, 1024));
-    QCOMPARE(Test::app()->workspace->clientArea(FullScreenArea, outputs.at(0), 1),
+    QCOMPARE(win::space_window_area(*Test::app()->workspace, FullScreenArea, outputs.at(0), 1),
              QRect(0, 0, 1280, 1024));
-    QCOMPARE(Test::app()->workspace->clientArea(ScreenArea, outputs.at(0), 1),
+    QCOMPARE(win::space_window_area(*Test::app()->workspace, ScreenArea, outputs.at(0), 1),
              QRect(0, 0, 1280, 1024));
 
     // second screen
-    QCOMPARE(Test::app()->workspace->clientArea(PlacementArea, outputs.at(1), 1),
+    QCOMPARE(win::space_window_area(*Test::app()->workspace, PlacementArea, outputs.at(1), 1),
              QRect(1280, 0, 1280, 1024));
-    QCOMPARE(Test::app()->workspace->clientArea(MovementArea, outputs.at(1), 1),
+    QCOMPARE(win::space_window_area(*Test::app()->workspace, MovementArea, outputs.at(1), 1),
              QRect(1280, 0, 1280, 1024));
-    QCOMPARE(Test::app()->workspace->clientArea(MaximizeArea, outputs.at(1), 1),
+    QCOMPARE(win::space_window_area(*Test::app()->workspace, MaximizeArea, outputs.at(1), 1),
              QRect(1280, 0, 1280, 1024));
-    QCOMPARE(Test::app()->workspace->clientArea(MaximizeFullArea, outputs.at(1), 1),
+    QCOMPARE(win::space_window_area(*Test::app()->workspace, MaximizeFullArea, outputs.at(1), 1),
              QRect(1280, 0, 1280, 1024));
-    QCOMPARE(Test::app()->workspace->clientArea(FullScreenArea, outputs.at(1), 1),
+    QCOMPARE(win::space_window_area(*Test::app()->workspace, FullScreenArea, outputs.at(1), 1),
              QRect(1280, 0, 1280, 1024));
-    QCOMPARE(Test::app()->workspace->clientArea(ScreenArea, outputs.at(1), 1),
+    QCOMPARE(win::space_window_area(*Test::app()->workspace, ScreenArea, outputs.at(1), 1),
              QRect(1280, 0, 1280, 1024));
 
     // combined
-    QCOMPARE(Test::app()->workspace->clientArea(WorkArea, outputs.at(0), 1),
+    QCOMPARE(win::space_window_area(*Test::app()->workspace, WorkArea, outputs.at(0), 1),
              QRect(0, 0, 2560, 1024));
-    QCOMPARE(Test::app()->workspace->clientArea(FullArea, outputs.at(0), 1),
+    QCOMPARE(win::space_window_area(*Test::app()->workspace, FullArea, outputs.at(0), 1),
              QRect(0, 0, 2560, 1024));
     QCOMPARE(Test::app()->workspace->restrictedMoveArea(-1), QRegion());
 
@@ -630,35 +634,39 @@ void StrutsTest::testX11Struts()
 
     // this should have affected the client area
     // some props are independent of struts - those first
-    QCOMPARE(Test::app()->workspace->clientArea(MovementArea, outputs.at(0), 1),
+    QCOMPARE(win::space_window_area(*Test::app()->workspace, MovementArea, outputs.at(0), 1),
              QRect(0, 0, 1280, 1024));
-    QCOMPARE(Test::app()->workspace->clientArea(MaximizeFullArea, outputs.at(0), 1),
+    QCOMPARE(win::space_window_area(*Test::app()->workspace, MaximizeFullArea, outputs.at(0), 1),
              QRect(0, 0, 1280, 1024));
-    QCOMPARE(Test::app()->workspace->clientArea(FullScreenArea, outputs.at(0), 1),
+    QCOMPARE(win::space_window_area(*Test::app()->workspace, FullScreenArea, outputs.at(0), 1),
              QRect(0, 0, 1280, 1024));
-    QCOMPARE(Test::app()->workspace->clientArea(ScreenArea, outputs.at(0), 1),
+    QCOMPARE(win::space_window_area(*Test::app()->workspace, ScreenArea, outputs.at(0), 1),
              QRect(0, 0, 1280, 1024));
 
     // screen 1
-    QCOMPARE(Test::app()->workspace->clientArea(MovementArea, outputs.at(1), 1),
+    QCOMPARE(win::space_window_area(*Test::app()->workspace, MovementArea, outputs.at(1), 1),
              QRect(1280, 0, 1280, 1024));
-    QCOMPARE(Test::app()->workspace->clientArea(MaximizeFullArea, outputs.at(1), 1),
+    QCOMPARE(win::space_window_area(*Test::app()->workspace, MaximizeFullArea, outputs.at(1), 1),
              QRect(1280, 0, 1280, 1024));
-    QCOMPARE(Test::app()->workspace->clientArea(FullScreenArea, outputs.at(1), 1),
+    QCOMPARE(win::space_window_area(*Test::app()->workspace, FullScreenArea, outputs.at(1), 1),
              QRect(1280, 0, 1280, 1024));
-    QCOMPARE(Test::app()->workspace->clientArea(ScreenArea, outputs.at(1), 1),
+    QCOMPARE(win::space_window_area(*Test::app()->workspace, ScreenArea, outputs.at(1), 1),
              QRect(1280, 0, 1280, 1024));
 
     // combined
-    QCOMPARE(Test::app()->workspace->clientArea(FullArea, outputs.at(0), 1),
+    QCOMPARE(win::space_window_area(*Test::app()->workspace, FullArea, outputs.at(0), 1),
              QRect(0, 0, 2560, 1024));
 
     // now verify the actual updated client areas
-    QTEST(Test::app()->workspace->clientArea(PlacementArea, outputs.at(0), 1), "screen0Maximized");
-    QTEST(Test::app()->workspace->clientArea(MaximizeArea, outputs.at(0), 1), "screen0Maximized");
-    QTEST(Test::app()->workspace->clientArea(PlacementArea, outputs.at(1), 1), "screen1Maximized");
-    QTEST(Test::app()->workspace->clientArea(MaximizeArea, outputs.at(1), 1), "screen1Maximized");
-    QTEST(Test::app()->workspace->clientArea(WorkArea, outputs.at(0), 1), "workArea");
+    QTEST(win::space_window_area(*Test::app()->workspace, PlacementArea, outputs.at(0), 1),
+          "screen0Maximized");
+    QTEST(win::space_window_area(*Test::app()->workspace, MaximizeArea, outputs.at(0), 1),
+          "screen0Maximized");
+    QTEST(win::space_window_area(*Test::app()->workspace, PlacementArea, outputs.at(1), 1),
+          "screen1Maximized");
+    QTEST(win::space_window_area(*Test::app()->workspace, MaximizeArea, outputs.at(1), 1),
+          "screen1Maximized");
+    QTEST(win::space_window_area(*Test::app()->workspace, WorkArea, outputs.at(0), 1), "workArea");
     QTEST(Test::app()->workspace->restrictedMoveArea(-1), "restrictedMoveArea");
 
     // and destroy the window again
@@ -672,37 +680,37 @@ void StrutsTest::testX11Struts()
     QVERIFY(windowClosedSpy.wait());
 
     // now struts should be removed again
-    QCOMPARE(Test::app()->workspace->clientArea(PlacementArea, outputs.at(0), 1),
+    QCOMPARE(win::space_window_area(*Test::app()->workspace, PlacementArea, outputs.at(0), 1),
              QRect(0, 0, 1280, 1024));
-    QCOMPARE(Test::app()->workspace->clientArea(MovementArea, outputs.at(0), 1),
+    QCOMPARE(win::space_window_area(*Test::app()->workspace, MovementArea, outputs.at(0), 1),
              QRect(0, 0, 1280, 1024));
-    QCOMPARE(Test::app()->workspace->clientArea(MaximizeArea, outputs.at(0), 1),
+    QCOMPARE(win::space_window_area(*Test::app()->workspace, MaximizeArea, outputs.at(0), 1),
              QRect(0, 0, 1280, 1024));
-    QCOMPARE(Test::app()->workspace->clientArea(MaximizeFullArea, outputs.at(0), 1),
+    QCOMPARE(win::space_window_area(*Test::app()->workspace, MaximizeFullArea, outputs.at(0), 1),
              QRect(0, 0, 1280, 1024));
-    QCOMPARE(Test::app()->workspace->clientArea(FullScreenArea, outputs.at(0), 1),
+    QCOMPARE(win::space_window_area(*Test::app()->workspace, FullScreenArea, outputs.at(0), 1),
              QRect(0, 0, 1280, 1024));
-    QCOMPARE(Test::app()->workspace->clientArea(ScreenArea, outputs.at(0), 1),
+    QCOMPARE(win::space_window_area(*Test::app()->workspace, ScreenArea, outputs.at(0), 1),
              QRect(0, 0, 1280, 1024));
 
     // second screen
-    QCOMPARE(Test::app()->workspace->clientArea(PlacementArea, outputs.at(1), 1),
+    QCOMPARE(win::space_window_area(*Test::app()->workspace, PlacementArea, outputs.at(1), 1),
              QRect(1280, 0, 1280, 1024));
-    QCOMPARE(Test::app()->workspace->clientArea(MovementArea, outputs.at(1), 1),
+    QCOMPARE(win::space_window_area(*Test::app()->workspace, MovementArea, outputs.at(1), 1),
              QRect(1280, 0, 1280, 1024));
-    QCOMPARE(Test::app()->workspace->clientArea(MaximizeArea, outputs.at(1), 1),
+    QCOMPARE(win::space_window_area(*Test::app()->workspace, MaximizeArea, outputs.at(1), 1),
              QRect(1280, 0, 1280, 1024));
-    QCOMPARE(Test::app()->workspace->clientArea(MaximizeFullArea, outputs.at(1), 1),
+    QCOMPARE(win::space_window_area(*Test::app()->workspace, MaximizeFullArea, outputs.at(1), 1),
              QRect(1280, 0, 1280, 1024));
-    QCOMPARE(Test::app()->workspace->clientArea(FullScreenArea, outputs.at(1), 1),
+    QCOMPARE(win::space_window_area(*Test::app()->workspace, FullScreenArea, outputs.at(1), 1),
              QRect(1280, 0, 1280, 1024));
-    QCOMPARE(Test::app()->workspace->clientArea(ScreenArea, outputs.at(1), 1),
+    QCOMPARE(win::space_window_area(*Test::app()->workspace, ScreenArea, outputs.at(1), 1),
              QRect(1280, 0, 1280, 1024));
 
     // combined
-    QCOMPARE(Test::app()->workspace->clientArea(WorkArea, outputs.at(0), 1),
+    QCOMPARE(win::space_window_area(*Test::app()->workspace, WorkArea, outputs.at(0), 1),
              QRect(0, 0, 2560, 1024));
-    QCOMPARE(Test::app()->workspace->clientArea(FullArea, outputs.at(0), 1),
+    QCOMPARE(win::space_window_area(*Test::app()->workspace, FullArea, outputs.at(0), 1),
              QRect(0, 0, 2560, 1024));
     QCOMPARE(Test::app()->workspace->restrictedMoveArea(-1), QRegion());
 }
@@ -774,13 +782,15 @@ void StrutsTest::test363804()
 
     // now verify the actual updated client areas
     auto const& outputs = Test::app()->base.get_outputs();
-    QCOMPARE(Test::app()->workspace->clientArea(PlacementArea, outputs.at(0), 1), geometries.at(0));
-    QCOMPARE(Test::app()->workspace->clientArea(MaximizeArea, outputs.at(0), 1), geometries.at(0));
-    QCOMPARE(Test::app()->workspace->clientArea(PlacementArea, outputs.at(1), 1),
+    QCOMPARE(win::space_window_area(*Test::app()->workspace, PlacementArea, outputs.at(0), 1),
+             geometries.at(0));
+    QCOMPARE(win::space_window_area(*Test::app()->workspace, MaximizeArea, outputs.at(0), 1),
+             geometries.at(0));
+    QCOMPARE(win::space_window_area(*Test::app()->workspace, PlacementArea, outputs.at(1), 1),
              QRect(554, 1080, 1366, 732));
-    QCOMPARE(Test::app()->workspace->clientArea(MaximizeArea, outputs.at(1), 1),
+    QCOMPARE(win::space_window_area(*Test::app()->workspace, MaximizeArea, outputs.at(1), 1),
              QRect(554, 1080, 1366, 732));
-    QCOMPARE(Test::app()->workspace->clientArea(WorkArea, outputs.at(0), 1),
+    QCOMPARE(win::space_window_area(*Test::app()->workspace, WorkArea, outputs.at(0), 1),
              QRect(0, 0, 1920, 1812));
 
     // and destroy the window again
@@ -863,13 +873,15 @@ void StrutsTest::testLeftScreenSmallerBottomAligned()
 
     // now verify the actual updated client areas
     auto const& outputs = Test::app()->base.get_outputs();
-    QCOMPARE(Test::app()->workspace->clientArea(PlacementArea, outputs.at(0), 1),
+    QCOMPARE(win::space_window_area(*Test::app()->workspace, PlacementArea, outputs.at(0), 1),
              QRect(0, 306, 1366, 744));
-    QCOMPARE(Test::app()->workspace->clientArea(MaximizeArea, outputs.at(0), 1),
+    QCOMPARE(win::space_window_area(*Test::app()->workspace, MaximizeArea, outputs.at(0), 1),
              QRect(0, 306, 1366, 744));
-    QCOMPARE(Test::app()->workspace->clientArea(PlacementArea, outputs.at(1), 1), geometries.at(1));
-    QCOMPARE(Test::app()->workspace->clientArea(MaximizeArea, outputs.at(1), 1), geometries.at(1));
-    QCOMPARE(Test::app()->workspace->clientArea(WorkArea, outputs.at(0), 1),
+    QCOMPARE(win::space_window_area(*Test::app()->workspace, PlacementArea, outputs.at(1), 1),
+             geometries.at(1));
+    QCOMPARE(win::space_window_area(*Test::app()->workspace, MaximizeArea, outputs.at(1), 1),
+             geometries.at(1));
+    QCOMPARE(win::space_window_area(*Test::app()->workspace, WorkArea, outputs.at(0), 1),
              QRect(0, 0, 3046, 1050));
 
     // now create a window which is larger than screen 0
@@ -996,15 +1008,15 @@ void StrutsTest::testWindowMoveWithPanelBetweenScreens()
 
     // now verify the actual updated client areas
     auto const& outputs = Test::app()->base.get_outputs();
-    QCOMPARE(Test::app()->workspace->clientArea(PlacementArea, outputs.at(0), 1),
+    QCOMPARE(win::space_window_area(*Test::app()->workspace, PlacementArea, outputs.at(0), 1),
              QRect(0, 282, 1366, 768));
-    QCOMPARE(Test::app()->workspace->clientArea(MaximizeArea, outputs.at(0), 1),
+    QCOMPARE(win::space_window_area(*Test::app()->workspace, MaximizeArea, outputs.at(0), 1),
              QRect(0, 282, 1366, 768));
-    QCOMPARE(Test::app()->workspace->clientArea(PlacementArea, outputs.at(1), 1),
+    QCOMPARE(win::space_window_area(*Test::app()->workspace, PlacementArea, outputs.at(1), 1),
              QRect(1390, 0, 1656, 1050));
-    QCOMPARE(Test::app()->workspace->clientArea(MaximizeArea, outputs.at(1), 1),
+    QCOMPARE(win::space_window_area(*Test::app()->workspace, MaximizeArea, outputs.at(1), 1),
              QRect(1390, 0, 1656, 1050));
-    QCOMPARE(Test::app()->workspace->clientArea(WorkArea, outputs.at(0), 1),
+    QCOMPARE(win::space_window_area(*Test::app()->workspace, WorkArea, outputs.at(0), 1),
              QRect(0, 0, 3046, 1050));
     QCOMPARE(Test::app()->workspace->restrictedMoveArea(-1), QRegion(1366, 0, 24, 1050));
 
diff --git a/autotests/integration/transient_placement.cpp b/autotests/integration/transient_placement.cpp
index d80d01360..37fb01ca2 100644
--- a/autotests/integration/transient_placement.cpp
+++ b/autotests/integration/transient_placement.cpp
@@ -338,8 +338,8 @@ void TransientPlacementTest::testXdgPopupWithPanel()
     plasmaSurface->setPanelBehavior(PlasmaShellSurface::PanelBehavior::AlwaysVisible);
 
     // Placement area still full screen.
-    QVERIFY(Test::app()->workspace->clientArea(PlacementArea, 0, 1)
-            == Test::app()->workspace->clientArea(FullScreenArea, 0, 1));
+    QVERIFY(win::space_window_area(*Test::app()->workspace, PlacementArea, 0, 1)
+            == win::space_window_area(*Test::app()->workspace, FullScreenArea, 0, 1));
 
     // Now map the panel and placement area is reduced.
     auto dock = Test::render_and_wait_for_shown(surface, QSize(1280, 50), Qt::blue);
@@ -349,8 +349,8 @@ void TransientPlacementTest::testXdgPopupWithPanel()
     QCOMPARE(dock->frameGeometry(),
              QRect(0, Test::get_output(0)->geometry().height() - 50, 1280, 50));
     QCOMPARE(dock->hasStrut(), true);
-    QVERIFY(Test::app()->workspace->clientArea(PlacementArea, 0, 1)
-            != Test::app()->workspace->clientArea(FullScreenArea, 0, 1));
+    QVERIFY(win::space_window_area(*Test::app()->workspace, PlacementArea, 0, 1)
+            != win::space_window_area(*Test::app()->workspace, FullScreenArea, 0, 1));
 
     // Create parent
     auto parentSurface = Test::create_surface();
@@ -363,7 +363,8 @@ void TransientPlacementTest::testXdgPopupWithPanel()
     QVERIFY(!win::decoration(parent));
 
     win::move(parent, {0, Test::get_output(0)->geometry().height() - 300});
-    win::keep_in_area(parent, Test::app()->workspace->clientArea(PlacementArea, parent), false);
+    win::keep_in_area(
+        parent, win::space_window_area(*Test::app()->workspace, PlacementArea, parent), false);
     QCOMPARE(parent->frameGeometry(),
              QRect(0, Test::get_output(0)->geometry().height() - 600 - 50, 800, 600));
 
diff --git a/input/wayland/input_method.cpp b/input/wayland/input_method.cpp
index 40e39b0e5..549a81ffb 100644
--- a/input/wayland/input_method.cpp
+++ b/input/wayland/input_method.cpp
@@ -19,6 +19,7 @@
 #include "win/wayland/space.h"
 #include "win/wayland/window.h"
 #include "win/wayland/window_release.h"
+#include "win/window_area.h"
 
 #include <Wrapland/Server/input_method_v2.h>
 #include <Wrapland/Server/seat.h>
@@ -54,8 +55,10 @@ QRect get_input_popup_placement(input::wayland::platform& platform,
     using constraint_adjust = Wrapland::Server::XdgShellSurface::ConstraintAdjustment;
 
     auto const toplevel = win::lead_of_annexed_transient(parent_window);
-    auto const& screen_bounds = platform.redirect->space.clientArea(
-        toplevel->control->fullscreen() ? FullScreenArea : PlacementArea, toplevel);
+    auto const& screen_bounds
+        = win::space_window_area(platform.redirect->space,
+                                 toplevel->control->fullscreen() ? FullScreenArea : PlacementArea,
+                                 toplevel);
 
     auto const& text_area = cursor_rectangle.isValid() ? cursor_rectangle : QRect(0, 0, 0, 0);
 
diff --git a/render/effects.cpp b/render/effects.cpp
index 9f423e7d3..0f1f99fc6 100644
--- a/render/effects.cpp
+++ b/render/effects.cpp
@@ -51,6 +51,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "win/stacking_order.h"
 #include "win/transient.h"
 #include "win/virtual_desktops.h"
+#include "win/window_area.h"
 #include "win/x11/group.h"
 #include "win/x11/unmanaged.h"
 #include "win/x11/window.h"
@@ -1273,7 +1274,7 @@ int effects_handler_impl::screenNumber(const QPoint& pos) const
 QRect effects_handler_impl::clientArea(clientAreaOption opt, int screen, int desktop) const
 {
     auto output = base::get_output(kwinApp()->get_base().get_outputs(), screen);
-    return m_compositor->space->clientArea(opt, output, desktop);
+    return win::space_window_area(*m_compositor->space, opt, output, desktop);
 }
 
 QRect effects_handler_impl::clientArea(clientAreaOption opt, const EffectWindow* c) const
@@ -1282,16 +1283,18 @@ QRect effects_handler_impl::clientArea(clientAreaOption opt, const EffectWindow*
     auto space = m_compositor->space;
 
     if (window->control) {
-        return space->clientArea(opt, window);
+        return win::space_window_area(*space, opt, window);
     } else {
-        return space->clientArea(
-            opt, window->frameGeometry().center(), space->virtual_desktop_manager->current());
+        return win::space_window_area(*space,
+                                      opt,
+                                      window->frameGeometry().center(),
+                                      space->virtual_desktop_manager->current());
     }
 }
 
 QRect effects_handler_impl::clientArea(clientAreaOption opt, const QPoint& p, int desktop) const
 {
-    return m_compositor->space->clientArea(opt, p, desktop);
+    return win::space_window_area(*m_compositor->space, opt, p, desktop);
 }
 
 QRect effects_handler_impl::virtualScreenGeometry() const
diff --git a/render/gl/lanczos_filter.cpp b/render/gl/lanczos_filter.cpp
index 002f54d72..ad6270712 100644
--- a/render/gl/lanczos_filter.cpp
+++ b/render/gl/lanczos_filter.cpp
@@ -29,6 +29,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "render/effects.h"
 #include "toplevel.h"
 #include "win/space.h"
+#include "win/window_area.h"
 
 #include <kwingl/platform.h>
 #include <kwingl/utils.h>
@@ -182,8 +183,8 @@ void lanczos_filter::performPaint(effects_window_impl* w,
             init();
         }
 
-        auto const screenRect = m_scene->compositor.space->clientArea(
-            ScreenArea, w->window()->central_output, w->desktop());
+        auto const screenRect = win::space_window_area(
+            *m_scene->compositor.space, ScreenArea, w->window()->central_output, w->desktop());
 
         // window geometry may not be bigger than screen geometry to fit into the FBO
         QRect winGeo(w->expandedGeometry());
diff --git a/scripting/space.h b/scripting/space.h
index e1ddf9a53..786ec1214 100644
--- a/scripting/space.h
+++ b/scripting/space.h
@@ -762,22 +762,22 @@ protected:
     QRect client_area_impl(clientAreaOption option, int screen, int desktop) const override
     {
         auto output = base::get_output(kwinApp()->get_base().get_outputs(), screen);
-        return ref_space->clientArea(option, output, desktop);
+        return win::space_window_area(*ref_space, option, output, desktop);
     }
 
     QRect client_area_impl(clientAreaOption option, QPoint const& point, int desktop) const override
     {
-        return ref_space->clientArea(option, point, desktop);
+        return win::space_window_area(*ref_space, option, point, desktop);
     }
 
     QRect client_area_impl(clientAreaOption option, window* window) const override
     {
-        return ref_space->clientArea(option, window->client());
+        return win::space_window_area(*ref_space, option, window->client());
     }
 
     QRect client_area_impl(clientAreaOption option, window const* window) const override
     {
-        return ref_space->clientArea(option, window->client());
+        return win::space_window_area(*ref_space, option, window->client());
     }
 
     QString desktop_name_impl(int desktop) const override
diff --git a/win/fullscreen.h b/win/fullscreen.h
index b0904c013..0da4d1b71 100644
--- a/win/fullscreen.h
+++ b/win/fullscreen.h
@@ -27,7 +27,7 @@ QRect rectify_fullscreen_restore_geometry(Win* win)
         return win->restore_geometries.maximize;
     }
 
-    auto const client_area = win->space.clientArea(PlacementArea, win);
+    auto const client_area = space_window_area(win->space, PlacementArea, win);
     auto const frame_size = win->control->adjusted_frame_size(client_area.size() * 2 / 3.,
                                                               win::size_mode::fixed_height);
 
@@ -77,7 +77,7 @@ void update_fullscreen_enable(Win* win)
     if (!win->restore_geometries.maximize.isValid()) {
         win->restore_geometries.maximize = win->geometry_update.frame;
     }
-    win->setFrameGeometry(win->space.clientArea(FullScreenArea, win));
+    win->setFrameGeometry(space_window_area(win->space, FullScreenArea, win));
 }
 
 template<typename Win>
diff --git a/win/geo_change.h b/win/geo_change.h
index 3a62350a3..ba22dcce0 100644
--- a/win/geo_change.h
+++ b/win/geo_change.h
@@ -8,6 +8,7 @@
 #include "geo.h"
 #include "scene.h"
 #include "types.h"
+#include "window_area.h"
 
 namespace KWin::win
 {
@@ -18,7 +19,7 @@ QSize constrain_and_adjust_size(Win* win, QSize const& size)
     auto width = size.width();
     auto height = size.height();
 
-    auto const area = win->space.clientArea(WorkArea, win);
+    auto const area = space_window_area(win->space, WorkArea, win);
 
     width = std::min(width, area.width());
     height = std::min(height, area.height());
@@ -53,7 +54,8 @@ void grow_horizontal(Win* win)
 
         // Check that it hasn't grown outside of the area, due to size increments.
         // TODO this may be wrong?
-        auto const area = win->space.clientArea(
+        auto const area = space_window_area(
+            win->space,
             MovementArea,
             QPoint((win->pos().x() + grown_right) / 2, win->frameGeometry().center().y()),
             win->desktop());
@@ -112,7 +114,8 @@ void grow_vertical(Win* win)
             win, frame_geo.bottom() + win->resizeIncrements().height() - 1, true);
 
         // check that it hasn't grown outside of the area, due to size increments
-        auto const area = win->space.clientArea(
+        auto const area = space_window_area(
+            win->space,
             MovementArea,
             QPoint(win->frameGeometry().center().x(), (win->pos().y() + newbottom) / 2),
             win->desktop());
diff --git a/win/geo_electric.h b/win/geo_electric.h
index d369f8689..6e7e80ba7 100644
--- a/win/geo_electric.h
+++ b/win/geo_electric.h
@@ -6,6 +6,7 @@
 #pragma once
 
 #include "types.h"
+#include "window_area.h"
 
 namespace KWin::win
 {
@@ -17,11 +18,11 @@ QRect electric_border_maximize_geometry(Win const* win, QPoint pos, int desktop)
         if (win->maximizeMode() == maximize_mode::full) {
             return win->restore_geometries.maximize;
         } else {
-            return win->space.clientArea(MaximizeArea, pos, desktop);
+            return space_window_area(win->space, MaximizeArea, pos, desktop);
         }
     }
 
-    auto ret = win->space.clientArea(MaximizeArea, pos, desktop);
+    auto ret = space_window_area(win->space, MaximizeArea, pos, desktop);
 
     if (flags(win->control->electric() & win::quicktiles::left)) {
         ret.setRight(ret.left() + ret.width() / 2 - 1);
diff --git a/win/internal_window.cpp b/win/internal_window.cpp
index 0a10387d5..8a3040c2e 100644
--- a/win/internal_window.cpp
+++ b/win/internal_window.cpp
@@ -623,7 +623,8 @@ void internal_window::markAsMapped()
     update_layer(this);
 
     if (placeable()) {
-        auto const area = space.clientArea(PlacementArea, get_current_output(space), desktop());
+        auto const area
+            = space_window_area(space, PlacementArea, get_current_output(space), desktop());
         place(this, area);
     }
 
diff --git a/win/maximize.h b/win/maximize.h
index 12319fa3e..2498a258d 100644
--- a/win/maximize.h
+++ b/win/maximize.h
@@ -50,9 +50,10 @@ QRect get_maximizing_area(Win* win)
     QRect area;
 
     if (win->control->electric_maximizing()) {
-        area = win->space.clientArea(MaximizeArea, input::get_cursor()->pos(), win->desktop());
+        area = space_window_area(
+            win->space, MaximizeArea, input::get_cursor()->pos(), win->desktop());
     } else {
-        area = win->space.clientArea(MaximizeArea, win);
+        area = space_window_area(win->space, MaximizeArea, win);
     }
 
     return area;
diff --git a/win/move.h b/win/move.h
index 8f4b6c85f..53c83f27b 100644
--- a/win/move.h
+++ b/win/move.h
@@ -13,6 +13,7 @@
 #include "space.h"
 #include "stacking.h"
 #include "types.h"
+#include "window_area.h"
 
 #include "base/output_helpers.h"
 #include "base/platform.h"
@@ -135,7 +136,8 @@ void check_unrestricted_move_resize(Win* win)
         return;
     }
 
-    auto desktopArea = win->space.clientArea(WorkArea, mov_res.geometry.center(), win->desktop());
+    auto desktopArea
+        = space_window_area(win->space, WorkArea, mov_res.geometry.center(), win->desktop());
     int left_marge, right_marge, top_marge, bottom_marge, titlebar_marge;
 
     // restricted move/resize - keep at least part of the titlebar always visible
@@ -237,7 +239,7 @@ void check_workspace_position(Win* win,
     }
 
     if (win->geometry_update.fullscreen) {
-        auto area = win->space.clientArea(FullScreenArea, win);
+        auto area = space_window_area(win->space, FullScreenArea, win);
         win->setFrameGeometry(area);
         return;
     }
@@ -246,7 +248,7 @@ void check_workspace_position(Win* win,
         geometry_updates_blocker block(win);
 
         win->update_maximized(win->geometry_update.max_mode);
-        auto const screenArea = win->space.clientArea(ScreenArea, win);
+        auto const screenArea = space_window_area(win->space, ScreenArea, win);
 
         auto geo = pending_frame_geometry(win);
         check_offscreen_position(geo, screenArea);
@@ -280,7 +282,7 @@ void check_workspace_position(Win* win,
     // Old and new maximums have different starting values so windows on the screen
     // edge will move when a new strut is placed on the edge.
     QRect old_screen_area;
-    if (win->space.inUpdateClientArea()) {
+    if (in_update_window_area(win->space)) {
         // we need to find the screen area as it was before the change
         old_screen_area = QRect(0, 0, win->space.oldDisplayWidth(), win->space.oldDisplayHeight());
         int distance = INT_MAX;
@@ -294,7 +296,8 @@ void check_workspace_position(Win* win,
             }
         }
     } else {
-        old_screen_area = win->space.clientArea(ScreenArea, old_frame_geo.center(), oldDesktop);
+        old_screen_area
+            = space_window_area(win->space, ScreenArea, old_frame_geo.center(), oldDesktop);
     }
 
     // With full screen height.
@@ -310,8 +313,8 @@ void check_workspace_position(Win* win,
     auto old_bottom_max = old_screen_area.y() + old_screen_area.height();
     auto old_left_max = old_screen_area.x();
 
-    auto const screenArea
-        = win->space.clientArea(ScreenArea, pending_frame_geometry(win).center(), win->desktop());
+    auto const screenArea = space_window_area(
+        win->space, ScreenArea, pending_frame_geometry(win).center(), win->desktop());
 
     auto top_max = screenArea.y();
     auto right_max = screenArea.x() + screenArea.width();
@@ -335,10 +338,10 @@ void check_workspace_position(Win* win,
 
     // Default is to use restrictedMoveArea. That's on active desktop or screen change.
     auto moveAreaFunc = &space::restrictedMoveArea;
-    if (win->space.inUpdateClientArea()) {
+    if (in_update_window_area(win->space)) {
         // On restriected area changes.
-        // TODO(romangg): This check back on inUpdateClientArea and then setting here internally a
-        //                different function is bad design. Replace with an argument or something.
+        // TODO(romangg): This check back on in_update_window_area and then setting here internally
+        //                a different function is bad design. Replace with an argument or something.
         moveAreaFunc = &space::previousRestrictedMoveArea;
     }
 
@@ -550,7 +553,8 @@ void check_quicktile_maximization_zones(Win* win, int xroot, int yroot)
             return false;
         };
 
-        auto area = win->space.clientArea(MaximizeArea, QPoint(xroot, yroot), win->desktop());
+        auto area
+            = space_window_area(win->space, MaximizeArea, QPoint(xroot, yroot), win->desktop());
         if (kwinApp()->options->electricBorderTiling()) {
             if (xroot <= area.x() + 20) {
                 mode |= quicktiles::left;
@@ -622,7 +626,7 @@ void set_quicktile_mode(Win* win, quicktiles mode, bool keyboard)
         } else {
             win->control->set_quicktiling(quicktiles::maximize);
             set_maximize(win, true, true);
-            auto clientArea = win->space.clientArea(MaximizeArea, win);
+            auto clientArea = space_window_area(win->space, MaximizeArea, win);
 
             if (auto frame_geo = pending_frame_geometry(win); frame_geo.top() != clientArea.top()) {
                 frame_geo.moveTop(clientArea.top());
@@ -982,8 +986,9 @@ auto move_resize_impl(Win* win, int x, int y, int x_root, int y_root)
             // Make sure the titlebar isn't behind a restricted area. We don't need to restrict
             // the other directions. If not visible enough, move the window to the closest valid
             // point. We bruteforce this by slowly moving the window back to its previous position
-            QRegion availableArea(win->space.clientArea(FullArea, nullptr, 0)); // On the screen
-            availableArea -= win->space.restrictedMoveArea(win->desktop());     // Strut areas
+            QRegion availableArea(
+                space_window_area(win->space, FullArea, nullptr, 0));       // On the screen
+            availableArea -= win->space.restrictedMoveArea(win->desktop()); // Strut areas
             bool transposed = false;
             int requiredPixels;
             QRect bTitleRect = titleBarRect(transposed, requiredPixels);
@@ -1097,9 +1102,9 @@ auto move_resize_impl(Win* win, int x, int y, int x_root, int y_root)
             // Special moving of maximized windows on Xinerama screens
             auto output = base::get_nearest_output(kwinApp()->get_base().get_outputs(), globalPos);
             if (win->control->fullscreen())
-                mov_res.geometry = win->space.clientArea(FullScreenArea, output, 0);
+                mov_res.geometry = space_window_area(win->space, FullScreenArea, output, 0);
             else {
-                auto moveResizeGeom = win->space.clientArea(MaximizeArea, output, 0);
+                auto moveResizeGeom = space_window_area(win->space, MaximizeArea, output, 0);
                 auto adjSize = adjusted_frame_size(win, moveResizeGeom.size(), size_mode::max);
                 if (adjSize != moveResizeGeom.size()) {
                     QRect r(moveResizeGeom);
@@ -1121,7 +1126,7 @@ auto move_resize_impl(Win* win, int x, int y, int x_root, int y_root)
                 auto const strut = win->space.restrictedMoveArea(win->desktop());
 
                 // On the screen
-                QRegion availableArea(win->space.clientArea(FullArea, nullptr, 0));
+                QRegion availableArea(space_window_area(win->space, FullArea, nullptr, 0));
 
                 // Strut areas
                 availableArea -= strut;
@@ -1487,8 +1492,8 @@ void send_to_screen(Space const& space, Win* win, Output const& output)
         set_quicktile_mode(win, quicktiles::none, true);
     }
 
-    auto oldScreenArea = space.clientArea(MaximizeArea, win);
-    auto screenArea = space.clientArea(MaximizeArea, checked_output, win->desktop());
+    auto oldScreenArea = space_window_area(space, MaximizeArea, win);
+    auto screenArea = space_window_area(space, MaximizeArea, checked_output, win->desktop());
 
     // the window can have its center so that the position correction moves the new center onto
     // the old screen, what will tile it where it is. Ie. the screen is not changed
diff --git a/win/placement.h b/win/placement.h
index 523b9e8e9..06036bb16 100644
--- a/win/placement.h
+++ b/win/placement.h
@@ -36,6 +36,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "space.h"
 #include "stacking_order.h"
 #include "transient.h"
+#include "window_area.h"
 
 #include <QList>
 #include <QPoint>
@@ -191,7 +192,7 @@ void place(Win* window, const QRect& area, placement policy, placement nextPlace
         QPoint corner = geo.topLeft();
         auto const frameMargins = frame_margins(window);
 
-        const QRect fullRect = window->space.clientArea(FullArea, window);
+        const QRect fullRect = space_window_area(window->space, FullArea, window);
         if (!(window->maximizeMode() & maximize_mode::horizontal)) {
             if (geo.right() == fullRect.right()) {
                 corner.rx() += frameMargins.right();
@@ -556,7 +557,7 @@ void place_on_main_window(Win* window, const QRect& area, placement nextPlacemen
     geom.moveCenter(place_on->geometry_update.frame.center());
     move(window, geom.topLeft());
     // get area again, because the mainwindow may be on different xinerama screen
-    const QRect placementArea = window->space.clientArea(PlacementArea, window);
+    const QRect placementArea = space_window_area(window->space, PlacementArea, window);
     keep_in_area(window, placementArea, false); // make sure it's kept inside workarea
 }
 
@@ -569,7 +570,7 @@ void place_maximizing(Win* window, const QRect& area, placement nextPlacement)
         nextPlacement = placement::smart;
     if (window->isMaximizable() && window->maxSize().width() >= area.width()
         && window->maxSize().height() >= area.height()) {
-        if (window->space.clientArea(MaximizeArea, window) == area)
+        if (space_window_area(window->space, MaximizeArea, window) == area)
             maximize(window, maximize_mode::full);
         else { // if the geometry doesn't match default maximize area (xinerama case?),
             // it's probably better to use the given area
@@ -593,7 +594,7 @@ inline void unclutter_desktop(win::space& space)
             || client->isOnAllDesktops() || !client->isMovable()) {
             continue;
         }
-        const QRect placementArea = space.clientArea(PlacementArea, client);
+        auto const placementArea = space_window_area(space, PlacementArea, client);
         place_smart(client, placementArea);
     }
 }
diff --git a/win/screen_edges.cpp b/win/screen_edges.cpp
index 17275c2ad..be367e0cc 100644
--- a/win/screen_edges.cpp
+++ b/win/screen_edges.cpp
@@ -1341,7 +1341,7 @@ void screen_edger::createEdgeForClient(Toplevel* window, ElectricBorder border)
 
     auto const& outputs = kwinApp()->get_base().get_outputs();
     QRect const geo = window->frameGeometry();
-    QRect const fullArea = space.clientArea(FullArea, 0, 1);
+    auto const fullArea = space_window_area(space, FullArea, 0, 1);
 
     for (auto output : outputs) {
         auto const screen = output->geometry();
diff --git a/win/setup.h b/win/setup.h
index e3654d4ab..9dad6d010 100644
--- a/win/setup.h
+++ b/win/setup.h
@@ -93,11 +93,12 @@ void setup_window_control_connections(Win* win)
                              // Position (geometry?) already set.
                              return;
                          }
-                         geometry_updates_blocker blocker(win);
-
-                         auto const area = win->space.clientArea(
-                             PlacementArea, get_current_output(win->space), win->desktop());
 
+                         geometry_updates_blocker blocker(win);
+                         auto const area = space_window_area(win->space,
+                                                             PlacementArea,
+                                                             get_current_output(win->space),
+                                                             win->desktop());
                          win::place(win, area);
                      });
 
diff --git a/win/space.cpp b/win/space.cpp
index 710f2ce11..cf56b147f 100644
--- a/win/space.cpp
+++ b/win/space.cpp
@@ -27,6 +27,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "output_space.h"
 #include "singleton_interface.h"
 #include "space_areas_helpers.h"
+#include "window_area.h"
 #include "x11/tool_windows.h"
 
 #include "base/dbus/kwin.h"
@@ -480,7 +481,9 @@ void space::desktopResized()
     }
 
     update_space_areas(*this);
-    saveOldScreenSizes(); // after updateClientArea(), so that one still uses the previous one
+
+    // after updateClientArea(), so that one still uses the previous one
+    saveOldScreenSizes();
 
     // TODO: emit a signal instead and remove the deep function calls into edges and effects
     edges->recreateEdges();
@@ -510,66 +513,6 @@ void space::update_space_area_from_windows(QRect const& /*desktop_area*/,
     // Can't be pure virtual because the function might be called from the ctor.
 }
 
-/**
- * Returns the area available for clients. This is the desktop
- * geometry minus windows on the dock. Placement algorithms should
- * refer to this rather than Screens::geometry.
- */
-QRect space::clientArea(clientAreaOption opt, base::output const* output, int desktop) const
-{
-    auto const& outputs = kwinApp()->get_base().get_outputs();
-
-    if (desktop == NETWinInfo::OnAllDesktops || desktop == 0)
-        desktop = virtual_desktop_manager->current();
-    if (!output) {
-        output = get_current_output(*this);
-    }
-
-    QRect output_geo;
-    size_t output_index{0};
-
-    if (output) {
-        output_geo = output->geometry();
-        output_index = base::get_output_index(outputs, *output);
-    }
-
-    auto& base = kwinApp()->get_base();
-    QRect sarea, warea;
-    sarea = (!areas.screen.empty()
-             // screens may be missing during KWin initialization or screen config changes
-             && output_index < areas.screen[desktop].size())
-        ? areas.screen[desktop][output_index]
-        : output_geo;
-    warea = areas.work[desktop].isNull() ? QRect({}, base.topology.size) : areas.work[desktop];
-
-    switch (opt) {
-    case MaximizeArea:
-    case PlacementArea:
-        return sarea;
-    case MaximizeFullArea:
-    case FullScreenArea:
-    case MovementArea:
-    case ScreenArea:
-        return output_geo;
-    case WorkArea:
-        return warea;
-    case FullArea:
-        return QRect({}, base.topology.size);
-    }
-    abort();
-}
-
-QRect space::clientArea(clientAreaOption opt, const QPoint& p, int desktop) const
-{
-    return clientArea(
-        opt, base::get_nearest_output(kwinApp()->get_base().get_outputs(), p), desktop);
-}
-
-QRect space::clientArea(clientAreaOption opt, Toplevel const* window) const
-{
-    return clientArea(opt, win::pending_frame_geometry(window).center(), window->desktop());
-}
-
 static QRegion strutsToRegion(win::space const& space,
                               int desktop,
                               win::strut_area areas,
@@ -596,11 +539,6 @@ QRegion space::restrictedMoveArea(int desktop, win::strut_area areas) const
     return strutsToRegion(*this, desktop, areas, this->areas.restrictedmove);
 }
 
-bool space::inUpdateClientArea() const
-{
-    return !oldrestrictedmovearea.empty();
-}
-
 QRegion space::previousRestrictedMoveArea(int desktop, win::strut_area areas) const
 {
     return strutsToRegion(*this, desktop, areas, oldrestrictedmovearea);
@@ -638,8 +576,8 @@ space::adjustClientPosition(Toplevel* window, QPoint pos, bool unrestricted, dou
     QRect maxRect;
     auto guideMaximized = win::maximize_mode::restore;
     if (window->maximizeMode() != win::maximize_mode::restore) {
-        maxRect = clientArea(
-            MaximizeArea, pos + QRect(QPoint(), window->size()).center(), window->desktop());
+        maxRect = space_window_area(
+            *this, MaximizeArea, pos + QRect(QPoint(), window->size()).center(), window->desktop());
         QRect geo = window->frameGeometry();
         if (flags(window->maximizeMode() & win::maximize_mode::horizontal)
             && (geo.x() == maxRect.left() || geo.right() == maxRect.right())) {
@@ -661,7 +599,7 @@ space::adjustClientPosition(Toplevel* window, QPoint pos, bool unrestricted, dou
             = base::get_nearest_output(outputs, pos + QRect(QPoint(), window->size()).center());
 
         if (maxRect.isNull()) {
-            maxRect = clientArea(MovementArea, output, window->desktop());
+            maxRect = space_window_area(*this, MovementArea, output, window->desktop());
         }
 
         const int xmin = maxRect.left();
@@ -869,8 +807,8 @@ QRect space::adjustClientSize(Toplevel* window, QRect moveResizeGeom, win::posit
         || kwinApp()->options->borderSnapZone()) { // || kwinApp()->options->centerSnapZone )
         const bool sOWO = kwinApp()->options->isSnapOnlyWhenOverlapping();
 
-        auto const maxRect = clientArea(
-            MovementArea, QRect(QPoint(0, 0), window->size()).center(), window->desktop());
+        auto const maxRect = space_window_area(
+            *this, MovementArea, QRect(QPoint(0, 0), window->size()).center(), window->desktop());
         const int xmin = maxRect.left();
         const int xmax = maxRect.right(); // desk size
         const int ymin = maxRect.top();
@@ -1258,12 +1196,14 @@ void space::quickTileWindow(win::quicktiles mode)
 
 int space::packPositionLeft(Toplevel const* window, int oldX, bool leftEdge) const
 {
-    int newX = clientArea(MaximizeArea, window).left();
-    if (oldX <= newX) { // try another Xinerama screen
-        newX = clientArea(MaximizeArea,
-                          QPoint(window->geometry_update.frame.left() - 1,
-                                 window->geometry_update.frame.center().y()),
-                          window->desktop())
+    int newX = space_window_area(*this, MaximizeArea, window).left();
+    if (oldX <= newX) {
+        // try another Xinerama screen
+        newX = space_window_area(*this,
+                                 MaximizeArea,
+                                 QPoint(window->geometry_update.frame.left() - 1,
+                                        window->geometry_update.frame.center().y()),
+                                 window->desktop())
                    .left();
     }
 
@@ -1299,14 +1239,15 @@ int space::packPositionLeft(Toplevel const* window, int oldX, bool leftEdge) con
 
 int space::packPositionRight(Toplevel const* window, int oldX, bool rightEdge) const
 {
-    int newX = clientArea(MaximizeArea, window).right();
+    int newX = space_window_area(*this, MaximizeArea, window).right();
 
     if (oldX >= newX) {
         // try another Xinerama screen
-        newX = clientArea(MaximizeArea,
-                          QPoint(window->geometry_update.frame.right() + 1,
-                                 window->geometry_update.frame.center().y()),
-                          window->desktop())
+        newX = space_window_area(*this,
+                                 MaximizeArea,
+                                 QPoint(window->geometry_update.frame.right() + 1,
+                                        window->geometry_update.frame.center().y()),
+                                 window->desktop())
                    .right();
     }
 
@@ -1342,12 +1283,14 @@ int space::packPositionRight(Toplevel const* window, int oldX, bool rightEdge) c
 
 int space::packPositionUp(Toplevel const* window, int oldY, bool topEdge) const
 {
-    int newY = clientArea(MaximizeArea, window).top();
-    if (oldY <= newY) { // try another Xinerama screen
-        newY = clientArea(MaximizeArea,
-                          QPoint(window->geometry_update.frame.center().x(),
-                                 window->geometry_update.frame.top() - 1),
-                          window->desktop())
+    int newY = space_window_area(*this, MaximizeArea, window).top();
+    if (oldY <= newY) {
+        // try another Xinerama screen
+        newY = space_window_area(*this,
+                                 MaximizeArea,
+                                 QPoint(window->geometry_update.frame.center().x(),
+                                        window->geometry_update.frame.top() - 1),
+                                 window->desktop())
                    .top();
     }
 
@@ -1376,12 +1319,13 @@ int space::packPositionUp(Toplevel const* window, int oldY, bool topEdge) const
 
 int space::packPositionDown(Toplevel const* window, int oldY, bool bottomEdge) const
 {
-    int newY = clientArea(MaximizeArea, window).bottom();
+    int newY = space_window_area(*this, MaximizeArea, window).bottom();
     if (oldY >= newY) { // try another Xinerama screen
-        newY = clientArea(MaximizeArea,
-                          QPoint(window->geometry_update.frame.center().x(),
-                                 window->geometry_update.frame.bottom() + 1),
-                          window->desktop())
+        newY = space_window_area(*this,
+                                 MaximizeArea,
+                                 QPoint(window->geometry_update.frame.center().x(),
+                                        window->geometry_update.frame.bottom() + 1),
+                                 window->desktop())
                    .bottom();
     }
 
@@ -1961,7 +1905,7 @@ void space::setupWindowShortcut(Toplevel* window)
                      qobject.get(),
                      [this](auto&& ok) { setupWindowShortcutDone(ok); });
 
-    auto area = clientArea(ScreenArea, window);
+    auto area = space_window_area(*this, ScreenArea, window);
     auto size = client_keys_dialog->sizeHint();
 
     auto pos = win::frame_to_client_pos(window, window->pos());
diff --git a/win/space.h b/win/space.h
index 3b1e14605..c9e7246fd 100644
--- a/win/space.h
+++ b/win/space.h
@@ -237,10 +237,6 @@ public:
      */
     virtual Toplevel* findInternal(QWindow* w) const = 0;
 
-    QRect clientArea(clientAreaOption, const QPoint& p, int desktop) const;
-    QRect clientArea(clientAreaOption, Toplevel const* window) const;
-    QRect clientArea(clientAreaOption, base::output const* output, int desktop) const;
-
     QRegion restrictedMoveArea(int desktop, win::strut_area areas = win::strut_area::all) const;
 
     void initShortcuts();
diff --git a/win/wayland/layer_shell.h b/win/wayland/layer_shell.h
index d5b4114b0..7cbd35c8a 100644
--- a/win/wayland/layer_shell.h
+++ b/win/wayland/layer_shell.h
@@ -43,7 +43,7 @@ QRectF layer_surface_area(Win* win)
 
     if (layer_surf->exclusive_zone() == 0) {
         auto output_geo_rect = output_geo.toRect();
-        auto area = win->space.clientArea(WorkArea, output_geo_rect.center(), 0);
+        auto area = space_window_area(win->space, WorkArea, output_geo_rect.center(), 0);
         return area.intersected(output_geo_rect);
     }
 
diff --git a/win/wayland/space.cpp b/win/wayland/space.cpp
index fe94f5ecd..c3bf6ea18 100644
--- a/win/wayland/space.cpp
+++ b/win/wayland/space.cpp
@@ -215,8 +215,8 @@ void space::handle_window_added(wayland::window* window)
         window->updateDecoration(false);
         win::update_layer(window);
 
-        auto const area
-            = clientArea(PlacementArea, get_current_output(window->space), window->desktop());
+        auto const area = space_window_area(
+            *this, PlacementArea, get_current_output(window->space), window->desktop());
         auto placementDone = false;
 
         if (window->isInitialPositionSet()) {
diff --git a/win/wayland/window.cpp b/win/wayland/window.cpp
index f218319d6..4c25a0894 100644
--- a/win/wayland/window.cpp
+++ b/win/wayland/window.cpp
@@ -574,8 +574,8 @@ void window::configure_geometry(QRect const& frame_geo)
         auto parent = transient()->lead();
         if (parent) {
             auto const top_lead = lead_of_annexed_transient(this);
-            auto const bounds = space.clientArea(
-                top_lead->control->fullscreen() ? FullScreenArea : PlacementArea, top_lead);
+            auto const bounds = space_window_area(
+                space, top_lead->control->fullscreen() ? FullScreenArea : PlacementArea, top_lead);
 
             serial = popup->configure(
                 get_xdg_shell_popup_placement(this, bounds).translated(-top_lead->pos()));
@@ -655,8 +655,8 @@ void window::apply_pending_geometry()
             return;
         }
 
-        auto const screen_bounds = space.clientArea(
-            toplevel->control->fullscreen() ? FullScreenArea : PlacementArea, toplevel);
+        auto const screen_bounds = space_window_area(
+            space, toplevel->control->fullscreen() ? FullScreenArea : PlacementArea, toplevel);
 
         // Need to set that for get_xdg_shell_popup_placement(..) call.
         // TODO(romangg): make this less akward, i.e. if possible include it in the call.
@@ -962,7 +962,8 @@ void window::handle_commit()
         // Plasma surfaces might set their position late. So check again initial position being set.
         if (must_place && !isInitialPositionSet()) {
             must_place = false;
-            auto const area = space.clientArea(PlacementArea, get_current_output(space), desktop());
+            auto const area
+                = space_window_area(space, PlacementArea, get_current_output(space), desktop());
             placeIn(area);
         }
     } else if (layer_surface) {
diff --git a/win/window_area.h b/win/window_area.h
new file mode 100644
index 000000000..dc59f4fb7
--- /dev/null
+++ b/win/window_area.h
@@ -0,0 +1,96 @@
+/*
+    SPDX-FileCopyrightText: 2022 Roman Gilg <subdiff@gmail.com>
+
+    SPDX-License-Identifier: GPL-2.0-or-later
+*/
+#pragma once
+
+#include "geo.h"
+#include "screen.h"
+
+#include "base/output_helpers.h"
+#include "base/platform.h"
+#include "kwinglobals.h"
+#include "main.h"
+
+#include <NETWM>
+
+namespace KWin::win
+{
+
+template<typename Space>
+bool in_update_window_area(Space const& space)
+{
+    return !space.oldrestrictedmovearea.empty();
+}
+
+/**
+ * Returns the area available for clients. This is the desktop
+ * geometry minus windows on the dock. Placement algorithms should
+ * refer to this rather than Screens::geometry.
+ */
+template<typename Space>
+QRect space_window_area(Space const& space,
+                        clientAreaOption opt,
+                        base::output const* output,
+                        int desktop)
+{
+    auto const& outputs = kwinApp()->get_base().get_outputs();
+
+    if (desktop == NETWinInfo::OnAllDesktops || desktop == 0) {
+        desktop = space.virtual_desktop_manager->current();
+    }
+    if (!output) {
+        output = get_current_output(space);
+    }
+
+    QRect output_geo;
+    size_t output_index{0};
+
+    if (output) {
+        output_geo = output->geometry();
+        output_index = base::get_output_index(outputs, *output);
+    }
+
+    auto& base = kwinApp()->get_base();
+    QRect sarea, warea;
+    sarea = (!space.areas.screen.empty()
+             // screens may be missing during KWin initialization or screen config changes
+             && output_index < space.areas.screen[desktop].size())
+        ? space.areas.screen[desktop][output_index]
+        : output_geo;
+    warea = space.areas.work[desktop].isNull() ? QRect({}, base.topology.size)
+                                               : space.areas.work[desktop];
+
+    switch (opt) {
+    case MaximizeArea:
+    case PlacementArea:
+        return sarea;
+    case MaximizeFullArea:
+    case FullScreenArea:
+    case MovementArea:
+    case ScreenArea:
+        return output_geo;
+    case WorkArea:
+        return warea;
+    case FullArea:
+        return QRect({}, base.topology.size);
+    }
+    abort();
+}
+
+template<typename Space>
+QRect space_window_area(Space const& space, clientAreaOption opt, QPoint const& p, int desktop)
+{
+    return space_window_area(
+        space, opt, base::get_nearest_output(kwinApp()->get_base().get_outputs(), p), desktop);
+}
+
+template<typename Space>
+QRect space_window_area(Space const& space, clientAreaOption opt, Toplevel const* window)
+{
+    return space_window_area(
+        space, opt, pending_frame_geometry(window).center(), window->desktop());
+}
+
+}
diff --git a/win/x11/control.h b/win/x11/control.h
index 5cb1b080c..dbe46ce4e 100644
--- a/win/x11/control.h
+++ b/win/x11/control.h
@@ -139,7 +139,7 @@ public:
         }
         if (rules().checkStrictGeometry(true)) {
             // check geometry constraints (rule to obey is set)
-            const QRect fsarea = m_window->space.clientArea(FullScreenArea, m_window);
+            const QRect fsarea = space_window_area(m_window->space, FullScreenArea, m_window);
             if (size_for_client_size(m_window, fsarea.size(), win::size_mode::any, true)
                 != fsarea.size()) {
                 // the app wouldn't fit exactly fullscreen geometry due to its strict geometry
diff --git a/win/x11/geo.h b/win/x11/geo.h
index 6011e7030..4b8c4b4be 100644
--- a/win/x11/geo.h
+++ b/win/x11/geo.h
@@ -230,12 +230,12 @@ void get_wm_normal_hints(Win* win)
                 && !win->control->fullscreen()) {
                 // try to keep the window in its xinerama screen if possible,
                 // if that fails at least keep it visible somewhere
-                auto area = win->space.clientArea(MovementArea, win);
+                auto area = space_window_area(win->space, MovementArea, win);
                 if (area.contains(orig_client_geo)) {
                     win::keep_in_area(win, area, false);
                 }
 
-                area = win->space.clientArea(WorkArea, win);
+                area = space_window_area(win->space, WorkArea, win);
                 if (area.contains(orig_client_geo)) {
                     win::keep_in_area(win, area, false);
                 }
@@ -683,7 +683,7 @@ void configure_position_size_from_request(Win* win,
 
     win->setFrameGeometry(frame_rect);
 
-    auto area = win->space.clientArea(WorkArea, win);
+    auto area = space_window_area(win->space, WorkArea, win);
 
     if (!from_tool && (!is_special_window(win) || is_toolbar(win)) && !win->control->fullscreen()
         && area.contains(frame_to_client_rect(win, frame_rect))) {
@@ -721,12 +721,12 @@ void configure_only_size_from_request(Win* win,
 
     // TODO(romangg): If this is about Xinerama, can be removed?
 
-    auto area = win->space.clientArea(MovementArea, win);
+    auto area = space_window_area(win->space, MovementArea, win);
     if (area.contains(orig_client_geo)) {
         keep_in_area(win, area, false);
     }
 
-    area = win->space.clientArea(WorkArea, win);
+    area = space_window_area(win->space, WorkArea, win);
     if (area.contains(orig_client_geo)) {
         keep_in_area(win, area, false);
     }
@@ -1024,7 +1024,7 @@ QRect adjusted_client_area(Win const* win, QRect const& desktopArea, QRect const
                           str.bottom_end - str.bottom_start + 1,
                           str.bottom_width);
 
-    auto screenarea = win->space.clientArea(ScreenArea, win);
+    auto screenarea = space_window_area(win->space, ScreenArea, win);
 
     // HACK: workarea handling is not xinerama aware, so if this strut
     // reserves place at a xinerama edge that's inside the virtual screen,
diff --git a/win/x11/placement.h b/win/x11/placement.h
index 3fc343260..c2b0b71b5 100644
--- a/win/x11/placement.h
+++ b/win/x11/placement.h
@@ -33,7 +33,7 @@ bool position_via_hint(Win* win, QRect const& geo, bool ignore_default, QRect& p
     // Window provides its own placement via geometry hint.
 
     // Disobey xinerama placement option for now (#70943)
-    place_area = win->space.clientArea(PlacementArea, geo.center(), win->desktop());
+    place_area = space_window_area(win->space, PlacementArea, geo.center(), win->desktop());
 
     return true;
 }
@@ -51,7 +51,7 @@ bool move_with_force_rule(Win* win, QRect& frame_geo, bool is_inital_placement,
     frame_geo = pending_frame_geometry(win);
 
     // Don't keep inside workarea if the window has specially configured position
-    area = win->space.clientArea(FullArea, frame_geo.center(), win->desktop());
+    area = space_window_area(win->space, FullArea, frame_geo.center(), win->desktop());
     return true;
 }
 
@@ -100,8 +100,9 @@ void place_max_fs(Win* win,
     }
 
     auto const screen_area
-        = win->space.clientArea(ScreenArea, area.center(), win->desktop()).size();
-    auto const full_area = win->space.clientArea(FullArea, frame_geo.center(), win->desktop());
+        = space_window_area(win->space, ScreenArea, area.center(), win->desktop()).size();
+    auto const full_area
+        = space_window_area(win->space, FullArea, frame_geo.center(), win->desktop());
     auto const client_size = frame_to_client_size(win, win->size());
 
     auto pseudo_max{maximize_mode::restore};
@@ -186,7 +187,7 @@ QRect place_mapped(Win* win, QRect& frame_geo)
 {
     auto must_place{false};
 
-    auto area = win->space.clientArea(FullArea, frame_geo.center(), win->desktop());
+    auto area = space_window_area(win->space, FullArea, frame_geo.center(), win->desktop());
     check_offscreen_position(frame_geo, area);
 
     if (must_correct_position(win, frame_geo, area)) {
@@ -214,7 +215,7 @@ QRect place_mapped(Win* win, QRect& frame_geo)
     frame_geo = pending_frame_geometry(win);
 
     // The client may have been moved to another screen, update placement area.
-    area = win->space.clientArea(PlacementArea, win);
+    area = space_window_area(win->space, PlacementArea, win);
 
     place_max_fs(win, frame_geo, area, false, true);
     return area;
@@ -225,7 +226,7 @@ QRect place_session(Win* win, QRect& frame_geo)
 {
     auto must_place{false};
 
-    auto area = win->space.clientArea(FullArea, frame_geo.center(), win->desktop());
+    auto area = space_window_area(win->space, FullArea, frame_geo.center(), win->desktop());
     check_offscreen_position(frame_geo, area);
 
     if (must_correct_position(win, frame_geo, area)) {
@@ -254,7 +255,7 @@ QRect place_session(Win* win, QRect& frame_geo)
     frame_geo = pending_frame_geometry(win);
 
     // The client may have been moved to another screen, update placement area.
-    area = win->space.clientArea(PlacementArea, win);
+    area = space_window_area(win->space, PlacementArea, win);
     frame_geo = keep_in_placement_area(win, area, true);
     return area;
 }
@@ -298,7 +299,7 @@ QRect place_unmapped(Win* win, QRect& frame_geo, KStartupInfoData const& asn_dat
         center = output->geometry().center();
     }
 
-    auto area = win->space.clientArea(PlacementArea, center, win->desktop());
+    auto area = space_window_area(win->space, PlacementArea, center, win->desktop());
 
     // Desktop windows' positions are not placed by us.
     auto must_place = !is_desktop(win);
@@ -324,7 +325,7 @@ QRect place_unmapped(Win* win, QRect& frame_geo, KStartupInfoData const& asn_dat
         frame_geo = pending_frame_geometry(win);
 
         // The client may have been moved to another screen, update placement area.
-        area = win->space.clientArea(PlacementArea, win);
+        area = space_window_area(win->space, PlacementArea, win);
     }
 
     place_max_fs(win, frame_geo, area, false, false);
diff --git a/win/x11/window.cpp b/win/x11/window.cpp
index 4e176c5fe..49c9f968c 100644
--- a/win/x11/window.cpp
+++ b/win/x11/window.cpp
@@ -1111,7 +1111,7 @@ bool window::doStartMoveResize()
     // This reportedly improves smoothness of the moveresize operation,
     // something with Enter/LeaveNotify events, looks like XFree performance problem or something
     // *shrug* (https://lists.kde.org/?t=107302193400001&r=1&w=2)
-    auto r = space.clientArea(FullArea, this);
+    auto r = space_window_area(space, FullArea, this);
 
     xcb_windows.grab.create(r, XCB_WINDOW_CLASS_INPUT_ONLY, 0, nullptr, rootWindow());
     xcb_windows.grab.map();
-- 
GitLab


From 8d51429e16c1900fede6226de39025664a6888b3 Mon Sep 17 00:00:00 2001
From: Roman Gilg <subdiff@gmail.com>
Date: Wed, 6 Jul 2022 10:46:40 +0200
Subject: [PATCH 12/51] refactor: reimplement space move functions as free
 functions

This way it can be reused by different types of spaces.
---
 autotests/integration/screen_edges.cpp |  4 +-
 autotests/integration/struts_test.cpp  | 21 ++++--
 toplevel.cpp                           |  2 +-
 win/activation.h                       | 29 +++++++-
 win/geo_move.h                         | 51 ++++++++++++++
 win/input.h                            |  2 +-
 win/move.h                             | 57 +++++++++++-----
 win/space.cpp                          | 93 ++------------------------
 win/space.h                            | 14 ----
 9 files changed, 141 insertions(+), 132 deletions(-)
 create mode 100644 win/geo_move.h

diff --git a/autotests/integration/screen_edges.cpp b/autotests/integration/screen_edges.cpp
index 24e6a0345..5e5a498f1 100644
--- a/autotests/integration/screen_edges.cpp
+++ b/autotests/integration/screen_edges.cpp
@@ -354,7 +354,7 @@ void TestScreenEdges::testCreatingInitialEdges()
     auto client = Test::app()->workspace->active_client;
     QVERIFY(client);
 
-    Test::app()->workspace->setMoveResizeClient(client);
+    win::set_move_resize_window(*Test::app()->workspace, client);
     for (int i = 0; i < 8; ++i) {
         auto e = edges.at(i);
         QVERIFY(e->reserved_count > 0);
@@ -372,7 +372,7 @@ void TestScreenEdges::testCreatingInitialEdges()
         QCOMPARE(e->activatesForTouchGesture(), false);
         QCOMPARE(e->approach_geometry, expectedGeometries.at(i * 2 + 1));
     }
-    Test::app()->workspace->setMoveResizeClient(nullptr);
+    win::set_move_resize_window(*Test::app()->workspace, nullptr);
 }
 
 void TestScreenEdges::testCallback()
diff --git a/autotests/integration/struts_test.cpp b/autotests/integration/struts_test.cpp
index 9c5231b5d..388217577 100644
--- a/autotests/integration/struts_test.cpp
+++ b/autotests/integration/struts_test.cpp
@@ -221,7 +221,8 @@ void StrutsTest::testWaylandStruts()
              QRect(0, 0, 2560, 1024));
     QCOMPARE(win::space_window_area(*Test::app()->workspace, FullArea, outputs.at(0), 1),
              QRect(0, 0, 2560, 1024));
-    QCOMPARE(Test::app()->workspace->restrictedMoveArea(-1), QRegion());
+    QCOMPARE(win::restricted_move_area(*Test::app()->workspace, -1, win::strut_area::all),
+             QRegion());
 
     struct client_holder {
         win::wayland::window* window;
@@ -292,7 +293,8 @@ void StrutsTest::testWaylandStruts()
     QTEST(win::space_window_area(*Test::app()->workspace, MaximizeArea, outputs.at(1), 1),
           "screen1Maximized");
     QTEST(win::space_window_area(*Test::app()->workspace, WorkArea, outputs.at(0), 1), "workArea");
-    QTEST(Test::app()->workspace->restrictedMoveArea(-1), "restrictedMoveArea");
+    QTEST(win::restricted_move_area(*Test::app()->workspace, -1, win::strut_area::all),
+          "restrictedMoveArea");
 
     // delete all surfaces
     for (auto& client : clients) {
@@ -301,7 +303,8 @@ void StrutsTest::testWaylandStruts()
         client = {};
         QVERIFY(destroyedSpy.wait());
     }
-    QCOMPARE(Test::app()->workspace->restrictedMoveArea(-1), QRegion());
+    QCOMPARE(win::restricted_move_area(*Test::app()->workspace, -1, win::strut_area::all),
+             QRegion());
 }
 
 void StrutsTest::testMoveWaylandPanel()
@@ -562,7 +565,8 @@ void StrutsTest::testX11Struts()
              QRect(0, 0, 2560, 1024));
     QCOMPARE(win::space_window_area(*Test::app()->workspace, FullArea, outputs.at(0), 1),
              QRect(0, 0, 2560, 1024));
-    QCOMPARE(Test::app()->workspace->restrictedMoveArea(-1), QRegion());
+    QCOMPARE(win::restricted_move_area(*Test::app()->workspace, -1, win::strut_area::all),
+             QRegion());
 
     // create an xcb window
     auto c = create_xcb_connection();
@@ -667,7 +671,8 @@ void StrutsTest::testX11Struts()
     QTEST(win::space_window_area(*Test::app()->workspace, MaximizeArea, outputs.at(1), 1),
           "screen1Maximized");
     QTEST(win::space_window_area(*Test::app()->workspace, WorkArea, outputs.at(0), 1), "workArea");
-    QTEST(Test::app()->workspace->restrictedMoveArea(-1), "restrictedMoveArea");
+    QTEST(win::restricted_move_area(*Test::app()->workspace, -1, win::strut_area::all),
+          "restrictedMoveArea");
 
     // and destroy the window again
     xcb_unmap_window(c.get(), w);
@@ -712,7 +717,8 @@ void StrutsTest::testX11Struts()
              QRect(0, 0, 2560, 1024));
     QCOMPARE(win::space_window_area(*Test::app()->workspace, FullArea, outputs.at(0), 1),
              QRect(0, 0, 2560, 1024));
-    QCOMPARE(Test::app()->workspace->restrictedMoveArea(-1), QRegion());
+    QCOMPARE(win::restricted_move_area(*Test::app()->workspace, -1, win::strut_area::all),
+             QRegion());
 }
 
 void StrutsTest::test363804()
@@ -1018,7 +1024,8 @@ void StrutsTest::testWindowMoveWithPanelBetweenScreens()
              QRect(1390, 0, 1656, 1050));
     QCOMPARE(win::space_window_area(*Test::app()->workspace, WorkArea, outputs.at(0), 1),
              QRect(0, 0, 3046, 1050));
-    QCOMPARE(Test::app()->workspace->restrictedMoveArea(-1), QRegion(1366, 0, 24, 1050));
+    QCOMPARE(win::restricted_move_area(*Test::app()->workspace, -1, win::strut_area::all),
+             QRegion(1366, 0, 24, 1050));
 
     // create another window and try to move it
     xcb_window_t w2 = xcb_generate_id(c.get());
diff --git a/toplevel.cpp b/toplevel.cpp
index 4854260a7..763886ac6 100644
--- a/toplevel.cpp
+++ b/toplevel.cpp
@@ -842,7 +842,7 @@ void Toplevel::doPerformMoveResize()
 
 void Toplevel::leaveMoveResize()
 {
-    space.setMoveResizeClient(nullptr);
+    win::set_move_resize_window(space, nullptr);
     control->move_resize().enabled = false;
     if (space.edges->desktop_switching.when_moving_client) {
         space.edges->reserveDesktopSwitching(false, Qt::Vertical|Qt::Horizontal);
diff --git a/win/activation.h b/win/activation.h
index 3ac9d69d0..488a6264f 100644
--- a/win/activation.h
+++ b/win/activation.h
@@ -279,6 +279,31 @@ void focus_to_null(Space& space)
     }
 }
 
+template<typename Space>
+Toplevel* window_under_mouse(Space const& space, base::output const* output)
+{
+    auto it = space.stacking_order->stack.cend();
+
+    while (it != space.stacking_order->stack.cbegin()) {
+        auto window = *(--it);
+        if (!window->control) {
+            continue;
+        }
+
+        // Rule out windows which are not really visible.
+        // The screen test is rather superfluous for xrandr & twinview since the geometry would
+        // differ. -> TODO: might be dropped
+        if (!(window->isShown() && window->isOnCurrentDesktop() && on_screen(window, output)))
+            continue;
+
+        if (window->frameGeometry().contains(input::get_cursor()->pos())) {
+            return window;
+        }
+    }
+
+    return nullptr;
+}
+
 template<typename Win>
 void set_demands_attention(Win* win, bool demand)
 {
@@ -512,8 +537,8 @@ bool activate_next_window(Space& space, Toplevel* window)
     }
 
     if (!get_focus && kwinApp()->options->isNextFocusPrefersMouse()) {
-        get_focus
-            = space.clientUnderMouse(window ? window->central_output : get_current_output(space));
+        get_focus = window_under_mouse(space,
+                                       window ? window->central_output : get_current_output(space));
         if (get_focus && (get_focus == window || is_desktop(get_focus))) {
             // should rather not happen, but it cannot get the focus. rest of usability is tested
             // above
diff --git a/win/geo_move.h b/win/geo_move.h
new file mode 100644
index 000000000..98592f1e3
--- /dev/null
+++ b/win/geo_move.h
@@ -0,0 +1,51 @@
+/*
+    SPDX-FileCopyrightText: 2022 Roman Gilg <subdiff@gmail.com>
+
+    SPDX-License-Identifier: GPL-2.0-or-later
+*/
+#pragma once
+
+#include "strut_rect.h"
+#include "types.h"
+
+#include <NETWM>
+#include <QRegion>
+
+namespace KWin::win
+{
+
+template<typename Space>
+QRegion struts_to_region(Space const& space,
+                         int desktop,
+                         win::strut_area areas,
+                         std::vector<win::strut_rects> const& struts)
+{
+    if (desktop == NETWinInfo::OnAllDesktops || desktop == 0) {
+        desktop = space.virtual_desktop_manager->current();
+    }
+
+    QRegion region;
+    auto const& rects = struts[desktop];
+
+    for (auto const& rect : rects) {
+        if (flags(areas & rect.area())) {
+            region += rect;
+        }
+    }
+
+    return region;
+}
+
+template<typename Space>
+QRegion restricted_move_area(Space const& space, int desktop, win::strut_area areas)
+{
+    return struts_to_region(space, desktop, areas, space.areas.restrictedmove);
+}
+
+template<typename Space>
+QRegion previous_restricted_move_area(Space const& space, int desktop, win::strut_area areas)
+{
+    return struts_to_region(space, desktop, areas, space.oldrestrictedmovearea);
+}
+
+}
diff --git a/win/input.h b/win/input.h
index 31f734eb6..8d61a147a 100644
--- a/win/input.h
+++ b/win/input.h
@@ -96,7 +96,7 @@ bool perform_mouse_command(Win& win, base::options::MouseCommand cmd, QPoint con
         // Used to be activateNextClient(win), then topClientOnDesktop
         // since win is a mouseOp it's however safe to use the client under the mouse instead.
         if (win.control->active() && kwinApp()->options->focusPolicyIsReasonable()) {
-            auto next = space.clientUnderMouse(win.central_output);
+            auto next = window_under_mouse(space, win.central_output);
             if (next && next != &win) {
                 request_focus(space, next);
             }
diff --git a/win/move.h b/win/move.h
index 53c83f27b..25c47b269 100644
--- a/win/move.h
+++ b/win/move.h
@@ -9,6 +9,7 @@
 #include "geo_block.h"
 #include "geo_change.h"
 #include "geo_electric.h"
+#include "geo_move.h"
 #include "net.h"
 #include "space.h"
 #include "stacking.h"
@@ -65,6 +66,22 @@ position mouse_position(Win* win)
     }
 }
 
+template<typename Space>
+void set_move_resize_window(Space& space, Toplevel* window)
+{
+    // Catch attempts to move a second
+    assert(!window || !space.movingClient);
+
+    // window while still moving the first one.
+    space.movingClient = window;
+
+    if (space.movingClient) {
+        ++space.block_focus;
+    } else {
+        --space.block_focus;
+    }
+}
+
 template<typename Win>
 void update_cursor(Win* win)
 {
@@ -284,9 +301,10 @@ void check_workspace_position(Win* win,
     QRect old_screen_area;
     if (in_update_window_area(win->space)) {
         // we need to find the screen area as it was before the change
-        old_screen_area = QRect(0, 0, win->space.oldDisplayWidth(), win->space.oldDisplayHeight());
+        old_screen_area
+            = QRect(0, 0, win->space.olddisplaysize.width(), win->space.olddisplaysize.height());
         int distance = INT_MAX;
-        for (auto const& r : win->space.previousScreenSizes()) {
+        for (auto const& r : win->space.oldscreensizes) {
             int d = r.contains(old_frame_geo.center())
                 ? 0
                 : (r.center() - old_frame_geo.center()).manhattanLength();
@@ -337,34 +355,34 @@ void check_workspace_position(Win* win,
     // the bottom struts bounded by the window's left and right sides).
 
     // Default is to use restrictedMoveArea. That's on active desktop or screen change.
-    auto moveAreaFunc = &space::restrictedMoveArea;
+    auto move_area_func = win::restricted_move_area<decltype(win->space)>;
     if (in_update_window_area(win->space)) {
         // On restriected area changes.
         // TODO(romangg): This check back on in_update_window_area and then setting here internally
         //                a different function is bad design. Replace with an argument or something.
-        moveAreaFunc = &space::previousRestrictedMoveArea;
+        move_area_func = win::previous_restricted_move_area<decltype(win->space)>;
     }
 
     // These 4 compute old bounds.
-    for (auto const& r : (win->space.*moveAreaFunc)(oldDesktop, strut_area::top)) {
+    for (auto const& r : move_area_func(win->space, oldDesktop, strut_area::top)) {
         auto rect = r & old_tall_frame_geo;
         if (!rect.isEmpty()) {
             old_top_max = std::max(old_top_max, rect.y() + rect.height());
         }
     }
-    for (auto const& r : (win->space.*moveAreaFunc)(oldDesktop, strut_area::right)) {
+    for (auto const& r : move_area_func(win->space, oldDesktop, strut_area::right)) {
         auto rect = r & old_wide_frame_geo;
         if (!rect.isEmpty()) {
             old_right_max = std::min(old_right_max, rect.x());
         }
     }
-    for (auto const& r : (win->space.*moveAreaFunc)(oldDesktop, strut_area::bottom)) {
+    for (auto const& r : move_area_func(win->space, oldDesktop, strut_area::bottom)) {
         auto rect = r & old_tall_frame_geo;
         if (!rect.isEmpty()) {
             old_bottom_max = std::min(old_bottom_max, rect.y());
         }
     }
-    for (auto const& r : (win->space.*moveAreaFunc)(oldDesktop, strut_area::left)) {
+    for (auto const& r : move_area_func(win->space, oldDesktop, strut_area::left)) {
         auto rect = r & old_wide_frame_geo;
         if (!rect.isEmpty()) {
             old_left_max = std::max(old_left_max, rect.x() + rect.width());
@@ -372,25 +390,25 @@ void check_workspace_position(Win* win,
     }
 
     // These 4 compute new bounds.
-    for (auto const& r : win->space.restrictedMoveArea(win->desktop(), strut_area::top)) {
+    for (auto const& r : restricted_move_area(win->space, win->desktop(), strut_area::top)) {
         auto rect = r & tall_frame_geo;
         if (!rect.isEmpty()) {
             top_max = std::max(top_max, rect.y() + rect.height());
         }
     }
-    for (auto const& r : win->space.restrictedMoveArea(win->desktop(), strut_area::right)) {
+    for (auto const& r : restricted_move_area(win->space, win->desktop(), strut_area::right)) {
         auto rect = r & wide_frame_geo;
         if (!rect.isEmpty()) {
             right_max = std::min(right_max, rect.x());
         }
     }
-    for (auto const& r : win->space.restrictedMoveArea(win->desktop(), strut_area::bottom)) {
+    for (auto const& r : restricted_move_area(win->space, win->desktop(), strut_area::bottom)) {
         auto rect = r & tall_frame_geo;
         if (!rect.isEmpty()) {
             bottom_max = std::min(bottom_max, rect.y());
         }
     }
-    for (auto const& r : win->space.restrictedMoveArea(win->desktop(), strut_area::left)) {
+    for (auto const& r : restricted_move_area(win->space, win->desktop(), strut_area::left)) {
         auto rect = r & wide_frame_geo;
         if (!rect.isEmpty()) {
             left_max = std::max(left_max, rect.x() + rect.width());
@@ -845,7 +863,7 @@ bool start_move_resize(Win* win)
     }
 
     mov_res.enabled = true;
-    win->space.setMoveResizeClient(win);
+    set_move_resize_window(win->space, win);
 
     win->control->update_have_resize_effect();
 
@@ -986,9 +1004,13 @@ auto move_resize_impl(Win* win, int x, int y, int x_root, int y_root)
             // Make sure the titlebar isn't behind a restricted area. We don't need to restrict
             // the other directions. If not visible enough, move the window to the closest valid
             // point. We bruteforce this by slowly moving the window back to its previous position
-            QRegion availableArea(
-                space_window_area(win->space, FullArea, nullptr, 0));       // On the screen
-            availableArea -= win->space.restrictedMoveArea(win->desktop()); // Strut areas
+
+            // On the screen
+            QRegion availableArea(space_window_area(win->space, FullArea, nullptr, 0));
+
+            // Strut areas
+            availableArea -= restricted_move_area(win->space, win->desktop(), strut_area::all);
+
             bool transposed = false;
             int requiredPixels;
             QRect bTitleRect = titleBarRect(transposed, requiredPixels);
@@ -1123,7 +1145,8 @@ auto move_resize_impl(Win* win, int x, int y, int x_root, int y_root)
 
             if (!mov_res.unrestricted) {
                 // Strut areas
-                auto const strut = win->space.restrictedMoveArea(win->desktop());
+                auto const strut
+                    = restricted_move_area(win->space, win->desktop(), strut_area::all);
 
                 // On the screen
                 QRegion availableArea(space_window_area(win->space, FullArea, nullptr, 0));
diff --git a/win/space.cpp b/win/space.cpp
index cf56b147f..7b51d703d 100644
--- a/win/space.cpp
+++ b/win/space.cpp
@@ -513,52 +513,6 @@ void space::update_space_area_from_windows(QRect const& /*desktop_area*/,
     // Can't be pure virtual because the function might be called from the ctor.
 }
 
-static QRegion strutsToRegion(win::space const& space,
-                              int desktop,
-                              win::strut_area areas,
-                              std::vector<win::strut_rects> const& struts)
-{
-    if (desktop == NETWinInfo::OnAllDesktops || desktop == 0) {
-        desktop = space.virtual_desktop_manager->current();
-    }
-
-    QRegion region;
-    auto const& rects = struts[desktop];
-
-    for (auto const& rect : rects) {
-        if (flags(areas & rect.area())) {
-            region += rect;
-        }
-    }
-
-    return region;
-}
-
-QRegion space::restrictedMoveArea(int desktop, win::strut_area areas) const
-{
-    return strutsToRegion(*this, desktop, areas, this->areas.restrictedmove);
-}
-
-QRegion space::previousRestrictedMoveArea(int desktop, win::strut_area areas) const
-{
-    return strutsToRegion(*this, desktop, areas, oldrestrictedmovearea);
-}
-
-std::vector<QRect> space::previousScreenSizes() const
-{
-    return oldscreensizes;
-}
-
-int space::oldDisplayWidth() const
-{
-    return olddisplaysize.width();
-}
-
-int space::oldDisplayHeight() const
-{
-    return olddisplaysize.height();
-}
-
 /**
  * Client \a c is moved around to position \a pos. This gives the
  * space:: the opportunity to interveniate and to implement
@@ -1026,21 +980,6 @@ QRect space::adjustClientSize(Toplevel* window, QRect moveResizeGeom, win::posit
     return moveResizeGeom;
 }
 
-/**
- * Marks the client as being moved or resized by the user.
- */
-void space::setMoveResizeClient(Toplevel* window)
-{
-    Q_ASSERT(!window || !movingClient); // Catch attempts to move a second
-    // window while still moving the first one.
-    movingClient = window;
-    if (movingClient) {
-        ++block_focus;
-    } else {
-        --block_focus;
-    }
-}
-
 // When kwin crashes, windows will not be gravitated back to their original position
 // and will remain offset by the size of the decoration. So when restarting, fix this
 // (the property with the size of the frame remains on the window after the crash).
@@ -1373,28 +1312,6 @@ void space::clientHidden(Toplevel* window)
     activate_next_window(*this, window);
 }
 
-Toplevel* space::clientUnderMouse(base::output const* output) const
-{
-    auto it = stacking_order->stack.cend();
-    while (it != stacking_order->stack.cbegin()) {
-        auto client = *(--it);
-        if (!client->control) {
-            continue;
-        }
-
-        // rule out clients which are not really visible.
-        // the screen test is rather superfluous for xrandr & twinview since the geometry would
-        // differ -> TODO: might be dropped
-        if (!(client->isShown() && client->isOnCurrentDesktop() && win::on_screen(client, output)))
-            continue;
-
-        if (client->frameGeometry().contains(input::get_cursor()->pos())) {
-            return client;
-        }
-    }
-    return nullptr;
-}
-
 void space::gotFocusIn(Toplevel const* window)
 {
     if (std::find(should_get_focus.cbegin(), should_get_focus.cend(), const_cast<Toplevel*>(window))
@@ -2243,7 +2160,7 @@ void space::slotWindowLower()
         // activateNextClient( c ); // Doesn't work when we lower a child window
         if (active_client->control->active() && kwinApp()->options->focusPolicyIsReasonable()) {
             if (kwinApp()->options->isNextFocusPrefersMouse()) {
-                auto next = clientUnderMouse(active_client->central_output);
+                auto next = window_under_mouse(*this, active_client->central_output);
                 if (next && next != active_client)
                     request_focus(*this, next);
             } else {
@@ -2316,9 +2233,9 @@ void windowToDesktop(Toplevel& window)
     // TODO: why is kwinApp()->options->isRollOverDesktops() not honored?
     const auto desktop = functor(nullptr, true);
     if (!win::is_desktop(&window) && !win::is_dock(&window)) {
-        ws.setMoveResizeClient(&window);
+        set_move_resize_window(ws, &window);
         vds->setCurrent(desktop);
-        ws.setMoveResizeClient(nullptr);
+        set_move_resize_window(ws, nullptr);
     }
 }
 
@@ -2360,9 +2277,9 @@ void activeClientToDesktop(win::space& space)
     if (d == current) {
         return;
     }
-    space.setMoveResizeClient(space.active_client);
+    set_move_resize_window(space, space.active_client);
     vds->setCurrent(d);
-    space.setMoveResizeClient(nullptr);
+    set_move_resize_window(space, nullptr);
 }
 
 void space::slotWindowToDesktopRight()
diff --git a/win/space.h b/win/space.h
index c9e7246fd..2e19fd232 100644
--- a/win/space.h
+++ b/win/space.h
@@ -237,13 +237,9 @@ public:
      */
     virtual Toplevel* findInternal(QWindow* w) const = 0;
 
-    QRegion restrictedMoveArea(int desktop, win::strut_area areas = win::strut_area::all) const;
-
     void initShortcuts();
     bool initializing() const;
 
-    Toplevel* clientUnderMouse(base::output const* output) const;
-
     bool allowClientActivation(Toplevel const* window,
                                xcb_timestamp_t time = -1U,
                                bool focus_in = false,
@@ -252,11 +248,6 @@ public:
     void gotFocusIn(Toplevel const* window);
     void setShouldGetFocus(Toplevel* window);
 
-    /**
-     * Indicates that the client c is being moved or resized by the user.
-     */
-    void setMoveResizeClient(Toplevel* window);
-
     QPoint
     adjustClientPosition(Toplevel* window, QPoint pos, bool unrestricted, double snapAdjust = 1.0);
     QRect adjustClientSize(Toplevel* window, QRect moveResizeGeom, win::position mode);
@@ -304,11 +295,6 @@ public:
     // True when performing space::updateClientArea().
     // The calls below are valid only in that case.
     bool inUpdateClientArea() const;
-    QRegion previousRestrictedMoveArea(int desktop,
-                                       win::strut_area areas = win::strut_area::all) const;
-    std::vector<QRect> previousScreenSizes() const;
-    int oldDisplayWidth() const;
-    int oldDisplayHeight() const;
 
     Toplevel* active_client{nullptr};
 
-- 
GitLab


From a86de248b0df78684ba01845dab304100009dcb4 Mon Sep 17 00:00:00 2001
From: Roman Gilg <subdiff@gmail.com>
Date: Wed, 6 Jul 2022 11:16:27 +0200
Subject: [PATCH 13/51] refactor: reimplement space session functions as free
 functions

This way it can be reused by different types of spaces.
---
 win/session.h     | 373 ++++++++++++++++++++++++++++++++++++++++++++++
 win/space.cpp     | 369 ++-------------------------------------------
 win/space.h       |  10 --
 win/x11/control.h |   3 +-
 4 files changed, 387 insertions(+), 368 deletions(-)
 create mode 100644 win/session.h

diff --git a/win/session.h b/win/session.h
new file mode 100644
index 000000000..f4d63046d
--- /dev/null
+++ b/win/session.h
@@ -0,0 +1,373 @@
+/*
+    SPDX-FileCopyrightText: 2022 Roman Gilg <subdiff@gmail.com>
+
+    SPDX-License-Identifier: GPL-2.0-or-later
+*/
+#pragma once
+
+#include "session_manager.h"
+#include "x11/geo.h"
+
+#include "utils/algorithm.h"
+
+#include <KConfig>
+#include <KConfigGroup>
+
+namespace KWin::win
+{
+
+static inline KConfig* get_session_config(QString const& id, QString const& key)
+{
+    static KConfig* config = nullptr;
+    static QString lastId;
+    static QString lastKey;
+    static auto pattern = QString(QLatin1String("session/%1_%2_%3")).arg(qApp->applicationName());
+
+    if (id != lastId || key != lastKey) {
+        delete config;
+        config = nullptr;
+    }
+
+    lastId = id;
+    lastKey = key;
+
+    if (!config) {
+        config = new KConfig(pattern.arg(id).arg(key), KConfig::SimpleConfig);
+    }
+
+    return config;
+}
+
+static const char* const window_type_names[] = {"Unknown",
+                                                "Normal",
+                                                "Desktop",
+                                                "Dock",
+                                                "Toolbar",
+                                                "Menu",
+                                                "Dialog",
+                                                "Override",
+                                                "TopMenu",
+                                                "Utility",
+                                                "Splash"};
+// change also the two functions below when adding new entries
+
+static inline char const* window_type_to_txt(NET::WindowType type)
+{
+    if (type >= NET::Unknown && type <= NET::Splash) {
+        // +1 (unknown==-1)
+        return window_type_names[type + 1];
+    }
+
+    if (type == -2) {
+        // undefined (not really part of NET::WindowType)
+        return "Undefined";
+    }
+
+    qFatal("Unknown Window Type");
+    return nullptr;
+}
+
+static inline NET::WindowType txt_to_window_type(const char* txt)
+{
+    for (int i = NET::Unknown; i <= NET::Splash; ++i) {
+        // Compare with window_type_names at i+1.
+        if (qstrcmp(txt, window_type_names[i + 1]) == 0) {
+            return static_cast<NET::WindowType>(i);
+        }
+    }
+
+    // undefined
+    return static_cast<NET::WindowType>(-2);
+}
+
+/**
+ * Stores the current session in the config file
+ *
+ * @see loadSessionInfo
+ */
+template<typename Space>
+void store_session(Space& space, QString const& sessionName, sm_save_phase phase)
+{
+    qCDebug(KWIN_CORE) << "storing session" << sessionName << "in phase" << phase;
+    KConfig* config = get_session_config(sessionName, QString());
+
+    KConfigGroup cg(config, "Session");
+    int count = 0;
+    int active_client = -1;
+
+    for (auto const& window : space.m_windows) {
+        if (!window->control) {
+            continue;
+        }
+        auto x11_client = qobject_cast<x11::window*>(window);
+        if (!x11_client) {
+            continue;
+        }
+
+        if (x11_client->windowType() > NET::Splash) {
+            // window types outside this are not tooltips/menus/OSDs
+            // typically these will be unmanaged and not in this list anyway, but that is not
+            // enforced
+            continue;
+        }
+
+        QByteArray sessionId = x11_client->sessionId();
+        QByteArray wmCommand = x11_client->wmCommand();
+
+        if (sessionId.isEmpty()) {
+            // remember also applications that are not XSMP capable
+            // and use the obsolete WM_COMMAND / WM_SAVE_YOURSELF
+            if (wmCommand.isEmpty()) {
+                continue;
+            }
+        }
+
+        count++;
+        if (x11_client->control->active()) {
+            active_client = count;
+        }
+
+        if (phase == sm_save_phase2 || phase == sm_save_phase2_full) {
+            store_window(space, cg, count, x11_client);
+        }
+    }
+
+    if (phase == sm_save_phase0) {
+        // it would be much simpler to save these values to the config file,
+        // but both Qt and KDE treat phase1 and phase2 separately,
+        // which results in different sessionkey and different config file :(
+        space.session_active_client = active_client;
+        space.session_desktop = space.virtual_desktop_manager->current();
+    } else if (phase == sm_save_phase2) {
+        cg.writeEntry("count", count);
+        cg.writeEntry("active", space.session_active_client);
+        cg.writeEntry("desktop", space.session_desktop);
+    } else {
+        // SMSavePhase2Full
+        cg.writeEntry("count", count);
+        cg.writeEntry("active", space.session_active_client);
+        cg.writeEntry("desktop", space.virtual_desktop_manager->current());
+    }
+
+    // it previously did some "revert to defaults" stuff for phase1 I think
+    config->sync();
+}
+
+template<typename Space, typename Win>
+void store_window(Space const& space, KConfigGroup& cg, int num, Win* c)
+{
+    QString n = QString::number(num);
+    cg.writeEntry(QLatin1String("sessionId") + n, c->sessionId().constData());
+    cg.writeEntry(QLatin1String("windowRole") + n, c->windowRole().constData());
+    cg.writeEntry(QLatin1String("wmCommand") + n, c->wmCommand().constData());
+    cg.writeEntry(QLatin1String("resourceName") + n, c->resource_name.constData());
+    cg.writeEntry(QLatin1String("resourceClass") + n, c->resource_class.constData());
+    cg.writeEntry(QLatin1String("geometry") + n,
+                  QRect(x11::calculate_gravitation(c, true), frame_to_client_size(c, c->size())));
+    cg.writeEntry(QLatin1String("restore") + n, c->restore_geometries.maximize);
+    cg.writeEntry(QLatin1String("fsrestore") + n, c->restore_geometries.maximize);
+    cg.writeEntry(QLatin1String("maximize") + n, static_cast<int>(c->maximizeMode()));
+    cg.writeEntry(QLatin1String("fullscreen") + n, static_cast<int>(c->control->fullscreen()));
+    cg.writeEntry(QLatin1String("desktop") + n, c->desktop());
+
+    // the config entry is called "iconified" for back. comp. reasons
+    // (kconf_update script for updating session files would be too complicated)
+    cg.writeEntry(QLatin1String("iconified") + n, c->control->minimized());
+    cg.writeEntry(QLatin1String("opacity") + n, c->opacity());
+
+    // the config entry is called "sticky" for back. comp. reasons
+    cg.writeEntry(QLatin1String("sticky") + n, c->isOnAllDesktops());
+
+    // the config entry is called "staysOnTop" for back. comp. reasons
+    cg.writeEntry(QLatin1String("staysOnTop") + n, c->control->keep_above());
+    cg.writeEntry(QLatin1String("keepBelow") + n, c->control->keep_below());
+    cg.writeEntry(QLatin1String("skipTaskbar") + n, c->control->original_skip_taskbar());
+    cg.writeEntry(QLatin1String("skipPager") + n, c->control->skip_pager());
+    cg.writeEntry(QLatin1String("skipSwitcher") + n, c->control->skip_switcher());
+
+    // not really just set by user, but name kept for back. comp. reasons
+    cg.writeEntry(QLatin1String("userNoBorder") + n, c->user_no_border);
+    cg.writeEntry(QLatin1String("windowType") + n, window_type_to_txt(c->windowType()));
+    cg.writeEntry(QLatin1String("shortcut") + n, c->control->shortcut().toString());
+    cg.writeEntry(QLatin1String("stackingOrder") + n,
+                  static_cast<int>(index_of(space.stacking_order->pre_stack, c)));
+}
+
+template<typename Space>
+void store_subsession(Space const& space, QString const& name, QSet<QByteArray> sessionIds)
+{
+    // TODO clear it first
+    KConfigGroup cg(KSharedConfig::openConfig(), QLatin1String("SubSession: ") + name);
+    int count = 0;
+    int active_client = -1;
+
+    for (auto const& window : space.m_windows) {
+        if (!window->control) {
+            continue;
+        }
+
+        auto x11_client = qobject_cast<win::x11::window*>(window);
+        if (!x11_client) {
+            continue;
+        }
+        if (x11_client->windowType() > NET::Splash) {
+            continue;
+        }
+
+        QByteArray sessionId = x11_client->sessionId();
+        QByteArray wmCommand = x11_client->wmCommand();
+        if (sessionId.isEmpty()) {
+            // remember also applications that are not XSMP capable
+            // and use the obsolete WM_COMMAND / WM_SAVE_YOURSELF
+            if (wmCommand.isEmpty()) {
+                continue;
+            }
+        }
+        if (!sessionIds.contains(sessionId)) {
+            continue;
+        }
+
+        qCDebug(KWIN_CORE) << "storing" << sessionId;
+        count++;
+
+        if (x11_client->control->active()) {
+            active_client = count;
+        }
+        store_window(space, cg, count, x11_client);
+    }
+
+    cg.writeEntry("count", count);
+    cg.writeEntry("active", active_client);
+    // cg.writeEntry( "desktop", currentDesktop());
+}
+
+/**
+ * Loads the session information from the config file.
+ *
+ * @see storeSession
+ */
+template<typename Space>
+void load_session_info(Space& space, QString const& sessionName)
+{
+    space.session.clear();
+    KConfigGroup cg(get_session_config(sessionName, QString()), "Session");
+    add_session_info(space, cg);
+}
+
+template<typename Space>
+void add_session_info(Space& space, KConfigGroup& cg)
+{
+    space.m_initialDesktop = cg.readEntry("desktop", 1);
+    int count = cg.readEntry("count", 0);
+    int active_client = cg.readEntry("active", 0);
+
+    for (int i = 1; i <= count; i++) {
+        QString n = QString::number(i);
+        auto info = new win::session_info;
+        space.session.push_back(info);
+        info->sessionId = cg.readEntry(QLatin1String("sessionId") + n, QString()).toLatin1();
+        info->windowRole = cg.readEntry(QLatin1String("windowRole") + n, QString()).toLatin1();
+        info->wmCommand = cg.readEntry(QLatin1String("wmCommand") + n, QString()).toLatin1();
+        info->resourceName = cg.readEntry(QLatin1String("resourceName") + n, QString()).toLatin1();
+        info->resourceClass
+            = cg.readEntry(QLatin1String("resourceClass") + n, QString()).toLower().toLatin1();
+        info->geometry = cg.readEntry(QLatin1String("geometry") + n, QRect());
+        info->restore = cg.readEntry(QLatin1String("restore") + n, QRect());
+        info->fsrestore = cg.readEntry(QLatin1String("fsrestore") + n, QRect());
+        info->maximized = cg.readEntry(QLatin1String("maximize") + n, 0);
+        info->fullscreen = cg.readEntry(QLatin1String("fullscreen") + n, 0);
+        info->desktop = cg.readEntry(QLatin1String("desktop") + n, 0);
+        info->minimized = cg.readEntry(QLatin1String("iconified") + n, false);
+        info->opacity = cg.readEntry(QLatin1String("opacity") + n, 1.0);
+        info->onAllDesktops = cg.readEntry(QLatin1String("sticky") + n, false);
+        info->keepAbove = cg.readEntry(QLatin1String("staysOnTop") + n, false);
+        info->keepBelow = cg.readEntry(QLatin1String("keepBelow") + n, false);
+        info->skipTaskbar = cg.readEntry(QLatin1String("skipTaskbar") + n, false);
+        info->skipPager = cg.readEntry(QLatin1String("skipPager") + n, false);
+        info->skipSwitcher = cg.readEntry(QLatin1String("skipSwitcher") + n, false);
+        info->noBorder = cg.readEntry(QLatin1String("userNoBorder") + n, false);
+        info->windowType = txt_to_window_type(
+            cg.readEntry(QLatin1String("windowType") + n, QString()).toLatin1().constData());
+        info->shortcut = cg.readEntry(QLatin1String("shortcut") + n, QString());
+        info->active = (active_client == i);
+        info->stackingOrder = cg.readEntry(QLatin1String("stackingOrder") + n, -1);
+    }
+}
+
+template<typename Space>
+void load_subsession_info(Space& space, QString const& name)
+{
+    KConfigGroup cg(KSharedConfig::openConfig(), QLatin1String("SubSession: ") + name);
+    add_session_info(space, cg);
+}
+
+template<typename Win>
+static bool session_info_window_type_match(Win const& c, win::session_info* info)
+{
+    if (info->windowType == -2) {
+        // undefined (not really part of NET::WindowType)
+        return !is_special_window(c);
+    }
+    return info->windowType == c->windowType();
+}
+
+/**
+ * Returns a SessionInfo for client \a c. The returned session
+ * info is removed from the storage. It's up to the caller to delete it.
+ *
+ * This function is called when a new window is mapped and must be managed.
+ * We try to find a matching entry in the session.
+ *
+ * May return 0 if there's no session info for the client.
+ */
+template<typename Space, typename Win>
+session_info* take_session_info(Space& space, Win* c)
+{
+    win::session_info* realInfo = nullptr;
+    QByteArray sessionId = c->sessionId();
+    QByteArray windowRole = c->windowRole();
+    QByteArray wmCommand = c->wmCommand();
+    auto const& resourceName = c->resource_name;
+    auto const& resourceClass = c->resource_class;
+
+    // First search ``session''
+    if (!sessionId.isEmpty()) {
+        // look for a real session managed client (algorithm suggested by ICCCM)
+        for (auto const& info : space.session) {
+            if (realInfo) {
+                break;
+            }
+            if (info->sessionId == sessionId && session_info_window_type_match(c, info)) {
+                if (!windowRole.isEmpty()) {
+                    if (info->windowRole == windowRole) {
+                        realInfo = info;
+                        remove_all(space.session, info);
+                    }
+                } else {
+                    if (info->windowRole.isEmpty() && info->resourceName == resourceName
+                        && info->resourceClass == resourceClass) {
+                        realInfo = info;
+                        remove_all(space.session, info);
+                    }
+                }
+            }
+        }
+    } else {
+        // look for a sessioninfo with matching features.
+        for (auto const& info : space.session) {
+            if (realInfo) {
+                break;
+            }
+            if (info->resourceName == resourceName && info->resourceClass == resourceClass
+                && session_info_window_type_match(c, info)) {
+                if (wmCommand.isEmpty() || info->wmCommand == wmCommand) {
+                    realInfo = info;
+                    remove_all(space.session, info);
+                }
+            }
+        }
+    }
+    return realInfo;
+}
+
+}
diff --git a/win/space.cpp b/win/space.cpp
index 7b51d703d..09cb181b4 100644
--- a/win/space.cpp
+++ b/win/space.cpp
@@ -25,6 +25,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "deco/bridge.h"
 #include "desktop_space.h"
 #include "output_space.h"
+#include "session.h"
 #include "singleton_interface.h"
 #include "space_areas_helpers.h"
 #include "window_area.h"
@@ -80,8 +81,6 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 // TODO(romangg): For now this needs to be included late because of some conflict with Qt libraries.
 #include "space_reconfigure.h"
 
-#include <KConfig>
-#include <KConfigGroup>
 #include <KGlobalAccel>
 #include <KLazyLocalizedString>
 #include <KLocalizedString>
@@ -150,15 +149,17 @@ space::space(render::compositor& render)
     QObject::connect(session_manager.get(),
                      &win::session_manager::loadSessionRequested,
                      qobject.get(),
-                     [this](auto&& session_name) { loadSessionInfo(session_name); });
-    QObject::connect(session_manager.get(),
-                     &win::session_manager::prepareSessionSaveRequested,
-                     qobject.get(),
-                     [this](const QString& name) { storeSession(name, win::sm_save_phase0); });
-    QObject::connect(session_manager.get(),
-                     &win::session_manager::finishSessionSaveRequested,
-                     qobject.get(),
-                     [this](const QString& name) { storeSession(name, win::sm_save_phase2); });
+                     [this](auto&& session_name) { load_session_info(*this, session_name); });
+    QObject::connect(
+        session_manager.get(),
+        &win::session_manager::prepareSessionSaveRequested,
+        qobject.get(),
+        [this](const QString& name) { store_session(*this, name, win::sm_save_phase0); });
+    QObject::connect(
+        session_manager.get(),
+        &win::session_manager::finishSessionSaveRequested,
+        qobject.get(),
+        [this](const QString& name) { store_session(*this, name, win::sm_save_phase2); });
 
     auto& base = kwinApp()->get_base();
     QObject::connect(
@@ -2490,350 +2491,4 @@ bool space::shortcutAvailable(const QKeySequence& cut, Toplevel* ignore) const
     return true;
 }
 
-static KConfig* sessionConfig(QString id, QString key)
-{
-    static KConfig* config = nullptr;
-    static QString lastId;
-    static QString lastKey;
-    static QString pattern
-        = QString(QLatin1String("session/%1_%2_%3")).arg(qApp->applicationName());
-
-    if (id != lastId || key != lastKey) {
-        delete config;
-        config = nullptr;
-    }
-
-    lastId = id;
-    lastKey = key;
-
-    if (!config) {
-        config = new KConfig(pattern.arg(id).arg(key), KConfig::SimpleConfig);
-    }
-
-    return config;
-}
-
-static const char* const window_type_names[] = {"Unknown",
-                                                "Normal",
-                                                "Desktop",
-                                                "Dock",
-                                                "Toolbar",
-                                                "Menu",
-                                                "Dialog",
-                                                "Override",
-                                                "TopMenu",
-                                                "Utility",
-                                                "Splash"};
-// change also the two functions below when adding new entries
-
-static const char* windowTypeToTxt(NET::WindowType type)
-{
-    if (type >= NET::Unknown && type <= NET::Splash) {
-        // +1 (unknown==-1)
-        return window_type_names[type + 1];
-    }
-
-    if (type == -2) {
-        // undefined (not really part of NET::WindowType)
-        return "Undefined";
-    }
-
-    qFatal("Unknown Window Type");
-    return nullptr;
-}
-
-static NET::WindowType txtToWindowType(const char* txt)
-{
-    for (int i = NET::Unknown; i <= NET::Splash; ++i) {
-        // Compare with window_type_names at i+1.
-        if (qstrcmp(txt, window_type_names[i + 1]) == 0) {
-            return static_cast<NET::WindowType>(i);
-        }
-    }
-
-    // undefined
-    return static_cast<NET::WindowType>(-2);
-}
-
-/**
- * Stores the current session in the config file
- *
- * @see loadSessionInfo
- */
-void space::storeSession(const QString& sessionName, win::sm_save_phase phase)
-{
-    qCDebug(KWIN_CORE) << "storing session" << sessionName << "in phase" << phase;
-    KConfig* config = sessionConfig(sessionName, QString());
-
-    KConfigGroup cg(config, "Session");
-    int count = 0;
-    int active_client = -1;
-
-    for (auto const& window : m_windows) {
-        if (!window->control) {
-            continue;
-        }
-        auto x11_client = qobject_cast<x11::window*>(window);
-        if (!x11_client) {
-            continue;
-        }
-
-        if (x11_client->windowType() > NET::Splash) {
-            // window types outside this are not tooltips/menus/OSDs
-            // typically these will be unmanaged and not in this list anyway, but that is not
-            // enforced
-            continue;
-        }
-
-        QByteArray sessionId = x11_client->sessionId();
-        QByteArray wmCommand = x11_client->wmCommand();
-
-        if (sessionId.isEmpty()) {
-            // remember also applications that are not XSMP capable
-            // and use the obsolete WM_COMMAND / WM_SAVE_YOURSELF
-            if (wmCommand.isEmpty()) {
-                continue;
-            }
-        }
-
-        count++;
-        if (x11_client->control->active()) {
-            active_client = count;
-        }
-
-        if (phase == win::sm_save_phase2 || phase == win::sm_save_phase2_full) {
-            storeClient(cg, count, x11_client);
-        }
-    }
-
-    if (phase == win::sm_save_phase0) {
-        // it would be much simpler to save these values to the config file,
-        // but both Qt and KDE treat phase1 and phase2 separately,
-        // which results in different sessionkey and different config file :(
-        session_active_client = active_client;
-        session_desktop = virtual_desktop_manager->current();
-    } else if (phase == win::sm_save_phase2) {
-        cg.writeEntry("count", count);
-        cg.writeEntry("active", session_active_client);
-        cg.writeEntry("desktop", session_desktop);
-    } else {
-        // SMSavePhase2Full
-        cg.writeEntry("count", count);
-        cg.writeEntry("active", session_active_client);
-        cg.writeEntry("desktop", virtual_desktop_manager->current());
-    }
-
-    // it previously did some "revert to defaults" stuff for phase1 I think
-    config->sync();
-}
-
-void space::storeClient(KConfigGroup& cg, int num, win::x11::window* c)
-{
-    QString n = QString::number(num);
-    cg.writeEntry(QLatin1String("sessionId") + n, c->sessionId().constData());
-    cg.writeEntry(QLatin1String("windowRole") + n, c->windowRole().constData());
-    cg.writeEntry(QLatin1String("wmCommand") + n, c->wmCommand().constData());
-    cg.writeEntry(QLatin1String("resourceName") + n, c->resource_name.constData());
-    cg.writeEntry(QLatin1String("resourceClass") + n, c->resource_class.constData());
-    cg.writeEntry(
-        QLatin1String("geometry") + n,
-        QRect(win::x11::calculate_gravitation(c, true), win::frame_to_client_size(c, c->size())));
-    cg.writeEntry(QLatin1String("restore") + n, c->restore_geometries.maximize);
-    cg.writeEntry(QLatin1String("fsrestore") + n, c->restore_geometries.maximize);
-    cg.writeEntry(QLatin1String("maximize") + n, static_cast<int>(c->maximizeMode()));
-    cg.writeEntry(QLatin1String("fullscreen") + n, static_cast<int>(c->control->fullscreen()));
-    cg.writeEntry(QLatin1String("desktop") + n, c->desktop());
-
-    // the config entry is called "iconified" for back. comp. reasons
-    // (kconf_update script for updating session files would be too complicated)
-    cg.writeEntry(QLatin1String("iconified") + n, c->control->minimized());
-    cg.writeEntry(QLatin1String("opacity") + n, c->opacity());
-
-    // the config entry is called "sticky" for back. comp. reasons
-    cg.writeEntry(QLatin1String("sticky") + n, c->isOnAllDesktops());
-
-    // the config entry is called "staysOnTop" for back. comp. reasons
-    cg.writeEntry(QLatin1String("staysOnTop") + n, c->control->keep_above());
-    cg.writeEntry(QLatin1String("keepBelow") + n, c->control->keep_below());
-    cg.writeEntry(QLatin1String("skipTaskbar") + n, c->control->original_skip_taskbar());
-    cg.writeEntry(QLatin1String("skipPager") + n, c->control->skip_pager());
-    cg.writeEntry(QLatin1String("skipSwitcher") + n, c->control->skip_switcher());
-
-    // not really just set by user, but name kept for back. comp. reasons
-    cg.writeEntry(QLatin1String("userNoBorder") + n, c->user_no_border);
-    cg.writeEntry(QLatin1String("windowType") + n, windowTypeToTxt(c->windowType()));
-    cg.writeEntry(QLatin1String("shortcut") + n, c->control->shortcut().toString());
-    cg.writeEntry(QLatin1String("stackingOrder") + n,
-                  static_cast<int>(index_of(stacking_order->pre_stack, c)));
-}
-
-void space::storeSubSession(const QString& name, QSet<QByteArray> sessionIds)
-{
-    // TODO clear it first
-    KConfigGroup cg(KSharedConfig::openConfig(), QLatin1String("SubSession: ") + name);
-    int count = 0;
-    int active_client = -1;
-
-    for (auto const& window : m_windows) {
-        if (!window->control) {
-            continue;
-        }
-
-        auto x11_client = qobject_cast<win::x11::window*>(window);
-        if (!x11_client) {
-            continue;
-        }
-        if (x11_client->windowType() > NET::Splash) {
-            continue;
-        }
-
-        QByteArray sessionId = x11_client->sessionId();
-        QByteArray wmCommand = x11_client->wmCommand();
-        if (sessionId.isEmpty()) {
-            // remember also applications that are not XSMP capable
-            // and use the obsolete WM_COMMAND / WM_SAVE_YOURSELF
-            if (wmCommand.isEmpty()) {
-                continue;
-            }
-        }
-        if (!sessionIds.contains(sessionId)) {
-            continue;
-        }
-
-        qCDebug(KWIN_CORE) << "storing" << sessionId;
-        count++;
-
-        if (x11_client->control->active()) {
-            active_client = count;
-        }
-        storeClient(cg, count, x11_client);
-    }
-
-    cg.writeEntry("count", count);
-    cg.writeEntry("active", active_client);
-    // cg.writeEntry( "desktop", currentDesktop());
-}
-
-/**
- * Loads the session information from the config file.
- *
- * @see storeSession
- */
-void space::loadSessionInfo(const QString& sessionName)
-{
-    session.clear();
-    KConfigGroup cg(sessionConfig(sessionName, QString()), "Session");
-    addSessionInfo(cg);
-}
-
-void space::addSessionInfo(KConfigGroup& cg)
-{
-    m_initialDesktop = cg.readEntry("desktop", 1);
-    int count = cg.readEntry("count", 0);
-    int active_client = cg.readEntry("active", 0);
-
-    for (int i = 1; i <= count; i++) {
-        QString n = QString::number(i);
-        auto info = new win::session_info;
-        session.push_back(info);
-        info->sessionId = cg.readEntry(QLatin1String("sessionId") + n, QString()).toLatin1();
-        info->windowRole = cg.readEntry(QLatin1String("windowRole") + n, QString()).toLatin1();
-        info->wmCommand = cg.readEntry(QLatin1String("wmCommand") + n, QString()).toLatin1();
-        info->resourceName = cg.readEntry(QLatin1String("resourceName") + n, QString()).toLatin1();
-        info->resourceClass
-            = cg.readEntry(QLatin1String("resourceClass") + n, QString()).toLower().toLatin1();
-        info->geometry = cg.readEntry(QLatin1String("geometry") + n, QRect());
-        info->restore = cg.readEntry(QLatin1String("restore") + n, QRect());
-        info->fsrestore = cg.readEntry(QLatin1String("fsrestore") + n, QRect());
-        info->maximized = cg.readEntry(QLatin1String("maximize") + n, 0);
-        info->fullscreen = cg.readEntry(QLatin1String("fullscreen") + n, 0);
-        info->desktop = cg.readEntry(QLatin1String("desktop") + n, 0);
-        info->minimized = cg.readEntry(QLatin1String("iconified") + n, false);
-        info->opacity = cg.readEntry(QLatin1String("opacity") + n, 1.0);
-        info->onAllDesktops = cg.readEntry(QLatin1String("sticky") + n, false);
-        info->keepAbove = cg.readEntry(QLatin1String("staysOnTop") + n, false);
-        info->keepBelow = cg.readEntry(QLatin1String("keepBelow") + n, false);
-        info->skipTaskbar = cg.readEntry(QLatin1String("skipTaskbar") + n, false);
-        info->skipPager = cg.readEntry(QLatin1String("skipPager") + n, false);
-        info->skipSwitcher = cg.readEntry(QLatin1String("skipSwitcher") + n, false);
-        info->noBorder = cg.readEntry(QLatin1String("userNoBorder") + n, false);
-        info->windowType = txtToWindowType(
-            cg.readEntry(QLatin1String("windowType") + n, QString()).toLatin1().constData());
-        info->shortcut = cg.readEntry(QLatin1String("shortcut") + n, QString());
-        info->active = (active_client == i);
-        info->stackingOrder = cg.readEntry(QLatin1String("stackingOrder") + n, -1);
-    }
-}
-
-void space::loadSubSessionInfo(const QString& name)
-{
-    KConfigGroup cg(KSharedConfig::openConfig(), QLatin1String("SubSession: ") + name);
-    addSessionInfo(cg);
-}
-
-static bool sessionInfoWindowTypeMatch(win::x11::window* c, win::session_info* info)
-{
-    if (info->windowType == -2) {
-        // undefined (not really part of NET::WindowType)
-        return !win::is_special_window(c);
-    }
-    return info->windowType == c->windowType();
-}
-
-/**
- * Returns a SessionInfo for client \a c. The returned session
- * info is removed from the storage. It's up to the caller to delete it.
- *
- * This function is called when a new window is mapped and must be managed.
- * We try to find a matching entry in the session.
- *
- * May return 0 if there's no session info for the client.
- */
-win::session_info* space::takeSessionInfo(win::x11::window* c)
-{
-    win::session_info* realInfo = nullptr;
-    QByteArray sessionId = c->sessionId();
-    QByteArray windowRole = c->windowRole();
-    QByteArray wmCommand = c->wmCommand();
-    auto const& resourceName = c->resource_name;
-    auto const& resourceClass = c->resource_class;
-
-    // First search ``session''
-    if (!sessionId.isEmpty()) {
-        // look for a real session managed client (algorithm suggested by ICCCM)
-        for (auto const& info : session) {
-            if (realInfo)
-                break;
-            if (info->sessionId == sessionId && sessionInfoWindowTypeMatch(c, info)) {
-                if (!windowRole.isEmpty()) {
-                    if (info->windowRole == windowRole) {
-                        realInfo = info;
-                        remove_all(session, info);
-                    }
-                } else {
-                    if (info->windowRole.isEmpty() && info->resourceName == resourceName
-                        && info->resourceClass == resourceClass) {
-                        realInfo = info;
-                        remove_all(session, info);
-                    }
-                }
-            }
-        }
-    } else {
-        // look for a sessioninfo with matching features.
-        for (auto const& info : session) {
-            if (realInfo)
-                break;
-            if (info->resourceName == resourceName && info->resourceClass == resourceClass
-                && sessionInfoWindowTypeMatch(c, info)) {
-                if (wmCommand.isEmpty() || info->wmCommand == wmCommand) {
-                    realInfo = info;
-                    remove_all(session, info);
-                }
-            }
-        }
-    }
-    return realInfo;
-}
-
 }
diff --git a/win/space.h b/win/space.h
index 2e19fd232..944018845 100644
--- a/win/space.h
+++ b/win/space.h
@@ -313,13 +313,6 @@ public:
     void updateOnAllDesktopsOfTransients(Toplevel* window);
     void checkTransients(Toplevel* window);
 
-    void storeSession(const QString& sessionName, win::sm_save_phase phase);
-    void storeClient(KConfigGroup& cg, int num, win::x11::window* c);
-    void storeSubSession(const QString& name, QSet<QByteArray> sessionIds);
-    void loadSubSessionInfo(const QString& name);
-
-    win::session_info* takeSessionInfo(win::x11::window*);
-
     void setShowingDesktop(bool showing);
     bool showingDesktop() const;
 
@@ -456,9 +449,6 @@ public:
 
     QWidget* active_popup{nullptr};
 
-    void loadSessionInfo(const QString& sessionName);
-    void addSessionInfo(KConfigGroup& cg);
-
     std::vector<win::session_info*> session;
 
     // Delay(ed) window focus timer and client
diff --git a/win/x11/control.h b/win/x11/control.h
index dbe46ce4e..398a0bb24 100644
--- a/win/x11/control.h
+++ b/win/x11/control.h
@@ -20,6 +20,7 @@
 #include "base/logging.h"
 #include "win/input.h"
 #include "win/layers.h"
+#include "win/session.h"
 
 #if KWIN_BUILD_TABBOX
 #include "win/tabbox/tabbox.h"
@@ -444,7 +445,7 @@ auto create_controlled_window(xcb_window_t xcb_win, bool isMapped, Space& space)
 
     update_layer(win);
 
-    auto session = space.takeSessionInfo(win);
+    auto session = take_session_info(space, win);
     if (session) {
         init_minimize = session->minimized;
         win->user_no_border = session->noBorder;
-- 
GitLab


From f52526c2b5957f20aba7b10ff8c0eb23bf0ed58c Mon Sep 17 00:00:00 2001
From: Roman Gilg <subdiff@gmail.com>
Date: Wed, 6 Jul 2022 20:14:29 +0200
Subject: [PATCH 14/51] refactor: reimplement space active window functions as
 free functions

This way they can be reused by different types of spaces.
---
 autotests/integration/activation_test.cpp     |   9 +-
 .../effects/maximize_animation_test.cpp       |   5 +-
 .../integration/effects/translucency_test.cpp |   2 +-
 .../integration/globalshortcuts_test.cpp      |   3 +-
 autotests/integration/lockscreen.cpp          |   3 +-
 autotests/integration/maximize_test.cpp       |   9 +-
 .../integration/move_resize_window_test.cpp   |  61 +-
 autotests/integration/quick_tiling_test.cpp   |   5 +-
 .../integration/scripting/screenedge_test.cpp |   6 +-
 .../integration/showing_desktop_test.cpp      |   9 +-
 autotests/integration/struts_test.cpp         |   2 +-
 autotests/integration/x11_client_test.cpp     |  11 +-
 .../integration/xdgshellclient_rules_test.cpp |  29 +-
 autotests/integration/xdgshellclient_test.cpp |  19 +-
 base/dbus/kwin.h                              |   3 +-
 render/effects.cpp                            |   2 +-
 scripting/space.h                             | 224 ++++--
 win/activation.h                              |  64 ++
 win/active_window.h                           | 391 +++++++++
 win/deco/client_impl.cpp                      |   7 +-
 win/desktop_space.h                           |  31 +-
 win/input.h                                   |   9 +-
 win/kill_window.h                             |   9 +
 win/output_space.h                            |  70 ++
 win/screen_edges.cpp                          |   3 +-
 win/space.cpp                                 | 753 ++----------------
 win/space.h                                   |  59 --
 win/tabbox/tabbox.cpp                         |   5 +-
 win/user_actions_menu.h                       |   3 +-
 win/util.h                                    |  14 +
 win/wayland/plasma_window.h                   |   4 +-
 win/wayland/window.cpp                        |   2 +-
 win/window_operation.h                        | 113 +++
 win/x11/netinfo.cpp                           |   2 +-
 win/x11/space_setup.h                         |   2 +-
 win/x11/window.cpp                            |   2 +-
 36 files changed, 1058 insertions(+), 887 deletions(-)
 create mode 100644 win/active_window.h
 create mode 100644 win/window_operation.h

diff --git a/autotests/integration/activation_test.cpp b/autotests/integration/activation_test.cpp
index 8cf4f3b6f..575b66428 100644
--- a/autotests/integration/activation_test.cpp
+++ b/autotests/integration/activation_test.cpp
@@ -21,6 +21,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
 #include "base/wayland/server.h"
 #include "input/cursor.h"
+#include "win/active_window.h"
 #include "win/control.h"
 #include "win/move.h"
 #include "win/space.h"
@@ -370,7 +371,7 @@ void ActivationTest::testSwitchToWindowMaximized()
     QVERIFY(client1->control->active());
     QSignalSpy configureRequestedSpy1(shellSurface1.get(), &XdgShellToplevel::configureRequested);
     QVERIFY(configureRequestedSpy1.wait());
-    Test::app()->workspace->slotWindowMaximize();
+    win::active_window_maximize(*Test::app()->workspace);
     QVERIFY(configureRequestedSpy1.wait());
     QSignalSpy geometryChangedSpy1(client1, &win::wayland::window::frame_geometry_changed);
     QVERIFY(geometryChangedSpy1.isValid());
@@ -386,7 +387,7 @@ void ActivationTest::testSwitchToWindowMaximized()
     QVERIFY(client2->control->active());
     QSignalSpy configureRequestedSpy2(shellSurface2.get(), &XdgShellToplevel::configureRequested);
     QVERIFY(configureRequestedSpy2.wait());
-    Test::app()->workspace->slotWindowMaximize();
+    win::active_window_maximize(*Test::app()->workspace);
     QVERIFY(configureRequestedSpy2.wait());
     QSignalSpy geometryChangedSpy2(client2, &win::wayland::window::frame_geometry_changed);
     QVERIFY(geometryChangedSpy2.isValid());
@@ -456,7 +457,7 @@ void ActivationTest::testSwitchToWindowFullScreen()
     QVERIFY(client1->control->active());
     QSignalSpy configureRequestedSpy1(shellSurface1.get(), &XdgShellToplevel::configureRequested);
     QVERIFY(configureRequestedSpy1.wait());
-    Test::app()->workspace->slotWindowFullScreen();
+    win::active_window_set_fullscreen(*Test::app()->workspace);
     QVERIFY(configureRequestedSpy1.wait());
     QSignalSpy geometryChangedSpy1(client1, &win::wayland::window::frame_geometry_changed);
     QVERIFY(geometryChangedSpy1.isValid());
@@ -471,7 +472,7 @@ void ActivationTest::testSwitchToWindowFullScreen()
     QVERIFY(client2->control->active());
     QSignalSpy configureRequestedSpy2(shellSurface2.get(), &XdgShellToplevel::configureRequested);
     QVERIFY(configureRequestedSpy2.wait());
-    Test::app()->workspace->slotWindowFullScreen();
+    win::active_window_set_fullscreen(*Test::app()->workspace);
     QVERIFY(configureRequestedSpy2.wait());
     QSignalSpy geometryChangedSpy2(client2, &win::wayland::window::frame_geometry_changed);
     QVERIFY(geometryChangedSpy2.isValid());
diff --git a/autotests/integration/effects/maximize_animation_test.cpp b/autotests/integration/effects/maximize_animation_test.cpp
index 688f58837..6c6d93bad 100644
--- a/autotests/integration/effects/maximize_animation_test.cpp
+++ b/autotests/integration/effects/maximize_animation_test.cpp
@@ -24,6 +24,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "render/effects.h"
 #include "render/scene.h"
 #include "toplevel.h"
+#include "win/active_window.h"
 #include "win/control.h"
 #include "win/space.h"
 #include "win/wayland/window.h"
@@ -146,7 +147,7 @@ void MaximizeAnimationTest::testMaximizeRestore()
         qOverload<Toplevel*, bool, bool>(&win::wayland::window::clientMaximizedStateChanged));
     QVERIFY(maximizeChangedSpy.isValid());
 
-    Test::app()->workspace->slotWindowMaximize();
+    win::active_window_maximize(*Test::app()->workspace);
     QVERIFY(configureRequestedSpy.wait());
     QCOMPARE(configureRequestedSpy.count(), 3);
     QCOMPARE(configureRequestedSpy.last().at(0).value<QSize>(), QSize(1280, 1024));
@@ -167,7 +168,7 @@ void MaximizeAnimationTest::testMaximizeRestore()
     QTRY_VERIFY(!effect->isActive());
 
     // Restore the client.
-    Test::app()->workspace->slotWindowMaximize();
+    win::active_window_maximize(*Test::app()->workspace);
     QVERIFY(configureRequestedSpy.wait());
     QCOMPARE(configureRequestedSpy.count(), 4);
     QCOMPARE(configureRequestedSpy.last().at(0).value<QSize>(), QSize(100, 50));
diff --git a/autotests/integration/effects/translucency_test.cpp b/autotests/integration/effects/translucency_test.cpp
index 7c922afea..69024c482 100644
--- a/autotests/integration/effects/translucency_test.cpp
+++ b/autotests/integration/effects/translucency_test.cpp
@@ -176,7 +176,7 @@ void TranslucencyTest::testMoveAfterDesktopChange()
     effects->setCurrentDesktop(2);
     QVERIFY(!m_translucencyEffect->isActive());
     input::get_cursor()->set_pos(client->frameGeometry().center());
-    Test::app()->workspace->performWindowOperation(client, base::options::MoveOp);
+    win::perform_window_operation(*Test::app()->workspace, client, base::options::MoveOp);
     QVERIFY(m_translucencyEffect->isActive());
     QTest::qWait(200);
     QVERIFY(m_translucencyEffect->isActive());
diff --git a/autotests/integration/globalshortcuts_test.cpp b/autotests/integration/globalshortcuts_test.cpp
index 5cf7238ed..536011028 100644
--- a/autotests/integration/globalshortcuts_test.cpp
+++ b/autotests/integration/globalshortcuts_test.cpp
@@ -23,6 +23,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "input/cursor.h"
 #include "input/keyboard_redirect.h"
 #include "input/xkb/helpers.h"
+#include "win/active_window.h"
 #include "win/input.h"
 #include "win/internal_window.h"
 #include "win/meta.h"
@@ -460,7 +461,7 @@ void GlobalShortcutsTest::testSetupWindowShortcut()
     QSignalSpy shortcutDialogAddedSpy(Test::app()->workspace->qobject.get(),
                                       &win::space::qobject_t::internalClientAdded);
     QVERIFY(shortcutDialogAddedSpy.isValid());
-    Test::app()->workspace->slotSetupWindowShortcut();
+    win::active_window_setup_window_shortcut(*Test::app()->workspace);
     QTRY_COMPARE(shortcutDialogAddedSpy.count(), 1);
     auto dialog = shortcutDialogAddedSpy.first().first().value<win::internal_window*>();
     QVERIFY(dialog);
diff --git a/autotests/integration/lockscreen.cpp b/autotests/integration/lockscreen.cpp
index d54845c42..ac7db16cf 100644
--- a/autotests/integration/lockscreen.cpp
+++ b/autotests/integration/lockscreen.cpp
@@ -25,6 +25,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "render/compositor.h"
 #include "render/scene.h"
 #include "toplevel.h"
+#include "win/active_window.h"
 #include "win/move.h"
 #include "win/screen.h"
 #include "win/screen_edges.h"
@@ -605,7 +606,7 @@ void LockScreenTest::testMoveWindow()
     QVERIFY(clientStepUserMovedResizedSpy.isValid());
     quint32 timestamp = 1;
 
-    Test::app()->workspace->slotWindowMove();
+    win::active_window_move(*Test::app()->workspace);
     QCOMPARE(Test::app()->workspace->moveResizeClient(), c);
     QVERIFY(win::is_move(c));
 
diff --git a/autotests/integration/maximize_test.cpp b/autotests/integration/maximize_test.cpp
index bc7e70335..3314a8914 100644
--- a/autotests/integration/maximize_test.cpp
+++ b/autotests/integration/maximize_test.cpp
@@ -21,6 +21,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
 #include "base/wayland/server.h"
 #include "input/cursor.h"
+#include "win/active_window.h"
 #include "win/deco.h"
 #include "win/deco/bridge.h"
 #include "win/deco/settings.h"
@@ -134,7 +135,7 @@ void TestMaximized::testMaximizedPassedToDeco()
     QSignalSpy geometryShapeChangedSpy(client, &Toplevel::frame_geometry_changed);
     QVERIFY(geometryShapeChangedSpy.isValid());
 
-    Test::app()->workspace->slotWindowMaximize();
+    win::active_window_maximize(*Test::app()->workspace);
     QVERIFY(configureRequestedSpy.wait());
     QCOMPARE(configureRequestedSpy.count(), 2);
     QCOMPARE(configureRequestedSpy.last().at(0).toSize(),
@@ -156,7 +157,7 @@ void TestMaximized::testMaximizedPassedToDeco()
     QVERIFY(decoration->borderTop() != 0);
 
     // now unmaximize again
-    Test::app()->workspace->slotWindowMaximize();
+    win::active_window_maximize(*Test::app()->workspace);
     QVERIFY(configureRequestedSpy.wait());
     QCOMPARE(configureRequestedSpy.count(), 3);
     QCOMPARE(configureRequestedSpy.last().at(0).toSize(), QSize(100, 50));
@@ -319,7 +320,7 @@ void TestMaximized::testBorderlessMaximizedWindow()
 
     // Maximize the client.
     const QRect maximizeRestoreGeometry = client->frameGeometry();
-    Test::app()->workspace->slotWindowMaximize();
+    win::active_window_maximize(*Test::app()->workspace);
     QVERIFY(configureRequestedSpy.wait());
     QCOMPARE(configureRequestedSpy.count(), 3);
     QCOMPARE(configureRequestedSpy.last().at(0).toSize(), QSize(1280, 1024));
@@ -338,7 +339,7 @@ void TestMaximized::testBorderlessMaximizedWindow()
     QVERIFY(!win::decoration(client));
 
     // Restore the client.
-    Test::app()->workspace->slotWindowMaximize();
+    win::active_window_maximize(*Test::app()->workspace);
     QVERIFY(configureRequestedSpy.wait());
     QCOMPARE(configureRequestedSpy.count(), 4);
     QCOMPARE(configureRequestedSpy.last().at(0).toSize(), QSize(100, 50));
diff --git a/autotests/integration/move_resize_window_test.cpp b/autotests/integration/move_resize_window_test.cpp
index 59ed44497..1fc279e92 100644
--- a/autotests/integration/move_resize_window_test.cpp
+++ b/autotests/integration/move_resize_window_test.cpp
@@ -24,6 +24,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "input/cursor.h"
 #include "render/effects.h"
 #include "toplevel.h"
+#include "win/active_window.h"
 #include "win/input.h"
 #include "win/move.h"
 #include "win/placement.h"
@@ -153,7 +154,7 @@ void MoveResizeWindowTest::testMove()
     QCOMPARE(win::is_move(c), false);
 
     // begin move
-    Test::app()->workspace->slotWindowMove();
+    win::active_window_move(*Test::app()->workspace);
     QCOMPARE(Test::app()->workspace->moveResizeClient(), c);
     QCOMPARE(startMoveResizedSpy.count(), 1);
     QCOMPARE(moveResizedChangedSpy.count(), 1);
@@ -252,7 +253,7 @@ void MoveResizeWindowTest::testResize()
     QCOMPARE(Test::app()->workspace->moveResizeClient(), nullptr);
     QCOMPARE(win::is_move(c), false);
     QCOMPARE(win::is_resize(c), false);
-    Test::app()->workspace->slotWindowResize();
+    win::active_window_resize(*Test::app()->workspace);
     QCOMPARE(Test::app()->workspace->moveResizeClient(), c);
     QCOMPARE(startMoveResizedSpy.count(), 1);
     QCOMPARE(moveResizedChangedSpy.count(), 1);
@@ -336,16 +337,16 @@ void MoveResizeWindowTest::testPackTo_data()
     QTest::newRow("down") << QRect(590, 974, 100, 50);
 }
 
-std::function<void(win::space*)> get_space_pack_method(std::string const& method_name)
+std::function<void(win::space&)> get_space_pack_method(std::string const& method_name)
 {
     if (method_name == "left") {
-        return &win::space::slotWindowPackLeft;
+        return win::active_window_pack_left<win::space>;
     } else if (method_name == "up") {
-        return &win::space::slotWindowPackUp;
+        return &win::active_window_pack_up<win::space>;
     } else if (method_name == "right") {
-        return &win::space::slotWindowPackRight;
+        return &win::active_window_pack_right<win::space>;
     } else if (method_name == "down") {
-        return &win::space::slotWindowPackDown;
+        return &win::active_window_pack_down<win::space>;
     }
     return {};
 }
@@ -374,7 +375,7 @@ void MoveResizeWindowTest::testPackTo()
 
     auto method_call = get_space_pack_method(QTest::currentDataTag());
     QVERIFY(method_call);
-    method_call(Test::app()->workspace.get());
+    method_call(*Test::app()->workspace.get());
 
     QTEST(c->frameGeometry(), "expectedGeometry");
     surface.reset();
@@ -413,7 +414,7 @@ void MoveResizeWindowTest::testPackAgainstClient()
     std::unique_ptr<XdgShellToplevel> shellSurface4(Test::create_xdg_shell_toplevel(surface4));
     QVERIFY(shellSurface4);
     auto renderWindow = [this](std::unique_ptr<Surface> const& surface,
-                               std::function<void(win::space*)> const& method_call,
+                               std::function<void(win::space&)> const& method_call,
                                const QRect& expectedGeometry) {
         // let's render
         auto c = Test::render_and_wait_for_shown(surface, QSize(10, 10), Qt::blue);
@@ -424,13 +425,13 @@ void MoveResizeWindowTest::testPackAgainstClient()
         // let's place it centered
         win::place_centered(c, QRect(0, 0, 1280, 1024));
         QCOMPARE(c->frameGeometry(), QRect(635, 507, 10, 10));
-        method_call(Test::app()->workspace.get());
+        method_call(*Test::app()->workspace.get());
         QCOMPARE(c->frameGeometry(), expectedGeometry);
     };
-    renderWindow(surface1, &win::space::slotWindowPackLeft, QRect(0, 507, 10, 10));
-    renderWindow(surface2, &win::space::slotWindowPackUp, QRect(635, 0, 10, 10));
-    renderWindow(surface3, &win::space::slotWindowPackRight, QRect(1270, 507, 10, 10));
-    renderWindow(surface4, &win::space::slotWindowPackDown, QRect(635, 1014, 10, 10));
+    renderWindow(surface1, &win::active_window_pack_left<win::space>, QRect(0, 507, 10, 10));
+    renderWindow(surface2, &win::active_window_pack_up<win::space>, QRect(635, 0, 10, 10));
+    renderWindow(surface3, &win::active_window_pack_right<win::space>, QRect(1270, 507, 10, 10));
+    renderWindow(surface4, &win::active_window_pack_down<win::space>, QRect(635, 1014, 10, 10));
 
     std::unique_ptr<Surface> surface(Test::create_surface());
     QVERIFY(surface);
@@ -446,20 +447,20 @@ void MoveResizeWindowTest::testPackAgainstClient()
 
     auto method_call = get_space_pack_method(QTest::currentDataTag());
     QVERIFY(method_call);
-    method_call(Test::app()->workspace.get());
+    method_call(*Test::app()->workspace.get());
     QTEST(c->frameGeometry(), "expectedGeometry");
 }
 
-std::function<void(win::space*)> get_space_grow_shrink_method(std::string const& method_name)
+std::function<void(win::space&)> get_space_grow_shrink_method(std::string const& method_name)
 {
     if (method_name == "grow vertical") {
-        return &win::space::slotWindowGrowVertical;
+        return win::active_window_grow_vertical<win::space>;
     } else if (method_name == "grow horizontal") {
-        return &win::space::slotWindowGrowHorizontal;
+        return win::active_window_grow_horizontal<win::space>;
     } else if (method_name == "shrink vertical") {
-        return &win::space::slotWindowShrinkVertical;
+        return win::active_window_shrink_vertical<win::space>;
     } else if (method_name == "shrink horizontal") {
-        return &win::space::slotWindowShrinkHorizontal;
+        return win::active_window_shrink_horizontal<win::space>;
     }
     return {};
 }
@@ -485,8 +486,8 @@ void MoveResizeWindowTest::testGrowShrink()
     QVERIFY(shellSurface1);
     auto window = Test::render_and_wait_for_shown(surface1, QSize(650, 514), Qt::blue);
     QVERIFY(window);
-    Test::app()->workspace->slotWindowPackRight();
-    Test::app()->workspace->slotWindowPackDown();
+    win::active_window_pack_right(*Test::app()->workspace);
+    win::active_window_pack_down(*Test::app()->workspace);
 
     std::unique_ptr<Surface> surface(Test::create_surface());
     QVERIFY(surface);
@@ -515,7 +516,7 @@ void MoveResizeWindowTest::testGrowShrink()
     // Now according to test data grow/shrink vertically/horizontally.
     auto method_call = get_space_grow_shrink_method(QTest::currentDataTag());
     QVERIFY(method_call);
-    method_call(Test::app()->workspace.get());
+    method_call(*Test::app()->workspace.get());
 
     QVERIFY(sizeChangeSpy.wait());
     QCOMPARE(configure_spy.count(), 2);
@@ -567,7 +568,7 @@ void MoveResizeWindowTest::testPointerMoveEnd()
     quint32 timestamp = 1;
     Test::pointer_button_pressed(BTN_LEFT, timestamp++);
     QVERIFY(!win::is_move(c));
-    Test::app()->workspace->slotWindowMove();
+    win::active_window_move(*Test::app()->workspace);
     QVERIFY(win::is_move(c));
 
     // let's press another button
@@ -1006,7 +1007,7 @@ void MoveResizeWindowTest::testDestroyMoveClient()
     QCOMPARE(Test::app()->workspace->moveResizeClient(), nullptr);
     QCOMPARE(win::is_move(client), false);
     QCOMPARE(win::is_resize(client), false);
-    Test::app()->workspace->slotWindowMove();
+    win::active_window_move(*Test::app()->workspace);
     QCOMPARE(clientStartMoveResizedSpy.count(), 1);
     QCOMPARE(Test::app()->workspace->moveResizeClient(), client);
     QCOMPARE(win::is_move(client), true);
@@ -1043,7 +1044,7 @@ void MoveResizeWindowTest::testDestroyResizeClient()
     QCOMPARE(Test::app()->workspace->moveResizeClient(), nullptr);
     QCOMPARE(win::is_move(client), false);
     QCOMPARE(win::is_resize(client), false);
-    Test::app()->workspace->slotWindowResize();
+    win::active_window_resize(*Test::app()->workspace);
     QCOMPARE(clientStartMoveResizedSpy.count(), 1);
     QCOMPARE(Test::app()->workspace->moveResizeClient(), client);
     QCOMPARE(win::is_move(client), false);
@@ -1080,7 +1081,7 @@ void MoveResizeWindowTest::testUnmapMoveClient()
     QCOMPARE(Test::app()->workspace->moveResizeClient(), nullptr);
     QCOMPARE(win::is_move(client), false);
     QCOMPARE(win::is_resize(client), false);
-    Test::app()->workspace->slotWindowMove();
+    win::active_window_move(*Test::app()->workspace);
     QCOMPARE(clientStartMoveResizedSpy.count(), 1);
     QCOMPARE(Test::app()->workspace->moveResizeClient(), client);
     QCOMPARE(win::is_move(client), true);
@@ -1126,7 +1127,7 @@ void MoveResizeWindowTest::testUnmapResizeClient()
     QCOMPARE(Test::app()->workspace->moveResizeClient(), nullptr);
     QCOMPARE(win::is_move(client), false);
     QCOMPARE(win::is_resize(client), false);
-    Test::app()->workspace->slotWindowResize();
+    win::active_window_resize(*Test::app()->workspace);
     QCOMPARE(clientStartMoveResizedSpy.count(), 1);
     QCOMPARE(Test::app()->workspace->moveResizeClient(), client);
     QCOMPARE(win::is_move(client), false);
@@ -1169,7 +1170,7 @@ void MoveResizeWindowTest::testSetFullScreenWhenMoving()
     QVERIFY(configureRequestedSpy.isValid());
     QVERIFY(configureRequestedSpy.wait());
 
-    Test::app()->workspace->slotWindowMove();
+    win::active_window_move(*Test::app()->workspace);
     QCOMPARE(win::is_move(client), true);
 
     QVERIFY(configureRequestedSpy.wait());
@@ -1224,7 +1225,7 @@ void MoveResizeWindowTest::testSetMaximizeWhenMoving()
     auto client = Test::render_and_wait_for_shown(surface, QSize(500, 800), Qt::blue);
     QVERIFY(client);
 
-    Test::app()->workspace->slotWindowMove();
+    win::active_window_move(*Test::app()->workspace);
     QCOMPARE(win::is_move(client), true);
     win::set_maximize(client, true, true);
 
diff --git a/autotests/integration/quick_tiling_test.cpp b/autotests/integration/quick_tiling_test.cpp
index ef2f5848e..94adb92b1 100644
--- a/autotests/integration/quick_tiling_test.cpp
+++ b/autotests/integration/quick_tiling_test.cpp
@@ -29,6 +29,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "win/move.h"
 #include "win/screen.h"
 #include "win/wayland/space.h"
+#include "win/window_operation.h"
 #include "win/x11/window.h"
 
 #include <KDecoration2/DecoratedClient>
@@ -426,7 +427,7 @@ void QuickTilingTest::testQuickTilingKeyboardMove()
     QSignalSpy quickTileChangedSpy(c, &Toplevel::quicktiling_changed);
     QVERIFY(quickTileChangedSpy.isValid());
 
-    Test::app()->workspace->performWindowOperation(c, base::options::UnrestrictedMoveOp);
+    win::perform_window_operation(*Test::app()->workspace, c, base::options::UnrestrictedMoveOp);
     QCOMPARE(c, Test::app()->workspace->moveResizeClient());
     QCOMPARE(input::get_cursor()->pos(), QPoint(49, 24));
 
@@ -509,7 +510,7 @@ void QuickTilingTest::testQuickTilingPointerMove()
     QSignalSpy quickTileChangedSpy(c, &Toplevel::quicktiling_changed);
     QVERIFY(quickTileChangedSpy.isValid());
 
-    Test::app()->workspace->performWindowOperation(c, base::options::UnrestrictedMoveOp);
+    win::perform_window_operation(*Test::app()->workspace, c, base::options::UnrestrictedMoveOp);
     QCOMPARE(c, Test::app()->workspace->moveResizeClient());
     QCOMPARE(input::get_cursor()->pos(), QPoint(49, 24));
     QVERIFY(configureRequestedSpy.wait());
diff --git a/autotests/integration/scripting/screenedge_test.cpp b/autotests/integration/scripting/screenedge_test.cpp
index c166d8e9b..e2c81a89a 100644
--- a/autotests/integration/scripting/screenedge_test.cpp
+++ b/autotests/integration/scripting/screenedge_test.cpp
@@ -91,7 +91,7 @@ void ScreenEdgeTest::init()
 {
     input::get_cursor()->set_pos(640, 512);
     if (Test::app()->workspace->showingDesktop()) {
-        Test::app()->workspace->slotToggleShowDesktop();
+        win::toggle_show_desktop(*Test::app()->workspace);
     }
     QVERIFY(!Test::app()->workspace->showingDesktop());
 }
@@ -252,7 +252,7 @@ void ScreenEdgeTest::testEdgeUnregister()
 
     // reset
     input::get_cursor()->set_pos(500, 500);
-    Test::app()->workspace->slotToggleShowDesktop();
+    win::toggle_show_desktop(*Test::app()->workspace);
     showDesktopSpy.clear();
 
     // trigger again, to show that retriggering works
@@ -261,7 +261,7 @@ void ScreenEdgeTest::testEdgeUnregister()
 
     // reset
     input::get_cursor()->set_pos(500, 500);
-    Test::app()->workspace->slotToggleShowDesktop();
+    win::toggle_show_desktop(*Test::app()->workspace);
     showDesktopSpy.clear();
 
     // make the script unregister the edge
diff --git a/autotests/integration/showing_desktop_test.cpp b/autotests/integration/showing_desktop_test.cpp
index 615f10884..6bf4e89ab 100644
--- a/autotests/integration/showing_desktop_test.cpp
+++ b/autotests/integration/showing_desktop_test.cpp
@@ -20,6 +20,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "lib/app.h"
 
 #include "base/wayland/server.h"
+#include "win/activation.h"
 #include "win/net.h"
 #include "win/space.h"
 #include "win/wayland/window.h"
@@ -74,9 +75,9 @@ void ShowingDesktopTest::testRestoreFocus()
     QVERIFY(client1 != client2);
 
     QCOMPARE(Test::app()->workspace->active_client, client2);
-    Test::app()->workspace->slotToggleShowDesktop();
+    win::toggle_show_desktop(*Test::app()->workspace);
     QVERIFY(Test::app()->workspace->showingDesktop());
-    Test::app()->workspace->slotToggleShowDesktop();
+    win::toggle_show_desktop(*Test::app()->workspace);
     QVERIFY(!Test::app()->workspace->showingDesktop());
 
     QVERIFY(Test::app()->workspace->active_client);
@@ -111,10 +112,10 @@ void ShowingDesktopTest::testRestoreFocusWithDesktopWindow()
     QVERIFY(client1 != client2);
 
     QCOMPARE(Test::app()->workspace->active_client, client2);
-    Test::app()->workspace->slotToggleShowDesktop();
+    win::toggle_show_desktop(*Test::app()->workspace);
     QVERIFY(Test::app()->workspace->showingDesktop());
     QCOMPARE(Test::app()->workspace->active_client, desktop);
-    Test::app()->workspace->slotToggleShowDesktop();
+    win::toggle_show_desktop(*Test::app()->workspace);
     QVERIFY(!Test::app()->workspace->showingDesktop());
 
     QVERIFY(Test::app()->workspace->active_client);
diff --git a/autotests/integration/struts_test.cpp b/autotests/integration/struts_test.cpp
index 388217577..af7910ae7 100644
--- a/autotests/integration/struts_test.cpp
+++ b/autotests/integration/struts_test.cpp
@@ -1062,7 +1062,7 @@ void StrutsTest::testWindowMoveWithPanelBetweenScreens()
 
     const QRect origGeo = client2->frameGeometry();
     input::get_cursor()->set_pos(origGeo.center());
-    Test::app()->workspace->performWindowOperation(client2, base::options::MoveOp);
+    win::perform_window_operation(*Test::app()->workspace, client2, base::options::MoveOp);
 
     QTRY_COMPARE(Test::app()->workspace->moveResizeClient(), client2);
     QVERIFY(win::is_move(client2));
diff --git a/autotests/integration/x11_client_test.cpp b/autotests/integration/x11_client_test.cpp
index fd73979da..7502977f0 100644
--- a/autotests/integration/x11_client_test.cpp
+++ b/autotests/integration/x11_client_test.cpp
@@ -25,6 +25,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "render/effect_loader.h"
 #include "render/effects.h"
 #include "win/activation.h"
+#include "win/active_window.h"
 #include "win/meta.h"
 #include "win/space.h"
 #include "win/stacking_order.h"
@@ -215,7 +216,7 @@ void X11ClientTest::testFullscreenLayerWithActiveWaylandWindow()
     QVERIFY(client->control->active());
     QCOMPARE(client->layer(), win::layer::normal);
 
-    Test::app()->workspace->slotWindowFullScreen();
+    win::active_window_set_fullscreen(*Test::app()->workspace);
     QVERIFY(client->control->fullscreen());
     QCOMPARE(client->layer(), win::layer::active);
     QCOMPARE(Test::app()->workspace->stacking_order->stack.back(), client);
@@ -249,10 +250,10 @@ void X11ClientTest::testFullscreenLayerWithActiveWaylandWindow()
     QTRY_VERIFY(client->control->active());
     // remove fullscreen
     QVERIFY(client->control->fullscreen());
-    Test::app()->workspace->slotWindowFullScreen();
+    win::active_window_set_fullscreen(*Test::app()->workspace);
     QVERIFY(!client->control->fullscreen());
     // and fullscreen again
-    Test::app()->workspace->slotWindowFullScreen();
+    win::active_window_set_fullscreen(*Test::app()->workspace);
     QVERIFY(client->control->fullscreen());
     QCOMPARE(Test::app()->workspace->stacking_order->stack.back(), client);
     QCOMPARE(win::render_stack(*Test::app()->workspace->stacking_order).back(), client);
@@ -269,7 +270,7 @@ void X11ClientTest::testFullscreenLayerWithActiveWaylandWindow()
 
     // remove fullscreen
     QVERIFY(client->control->fullscreen());
-    Test::app()->workspace->slotWindowFullScreen();
+    win::active_window_set_fullscreen(*Test::app()->workspace);
     QVERIFY(!client->control->fullscreen());
 
     // Wait a moment for the X11 client to catch up.
@@ -693,7 +694,7 @@ void X11ClientTest::testFullscreenWindowGroups()
 
     QCOMPARE(client->control->fullscreen(), false);
     QCOMPARE(client->layer(), win::layer::normal);
-    Test::app()->workspace->slotWindowFullScreen();
+    win::active_window_set_fullscreen(*Test::app()->workspace);
     QCOMPARE(client->control->fullscreen(), true);
     QCOMPARE(client->layer(), win::layer::active);
 
diff --git a/autotests/integration/xdgshellclient_rules_test.cpp b/autotests/integration/xdgshellclient_rules_test.cpp
index ca4023504..575220484 100644
--- a/autotests/integration/xdgshellclient_rules_test.cpp
+++ b/autotests/integration/xdgshellclient_rules_test.cpp
@@ -24,6 +24,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "input/cursor.h"
 #include "rules/rule_book.h"
 #include "rules/rules.h"
+#include "win/active_window.h"
 #include "win/controlling.h"
 #include "win/input.h"
 #include "win/setup.h"
@@ -291,7 +292,7 @@ void TestXdgShellClientRules::testPositionApply()
     QCOMPARE(Test::app()->workspace->moveResizeClient(), nullptr);
     QVERIFY(!win::is_move(client));
     QVERIFY(!win::is_resize(client));
-    Test::app()->workspace->slotWindowMove();
+    win::active_window_move(*Test::app()->workspace);
     QCOMPARE(Test::app()->workspace->moveResizeClient(), client);
     QCOMPARE(clientStartMoveResizedSpy.count(), 1);
     QVERIFY(win::is_move(client));
@@ -367,7 +368,7 @@ void TestXdgShellClientRules::testPositionRemember()
     QCOMPARE(Test::app()->workspace->moveResizeClient(), nullptr);
     QVERIFY(!win::is_move(client));
     QVERIFY(!win::is_resize(client));
-    Test::app()->workspace->slotWindowMove();
+    win::active_window_move(*Test::app()->workspace);
     QCOMPARE(Test::app()->workspace->moveResizeClient(), client);
     QCOMPARE(clientStartMoveResizedSpy.count(), 1);
     QVERIFY(win::is_move(client));
@@ -438,7 +439,7 @@ void TestXdgShellClientRules::testPositionForce()
     QCOMPARE(Test::app()->workspace->moveResizeClient(), nullptr);
     QVERIFY(!win::is_move(client));
     QVERIFY(!win::is_resize(client));
-    Test::app()->workspace->slotWindowMove();
+    win::active_window_move(*Test::app()->workspace);
     QCOMPARE(Test::app()->workspace->moveResizeClient(), nullptr);
     QCOMPARE(clientStartMoveResizedSpy.count(), 0);
     QVERIFY(!win::is_move(client));
@@ -509,7 +510,7 @@ void TestXdgShellClientRules::testPositionApplyNow()
     QCOMPARE(Test::app()->workspace->moveResizeClient(), nullptr);
     QVERIFY(!win::is_move(client));
     QVERIFY(!win::is_resize(client));
-    Test::app()->workspace->slotWindowMove();
+    win::active_window_move(*Test::app()->workspace);
     QCOMPARE(Test::app()->workspace->moveResizeClient(), client);
     QCOMPARE(clientStartMoveResizedSpy.count(), 1);
     QVERIFY(win::is_move(client));
@@ -573,7 +574,7 @@ void TestXdgShellClientRules::testPositionForceTemporarily()
     QCOMPARE(Test::app()->workspace->moveResizeClient(), nullptr);
     QVERIFY(!win::is_move(client));
     QVERIFY(!win::is_resize(client));
-    Test::app()->workspace->slotWindowMove();
+    win::active_window_move(*Test::app()->workspace);
     QCOMPARE(Test::app()->workspace->moveResizeClient(), nullptr);
     QCOMPARE(clientStartMoveResizedSpy.count(), 0);
     QVERIFY(!win::is_move(client));
@@ -708,7 +709,7 @@ void TestXdgShellClientRules::testSizeApply()
     QCOMPARE(Test::app()->workspace->moveResizeClient(), nullptr);
     QVERIFY(!win::is_move(client));
     QVERIFY(!win::is_resize(client));
-    Test::app()->workspace->slotWindowResize();
+    win::active_window_resize(*Test::app()->workspace);
     QCOMPARE(Test::app()->workspace->moveResizeClient(), client);
     QCOMPARE(clientStartMoveResizedSpy.count(), 1);
     QVERIFY(!win::is_move(client));
@@ -843,7 +844,7 @@ void TestXdgShellClientRules::testSizeRemember()
     QCOMPARE(Test::app()->workspace->moveResizeClient(), nullptr);
     QVERIFY(!win::is_move(client));
     QVERIFY(!win::is_resize(client));
-    Test::app()->workspace->slotWindowResize();
+    win::active_window_resize(*Test::app()->workspace);
     QCOMPARE(Test::app()->workspace->moveResizeClient(), client);
     QCOMPARE(clientStartMoveResizedSpy.count(), 1);
     QVERIFY(!win::is_move(client));
@@ -962,7 +963,7 @@ void TestXdgShellClientRules::testSizeForce()
     QCOMPARE(Test::app()->workspace->moveResizeClient(), nullptr);
     QVERIFY(!win::is_move(client));
     QVERIFY(!win::is_resize(client));
-    Test::app()->workspace->slotWindowResize();
+    win::active_window_resize(*Test::app()->workspace);
     QCOMPARE(Test::app()->workspace->moveResizeClient(), nullptr);
     QCOMPARE(clientStartMoveResizedSpy.count(), 0);
     QVERIFY(!win::is_move(client));
@@ -1112,7 +1113,7 @@ void TestXdgShellClientRules::testSizeForceTemporarily()
     QCOMPARE(Test::app()->workspace->moveResizeClient(), nullptr);
     QVERIFY(!win::is_move(client));
     QVERIFY(!win::is_resize(client));
-    Test::app()->workspace->slotWindowResize();
+    win::active_window_resize(*Test::app()->workspace);
     QCOMPARE(Test::app()->workspace->moveResizeClient(), nullptr);
     QCOMPARE(clientStartMoveResizedSpy.count(), 0);
     QVERIFY(!win::is_move(client));
@@ -1261,7 +1262,7 @@ void TestXdgShellClientRules::testMaximizeApply()
     QVERIFY(states.testFlag(XdgShellToplevel::State::Maximized));
 
     // One should still be able to change the maximized state of the client.
-    Test::app()->workspace->slotWindowMaximize();
+    win::active_window_maximize(*Test::app()->workspace);
     QVERIFY(configureRequestedSpy->wait());
     QCOMPARE(configureRequestedSpy->count(), 3);
 
@@ -1373,7 +1374,7 @@ void TestXdgShellClientRules::testMaximizeRemember()
     QVERIFY(states.testFlag(XdgShellToplevel::State::Maximized));
 
     // One should still be able to change the maximized state of the client.
-    Test::app()->workspace->slotWindowMaximize();
+    win::active_window_maximize(*Test::app()->workspace);
     QVERIFY(configureRequestedSpy->wait());
     QCOMPARE(configureRequestedSpy->count(), 3);
 
@@ -1486,7 +1487,7 @@ void TestXdgShellClientRules::testMaximizeForce()
 
     // Any attempt to change the maximized state should not succeed.
     const QRect oldGeometry = client->frameGeometry();
-    Test::app()->workspace->slotWindowMaximize();
+    win::active_window_maximize(*Test::app()->workspace);
     QVERIFY(!configureRequestedSpy->wait(100));
     QCOMPARE(client->maximizeMode(), win::maximize_mode::full);
     QCOMPARE(client->synced_geometry.max_mode, win::maximize_mode::full);
@@ -1605,7 +1606,7 @@ void TestXdgShellClientRules::testMaximizeApplyNow()
     QVERIFY(client->isMaximizable());
 
     // Restore the client.
-    Test::app()->workspace->slotWindowMaximize();
+    win::active_window_maximize(*Test::app()->workspace);
     QVERIFY(configureRequestedSpy->wait());
     QCOMPARE(configureRequestedSpy->count(), 4);
     QCOMPARE(configureRequestedSpy->last().at(0).toSize(), QSize(100, 50));
@@ -1688,7 +1689,7 @@ void TestXdgShellClientRules::testMaximizeForceTemporarily()
 
     // Any attempt to change the maximized state should not succeed.
     const QRect oldGeometry = client->frameGeometry();
-    Test::app()->workspace->slotWindowMaximize();
+    win::active_window_maximize(*Test::app()->workspace);
     QVERIFY(!configureRequestedSpy->wait(100));
     QCOMPARE(client->maximizeMode(), win::maximize_mode::full);
     QCOMPARE(client->synced_geometry.max_mode, win::maximize_mode::full);
diff --git a/autotests/integration/xdgshellclient_test.cpp b/autotests/integration/xdgshellclient_test.cpp
index c0384ecb5..06f841104 100644
--- a/autotests/integration/xdgshellclient_test.cpp
+++ b/autotests/integration/xdgshellclient_test.cpp
@@ -24,6 +24,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "base/wayland/server.h"
 #include "input/cursor.h"
 #include "render/effects.h"
+#include "win/active_window.h"
 #include "win/control.h"
 #include "win/controlling.h"
 #include "win/deco/bridge.h"
@@ -375,7 +376,7 @@ void TestXdgShellClient::testMinimizeActiveWindow()
     QVERIFY(win::wants_tab_focus(c));
     QVERIFY(c->isShown());
 
-    Test::app()->workspace->slotWindowMinimize();
+    win::active_window_minimize(*Test::app()->workspace);
     QVERIFY(!c->isShown());
     QVERIFY(c->wantsInput());
     QVERIFY(win::wants_tab_focus(c));
@@ -1079,7 +1080,7 @@ void TestXdgShellClient::testSendClientWithTransientToDesktop()
     QVERIFY(!c->isOnAllDesktops());
     QCOMPARE(transient->desktop(), 1);
     QVERIFY(!transient->isOnAllDesktops());
-    Test::app()->workspace->slotWindowToDesktop(2);
+    win::active_window_to_desktop(*Test::app()->workspace, 2);
 
     QCOMPARE(c->desktop(), 1);
     QCOMPARE(transient->desktop(), 2);
@@ -1092,7 +1093,7 @@ void TestXdgShellClient::testSendClientWithTransientToDesktop()
     // and send it to the desktop it's already on
     QCOMPARE(c->desktop(), 1);
     QCOMPARE(transient->desktop(), 2);
-    Test::app()->workspace->slotWindowToDesktop(1);
+    win::active_window_to_desktop(*Test::app()->workspace, 1);
 
     // which should move the transient back to the desktop
     QCOMPARE(c->desktop(), 1);
@@ -1241,7 +1242,7 @@ void TestXdgShellClient::testXdgInitiallyMaximised()
     QVERIFY(state & Wrapland::Client::XdgShellToplevel::State::Maximized);
 
     // Unmaximize again, an empty size is returned, that means the client should decide.
-    Test::app()->workspace->slotWindowMaximize();
+    win::active_window_maximize(*Test::app()->workspace);
     QVERIFY(configureRequestedSpy.wait());
     QCOMPARE(configureRequestedSpy.count(), 3);
 
@@ -1535,7 +1536,7 @@ void TestXdgShellClient::testXdgWindowGeometryInteractiveResize()
 
     // Start interactively resizing the client.
     QCOMPARE(Test::app()->workspace->moveResizeClient(), nullptr);
-    Test::app()->workspace->slotWindowResize();
+    win::active_window_resize(*Test::app()->workspace);
     QCOMPARE(Test::app()->workspace->moveResizeClient(), client);
     QCOMPARE(clientStartMoveResizedSpy.count(), 1);
     QVERIFY(configureRequestedSpy.wait());
@@ -1630,7 +1631,7 @@ void TestXdgShellClient::testXdgWindowGeometryFullScreen()
     QCOMPARE(win::render_geometry(client).size(), QSize(200, 100));
     QCOMPARE(client->frameGeometry().size(), QSize(180, 80));
 
-    Test::app()->workspace->slotWindowFullScreen();
+    win::active_window_set_fullscreen(*Test::app()->workspace);
     QCOMPARE(client->restore_geometries.maximize, QRect(0, 0, 180, 80));
 
     QVERIFY(configureRequestedSpy.wait());
@@ -1648,7 +1649,7 @@ void TestXdgShellClient::testXdgWindowGeometryFullScreen()
     QCOMPARE(win::render_geometry(client).size(), QSize(1280, 1024));
     QCOMPARE(client->frameGeometry().size(), QSize(1280, 1024));
 
-    Test::app()->workspace->slotWindowFullScreen();
+    win::active_window_set_fullscreen(*Test::app()->workspace);
     QVERIFY(configureRequestedSpy.wait());
     QCOMPARE(configureRequestedSpy.count(), 3);
     QCOMPARE(configureRequestedSpy.last().at(0).toSize(), QSize(180, 80));
@@ -1691,7 +1692,7 @@ void TestXdgShellClient::testXdgWindowGeometryMaximize()
     QCOMPARE(win::render_geometry(client).size(), QSize(200, 100));
     QCOMPARE(client->frameGeometry().size(), QSize(180, 80));
 
-    Test::app()->workspace->slotWindowMaximize();
+    win::active_window_maximize(*Test::app()->workspace);
     QVERIFY(configureRequestedSpy.wait());
     QCOMPARE(configureRequestedSpy.count(), 2);
     QCOMPARE(configureRequestedSpy.last().at(0).toSize(), QSize(1280, 1024));
@@ -1705,7 +1706,7 @@ void TestXdgShellClient::testXdgWindowGeometryMaximize()
     QCOMPARE(win::render_geometry(client).size(), QSize(1280, 1024));
     QCOMPARE(client->frameGeometry().size(), QSize(1280, 1024));
 
-    Test::app()->workspace->slotWindowMaximize();
+    win::active_window_maximize(*Test::app()->workspace);
     QVERIFY(configureRequestedSpy.wait());
     QCOMPARE(configureRequestedSpy.count(), 3);
     QCOMPARE(configureRequestedSpy.last().at(0).toSize(), QSize(180, 80));
diff --git a/base/dbus/kwin.h b/base/dbus/kwin.h
index bc115aa7d..e69e92549 100644
--- a/base/dbus/kwin.h
+++ b/base/dbus/kwin.h
@@ -10,6 +10,7 @@
 #include "input/platform.h"
 #include "main.h"
 #include "toplevel.h"
+#include "win/kill_window.h"
 #include "win/placement.h"
 
 #include <QObject>
@@ -133,7 +134,7 @@ public:
 
     void kill_window_impl() override
     {
-        space.slotKillWindow();
+        win::start_window_killer(space);
     }
 
     void unclutter_desktop_impl() override
diff --git a/render/effects.cpp b/render/effects.cpp
index 0f1f99fc6..6e1d292eb 100644
--- a/render/effects.cpp
+++ b/render/effects.cpp
@@ -968,7 +968,7 @@ void effects_handler_impl::windowToScreen(EffectWindow* w, int screen)
 
 void effects_handler_impl::setShowingDesktop(bool showing)
 {
-    m_compositor->space->setShowingDesktop(showing);
+    win::set_showing_desktop(*m_compositor->space, showing);
 }
 
 QString effects_handler_impl::currentActivity() const
diff --git a/scripting/space.h b/scripting/space.h
index 786ec1214..c96e82e32 100644
--- a/scripting/space.h
+++ b/scripting/space.h
@@ -27,7 +27,9 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "debug/support_info.h"
 #include "main.h"
 #include "win/activation.h"
+#include "win/active_window.h"
 #include "win/move.h"
+#include "win/output_space.h"
 #include "win/screen.h"
 #include "win/virtual_desktops.h"
 #include "win/wayland/window.h"
@@ -345,7 +347,6 @@ public Q_SLOTS:
     virtual void slotWindowToDesktopUp() = 0;
     virtual void slotWindowToDesktopDown() = 0;
 
-#undef SIMPLE_SLOT
 #undef QUICKTILE_SLOT
 #undef SWITCH_WINDOW_SLOT
 #undef SWITCH_VD_SLOT
@@ -678,12 +679,6 @@ public:
         ref_space->outline->hide();
     }
 
-#define SIMPLE_SLOT(name)                                                                          \
-    void name() override                                                                           \
-    {                                                                                              \
-        ref_space->name();                                                                         \
-    }
-
 #define QUICKTILE_SLOT(name, modes)                                                                \
     void name() override                                                                           \
     {                                                                                              \
@@ -696,29 +691,185 @@ public:
         ref_space->switchWindow(win::space::direction);                                            \
     }
 
-    SIMPLE_SLOT(slotSwitchToNextScreen)
-    SIMPLE_SLOT(slotWindowToNextScreen)
-    SIMPLE_SLOT(slotToggleShowDesktop)
+    void slotSwitchToNextScreen() override
+    {
+        win::switch_to_next_output(*ref_space);
+    }
+
+    void slotWindowToNextScreen() override
+    {
+        win::active_window_to_next_output(*ref_space);
+    }
+
+    void slotToggleShowDesktop() override
+    {
+        win::toggle_show_desktop(*ref_space);
+    }
+
+    void slotWindowMaximize() override
+    {
+        win::active_window_maximize(*ref_space);
+    }
+
+    void slotWindowMaximizeVertical() override
+    {
+        win::active_window_maximize_vertical(*ref_space);
+    }
+
+    void slotWindowMaximizeHorizontal() override
+    {
+        win::active_window_maximize_horizontal(*ref_space);
+    }
+
+    void slotWindowMinimize() override
+    {
+        win::active_window_minimize(*ref_space);
+    }
+
+    void slotWindowRaise() override
+    {
+        win::active_window_raise(*ref_space);
+    }
+
+    void slotWindowLower() override
+    {
+        win::active_window_lower(*ref_space);
+    }
+
+    void slotWindowRaiseOrLower() override
+    {
+        win::active_window_raise_or_lower(*ref_space);
+    }
+
+    void slotActivateAttentionWindow() override
+    {
+        win::activate_attention_window(*ref_space);
+    }
 
-    SIMPLE_SLOT(slotWindowMaximize)
-    SIMPLE_SLOT(slotWindowMaximizeVertical)
-    SIMPLE_SLOT(slotWindowMaximizeHorizontal)
-    SIMPLE_SLOT(slotWindowMinimize)
+    void slotWindowPackLeft() override
+    {
+        win::active_window_pack_left(*ref_space);
+    }
 
-    SIMPLE_SLOT(slotWindowRaise)
-    SIMPLE_SLOT(slotWindowLower)
-    SIMPLE_SLOT(slotWindowRaiseOrLower)
-    SIMPLE_SLOT(slotActivateAttentionWindow)
+    void slotWindowPackRight() override
+    {
+        win::active_window_pack_right(*ref_space);
+    }
 
-    SIMPLE_SLOT(slotWindowPackLeft)
-    SIMPLE_SLOT(slotWindowPackRight)
-    SIMPLE_SLOT(slotWindowPackUp)
-    SIMPLE_SLOT(slotWindowPackDown)
+    void slotWindowPackUp() override
+    {
+        win::active_window_pack_up(*ref_space);
+    }
+
+    void slotWindowPackDown() override
+    {
+        win::active_window_pack_down(*ref_space);
+    }
+
+    void slotWindowGrowHorizontal() override
+    {
+        win::active_window_grow_horizontal(*ref_space);
+    }
+
+    void slotWindowGrowVertical() override
+    {
+        win::active_window_grow_vertical(*ref_space);
+    }
+
+    void slotWindowShrinkHorizontal() override
+    {
+        win::active_window_shrink_horizontal(*ref_space);
+    }
 
-    SIMPLE_SLOT(slotWindowGrowHorizontal)
-    SIMPLE_SLOT(slotWindowGrowVertical)
-    SIMPLE_SLOT(slotWindowShrinkHorizontal)
-    SIMPLE_SLOT(slotWindowShrinkVertical)
+    void slotWindowShrinkVertical() override
+    {
+        win::active_window_shrink_vertical(*ref_space);
+    }
+
+    void slotIncreaseWindowOpacity() override
+    {
+        win::active_window_increase_opacity(*ref_space);
+    }
+
+    void slotLowerWindowOpacity() override
+    {
+        win::active_window_lower_opacity(*ref_space);
+    }
+
+    void slotWindowOperations() override
+    {
+        win::active_window_show_operations_popup(*ref_space);
+    }
+
+    void slotWindowClose() override
+    {
+        win::active_window_close(*ref_space);
+    }
+
+    void slotWindowMove() override
+    {
+        win::active_window_move(*ref_space);
+    }
+
+    void slotWindowResize() override
+    {
+        win::active_window_resize(*ref_space);
+    }
+
+    void slotWindowAbove() override
+    {
+        win::active_window_set_keep_above(*ref_space);
+    }
+
+    void slotWindowBelow() override
+    {
+        win::active_window_set_keep_below(*ref_space);
+    }
+
+    void slotWindowOnAllDesktops() override
+    {
+        win::active_window_set_on_all_desktops(*ref_space);
+    }
+
+    void slotWindowFullScreen() override
+    {
+        win::active_window_set_fullscreen(*ref_space);
+    }
+
+    void slotWindowNoBorder() override
+    {
+        win::active_window_set_no_border(*ref_space);
+    }
+
+    void slotWindowToNextDesktop() override
+    {
+        win::active_window_to_next_desktop(*ref_space);
+    }
+
+    void slotWindowToPreviousDesktop() override
+    {
+        win::active_window_to_prev_desktop(*ref_space);
+    }
+
+    void slotWindowToDesktopRight() override
+    {
+        win::active_window_to_right_desktop(*ref_space);
+    }
+
+    void slotWindowToDesktopLeft() override
+    {
+        win::active_window_to_left_desktop(*ref_space);
+    }
+
+    void slotWindowToDesktopUp() override
+    {
+        win::active_window_to_above_desktop(*ref_space);
+    }
+
+    void slotWindowToDesktopDown() override
+    {
+        win::active_window_to_below_desktop(*ref_space);
+    }
 
     QUICKTILE_SLOT(slotWindowQuickTileLeft, win::quicktiles::left)
     QUICKTILE_SLOT(slotWindowQuickTileRight, win::quicktiles::right)
@@ -734,27 +885,6 @@ public:
     SWITCH_WINDOW_SLOT(slotSwitchWindowRight, DirectionEast)
     SWITCH_WINDOW_SLOT(slotSwitchWindowLeft, DirectionWest)
 
-    SIMPLE_SLOT(slotIncreaseWindowOpacity)
-    SIMPLE_SLOT(slotLowerWindowOpacity)
-
-    SIMPLE_SLOT(slotWindowOperations)
-    SIMPLE_SLOT(slotWindowClose)
-    SIMPLE_SLOT(slotWindowMove)
-    SIMPLE_SLOT(slotWindowResize)
-    SIMPLE_SLOT(slotWindowAbove)
-    SIMPLE_SLOT(slotWindowBelow)
-    SIMPLE_SLOT(slotWindowOnAllDesktops)
-    SIMPLE_SLOT(slotWindowFullScreen)
-    SIMPLE_SLOT(slotWindowNoBorder)
-
-    SIMPLE_SLOT(slotWindowToNextDesktop)
-    SIMPLE_SLOT(slotWindowToPreviousDesktop)
-    SIMPLE_SLOT(slotWindowToDesktopRight)
-    SIMPLE_SLOT(slotWindowToDesktopLeft)
-    SIMPLE_SLOT(slotWindowToDesktopUp)
-    SIMPLE_SLOT(slotWindowToDesktopDown)
-
-#undef SIMPLE_SLOT
 #undef QUICKTILE_SLOT
 #undef SWITCH_WINDOW_SLOT
 
diff --git a/win/activation.h b/win/activation.h
index 488a6264f..f1a1d0a77 100644
--- a/win/activation.h
+++ b/win/activation.h
@@ -496,6 +496,14 @@ void force_activate_window(Space& space, Win* window)
     activate_window_impl(space, window, true);
 }
 
+template<typename Space>
+void activate_attention_window(Space& space)
+{
+    if (space.attention_chain.size() > 0) {
+        activate_window(space, space.attention_chain.front());
+    }
+}
+
 /// Deactivates 'window' and activates next one.
 template<typename Space>
 bool activate_next_window(Space& space, Toplevel* window)
@@ -682,4 +690,60 @@ void close_active_popup(Space& space)
     space.user_actions_menu->close();
 }
 
+template<typename Space>
+void set_showing_desktop(Space& space, bool showing)
+{
+    const bool changed = showing != space.showing_desktop;
+    if (x11::rootInfo() && changed) {
+        x11::rootInfo()->setShowingDesktop(showing);
+    }
+
+    space.showing_desktop = showing;
+
+    Toplevel* topDesk = nullptr;
+
+    // for the blocker RAII
+    // updateLayer & lowerClient would invalidate stacking_order
+    {
+        blocker block(space.stacking_order);
+        for (int i = static_cast<int>(space.stacking_order->stack.size()) - 1; i > -1; --i) {
+            auto c = qobject_cast<Toplevel*>(space.stacking_order->stack.at(i));
+            if (c && c->isOnCurrentDesktop()) {
+                if (is_dock(c)) {
+                    update_layer(c);
+                } else if (is_desktop(c) && c->isShown()) {
+                    update_layer(c);
+                    lower_window(&space, c);
+                    if (!topDesk)
+                        topDesk = c;
+                    if (auto group = c->group()) {
+                        for (auto cm : group->members) {
+                            update_layer(cm);
+                        }
+                    }
+                }
+            }
+        }
+    } // ~Blocker
+
+    if (space.showing_desktop && topDesk) {
+        request_focus(space, topDesk);
+    } else if (!space.showing_desktop && changed) {
+        auto const window = focus_chain_get_for_activation_on_current_output<Toplevel>(
+            space.focus_chain, space.virtual_desktop_manager->current());
+        if (window) {
+            activate_window(space, window);
+        }
+    }
+    if (changed) {
+        Q_EMIT space.qobject->showingDesktopChanged(showing);
+    }
+}
+
+template<typename Space>
+void toggle_show_desktop(Space& space)
+{
+    set_showing_desktop(space, !space.showingDesktop());
+}
+
 }
diff --git a/win/active_window.h b/win/active_window.h
new file mode 100644
index 000000000..230c355e3
--- /dev/null
+++ b/win/active_window.h
@@ -0,0 +1,391 @@
+/*
+    SPDX-FileCopyrightText: 2022 Roman Gilg <subdiff@gmail.com>
+
+    SPDX-License-Identifier: GPL-2.0-or-later
+*/
+#pragma once
+
+#include "desktop_space.h"
+#include "move.h"
+#include "net.h"
+#include "output_space.h"
+#include "placement.h"
+#include "stacking.h"
+#include "window_operation.h"
+
+namespace KWin::win
+{
+
+template<typename Space>
+bool has_usable_active_window(Space& space)
+{
+    return space.active_client
+        && !(is_desktop(space.active_client) || is_dock(space.active_client));
+}
+
+template<typename Space>
+void active_window_to_desktop(Space& space, unsigned int i)
+{
+    if (has_usable_active_window(space)) {
+        if (i < 1) {
+            return;
+        }
+
+        if (i >= 1 && i <= space.virtual_desktop_manager->count())
+            send_window_to_desktop(space, space.active_client, i, true);
+    }
+}
+
+template<typename Space>
+void active_window_to_output(Space& space, QAction* action)
+{
+    if (has_usable_active_window(space)) {
+        int const screen = get_action_data_as_uint(action);
+        auto output = base::get_output(kwinApp()->get_base().get_outputs(), screen);
+        if (output) {
+            send_to_screen(space, space.active_client, *output);
+        }
+    }
+}
+
+template<typename Space>
+void active_window_to_next_output(Space& space)
+{
+    if (!has_usable_active_window(space)) {
+        return;
+    }
+    if (auto output = get_derivated_output(space.active_client->central_output, 1)) {
+        send_to_screen(space, space.active_client, *output);
+    }
+}
+
+template<typename Space>
+void active_window_to_prev_output(Space& space)
+{
+    if (!has_usable_active_window(space)) {
+        return;
+    }
+    if (auto output = get_derivated_output(space.active_client->central_output, -1)) {
+        send_to_screen(space, space.active_client, *output);
+    }
+}
+
+template<typename Space>
+void active_window_maximize(Space& space)
+{
+    if (has_usable_active_window(space)) {
+        perform_window_operation(space, space.active_client, base::options::MaximizeOp);
+    }
+}
+
+template<typename Space>
+void active_window_maximize_vertical(Space& space)
+{
+    if (has_usable_active_window(space)) {
+        perform_window_operation(space, space.active_client, base::options::VMaximizeOp);
+    }
+}
+
+template<typename Space>
+void active_window_maximize_horizontal(Space& space)
+{
+    if (has_usable_active_window(space)) {
+        perform_window_operation(space, space.active_client, base::options::HMaximizeOp);
+    }
+}
+
+template<typename Space>
+void active_window_minimize(Space& space)
+{
+    if (has_usable_active_window(space)) {
+        perform_window_operation(space, space.active_client, base::options::MinimizeOp);
+    }
+}
+
+template<typename Space>
+void active_window_raise(Space& space)
+{
+    if (has_usable_active_window(space)) {
+        raise_window(&space, space.active_client);
+    }
+}
+
+template<typename Space>
+void active_window_lower(Space& space)
+{
+    if (!has_usable_active_window(space)) {
+        return;
+    }
+
+    lower_window(&space, space.active_client);
+    // As this most likely makes the window no longer visible change the
+    // keyboard focus to the next available window.
+    // activateNextClient( c ); // Doesn't work when we lower a child window
+    if (space.active_client->control->active() && kwinApp()->options->focusPolicyIsReasonable()) {
+        if (kwinApp()->options->isNextFocusPrefersMouse()) {
+            auto next = window_under_mouse(space, space.active_client->central_output);
+            if (next && next != space.active_client)
+                request_focus(space, next);
+        } else {
+            activate_window(
+                space,
+                top_client_on_desktop(&space, space.virtual_desktop_manager->current(), nullptr));
+        }
+    }
+}
+
+template<typename Space>
+void active_window_raise_or_lower(Space& space)
+{
+    if (has_usable_active_window(space)) {
+        raise_or_lower_client(&space, space.active_client);
+    }
+}
+
+template<typename Space>
+void active_window_set_on_all_desktops(Space& space)
+{
+    if (has_usable_active_window(space)) {
+        set_on_all_desktops(space.active_client, !space.active_client->isOnAllDesktops());
+    }
+}
+
+template<typename Space>
+void active_window_set_fullscreen(Space& space)
+{
+    if (has_usable_active_window(space)) {
+        perform_window_operation(space, space.active_client, base::options::FullScreenOp);
+    }
+}
+
+template<typename Space>
+void active_window_set_no_border(Space& space)
+{
+    if (has_usable_active_window(space)) {
+        perform_window_operation(space, space.active_client, base::options::NoBorderOp);
+    }
+}
+
+template<typename Space>
+void active_window_set_keep_above(Space& space)
+{
+    if (has_usable_active_window(space)) {
+        perform_window_operation(space, space.active_client, base::options::KeepAboveOp);
+    }
+}
+
+template<typename Space>
+void active_window_set_keep_below(Space& space)
+{
+    if (has_usable_active_window(space)) {
+        perform_window_operation(space, space.active_client, base::options::KeepBelowOp);
+    }
+}
+
+template<typename Space>
+void active_window_setup_window_shortcut(Space& space)
+{
+    if (has_usable_active_window(space)) {
+        perform_window_operation(space, space.active_client, base::options::SetupWindowShortcutOp);
+    }
+}
+
+template<typename Space>
+void active_window_close(Space& space)
+{
+    if (has_usable_active_window(space)) {
+        perform_window_operation(space, space.active_client, base::options::CloseOp);
+    }
+}
+
+template<typename Space>
+void active_window_move(Space& space)
+{
+    if (has_usable_active_window(space)) {
+        perform_window_operation(space, space.active_client, base::options::UnrestrictedMoveOp);
+    }
+}
+
+template<typename Space>
+void active_window_resize(Space& space)
+{
+    if (has_usable_active_window(space)) {
+        perform_window_operation(space, space.active_client, base::options::UnrestrictedResizeOp);
+    }
+}
+
+template<typename Space>
+void active_window_increase_opacity(Space& space)
+{
+    if (space.active_client) {
+        space.active_client->setOpacity(qMin(space.active_client->opacity() + 0.05, 1.0));
+    }
+}
+
+template<typename Space>
+void active_window_lower_opacity(Space& space)
+{
+    if (space.active_client) {
+        space.active_client->setOpacity(qMax(space.active_client->opacity() - 0.05, 0.05));
+    }
+}
+
+template<typename Space>
+void active_window_to_next_desktop(Space& space)
+{
+    if (has_usable_active_window(space)) {
+        window_to_next_desktop(*space.active_client);
+    }
+}
+
+template<typename Space>
+void active_window_to_prev_desktop(Space& space)
+{
+    if (has_usable_active_window(space)) {
+        window_to_prev_desktop(*space.active_client);
+    }
+}
+
+template<typename Direction, typename Space>
+void active_window_to_desktop(Space& space)
+{
+    auto& vds = space.virtual_desktop_manager;
+    int const current = vds->current();
+    Direction functor(*vds);
+
+    int const d = functor(current, kwinApp()->options->isRollOverDesktops());
+    if (d == current) {
+        return;
+    }
+
+    set_move_resize_window(space, space.active_client);
+    vds->setCurrent(d);
+    set_move_resize_window(space, nullptr);
+}
+
+template<typename Space>
+void active_window_to_right_desktop(Space& space)
+{
+    if (has_usable_active_window(space)) {
+        active_window_to_desktop<virtual_desktop_right>(space);
+    }
+}
+
+template<typename Space>
+void active_window_to_left_desktop(Space& space)
+{
+    if (has_usable_active_window(space)) {
+        active_window_to_desktop<virtual_desktop_left>(space);
+    }
+}
+
+template<typename Space>
+void active_window_to_above_desktop(Space& space)
+{
+    if (has_usable_active_window(space)) {
+        active_window_to_desktop<virtual_desktop_above>(space);
+    }
+}
+
+template<typename Space>
+void active_window_to_below_desktop(Space& space)
+{
+    if (has_usable_active_window(space)) {
+        active_window_to_desktop<virtual_desktop_below>(space);
+    }
+}
+
+template<typename Space>
+void active_window_show_operations_popup(Space& space)
+{
+    if (!space.active_client) {
+        return;
+    }
+
+    auto pos = frame_to_client_pos(space.active_client, space.active_client->pos());
+    space.showWindowMenu(QRect(pos, pos), space.active_client);
+}
+
+template<typename Space>
+void active_window_pack_left(Space& space)
+{
+    if (!can_move(space.active_client)) {
+        return;
+    }
+    auto const pos = space.active_client->geometry_update.frame.topLeft();
+    pack_to(
+        space.active_client, space.packPositionLeft(space.active_client, pos.x(), true), pos.y());
+}
+
+template<typename Space>
+void active_window_pack_right(Space& space)
+{
+    if (!can_move(space.active_client)) {
+        return;
+    }
+
+    auto const pos = space.active_client->geometry_update.frame.topLeft();
+    auto const width = space.active_client->geometry_update.frame.size().width();
+    pack_to(space.active_client,
+            space.packPositionRight(space.active_client, pos.x() + width, true) - width + 1,
+            pos.y());
+}
+
+template<typename Space>
+void active_window_pack_up(Space& space)
+{
+    if (!can_move(space.active_client)) {
+        return;
+    }
+
+    auto const pos = space.active_client->geometry_update.frame.topLeft();
+    pack_to(space.active_client, pos.x(), space.packPositionUp(space.active_client, pos.y(), true));
+}
+
+template<typename Space>
+void active_window_pack_down(Space& space)
+{
+    if (!can_move(space.active_client)) {
+        return;
+    }
+
+    auto const pos = space.active_client->geometry_update.frame.topLeft();
+    auto const height = space.active_client->geometry_update.frame.size().height();
+    pack_to(space.active_client,
+            pos.x(),
+            space.packPositionDown(space.active_client, pos.y() + height, true) - height + 1);
+}
+
+template<typename Space>
+void active_window_grow_horizontal(Space& space)
+{
+    if (space.active_client) {
+        grow_horizontal(space.active_client);
+    }
+}
+
+template<typename Space>
+void active_window_shrink_horizontal(Space& space)
+{
+    if (space.active_client) {
+        shrink_horizontal(space.active_client);
+    }
+}
+
+template<typename Space>
+void active_window_grow_vertical(Space& space)
+{
+    if (space.active_client) {
+        grow_vertical(space.active_client);
+    }
+}
+
+template<typename Space>
+void active_window_shrink_vertical(Space& space)
+{
+    if (space.active_client) {
+        shrink_vertical(space.active_client);
+    }
+}
+
+}
diff --git a/win/deco/client_impl.cpp b/win/deco/client_impl.cpp
index 3a75fdbf5..5abbd2f52 100644
--- a/win/deco/client_impl.cpp
+++ b/win/deco/client_impl.cpp
@@ -35,6 +35,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "win/meta.h"
 #include "win/space.h"
 #include "win/transient.h"
+#include "win/window_operation.h"
 
 #include <KDecoration2/DecoratedClient>
 #include <KDecoration2/Decoration>
@@ -248,7 +249,7 @@ DELEGATE(WId, decorationId, frameId)
 #define DELEGATE(name, op)                                                                         \
     void client_impl::name()                                                                       \
     {                                                                                              \
-        space.performWindowOperation(m_client, base::options::op);                                 \
+        win::perform_window_operation(space, m_client, base::options::op);                         \
     }
 
 DELEGATE(requestToggleOnAllDesktops, OnAllDesktopsOp)
@@ -334,8 +335,8 @@ void client_impl::requestToggleMaximization(Qt::MouseButtons buttons)
     QMetaObject::invokeMethod(
         qobject.get(),
         [this, buttons] {
-            space.performWindowOperation(m_client,
-                                         kwinApp()->options->operationMaxButtonClick(buttons));
+            perform_window_operation(
+                space, m_client, kwinApp()->options->operationMaxButtonClick(buttons));
         },
         Qt::QueuedConnection);
 }
diff --git a/win/desktop_space.h b/win/desktop_space.h
index d17827b1b..3ec24be93 100644
--- a/win/desktop_space.h
+++ b/win/desktop_space.h
@@ -98,7 +98,7 @@ void update_client_visibility_on_desktop_change(Space* space, uint newDesktop)
 
     if (space->showingDesktop()) {
         // Do this only after desktop change to avoid flicker.
-        space->setShowingDesktop(false);
+        set_showing_desktop(*space, false);
     }
 }
 
@@ -124,4 +124,33 @@ void handle_desktop_count_changed(Space& space, unsigned int /*prev*/, unsigned
     reset_space_areas(space, next);
 }
 
+template<typename Direction, typename Win>
+void window_to_desktop(Win& window)
+{
+    auto& ws = window.space;
+    auto& vds = ws.virtual_desktop_manager;
+    Direction functor(*vds);
+
+    // TODO: why is kwinApp()->options->isRollOverDesktops() not honored?
+    auto const desktop = functor(nullptr, true);
+
+    if (!is_desktop(&window) && !is_dock(&window)) {
+        set_move_resize_window(ws, &window);
+        vds->setCurrent(desktop);
+        set_move_resize_window(ws, nullptr);
+    }
+}
+
+template<typename Win>
+void window_to_next_desktop(Win& window)
+{
+    window_to_desktop<win::virtual_desktop_next>(window);
+}
+
+template<typename Win>
+void window_to_prev_desktop(Win& window)
+{
+    window_to_desktop<win::virtual_desktop_previous>(window);
+}
+
 }
diff --git a/win/input.h b/win/input.h
index 8d61a147a..7bfb7d9c9 100644
--- a/win/input.h
+++ b/win/input.h
@@ -15,6 +15,7 @@
 #include "toplevel.h"
 #include "types.h"
 #include "user_actions_menu.h"
+#include "window_operation.h"
 
 #include "base/options.h"
 #include "utils/blocker.h"
@@ -189,10 +190,10 @@ bool perform_mouse_command(Win& win, base::options::MouseCommand cmd, QPoint con
         break;
     }
     case base::options::MousePreviousDesktop:
-        space.windowToPreviousDesktop(win);
+        window_to_prev_desktop(win);
         break;
     case base::options::MouseNextDesktop:
-        space.windowToNextDesktop(win);
+        window_to_next_desktop(win);
         break;
     case base::options::MouseOpacityMore:
         // No point in changing the opacity of the desktop.
@@ -364,8 +365,8 @@ bool process_decoration_button_press(Win* win, QMouseEvent* event, bool ignoreMe
                 // expired -> new first click and pot. init
                 deco.double_click.start();
             } else {
-                win->space.performWindowOperation(win,
-                                                  kwinApp()->options->operationTitlebarDblClick());
+                perform_window_operation(
+                    win->space, win, kwinApp()->options->operationTitlebarDblClick());
                 end_move_resize(win);
                 return false;
             }
diff --git a/win/kill_window.h b/win/kill_window.h
index 07fe01419..491bbd02d 100644
--- a/win/kill_window.h
+++ b/win/kill_window.h
@@ -60,4 +60,13 @@ private:
     Space& space;
 };
 
+template<typename Space>
+void start_window_killer(Space& space)
+{
+    if (!space.window_killer) {
+        space.window_killer = std::make_unique<kill_window<Space>>(space);
+    }
+    space.window_killer->start();
+}
+
 }
diff --git a/win/output_space.h b/win/output_space.h
index cda01e35e..e43ce2e7c 100644
--- a/win/output_space.h
+++ b/win/output_space.h
@@ -9,12 +9,31 @@
 #include "screen.h"
 #include "stacking.h"
 
+#include "base/output.h"
 #include "base/output_helpers.h"
 #include "main.h"
 
 namespace KWin::win
 {
 
+static inline bool is_output_switch_impossible()
+{
+    if (!kwinApp()->options->get_current_output_follows_mouse()) {
+        return false;
+    }
+
+    QStringList args;
+    args << QStringLiteral("--passivepopup")
+         << i18n(
+                "The window manager is configured to consider the screen with the mouse on it as "
+                "active one.\n"
+                "Therefore it is not possible to switch to a screen explicitly.")
+         << QStringLiteral("20");
+
+    KProcess::startDetached(QStringLiteral("kdialog"), args);
+    return true;
+}
+
 template<typename Space>
 void set_current_output(Space& space, base::output const& output)
 {
@@ -38,4 +57,55 @@ void set_current_output(Space& space, base::output const& output)
     base::set_current_output(kwinApp()->get_base(), &output);
 }
 
+template<typename Space>
+void switch_to_output(Space& space, QAction* action)
+{
+    if (is_output_switch_impossible()) {
+        return;
+    }
+
+    int const screen = get_action_data_as_uint(action);
+    auto output = base::get_output(kwinApp()->get_base().get_outputs(), screen);
+
+    if (output) {
+        set_current_output(space, *output);
+    }
+}
+
+static inline base::output const* get_derivated_output(base::output const* output, int drift)
+{
+    auto const& outputs = kwinApp()->get_base().get_outputs();
+    auto index = output ? base::get_output_index(outputs, *output) : 0;
+    index += drift;
+    return base::get_output(outputs, index % outputs.size());
+}
+
+template<typename Space>
+base::output const* get_derivated_output(Space& space, int drift)
+{
+    return get_derivated_output(get_current_output(space), drift);
+}
+
+template<typename Space>
+void switch_to_next_output(Space& space)
+{
+    if (is_output_switch_impossible()) {
+        return;
+    }
+    if (auto output = get_derivated_output(space, 1)) {
+        set_current_output(space, *output);
+    }
+}
+
+template<typename Space>
+void switch_to_prev_output(Space& space)
+{
+    if (is_output_switch_impossible()) {
+        return;
+    }
+    if (auto output = get_derivated_output(space, -1)) {
+        set_current_output(space, *output);
+    }
+}
+
 }
diff --git a/win/screen_edges.cpp b/win/screen_edges.cpp
index be367e0cc..ee9e19fa3 100644
--- a/win/screen_edges.cpp
+++ b/win/screen_edges.cpp
@@ -10,6 +10,7 @@
 */
 #include "screen_edges.h"
 
+#include "activation.h"
 #include "move.h"
 #include "space.h"
 
@@ -318,7 +319,7 @@ bool screen_edge::handleAction(ElectricBorderAction action)
 {
     switch (action) {
     case ElectricActionShowDesktop: {
-        edger->space.setShowingDesktop(!edger->space.showingDesktop());
+        set_showing_desktop(edger->space, !edger->space.showingDesktop());
         return true;
     }
     case ElectricActionLockScreen: { // Lock the screen
diff --git a/win/space.cpp b/win/space.cpp
index 09cb181b4..e1069664e 100644
--- a/win/space.cpp
+++ b/win/space.cpp
@@ -22,6 +22,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "space.h"
 
 #include "activation.h"
+#include "active_window.h"
 #include "deco/bridge.h"
 #include "desktop_space.h"
 #include "output_space.h"
@@ -301,52 +302,6 @@ bool space::checkStartupNotification(xcb_window_t w, KStartupInfoId& id, KStartu
     return startup->checkStartup(w, id, data) == KStartupInfo::Match;
 }
 
-void space::setShowingDesktop(bool showing)
-{
-    const bool changed = showing != showing_desktop;
-    if (win::x11::rootInfo() && changed) {
-        win::x11::rootInfo()->setShowingDesktop(showing);
-    }
-    showing_desktop = showing;
-
-    Toplevel* topDesk = nullptr;
-
-    {                                  // for the blocker RAII
-        blocker block(stacking_order); // updateLayer & lowerClient would invalidate stacking_order
-        for (int i = static_cast<int>(stacking_order->stack.size()) - 1; i > -1; --i) {
-            auto c = qobject_cast<Toplevel*>(stacking_order->stack.at(i));
-            if (c && c->isOnCurrentDesktop()) {
-                if (win::is_dock(c)) {
-                    win::update_layer(c);
-                } else if (win::is_desktop(c) && c->isShown()) {
-                    win::update_layer(c);
-                    win::lower_window(this, c);
-                    if (!topDesk)
-                        topDesk = c;
-                    if (auto group = c->group()) {
-                        for (auto cm : group->members) {
-                            win::update_layer(cm);
-                        }
-                    }
-                }
-            }
-        }
-    } // ~Blocker
-
-    if (showing_desktop && topDesk) {
-        request_focus(*this, topDesk);
-    } else if (!showing_desktop && changed) {
-        const auto client = focus_chain_get_for_activation_on_current_output<Toplevel>(
-            focus_chain, virtual_desktop_manager->current());
-        if (client) {
-            activate_window(*this, client);
-        }
-    }
-    if (changed) {
-        Q_EMIT qobject->showingDesktopChanged(showing);
-    }
-}
-
 void space::disableGlobalShortcutsForClient(bool disable)
 {
     if (global_shortcuts_disabled_for_client == disable)
@@ -1027,82 +982,6 @@ std::vector<Toplevel*> space::remnants() const
 
 #ifndef KCMRULES
 
-// ********************
-// placement code
-// ********************
-
-/**
- * Moves active window left until in bumps into another window or workarea edge.
- */
-void space::slotWindowPackLeft()
-{
-    if (!win::can_move(active_client)) {
-        return;
-    }
-    auto const pos = active_client->geometry_update.frame.topLeft();
-    win::pack_to(active_client, packPositionLeft(active_client, pos.x(), true), pos.y());
-}
-
-void space::slotWindowPackRight()
-{
-    if (!win::can_move(active_client)) {
-        return;
-    }
-    auto const pos = active_client->geometry_update.frame.topLeft();
-    auto const width = active_client->geometry_update.frame.size().width();
-    win::pack_to(active_client,
-                 packPositionRight(active_client, pos.x() + width, true) - width + 1,
-                 pos.y());
-}
-
-void space::slotWindowPackUp()
-{
-    if (!win::can_move(active_client)) {
-        return;
-    }
-    auto const pos = active_client->geometry_update.frame.topLeft();
-    win::pack_to(active_client, pos.x(), packPositionUp(active_client, pos.y(), true));
-}
-
-void space::slotWindowPackDown()
-{
-    if (!win::can_move(active_client)) {
-        return;
-    }
-    auto const pos = active_client->geometry_update.frame.topLeft();
-    auto const height = active_client->geometry_update.frame.size().height();
-    win::pack_to(active_client,
-                 pos.x(),
-                 packPositionDown(active_client, pos.y() + height, true) - height + 1);
-}
-
-void space::slotWindowGrowHorizontal()
-{
-    if (active_client) {
-        win::grow_horizontal(active_client);
-    }
-}
-
-void space::slotWindowShrinkHorizontal()
-{
-    if (active_client) {
-        win::shrink_horizontal(active_client);
-    }
-}
-void space::slotWindowGrowVertical()
-{
-    if (active_client) {
-        win::grow_vertical(active_client);
-    }
-}
-
-void space::slotWindowShrinkVertical()
-{
-    if (active_client) {
-        win::shrink_vertical(active_client);
-    }
-}
-
 void space::quickTileWindow(win::quicktiles mode)
 {
     if (!active_client) {
@@ -1527,22 +1406,6 @@ bool space::workspaceEvent(QEvent* e)
     return false;
 }
 
-void space::slotIncreaseWindowOpacity()
-{
-    if (!active_client) {
-        return;
-    }
-    active_client->setOpacity(qMin(active_client->opacity() + 0.05, 1.0));
-}
-
-void space::slotLowerWindowOpacity()
-{
-    if (!active_client) {
-        return;
-    }
-    active_client->setOpacity(qMax(active_client->opacity() - 0.05, 0.05));
-}
-
 QAction* prepare_shortcut_action(win::space& space,
                                  QString const& actionName,
                                  QString const& description,
@@ -1606,11 +1469,12 @@ void space::initShortcuts()
     // new DEF3 allows to pass data to the action, replacing the %1 argument in the name
 
 #define DEF2(name, descr, key, fnSlot)                                                             \
-    initShortcut(QStringLiteral(name), descr.toString(), key, [this] { fnSlot(); });
+    initShortcut(QStringLiteral(name), descr.toString(), key, [this] { fnSlot(*this); });
 
 #define DEF(name, key, fnSlot)                                                                     \
-    initShortcut(                                                                                  \
-        QString::fromUtf8(name.untranslatedText()), name.toString(), key, [this] { fnSlot(); });
+    initShortcut(QString::fromUtf8(name.untranslatedText()), name.toString(), key, [this] {        \
+        fnSlot(*this);                                                                             \
+    });
 
 #define DEF3(name, key, fnSlot, value)                                                             \
     init_shortcut_with_action_arg(                                                                 \
@@ -1618,70 +1482,82 @@ void space::initShortcuts()
         name.subs(value).toString(),                                                               \
         key,                                                                                       \
         qobject.get(),                                                                             \
-        [this](QAction* action) { fnSlot(action); },                                               \
+        [this](QAction* action) { fnSlot(*this, action); },                                        \
         value);
 
 #define DEF4(name, descr, key, functor)                                                            \
     initShortcut(QStringLiteral(name), descr.toString(), key, functor);
 
-#define DEF5(name, key, functor, value)                                                            \
-    initShortcut(QString::fromUtf8(name.untranslatedText()).arg(value),                            \
-                 name.subs(value).toString(),                                                      \
-                 key,                                                                              \
-                 functor,                                                                          \
-                 value);
+    auto def5 = [this](auto name, auto key, auto functor, auto value) {
+        initShortcut(QString::fromUtf8(name.untranslatedText()).arg(value),
+                     name.subs(value).toString(),
+                     key,
+                     functor,
+                     value);
+    };
 
 #define DEF6(name, key, target, fnSlot)                                                            \
     initShortcut(QString::fromUtf8(name.untranslatedText()), name.toString(), key, target, &fnSlot);
 
-    DEF(kli18n("Window Operations Menu"), Qt::ALT + Qt::Key_F3, slotWindowOperations);
-    DEF2("Window Close", kli18n("Close Window"), Qt::ALT + Qt::Key_F4, slotWindowClose);
+    DEF(kli18n("Window Operations Menu"),
+        Qt::ALT + Qt::Key_F3,
+        active_window_show_operations_popup);
+    DEF2("Window Close", kli18n("Close Window"), Qt::ALT + Qt::Key_F4, active_window_close);
     DEF2("Window Maximize",
          kli18n("Maximize Window"),
          Qt::META + Qt::Key_PageUp,
-         slotWindowMaximize);
+         active_window_maximize);
     DEF2("Window Maximize Vertical",
          kli18n("Maximize Window Vertically"),
          0,
-         slotWindowMaximizeVertical);
+         active_window_maximize_vertical);
     DEF2("Window Maximize Horizontal",
          kli18n("Maximize Window Horizontally"),
          0,
-         slotWindowMaximizeHorizontal);
+         active_window_maximize_horizontal);
     DEF2("Window Minimize",
          kli18n("Minimize Window"),
          Qt::META + Qt::Key_PageDown,
-         slotWindowMinimize);
-    DEF2("Window Move", kli18n("Move Window"), 0, slotWindowMove);
-    DEF2("Window Resize", kli18n("Resize Window"), 0, slotWindowResize);
-    DEF2("Window Raise", kli18n("Raise Window"), 0, slotWindowRaise);
-    DEF2("Window Lower", kli18n("Lower Window"), 0, slotWindowLower);
-    DEF(kli18n("Toggle Window Raise/Lower"), 0, slotWindowRaiseOrLower);
-    DEF2("Window Fullscreen", kli18n("Make Window Fullscreen"), 0, slotWindowFullScreen);
-    DEF2("Window No Border", kli18n("Hide Window Border"), 0, slotWindowNoBorder);
-    DEF2("Window Above Other Windows", kli18n("Keep Window Above Others"), 0, slotWindowAbove);
-    DEF2("Window Below Other Windows", kli18n("Keep Window Below Others"), 0, slotWindowBelow);
+         active_window_minimize);
+    DEF2("Window Move", kli18n("Move Window"), 0, active_window_move);
+    DEF2("Window Resize", kli18n("Resize Window"), 0, active_window_resize);
+    DEF2("Window Raise", kli18n("Raise Window"), 0, active_window_raise);
+    DEF2("Window Lower", kli18n("Lower Window"), 0, active_window_lower);
+    DEF(kli18n("Toggle Window Raise/Lower"), 0, active_window_raise_or_lower);
+    DEF2("Window Fullscreen", kli18n("Make Window Fullscreen"), 0, active_window_set_fullscreen);
+    DEF2("Window No Border", kli18n("Hide Window Border"), 0, active_window_set_no_border);
+    DEF2("Window Above Other Windows",
+         kli18n("Keep Window Above Others"),
+         0,
+         active_window_set_keep_above);
+    DEF2("Window Below Other Windows",
+         kli18n("Keep Window Below Others"),
+         0,
+         active_window_set_keep_below);
     DEF(kli18n("Activate Window Demanding Attention"),
         Qt::META | Qt::CTRL | Qt::Key_A,
-        slotActivateAttentionWindow);
-    DEF(kli18n("Setup Window Shortcut"), 0, slotSetupWindowShortcut);
-    DEF2("Window Pack Right", kli18n("Pack Window to the Right"), 0, slotWindowPackRight);
-    DEF2("Window Pack Left", kli18n("Pack Window to the Left"), 0, slotWindowPackLeft);
-    DEF2("Window Pack Up", kli18n("Pack Window Up"), 0, slotWindowPackUp);
-    DEF2("Window Pack Down", kli18n("Pack Window Down"), 0, slotWindowPackDown);
+        activate_attention_window);
+    DEF(kli18n("Setup Window Shortcut"), 0, active_window_setup_window_shortcut);
+    DEF2("Window Pack Right", kli18n("Pack Window to the Right"), 0, active_window_pack_right);
+    DEF2("Window Pack Left", kli18n("Pack Window to the Left"), 0, active_window_pack_left);
+    DEF2("Window Pack Up", kli18n("Pack Window Up"), 0, active_window_pack_up);
+    DEF2("Window Pack Down", kli18n("Pack Window Down"), 0, active_window_pack_down);
     DEF2("Window Grow Horizontal",
          kli18n("Pack Grow Window Horizontally"),
          0,
-         slotWindowGrowHorizontal);
-    DEF2("Window Grow Vertical", kli18n("Pack Grow Window Vertically"), 0, slotWindowGrowVertical);
+         active_window_grow_horizontal);
+    DEF2("Window Grow Vertical",
+         kli18n("Pack Grow Window Vertically"),
+         0,
+         active_window_grow_vertical);
     DEF2("Window Shrink Horizontal",
          kli18n("Pack Shrink Window Horizontally"),
          0,
-         slotWindowShrinkHorizontal);
+         active_window_shrink_horizontal);
     DEF2("Window Shrink Vertical",
          kli18n("Pack Shrink Window Vertically"),
          0,
-         slotWindowShrinkVertical);
+         active_window_shrink_vertical);
     DEF4("Window Quick Tile Left",
          kli18n("Quick Tile Window to the Left"),
          Qt::META + Qt::Key_Left,
@@ -1738,50 +1614,47 @@ void space::initShortcuts()
     DEF2("Increase Opacity",
          kli18n("Increase Opacity of Active Window by 5 %"),
          0,
-         slotIncreaseWindowOpacity);
+         active_window_increase_opacity);
     DEF2("Decrease Opacity",
          kli18n("Decrease Opacity of Active Window by 5 %"),
          0,
-         slotLowerWindowOpacity);
+         active_window_lower_opacity);
 
     DEF2("Window On All Desktops",
          kli18n("Keep Window on All Desktops"),
          0,
-         slotWindowOnAllDesktops);
+         active_window_set_on_all_desktops);
 
     for (int i = 1; i < 21; ++i) {
-        DEF5(kli18n("Window to Desktop %1"), 0, std::bind(&space::slotWindowToDesktop, this, i), i);
+        def5(
+            kli18n("Window to Desktop %1"),
+            0,
+            [this, i] { active_window_to_desktop(*this, i); },
+            i);
     }
-    DEF(kli18n("Window to Next Desktop"), 0, slotWindowToNextDesktop);
-    DEF(kli18n("Window to Previous Desktop"), 0, slotWindowToPreviousDesktop);
-    DEF(kli18n("Window One Desktop to the Right"), 0, slotWindowToDesktopRight);
-    DEF(kli18n("Window One Desktop to the Left"), 0, slotWindowToDesktopLeft);
-    DEF(kli18n("Window One Desktop Up"), 0, slotWindowToDesktopUp);
-    DEF(kli18n("Window One Desktop Down"), 0, slotWindowToDesktopDown);
+
+    DEF(kli18n("Window to Next Desktop"), 0, active_window_to_next_desktop);
+    DEF(kli18n("Window to Previous Desktop"), 0, active_window_to_prev_desktop);
+    DEF(kli18n("Window One Desktop to the Right"), 0, active_window_to_right_desktop);
+    DEF(kli18n("Window One Desktop to the Left"), 0, active_window_to_left_desktop);
+    DEF(kli18n("Window One Desktop Up"), 0, active_window_to_above_desktop);
+    DEF(kli18n("Window One Desktop Down"), 0, active_window_to_below_desktop);
 
     for (int i = 0; i < 8; ++i) {
-        DEF3(
-            kli18n("Window to Screen %1"),
-            0,
-            [this](QAction* action) { slotWindowToScreen(action); },
-            i);
+        DEF3(kli18n("Window to Screen %1"), 0, active_window_to_output, i);
     }
-    DEF(kli18n("Window to Next Screen"), 0, slotWindowToNextScreen);
-    DEF(kli18n("Window to Previous Screen"), 0, slotWindowToPrevScreen);
-    DEF(kli18n("Show Desktop"), Qt::META + Qt::Key_D, slotToggleShowDesktop);
+    DEF(kli18n("Window to Next Screen"), 0, active_window_to_next_output);
+    DEF(kli18n("Window to Previous Screen"), 0, active_window_to_prev_output);
+    DEF(kli18n("Show Desktop"), Qt::META + Qt::Key_D, toggle_show_desktop);
 
     for (int i = 0; i < 8; ++i) {
-        DEF3(
-            kli18n("Switch to Screen %1"),
-            0,
-            [this](QAction* action) { slotSwitchToScreen(action); },
-            i);
+        DEF3(kli18n("Switch to Screen %1"), 0, switch_to_output, i);
     }
 
-    DEF(kli18n("Switch to Next Screen"), 0, slotSwitchToNextScreen);
-    DEF(kli18n("Switch to Previous Screen"), 0, slotSwitchToPrevScreen);
+    DEF(kli18n("Switch to Next Screen"), 0, switch_to_next_output);
+    DEF(kli18n("Switch to Previous Screen"), 0, switch_to_prev_output);
 
-    DEF(kli18n("Kill Window"), Qt::META | Qt::CTRL | Qt::Key_Escape, slotKillWindow);
+    DEF(kli18n("Kill Window"), Qt::META | Qt::CTRL | Qt::Key_Escape, start_window_killer);
     DEF6(kli18n("Suspend Compositing"),
          Qt::SHIFT + Qt::ALT + Qt::Key_F12,
          &render,
@@ -1883,445 +1756,6 @@ void space::clientShortcutUpdated(Toplevel* window)
     }
 }
 
-void space::performWindowOperation(Toplevel* window, base::options::WindowOperation op)
-{
-    if (!window) {
-        return;
-    }
-
-    auto cursor = input::get_cursor();
-
-    if (op == base::options::MoveOp || op == base::options::UnrestrictedMoveOp) {
-        cursor->set_pos(window->frameGeometry().center());
-    }
-    if (op == base::options::ResizeOp || op == base::options::UnrestrictedResizeOp) {
-        cursor->set_pos(window->frameGeometry().bottomRight());
-    }
-
-    switch (op) {
-    case base::options::MoveOp:
-        window->performMouseCommand(base::options::MouseMove, cursor->pos());
-        break;
-    case base::options::UnrestrictedMoveOp:
-        window->performMouseCommand(base::options::MouseUnrestrictedMove, cursor->pos());
-        break;
-    case base::options::ResizeOp:
-        window->performMouseCommand(base::options::MouseResize, cursor->pos());
-        break;
-    case base::options::UnrestrictedResizeOp:
-        window->performMouseCommand(base::options::MouseUnrestrictedResize, cursor->pos());
-        break;
-    case base::options::CloseOp:
-        QMetaObject::invokeMethod(window, "closeWindow", Qt::QueuedConnection);
-        break;
-    case base::options::MaximizeOp:
-        win::maximize(window,
-                      window->maximizeMode() == win::maximize_mode::full
-                          ? win::maximize_mode::restore
-                          : win::maximize_mode::full);
-        break;
-    case base::options::HMaximizeOp:
-        win::maximize(window, window->maximizeMode() ^ win::maximize_mode::horizontal);
-        break;
-    case base::options::VMaximizeOp:
-        win::maximize(window, window->maximizeMode() ^ win::maximize_mode::vertical);
-        break;
-    case base::options::RestoreOp:
-        win::maximize(window, win::maximize_mode::restore);
-        break;
-    case base::options::MinimizeOp:
-        win::set_minimized(window, true);
-        break;
-    case base::options::OnAllDesktopsOp:
-        win::set_on_all_desktops(window, !window->isOnAllDesktops());
-        break;
-    case base::options::FullScreenOp:
-        window->setFullScreen(!window->control->fullscreen(), true);
-        break;
-    case base::options::NoBorderOp:
-        window->setNoBorder(!window->noBorder());
-        break;
-    case base::options::KeepAboveOp: {
-        blocker block(stacking_order);
-        bool was = window->control->keep_above();
-        win::set_keep_above(window, !window->control->keep_above());
-        if (was && !window->control->keep_above()) {
-            win::raise_window(this, window);
-        }
-        break;
-    }
-    case base::options::KeepBelowOp: {
-        blocker block(stacking_order);
-        bool was = window->control->keep_below();
-        win::set_keep_below(window, !window->control->keep_below());
-        if (was && !window->control->keep_below()) {
-            win::lower_window(this, window);
-        }
-        break;
-    }
-    case base::options::WindowRulesOp:
-        rule_book->edit(window, false);
-        break;
-    case base::options::ApplicationRulesOp:
-        rule_book->edit(window, true);
-        break;
-    case base::options::SetupWindowShortcutOp:
-        setupWindowShortcut(window);
-        break;
-    case base::options::LowerOp:
-        win::lower_window(this, window);
-        break;
-    case base::options::OperationsOp:
-    case base::options::NoOp:
-        break;
-    }
-}
-
-void space::slotActivateAttentionWindow()
-{
-    if (attention_chain.size() > 0) {
-        activate_window(*this, attention_chain.front());
-    }
-}
-
-static uint senderValue(QAction* act)
-{
-    bool ok = false;
-    uint i = -1;
-    if (act)
-        i = act->data().toUInt(&ok);
-    if (ok)
-        return i;
-    return -1;
-}
-
-#define USABLE_ACTIVE_CLIENT                                                                       \
-    (active_client && !(win::is_desktop(active_client) || win::is_dock(active_client)))
-
-void space::slotWindowToDesktop(uint i)
-{
-    if (USABLE_ACTIVE_CLIENT) {
-        if (i < 1)
-            return;
-
-        if (i >= 1 && i <= virtual_desktop_manager->count())
-            send_window_to_desktop(*this, active_client, i, true);
-    }
-}
-
-static bool screenSwitchImpossible()
-{
-    if (!kwinApp()->options->get_current_output_follows_mouse()) {
-        return false;
-    }
-    QStringList args;
-    args << QStringLiteral("--passivepopup")
-         << i18n(
-                "The window manager is configured to consider the screen with the mouse on it as "
-                "active one.\n"
-                "Therefore it is not possible to switch to a screen explicitly.")
-         << QStringLiteral("20");
-    KProcess::startDetached(QStringLiteral("kdialog"), args);
-    return true;
-}
-
-void space::slotSwitchToScreen(QAction* action)
-{
-    if (screenSwitchImpossible()) {
-        return;
-    }
-
-    int const screen = senderValue(action);
-    auto output = base::get_output(kwinApp()->get_base().get_outputs(), screen);
-
-    if (output) {
-        set_current_output(*this, *output);
-    }
-}
-
-base::output const* get_derivated_output(base::output const* output, int drift)
-{
-    auto const& outputs = kwinApp()->get_base().get_outputs();
-    auto index = output ? base::get_output_index(outputs, *output) : 0;
-    index += drift;
-    return base::get_output(outputs, index % outputs.size());
-}
-
-base::output const* get_derivated_output(win::space& space, int drift)
-{
-    return get_derivated_output(get_current_output(space), drift);
-}
-
-void space::slotSwitchToNextScreen()
-{
-    if (screenSwitchImpossible()) {
-        return;
-    }
-    if (auto output = get_derivated_output(*this, 1)) {
-        set_current_output(*this, *output);
-    }
-}
-
-void space::slotSwitchToPrevScreen()
-{
-    if (screenSwitchImpossible()) {
-        return;
-    }
-    if (auto output = get_derivated_output(*this, -1)) {
-        set_current_output(*this, *output);
-    }
-}
-
-void space::slotWindowToScreen(QAction* action)
-{
-    if (USABLE_ACTIVE_CLIENT) {
-        int const screen = senderValue(action);
-        auto output = base::get_output(kwinApp()->get_base().get_outputs(), screen);
-        if (output) {
-            send_to_screen(*this, active_client, *output);
-        }
-    }
-}
-
-void space::slotWindowToNextScreen()
-{
-    if (!USABLE_ACTIVE_CLIENT) {
-        return;
-    }
-    if (auto output = get_derivated_output(active_client->central_output, 1)) {
-        send_to_screen(*this, active_client, *output);
-    }
-}
-
-void space::slotWindowToPrevScreen()
-{
-    if (!USABLE_ACTIVE_CLIENT) {
-        return;
-    }
-    if (auto output = get_derivated_output(active_client->central_output, -1)) {
-        send_to_screen(*this, active_client, *output);
-    }
-}
-
-/**
- * Maximizes the active client.
- */
-void space::slotWindowMaximize()
-{
-    if (USABLE_ACTIVE_CLIENT)
-        performWindowOperation(active_client, base::options::MaximizeOp);
-}
-
-/**
- * Maximizes the active client vertically.
- */
-void space::slotWindowMaximizeVertical()
-{
-    if (USABLE_ACTIVE_CLIENT)
-        performWindowOperation(active_client, base::options::VMaximizeOp);
-}
-
-/**
- * Maximizes the active client horiozontally.
- */
-void space::slotWindowMaximizeHorizontal()
-{
-    if (USABLE_ACTIVE_CLIENT)
-        performWindowOperation(active_client, base::options::HMaximizeOp);
-}
-
-/**
- * Minimizes the active client.
- */
-void space::slotWindowMinimize()
-{
-    if (USABLE_ACTIVE_CLIENT)
-        performWindowOperation(active_client, base::options::MinimizeOp);
-}
-
-/**
- * Raises the active client.
- */
-void space::slotWindowRaise()
-{
-    if (USABLE_ACTIVE_CLIENT) {
-        win::raise_window(this, active_client);
-    }
-}
-
-/**
- * Lowers the active client.
- */
-void space::slotWindowLower()
-{
-    if (USABLE_ACTIVE_CLIENT) {
-        win::lower_window(this, active_client);
-        // As this most likely makes the window no longer visible change the
-        // keyboard focus to the next available window.
-        // activateNextClient( c ); // Doesn't work when we lower a child window
-        if (active_client->control->active() && kwinApp()->options->focusPolicyIsReasonable()) {
-            if (kwinApp()->options->isNextFocusPrefersMouse()) {
-                auto next = window_under_mouse(*this, active_client->central_output);
-                if (next && next != active_client)
-                    request_focus(*this, next);
-            } else {
-                activate_window(
-                    *this,
-                    top_client_on_desktop(this, virtual_desktop_manager->current(), nullptr));
-            }
-        }
-    }
-}
-
-/**
- * Does a toggle-raise-and-lower on the active client.
- */
-void space::slotWindowRaiseOrLower()
-{
-    if (USABLE_ACTIVE_CLIENT)
-        win::raise_or_lower_client(this, active_client);
-}
-
-void space::slotWindowOnAllDesktops()
-{
-    if (USABLE_ACTIVE_CLIENT)
-        win::set_on_all_desktops(active_client, !active_client->isOnAllDesktops());
-}
-
-void space::slotWindowFullScreen()
-{
-    if (USABLE_ACTIVE_CLIENT)
-        performWindowOperation(active_client, base::options::FullScreenOp);
-}
-
-void space::slotWindowNoBorder()
-{
-    if (USABLE_ACTIVE_CLIENT)
-        performWindowOperation(active_client, base::options::NoBorderOp);
-}
-
-void space::slotWindowAbove()
-{
-    if (USABLE_ACTIVE_CLIENT)
-        performWindowOperation(active_client, base::options::KeepAboveOp);
-}
-
-void space::slotWindowBelow()
-{
-    if (USABLE_ACTIVE_CLIENT)
-        performWindowOperation(active_client, base::options::KeepBelowOp);
-}
-void space::slotSetupWindowShortcut()
-{
-    if (USABLE_ACTIVE_CLIENT)
-        performWindowOperation(active_client, base::options::SetupWindowShortcutOp);
-}
-
-/**
- * Toggles show desktop.
- */
-void space::slotToggleShowDesktop()
-{
-    setShowingDesktop(!showingDesktop());
-}
-
-template<typename Direction>
-void windowToDesktop(Toplevel& window)
-{
-    auto& ws = window.space;
-    auto& vds = ws.virtual_desktop_manager;
-    Direction functor(*vds);
-    // TODO: why is kwinApp()->options->isRollOverDesktops() not honored?
-    const auto desktop = functor(nullptr, true);
-    if (!win::is_desktop(&window) && !win::is_dock(&window)) {
-        set_move_resize_window(ws, &window);
-        vds->setCurrent(desktop);
-        set_move_resize_window(ws, nullptr);
-    }
-}
-
-/**
- * Moves the active client to the next desktop.
- */
-void space::slotWindowToNextDesktop()
-{
-    if (USABLE_ACTIVE_CLIENT)
-        windowToNextDesktop(*active_client);
-}
-
-void space::windowToNextDesktop(Toplevel& window)
-{
-    windowToDesktop<win::virtual_desktop_next>(window);
-}
-
-/**
- * Moves the active client to the previous desktop.
- */
-void space::slotWindowToPreviousDesktop()
-{
-    if (USABLE_ACTIVE_CLIENT)
-        windowToPreviousDesktop(*active_client);
-}
-
-void space::windowToPreviousDesktop(Toplevel& window)
-{
-    windowToDesktop<win::virtual_desktop_previous>(window);
-}
-
-template<typename Direction>
-void activeClientToDesktop(win::space& space)
-{
-    auto& vds = space.virtual_desktop_manager;
-    const int current = vds->current();
-    Direction functor(*vds);
-    const int d = functor(current, kwinApp()->options->isRollOverDesktops());
-    if (d == current) {
-        return;
-    }
-    set_move_resize_window(space, space.active_client);
-    vds->setCurrent(d);
-    set_move_resize_window(space, nullptr);
-}
-
-void space::slotWindowToDesktopRight()
-{
-    if (USABLE_ACTIVE_CLIENT) {
-        activeClientToDesktop<win::virtual_desktop_right>(*this);
-    }
-}
-
-void space::slotWindowToDesktopLeft()
-{
-    if (USABLE_ACTIVE_CLIENT) {
-        activeClientToDesktop<win::virtual_desktop_left>(*this);
-    }
-}
-
-void space::slotWindowToDesktopUp()
-{
-    if (USABLE_ACTIVE_CLIENT) {
-        activeClientToDesktop<win::virtual_desktop_above>(*this);
-    }
-}
-
-void space::slotWindowToDesktopDown()
-{
-    if (USABLE_ACTIVE_CLIENT) {
-        activeClientToDesktop<win::virtual_desktop_below>(*this);
-    }
-}
-
-/**
- * Kill Window feature, similar to xkill.
- */
-void space::slotKillWindow()
-{
-    if (!window_killer) {
-        window_killer = std::make_unique<kill_window<space>>(*this);
-    }
-    window_killer->start();
-}
-
 /**
  * Switches to the nearest window in given direction.
  */
@@ -2413,17 +1847,6 @@ bool space::switchWindow(Toplevel* c, Direction direction, QPoint curPos, int d)
     return switchTo;
 }
 
-/**
- * Shows the window operations popup menu for the active client.
- */
-void space::slotWindowOperations()
-{
-    if (!active_client)
-        return;
-    auto pos = win::frame_to_client_pos(active_client, active_client->pos());
-    showWindowMenu(QRect(pos, pos), active_client);
-}
-
 void space::showWindowMenu(const QRect& pos, Toplevel* window)
 {
     user_actions_menu->show(pos, window);
@@ -2434,38 +1857,6 @@ void space::showApplicationMenu(const QRect& pos, Toplevel* window, int actionId
     appmenu->showApplicationMenu(window->pos() + pos.bottomLeft(), window, actionId);
 }
 
-/**
- * Closes the active client.
- */
-void space::slotWindowClose()
-{
-    // TODO: why?
-    //     if ( tab_box->isVisible())
-    //         return;
-    if (USABLE_ACTIVE_CLIENT)
-        performWindowOperation(active_client, base::options::CloseOp);
-}
-
-/**
- * Starts keyboard move mode for the active client.
- */
-void space::slotWindowMove()
-{
-    if (USABLE_ACTIVE_CLIENT)
-        performWindowOperation(active_client, base::options::UnrestrictedMoveOp);
-}
-
-/**
- * Starts keyboard resize mode for the active client.
- */
-void space::slotWindowResize()
-{
-    if (USABLE_ACTIVE_CLIENT)
-        performWindowOperation(active_client, base::options::UnrestrictedResizeOp);
-}
-
-#undef USABLE_ACTIVE_CLIENT
-
 bool space::shortcutAvailable(const QKeySequence& cut, Toplevel* ignore) const
 {
     if (ignore && cut == ignore->control->shortcut())
diff --git a/win/space.h b/win/space.h
index 944018845..65d044542 100644
--- a/win/space.h
+++ b/win/space.h
@@ -298,9 +298,6 @@ public:
 
     Toplevel* active_client{nullptr};
 
-    void windowToPreviousDesktop(Toplevel& window);
-    void windowToNextDesktop(Toplevel& window);
-
     /**
      * Shows the menu operations menu for the client and makes it active if
      * it's not already.
@@ -313,7 +310,6 @@ public:
     void updateOnAllDesktopsOfTransients(Toplevel* window);
     void checkTransients(Toplevel* window);
 
-    void setShowingDesktop(bool showing);
     bool showingDesktop() const;
 
     bool checkStartupNotification(xcb_window_t w, KStartupInfoId& id, KStartupInfoData& data);
@@ -363,61 +359,6 @@ public:
     void saveOldScreenSizes();
     void desktopResized();
 
-    void performWindowOperation(KWin::Toplevel* window, base::options::WindowOperation op);
-
-    // Keybindings
-    // void slotSwitchToWindow( int );
-    void slotWindowToDesktop(uint i);
-
-    // void slotWindowToListPosition( int );
-    void slotSwitchToScreen(QAction* action);
-    void slotWindowToScreen(QAction* action);
-    void slotSwitchToNextScreen();
-    void slotWindowToNextScreen();
-    void slotSwitchToPrevScreen();
-    void slotWindowToPrevScreen();
-    void slotToggleShowDesktop();
-
-    void slotWindowMaximize();
-    void slotWindowMaximizeVertical();
-    void slotWindowMaximizeHorizontal();
-    void slotWindowMinimize();
-    void slotWindowRaise();
-    void slotWindowLower();
-    void slotWindowRaiseOrLower();
-    void slotActivateAttentionWindow();
-    void slotWindowPackLeft();
-    void slotWindowPackRight();
-    void slotWindowPackUp();
-    void slotWindowPackDown();
-    void slotWindowGrowHorizontal();
-    void slotWindowGrowVertical();
-    void slotWindowShrinkHorizontal();
-    void slotWindowShrinkVertical();
-
-    void slotIncreaseWindowOpacity();
-    void slotLowerWindowOpacity();
-
-    void slotWindowOperations();
-    void slotWindowClose();
-    void slotWindowMove();
-    void slotWindowResize();
-    void slotWindowAbove();
-    void slotWindowBelow();
-    void slotWindowOnAllDesktops();
-    void slotWindowFullScreen();
-    void slotWindowNoBorder();
-
-    void slotWindowToNextDesktop();
-    void slotWindowToPreviousDesktop();
-    void slotWindowToDesktopRight();
-    void slotWindowToDesktopLeft();
-    void slotWindowToDesktopUp();
-    void slotWindowToDesktopDown();
-
-    void slotKillWindow();
-
-    void slotSetupWindowShortcut();
     void setupWindowShortcutDone(bool);
 
     virtual void update_space_area_from_windows(QRect const& desktop_area,
diff --git a/win/tabbox/tabbox.cpp b/win/tabbox/tabbox.cpp
index 9ab2e7c4e..985fc101d 100644
--- a/win/tabbox/tabbox.cpp
+++ b/win/tabbox/tabbox.cpp
@@ -710,7 +710,8 @@ void tabbox::show()
         m_is_shown = false;
         return;
     }
-    space.setShowingDesktop(false);
+
+    set_showing_desktop(space, false);
     reference();
     m_is_shown = true;
     m_tabbox->show();
@@ -1439,7 +1440,7 @@ void tabbox::accept(bool closeTabBox)
     if (c) {
         activate_window(space, c);
         if (win::is_desktop(c))
-            space.setShowingDesktop(!space.showingDesktop());
+            set_showing_desktop(space, !space.showingDesktop());
     }
 }
 
diff --git a/win/user_actions_menu.h b/win/user_actions_menu.h
index ff1369ff6..5cded121a 100644
--- a/win/user_actions_menu.h
+++ b/win/user_actions_menu.h
@@ -12,6 +12,7 @@
 #include "move.h"
 #include "net.h"
 #include "screen.h"
+#include "window_operation.h"
 
 #include "base/logging.h"
 #include "main.h"
@@ -511,7 +512,7 @@ private:
         // user actions menu closed before we destroy the decoration. Otherwise Qt crashes
         qRegisterMetaType<base::options::WindowOperation>();
         QMetaObject::invokeMethod(space.qobject.get(), [&space = this->space, c, op] {
-            space.performWindowOperation(c, op);
+            win::perform_window_operation(space, c, op);
         });
     }
 
diff --git a/win/util.h b/win/util.h
index 854acd3ec..ac9ea6f2f 100644
--- a/win/util.h
+++ b/win/util.h
@@ -7,9 +7,23 @@
 
 #include "types.h"
 
+#include <QAction>
+
 namespace KWin::win
 {
 
+static inline unsigned int get_action_data_as_uint(QAction* act)
+{
+    auto ok = false;
+    unsigned int i = -1;
+
+    if (act) {
+        i = act->data().toUInt(&ok);
+    }
+
+    return ok ? i : -1;
+}
+
 /**
  * @brief Finds the window matching the condition expressed in @p func in @p list.
  *
diff --git a/win/wayland/plasma_window.h b/win/wayland/plasma_window.h
index 33a405912..9eee74982 100644
--- a/win/wayland/plasma_window.h
+++ b/win/wayland/plasma_window.h
@@ -5,6 +5,8 @@
 */
 #pragma once
 
+#include "win/activation.h"
+
 #include <cassert>
 
 #include <Wrapland/Server/plasma_window.h>
@@ -36,7 +38,7 @@ void handle_change_showing_desktop(Space* space,
     if (set == space->showingDesktop()) {
         return;
     }
-    space->setShowingDesktop(set);
+    set_showing_desktop(*space, set);
 }
 
 }
diff --git a/win/wayland/window.cpp b/win/wayland/window.cpp
index 4c25a0894..f9bed3c4d 100644
--- a/win/wayland/window.cpp
+++ b/win/wayland/window.cpp
@@ -352,7 +352,7 @@ void window::takeFocus()
     }
 
     if (!control->keep_above() && !is_on_screen_display(this) && !belongsToDesktop()) {
-        space.setShowingDesktop(false);
+        set_showing_desktop(space, false);
     }
 }
 
diff --git a/win/window_operation.h b/win/window_operation.h
new file mode 100644
index 000000000..800f7a2ab
--- /dev/null
+++ b/win/window_operation.h
@@ -0,0 +1,113 @@
+/*
+    SPDX-FileCopyrightText: 2022 Roman Gilg <subdiff@gmail.com>
+
+    SPDX-License-Identifier: GPL-2.0-or-later
+*/
+#pragma once
+
+#include "actions.h"
+#include "desktop_set.h"
+#include "move.h"
+#include "rules/rule_book.h"
+#include "stacking.h"
+
+#include "input/cursor.h"
+
+namespace KWin::win
+{
+
+template<typename Space>
+void perform_window_operation(Space& space, Toplevel* window, base::options::WindowOperation op)
+{
+    if (!window) {
+        return;
+    }
+
+    auto cursor = input::get_cursor();
+
+    if (op == base::options::MoveOp || op == base::options::UnrestrictedMoveOp) {
+        cursor->set_pos(window->frameGeometry().center());
+    }
+    if (op == base::options::ResizeOp || op == base::options::UnrestrictedResizeOp) {
+        cursor->set_pos(window->frameGeometry().bottomRight());
+    }
+
+    switch (op) {
+    case base::options::MoveOp:
+        window->performMouseCommand(base::options::MouseMove, cursor->pos());
+        break;
+    case base::options::UnrestrictedMoveOp:
+        window->performMouseCommand(base::options::MouseUnrestrictedMove, cursor->pos());
+        break;
+    case base::options::ResizeOp:
+        window->performMouseCommand(base::options::MouseResize, cursor->pos());
+        break;
+    case base::options::UnrestrictedResizeOp:
+        window->performMouseCommand(base::options::MouseUnrestrictedResize, cursor->pos());
+        break;
+    case base::options::CloseOp:
+        QMetaObject::invokeMethod(window, "closeWindow", Qt::QueuedConnection);
+        break;
+    case base::options::MaximizeOp:
+        maximize(window,
+                 window->maximizeMode() == maximize_mode::full ? maximize_mode::restore
+                                                               : maximize_mode::full);
+        break;
+    case base::options::HMaximizeOp:
+        maximize(window, window->maximizeMode() ^ maximize_mode::horizontal);
+        break;
+    case base::options::VMaximizeOp:
+        maximize(window, window->maximizeMode() ^ maximize_mode::vertical);
+        break;
+    case base::options::RestoreOp:
+        maximize(window, maximize_mode::restore);
+        break;
+    case base::options::MinimizeOp:
+        set_minimized(window, true);
+        break;
+    case base::options::OnAllDesktopsOp:
+        set_on_all_desktops(window, !window->isOnAllDesktops());
+        break;
+    case base::options::FullScreenOp:
+        window->setFullScreen(!window->control->fullscreen(), true);
+        break;
+    case base::options::NoBorderOp:
+        window->setNoBorder(!window->noBorder());
+        break;
+    case base::options::KeepAboveOp: {
+        blocker block(space.stacking_order);
+        bool was = window->control->keep_above();
+        set_keep_above(window, !window->control->keep_above());
+        if (was && !window->control->keep_above()) {
+            raise_window(&space, window);
+        }
+        break;
+    }
+    case base::options::KeepBelowOp: {
+        blocker block(space.stacking_order);
+        bool was = window->control->keep_below();
+        set_keep_below(window, !window->control->keep_below());
+        if (was && !window->control->keep_below()) {
+            lower_window(&space, window);
+        }
+        break;
+    }
+    case base::options::WindowRulesOp:
+        space.rule_book->edit(window, false);
+        break;
+    case base::options::ApplicationRulesOp:
+        space.rule_book->edit(window, true);
+        break;
+    case base::options::SetupWindowShortcutOp:
+        space.setupWindowShortcut(window);
+        break;
+    case base::options::LowerOp:
+        lower_window(&space, window);
+        break;
+    case base::options::OperationsOp:
+    case base::options::NoOp:
+        break;
+    }
+}
+
+}
diff --git a/win/x11/netinfo.cpp b/win/x11/netinfo.cpp
index 2a1cb110a..9ed95f4b2 100644
--- a/win/x11/netinfo.cpp
+++ b/win/x11/netinfo.cpp
@@ -276,7 +276,7 @@ void root_info::gotPing(xcb_window_t w, xcb_timestamp_t timestamp)
 
 void root_info::changeShowingDesktop(bool showing)
 {
-    space.setShowingDesktop(showing);
+    set_showing_desktop(space, showing);
 }
 
 void root_info::setActiveClient(Toplevel* window)
diff --git a/win/x11/space_setup.h b/win/x11/space_setup.h
index ca1068e00..85ec1bf50 100644
--- a/win/x11/space_setup.h
+++ b/win/x11/space_setup.h
@@ -160,7 +160,7 @@ void init_space(Space& space)
         desktop_geometry.width = geom.width();
         desktop_geometry.height = geom.height();
         rootInfo->setDesktopGeometry(desktop_geometry);
-        space.setShowingDesktop(false);
+        set_showing_desktop(space, false);
 
     } // End updates blocker block
 
diff --git a/win/x11/window.cpp b/win/x11/window.cpp
index 49c9f968c..aa678358d 100644
--- a/win/x11/window.cpp
+++ b/win/x11/window.cpp
@@ -533,7 +533,7 @@ void window::takeFocus()
     }
 
     if (breakShowingDesktop) {
-        space.setShowingDesktop(false);
+        set_showing_desktop(space, false);
     }
 }
 
-- 
GitLab


From db1c189505f1bd727c6859376d4ad3039e8abc6a Mon Sep 17 00:00:00 2001
From: Roman Gilg <subdiff@gmail.com>
Date: Wed, 6 Jul 2022 12:30:02 +0200
Subject: [PATCH 15/51] refactor: replace shortcut macros with lambdas

We have to use some QStrings instead of QStringLiterals, which is less
performant. But we may change to std::string later on anyway.
---
 win/space.cpp | 209 ++++++++++++++++++++++++++------------------------
 1 file changed, 107 insertions(+), 102 deletions(-)

diff --git a/win/space.cpp b/win/space.cpp
index e1069664e..1f40aa304 100644
--- a/win/space.cpp
+++ b/win/space.cpp
@@ -1465,28 +1465,33 @@ void space::init_shortcut_with_action_arg(const QString& actionName,
 void space::initShortcuts()
 {
     // Some shortcuts have Tarzan-speech like names, they need extra
-    // normal human descriptions with DEF2() the others can use DEF()
-    // new DEF3 allows to pass data to the action, replacing the %1 argument in the name
+    // normal human descriptions with def2() the others can use def()
+    // new def3 allows to pass data to the action, replacing the %1 argument in the name
 
-#define DEF2(name, descr, key, fnSlot)                                                             \
-    initShortcut(QStringLiteral(name), descr.toString(), key, [this] { fnSlot(*this); });
+    auto def2 = [this](auto name, auto descr, auto key, auto functor) {
+        initShortcut(QString(name), descr.toString(), key, [this, functor] { functor(*this); });
+    };
 
-#define DEF(name, key, fnSlot)                                                                     \
-    initShortcut(QString::fromUtf8(name.untranslatedText()), name.toString(), key, [this] {        \
-        fnSlot(*this);                                                                             \
-    });
+    auto def = [this](auto name, auto key, auto functor) {
+        initShortcut(QString::fromUtf8(name.untranslatedText()),
+                     name.toString(),
+                     key,
+                     [this, functor] { functor(*this); });
+    };
 
-#define DEF3(name, key, fnSlot, value)                                                             \
-    init_shortcut_with_action_arg(                                                                 \
-        QString::fromUtf8(name.untranslatedText()).arg(value),                                     \
-        name.subs(value).toString(),                                                               \
-        key,                                                                                       \
-        qobject.get(),                                                                             \
-        [this](QAction* action) { fnSlot(*this, action); },                                        \
-        value);
+    auto def3 = [this](auto name, auto key, auto functor, auto value) {
+        init_shortcut_with_action_arg(
+            QString::fromUtf8(name.untranslatedText()).arg(value),
+            name.subs(value).toString(),
+            key,
+            qobject.get(),
+            [this, functor](QAction* action) { functor(*this, action); },
+            value);
+    };
 
-#define DEF4(name, descr, key, functor)                                                            \
-    initShortcut(QStringLiteral(name), descr.toString(), key, functor);
+    auto def4 = [this](auto name, auto descr, auto key, auto functor) {
+        initShortcut(QString(name), descr.toString(), key, functor);
+    };
 
     auto def5 = [this](auto name, auto key, auto functor, auto value) {
         initShortcut(QString::fromUtf8(name.untranslatedText()).arg(value),
@@ -1496,134 +1501,142 @@ void space::initShortcuts()
                      value);
     };
 
-#define DEF6(name, key, target, fnSlot)                                                            \
-    initShortcut(QString::fromUtf8(name.untranslatedText()), name.toString(), key, target, &fnSlot);
+    auto def6 = [this](auto name, auto key, auto target, auto functor) {
+        initShortcut(
+            QString::fromUtf8(name.untranslatedText()), name.toString(), key, target, functor);
+    };
 
-    DEF(kli18n("Window Operations Menu"),
+    def(kli18n("Window Operations Menu"),
         Qt::ALT + Qt::Key_F3,
-        active_window_show_operations_popup);
-    DEF2("Window Close", kli18n("Close Window"), Qt::ALT + Qt::Key_F4, active_window_close);
-    DEF2("Window Maximize",
+        active_window_show_operations_popup<space>);
+    def2("Window Close", kli18n("Close Window"), Qt::ALT + Qt::Key_F4, active_window_close<space>);
+    def2("Window Maximize",
          kli18n("Maximize Window"),
          Qt::META + Qt::Key_PageUp,
-         active_window_maximize);
-    DEF2("Window Maximize Vertical",
+         active_window_maximize<space>);
+    def2("Window Maximize Vertical",
          kli18n("Maximize Window Vertically"),
          0,
-         active_window_maximize_vertical);
-    DEF2("Window Maximize Horizontal",
+         active_window_maximize_vertical<space>);
+    def2("Window Maximize Horizontal",
          kli18n("Maximize Window Horizontally"),
          0,
-         active_window_maximize_horizontal);
-    DEF2("Window Minimize",
+         active_window_maximize_horizontal<space>);
+    def2("Window Minimize",
          kli18n("Minimize Window"),
          Qt::META + Qt::Key_PageDown,
-         active_window_minimize);
-    DEF2("Window Move", kli18n("Move Window"), 0, active_window_move);
-    DEF2("Window Resize", kli18n("Resize Window"), 0, active_window_resize);
-    DEF2("Window Raise", kli18n("Raise Window"), 0, active_window_raise);
-    DEF2("Window Lower", kli18n("Lower Window"), 0, active_window_lower);
-    DEF(kli18n("Toggle Window Raise/Lower"), 0, active_window_raise_or_lower);
-    DEF2("Window Fullscreen", kli18n("Make Window Fullscreen"), 0, active_window_set_fullscreen);
-    DEF2("Window No Border", kli18n("Hide Window Border"), 0, active_window_set_no_border);
-    DEF2("Window Above Other Windows",
+         active_window_minimize<space>);
+    def2("Window Move", kli18n("Move Window"), 0, active_window_move<space>);
+    def2("Window Resize", kli18n("Resize Window"), 0, active_window_resize<space>);
+    def2("Window Raise", kli18n("Raise Window"), 0, active_window_raise<space>);
+    def2("Window Lower", kli18n("Lower Window"), 0, active_window_lower<space>);
+    def(kli18n("Toggle Window Raise/Lower"), 0, active_window_raise_or_lower<space>);
+    def2("Window Fullscreen",
+         kli18n("Make Window Fullscreen"),
+         0,
+         active_window_set_fullscreen<space>);
+    def2("Window No Border", kli18n("Hide Window Border"), 0, active_window_set_no_border<space>);
+    def2("Window Above Other Windows",
          kli18n("Keep Window Above Others"),
          0,
-         active_window_set_keep_above);
-    DEF2("Window Below Other Windows",
+         active_window_set_keep_above<space>);
+    def2("Window Below Other Windows",
          kli18n("Keep Window Below Others"),
          0,
-         active_window_set_keep_below);
-    DEF(kli18n("Activate Window Demanding Attention"),
+         active_window_set_keep_below<space>);
+    def(kli18n("Activate Window Demanding Attention"),
         Qt::META | Qt::CTRL | Qt::Key_A,
-        activate_attention_window);
-    DEF(kli18n("Setup Window Shortcut"), 0, active_window_setup_window_shortcut);
-    DEF2("Window Pack Right", kli18n("Pack Window to the Right"), 0, active_window_pack_right);
-    DEF2("Window Pack Left", kli18n("Pack Window to the Left"), 0, active_window_pack_left);
-    DEF2("Window Pack Up", kli18n("Pack Window Up"), 0, active_window_pack_up);
-    DEF2("Window Pack Down", kli18n("Pack Window Down"), 0, active_window_pack_down);
-    DEF2("Window Grow Horizontal",
+        activate_attention_window<space>);
+    def(kli18n("Setup Window Shortcut"), 0, active_window_setup_window_shortcut<space>);
+    def2("Window Pack Right",
+         kli18n("Pack Window to the Right"),
+         0,
+         active_window_pack_right<space>);
+    def2("Window Pack Left", kli18n("Pack Window to the Left"), 0, active_window_pack_left<space>);
+    def2("Window Pack Up", kli18n("Pack Window Up"), 0, active_window_pack_up<space>);
+    def2("Window Pack Down", kli18n("Pack Window Down"), 0, active_window_pack_down<space>);
+    def2("Window Grow Horizontal",
          kli18n("Pack Grow Window Horizontally"),
          0,
-         active_window_grow_horizontal);
-    DEF2("Window Grow Vertical",
+         active_window_grow_horizontal<space>);
+    def2("Window Grow Vertical",
          kli18n("Pack Grow Window Vertically"),
          0,
-         active_window_grow_vertical);
-    DEF2("Window Shrink Horizontal",
+         active_window_grow_vertical<space>);
+    def2("Window Shrink Horizontal",
          kli18n("Pack Shrink Window Horizontally"),
          0,
-         active_window_shrink_horizontal);
-    DEF2("Window Shrink Vertical",
+         active_window_shrink_horizontal<space>);
+    def2("Window Shrink Vertical",
          kli18n("Pack Shrink Window Vertically"),
          0,
-         active_window_shrink_vertical);
-    DEF4("Window Quick Tile Left",
+         active_window_shrink_vertical<space>);
+    def4("Window Quick Tile Left",
          kli18n("Quick Tile Window to the Left"),
          Qt::META + Qt::Key_Left,
          std::bind(&space::quickTileWindow, this, win::quicktiles::left));
-    DEF4("Window Quick Tile Right",
+    def4("Window Quick Tile Right",
          kli18n("Quick Tile Window to the Right"),
          Qt::META + Qt::Key_Right,
          std::bind(&space::quickTileWindow, this, win::quicktiles::right));
-    DEF4("Window Quick Tile Top",
+    def4("Window Quick Tile Top",
          kli18n("Quick Tile Window to the Top"),
          Qt::META + Qt::Key_Up,
          std::bind(&space::quickTileWindow, this, win::quicktiles::top));
-    DEF4("Window Quick Tile Bottom",
+    def4("Window Quick Tile Bottom",
          kli18n("Quick Tile Window to the Bottom"),
          Qt::META + Qt::Key_Down,
          std::bind(&space::quickTileWindow, this, win::quicktiles::bottom));
-    DEF4("Window Quick Tile Top Left",
+    def4("Window Quick Tile Top Left",
          kli18n("Quick Tile Window to the Top Left"),
          0,
          std::bind(&space::quickTileWindow, this, win::quicktiles::top | win::quicktiles::left));
-    DEF4("Window Quick Tile Bottom Left",
+    def4("Window Quick Tile Bottom Left",
          kli18n("Quick Tile Window to the Bottom Left"),
          0,
          std::bind(&space::quickTileWindow, this, win::quicktiles::bottom | win::quicktiles::left));
-    DEF4("Window Quick Tile Top Right",
+    def4("Window Quick Tile Top Right",
          kli18n("Quick Tile Window to the Top Right"),
          0,
          std::bind(&space::quickTileWindow, this, win::quicktiles::top | win::quicktiles::right));
-    DEF4(
+    def4(
         "Window Quick Tile Bottom Right",
         kli18n("Quick Tile Window to the Bottom Right"),
         0,
         std::bind(&space::quickTileWindow, this, win::quicktiles::bottom | win::quicktiles::right));
-    DEF4("Switch Window Up",
+    def4("Switch Window Up",
          kli18n("Switch to Window Above"),
          Qt::META + Qt::ALT + Qt::Key_Up,
          std::bind(
              static_cast<void (space::*)(Direction)>(&space::switchWindow), this, DirectionNorth));
-    DEF4("Switch Window Down",
+    def4("Switch Window Down",
          kli18n("Switch to Window Below"),
          Qt::META + Qt::ALT + Qt::Key_Down,
          std::bind(
              static_cast<void (space::*)(Direction)>(&space::switchWindow), this, DirectionSouth));
-    DEF4("Switch Window Right",
+    def4("Switch Window Right",
          kli18n("Switch to Window to the Right"),
          Qt::META + Qt::ALT + Qt::Key_Right,
          std::bind(
              static_cast<void (space::*)(Direction)>(&space::switchWindow), this, DirectionEast));
-    DEF4("Switch Window Left",
+    def4("Switch Window Left",
          kli18n("Switch to Window to the Left"),
          Qt::META + Qt::ALT + Qt::Key_Left,
          std::bind(
              static_cast<void (space::*)(Direction)>(&space::switchWindow), this, DirectionWest));
-    DEF2("Increase Opacity",
+    def2("Increase Opacity",
          kli18n("Increase Opacity of Active Window by 5 %"),
          0,
-         active_window_increase_opacity);
-    DEF2("Decrease Opacity",
+         active_window_increase_opacity<space>);
+    def2("Decrease Opacity",
          kli18n("Decrease Opacity of Active Window by 5 %"),
          0,
-         active_window_lower_opacity);
+         active_window_lower_opacity<space>);
 
-    DEF2("Window On All Desktops",
+    def2("Window On All Desktops",
          kli18n("Keep Window on All Desktops"),
          0,
-         active_window_set_on_all_desktops);
+         active_window_set_on_all_desktops<space>);
 
     for (int i = 1; i < 21; ++i) {
         def5(
@@ -1633,43 +1646,35 @@ void space::initShortcuts()
             i);
     }
 
-    DEF(kli18n("Window to Next Desktop"), 0, active_window_to_next_desktop);
-    DEF(kli18n("Window to Previous Desktop"), 0, active_window_to_prev_desktop);
-    DEF(kli18n("Window One Desktop to the Right"), 0, active_window_to_right_desktop);
-    DEF(kli18n("Window One Desktop to the Left"), 0, active_window_to_left_desktop);
-    DEF(kli18n("Window One Desktop Up"), 0, active_window_to_above_desktop);
-    DEF(kli18n("Window One Desktop Down"), 0, active_window_to_below_desktop);
+    def(kli18n("Window to Next Desktop"), 0, active_window_to_next_desktop<space>);
+    def(kli18n("Window to Previous Desktop"), 0, active_window_to_prev_desktop<space>);
+    def(kli18n("Window One Desktop to the Right"), 0, active_window_to_right_desktop<space>);
+    def(kli18n("Window One Desktop to the Left"), 0, active_window_to_left_desktop<space>);
+    def(kli18n("Window One Desktop Up"), 0, active_window_to_above_desktop<space>);
+    def(kli18n("Window One Desktop Down"), 0, active_window_to_below_desktop<space>);
 
     for (int i = 0; i < 8; ++i) {
-        DEF3(kli18n("Window to Screen %1"), 0, active_window_to_output, i);
+        def3(kli18n("Window to Screen %1"), 0, active_window_to_output<space>, i);
     }
-    DEF(kli18n("Window to Next Screen"), 0, active_window_to_next_output);
-    DEF(kli18n("Window to Previous Screen"), 0, active_window_to_prev_output);
-    DEF(kli18n("Show Desktop"), Qt::META + Qt::Key_D, toggle_show_desktop);
+    def(kli18n("Window to Next Screen"), 0, active_window_to_next_output<space>);
+    def(kli18n("Window to Previous Screen"), 0, active_window_to_prev_output<space>);
+    def(kli18n("Show Desktop"), Qt::META + Qt::Key_D, toggle_show_desktop<space>);
 
     for (int i = 0; i < 8; ++i) {
-        DEF3(kli18n("Switch to Screen %1"), 0, switch_to_output, i);
+        def3(kli18n("Switch to Screen %1"), 0, switch_to_output<space>, i);
     }
 
-    DEF(kli18n("Switch to Next Screen"), 0, switch_to_next_output);
-    DEF(kli18n("Switch to Previous Screen"), 0, switch_to_prev_output);
+    def(kli18n("Switch to Next Screen"), 0, switch_to_next_output<space>);
+    def(kli18n("Switch to Previous Screen"), 0, switch_to_prev_output<space>);
 
-    DEF(kli18n("Kill Window"), Qt::META | Qt::CTRL | Qt::Key_Escape, start_window_killer);
-    DEF6(kli18n("Suspend Compositing"),
+    def(kli18n("Kill Window"), Qt::META | Qt::CTRL | Qt::Key_Escape, start_window_killer<space>);
+    def6(kli18n("Suspend Compositing"),
          Qt::SHIFT + Qt::ALT + Qt::Key_F12,
          &render,
-         render::compositor::toggleCompositing);
-    DEF6(kli18n("Invert Screen Colors"),
-         0,
-         kwinApp()->get_base().render.get(),
-         render::platform::invertScreen);
-
-#undef DEF
-#undef DEF2
-#undef DEF3
-#undef DEF4
-#undef DEF5
-#undef DEF6
+         [render = &render] { render->toggleCompositing(); });
+    def6(kli18n("Invert Screen Colors"), 0, &render, [render = &render] {
+        render->platform.invertScreen();
+    });
 
 #if KWIN_BUILD_TABBOX
     tabbox->init_shortcuts();
-- 
GitLab


From f90bf1274af9dee86bbcf18ad15235fa4248be8f Mon Sep 17 00:00:00 2001
From: Roman Gilg <subdiff@gmail.com>
Date: Wed, 6 Jul 2022 12:29:36 +0200
Subject: [PATCH 16/51] refactor: replace snap macros with lambdas

Improves readability and type safety. Functionality is the same.
---
 win/space.cpp | 241 ++++++++++++++++++++++++++------------------------
 1 file changed, 127 insertions(+), 114 deletions(-)

diff --git a/win/space.cpp b/win/space.cpp
index 1f40aa304..8e2416c11 100644
--- a/win/space.cpp
+++ b/win/space.cpp
@@ -742,57 +742,62 @@ QRect space::adjustClientSize(Toplevel* window, QRect moveResizeGeom, win::posit
             deltaX = int(snap);
             deltaY = int(snap);
 
-#define SNAP_BORDER_TOP                                                                            \
-    if ((sOWO ? (newcy < ymin) : true) && (qAbs(ymin - newcy) < deltaY)) {                         \
-        deltaY = qAbs(ymin - newcy);                                                               \
-        newcy = ymin;                                                                              \
-    }
+            auto snap_border_top = [&] {
+                if ((sOWO ? (newcy < ymin) : true) && (qAbs(ymin - newcy) < deltaY)) {
+                    deltaY = qAbs(ymin - newcy);
+                    newcy = ymin;
+                }
+            };
 
-#define SNAP_BORDER_BOTTOM                                                                         \
-    if ((sOWO ? (newry > ymax) : true) && (qAbs(ymax - newry) < deltaY)) {                         \
-        deltaY = qAbs(ymax - newcy);                                                               \
-        newry = ymax;                                                                              \
-    }
+            auto snap_border_bottom = [&] {
+                if ((sOWO ? (newry > ymax) : true) && (qAbs(ymax - newry) < deltaY)) {
+                    deltaY = qAbs(ymax - newcy);
+                    newry = ymax;
+                }
+            };
 
-#define SNAP_BORDER_LEFT                                                                           \
-    if ((sOWO ? (newcx < xmin) : true) && (qAbs(xmin - newcx) < deltaX)) {                         \
-        deltaX = qAbs(xmin - newcx);                                                               \
-        newcx = xmin;                                                                              \
-    }
+            auto snap_border_left = [&] {
+                if ((sOWO ? (newcx < xmin) : true) && (qAbs(xmin - newcx) < deltaX)) {
+                    deltaX = qAbs(xmin - newcx);
+                    newcx = xmin;
+                }
+            };
+
+            auto snap_border_right = [&] {
+                if ((sOWO ? (newrx > xmax) : true) && (qAbs(xmax - newrx) < deltaX)) {
+                    deltaX = qAbs(xmax - newrx);
+                    newrx = xmax;
+                }
+            };
 
-#define SNAP_BORDER_RIGHT                                                                          \
-    if ((sOWO ? (newrx > xmax) : true) && (qAbs(xmax - newrx) < deltaX)) {                         \
-        deltaX = qAbs(xmax - newrx);                                                               \
-        newrx = xmax;                                                                              \
-    }
             switch (mode) {
             case win::position::bottom_right:
-                SNAP_BORDER_BOTTOM
-                SNAP_BORDER_RIGHT
+                snap_border_bottom();
+                snap_border_right();
                 break;
             case win::position::right:
-                SNAP_BORDER_RIGHT
+                snap_border_right();
                 break;
             case win::position::bottom:
-                SNAP_BORDER_BOTTOM
+                snap_border_bottom();
                 break;
             case win::position::top_left:
-                SNAP_BORDER_TOP
-                SNAP_BORDER_LEFT
+                snap_border_top();
+                snap_border_left();
                 break;
             case win::position::left:
-                SNAP_BORDER_LEFT
+                snap_border_left();
                 break;
             case win::position::top:
-                SNAP_BORDER_TOP
+                snap_border_top();
                 break;
             case win::position::top_right:
-                SNAP_BORDER_TOP
-                SNAP_BORDER_RIGHT
+                snap_border_top();
+                snap_border_right();
                 break;
             case win::position::bottom_left:
-                SNAP_BORDER_BOTTOM
-                SNAP_BORDER_LEFT
+                snap_border_bottom();
+                snap_border_left();
                 break;
             default:
                 abort();
@@ -813,105 +818,113 @@ QRect space::adjustClientSize(Toplevel* window, QRect moveResizeGeom, win::posit
                     lrx = win->pos().x() + win->size().width();
                     lry = win->pos().y() + win->size().height();
 
-#define WITHIN_HEIGHT                                                                              \
-    (((newcy <= lry) && (newcy >= ly)) || ((newry >= ly) && (newry <= lry))                        \
-     || ((newcy <= ly) && (newry >= lry)))
-
-#define WITHIN_WIDTH                                                                               \
-    (((cx <= lrx) && (cx >= lx)) || ((rx >= lx) && (rx <= lrx)) || ((cx <= lx) && (rx >= lrx)))
-
-#define SNAP_WINDOW_TOP                                                                            \
-    if ((sOWO ? (newcy < lry) : true) && WITHIN_WIDTH && (qAbs(lry - newcy) < deltaY)) {           \
-        deltaY = qAbs(lry - newcy);                                                                \
-        newcy = lry;                                                                               \
-    }
-
-#define SNAP_WINDOW_BOTTOM                                                                         \
-    if ((sOWO ? (newry > ly) : true) && WITHIN_WIDTH && (qAbs(ly - newry) < deltaY)) {             \
-        deltaY = qAbs(ly - newry);                                                                 \
-        newry = ly;                                                                                \
-    }
-
-#define SNAP_WINDOW_LEFT                                                                           \
-    if ((sOWO ? (newcx < lrx) : true) && WITHIN_HEIGHT && (qAbs(lrx - newcx) < deltaX)) {          \
-        deltaX = qAbs(lrx - newcx);                                                                \
-        newcx = lrx;                                                                               \
-    }
-
-#define SNAP_WINDOW_RIGHT                                                                          \
-    if ((sOWO ? (newrx > lx) : true) && WITHIN_HEIGHT && (qAbs(lx - newrx) < deltaX)) {            \
-        deltaX = qAbs(lx - newrx);                                                                 \
-        newrx = lx;                                                                                \
-    }
-
-#define SNAP_WINDOW_C_TOP                                                                          \
-    if ((sOWO ? (newcy < ly) : true) && (newcx == lrx || newrx == lx)                              \
-        && qAbs(ly - newcy) < deltaY) {                                                            \
-        deltaY = qAbs(ly - newcy + 1);                                                             \
-        newcy = ly + 1;                                                                            \
-    }
-
-#define SNAP_WINDOW_C_BOTTOM                                                                       \
-    if ((sOWO ? (newry > lry) : true) && (newcx == lrx || newrx == lx)                             \
-        && qAbs(lry - newry) < deltaY) {                                                           \
-        deltaY = qAbs(lry - newry - 1);                                                            \
-        newry = lry - 1;                                                                           \
-    }
-
-#define SNAP_WINDOW_C_LEFT                                                                         \
-    if ((sOWO ? (newcx < lx) : true) && (newcy == lry || newry == ly)                              \
-        && qAbs(lx - newcx) < deltaX) {                                                            \
-        deltaX = qAbs(lx - newcx + 1);                                                             \
-        newcx = lx + 1;                                                                            \
-    }
-
-#define SNAP_WINDOW_C_RIGHT                                                                        \
-    if ((sOWO ? (newrx > lrx) : true) && (newcy == lry || newry == ly)                             \
-        && qAbs(lrx - newrx) < deltaX) {                                                           \
-        deltaX = qAbs(lrx - newrx - 1);                                                            \
-        newrx = lrx - 1;                                                                           \
-    }
+                    auto within_height = [&] {
+                        return ((newcy <= lry) && (newcy >= ly))
+                            || ((newry >= ly) && (newry <= lry))
+                            || ((newcy <= ly) && (newry >= lry));
+                    };
+                    auto within_width = [&] {
+                        return ((cx <= lrx) && (cx >= lx)) || ((rx >= lx) && (rx <= lrx))
+                            || ((cx <= lx) && (rx >= lrx));
+                    };
+
+                    auto snap_window_top = [&] {
+                        if ((sOWO ? (newcy < lry) : true) && within_width()
+                            && (qAbs(lry - newcy) < deltaY)) {
+                            deltaY = qAbs(lry - newcy);
+                            newcy = lry;
+                        }
+                    };
+                    auto snap_window_bottom = [&] {
+                        if ((sOWO ? (newry > ly) : true) && within_width()
+                            && (qAbs(ly - newry) < deltaY)) {
+                            deltaY = qAbs(ly - newry);
+                            newry = ly;
+                        }
+                    };
+                    auto snap_window_left = [&] {
+                        if ((sOWO ? (newcx < lrx) : true) && within_height()
+                            && (qAbs(lrx - newcx) < deltaX)) {
+                            deltaX = qAbs(lrx - newcx);
+                            newcx = lrx;
+                        }
+                    };
+                    auto snap_window_right = [&] {
+                        if ((sOWO ? (newrx > lx) : true) && within_height()
+                            && (qAbs(lx - newrx) < deltaX)) {
+                            deltaX = qAbs(lx - newrx);
+                            newrx = lx;
+                        }
+                    };
+                    auto snap_window_c_top = [&] {
+                        if ((sOWO ? (newcy < ly) : true) && (newcx == lrx || newrx == lx)
+                            && qAbs(ly - newcy) < deltaY) {
+                            deltaY = qAbs(ly - newcy + 1);
+                            newcy = ly + 1;
+                        }
+                    };
+                    auto snap_window_c_bottom = [&] {
+                        if ((sOWO ? (newry > lry) : true) && (newcx == lrx || newrx == lx)
+                            && qAbs(lry - newry) < deltaY) {
+                            deltaY = qAbs(lry - newry - 1);
+                            newry = lry - 1;
+                        }
+                    };
+                    auto snap_window_c_left = [&] {
+                        if ((sOWO ? (newcx < lx) : true) && (newcy == lry || newry == ly)
+                            && qAbs(lx - newcx) < deltaX) {
+                            deltaX = qAbs(lx - newcx + 1);
+                            newcx = lx + 1;
+                        }
+                    };
+                    auto snap_window_c_right = [&] {
+                        if ((sOWO ? (newrx > lrx) : true) && (newcy == lry || newry == ly)
+                            && qAbs(lrx - newrx) < deltaX) {
+                            deltaX = qAbs(lrx - newrx - 1);
+                            newrx = lrx - 1;
+                        }
+                    };
 
                     switch (mode) {
                     case win::position::bottom_right:
-                        SNAP_WINDOW_BOTTOM
-                        SNAP_WINDOW_RIGHT
-                        SNAP_WINDOW_C_BOTTOM
-                        SNAP_WINDOW_C_RIGHT
+                        snap_window_bottom();
+                        snap_window_right();
+                        snap_window_c_bottom();
+                        snap_window_c_right();
                         break;
                     case win::position::right:
-                        SNAP_WINDOW_RIGHT
-                        SNAP_WINDOW_C_RIGHT
+                        snap_window_right();
+                        snap_window_c_right();
                         break;
                     case win::position::bottom:
-                        SNAP_WINDOW_BOTTOM
-                        SNAP_WINDOW_C_BOTTOM
+                        snap_window_bottom();
+                        snap_window_c_bottom();
                         break;
                     case win::position::top_left:
-                        SNAP_WINDOW_TOP
-                        SNAP_WINDOW_LEFT
-                        SNAP_WINDOW_C_TOP
-                        SNAP_WINDOW_C_LEFT
+                        snap_window_top();
+                        snap_window_left();
+                        snap_window_c_top();
+                        snap_window_c_left();
                         break;
                     case win::position::left:
-                        SNAP_WINDOW_LEFT
-                        SNAP_WINDOW_C_LEFT
+                        snap_window_left();
+                        snap_window_c_left();
                         break;
                     case win::position::top:
-                        SNAP_WINDOW_TOP
-                        SNAP_WINDOW_C_TOP
+                        snap_window_top();
+                        snap_window_c_top();
                         break;
                     case win::position::top_right:
-                        SNAP_WINDOW_TOP
-                        SNAP_WINDOW_RIGHT
-                        SNAP_WINDOW_C_TOP
-                        SNAP_WINDOW_C_RIGHT
+                        snap_window_top();
+                        snap_window_right();
+                        snap_window_c_top();
+                        snap_window_c_right();
                         break;
                     case win::position::bottom_left:
-                        SNAP_WINDOW_BOTTOM
-                        SNAP_WINDOW_LEFT
-                        SNAP_WINDOW_C_BOTTOM
-                        SNAP_WINDOW_C_LEFT
+                        snap_window_bottom();
+                        snap_window_left();
+                        snap_window_c_bottom();
+                        snap_window_c_left();
                         break;
                     default:
                         abort();
-- 
GitLab


From 6e40cc63f2d7f9cbc9e2f83548906d096e37053d Mon Sep 17 00:00:00 2001
From: Roman Gilg <subdiff@gmail.com>
Date: Wed, 6 Jul 2022 23:57:43 +0200
Subject: [PATCH 17/51] refactor: remove space menu wrapper

Instead call directly into the respective space menu members.
---
 .../integration/dont_crash_useractions_menu.cpp |  4 ++--
 .../effects/popup_open_close_animation_test.cpp |  2 +-
 win/active_window.h                             |  2 +-
 win/appmenu.h                                   | 15 ---------------
 win/dbus/appmenu.h                              | 17 ++++++++++++++++-
 win/deco/client_impl.cpp                        |  8 +++++---
 win/input.h                                     |  2 +-
 win/space.cpp                                   | 10 ----------
 win/space.h                                     |  8 --------
 9 files changed, 26 insertions(+), 42 deletions(-)

diff --git a/autotests/integration/dont_crash_useractions_menu.cpp b/autotests/integration/dont_crash_useractions_menu.cpp
index 60f881ec4..cc88bdef5 100644
--- a/autotests/integration/dont_crash_useractions_menu.cpp
+++ b/autotests/integration/dont_crash_useractions_menu.cpp
@@ -89,7 +89,7 @@ void TestDontCrashUseractionsMenu::testShowHideShowUseractionsMenu()
     auto client = Test::render_and_wait_for_shown(surface1, QSize(100, 50), Qt::blue);
     QVERIFY(client);
 
-    Test::app()->workspace->showWindowMenu(QRect(), client);
+    Test::app()->workspace->user_actions_menu->show(QRect(), client);
     auto& userActionsMenu = Test::app()->workspace->user_actions_menu;
     QTRY_VERIFY(userActionsMenu->isShown());
     QVERIFY(userActionsMenu->hasClient());
@@ -100,7 +100,7 @@ void TestDontCrashUseractionsMenu::testShowHideShowUseractionsMenu()
     QVERIFY(!userActionsMenu->hasClient());
 
     // and show again, this triggers BUG 382063
-    Test::app()->workspace->showWindowMenu(QRect(), client);
+    Test::app()->workspace->user_actions_menu->show(QRect(), client);
     QTRY_VERIFY(userActionsMenu->isShown());
     QVERIFY(userActionsMenu->hasClient());
 }
diff --git a/autotests/integration/effects/popup_open_close_animation_test.cpp b/autotests/integration/effects/popup_open_close_animation_test.cpp
index 72bbad5ad..0c37939d4 100644
--- a/autotests/integration/effects/popup_open_close_animation_test.cpp
+++ b/autotests/integration/effects/popup_open_close_animation_test.cpp
@@ -182,7 +182,7 @@ void PopupOpenCloseAnimationTest::testAnimateUserActionsPopup()
     QVERIFY(!effect->isActive());
 
     // Show the user actions popup.
-    Test::app()->workspace->showWindowMenu(QRect(), client);
+    Test::app()->workspace->user_actions_menu->show(QRect(), client);
     auto& userActionsMenu = Test::app()->workspace->user_actions_menu;
     QTRY_VERIFY(userActionsMenu->isShown());
     QVERIFY(userActionsMenu->hasClient());
diff --git a/win/active_window.h b/win/active_window.h
index 230c355e3..1d909de07 100644
--- a/win/active_window.h
+++ b/win/active_window.h
@@ -303,7 +303,7 @@ void active_window_show_operations_popup(Space& space)
     }
 
     auto pos = frame_to_client_pos(space.active_client, space.active_client->pos());
-    space.showWindowMenu(QRect(pos, pos), space.active_client);
+    space.user_actions_menu->show(QRect(pos, pos), space.active_client);
 }
 
 template<typename Space>
diff --git a/win/appmenu.h b/win/appmenu.h
index 647a6ac7d..196a05eae 100644
--- a/win/appmenu.h
+++ b/win/appmenu.h
@@ -49,19 +49,4 @@ Toplevel* find_window_with_appmenu(Space const& space, appmenu_address const& ad
     return nullptr;
 }
 
-/**
- * Request showing the application menu bar.
- * @param actionId The DBus menu ID of the action that should be highlighted, 0 for the root menu.
- */
-template<typename Win>
-void show_appmenu(Win& win, int actionId)
-{
-    if (auto decoration = win.control->deco().decoration) {
-        decoration->showApplicationMenu(actionId);
-    } else {
-        // No info where application menu button is, show it in the top left corner by default.
-        win.space.showApplicationMenu(QRect(), &win, actionId);
-    }
-}
-
 }
diff --git a/win/dbus/appmenu.h b/win/dbus/appmenu.h
index 989d3dc48..0081f3c15 100644
--- a/win/dbus/appmenu.h
+++ b/win/dbus/appmenu.h
@@ -47,6 +47,21 @@ struct appmenu_callbacks {
     std::function<void(appmenu_address const&, bool)> visibility;
 };
 
+/**
+ * Request showing the application menu bar.
+ * @param actionId The DBus menu ID of the action that should be highlighted, 0 for the root menu.
+ */
+template<typename Win>
+void show_appmenu(Win& win, int actionId)
+{
+    if (auto decoration = win.control->deco().decoration) {
+        decoration->showApplicationMenu(actionId);
+    } else {
+        // No info where application menu button is, show it in the top left corner by default.
+        win.space.appmenu->showApplicationMenu(win.pos(), &win, actionId);
+    }
+}
+
 template<typename Space>
 appmenu_callbacks create_appmenu_callbacks(Space const& space)
 {
@@ -63,7 +78,7 @@ appmenu_callbacks create_appmenu_callbacks(Space const& space)
             }
         }
         if (auto win = find_window_with_appmenu(space, addr)) {
-            win::show_appmenu(*win, action_id);
+            show_appmenu(*win, action_id);
         }
     };
     callbacks.visibility = [&space](appmenu_address const& addr, bool active) {
diff --git a/win/deco/client_impl.cpp b/win/deco/client_impl.cpp
index 5abbd2f52..a0ca73d50 100644
--- a/win/deco/client_impl.cpp
+++ b/win/deco/client_impl.cpp
@@ -31,10 +31,12 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "toplevel.h"
 #include "win/actions.h"
 #include "win/control.h"
+#include "win/dbus/appmenu.h"
 #include "win/geo.h"
 #include "win/meta.h"
 #include "win/space.h"
 #include "win/transient.h"
+#include "win/user_actions_menu.h"
 #include "win/window_operation.h"
 
 #include <KDecoration2/DecoratedClient>
@@ -316,13 +318,13 @@ void client_impl::requestShowWindowMenu(QRect const& rect)
 {
     // TODO: add rect to requestShowWindowMenu
     auto const client_pos = m_client->pos();
-    space.showWindowMenu(QRect(client_pos + rect.topLeft(), client_pos + rect.bottomRight()),
-                         m_client);
+    space.user_actions_menu->show(
+        QRect(client_pos + rect.topLeft(), client_pos + rect.bottomRight()), m_client);
 }
 
 void client_impl::requestShowApplicationMenu(const QRect& rect, int actionId)
 {
-    space.showApplicationMenu(rect, m_client, actionId);
+    space.appmenu->showApplicationMenu(m_client->pos() + rect.bottomLeft(), m_client, actionId);
 }
 
 void client_impl::showApplicationMenu(int actionId)
diff --git a/win/input.h b/win/input.h
index 7bfb7d9c9..6cbc4d9e5 100644
--- a/win/input.h
+++ b/win/input.h
@@ -108,7 +108,7 @@ bool perform_mouse_command(Win& win, base::options::MouseCommand cmd, QPoint con
         if (win.control->active() && kwinApp()->options->isClickRaise()) {
             auto_raise(&win);
         }
-        space.showWindowMenu(QRect(globalPos, globalPos), &win);
+        space.user_actions_menu->show(QRect(globalPos, globalPos), &win);
         break;
     case base::options::MouseToggleRaiseAndLower:
         raise_or_lower_client(&space, &win);
diff --git a/win/space.cpp b/win/space.cpp
index 8e2416c11..ca1ff4a3a 100644
--- a/win/space.cpp
+++ b/win/space.cpp
@@ -1865,16 +1865,6 @@ bool space::switchWindow(Toplevel* c, Direction direction, QPoint curPos, int d)
     return switchTo;
 }
 
-void space::showWindowMenu(const QRect& pos, Toplevel* window)
-{
-    user_actions_menu->show(pos, window);
-}
-
-void space::showApplicationMenu(const QRect& pos, Toplevel* window, int actionId)
-{
-    appmenu->showApplicationMenu(window->pos() + pos.bottomLeft(), window, actionId);
-}
-
 bool space::shortcutAvailable(const QKeySequence& cut, Toplevel* ignore) const
 {
     if (ignore && cut == ignore->control->shortcut())
diff --git a/win/space.h b/win/space.h
index 65d044542..21f8bfc63 100644
--- a/win/space.h
+++ b/win/space.h
@@ -298,14 +298,6 @@ public:
 
     Toplevel* active_client{nullptr};
 
-    /**
-     * Shows the menu operations menu for the client and makes it active if
-     * it's not already.
-     */
-    void showWindowMenu(const QRect& pos, Toplevel* window);
-
-    void showApplicationMenu(const QRect& pos, Toplevel* window, int actionId);
-
     void updateMinimizedOfTransients(Toplevel*);
     void updateOnAllDesktopsOfTransients(Toplevel* window);
     void checkTransients(Toplevel* window);
-- 
GitLab


From e330c1de0c0df1303d100639b509f833e45468ca Mon Sep 17 00:00:00 2001
From: Roman Gilg <subdiff@gmail.com>
Date: Thu, 7 Jul 2022 23:41:29 +0200
Subject: [PATCH 18/51] refactor: define directions as enum class in types
 header

Move the enum from the space class to the win namespace and change them to enum
case and lower-case.
---
 autotests/integration/activation_test.cpp | 44 +++++++++++------------
 scripting/space.h                         | 12 +++----
 win/space.cpp                             | 34 +++++++++---------
 win/space.h                               |  5 ++-
 win/types.h                               |  7 ++++
 5 files changed, 55 insertions(+), 47 deletions(-)

diff --git a/autotests/integration/activation_test.cpp b/autotests/integration/activation_test.cpp
index 575b66428..3f3ec3e07 100644
--- a/autotests/integration/activation_test.cpp
+++ b/autotests/integration/activation_test.cpp
@@ -123,19 +123,19 @@ void ActivationTest::testSwitchToWindowToLeft()
     win::move(client4, QPoint(1580, 200));
 
     // Switch to window to the left.
-    Test::app()->workspace->switchWindow(win::space::DirectionWest);
+    Test::app()->workspace->switchWindow(win::direction::west);
     QVERIFY(client3->control->active());
 
     // Switch to window to the left.
-    Test::app()->workspace->switchWindow(win::space::DirectionWest);
+    Test::app()->workspace->switchWindow(win::direction::west);
     QVERIFY(client2->control->active());
 
     // Switch to window to the left.
-    Test::app()->workspace->switchWindow(win::space::DirectionWest);
+    Test::app()->workspace->switchWindow(win::direction::west);
     QVERIFY(client1->control->active());
 
     // Switch to window to the left.
-    Test::app()->workspace->switchWindow(win::space::DirectionWest);
+    Test::app()->workspace->switchWindow(win::direction::west);
     QVERIFY(client4->control->active());
 
     // Destroy all clients.
@@ -191,19 +191,19 @@ void ActivationTest::testSwitchToWindowToRight()
     win::move(client4, QPoint(1580, 200));
 
     // Switch to window to the right.
-    Test::app()->workspace->switchWindow(win::space::DirectionEast);
+    Test::app()->workspace->switchWindow(win::direction::east);
     QVERIFY(client1->control->active());
 
     // Switch to window to the right.
-    Test::app()->workspace->switchWindow(win::space::DirectionEast);
+    Test::app()->workspace->switchWindow(win::direction::east);
     QVERIFY(client2->control->active());
 
     // Switch to window to the right.
-    Test::app()->workspace->switchWindow(win::space::DirectionEast);
+    Test::app()->workspace->switchWindow(win::direction::east);
     QVERIFY(client3->control->active());
 
     // Switch to window to the right.
-    Test::app()->workspace->switchWindow(win::space::DirectionEast);
+    Test::app()->workspace->switchWindow(win::direction::east);
     QVERIFY(client4->control->active());
 
     // Destroy all clients.
@@ -259,19 +259,19 @@ void ActivationTest::testSwitchToWindowAbove()
     win::move(client4, QPoint(200, 1424));
 
     // Switch to window above.
-    Test::app()->workspace->switchWindow(win::space::DirectionNorth);
+    Test::app()->workspace->switchWindow(win::direction::north);
     QVERIFY(client3->control->active());
 
     // Switch to window above.
-    Test::app()->workspace->switchWindow(win::space::DirectionNorth);
+    Test::app()->workspace->switchWindow(win::direction::north);
     QVERIFY(client2->control->active());
 
     // Switch to window above.
-    Test::app()->workspace->switchWindow(win::space::DirectionNorth);
+    Test::app()->workspace->switchWindow(win::direction::north);
     QVERIFY(client1->control->active());
 
     // Switch to window above.
-    Test::app()->workspace->switchWindow(win::space::DirectionNorth);
+    Test::app()->workspace->switchWindow(win::direction::north);
     QVERIFY(client4->control->active());
 
     // Destroy all clients.
@@ -327,19 +327,19 @@ void ActivationTest::testSwitchToWindowBelow()
     win::move(client4, QPoint(200, 1424));
 
     // Switch to window below.
-    Test::app()->workspace->switchWindow(win::space::DirectionSouth);
+    Test::app()->workspace->switchWindow(win::direction::south);
     QVERIFY(client1->control->active());
 
     // Switch to window below.
-    Test::app()->workspace->switchWindow(win::space::DirectionSouth);
+    Test::app()->workspace->switchWindow(win::direction::south);
     QVERIFY(client2->control->active());
 
     // Switch to window below.
-    Test::app()->workspace->switchWindow(win::space::DirectionSouth);
+    Test::app()->workspace->switchWindow(win::direction::south);
     QVERIFY(client3->control->active());
 
     // Switch to window below.
-    Test::app()->workspace->switchWindow(win::space::DirectionSouth);
+    Test::app()->workspace->switchWindow(win::direction::south);
     QVERIFY(client4->control->active());
 
     // Destroy all clients.
@@ -417,15 +417,15 @@ void ActivationTest::testSwitchToWindowMaximized()
     win::move(client4, QPoint(1580, 200));
 
     // Switch to window to the left.
-    Test::app()->workspace->switchWindow(win::space::DirectionWest);
+    Test::app()->workspace->switchWindow(win::direction::west);
     QVERIFY(client3->control->active());
 
     // Switch to window to the left.
-    Test::app()->workspace->switchWindow(win::space::DirectionWest);
+    Test::app()->workspace->switchWindow(win::direction::west);
     QVERIFY(client2->control->active());
 
     // Switch to window to the left.
-    Test::app()->workspace->switchWindow(win::space::DirectionWest);
+    Test::app()->workspace->switchWindow(win::direction::west);
     QVERIFY(client4->control->active());
 
     // Destroy all clients.
@@ -502,15 +502,15 @@ void ActivationTest::testSwitchToWindowFullScreen()
     win::move(client4, QPoint(200, 1424));
 
     // Switch to window above.
-    Test::app()->workspace->switchWindow(win::space::DirectionNorth);
+    Test::app()->workspace->switchWindow(win::direction::north);
     QVERIFY(client3->control->active());
 
     // Switch to window above.
-    Test::app()->workspace->switchWindow(win::space::DirectionNorth);
+    Test::app()->workspace->switchWindow(win::direction::north);
     QVERIFY(client2->control->active());
 
     // Switch to window above.
-    Test::app()->workspace->switchWindow(win::space::DirectionNorth);
+    Test::app()->workspace->switchWindow(win::direction::north);
     QVERIFY(client4->control->active());
 
     // Destroy all clients.
diff --git a/scripting/space.h b/scripting/space.h
index c96e82e32..fc20d6a31 100644
--- a/scripting/space.h
+++ b/scripting/space.h
@@ -685,10 +685,10 @@ public:
         ref_space->quickTileWindow(modes);                                                         \
     }
 
-#define SWITCH_WINDOW_SLOT(name, direction)                                                        \
+#define SWITCH_WINDOW_SLOT(name, dir)                                                              \
     void name() override                                                                           \
     {                                                                                              \
-        ref_space->switchWindow(win::space::direction);                                            \
+        ref_space->switchWindow(win::direction::dir);                                              \
     }
 
     void slotSwitchToNextScreen() override
@@ -880,10 +880,10 @@ public:
     QUICKTILE_SLOT(slotWindowQuickTileBottomLeft, win::quicktiles::bottom | win::quicktiles::left)
     QUICKTILE_SLOT(slotWindowQuickTileBottomRight, win::quicktiles::bottom | win::quicktiles::right)
 
-    SWITCH_WINDOW_SLOT(slotSwitchWindowUp, DirectionNorth)
-    SWITCH_WINDOW_SLOT(slotSwitchWindowDown, DirectionSouth)
-    SWITCH_WINDOW_SLOT(slotSwitchWindowRight, DirectionEast)
-    SWITCH_WINDOW_SLOT(slotSwitchWindowLeft, DirectionWest)
+    SWITCH_WINDOW_SLOT(slotSwitchWindowUp, north)
+    SWITCH_WINDOW_SLOT(slotSwitchWindowDown, south)
+    SWITCH_WINDOW_SLOT(slotSwitchWindowRight, east)
+    SWITCH_WINDOW_SLOT(slotSwitchWindowLeft, west)
 
 #undef QUICKTILE_SLOT
 #undef SWITCH_WINDOW_SLOT
diff --git a/win/space.cpp b/win/space.cpp
index ca1ff4a3a..0723cceef 100644
--- a/win/space.cpp
+++ b/win/space.cpp
@@ -1620,23 +1620,25 @@ void space::initShortcuts()
     def4("Switch Window Up",
          kli18n("Switch to Window Above"),
          Qt::META + Qt::ALT + Qt::Key_Up,
-         std::bind(
-             static_cast<void (space::*)(Direction)>(&space::switchWindow), this, DirectionNorth));
+         std::bind(static_cast<void (space::*)(direction)>(&space::switchWindow),
+                   this,
+                   direction::north));
     def4("Switch Window Down",
          kli18n("Switch to Window Below"),
          Qt::META + Qt::ALT + Qt::Key_Down,
-         std::bind(
-             static_cast<void (space::*)(Direction)>(&space::switchWindow), this, DirectionSouth));
+         std::bind(static_cast<void (space::*)(direction)>(&space::switchWindow),
+                   this,
+                   direction::south));
     def4("Switch Window Right",
          kli18n("Switch to Window to the Right"),
          Qt::META + Qt::ALT + Qt::Key_Right,
          std::bind(
-             static_cast<void (space::*)(Direction)>(&space::switchWindow), this, DirectionEast));
+             static_cast<void (space::*)(direction)>(&space::switchWindow), this, direction::east));
     def4("Switch Window Left",
          kli18n("Switch to Window to the Left"),
          Qt::META + Qt::ALT + Qt::Key_Left,
          std::bind(
-             static_cast<void (space::*)(Direction)>(&space::switchWindow), this, DirectionWest));
+             static_cast<void (space::*)(direction)>(&space::switchWindow), this, direction::west));
     def2("Increase Opacity",
          kli18n("Increase Opacity of Active Window by 5 %"),
          0,
@@ -1777,7 +1779,7 @@ void space::clientShortcutUpdated(Toplevel* window)
 /**
  * Switches to the nearest window in given direction.
  */
-void space::switchWindow(Direction direction)
+void space::switchWindow(win::direction direction)
 {
     if (!active_client)
         return;
@@ -1790,13 +1792,13 @@ void space::switchWindow(Direction direction)
     if (!switchWindow(c, direction, curPos, desktopNumber)) {
         auto opposite = [&] {
             switch (direction) {
-            case DirectionNorth:
+            case direction::north:
                 return QPoint(curPos.x(), kwinApp()->get_base().topology.size.height());
-            case DirectionSouth:
+            case direction::south:
                 return QPoint(curPos.x(), 0);
-            case DirectionEast:
+            case direction::east:
                 return QPoint(0, curPos.y());
-            case DirectionWest:
+            case direction::west:
                 return QPoint(kwinApp()->get_base().topology.size.width(), curPos.y());
             default:
                 Q_UNREACHABLE();
@@ -1807,7 +1809,7 @@ void space::switchWindow(Direction direction)
     }
 }
 
-bool space::switchWindow(Toplevel* c, Direction direction, QPoint curPos, int d)
+bool space::switchWindow(Toplevel* c, win::direction direction, QPoint curPos, int d)
 {
     Toplevel* switchTo = nullptr;
     int bestScore = 0;
@@ -1827,19 +1829,19 @@ bool space::switchWindow(Toplevel* c, Direction direction, QPoint curPos, int d)
             int distance;
             int offset;
             switch (direction) {
-            case DirectionNorth:
+            case direction::north:
                 distance = curPos.y() - other.y();
                 offset = qAbs(other.x() - curPos.x());
                 break;
-            case DirectionEast:
+            case direction::east:
                 distance = other.x() - curPos.x();
                 offset = qAbs(other.y() - curPos.y());
                 break;
-            case DirectionSouth:
+            case direction::south:
                 distance = other.y() - curPos.y();
                 offset = qAbs(other.x() - curPos.x());
                 break;
-            case DirectionWest:
+            case direction::west:
                 distance = curPos.x() - other.x();
                 offset = qAbs(other.y() - curPos.y());
                 break;
diff --git a/win/space.h b/win/space.h
index 21f8bfc63..02c2558e5 100644
--- a/win/space.h
+++ b/win/space.h
@@ -336,8 +336,7 @@ public:
 
     void quickTileWindow(win::quicktiles mode);
 
-    enum Direction { DirectionNorth, DirectionEast, DirectionSouth, DirectionWest };
-    void switchWindow(Direction direction);
+    void switchWindow(win::direction direction);
 
     win::shortcut_dialog* shortcutDialog() const
     {
@@ -378,7 +377,7 @@ public:
                                        Slot slot,
                                        QVariant const& data);
     void setupWindowShortcut(Toplevel* window);
-    bool switchWindow(Toplevel* c, Direction direction, QPoint curPos, int desktop);
+    bool switchWindow(Toplevel* c, win::direction direction, QPoint curPos, int desktop);
 
     QWidget* active_popup{nullptr};
 
diff --git a/win/types.h b/win/types.h
index 2e3480858..5d58a6937 100644
--- a/win/types.h
+++ b/win/types.h
@@ -10,6 +10,13 @@
 namespace KWin::win
 {
 
+enum class direction {
+    north,
+    east,
+    south,
+    west,
+};
+
 enum class position {
     center = 0x0,
     left = 0x1,
-- 
GitLab


From 1ce40bd80fc1e8aa406f2971d3009aee705512da Mon Sep 17 00:00:00 2001
From: Roman Gilg <subdiff@gmail.com>
Date: Thu, 7 Jul 2022 23:07:53 +0200
Subject: [PATCH 19/51] refactor: reimplement space shortcut functions as free
 functions

This way they can be reused by different types of spaces.
---
 .../integration/globalshortcuts_test.cpp      |  10 +-
 autotests/integration/lib/app.cpp             |   3 +-
 main_wayland.cpp                              |   3 +-
 main_x11.cpp                                  |   3 +-
 render/post/night_color_manager.h             |   7 +-
 toplevel.cpp                                  |   3 +-
 win/input.h                                   |  74 ----
 win/osd.h                                     |  11 +-
 win/output_space.h                            |   2 +
 win/shortcut_dialog.h                         |   4 +-
 win/shortcut_set.h                            | 204 +++++++++
 win/shortcuts_init.h                          | 331 +++++++++++++++
 win/space.cpp                                 | 386 ------------------
 win/space.h                                   |  26 --
 win/user_actions_menu.h                       |   3 +
 win/wayland/space.cpp                         |   2 +-
 win/window_operation.h                        |   3 +-
 win/x11/window.cpp                            |   5 +-
 win/x11/window_release.h                      |   5 +-
 19 files changed, 575 insertions(+), 510 deletions(-)
 create mode 100644 win/shortcut_set.h
 create mode 100644 win/shortcuts_init.h

diff --git a/autotests/integration/globalshortcuts_test.cpp b/autotests/integration/globalshortcuts_test.cpp
index 536011028..aeccbad49 100644
--- a/autotests/integration/globalshortcuts_test.cpp
+++ b/autotests/integration/globalshortcuts_test.cpp
@@ -375,10 +375,10 @@ void GlobalShortcutsTest::testX11ClientShortcut()
     QVERIFY(client->control->active());
     QCOMPARE(client->control->shortcut(), QKeySequence());
     const QKeySequence seq(Qt::META + Qt::SHIFT + Qt::Key_Y);
-    QVERIFY(Test::app()->workspace->shortcutAvailable(seq));
+    QVERIFY(win::shortcut_available(*Test::app()->workspace, seq, nullptr));
     win::set_shortcut(client, seq.toString());
     QCOMPARE(client->control->shortcut(), seq);
-    QVERIFY(!Test::app()->workspace->shortcutAvailable(seq));
+    QVERIFY(!win::shortcut_available(*Test::app()->workspace, seq, nullptr));
     QCOMPARE(win::caption(client), QStringLiteral(" {Meta+Shift+Y}"));
 
     // it's delayed
@@ -417,10 +417,10 @@ void GlobalShortcutsTest::testWaylandClientShortcut()
     QVERIFY(client->control->active());
     QCOMPARE(client->control->shortcut(), QKeySequence());
     const QKeySequence seq(Qt::META + Qt::SHIFT + Qt::Key_Y);
-    QVERIFY(Test::app()->workspace->shortcutAvailable(seq));
+    QVERIFY(win::shortcut_available(*Test::app()->workspace, seq, nullptr));
     win::set_shortcut(client, seq.toString());
     QCOMPARE(client->control->shortcut(), seq);
-    QVERIFY(!Test::app()->workspace->shortcutAvailable(seq));
+    QVERIFY(!win::shortcut_available(*Test::app()->workspace, seq, nullptr));
     QCOMPARE(win::caption(client), QStringLiteral(" {Meta+Shift+Y}"));
 
     win::activate_window(*Test::app()->workspace, nullptr);
@@ -443,7 +443,7 @@ void GlobalShortcutsTest::testWaylandClientShortcut()
 
     // Wait a bit for KGlobalAccel to catch up.
     QTest::qWait(100);
-    QVERIFY(Test::app()->workspace->shortcutAvailable(seq));
+    QVERIFY(win::shortcut_available(*Test::app()->workspace, seq, nullptr));
 }
 
 void GlobalShortcutsTest::testSetupWindowShortcut()
diff --git a/autotests/integration/lib/app.cpp b/autotests/integration/lib/app.cpp
index 20aea3eef..4bbd52973 100644
--- a/autotests/integration/lib/app.cpp
+++ b/autotests/integration/lib/app.cpp
@@ -34,6 +34,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "render/wayland/compositor.h"
 #include "scripting/platform.h"
 #include "win/screen.h"
+#include "win/shortcuts_init.h"
 #include "win/wayland/space.h"
 #include "xwl/xwayland.h"
 
@@ -219,7 +220,7 @@ void WaylandTestApplication::start()
 
     workspace->input = std::make_unique<input::wayland::redirect>(*input, *workspace);
     input::wayland::add_dbus(input.get());
-    workspace->initShortcuts();
+    win::init_shortcuts(*workspace);
     workspace->scripting = std::make_unique<scripting::platform>(*workspace);
 
     base.render->compositor->start(*workspace);
diff --git a/main_wayland.cpp b/main_wayland.cpp
index ecd6aa9d3..b58d4d0fb 100644
--- a/main_wayland.cpp
+++ b/main_wayland.cpp
@@ -35,6 +35,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "input/wayland/redirect.h"
 #include "input/dbus/tablet_mode_manager.h"
 #include "scripting/platform.h"
+#include "win/shortcuts_init.h"
 #include "win/wayland/space.h"
 #include "xwl/xwayland.h"
 
@@ -240,7 +241,7 @@ void ApplicationWayland::start()
 
     workspace->input = std::make_unique<input::wayland::redirect>(*input, *workspace);
     input::wayland::add_dbus(input.get());
-    workspace->initShortcuts();
+    win::init_shortcuts(*workspace);
     tablet_mode_manager = std::make_unique<input::dbus::tablet_mode_manager>();
     workspace->scripting = std::make_unique<scripting::platform>(*workspace);
 
diff --git a/main_x11.cpp b/main_x11.cpp
index 63885c7f2..7e16b16b5 100644
--- a/main_x11.cpp
+++ b/main_x11.cpp
@@ -20,6 +20,7 @@
 #include "input/x11/redirect.h"
 #include "render/x11/compositor.h"
 #include "scripting/platform.h"
+#include "win/shortcuts_init.h"
 #include "win/space.h"
 #include "win/x11/space.h"
 
@@ -261,7 +262,7 @@ void ApplicationX11::start()
 
         workspace = std::make_unique<win::x11::space>(*render->compositor);
         workspace->input = std::make_unique<input::x11::redirect>(*input, *workspace);
-        workspace->initShortcuts();
+        win::init_shortcuts(*workspace);
 
         event_filter = std::make_unique<base::x11::xcb_event_filter<win::x11::space>>(*workspace);
         installNativeEventFilter(event_filter.get());
diff --git a/render/post/night_color_manager.h b/render/post/night_color_manager.h
index f33a4530f..da24537d8 100644
--- a/render/post/night_color_manager.h
+++ b/render/post/night_color_manager.h
@@ -200,6 +200,9 @@ public:
     // for auto tests
     void reconfigure();
 
+    // Internal
+    void init_shortcuts();
+
 public Q_SLOTS:
     void reset_slow_update_start_timer();
     void quick_adjust();
@@ -246,7 +249,6 @@ Q_SIGNALS:
     void scheduled_transition_timings_changed();
 
 private:
-    void init_shortcuts();
     void read_config();
     void hard_reset();
     void slow_update(int targetTemp);
@@ -324,9 +326,6 @@ private:
     int inhibit_reference_count{0};
 
     KConfigWatcher::Ptr config_watcher;
-
-    // The space class needs to call init_shortcuts during initialization.
-    friend class KWin::win::space;
 };
 
 }
diff --git a/toplevel.cpp b/toplevel.cpp
index 763886ac6..40515771d 100644
--- a/toplevel.cpp
+++ b/toplevel.cpp
@@ -29,6 +29,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "win/input.h"
 #include "win/remnant.h"
 #include "win/scene.h"
+#include "win/shortcut_set.h"
 #include "win/space.h"
 #include "win/transient.h"
 #include "win/x11/client_machine.h"
@@ -923,7 +924,7 @@ QRect Toplevel::iconGeometry() const
 void Toplevel::setShortcutInternal()
 {
     updateCaption();
-    space.clientShortcutUpdated(this);
+    win::window_shortcut_updated(space, this);
 }
 
 }
diff --git a/win/input.h b/win/input.h
index 6cbc4d9e5..91b8531a7 100644
--- a/win/input.h
+++ b/win/input.h
@@ -508,78 +508,4 @@ base::options::MouseCommand get_wheel_command(Win* win, Qt::Orientation orientat
     return base::options::MouseNothing;
 }
 
-template<typename Win>
-void set_shortcut(Win* win, QString const& shortcut)
-{
-    auto update_shortcut = [&win](QKeySequence const& cut = QKeySequence()) {
-        if (win->control->shortcut() == cut) {
-            return;
-        }
-        win->control->set_shortcut(cut.toString());
-        win->setShortcutInternal();
-    };
-
-    auto cut = win->control->rules().checkShortcut(shortcut);
-    if (cut.isEmpty()) {
-        update_shortcut();
-        return;
-    }
-    if (cut == win->control->shortcut().toString()) {
-        // No change
-        return;
-    }
-
-    // Format:
-    //       base+(abcdef)<space>base+(abcdef)
-    //   Alt+Ctrl+(ABCDEF);Meta+X,Meta+(ABCDEF)
-    //
-    if (!cut.contains(QLatin1Char('(')) && !cut.contains(QLatin1Char(')'))
-        && !cut.contains(QLatin1String(" - "))) {
-        if (win->space.shortcutAvailable(cut, win)) {
-            update_shortcut(QKeySequence(cut));
-        } else {
-            update_shortcut();
-        }
-        return;
-    }
-
-    QRegularExpression const reg(QStringLiteral("(.*\\+)\\((.*)\\)"));
-    QList<QKeySequence> keys;
-    QStringList groups = cut.split(QStringLiteral(" - "));
-    for (QStringList::ConstIterator it = groups.constBegin(); it != groups.constEnd(); ++it) {
-        auto const match = reg.match(*it);
-        if (match.hasMatch()) {
-            auto const base = match.captured(1);
-            auto const list = match.captured(2);
-
-            for (int i = 0; i < list.length(); ++i) {
-                QKeySequence c(base + list[i]);
-                if (!c.isEmpty()) {
-                    keys.append(c);
-                }
-            }
-        } else {
-            // The regexp doesn't match, so it should be a normal shortcut.
-            QKeySequence c(*it);
-            if (!c.isEmpty()) {
-                keys.append(c);
-            }
-        }
-    }
-
-    for (auto it = keys.constBegin(); it != keys.constEnd(); ++it) {
-        if (win->control->shortcut() == *it) {
-            // Current one is in the list.
-            return;
-        }
-    }
-    for (auto it = keys.constBegin(); it != keys.constEnd(); ++it) {
-        if (win->space.shortcutAvailable(*it, win)) {
-            update_shortcut(*it);
-            return;
-        }
-    }
-    update_shortcut();
-}
-
 }
diff --git a/win/osd.h b/win/osd.h
index 63bf111b2..4cd82214e 100644
--- a/win/osd.h
+++ b/win/osd.h
@@ -6,6 +6,7 @@
 */
 #pragma once
 
+#include "kwin_export.h"
 #include "utils/flags.h"
 
 #include <QString>
@@ -15,16 +16,18 @@ namespace KWin::win
 
 class space;
 
-void osd_show(win::space& space, QString const& message, QString const& iconName = QString());
-void osd_show(win::space& space, QString const& message, int timeout);
-void osd_show(win::space& space, QString const& message, QString const& iconName, int timeout);
+KWIN_EXPORT void
+osd_show(win::space& space, QString const& message, QString const& iconName = QString());
+KWIN_EXPORT void osd_show(win::space& space, QString const& message, int timeout);
+KWIN_EXPORT void
+osd_show(win::space& space, QString const& message, QString const& iconName, int timeout);
 
 enum class osd_hide_flags {
     none = 0x0,
     skip_close_animation = 0x1,
 };
 
-void osd_hide(win::space& space, osd_hide_flags hide_flags = osd_hide_flags::none);
+KWIN_EXPORT void osd_hide(win::space& space, osd_hide_flags hide_flags = osd_hide_flags::none);
 
 }
 
diff --git a/win/output_space.h b/win/output_space.h
index e43ce2e7c..7321b695e 100644
--- a/win/output_space.h
+++ b/win/output_space.h
@@ -13,6 +13,8 @@
 #include "base/output_helpers.h"
 #include "main.h"
 
+#include <KProcess>
+
 namespace KWin::win
 {
 
diff --git a/win/shortcut_dialog.h b/win/shortcut_dialog.h
index 363dccdf9..e064745b1 100644
--- a/win/shortcut_dialog.h
+++ b/win/shortcut_dialog.h
@@ -6,6 +6,8 @@
 */
 #pragma once
 
+#include "kwin_export.h"
+
 #include "ui_shortcut_dialog.h"
 
 #include <QDialog>
@@ -13,7 +15,7 @@
 namespace KWin::win
 {
 
-class shortcut_dialog : public QDialog
+class KWIN_EXPORT shortcut_dialog : public QDialog
 {
     Q_OBJECT
 public:
diff --git a/win/shortcut_set.h b/win/shortcut_set.h
new file mode 100644
index 000000000..db0487180
--- /dev/null
+++ b/win/shortcut_set.h
@@ -0,0 +1,204 @@
+/*
+    SPDX-FileCopyrightText: 2022 Roman Gilg <subdiff@gmail.com>
+
+    SPDX-License-Identifier: GPL-2.0-or-later
+*/
+#pragma once
+
+#include "activation.h"
+#include "shortcut_dialog.h"
+#include "shortcut_set.h"
+
+#include <KGlobalAccel>
+
+namespace KWin::win
+{
+
+template<typename Space>
+bool shortcut_available(Space& space, const QKeySequence& cut, Toplevel* ignore)
+{
+    if (ignore && cut == ignore->control->shortcut()) {
+        return true;
+    }
+
+    // Check if the shortcut is already registered.
+    auto const registeredShortcuts = KGlobalAccel::globalShortcutsByKey(cut);
+    for (auto const& shortcut : registeredShortcuts) {
+        // Only return "not available" if is not a client activation shortcut, as it may be no
+        // longer valid.
+        if (!shortcut.uniqueName().startsWith(QStringLiteral("_k_session:"))) {
+            return false;
+        }
+    }
+
+    // Check now conflicts with activation shortcuts for current clients.
+    for (auto const win : space.m_windows) {
+        if (win != ignore && win->control && win->control->shortcut() == cut) {
+            return false;
+        }
+    }
+
+    return true;
+}
+
+template<typename Win>
+void set_shortcut(Win* win, QString const& shortcut)
+{
+    auto update_shortcut = [&win](QKeySequence const& cut = QKeySequence()) {
+        if (win->control->shortcut() == cut) {
+            return;
+        }
+        win->control->set_shortcut(cut.toString());
+        win->setShortcutInternal();
+    };
+
+    auto cut = win->control->rules().checkShortcut(shortcut);
+    if (cut.isEmpty()) {
+        update_shortcut();
+        return;
+    }
+    if (cut == win->control->shortcut().toString()) {
+        // No change
+        return;
+    }
+
+    // Format:
+    //       base+(abcdef)<space>base+(abcdef)
+    //   Alt+Ctrl+(ABCDEF);Meta+X,Meta+(ABCDEF)
+    //
+    if (!cut.contains(QLatin1Char('(')) && !cut.contains(QLatin1Char(')'))
+        && !cut.contains(QLatin1String(" - "))) {
+        if (shortcut_available(win->space, cut, win)) {
+            update_shortcut(QKeySequence(cut));
+        } else {
+            update_shortcut();
+        }
+        return;
+    }
+
+    QRegularExpression const reg(QStringLiteral("(.*\\+)\\((.*)\\)"));
+    QList<QKeySequence> keys;
+    QStringList groups = cut.split(QStringLiteral(" - "));
+    for (QStringList::ConstIterator it = groups.constBegin(); it != groups.constEnd(); ++it) {
+        auto const match = reg.match(*it);
+        if (match.hasMatch()) {
+            auto const base = match.captured(1);
+            auto const list = match.captured(2);
+
+            for (int i = 0; i < list.length(); ++i) {
+                QKeySequence c(base + list[i]);
+                if (!c.isEmpty()) {
+                    keys.append(c);
+                }
+            }
+        } else {
+            // The regexp doesn't match, so it should be a normal shortcut.
+            QKeySequence c(*it);
+            if (!c.isEmpty()) {
+                keys.append(c);
+            }
+        }
+    }
+
+    for (auto it = keys.constBegin(); it != keys.constEnd(); ++it) {
+        if (win->control->shortcut() == *it) {
+            // Current one is in the list.
+            return;
+        }
+    }
+    for (auto it = keys.constBegin(); it != keys.constEnd(); ++it) {
+        if (shortcut_available(win->space, *it, win)) {
+            update_shortcut(*it);
+            return;
+        }
+    }
+    update_shortcut();
+}
+
+template<typename Space>
+void setup_window_shortcut_done(Space& space, bool ok)
+{
+    //    keys->setEnabled( true );
+    //    disable_shortcuts_keys->setEnabled( true );
+    //    client_keys->setEnabled( true );
+    if (ok) {
+        set_shortcut(space.client_keys_client, space.client_keys_dialog->shortcut().toString());
+    }
+
+    close_active_popup(space);
+
+    space.client_keys_dialog->deleteLater();
+    space.client_keys_dialog = nullptr;
+    space.client_keys_client = nullptr;
+
+    if (space.active_client) {
+        space.active_client->takeFocus();
+    }
+}
+
+template<typename Space, typename Win>
+void setup_window_shortcut(Space& space, Win* window)
+{
+    assert(!space.client_keys_dialog);
+
+    // TODO: PORT ME (KGlobalAccel related)
+    // keys->setEnabled( false );
+    // disable_shortcuts_keys->setEnabled( false );
+    // client_keys->setEnabled( false );
+    space.client_keys_dialog = new shortcut_dialog(window->control->shortcut());
+    space.client_keys_client = window;
+
+    QObject::connect(space.client_keys_dialog,
+                     &win::shortcut_dialog::dialogDone,
+                     space.qobject.get(),
+                     [&space](auto&& ok) { setup_window_shortcut_done(space, ok); });
+
+    auto area = space_window_area(space, ScreenArea, window);
+    auto size = space.client_keys_dialog->sizeHint();
+
+    auto pos = win::frame_to_client_pos(window, window->pos());
+    if (pos.x() + size.width() >= area.right()) {
+        pos.setX(area.right() - size.width());
+    }
+    if (pos.y() + size.height() >= area.bottom()) {
+        pos.setY(area.bottom() - size.height());
+    }
+
+    space.client_keys_dialog->move(pos);
+    space.client_keys_dialog->show();
+    space.active_popup = space.client_keys_dialog;
+    space.active_popup_client = window;
+}
+
+template<typename Space>
+void window_shortcut_updated(Space& space, Toplevel* window)
+{
+    QString key = QStringLiteral("_k_session:%1").arg(window->xcb_window);
+    auto action = space.qobject->template findChild<QAction*>(key);
+
+    if (!window->control->shortcut().isEmpty()) {
+        if (action == nullptr) {
+            // new shortcut
+            action = new QAction(space.qobject.get());
+            kwinApp()->input->setup_action_for_global_accel(action);
+            action->setProperty("componentName", QStringLiteral(KWIN_NAME));
+            action->setObjectName(key);
+            action->setText(i18n("Activate Window (%1)", win::caption(window)));
+            QObject::connect(action, &QAction::triggered, window, [&space, window] {
+                force_activate_window(space, window);
+            });
+        }
+
+        // no autoloading, since it's configured explicitly here and is not meant to be reused
+        // (the key is the window id anyway, which is kind of random)
+        KGlobalAccel::self()->setShortcut(action,
+                                          QList<QKeySequence>() << window->control->shortcut(),
+                                          KGlobalAccel::NoAutoloading);
+        action->setEnabled(true);
+    } else {
+        KGlobalAccel::self()->removeAllShortcuts(action);
+        delete action;
+    }
+}
+
+}
diff --git a/win/shortcuts_init.h b/win/shortcuts_init.h
new file mode 100644
index 000000000..f9234feed
--- /dev/null
+++ b/win/shortcuts_init.h
@@ -0,0 +1,331 @@
+/*
+    SPDX-FileCopyrightText: 2022 Roman Gilg <subdiff@gmail.com>
+
+    SPDX-License-Identifier: GPL-2.0-or-later
+*/
+#pragma once
+
+#include "activation.h"
+#include "active_window.h"
+#include "kill_window.h"
+#include "types.h"
+
+#include "main.h"
+#include "render/platform.h"
+#include "render/post/night_color_manager.h"
+
+#include <QAction>
+#include <QKeySequence>
+#include <QString>
+#include <QVariant>
+
+#include <KGlobalAccel>
+#include <KLazyLocalizedString>
+#include <KLocalizedString>
+
+namespace KWin::win
+{
+
+template<typename Space>
+QAction* prepare_shortcut_action(Space& space,
+                                 QString const& actionName,
+                                 QString const& description,
+                                 QKeySequence const& shortcut,
+                                 QVariant const& data)
+{
+    auto action = new QAction(space.qobject.get());
+    action->setProperty("componentName", QStringLiteral(KWIN_NAME));
+    action->setObjectName(actionName);
+    action->setText(description);
+
+    if (data.isValid()) {
+        action->setData(data);
+    }
+
+    KGlobalAccel::self()->setDefaultShortcut(action, QList<QKeySequence>() << shortcut);
+    KGlobalAccel::self()->setShortcut(action, QList<QKeySequence>() << shortcut);
+    return action;
+}
+
+template<typename Space, typename T, typename Slot>
+void init_shortcut(Space& space,
+                   QString const& actionName,
+                   QString const& description,
+                   const QKeySequence& shortcut,
+                   T* receiver,
+                   Slot slot,
+                   const QVariant& data = QVariant())
+{
+    auto action = prepare_shortcut_action(space, actionName, description, shortcut, data);
+    kwinApp()->input->registerShortcut(shortcut, action, receiver, slot);
+}
+
+template<typename Space, typename Slot>
+void init_shortcut(Space& space,
+                   QString const& actionName,
+                   QString const& description,
+                   const QKeySequence& shortcut,
+                   Slot slot,
+                   const QVariant& data = QVariant())
+{
+    init_shortcut(space, actionName, description, shortcut, space.qobject.get(), slot, data);
+}
+
+template<typename Space, typename T, typename Slot>
+void init_shortcut_with_action_arg(Space& space,
+                                   QString const& actionName,
+                                   QString const& description,
+                                   const QKeySequence& shortcut,
+                                   T* receiver,
+                                   Slot slot,
+                                   QVariant const& data)
+{
+    auto action = prepare_shortcut_action(space, actionName, description, shortcut, data);
+    kwinApp()->input->registerShortcut(
+        shortcut, action, receiver, [action, &slot] { slot(action); });
+}
+
+/**
+ * Creates the global accel object \c keys.
+ */
+template<typename Space>
+void init_shortcuts(Space& space)
+{
+    // Some shortcuts have Tarzan-speech like names, they need extra
+    // normal human descriptions with def2() the others can use def()
+    // new def3 allows to pass data to the action, replacing the %1 argument in the name
+
+    auto def2 = [&](auto name, auto descr, auto key, auto functor) {
+        init_shortcut(
+            space, QString(name), descr.toString(), key, [&, functor] { functor(space); });
+    };
+
+    auto def = [&](auto name, auto key, auto functor) {
+        init_shortcut(
+            space, QString::fromUtf8(name.untranslatedText()), name.toString(), key, [&, functor] {
+                functor(space);
+            });
+    };
+
+    auto def3 = [&](auto name, auto key, auto functor, auto value) {
+        init_shortcut_with_action_arg(
+            space,
+            QString::fromUtf8(name.untranslatedText()).arg(value),
+            name.subs(value).toString(),
+            key,
+            space.qobject.get(),
+            [&, functor](QAction* action) { functor(space, action); },
+            value);
+    };
+
+    auto def4 = [&](auto name, auto descr, auto key, auto functor) {
+        init_shortcut(space, QString(name), descr.toString(), key, functor);
+    };
+
+    auto def5 = [&](auto name, auto key, auto functor, auto value) {
+        init_shortcut(space,
+                      QString::fromUtf8(name.untranslatedText()).arg(value),
+                      name.subs(value).toString(),
+                      key,
+                      functor,
+                      value);
+    };
+
+    auto def6 = [&](auto name, auto key, auto target, auto functor) {
+        init_shortcut(space,
+                      QString::fromUtf8(name.untranslatedText()),
+                      name.toString(),
+                      key,
+                      target,
+                      functor);
+    };
+
+    def(kli18n("Window Operations Menu"),
+        Qt::ALT + Qt::Key_F3,
+        active_window_show_operations_popup<Space>);
+    def2("Window Close", kli18n("Close Window"), Qt::ALT + Qt::Key_F4, active_window_close<Space>);
+    def2("Window Maximize",
+         kli18n("Maximize Window"),
+         Qt::META + Qt::Key_PageUp,
+         active_window_maximize<Space>);
+    def2("Window Maximize Vertical",
+         kli18n("Maximize Window Vertically"),
+         0,
+         active_window_maximize_vertical<Space>);
+    def2("Window Maximize Horizontal",
+         kli18n("Maximize Window Horizontally"),
+         0,
+         active_window_maximize_horizontal<Space>);
+    def2("Window Minimize",
+         kli18n("Minimize Window"),
+         Qt::META + Qt::Key_PageDown,
+         active_window_minimize<Space>);
+    def2("Window Move", kli18n("Move Window"), 0, active_window_move<Space>);
+    def2("Window Resize", kli18n("Resize Window"), 0, active_window_resize<Space>);
+    def2("Window Raise", kli18n("Raise Window"), 0, active_window_raise<Space>);
+    def2("Window Lower", kli18n("Lower Window"), 0, active_window_lower<Space>);
+    def(kli18n("Toggle Window Raise/Lower"), 0, active_window_raise_or_lower<Space>);
+    def2("Window Fullscreen",
+         kli18n("Make Window Fullscreen"),
+         0,
+         active_window_set_fullscreen<Space>);
+    def2("Window No Border", kli18n("Hide Window Border"), 0, active_window_set_no_border<Space>);
+    def2("Window Above Other Windows",
+         kli18n("Keep Window Above Others"),
+         0,
+         active_window_set_keep_above<Space>);
+    def2("Window Below Other Windows",
+         kli18n("Keep Window Below Others"),
+         0,
+         active_window_set_keep_below<Space>);
+
+    def(kli18n("Activate Window Demanding Attention"),
+        Qt::META | Qt::CTRL | Qt::Key_A,
+        activate_attention_window<Space>);
+    def(kli18n("Setup Window Shortcut"), 0, active_window_setup_window_shortcut<Space>);
+    def2("Window Pack Right",
+         kli18n("Pack Window to the Right"),
+         0,
+         active_window_pack_right<Space>);
+    def2("Window Pack Left", kli18n("Pack Window to the Left"), 0, active_window_pack_left<Space>);
+    def2("Window Pack Up", kli18n("Pack Window Up"), 0, active_window_pack_up<Space>);
+    def2("Window Pack Down", kli18n("Pack Window Down"), 0, active_window_pack_down<Space>);
+    def2("Window Grow Horizontal",
+         kli18n("Pack Grow Window Horizontally"),
+         0,
+         active_window_grow_horizontal<Space>);
+    def2("Window Grow Vertical",
+         kli18n("Pack Grow Window Vertically"),
+         0,
+         active_window_grow_vertical<Space>);
+    def2("Window Shrink Horizontal",
+         kli18n("Pack Shrink Window Horizontally"),
+         0,
+         active_window_shrink_horizontal<Space>);
+    def2("Window Shrink Vertical",
+         kli18n("Pack Shrink Window Vertically"),
+         0,
+         active_window_shrink_vertical<Space>);
+    def4("Window Quick Tile Left",
+         kli18n("Quick Tile Window to the Left"),
+         Qt::META + Qt::Key_Left,
+         std::bind(&Space::quickTileWindow, &space, win::quicktiles::left));
+    def4("Window Quick Tile Right",
+         kli18n("Quick Tile Window to the Right"),
+         Qt::META + Qt::Key_Right,
+         std::bind(&Space::quickTileWindow, &space, win::quicktiles::right));
+    def4("Window Quick Tile Top",
+         kli18n("Quick Tile Window to the Top"),
+         Qt::META + Qt::Key_Up,
+         std::bind(&Space::quickTileWindow, &space, win::quicktiles::top));
+    def4("Window Quick Tile Bottom",
+         kli18n("Quick Tile Window to the Bottom"),
+         Qt::META + Qt::Key_Down,
+         std::bind(&Space::quickTileWindow, &space, win::quicktiles::bottom));
+    def4("Window Quick Tile Top Left",
+         kli18n("Quick Tile Window to the Top Left"),
+         0,
+         std::bind(&Space::quickTileWindow, &space, win::quicktiles::top | win::quicktiles::left));
+    def4("Window Quick Tile Bottom Left",
+         kli18n("Quick Tile Window to the Bottom Left"),
+         0,
+         std::bind(
+             &Space::quickTileWindow, &space, win::quicktiles::bottom | win::quicktiles::left));
+    def4("Window Quick Tile Top Right",
+         kli18n("Quick Tile Window to the Top Right"),
+         0,
+         std::bind(&Space::quickTileWindow, &space, win::quicktiles::top | win::quicktiles::right));
+    def4("Window Quick Tile Bottom Right",
+         kli18n("Quick Tile Window to the Bottom Right"),
+         0,
+         std::bind(
+             &Space::quickTileWindow, &space, win::quicktiles::bottom | win::quicktiles::right));
+    def4("Switch Window Up",
+         kli18n("Switch to Window Above"),
+         Qt::META + Qt::ALT + Qt::Key_Up,
+         std::bind(static_cast<void (Space::*)(direction)>(&Space::switchWindow),
+                   &space,
+                   direction::north));
+    def4("Switch Window Down",
+         kli18n("Switch to Window Below"),
+         Qt::META + Qt::ALT + Qt::Key_Down,
+         std::bind(static_cast<void (Space::*)(direction)>(&Space::switchWindow),
+                   &space,
+                   direction::south));
+    def4("Switch Window Right",
+         kli18n("Switch to Window to the Right"),
+         Qt::META + Qt::ALT + Qt::Key_Right,
+         std::bind(static_cast<void (Space::*)(direction)>(&Space::switchWindow),
+                   &space,
+                   direction::east));
+    def4("Switch Window Left",
+         kli18n("Switch to Window to the Left"),
+         Qt::META + Qt::ALT + Qt::Key_Left,
+         std::bind(static_cast<void (Space::*)(direction)>(&Space::switchWindow),
+                   &space,
+                   direction::west));
+    def2("Increase Opacity",
+         kli18n("Increase Opacity of Active Window by 5 %"),
+         0,
+         active_window_increase_opacity<Space>);
+    def2("Decrease Opacity",
+         kli18n("Decrease Opacity of Active Window by 5 %"),
+         0,
+         active_window_lower_opacity<Space>);
+
+    def2("Window On All Desktops",
+         kli18n("Keep Window on All Desktops"),
+         0,
+         active_window_set_on_all_desktops<Space>);
+
+    for (int i = 1; i < 21; ++i) {
+        def5(
+            kli18n("Window to Desktop %1"),
+            0,
+            [&space, i] { active_window_to_desktop(space, i); },
+            i);
+    }
+
+    def(kli18n("Window to Next Desktop"), 0, active_window_to_next_desktop<Space>);
+    def(kli18n("Window to Previous Desktop"), 0, active_window_to_prev_desktop<Space>);
+    def(kli18n("Window One Desktop to the Right"), 0, active_window_to_right_desktop<Space>);
+    def(kli18n("Window One Desktop to the Left"), 0, active_window_to_left_desktop<Space>);
+    def(kli18n("Window One Desktop Up"), 0, active_window_to_above_desktop<Space>);
+    def(kli18n("Window One Desktop Down"), 0, active_window_to_below_desktop<Space>);
+
+    for (int i = 0; i < 8; ++i) {
+        def3(kli18n("Window to Screen %1"), 0, active_window_to_output<Space>, i);
+    }
+    def(kli18n("Window to Next Screen"), 0, active_window_to_next_output<Space>);
+    def(kli18n("Window to Previous Screen"), 0, active_window_to_prev_output<Space>);
+    def(kli18n("Show Desktop"), Qt::META + Qt::Key_D, toggle_show_desktop<Space>);
+
+    for (int i = 0; i < 8; ++i) {
+        def3(kli18n("Switch to Screen %1"), 0, switch_to_output<Space>, i);
+    }
+
+    def(kli18n("Switch to Next Screen"), 0, switch_to_next_output<Space>);
+    def(kli18n("Switch to Previous Screen"), 0, switch_to_prev_output<Space>);
+
+    def(kli18n("Kill Window"),
+        Qt::META | Qt::CTRL | Qt::Key_Escape,
+        start_window_killer<win::space>);
+    def6(kli18n("Suspend Compositing"),
+         Qt::SHIFT + Qt::ALT + Qt::Key_F12,
+         &space.render,
+         [render = &space.render] { render->toggleCompositing(); });
+    def6(kli18n("Invert Screen Colors"), 0, &space.render, [render = &space.render] {
+        render->platform.invertScreen();
+    });
+
+#if KWIN_BUILD_TABBOX
+    space.tabbox->init_shortcuts();
+#endif
+    space.virtual_desktop_manager->initShortcuts();
+    kwinApp()->get_base().render->night_color->init_shortcuts();
+
+    // so that it's recreated next time
+    space.user_actions_menu->discard();
+}
+
+}
diff --git a/win/space.cpp b/win/space.cpp
index 0723cceef..f854077c0 100644
--- a/win/space.cpp
+++ b/win/space.cpp
@@ -82,10 +82,6 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 // TODO(romangg): For now this needs to be included late because of some conflict with Qt libraries.
 #include "space_reconfigure.h"
 
-#include <KGlobalAccel>
-#include <KLazyLocalizedString>
-#include <KLocalizedString>
-#include <KProcess>
 #include <KStartupInfo>
 #include <QAction>
 #include <QtConcurrentRun>
@@ -1419,363 +1415,6 @@ bool space::workspaceEvent(QEvent* e)
     return false;
 }
 
-QAction* prepare_shortcut_action(win::space& space,
-                                 QString const& actionName,
-                                 QString const& description,
-                                 QKeySequence const& shortcut,
-                                 QVariant const& data)
-{
-    auto action = new QAction(space.qobject.get());
-    action->setProperty("componentName", QStringLiteral(KWIN_NAME));
-    action->setObjectName(actionName);
-    action->setText(description);
-    if (data.isValid()) {
-        action->setData(data);
-    }
-    KGlobalAccel::self()->setDefaultShortcut(action, QList<QKeySequence>() << shortcut);
-    KGlobalAccel::self()->setShortcut(action, QList<QKeySequence>() << shortcut);
-    return action;
-}
-
-template<typename Slot>
-void space::initShortcut(const QString& actionName,
-                         const QString& description,
-                         const QKeySequence& shortcut,
-                         Slot slot,
-                         const QVariant& data)
-{
-    initShortcut(actionName, description, shortcut, qobject.get(), slot, data);
-}
-
-template<typename T, typename Slot>
-void space::initShortcut(const QString& actionName,
-                         const QString& description,
-                         const QKeySequence& shortcut,
-                         T* receiver,
-                         Slot slot,
-                         const QVariant& data)
-{
-    auto action = prepare_shortcut_action(*this, actionName, description, shortcut, data);
-    kwinApp()->input->registerShortcut(shortcut, action, receiver, slot);
-}
-
-template<typename T, typename Slot>
-void space::init_shortcut_with_action_arg(const QString& actionName,
-                                          const QString& description,
-                                          const QKeySequence& shortcut,
-                                          T* receiver,
-                                          Slot slot,
-                                          QVariant const& data)
-{
-    auto action = prepare_shortcut_action(*this, actionName, description, shortcut, data);
-    kwinApp()->input->registerShortcut(
-        shortcut, action, receiver, [this, action, &slot] { slot(action); });
-}
-
-/**
- * Creates the global accel object \c keys.
- */
-void space::initShortcuts()
-{
-    // Some shortcuts have Tarzan-speech like names, they need extra
-    // normal human descriptions with def2() the others can use def()
-    // new def3 allows to pass data to the action, replacing the %1 argument in the name
-
-    auto def2 = [this](auto name, auto descr, auto key, auto functor) {
-        initShortcut(QString(name), descr.toString(), key, [this, functor] { functor(*this); });
-    };
-
-    auto def = [this](auto name, auto key, auto functor) {
-        initShortcut(QString::fromUtf8(name.untranslatedText()),
-                     name.toString(),
-                     key,
-                     [this, functor] { functor(*this); });
-    };
-
-    auto def3 = [this](auto name, auto key, auto functor, auto value) {
-        init_shortcut_with_action_arg(
-            QString::fromUtf8(name.untranslatedText()).arg(value),
-            name.subs(value).toString(),
-            key,
-            qobject.get(),
-            [this, functor](QAction* action) { functor(*this, action); },
-            value);
-    };
-
-    auto def4 = [this](auto name, auto descr, auto key, auto functor) {
-        initShortcut(QString(name), descr.toString(), key, functor);
-    };
-
-    auto def5 = [this](auto name, auto key, auto functor, auto value) {
-        initShortcut(QString::fromUtf8(name.untranslatedText()).arg(value),
-                     name.subs(value).toString(),
-                     key,
-                     functor,
-                     value);
-    };
-
-    auto def6 = [this](auto name, auto key, auto target, auto functor) {
-        initShortcut(
-            QString::fromUtf8(name.untranslatedText()), name.toString(), key, target, functor);
-    };
-
-    def(kli18n("Window Operations Menu"),
-        Qt::ALT + Qt::Key_F3,
-        active_window_show_operations_popup<space>);
-    def2("Window Close", kli18n("Close Window"), Qt::ALT + Qt::Key_F4, active_window_close<space>);
-    def2("Window Maximize",
-         kli18n("Maximize Window"),
-         Qt::META + Qt::Key_PageUp,
-         active_window_maximize<space>);
-    def2("Window Maximize Vertical",
-         kli18n("Maximize Window Vertically"),
-         0,
-         active_window_maximize_vertical<space>);
-    def2("Window Maximize Horizontal",
-         kli18n("Maximize Window Horizontally"),
-         0,
-         active_window_maximize_horizontal<space>);
-    def2("Window Minimize",
-         kli18n("Minimize Window"),
-         Qt::META + Qt::Key_PageDown,
-         active_window_minimize<space>);
-    def2("Window Move", kli18n("Move Window"), 0, active_window_move<space>);
-    def2("Window Resize", kli18n("Resize Window"), 0, active_window_resize<space>);
-    def2("Window Raise", kli18n("Raise Window"), 0, active_window_raise<space>);
-    def2("Window Lower", kli18n("Lower Window"), 0, active_window_lower<space>);
-    def(kli18n("Toggle Window Raise/Lower"), 0, active_window_raise_or_lower<space>);
-    def2("Window Fullscreen",
-         kli18n("Make Window Fullscreen"),
-         0,
-         active_window_set_fullscreen<space>);
-    def2("Window No Border", kli18n("Hide Window Border"), 0, active_window_set_no_border<space>);
-    def2("Window Above Other Windows",
-         kli18n("Keep Window Above Others"),
-         0,
-         active_window_set_keep_above<space>);
-    def2("Window Below Other Windows",
-         kli18n("Keep Window Below Others"),
-         0,
-         active_window_set_keep_below<space>);
-    def(kli18n("Activate Window Demanding Attention"),
-        Qt::META | Qt::CTRL | Qt::Key_A,
-        activate_attention_window<space>);
-    def(kli18n("Setup Window Shortcut"), 0, active_window_setup_window_shortcut<space>);
-    def2("Window Pack Right",
-         kli18n("Pack Window to the Right"),
-         0,
-         active_window_pack_right<space>);
-    def2("Window Pack Left", kli18n("Pack Window to the Left"), 0, active_window_pack_left<space>);
-    def2("Window Pack Up", kli18n("Pack Window Up"), 0, active_window_pack_up<space>);
-    def2("Window Pack Down", kli18n("Pack Window Down"), 0, active_window_pack_down<space>);
-    def2("Window Grow Horizontal",
-         kli18n("Pack Grow Window Horizontally"),
-         0,
-         active_window_grow_horizontal<space>);
-    def2("Window Grow Vertical",
-         kli18n("Pack Grow Window Vertically"),
-         0,
-         active_window_grow_vertical<space>);
-    def2("Window Shrink Horizontal",
-         kli18n("Pack Shrink Window Horizontally"),
-         0,
-         active_window_shrink_horizontal<space>);
-    def2("Window Shrink Vertical",
-         kli18n("Pack Shrink Window Vertically"),
-         0,
-         active_window_shrink_vertical<space>);
-    def4("Window Quick Tile Left",
-         kli18n("Quick Tile Window to the Left"),
-         Qt::META + Qt::Key_Left,
-         std::bind(&space::quickTileWindow, this, win::quicktiles::left));
-    def4("Window Quick Tile Right",
-         kli18n("Quick Tile Window to the Right"),
-         Qt::META + Qt::Key_Right,
-         std::bind(&space::quickTileWindow, this, win::quicktiles::right));
-    def4("Window Quick Tile Top",
-         kli18n("Quick Tile Window to the Top"),
-         Qt::META + Qt::Key_Up,
-         std::bind(&space::quickTileWindow, this, win::quicktiles::top));
-    def4("Window Quick Tile Bottom",
-         kli18n("Quick Tile Window to the Bottom"),
-         Qt::META + Qt::Key_Down,
-         std::bind(&space::quickTileWindow, this, win::quicktiles::bottom));
-    def4("Window Quick Tile Top Left",
-         kli18n("Quick Tile Window to the Top Left"),
-         0,
-         std::bind(&space::quickTileWindow, this, win::quicktiles::top | win::quicktiles::left));
-    def4("Window Quick Tile Bottom Left",
-         kli18n("Quick Tile Window to the Bottom Left"),
-         0,
-         std::bind(&space::quickTileWindow, this, win::quicktiles::bottom | win::quicktiles::left));
-    def4("Window Quick Tile Top Right",
-         kli18n("Quick Tile Window to the Top Right"),
-         0,
-         std::bind(&space::quickTileWindow, this, win::quicktiles::top | win::quicktiles::right));
-    def4(
-        "Window Quick Tile Bottom Right",
-        kli18n("Quick Tile Window to the Bottom Right"),
-        0,
-        std::bind(&space::quickTileWindow, this, win::quicktiles::bottom | win::quicktiles::right));
-    def4("Switch Window Up",
-         kli18n("Switch to Window Above"),
-         Qt::META + Qt::ALT + Qt::Key_Up,
-         std::bind(static_cast<void (space::*)(direction)>(&space::switchWindow),
-                   this,
-                   direction::north));
-    def4("Switch Window Down",
-         kli18n("Switch to Window Below"),
-         Qt::META + Qt::ALT + Qt::Key_Down,
-         std::bind(static_cast<void (space::*)(direction)>(&space::switchWindow),
-                   this,
-                   direction::south));
-    def4("Switch Window Right",
-         kli18n("Switch to Window to the Right"),
-         Qt::META + Qt::ALT + Qt::Key_Right,
-         std::bind(
-             static_cast<void (space::*)(direction)>(&space::switchWindow), this, direction::east));
-    def4("Switch Window Left",
-         kli18n("Switch to Window to the Left"),
-         Qt::META + Qt::ALT + Qt::Key_Left,
-         std::bind(
-             static_cast<void (space::*)(direction)>(&space::switchWindow), this, direction::west));
-    def2("Increase Opacity",
-         kli18n("Increase Opacity of Active Window by 5 %"),
-         0,
-         active_window_increase_opacity<space>);
-    def2("Decrease Opacity",
-         kli18n("Decrease Opacity of Active Window by 5 %"),
-         0,
-         active_window_lower_opacity<space>);
-
-    def2("Window On All Desktops",
-         kli18n("Keep Window on All Desktops"),
-         0,
-         active_window_set_on_all_desktops<space>);
-
-    for (int i = 1; i < 21; ++i) {
-        def5(
-            kli18n("Window to Desktop %1"),
-            0,
-            [this, i] { active_window_to_desktop(*this, i); },
-            i);
-    }
-
-    def(kli18n("Window to Next Desktop"), 0, active_window_to_next_desktop<space>);
-    def(kli18n("Window to Previous Desktop"), 0, active_window_to_prev_desktop<space>);
-    def(kli18n("Window One Desktop to the Right"), 0, active_window_to_right_desktop<space>);
-    def(kli18n("Window One Desktop to the Left"), 0, active_window_to_left_desktop<space>);
-    def(kli18n("Window One Desktop Up"), 0, active_window_to_above_desktop<space>);
-    def(kli18n("Window One Desktop Down"), 0, active_window_to_below_desktop<space>);
-
-    for (int i = 0; i < 8; ++i) {
-        def3(kli18n("Window to Screen %1"), 0, active_window_to_output<space>, i);
-    }
-    def(kli18n("Window to Next Screen"), 0, active_window_to_next_output<space>);
-    def(kli18n("Window to Previous Screen"), 0, active_window_to_prev_output<space>);
-    def(kli18n("Show Desktop"), Qt::META + Qt::Key_D, toggle_show_desktop<space>);
-
-    for (int i = 0; i < 8; ++i) {
-        def3(kli18n("Switch to Screen %1"), 0, switch_to_output<space>, i);
-    }
-
-    def(kli18n("Switch to Next Screen"), 0, switch_to_next_output<space>);
-    def(kli18n("Switch to Previous Screen"), 0, switch_to_prev_output<space>);
-
-    def(kli18n("Kill Window"), Qt::META | Qt::CTRL | Qt::Key_Escape, start_window_killer<space>);
-    def6(kli18n("Suspend Compositing"),
-         Qt::SHIFT + Qt::ALT + Qt::Key_F12,
-         &render,
-         [render = &render] { render->toggleCompositing(); });
-    def6(kli18n("Invert Screen Colors"), 0, &render, [render = &render] {
-        render->platform.invertScreen();
-    });
-
-#if KWIN_BUILD_TABBOX
-    tabbox->init_shortcuts();
-#endif
-    virtual_desktop_manager->initShortcuts();
-    kwinApp()->get_base().render->night_color->init_shortcuts();
-
-    // so that it's recreated next time
-    user_actions_menu->discard();
-}
-
-void space::setupWindowShortcut(Toplevel* window)
-{
-    Q_ASSERT(client_keys_dialog == nullptr);
-    // TODO: PORT ME (KGlobalAccel related)
-    // keys->setEnabled( false );
-    // disable_shortcuts_keys->setEnabled( false );
-    // client_keys->setEnabled( false );
-    client_keys_dialog = new win::shortcut_dialog(window->control->shortcut());
-    client_keys_client = window;
-
-    QObject::connect(client_keys_dialog,
-                     &win::shortcut_dialog::dialogDone,
-                     qobject.get(),
-                     [this](auto&& ok) { setupWindowShortcutDone(ok); });
-
-    auto area = space_window_area(*this, ScreenArea, window);
-    auto size = client_keys_dialog->sizeHint();
-
-    auto pos = win::frame_to_client_pos(window, window->pos());
-    if (pos.x() + size.width() >= area.right()) {
-        pos.setX(area.right() - size.width());
-    }
-    if (pos.y() + size.height() >= area.bottom()) {
-        pos.setY(area.bottom() - size.height());
-    }
-
-    client_keys_dialog->move(pos);
-    client_keys_dialog->show();
-    active_popup = client_keys_dialog;
-    active_popup_client = window;
-}
-
-void space::setupWindowShortcutDone(bool ok)
-{
-    //    keys->setEnabled( true );
-    //    disable_shortcuts_keys->setEnabled( true );
-    //    client_keys->setEnabled( true );
-    if (ok)
-        win::set_shortcut(client_keys_client, client_keys_dialog->shortcut().toString());
-    close_active_popup(*this);
-    client_keys_dialog->deleteLater();
-    client_keys_dialog = nullptr;
-    client_keys_client = nullptr;
-    if (active_client)
-        active_client->takeFocus();
-}
-
-void space::clientShortcutUpdated(Toplevel* window)
-{
-    QString key = QStringLiteral("_k_session:%1").arg(window->xcb_window);
-    auto action = qobject->findChild<QAction*>(key);
-    if (!window->control->shortcut().isEmpty()) {
-        if (action == nullptr) { // new shortcut
-            action = new QAction(qobject.get());
-            kwinApp()->input->setup_action_for_global_accel(action);
-            action->setProperty("componentName", QStringLiteral(KWIN_NAME));
-            action->setObjectName(key);
-            action->setText(i18n("Activate Window (%1)", win::caption(window)));
-            QObject::connect(action, &QAction::triggered, window, [this, window] {
-                force_activate_window(*this, window);
-            });
-        }
-
-        // no autoloading, since it's configured explicitly here and is not meant to be reused
-        // (the key is the window id anyway, which is kind of random)
-        KGlobalAccel::self()->setShortcut(action,
-                                          QList<QKeySequence>() << window->control->shortcut(),
-                                          KGlobalAccel::NoAutoloading);
-        action->setEnabled(true);
-    } else {
-        KGlobalAccel::self()->removeAllShortcuts(action);
-        delete action;
-    }
-}
-
 /**
  * Switches to the nearest window in given direction.
  */
@@ -1867,29 +1506,4 @@ bool space::switchWindow(Toplevel* c, win::direction direction, QPoint curPos, i
     return switchTo;
 }
 
-bool space::shortcutAvailable(const QKeySequence& cut, Toplevel* ignore) const
-{
-    if (ignore && cut == ignore->control->shortcut())
-        return true;
-
-    // Check if the shortcut is already registered.
-    auto const registeredShortcuts = KGlobalAccel::globalShortcutsByKey(cut);
-    for (auto const& shortcut : registeredShortcuts) {
-        // Only return "not available" if is not a client activation shortcut, as it may be no
-        // longer valid.
-        if (!shortcut.uniqueName().startsWith(QStringLiteral("_k_session:"))) {
-            return false;
-        }
-    }
-
-    // Check now conflicts with activation shortcuts for current clients.
-    for (auto const win : m_windows) {
-        if (win != ignore && win->control && win->control->shortcut() == cut) {
-            return false;
-        }
-    }
-
-    return true;
-}
-
 }
diff --git a/win/space.h b/win/space.h
index 02c2558e5..61e46826c 100644
--- a/win/space.h
+++ b/win/space.h
@@ -237,7 +237,6 @@ public:
      */
     virtual Toplevel* findInternal(QWindow* w) const = 0;
 
-    void initShortcuts();
     bool initializing() const;
 
     bool allowClientActivation(Toplevel const* window,
@@ -306,8 +305,6 @@ public:
 
     bool checkStartupNotification(xcb_window_t w, KStartupInfoId& id, KStartupInfoData& data);
 
-    void clientShortcutUpdated(Toplevel* window);
-    bool shortcutAvailable(const QKeySequence& cut, Toplevel* ignore = nullptr) const;
     bool globalShortcutsDisabled() const;
     void disableGlobalShortcutsForClient(bool disable);
 
@@ -350,33 +347,10 @@ public:
     void saveOldScreenSizes();
     void desktopResized();
 
-    void setupWindowShortcutDone(bool);
-
     virtual void update_space_area_from_windows(QRect const& desktop_area,
                                                 std::vector<QRect> const& screens_geos,
                                                 win::space_areas& areas);
 
-    template<typename Slot>
-    void initShortcut(const QString& actionName,
-                      const QString& description,
-                      const QKeySequence& shortcut,
-                      Slot slot,
-                      const QVariant& data = QVariant());
-    template<typename T, typename Slot>
-    void initShortcut(const QString& actionName,
-                      const QString& description,
-                      const QKeySequence& shortcut,
-                      T* receiver,
-                      Slot slot,
-                      const QVariant& data = QVariant());
-    template<typename T, typename Slot>
-    void init_shortcut_with_action_arg(const QString& actionName,
-                                       const QString& description,
-                                       const QKeySequence& shortcut,
-                                       T* receiver,
-                                       Slot slot,
-                                       QVariant const& data);
-    void setupWindowShortcut(Toplevel* window);
     bool switchWindow(Toplevel* c, win::direction direction, QPoint curPos, int desktop);
 
     QWidget* active_popup{nullptr};
diff --git a/win/user_actions_menu.h b/win/user_actions_menu.h
index 5cded121a..79f271f87 100644
--- a/win/user_actions_menu.h
+++ b/win/user_actions_menu.h
@@ -38,6 +38,9 @@
 namespace KWin::win
 {
 
+template<typename Space>
+void perform_window_operation(Space& space, Toplevel* window, base::options::WindowOperation op);
+
 struct user_actions_menu_desktop_action_data {
     uint desktop;
     bool move_to_single;
diff --git a/win/wayland/space.cpp b/win/wayland/space.cpp
index c3bf6ea18..9d361074c 100644
--- a/win/wayland/space.cpp
+++ b/win/wayland/space.cpp
@@ -286,7 +286,7 @@ void space::handle_window_removed(wayland::window* window)
             last_active_client = nullptr;
         }
         if (window == client_keys_client) {
-            setupWindowShortcutDone(false);
+            setup_window_shortcut_done(*this, false);
         }
         if (!window->control->shortcut().isEmpty()) {
             // Remove from client_keys.
diff --git a/win/window_operation.h b/win/window_operation.h
index 800f7a2ab..0350152b4 100644
--- a/win/window_operation.h
+++ b/win/window_operation.h
@@ -9,6 +9,7 @@
 #include "desktop_set.h"
 #include "move.h"
 #include "rules/rule_book.h"
+#include "shortcut_set.h"
 #include "stacking.h"
 
 #include "input/cursor.h"
@@ -99,7 +100,7 @@ void perform_window_operation(Space& space, Toplevel* window, base::options::Win
         space.rule_book->edit(window, true);
         break;
     case base::options::SetupWindowShortcutOp:
-        space.setupWindowShortcut(window);
+        setup_window_shortcut(space, window);
         break;
     case base::options::LowerOp:
         lower_window(&space, window);
diff --git a/win/x11/window.cpp b/win/x11/window.cpp
index aa678358d..24047fa18 100644
--- a/win/x11/window.cpp
+++ b/win/x11/window.cpp
@@ -27,6 +27,7 @@
 #include "win/deco/window.h"
 #include "win/layers.h"
 #include "win/remnant.h"
+#include "win/shortcut_set.h"
 #include "win/space_areas_helpers.h"
 #include "win/stacking.h"
 #include "win/stacking_order.h"
@@ -602,12 +603,12 @@ void window::setShortcutInternal()
 {
     updateCaption();
 #if 0
-    space.clientShortcutUpdated(this);
+    window_shortcut_updated(space, this);
 #else
     // Workaround for kwin<->kglobalaccel deadlock, when KWin has X grab and the kded
     // kglobalaccel module tries to create the key grab. KWin should preferably grab
     // they keys itself anyway :(.
-    QTimer::singleShot(0, this, std::bind(&space::clientShortcutUpdated, &space, this));
+    QTimer::singleShot(0, this, [this] { window_shortcut_updated(space, this); });
 #endif
 }
 
diff --git a/win/x11/window_release.h b/win/x11/window_release.h
index 93181e840..5932e2498 100644
--- a/win/x11/window_release.h
+++ b/win/x11/window_release.h
@@ -10,6 +10,7 @@
 #include "utils/blocker.h"
 #include "win/input.h"
 #include "win/rules.h"
+#include "win/shortcut_set.h"
 #include "win/space_areas_helpers.h"
 #include "win/window_release.h"
 
@@ -32,14 +33,14 @@ void remove_controlled_window_from_space(Space& space, Win* win)
     }
 
     if (space.client_keys_client == win) {
-        space.setupWindowShortcutDone(false);
+        setup_window_shortcut_done(space, false);
     }
     if (!win->control->shortcut().isEmpty()) {
         // Remove from client_keys.
         set_shortcut(win, QString());
 
         // Needed, since this is otherwise delayed by setShortcut() and wouldn't run
-        space.clientShortcutUpdated(win);
+        window_shortcut_updated(space, win);
     }
 
     assert(contains(space.m_windows, win));
-- 
GitLab


From 5e99c40f53a0709e93e1638747b9bb2f5cef350a Mon Sep 17 00:00:00 2001
From: Roman Gilg <subdiff@gmail.com>
Date: Sat, 9 Jul 2022 11:29:30 +0200
Subject: [PATCH 20/51] refactor: reimplement space switch window functions as
 free functions

This way they can be reused by different types of spaces.
---
 autotests/integration/activation_test.cpp |  44 +++++-----
 scripting/space.h                         |  30 ++++---
 win/activation.h                          | 101 ++++++++++++++++++++++
 win/shortcuts_init.h                      |  16 +---
 win/space.cpp                             |  91 -------------------
 win/space.h                               |   4 -
 6 files changed, 144 insertions(+), 142 deletions(-)

diff --git a/autotests/integration/activation_test.cpp b/autotests/integration/activation_test.cpp
index 3f3ec3e07..bed16228b 100644
--- a/autotests/integration/activation_test.cpp
+++ b/autotests/integration/activation_test.cpp
@@ -123,19 +123,19 @@ void ActivationTest::testSwitchToWindowToLeft()
     win::move(client4, QPoint(1580, 200));
 
     // Switch to window to the left.
-    Test::app()->workspace->switchWindow(win::direction::west);
+    win::activate_window_direction(*Test::app()->workspace, win::direction::west);
     QVERIFY(client3->control->active());
 
     // Switch to window to the left.
-    Test::app()->workspace->switchWindow(win::direction::west);
+    win::activate_window_direction(*Test::app()->workspace, win::direction::west);
     QVERIFY(client2->control->active());
 
     // Switch to window to the left.
-    Test::app()->workspace->switchWindow(win::direction::west);
+    win::activate_window_direction(*Test::app()->workspace, win::direction::west);
     QVERIFY(client1->control->active());
 
     // Switch to window to the left.
-    Test::app()->workspace->switchWindow(win::direction::west);
+    win::activate_window_direction(*Test::app()->workspace, win::direction::west);
     QVERIFY(client4->control->active());
 
     // Destroy all clients.
@@ -191,19 +191,19 @@ void ActivationTest::testSwitchToWindowToRight()
     win::move(client4, QPoint(1580, 200));
 
     // Switch to window to the right.
-    Test::app()->workspace->switchWindow(win::direction::east);
+    win::activate_window_direction(*Test::app()->workspace, win::direction::east);
     QVERIFY(client1->control->active());
 
     // Switch to window to the right.
-    Test::app()->workspace->switchWindow(win::direction::east);
+    win::activate_window_direction(*Test::app()->workspace, win::direction::east);
     QVERIFY(client2->control->active());
 
     // Switch to window to the right.
-    Test::app()->workspace->switchWindow(win::direction::east);
+    win::activate_window_direction(*Test::app()->workspace, win::direction::east);
     QVERIFY(client3->control->active());
 
     // Switch to window to the right.
-    Test::app()->workspace->switchWindow(win::direction::east);
+    win::activate_window_direction(*Test::app()->workspace, win::direction::east);
     QVERIFY(client4->control->active());
 
     // Destroy all clients.
@@ -259,19 +259,19 @@ void ActivationTest::testSwitchToWindowAbove()
     win::move(client4, QPoint(200, 1424));
 
     // Switch to window above.
-    Test::app()->workspace->switchWindow(win::direction::north);
+    win::activate_window_direction(*Test::app()->workspace, win::direction::north);
     QVERIFY(client3->control->active());
 
     // Switch to window above.
-    Test::app()->workspace->switchWindow(win::direction::north);
+    win::activate_window_direction(*Test::app()->workspace, win::direction::north);
     QVERIFY(client2->control->active());
 
     // Switch to window above.
-    Test::app()->workspace->switchWindow(win::direction::north);
+    win::activate_window_direction(*Test::app()->workspace, win::direction::north);
     QVERIFY(client1->control->active());
 
     // Switch to window above.
-    Test::app()->workspace->switchWindow(win::direction::north);
+    win::activate_window_direction(*Test::app()->workspace, win::direction::north);
     QVERIFY(client4->control->active());
 
     // Destroy all clients.
@@ -327,19 +327,19 @@ void ActivationTest::testSwitchToWindowBelow()
     win::move(client4, QPoint(200, 1424));
 
     // Switch to window below.
-    Test::app()->workspace->switchWindow(win::direction::south);
+    win::activate_window_direction(*Test::app()->workspace, win::direction::south);
     QVERIFY(client1->control->active());
 
     // Switch to window below.
-    Test::app()->workspace->switchWindow(win::direction::south);
+    win::activate_window_direction(*Test::app()->workspace, win::direction::south);
     QVERIFY(client2->control->active());
 
     // Switch to window below.
-    Test::app()->workspace->switchWindow(win::direction::south);
+    win::activate_window_direction(*Test::app()->workspace, win::direction::south);
     QVERIFY(client3->control->active());
 
     // Switch to window below.
-    Test::app()->workspace->switchWindow(win::direction::south);
+    win::activate_window_direction(*Test::app()->workspace, win::direction::south);
     QVERIFY(client4->control->active());
 
     // Destroy all clients.
@@ -417,15 +417,15 @@ void ActivationTest::testSwitchToWindowMaximized()
     win::move(client4, QPoint(1580, 200));
 
     // Switch to window to the left.
-    Test::app()->workspace->switchWindow(win::direction::west);
+    win::activate_window_direction(*Test::app()->workspace, win::direction::west);
     QVERIFY(client3->control->active());
 
     // Switch to window to the left.
-    Test::app()->workspace->switchWindow(win::direction::west);
+    win::activate_window_direction(*Test::app()->workspace, win::direction::west);
     QVERIFY(client2->control->active());
 
     // Switch to window to the left.
-    Test::app()->workspace->switchWindow(win::direction::west);
+    win::activate_window_direction(*Test::app()->workspace, win::direction::west);
     QVERIFY(client4->control->active());
 
     // Destroy all clients.
@@ -502,15 +502,15 @@ void ActivationTest::testSwitchToWindowFullScreen()
     win::move(client4, QPoint(200, 1424));
 
     // Switch to window above.
-    Test::app()->workspace->switchWindow(win::direction::north);
+    win::activate_window_direction(*Test::app()->workspace, win::direction::north);
     QVERIFY(client3->control->active());
 
     // Switch to window above.
-    Test::app()->workspace->switchWindow(win::direction::north);
+    win::activate_window_direction(*Test::app()->workspace, win::direction::north);
     QVERIFY(client2->control->active());
 
     // Switch to window above.
-    Test::app()->workspace->switchWindow(win::direction::north);
+    win::activate_window_direction(*Test::app()->workspace, win::direction::north);
     QVERIFY(client4->control->active());
 
     // Destroy all clients.
diff --git a/scripting/space.h b/scripting/space.h
index fc20d6a31..b29fda213 100644
--- a/scripting/space.h
+++ b/scripting/space.h
@@ -348,7 +348,6 @@ public Q_SLOTS:
     virtual void slotWindowToDesktopDown() = 0;
 
 #undef QUICKTILE_SLOT
-#undef SWITCH_WINDOW_SLOT
 #undef SWITCH_VD_SLOT
 
     /**
@@ -685,12 +684,6 @@ public:
         ref_space->quickTileWindow(modes);                                                         \
     }
 
-#define SWITCH_WINDOW_SLOT(name, dir)                                                              \
-    void name() override                                                                           \
-    {                                                                                              \
-        ref_space->switchWindow(win::direction::dir);                                              \
-    }
-
     void slotSwitchToNextScreen() override
     {
         win::switch_to_next_output(*ref_space);
@@ -880,13 +873,24 @@ public:
     QUICKTILE_SLOT(slotWindowQuickTileBottomLeft, win::quicktiles::bottom | win::quicktiles::left)
     QUICKTILE_SLOT(slotWindowQuickTileBottomRight, win::quicktiles::bottom | win::quicktiles::right)
 
-    SWITCH_WINDOW_SLOT(slotSwitchWindowUp, north)
-    SWITCH_WINDOW_SLOT(slotSwitchWindowDown, south)
-    SWITCH_WINDOW_SLOT(slotSwitchWindowRight, east)
-    SWITCH_WINDOW_SLOT(slotSwitchWindowLeft, west)
-
 #undef QUICKTILE_SLOT
-#undef SWITCH_WINDOW_SLOT
+
+    void slotSwitchWindowUp() override
+    {
+        win::activate_window_direction(*ref_space, win::direction::north);
+    }
+    void slotSwitchWindowDown() override
+    {
+        win::activate_window_direction(*ref_space, win::direction::south);
+    }
+    void slotSwitchWindowRight() override
+    {
+        win::activate_window_direction(*ref_space, win::direction::east);
+    }
+    void slotSwitchWindowLeft() override
+    {
+        win::activate_window_direction(*ref_space, win::direction::west);
+    }
 
 protected:
     QRect client_area_impl(clientAreaOption option, int screen, int desktop) const override
diff --git a/win/activation.h b/win/activation.h
index f1a1d0a77..d8fe953f3 100644
--- a/win/activation.h
+++ b/win/activation.h
@@ -656,6 +656,107 @@ void activate_window_on_new_desktop(Space& space, unsigned int desktop)
     }
 }
 
+template<typename Space>
+bool activate_window_direction(Space& space,
+                               Toplevel* c,
+                               win::direction direction,
+                               QPoint curPos,
+                               int d)
+{
+    Toplevel* switchTo = nullptr;
+    int bestScore = 0;
+    auto clist = space.stacking_order->stack;
+
+    for (auto i = clist.rbegin(); i != clist.rend(); ++i) {
+        auto client = *i;
+        if (!client->control) {
+            continue;
+        }
+
+        if (wants_tab_focus(client) && *i != c && client->isOnDesktop(d)
+            && !client->control->minimized()) {
+            // Centre of the other window
+            const QPoint other(client->pos().x() + client->size().width() / 2,
+                               client->pos().y() + client->size().height() / 2);
+
+            int distance;
+            int offset;
+            switch (direction) {
+            case direction::north:
+                distance = curPos.y() - other.y();
+                offset = qAbs(other.x() - curPos.x());
+                break;
+            case direction::east:
+                distance = other.x() - curPos.x();
+                offset = qAbs(other.y() - curPos.y());
+                break;
+            case direction::south:
+                distance = other.y() - curPos.y();
+                offset = qAbs(other.x() - curPos.x());
+                break;
+            case direction::west:
+                distance = curPos.x() - other.x();
+                offset = qAbs(other.y() - curPos.y());
+                break;
+            default:
+                distance = -1;
+                offset = -1;
+            }
+
+            if (distance > 0) {
+                // Inverse score
+                int score = distance + offset + ((offset * offset) / distance);
+                if (score < bestScore || !switchTo) {
+                    switchTo = client;
+                    bestScore = score;
+                }
+            }
+        }
+    }
+    if (switchTo) {
+        activate_window(space, switchTo);
+    }
+
+    return switchTo;
+}
+
+/**
+ * Switches to the nearest window in given direction.
+ */
+template<typename Space>
+void activate_window_direction(Space& space, win::direction direction)
+{
+    if (!space.active_client) {
+        return;
+    }
+
+    auto c = space.active_client;
+    int desktopNumber
+        = c->isOnAllDesktops() ? space.virtual_desktop_manager->current() : c->desktop();
+
+    // Centre of the active window
+    QPoint curPos(c->pos().x() + c->size().width() / 2, c->pos().y() + c->size().height() / 2);
+
+    if (!activate_window_direction(space, c, direction, curPos, desktopNumber)) {
+        auto opposite = [&] {
+            switch (direction) {
+            case direction::north:
+                return QPoint(curPos.x(), kwinApp()->get_base().topology.size.height());
+            case direction::south:
+                return QPoint(curPos.x(), 0);
+            case direction::east:
+                return QPoint(0, curPos.y());
+            case direction::west:
+                return QPoint(kwinApp()->get_base().topology.size.width(), curPos.y());
+            default:
+                Q_UNREACHABLE();
+            }
+        };
+
+        activate_window_direction(space, c, direction, opposite(), desktopNumber);
+    }
+}
+
 template<typename Space>
 void delay_focus(Space& space)
 {
diff --git a/win/shortcuts_init.h b/win/shortcuts_init.h
index f9234feed..b76ada7ca 100644
--- a/win/shortcuts_init.h
+++ b/win/shortcuts_init.h
@@ -243,27 +243,19 @@ void init_shortcuts(Space& space)
     def4("Switch Window Up",
          kli18n("Switch to Window Above"),
          Qt::META + Qt::ALT + Qt::Key_Up,
-         std::bind(static_cast<void (Space::*)(direction)>(&Space::switchWindow),
-                   &space,
-                   direction::north));
+         [&space] { activate_window_direction(space, direction::north); });
     def4("Switch Window Down",
          kli18n("Switch to Window Below"),
          Qt::META + Qt::ALT + Qt::Key_Down,
-         std::bind(static_cast<void (Space::*)(direction)>(&Space::switchWindow),
-                   &space,
-                   direction::south));
+         [&space] { activate_window_direction(space, direction::south); });
     def4("Switch Window Right",
          kli18n("Switch to Window to the Right"),
          Qt::META + Qt::ALT + Qt::Key_Right,
-         std::bind(static_cast<void (Space::*)(direction)>(&Space::switchWindow),
-                   &space,
-                   direction::east));
+         [&space] { activate_window_direction(space, direction::east); });
     def4("Switch Window Left",
          kli18n("Switch to Window to the Left"),
          Qt::META + Qt::ALT + Qt::Key_Left,
-         std::bind(static_cast<void (Space::*)(direction)>(&Space::switchWindow),
-                   &space,
-                   direction::west));
+         [&space] { activate_window_direction(space, direction::west); });
     def2("Increase Opacity",
          kli18n("Increase Opacity of Active Window by 5 %"),
          0,
diff --git a/win/space.cpp b/win/space.cpp
index f854077c0..ff7cd512e 100644
--- a/win/space.cpp
+++ b/win/space.cpp
@@ -1415,95 +1415,4 @@ bool space::workspaceEvent(QEvent* e)
     return false;
 }
 
-/**
- * Switches to the nearest window in given direction.
- */
-void space::switchWindow(win::direction direction)
-{
-    if (!active_client)
-        return;
-    auto c = active_client;
-    int desktopNumber = c->isOnAllDesktops() ? virtual_desktop_manager->current() : c->desktop();
-
-    // Centre of the active window
-    QPoint curPos(c->pos().x() + c->size().width() / 2, c->pos().y() + c->size().height() / 2);
-
-    if (!switchWindow(c, direction, curPos, desktopNumber)) {
-        auto opposite = [&] {
-            switch (direction) {
-            case direction::north:
-                return QPoint(curPos.x(), kwinApp()->get_base().topology.size.height());
-            case direction::south:
-                return QPoint(curPos.x(), 0);
-            case direction::east:
-                return QPoint(0, curPos.y());
-            case direction::west:
-                return QPoint(kwinApp()->get_base().topology.size.width(), curPos.y());
-            default:
-                Q_UNREACHABLE();
-            }
-        };
-
-        switchWindow(c, direction, opposite(), desktopNumber);
-    }
-}
-
-bool space::switchWindow(Toplevel* c, win::direction direction, QPoint curPos, int d)
-{
-    Toplevel* switchTo = nullptr;
-    int bestScore = 0;
-
-    auto clist = stacking_order->stack;
-    for (auto i = clist.rbegin(); i != clist.rend(); ++i) {
-        auto client = *i;
-        if (!client->control) {
-            continue;
-        }
-        if (win::wants_tab_focus(client) && *i != c && client->isOnDesktop(d)
-            && !client->control->minimized()) {
-            // Centre of the other window
-            const QPoint other(client->pos().x() + client->size().width() / 2,
-                               client->pos().y() + client->size().height() / 2);
-
-            int distance;
-            int offset;
-            switch (direction) {
-            case direction::north:
-                distance = curPos.y() - other.y();
-                offset = qAbs(other.x() - curPos.x());
-                break;
-            case direction::east:
-                distance = other.x() - curPos.x();
-                offset = qAbs(other.y() - curPos.y());
-                break;
-            case direction::south:
-                distance = other.y() - curPos.y();
-                offset = qAbs(other.x() - curPos.x());
-                break;
-            case direction::west:
-                distance = curPos.x() - other.x();
-                offset = qAbs(other.y() - curPos.y());
-                break;
-            default:
-                distance = -1;
-                offset = -1;
-            }
-
-            if (distance > 0) {
-                // Inverse score
-                int score = distance + offset + ((offset * offset) / distance);
-                if (score < bestScore || !switchTo) {
-                    switchTo = client;
-                    bestScore = score;
-                }
-            }
-        }
-    }
-    if (switchTo) {
-        activate_window(*this, switchTo);
-    }
-
-    return switchTo;
-}
-
 }
diff --git a/win/space.h b/win/space.h
index 61e46826c..eaeb49e59 100644
--- a/win/space.h
+++ b/win/space.h
@@ -333,8 +333,6 @@ public:
 
     void quickTileWindow(win::quicktiles mode);
 
-    void switchWindow(win::direction direction);
-
     win::shortcut_dialog* shortcutDialog() const
     {
         return client_keys_dialog;
@@ -351,8 +349,6 @@ public:
                                                 std::vector<QRect> const& screens_geos,
                                                 win::space_areas& areas);
 
-    bool switchWindow(Toplevel* c, win::direction direction, QPoint curPos, int desktop);
-
     QWidget* active_popup{nullptr};
 
     std::vector<win::session_info*> session;
-- 
GitLab


From 38052c70b3f7d19638b8dfb8b6a41ada04670855 Mon Sep 17 00:00:00 2001
From: Roman Gilg <subdiff@gmail.com>
Date: Sun, 10 Jul 2022 12:20:08 +0200
Subject: [PATCH 21/51] refactor: split up move header

Split out the quicktile and geometry checker functions to separate headers.
---
 win/geo_restrict.h | 332 ++++++++++++++++++++++++++
 win/move.h         | 580 +--------------------------------------------
 win/quicktile.h    | 285 ++++++++++++++++++++++
 3 files changed, 618 insertions(+), 579 deletions(-)
 create mode 100644 win/geo_restrict.h
 create mode 100644 win/quicktile.h

diff --git a/win/geo_restrict.h b/win/geo_restrict.h
new file mode 100644
index 000000000..fa5b4f257
--- /dev/null
+++ b/win/geo_restrict.h
@@ -0,0 +1,332 @@
+/*
+    SPDX-FileCopyrightText: 2022 Roman Gilg <subdiff@gmail.com>
+
+    SPDX-License-Identifier: GPL-2.0-or-later
+*/
+#pragma once
+
+#include "deco.h"
+#include "geo.h"
+#include "window_area.h"
+
+namespace KWin::win
+{
+
+inline void check_offscreen_position(QRect& frame_geo, const QRect& screenArea)
+{
+    if (frame_geo.left() > screenArea.right()) {
+        frame_geo.moveLeft(screenArea.right() - screenArea.width() / 4);
+    } else if (frame_geo.right() < screenArea.left()) {
+        frame_geo.moveRight(screenArea.left() + screenArea.width() / 4);
+    }
+    if (frame_geo.top() > screenArea.bottom()) {
+        frame_geo.moveTop(screenArea.bottom() - screenArea.height() / 4);
+    } else if (frame_geo.bottom() < screenArea.top()) {
+        frame_geo.moveBottom(screenArea.top() + screenArea.height() / 4);
+    }
+}
+
+template<typename Win>
+void check_workspace_position(Win* win,
+                              QRect old_frame_geo = QRect(),
+                              int oldDesktop = -2,
+                              QRect old_client_geo = QRect())
+{
+    assert(win->control);
+
+    if (is_desktop(win)) {
+        return;
+    }
+    if (is_dock(win)) {
+        return;
+    }
+    if (is_notification(win) || is_on_screen_display(win)) {
+        return;
+    }
+
+    if (kwinApp()->get_base().get_outputs().empty()) {
+        return;
+    }
+
+    if (win->geometry_update.fullscreen) {
+        auto area = space_window_area(win->space, FullScreenArea, win);
+        win->setFrameGeometry(area);
+        return;
+    }
+
+    if (win->maximizeMode() != maximize_mode::restore) {
+        geometry_updates_blocker block(win);
+
+        win->update_maximized(win->geometry_update.max_mode);
+        auto const screenArea = space_window_area(win->space, ScreenArea, win);
+
+        auto geo = pending_frame_geometry(win);
+        check_offscreen_position(geo, screenArea);
+        win->setFrameGeometry(geo);
+
+        return;
+    }
+
+    if (win->control->quicktiling() != quicktiles::none) {
+        win->setFrameGeometry(electric_border_maximize_geometry(
+            win, pending_frame_geometry(win).center(), win->desktop()));
+        return;
+    }
+
+    enum {
+        Left = 0,
+        Top,
+        Right,
+        Bottom,
+    };
+    int const border[4] = {
+        left_border(win),
+        top_border(win),
+        right_border(win),
+        bottom_border(win),
+    };
+
+    if (!old_frame_geo.isValid()) {
+        old_frame_geo = pending_frame_geometry(win);
+    }
+    if (oldDesktop == -2) {
+        oldDesktop = win->desktop();
+    }
+    if (!old_client_geo.isValid()) {
+        old_client_geo
+            = old_frame_geo.adjusted(border[Left], border[Top], -border[Right], -border[Bottom]);
+    }
+
+    // If the window was touching an edge before but not now move it so it is again.
+    // Old and new maximums have different starting values so windows on the screen
+    // edge will move when a new strut is placed on the edge.
+    QRect old_screen_area;
+    if (in_update_window_area(win->space)) {
+        // we need to find the screen area as it was before the change
+        old_screen_area
+            = QRect(0, 0, win->space.olddisplaysize.width(), win->space.olddisplaysize.height());
+        int distance = INT_MAX;
+        for (auto const& r : win->space.oldscreensizes) {
+            int d = r.contains(old_frame_geo.center())
+                ? 0
+                : (r.center() - old_frame_geo.center()).manhattanLength();
+            if (d < distance) {
+                distance = d;
+                old_screen_area = r;
+            }
+        }
+    } else {
+        old_screen_area
+            = space_window_area(win->space, ScreenArea, old_frame_geo.center(), oldDesktop);
+    }
+
+    // With full screen height.
+    auto const old_tall_frame_geo = QRect(
+        old_frame_geo.x(), old_screen_area.y(), old_frame_geo.width(), old_screen_area.height());
+
+    // With full screen width.
+    auto const old_wide_frame_geo = QRect(
+        old_screen_area.x(), old_frame_geo.y(), old_screen_area.width(), old_frame_geo.height());
+
+    auto old_top_max = old_screen_area.y();
+    auto old_right_max = old_screen_area.x() + old_screen_area.width();
+    auto old_bottom_max = old_screen_area.y() + old_screen_area.height();
+    auto old_left_max = old_screen_area.x();
+
+    auto const screenArea = space_window_area(
+        win->space, ScreenArea, pending_frame_geometry(win).center(), win->desktop());
+
+    auto top_max = screenArea.y();
+    auto right_max = screenArea.x() + screenArea.width();
+    auto bottom_max = screenArea.y() + screenArea.height();
+    auto left_max = screenArea.x();
+
+    auto frame_geo = pending_frame_geometry(win);
+    auto client_geo
+        = frame_geo.adjusted(border[Left], border[Top], -border[Right], -border[Bottom]);
+
+    // Full screen height
+    auto const tall_frame_geo
+        = QRect(frame_geo.x(), screenArea.y(), frame_geo.width(), screenArea.height());
+
+    // Full screen width
+    auto const wide_frame_geo
+        = QRect(screenArea.x(), frame_geo.y(), screenArea.width(), frame_geo.height());
+
+    // Get the max strut point for each side where the window is (E.g. Highest point for
+    // the bottom struts bounded by the window's left and right sides).
+
+    // Default is to use restrictedMoveArea. That's on active desktop or screen change.
+    auto move_area_func = win::restricted_move_area<decltype(win->space)>;
+    if (in_update_window_area(win->space)) {
+        // On restriected area changes.
+        // TODO(romangg): This check back on in_update_window_area and then setting here internally
+        //                a different function is bad design. Replace with an argument or something.
+        move_area_func = win::previous_restricted_move_area<decltype(win->space)>;
+    }
+
+    // These 4 compute old bounds.
+    for (auto const& r : move_area_func(win->space, oldDesktop, strut_area::top)) {
+        auto rect = r & old_tall_frame_geo;
+        if (!rect.isEmpty()) {
+            old_top_max = std::max(old_top_max, rect.y() + rect.height());
+        }
+    }
+    for (auto const& r : move_area_func(win->space, oldDesktop, strut_area::right)) {
+        auto rect = r & old_wide_frame_geo;
+        if (!rect.isEmpty()) {
+            old_right_max = std::min(old_right_max, rect.x());
+        }
+    }
+    for (auto const& r : move_area_func(win->space, oldDesktop, strut_area::bottom)) {
+        auto rect = r & old_tall_frame_geo;
+        if (!rect.isEmpty()) {
+            old_bottom_max = std::min(old_bottom_max, rect.y());
+        }
+    }
+    for (auto const& r : move_area_func(win->space, oldDesktop, strut_area::left)) {
+        auto rect = r & old_wide_frame_geo;
+        if (!rect.isEmpty()) {
+            old_left_max = std::max(old_left_max, rect.x() + rect.width());
+        }
+    }
+
+    // These 4 compute new bounds.
+    for (auto const& r : restricted_move_area(win->space, win->desktop(), strut_area::top)) {
+        auto rect = r & tall_frame_geo;
+        if (!rect.isEmpty()) {
+            top_max = std::max(top_max, rect.y() + rect.height());
+        }
+    }
+    for (auto const& r : restricted_move_area(win->space, win->desktop(), strut_area::right)) {
+        auto rect = r & wide_frame_geo;
+        if (!rect.isEmpty()) {
+            right_max = std::min(right_max, rect.x());
+        }
+    }
+    for (auto const& r : restricted_move_area(win->space, win->desktop(), strut_area::bottom)) {
+        auto rect = r & tall_frame_geo;
+        if (!rect.isEmpty()) {
+            bottom_max = std::min(bottom_max, rect.y());
+        }
+    }
+    for (auto const& r : restricted_move_area(win->space, win->desktop(), strut_area::left)) {
+        auto rect = r & wide_frame_geo;
+        if (!rect.isEmpty()) {
+            left_max = std::max(left_max, rect.x() + rect.width());
+        }
+    }
+
+    // Check if the sides were inside or touching but are no longer
+    bool keep[4] = {false, false, false, false};
+    bool save[4] = {false, false, false, false};
+    int padding[4] = {0, 0, 0, 0};
+
+    if (old_frame_geo.x() >= old_left_max) {
+        save[Left] = frame_geo.x() < left_max;
+    }
+
+    if (old_frame_geo.x() == old_left_max) {
+        keep[Left] = frame_geo.x() != left_max;
+    } else if (old_client_geo.x() == old_left_max && client_geo.x() != left_max) {
+        padding[0] = border[Left];
+        keep[Left] = true;
+    }
+
+    if (old_frame_geo.y() >= old_top_max) {
+        save[Top] = frame_geo.y() < top_max;
+    }
+
+    if (old_frame_geo.y() == old_top_max) {
+        keep[Top] = frame_geo.y() != top_max;
+    } else if (old_client_geo.y() == old_top_max && client_geo.y() != top_max) {
+        padding[1] = border[Left];
+        keep[Top] = true;
+    }
+
+    if (old_frame_geo.right() <= old_right_max - 1) {
+        save[Right] = frame_geo.right() > right_max - 1;
+    }
+
+    if (old_frame_geo.right() == old_right_max - 1) {
+        keep[Right] = frame_geo.right() != right_max - 1;
+    } else if (old_client_geo.right() == old_right_max - 1 && client_geo.right() != right_max - 1) {
+        padding[2] = border[Right];
+        keep[Right] = true;
+    }
+
+    if (old_frame_geo.bottom() <= old_bottom_max - 1) {
+        save[Bottom] = frame_geo.bottom() > bottom_max - 1;
+    }
+
+    if (old_frame_geo.bottom() == old_bottom_max - 1) {
+        keep[Bottom] = frame_geo.bottom() != bottom_max - 1;
+    } else if (old_client_geo.bottom() == old_bottom_max - 1
+               && client_geo.bottom() != bottom_max - 1) {
+        padding[3] = border[Bottom];
+        keep[Bottom] = true;
+    }
+
+    // if randomly touches opposing edges, do not favor either
+    if (keep[Left] && keep[Right]) {
+        keep[Left] = keep[Right] = false;
+        padding[0] = padding[2] = 0;
+    }
+    if (keep[Top] && keep[Bottom]) {
+        keep[Top] = keep[Bottom] = false;
+        padding[1] = padding[3] = 0;
+    }
+
+    auto const& outputs = kwinApp()->get_base().get_outputs();
+
+    if (save[Left] || keep[Left]) {
+        frame_geo.moveLeft(std::max(left_max, screenArea.x()) - padding[0]);
+    }
+    if (padding[0] && base::get_intersecting_outputs(outputs, frame_geo).size() > 1) {
+        frame_geo.moveLeft(frame_geo.left() + padding[0]);
+    }
+    if (save[Top] || keep[Top]) {
+        frame_geo.moveTop(std::max(top_max, screenArea.y()) - padding[1]);
+    }
+    if (padding[1] && base::get_intersecting_outputs(outputs, frame_geo).size() > 1) {
+        frame_geo.moveTop(frame_geo.top() + padding[1]);
+    }
+    if (save[Right] || keep[Right]) {
+        frame_geo.moveRight(std::min(right_max - 1, screenArea.right()) + padding[2]);
+    }
+    if (padding[2] && base::get_intersecting_outputs(outputs, frame_geo).size() > 1) {
+        frame_geo.moveRight(frame_geo.right() - padding[2]);
+    }
+    if (old_frame_geo.x() >= old_left_max && frame_geo.x() < left_max) {
+        frame_geo.setLeft(std::max(left_max, screenArea.x()));
+    } else if (old_client_geo.x() >= old_left_max && frame_geo.x() + border[Left] < left_max) {
+        frame_geo.setLeft(std::max(left_max, screenArea.x()) - border[Left]);
+        if (base::get_intersecting_outputs(outputs, frame_geo).size() > 1) {
+            frame_geo.setLeft(frame_geo.left() + border[Left]);
+        }
+    }
+    if (save[Bottom] || keep[Bottom]) {
+        frame_geo.moveBottom(std::min(bottom_max - 1, screenArea.bottom()) + padding[3]);
+    }
+    if (padding[3] && base::get_intersecting_outputs(outputs, frame_geo).size() > 1) {
+        frame_geo.moveBottom(frame_geo.bottom() - padding[3]);
+    }
+
+    if (old_frame_geo.y() >= old_top_max && frame_geo.y() < top_max) {
+        frame_geo.setTop(std::max(top_max, screenArea.y()));
+    } else if (old_client_geo.y() >= old_top_max && frame_geo.y() + border[Top] < top_max) {
+        frame_geo.setTop(std::max(top_max, screenArea.y()) - border[Top]);
+        if (base::get_intersecting_outputs(outputs, frame_geo).size() > 1) {
+            frame_geo.setTop(frame_geo.top() + border[Top]);
+        }
+    }
+
+    check_offscreen_position(frame_geo, screenArea);
+
+    // Obey size hints. TODO: We really should make sure it stays in the right place
+    frame_geo.setSize(adjusted_frame_size(win, frame_geo.size(), size_mode::any));
+
+    win->setFrameGeometry(frame_geo);
+}
+
+}
diff --git a/win/move.h b/win/move.h
index 25c47b269..ebe90a9f1 100644
--- a/win/move.h
+++ b/win/move.h
@@ -11,6 +11,7 @@
 #include "geo_electric.h"
 #include "geo_move.h"
 #include "net.h"
+#include "quicktile.h"
 #include "space.h"
 #include "stacking.h"
 #include "types.h"
@@ -219,591 +220,12 @@ void check_unrestricted_move_resize(Win* win)
     }
 }
 
-inline void check_offscreen_position(QRect& frame_geo, const QRect& screenArea)
-{
-    if (frame_geo.left() > screenArea.right()) {
-        frame_geo.moveLeft(screenArea.right() - screenArea.width() / 4);
-    } else if (frame_geo.right() < screenArea.left()) {
-        frame_geo.moveRight(screenArea.left() + screenArea.width() / 4);
-    }
-    if (frame_geo.top() > screenArea.bottom()) {
-        frame_geo.moveTop(screenArea.bottom() - screenArea.height() / 4);
-    } else if (frame_geo.bottom() < screenArea.top()) {
-        frame_geo.moveBottom(screenArea.top() + screenArea.height() / 4);
-    }
-}
-
-template<typename Win>
-void check_workspace_position(Win* win,
-                              QRect old_frame_geo = QRect(),
-                              int oldDesktop = -2,
-                              QRect old_client_geo = QRect())
-{
-    assert(win->control);
-
-    if (is_desktop(win)) {
-        return;
-    }
-    if (is_dock(win)) {
-        return;
-    }
-    if (is_notification(win) || is_on_screen_display(win)) {
-        return;
-    }
-
-    if (kwinApp()->get_base().get_outputs().empty()) {
-        return;
-    }
-
-    if (win->geometry_update.fullscreen) {
-        auto area = space_window_area(win->space, FullScreenArea, win);
-        win->setFrameGeometry(area);
-        return;
-    }
-
-    if (win->maximizeMode() != maximize_mode::restore) {
-        geometry_updates_blocker block(win);
-
-        win->update_maximized(win->geometry_update.max_mode);
-        auto const screenArea = space_window_area(win->space, ScreenArea, win);
-
-        auto geo = pending_frame_geometry(win);
-        check_offscreen_position(geo, screenArea);
-        win->setFrameGeometry(geo);
-
-        return;
-    }
-
-    if (win->control->quicktiling() != quicktiles::none) {
-        win->setFrameGeometry(electric_border_maximize_geometry(
-            win, pending_frame_geometry(win).center(), win->desktop()));
-        return;
-    }
-
-    enum { Left = 0, Top, Right, Bottom };
-    int const border[4]
-        = {left_border(win), top_border(win), right_border(win), bottom_border(win)};
-
-    if (!old_frame_geo.isValid()) {
-        old_frame_geo = pending_frame_geometry(win);
-    }
-    if (oldDesktop == -2) {
-        oldDesktop = win->desktop();
-    }
-    if (!old_client_geo.isValid()) {
-        old_client_geo
-            = old_frame_geo.adjusted(border[Left], border[Top], -border[Right], -border[Bottom]);
-    }
-
-    // If the window was touching an edge before but not now move it so it is again.
-    // Old and new maximums have different starting values so windows on the screen
-    // edge will move when a new strut is placed on the edge.
-    QRect old_screen_area;
-    if (in_update_window_area(win->space)) {
-        // we need to find the screen area as it was before the change
-        old_screen_area
-            = QRect(0, 0, win->space.olddisplaysize.width(), win->space.olddisplaysize.height());
-        int distance = INT_MAX;
-        for (auto const& r : win->space.oldscreensizes) {
-            int d = r.contains(old_frame_geo.center())
-                ? 0
-                : (r.center() - old_frame_geo.center()).manhattanLength();
-            if (d < distance) {
-                distance = d;
-                old_screen_area = r;
-            }
-        }
-    } else {
-        old_screen_area
-            = space_window_area(win->space, ScreenArea, old_frame_geo.center(), oldDesktop);
-    }
-
-    // With full screen height.
-    auto const old_tall_frame_geo = QRect(
-        old_frame_geo.x(), old_screen_area.y(), old_frame_geo.width(), old_screen_area.height());
-
-    // With full screen width.
-    auto const old_wide_frame_geo = QRect(
-        old_screen_area.x(), old_frame_geo.y(), old_screen_area.width(), old_frame_geo.height());
-
-    auto old_top_max = old_screen_area.y();
-    auto old_right_max = old_screen_area.x() + old_screen_area.width();
-    auto old_bottom_max = old_screen_area.y() + old_screen_area.height();
-    auto old_left_max = old_screen_area.x();
-
-    auto const screenArea = space_window_area(
-        win->space, ScreenArea, pending_frame_geometry(win).center(), win->desktop());
-
-    auto top_max = screenArea.y();
-    auto right_max = screenArea.x() + screenArea.width();
-    auto bottom_max = screenArea.y() + screenArea.height();
-    auto left_max = screenArea.x();
-
-    auto frame_geo = pending_frame_geometry(win);
-    auto client_geo
-        = frame_geo.adjusted(border[Left], border[Top], -border[Right], -border[Bottom]);
-
-    // Full screen height
-    auto const tall_frame_geo
-        = QRect(frame_geo.x(), screenArea.y(), frame_geo.width(), screenArea.height());
-
-    // Full screen width
-    auto const wide_frame_geo
-        = QRect(screenArea.x(), frame_geo.y(), screenArea.width(), frame_geo.height());
-
-    // Get the max strut point for each side where the window is (E.g. Highest point for
-    // the bottom struts bounded by the window's left and right sides).
-
-    // Default is to use restrictedMoveArea. That's on active desktop or screen change.
-    auto move_area_func = win::restricted_move_area<decltype(win->space)>;
-    if (in_update_window_area(win->space)) {
-        // On restriected area changes.
-        // TODO(romangg): This check back on in_update_window_area and then setting here internally
-        //                a different function is bad design. Replace with an argument or something.
-        move_area_func = win::previous_restricted_move_area<decltype(win->space)>;
-    }
-
-    // These 4 compute old bounds.
-    for (auto const& r : move_area_func(win->space, oldDesktop, strut_area::top)) {
-        auto rect = r & old_tall_frame_geo;
-        if (!rect.isEmpty()) {
-            old_top_max = std::max(old_top_max, rect.y() + rect.height());
-        }
-    }
-    for (auto const& r : move_area_func(win->space, oldDesktop, strut_area::right)) {
-        auto rect = r & old_wide_frame_geo;
-        if (!rect.isEmpty()) {
-            old_right_max = std::min(old_right_max, rect.x());
-        }
-    }
-    for (auto const& r : move_area_func(win->space, oldDesktop, strut_area::bottom)) {
-        auto rect = r & old_tall_frame_geo;
-        if (!rect.isEmpty()) {
-            old_bottom_max = std::min(old_bottom_max, rect.y());
-        }
-    }
-    for (auto const& r : move_area_func(win->space, oldDesktop, strut_area::left)) {
-        auto rect = r & old_wide_frame_geo;
-        if (!rect.isEmpty()) {
-            old_left_max = std::max(old_left_max, rect.x() + rect.width());
-        }
-    }
-
-    // These 4 compute new bounds.
-    for (auto const& r : restricted_move_area(win->space, win->desktop(), strut_area::top)) {
-        auto rect = r & tall_frame_geo;
-        if (!rect.isEmpty()) {
-            top_max = std::max(top_max, rect.y() + rect.height());
-        }
-    }
-    for (auto const& r : restricted_move_area(win->space, win->desktop(), strut_area::right)) {
-        auto rect = r & wide_frame_geo;
-        if (!rect.isEmpty()) {
-            right_max = std::min(right_max, rect.x());
-        }
-    }
-    for (auto const& r : restricted_move_area(win->space, win->desktop(), strut_area::bottom)) {
-        auto rect = r & tall_frame_geo;
-        if (!rect.isEmpty()) {
-            bottom_max = std::min(bottom_max, rect.y());
-        }
-    }
-    for (auto const& r : restricted_move_area(win->space, win->desktop(), strut_area::left)) {
-        auto rect = r & wide_frame_geo;
-        if (!rect.isEmpty()) {
-            left_max = std::max(left_max, rect.x() + rect.width());
-        }
-    }
-
-    // Check if the sides were inside or touching but are no longer
-    bool keep[4] = {false, false, false, false};
-    bool save[4] = {false, false, false, false};
-    int padding[4] = {0, 0, 0, 0};
-
-    if (old_frame_geo.x() >= old_left_max) {
-        save[Left] = frame_geo.x() < left_max;
-    }
-
-    if (old_frame_geo.x() == old_left_max) {
-        keep[Left] = frame_geo.x() != left_max;
-    } else if (old_client_geo.x() == old_left_max && client_geo.x() != left_max) {
-        padding[0] = border[Left];
-        keep[Left] = true;
-    }
-
-    if (old_frame_geo.y() >= old_top_max) {
-        save[Top] = frame_geo.y() < top_max;
-    }
-
-    if (old_frame_geo.y() == old_top_max) {
-        keep[Top] = frame_geo.y() != top_max;
-    } else if (old_client_geo.y() == old_top_max && client_geo.y() != top_max) {
-        padding[1] = border[Left];
-        keep[Top] = true;
-    }
-
-    if (old_frame_geo.right() <= old_right_max - 1) {
-        save[Right] = frame_geo.right() > right_max - 1;
-    }
-
-    if (old_frame_geo.right() == old_right_max - 1) {
-        keep[Right] = frame_geo.right() != right_max - 1;
-    } else if (old_client_geo.right() == old_right_max - 1 && client_geo.right() != right_max - 1) {
-        padding[2] = border[Right];
-        keep[Right] = true;
-    }
-
-    if (old_frame_geo.bottom() <= old_bottom_max - 1) {
-        save[Bottom] = frame_geo.bottom() > bottom_max - 1;
-    }
-
-    if (old_frame_geo.bottom() == old_bottom_max - 1) {
-        keep[Bottom] = frame_geo.bottom() != bottom_max - 1;
-    } else if (old_client_geo.bottom() == old_bottom_max - 1
-               && client_geo.bottom() != bottom_max - 1) {
-        padding[3] = border[Bottom];
-        keep[Bottom] = true;
-    }
-
-    // if randomly touches opposing edges, do not favor either
-    if (keep[Left] && keep[Right]) {
-        keep[Left] = keep[Right] = false;
-        padding[0] = padding[2] = 0;
-    }
-    if (keep[Top] && keep[Bottom]) {
-        keep[Top] = keep[Bottom] = false;
-        padding[1] = padding[3] = 0;
-    }
-
-    auto const& outputs = kwinApp()->get_base().get_outputs();
-
-    if (save[Left] || keep[Left]) {
-        frame_geo.moveLeft(std::max(left_max, screenArea.x()) - padding[0]);
-    }
-    if (padding[0] && base::get_intersecting_outputs(outputs, frame_geo).size() > 1) {
-        frame_geo.moveLeft(frame_geo.left() + padding[0]);
-    }
-    if (save[Top] || keep[Top]) {
-        frame_geo.moveTop(std::max(top_max, screenArea.y()) - padding[1]);
-    }
-    if (padding[1] && base::get_intersecting_outputs(outputs, frame_geo).size() > 1) {
-        frame_geo.moveTop(frame_geo.top() + padding[1]);
-    }
-    if (save[Right] || keep[Right]) {
-        frame_geo.moveRight(std::min(right_max - 1, screenArea.right()) + padding[2]);
-    }
-    if (padding[2] && base::get_intersecting_outputs(outputs, frame_geo).size() > 1) {
-        frame_geo.moveRight(frame_geo.right() - padding[2]);
-    }
-    if (old_frame_geo.x() >= old_left_max && frame_geo.x() < left_max) {
-        frame_geo.setLeft(std::max(left_max, screenArea.x()));
-    } else if (old_client_geo.x() >= old_left_max && frame_geo.x() + border[Left] < left_max) {
-        frame_geo.setLeft(std::max(left_max, screenArea.x()) - border[Left]);
-        if (base::get_intersecting_outputs(outputs, frame_geo).size() > 1) {
-            frame_geo.setLeft(frame_geo.left() + border[Left]);
-        }
-    }
-    if (save[Bottom] || keep[Bottom]) {
-        frame_geo.moveBottom(std::min(bottom_max - 1, screenArea.bottom()) + padding[3]);
-    }
-    if (padding[3] && base::get_intersecting_outputs(outputs, frame_geo).size() > 1) {
-        frame_geo.moveBottom(frame_geo.bottom() - padding[3]);
-    }
-
-    if (old_frame_geo.y() >= old_top_max && frame_geo.y() < top_max) {
-        frame_geo.setTop(std::max(top_max, screenArea.y()));
-    } else if (old_client_geo.y() >= old_top_max && frame_geo.y() + border[Top] < top_max) {
-        frame_geo.setTop(std::max(top_max, screenArea.y()) - border[Top]);
-        if (base::get_intersecting_outputs(outputs, frame_geo).size() > 1) {
-            frame_geo.setTop(frame_geo.top() + border[Top]);
-        }
-    }
-
-    check_offscreen_position(frame_geo, screenArea);
-
-    // Obey size hints. TODO: We really should make sure it stays in the right place
-    frame_geo.setSize(adjusted_frame_size(win, frame_geo.size(), size_mode::any));
-
-    win->setFrameGeometry(frame_geo);
-}
-
-template<typename Win>
-void set_maximize(Win* win, bool vertically, bool horizontally)
-{
-    auto mode = maximize_mode::restore;
-    if (vertically) {
-        mode |= maximize_mode::vertical;
-    }
-    if (horizontally) {
-        mode |= maximize_mode::horizontal;
-    }
-    win->update_maximized(mode);
-}
-
 template<typename Win>
 void maximize(Win* win, maximize_mode mode)
 {
     win->update_maximized(mode);
 }
 
-/**
- * Checks if the mouse cursor is near the edge of the screen and if so
- * activates quick tiling or maximization.
- */
-template<typename Win>
-void check_quicktile_maximization_zones(Win* win, int xroot, int yroot)
-{
-    auto mode = quicktiles::none;
-    bool inner_border = false;
-    auto const& outputs = kwinApp()->get_base().get_outputs();
-
-    for (size_t i = 0; i < outputs.size(); ++i) {
-        if (!outputs.at(i)->geometry().contains(QPoint(xroot, yroot))) {
-            continue;
-        }
-
-        auto in_screen = [i, &outputs](const QPoint& pt) {
-            for (size_t j = 0; j < outputs.size(); ++j) {
-                if (j != i && outputs.at(j)->geometry().contains(pt)) {
-                    return true;
-                }
-            }
-            return false;
-        };
-
-        auto area
-            = space_window_area(win->space, MaximizeArea, QPoint(xroot, yroot), win->desktop());
-        if (kwinApp()->options->electricBorderTiling()) {
-            if (xroot <= area.x() + 20) {
-                mode |= quicktiles::left;
-                inner_border = in_screen(QPoint(area.x() - 1, yroot));
-            } else if (xroot >= area.x() + area.width() - 20) {
-                mode |= quicktiles::right;
-                inner_border = in_screen(QPoint(area.right() + 1, yroot));
-            }
-        }
-
-        if (mode != quicktiles::none) {
-            if (yroot <= area.y() + area.height() * kwinApp()->options->electricBorderCornerRatio())
-                mode |= quicktiles::top;
-            else if (yroot >= area.y() + area.height()
-                         - area.height() * kwinApp()->options->electricBorderCornerRatio())
-                mode |= quicktiles::bottom;
-        } else if (kwinApp()->options->electricBorderMaximize() && yroot <= area.y() + 5
-                   && win->isMaximizable()) {
-            mode = quicktiles::maximize;
-            inner_border = in_screen(QPoint(xroot, area.y() - 1));
-        }
-        break;
-    }
-    if (mode != win->control->electric()) {
-        set_electric(win, mode);
-        if (inner_border) {
-            delayed_electric_maximize(win);
-        } else {
-            set_electric_maximizing(win, mode != quicktiles::none);
-        }
-    }
-}
-
-/**
- * Sets the quick tile mode ("snap") of this window.
- * This will also handle preserving and restoring of window geometry as necessary.
- * @param mode The tile mode (left/right) to give this window.
- * @param keyboard Defines whether to take keyboard cursor into account.
- */
-template<typename Win>
-void set_quicktile_mode(Win* win, quicktiles mode, bool keyboard)
-{
-    // Only allow quick tile on a regular window.
-    if (!win->isResizable()) {
-        return;
-    }
-
-    win->space.focusMousePos = input::get_cursor()->pos();
-
-    geometry_updates_blocker blocker(win);
-
-    // Store current geometry if not already defined.
-    if (!win->restore_geometries.maximize.isValid()) {
-        win->restore_geometries.maximize = win->frameGeometry();
-    }
-
-    // Later calls to set_maximize(..) would reset the restore geometry.
-    auto const old_restore_geo = win->restore_geometries.maximize;
-
-    if (mode == quicktiles::maximize) {
-        // Special case where we just maximize and return early.
-
-        auto const old_quicktiling = win->control->quicktiling();
-        win->control->set_quicktiling(quicktiles::none);
-
-        if (win->maximizeMode() == maximize_mode::full) {
-            // TODO(romangg): When window was already maximized we now "unmaximize" it. Why?
-            set_maximize(win, false, false);
-        } else {
-            win->control->set_quicktiling(quicktiles::maximize);
-            set_maximize(win, true, true);
-            auto clientArea = space_window_area(win->space, MaximizeArea, win);
-
-            if (auto frame_geo = pending_frame_geometry(win); frame_geo.top() != clientArea.top()) {
-                frame_geo.moveTop(clientArea.top());
-                win->setFrameGeometry(frame_geo);
-            }
-            win->restore_geometries.maximize = old_restore_geo;
-        }
-
-        if (old_quicktiling != win->control->quicktiling()) {
-            Q_EMIT win->quicktiling_changed();
-        }
-        return;
-    }
-
-    // Sanitize the mode, ie. simplify "invalid" combinations.
-    if ((mode & quicktiles::horizontal) == quicktiles::horizontal) {
-        mode &= ~quicktiles::horizontal;
-    }
-    if ((mode & quicktiles::vertical) == quicktiles::vertical) {
-        mode &= ~quicktiles::vertical;
-    }
-
-    // Used by electric_border_maximize_geometry(..).
-    win->control->set_electric(mode);
-
-    if (win->geometry_update.max_mode != maximize_mode::restore) {
-        // Restore from maximized so that it is possible to tile maximized windows with one hit or
-        // by dragging.
-        if (mode != quicktiles::none) {
-            // Temporary, so the maximize code doesn't get all confused
-            win->control->set_quicktiling(quicktiles::none);
-
-            set_maximize(win, false, false);
-
-            auto ref_pos
-                = keyboard ? pending_frame_geometry(win).center() : input::get_cursor()->pos();
-
-            win->setFrameGeometry(electric_border_maximize_geometry(win, ref_pos, win->desktop()));
-            // Store the mode change
-            win->control->set_quicktiling(mode);
-            win->restore_geometries.maximize = old_restore_geo;
-        } else {
-            win->control->set_quicktiling(mode);
-            set_maximize(win, false, false);
-        }
-
-        Q_EMIT win->quicktiling_changed();
-        return;
-    }
-
-    if (mode != quicktiles::none) {
-        auto target_screen
-            = keyboard ? pending_frame_geometry(win).center() : input::get_cursor()->pos();
-
-        if (win->control->quicktiling() == mode) {
-            // If trying to tile to the side that the window is already tiled to move the window to
-            // the next screen if it exists, otherwise toggle the mode (set quicktiles::none)
-
-            // TODO(romangg): Once we use size_t consistently for screens identification replace
-            // these (currentyl implicit casted) types with auto.
-            auto const& outputs = kwinApp()->get_base().get_outputs();
-            auto const old_screen = win->central_output
-                ? base::get_output_index(kwinApp()->get_base().get_outputs(), *win->central_output)
-                : 0;
-            auto screen = old_screen;
-
-            std::vector<QRect> screens_geos(outputs.size());
-            screens_geos.resize(outputs.size());
-
-            for (size_t i = 0; i < outputs.size(); ++i) {
-                // Geometry cache.
-                screens_geos[i] = outputs.at(i)->geometry();
-            }
-
-            for (size_t i = 0; i < outputs.size(); ++i) {
-                if (i == old_screen) {
-                    continue;
-                }
-
-                if (screens_geos[i].bottom() <= screens_geos[old_screen].top()
-                    || screens_geos[i].top() >= screens_geos[old_screen].bottom()) {
-                    // Not in horizontal line
-                    continue;
-                }
-
-                auto const x = screens_geos[i].center().x();
-                if ((mode & quicktiles::horizontal) == quicktiles::left) {
-                    if (x >= screens_geos[old_screen].center().x()
-                        || (old_screen != screen && x <= screens_geos[screen].center().x())) {
-                        // Not left of current or more left then found next
-                        continue;
-                    }
-                } else if ((mode & quicktiles::horizontal) == quicktiles::right) {
-                    if (x <= screens_geos[old_screen].center().x()
-                        || (old_screen != screen && x >= screens_geos[screen].center().x())) {
-                        // Not right of current or more right then found next.
-                        continue;
-                    }
-                }
-
-                screen = i;
-            }
-
-            if (screen == old_screen) {
-                // No other screens, toggle tiling.
-                mode = quicktiles::none;
-            } else {
-                // Move to other screen
-                win->setFrameGeometry(win->restore_geometries.maximize.translated(
-                    screens_geos[screen].topLeft() - screens_geos[old_screen].topLeft()));
-                target_screen = screens_geos[screen].center();
-
-                // Swap sides
-                if (flags(mode & quicktiles::horizontal)) {
-                    mode = (~mode & quicktiles::horizontal) | (mode & quicktiles::vertical);
-                }
-            }
-
-            // used by electric_border_maximize_geometry(.)
-            set_electric(win, mode);
-
-        } else if (win->control->quicktiling() == quicktiles::none) {
-            // Not coming out of an existing tile, not shifting monitors, we're setting a brand new
-            // tile. Store geometry first, so we can go out of this tile later.
-            if (!win->restore_geometries.maximize.isValid()) {
-                win->restore_geometries.maximize = win->frameGeometry();
-            }
-        }
-
-        if (mode != quicktiles::none) {
-            win->control->set_quicktiling(mode);
-            // Temporary, so the maximize code doesn't get all confused
-            win->control->set_quicktiling(quicktiles::none);
-
-            // TODO(romangg): With decorations this was previously forced in order to handle borders
-            //                being changed. Is it safe to do this now without that?
-            win->setFrameGeometry(
-                electric_border_maximize_geometry(win, target_screen, win->desktop()));
-        }
-
-        // Store the mode change
-        win->control->set_quicktiling(mode);
-    }
-
-    if (mode == quicktiles::none) {
-        win->control->set_quicktiling(quicktiles::none);
-        win->setFrameGeometry(win->restore_geometries.maximize);
-
-        // Just in case it's a different screen
-        check_workspace_position(win);
-
-        // If we're here we can unconditionally reset the restore geometry since we earlier excluded
-        // the case of the window being maximized.
-        win->restore_geometries.maximize = QRect();
-    }
-
-    Q_EMIT win->quicktiling_changed();
-}
-
 template<typename Win>
 void stop_delayed_move_resize(Win* win)
 {
diff --git a/win/quicktile.h b/win/quicktile.h
new file mode 100644
index 000000000..654a4edcf
--- /dev/null
+++ b/win/quicktile.h
@@ -0,0 +1,285 @@
+/*
+    SPDX-FileCopyrightText: 2022 Roman Gilg <subdiff@gmail.com>
+
+    SPDX-License-Identifier: GPL-2.0-or-later
+*/
+#pragma once
+
+#include "geo_restrict.h"
+#include "types.h"
+
+namespace KWin::win
+{
+
+template<typename Win>
+void set_maximize(Win* win, bool vertically, bool horizontally)
+{
+    auto mode = maximize_mode::restore;
+    if (vertically) {
+        mode |= maximize_mode::vertical;
+    }
+    if (horizontally) {
+        mode |= maximize_mode::horizontal;
+    }
+    win->update_maximized(mode);
+}
+
+/**
+ * Checks if the mouse cursor is near the edge of the screen and if so
+ * activates quick tiling or maximization.
+ */
+template<typename Win>
+void check_quicktile_maximization_zones(Win* win, int xroot, int yroot)
+{
+    auto mode = quicktiles::none;
+    bool inner_border = false;
+    auto const& outputs = kwinApp()->get_base().get_outputs();
+
+    for (size_t i = 0; i < outputs.size(); ++i) {
+        if (!outputs.at(i)->geometry().contains(QPoint(xroot, yroot))) {
+            continue;
+        }
+
+        auto in_screen = [i, &outputs](const QPoint& pt) {
+            for (size_t j = 0; j < outputs.size(); ++j) {
+                if (j != i && outputs.at(j)->geometry().contains(pt)) {
+                    return true;
+                }
+            }
+            return false;
+        };
+
+        auto area
+            = space_window_area(win->space, MaximizeArea, QPoint(xroot, yroot), win->desktop());
+        if (kwinApp()->options->electricBorderTiling()) {
+            if (xroot <= area.x() + 20) {
+                mode |= quicktiles::left;
+                inner_border = in_screen(QPoint(area.x() - 1, yroot));
+            } else if (xroot >= area.x() + area.width() - 20) {
+                mode |= quicktiles::right;
+                inner_border = in_screen(QPoint(area.right() + 1, yroot));
+            }
+        }
+
+        if (mode != quicktiles::none) {
+            if (yroot <= area.y() + area.height() * kwinApp()->options->electricBorderCornerRatio())
+                mode |= quicktiles::top;
+            else if (yroot >= area.y() + area.height()
+                         - area.height() * kwinApp()->options->electricBorderCornerRatio())
+                mode |= quicktiles::bottom;
+        } else if (kwinApp()->options->electricBorderMaximize() && yroot <= area.y() + 5
+                   && win->isMaximizable()) {
+            mode = quicktiles::maximize;
+            inner_border = in_screen(QPoint(xroot, area.y() - 1));
+        }
+        break;
+    }
+    if (mode != win->control->electric()) {
+        set_electric(win, mode);
+        if (inner_border) {
+            delayed_electric_maximize(win);
+        } else {
+            set_electric_maximizing(win, mode != quicktiles::none);
+        }
+    }
+}
+
+/**
+ * Sets the quick tile mode ("snap") of this window.
+ * This will also handle preserving and restoring of window geometry as necessary.
+ * @param mode The tile mode (left/right) to give this window.
+ * @param keyboard Defines whether to take keyboard cursor into account.
+ */
+template<typename Win>
+void set_quicktile_mode(Win* win, quicktiles mode, bool keyboard)
+{
+    // Only allow quick tile on a regular window.
+    if (!win->isResizable()) {
+        return;
+    }
+
+    win->space.focusMousePos = input::get_cursor()->pos();
+
+    geometry_updates_blocker blocker(win);
+
+    // Store current geometry if not already defined.
+    if (!win->restore_geometries.maximize.isValid()) {
+        win->restore_geometries.maximize = win->frameGeometry();
+    }
+
+    // Later calls to set_maximize(..) would reset the restore geometry.
+    auto const old_restore_geo = win->restore_geometries.maximize;
+
+    if (mode == quicktiles::maximize) {
+        // Special case where we just maximize and return early.
+
+        auto const old_quicktiling = win->control->quicktiling();
+        win->control->set_quicktiling(quicktiles::none);
+
+        if (win->maximizeMode() == maximize_mode::full) {
+            // TODO(romangg): When window was already maximized we now "unmaximize" it. Why?
+            set_maximize(win, false, false);
+        } else {
+            win->control->set_quicktiling(quicktiles::maximize);
+            set_maximize(win, true, true);
+            auto clientArea = space_window_area(win->space, MaximizeArea, win);
+
+            if (auto frame_geo = pending_frame_geometry(win); frame_geo.top() != clientArea.top()) {
+                frame_geo.moveTop(clientArea.top());
+                win->setFrameGeometry(frame_geo);
+            }
+            win->restore_geometries.maximize = old_restore_geo;
+        }
+
+        if (old_quicktiling != win->control->quicktiling()) {
+            Q_EMIT win->quicktiling_changed();
+        }
+        return;
+    }
+
+    // Sanitize the mode, ie. simplify "invalid" combinations.
+    if ((mode & quicktiles::horizontal) == quicktiles::horizontal) {
+        mode &= ~quicktiles::horizontal;
+    }
+    if ((mode & quicktiles::vertical) == quicktiles::vertical) {
+        mode &= ~quicktiles::vertical;
+    }
+
+    // Used by electric_border_maximize_geometry(..).
+    win->control->set_electric(mode);
+
+    if (win->geometry_update.max_mode != maximize_mode::restore) {
+        // Restore from maximized so that it is possible to tile maximized windows with one hit or
+        // by dragging.
+        if (mode != quicktiles::none) {
+            // Temporary, so the maximize code doesn't get all confused
+            win->control->set_quicktiling(quicktiles::none);
+
+            set_maximize(win, false, false);
+
+            auto ref_pos
+                = keyboard ? pending_frame_geometry(win).center() : input::get_cursor()->pos();
+
+            win->setFrameGeometry(electric_border_maximize_geometry(win, ref_pos, win->desktop()));
+            // Store the mode change
+            win->control->set_quicktiling(mode);
+            win->restore_geometries.maximize = old_restore_geo;
+        } else {
+            win->control->set_quicktiling(mode);
+            set_maximize(win, false, false);
+        }
+
+        Q_EMIT win->quicktiling_changed();
+        return;
+    }
+
+    if (mode != quicktiles::none) {
+        auto target_screen
+            = keyboard ? pending_frame_geometry(win).center() : input::get_cursor()->pos();
+
+        if (win->control->quicktiling() == mode) {
+            // If trying to tile to the side that the window is already tiled to move the window to
+            // the next screen if it exists, otherwise toggle the mode (set quicktiles::none)
+
+            // TODO(romangg): Once we use size_t consistently for screens identification replace
+            // these (currentyl implicit casted) types with auto.
+            auto const& outputs = kwinApp()->get_base().get_outputs();
+            auto const old_screen = win->central_output
+                ? base::get_output_index(kwinApp()->get_base().get_outputs(), *win->central_output)
+                : 0;
+            auto screen = old_screen;
+
+            std::vector<QRect> screens_geos(outputs.size());
+            screens_geos.resize(outputs.size());
+
+            for (size_t i = 0; i < outputs.size(); ++i) {
+                // Geometry cache.
+                screens_geos[i] = outputs.at(i)->geometry();
+            }
+
+            for (size_t i = 0; i < outputs.size(); ++i) {
+                if (i == old_screen) {
+                    continue;
+                }
+
+                if (screens_geos[i].bottom() <= screens_geos[old_screen].top()
+                    || screens_geos[i].top() >= screens_geos[old_screen].bottom()) {
+                    // Not in horizontal line
+                    continue;
+                }
+
+                auto const x = screens_geos[i].center().x();
+                if ((mode & quicktiles::horizontal) == quicktiles::left) {
+                    if (x >= screens_geos[old_screen].center().x()
+                        || (old_screen != screen && x <= screens_geos[screen].center().x())) {
+                        // Not left of current or more left then found next
+                        continue;
+                    }
+                } else if ((mode & quicktiles::horizontal) == quicktiles::right) {
+                    if (x <= screens_geos[old_screen].center().x()
+                        || (old_screen != screen && x >= screens_geos[screen].center().x())) {
+                        // Not right of current or more right then found next.
+                        continue;
+                    }
+                }
+
+                screen = i;
+            }
+
+            if (screen == old_screen) {
+                // No other screens, toggle tiling.
+                mode = quicktiles::none;
+            } else {
+                // Move to other screen
+                win->setFrameGeometry(win->restore_geometries.maximize.translated(
+                    screens_geos[screen].topLeft() - screens_geos[old_screen].topLeft()));
+                target_screen = screens_geos[screen].center();
+
+                // Swap sides
+                if (flags(mode & quicktiles::horizontal)) {
+                    mode = (~mode & quicktiles::horizontal) | (mode & quicktiles::vertical);
+                }
+            }
+
+            // used by electric_border_maximize_geometry(.)
+            set_electric(win, mode);
+
+        } else if (win->control->quicktiling() == quicktiles::none) {
+            // Not coming out of an existing tile, not shifting monitors, we're setting a brand new
+            // tile. Store geometry first, so we can go out of this tile later.
+            if (!win->restore_geometries.maximize.isValid()) {
+                win->restore_geometries.maximize = win->frameGeometry();
+            }
+        }
+
+        if (mode != quicktiles::none) {
+            win->control->set_quicktiling(mode);
+            // Temporary, so the maximize code doesn't get all confused
+            win->control->set_quicktiling(quicktiles::none);
+
+            // TODO(romangg): With decorations this was previously forced in order to handle borders
+            //                being changed. Is it safe to do this now without that?
+            win->setFrameGeometry(
+                electric_border_maximize_geometry(win, target_screen, win->desktop()));
+        }
+
+        // Store the mode change
+        win->control->set_quicktiling(mode);
+    }
+
+    if (mode == quicktiles::none) {
+        win->control->set_quicktiling(quicktiles::none);
+        win->setFrameGeometry(win->restore_geometries.maximize);
+
+        // Just in case it's a different screen
+        check_workspace_position(win);
+
+        // If we're here we can unconditionally reset the restore geometry since we earlier excluded
+        // the case of the window being maximized.
+        win->restore_geometries.maximize = QRect();
+    }
+
+    Q_EMIT win->quicktiling_changed();
+}
+
+}
-- 
GitLab


From 52d71a7d9f5f88a4eaeb7bd24ba770e9eae7c5ff Mon Sep 17 00:00:00 2001
From: Roman Gilg <subdiff@gmail.com>
Date: Sun, 10 Jul 2022 13:12:12 +0200
Subject: [PATCH 22/51] refactor: reimplement space quicktile window function
 as free function

This way it can be reused by different types of spaces.
---
 scripting/space.h    | 48 +++++++++++++++++++++++++++++---------------
 win/active_window.h  | 30 +++++++++++++++++++++++++++
 win/shortcuts_init.h | 28 +++++++++++---------------
 win/space.cpp        | 31 ----------------------------
 win/space.h          |  6 ------
 5 files changed, 74 insertions(+), 69 deletions(-)

diff --git a/scripting/space.h b/scripting/space.h
index b29fda213..d980ee92f 100644
--- a/scripting/space.h
+++ b/scripting/space.h
@@ -678,12 +678,6 @@ public:
         ref_space->outline->hide();
     }
 
-#define QUICKTILE_SLOT(name, modes)                                                                \
-    void name() override                                                                           \
-    {                                                                                              \
-        ref_space->quickTileWindow(modes);                                                         \
-    }
-
     void slotSwitchToNextScreen() override
     {
         win::switch_to_next_output(*ref_space);
@@ -864,16 +858,38 @@ public:
         win::active_window_to_below_desktop(*ref_space);
     }
 
-    QUICKTILE_SLOT(slotWindowQuickTileLeft, win::quicktiles::left)
-    QUICKTILE_SLOT(slotWindowQuickTileRight, win::quicktiles::right)
-    QUICKTILE_SLOT(slotWindowQuickTileTop, win::quicktiles::top)
-    QUICKTILE_SLOT(slotWindowQuickTileBottom, win::quicktiles::bottom)
-    QUICKTILE_SLOT(slotWindowQuickTileTopLeft, win::quicktiles::top | win::quicktiles::left)
-    QUICKTILE_SLOT(slotWindowQuickTileTopRight, win::quicktiles::top | win::quicktiles::right)
-    QUICKTILE_SLOT(slotWindowQuickTileBottomLeft, win::quicktiles::bottom | win::quicktiles::left)
-    QUICKTILE_SLOT(slotWindowQuickTileBottomRight, win::quicktiles::bottom | win::quicktiles::right)
-
-#undef QUICKTILE_SLOT
+    void slotWindowQuickTileLeft() override
+    {
+        win::active_window_quicktile(*ref_space, win::quicktiles::left);
+    }
+    void slotWindowQuickTileRight() override
+    {
+        win::active_window_quicktile(*ref_space, win::quicktiles::right);
+    }
+    void slotWindowQuickTileTop() override
+    {
+        win::active_window_quicktile(*ref_space, win::quicktiles::top);
+    }
+    void slotWindowQuickTileBottom() override
+    {
+        win::active_window_quicktile(*ref_space, win::quicktiles::bottom);
+    }
+    void slotWindowQuickTileTopLeft() override
+    {
+        win::active_window_quicktile(*ref_space, win::quicktiles::top | win::quicktiles::left);
+    }
+    void slotWindowQuickTileTopRight() override
+    {
+        win::active_window_quicktile(*ref_space, win::quicktiles::top | win::quicktiles::right);
+    }
+    void slotWindowQuickTileBottomLeft() override
+    {
+        win::active_window_quicktile(*ref_space, win::quicktiles::bottom | win::quicktiles::left);
+    }
+    void slotWindowQuickTileBottomRight() override
+    {
+        win::active_window_quicktile(*ref_space, win::quicktiles::bottom | win::quicktiles::right);
+    }
 
     void slotSwitchWindowUp() override
     {
diff --git a/win/active_window.h b/win/active_window.h
index 1d909de07..78915bb66 100644
--- a/win/active_window.h
+++ b/win/active_window.h
@@ -388,4 +388,34 @@ void active_window_shrink_vertical(Space& space)
     }
 }
 
+template<typename Space>
+void active_window_quicktile(Space& space, quicktiles mode)
+{
+    if (!space.active_client) {
+        return;
+    }
+
+    // If the user invokes two of these commands in a one second period, try to
+    // combine them together to enable easy and intuitive corner tiling
+    if (!space.m_quickTileCombineTimer->isActive()) {
+        space.m_quickTileCombineTimer->start(1000);
+        space.m_lastTilingMode = mode;
+    } else {
+        auto const was_left_or_right = space.m_lastTilingMode == quicktiles::left
+            || space.m_lastTilingMode == quicktiles::right;
+        auto const was_top_or_bottom = space.m_lastTilingMode == quicktiles::top
+            || space.m_lastTilingMode == quicktiles::bottom;
+
+        auto const is_left_or_right = mode == quicktiles::left || mode == quicktiles::right;
+        auto const is_top_or_bottom = mode == quicktiles::top || mode == quicktiles::bottom;
+
+        if ((was_left_or_right && is_top_or_bottom) || (was_top_or_bottom && is_left_or_right)) {
+            mode |= space.m_lastTilingMode;
+        }
+        space.m_quickTileCombineTimer->stop();
+    }
+
+    set_quicktile_mode(space.active_client, mode, true);
+}
+
 }
diff --git a/win/shortcuts_init.h b/win/shortcuts_init.h
index b76ada7ca..4868f0992 100644
--- a/win/shortcuts_init.h
+++ b/win/shortcuts_init.h
@@ -209,37 +209,33 @@ void init_shortcuts(Space& space)
     def4("Window Quick Tile Left",
          kli18n("Quick Tile Window to the Left"),
          Qt::META + Qt::Key_Left,
-         std::bind(&Space::quickTileWindow, &space, win::quicktiles::left));
+         [&space] { active_window_quicktile(space, quicktiles::left); });
     def4("Window Quick Tile Right",
          kli18n("Quick Tile Window to the Right"),
          Qt::META + Qt::Key_Right,
-         std::bind(&Space::quickTileWindow, &space, win::quicktiles::right));
+         [&space] { active_window_quicktile(space, quicktiles::right); });
     def4("Window Quick Tile Top",
          kli18n("Quick Tile Window to the Top"),
          Qt::META + Qt::Key_Up,
-         std::bind(&Space::quickTileWindow, &space, win::quicktiles::top));
+         [&space] { active_window_quicktile(space, quicktiles::top); });
     def4("Window Quick Tile Bottom",
          kli18n("Quick Tile Window to the Bottom"),
          Qt::META + Qt::Key_Down,
-         std::bind(&Space::quickTileWindow, &space, win::quicktiles::bottom));
-    def4("Window Quick Tile Top Left",
-         kli18n("Quick Tile Window to the Top Left"),
-         0,
-         std::bind(&Space::quickTileWindow, &space, win::quicktiles::top | win::quicktiles::left));
+         [&space] { active_window_quicktile(space, quicktiles::bottom); });
+    def4("Window Quick Tile Top Left", kli18n("Quick Tile Window to the Top Left"), 0, [&space] {
+        active_window_quicktile(space, quicktiles::top | quicktiles::left);
+    });
     def4("Window Quick Tile Bottom Left",
          kli18n("Quick Tile Window to the Bottom Left"),
          0,
-         std::bind(
-             &Space::quickTileWindow, &space, win::quicktiles::bottom | win::quicktiles::left));
-    def4("Window Quick Tile Top Right",
-         kli18n("Quick Tile Window to the Top Right"),
-         0,
-         std::bind(&Space::quickTileWindow, &space, win::quicktiles::top | win::quicktiles::right));
+         [&space] { active_window_quicktile(space, quicktiles::bottom | quicktiles::left); });
+    def4("Window Quick Tile Top Right", kli18n("Quick Tile Window to the Top Right"), 0, [&space] {
+        active_window_quicktile(space, quicktiles::top | quicktiles::right);
+    });
     def4("Window Quick Tile Bottom Right",
          kli18n("Quick Tile Window to the Bottom Right"),
          0,
-         std::bind(
-             &Space::quickTileWindow, &space, win::quicktiles::bottom | win::quicktiles::right));
+         [&space] { active_window_quicktile(space, quicktiles::bottom | quicktiles::right); });
     def4("Switch Window Up",
          kli18n("Switch to Window Above"),
          Qt::META + Qt::ALT + Qt::Key_Up,
diff --git a/win/space.cpp b/win/space.cpp
index ff7cd512e..ebd666d7a 100644
--- a/win/space.cpp
+++ b/win/space.cpp
@@ -991,37 +991,6 @@ std::vector<Toplevel*> space::remnants() const
 
 #ifndef KCMRULES
 
-void space::quickTileWindow(win::quicktiles mode)
-{
-    if (!active_client) {
-        return;
-    }
-
-    // If the user invokes two of these commands in a one second period, try to
-    // combine them together to enable easy and intuitive corner tiling
-    if (!m_quickTileCombineTimer->isActive()) {
-        m_quickTileCombineTimer->start(1000);
-        m_lastTilingMode = mode;
-    } else {
-        auto const was_left_or_right = m_lastTilingMode == win::quicktiles::left
-            || m_lastTilingMode == win::quicktiles::right;
-        auto const was_top_or_bottom = m_lastTilingMode == win::quicktiles::top
-            || m_lastTilingMode == win::quicktiles::bottom;
-
-        auto const is_left_or_right
-            = mode == win::quicktiles::left || mode == win::quicktiles::right;
-        auto const is_top_or_bottom
-            = mode == win::quicktiles::top || mode == win::quicktiles::bottom;
-
-        if ((was_left_or_right && is_top_or_bottom) || (was_top_or_bottom && is_left_or_right)) {
-            mode |= m_lastTilingMode;
-        }
-        m_quickTileCombineTimer->stop();
-    }
-
-    win::set_quicktile_mode(active_client, mode, true);
-}
-
 int space::packPositionLeft(Toplevel const* window, int oldX, bool leftEdge) const
 {
     int newX = space_window_area(*this, MaximizeArea, window).left();
diff --git a/win/space.h b/win/space.h
index eaeb49e59..38e366e3c 100644
--- a/win/space.h
+++ b/win/space.h
@@ -283,13 +283,9 @@ public:
 
     void updateTabbox();
 
-private:
     QTimer* m_quickTileCombineTimer{nullptr};
     win::quicktiles m_lastTilingMode{win::quicktiles::none};
 
-    //-------------------------------------------------
-    // Unsorted
-
 public:
     // True when performing space::updateClientArea().
     // The calls below are valid only in that case.
@@ -331,8 +327,6 @@ public:
      */
     bool compositing() const;
 
-    void quickTileWindow(win::quicktiles mode);
-
     win::shortcut_dialog* shortcutDialog() const
     {
         return client_keys_dialog;
-- 
GitLab


From 42507622aae287e17401351b8a9531daeaccf933 Mon Sep 17 00:00:00 2001
From: Roman Gilg <subdiff@gmail.com>
Date: Sun, 10 Jul 2022 13:49:13 +0200
Subject: [PATCH 23/51] refactor: reimplement pack position getters as free
 functions

This way they can be reused with different types of spaces.
---
 win/active_window.h |  14 ++--
 win/geo.h           |  25 ++++++
 win/geo_change.h    | 184 ++++++++++++++++++++++++++++++++++++++++++--
 win/placement.h     |  26 -------
 win/space.cpp       | 168 ----------------------------------------
 win/space.h         |   5 --
 6 files changed, 210 insertions(+), 212 deletions(-)

diff --git a/win/active_window.h b/win/active_window.h
index 78915bb66..744f63b12 100644
--- a/win/active_window.h
+++ b/win/active_window.h
@@ -313,8 +313,9 @@ void active_window_pack_left(Space& space)
         return;
     }
     auto const pos = space.active_client->geometry_update.frame.topLeft();
-    pack_to(
-        space.active_client, space.packPositionLeft(space.active_client, pos.x(), true), pos.y());
+    pack_to(space.active_client,
+            get_pack_position_left(space, space.active_client, pos.x(), true),
+            pos.y());
 }
 
 template<typename Space>
@@ -327,7 +328,7 @@ void active_window_pack_right(Space& space)
     auto const pos = space.active_client->geometry_update.frame.topLeft();
     auto const width = space.active_client->geometry_update.frame.size().width();
     pack_to(space.active_client,
-            space.packPositionRight(space.active_client, pos.x() + width, true) - width + 1,
+            get_pack_position_right(space, space.active_client, pos.x() + width, true) - width + 1,
             pos.y());
 }
 
@@ -339,7 +340,9 @@ void active_window_pack_up(Space& space)
     }
 
     auto const pos = space.active_client->geometry_update.frame.topLeft();
-    pack_to(space.active_client, pos.x(), space.packPositionUp(space.active_client, pos.y(), true));
+    pack_to(space.active_client,
+            pos.x(),
+            get_pack_position_up(space, space.active_client, pos.y(), true));
 }
 
 template<typename Space>
@@ -353,7 +356,8 @@ void active_window_pack_down(Space& space)
     auto const height = space.active_client->geometry_update.frame.size().height();
     pack_to(space.active_client,
             pos.x(),
-            space.packPositionDown(space.active_client, pos.y() + height, true) - height + 1);
+            get_pack_position_down(space, space.active_client, pos.y() + height, true) - height
+                + 1);
 }
 
 template<typename Space>
diff --git a/win/geo.h b/win/geo.h
index 555bfdf49..626660706 100644
--- a/win/geo.h
+++ b/win/geo.h
@@ -6,6 +6,7 @@
 #pragma once
 
 #include "deco.h"
+#include "net.h"
 #include "types.h"
 
 #include <QMargins>
@@ -14,6 +15,30 @@
 namespace KWin::win
 {
 
+template<typename Win1, typename Win2>
+static inline bool is_irrelevant(Win1 const* window, Win2 const* regarding, int desktop)
+{
+    if (!window) {
+        return true;
+    }
+    if (!window->control) {
+        return true;
+    }
+    if (window == regarding) {
+        return true;
+    }
+    if (!window->isShown()) {
+        return true;
+    }
+    if (!window->isOnDesktop(desktop)) {
+        return true;
+    }
+    if (is_desktop(window)) {
+        return true;
+    }
+    return false;
+}
+
 /**
  * Returns @c true if @p win is being interactively moved; otherwise @c false.
  */
diff --git a/win/geo_change.h b/win/geo_change.h
index ba22dcce0..174c6b14c 100644
--- a/win/geo_change.h
+++ b/win/geo_change.h
@@ -13,6 +13,174 @@
 namespace KWin::win
 {
 
+template<typename Space>
+int get_pack_position_left(Space const& space, Toplevel const* window, int oldX, bool leftEdge)
+{
+    int newX = space_window_area(space, MaximizeArea, window).left();
+    if (oldX <= newX) {
+        // try another Xinerama screen
+        newX = space_window_area(space,
+                                 MaximizeArea,
+                                 QPoint(window->geometry_update.frame.left() - 1,
+                                        window->geometry_update.frame.center().y()),
+                                 window->desktop())
+                   .left();
+    }
+
+    auto const right = newX - win::frame_margins(window).left();
+    auto frameGeometry = window->geometry_update.frame;
+    frameGeometry.moveRight(right);
+    if (base::get_intersecting_outputs(kwinApp()->get_base().get_outputs(), frameGeometry).size()
+        < 2) {
+        newX = right;
+    }
+
+    if (oldX <= newX) {
+        return oldX;
+    }
+
+    const int desktop = window->desktop() == 0 || window->isOnAllDesktops()
+        ? space.virtual_desktop_manager->current()
+        : window->desktop();
+    for (auto win : space.m_windows) {
+        if (is_irrelevant(win, window, desktop)) {
+            continue;
+        }
+        const int x = leftEdge ? win->geometry_update.frame.right() + 1
+                               : win->geometry_update.frame.left() - 1;
+        if (x > newX && x < oldX
+            && !(window->geometry_update.frame.top() > win->geometry_update.frame.bottom()
+                 || window->geometry_update.frame.bottom() < win->geometry_update.frame.top())) {
+            newX = x;
+        }
+    }
+    return newX;
+}
+
+template<typename Space>
+int get_pack_position_right(Space const& space, Toplevel const* window, int oldX, bool rightEdge)
+{
+    int newX = space_window_area(space, MaximizeArea, window).right();
+
+    if (oldX >= newX) {
+        // try another Xinerama screen
+        newX = space_window_area(space,
+                                 MaximizeArea,
+                                 QPoint(window->geometry_update.frame.right() + 1,
+                                        window->geometry_update.frame.center().y()),
+                                 window->desktop())
+                   .right();
+    }
+
+    auto const right = newX + win::frame_margins(window).right();
+    auto frameGeometry = window->geometry_update.frame;
+    frameGeometry.moveRight(right);
+    if (base::get_intersecting_outputs(kwinApp()->get_base().get_outputs(), frameGeometry).size()
+        < 2) {
+        newX = right;
+    }
+
+    if (oldX >= newX) {
+        return oldX;
+    }
+
+    int const desktop = window->desktop() == 0 || window->isOnAllDesktops()
+        ? space.virtual_desktop_manager->current()
+        : window->desktop();
+    for (auto win : space.m_windows) {
+        if (is_irrelevant(win, window, desktop)) {
+            continue;
+        }
+        const int x = rightEdge ? win->geometry_update.frame.left() - 1
+                                : win->geometry_update.frame.right() + 1;
+        if (x < newX && x > oldX
+            && !(window->geometry_update.frame.top() > win->geometry_update.frame.bottom()
+                 || window->geometry_update.frame.bottom() < win->geometry_update.frame.top())) {
+            newX = x;
+        }
+    }
+    return newX;
+}
+
+template<typename Space>
+int get_pack_position_up(Space const& space, Toplevel const* window, int oldY, bool topEdge)
+{
+    int newY = space_window_area(space, MaximizeArea, window).top();
+    if (oldY <= newY) {
+        // try another Xinerama screen
+        newY = space_window_area(space,
+                                 MaximizeArea,
+                                 QPoint(window->geometry_update.frame.center().x(),
+                                        window->geometry_update.frame.top() - 1),
+                                 window->desktop())
+                   .top();
+    }
+
+    if (oldY <= newY) {
+        return oldY;
+    }
+
+    int const desktop = window->desktop() == 0 || window->isOnAllDesktops()
+        ? space.virtual_desktop_manager->current()
+        : window->desktop();
+    for (auto win : space.m_windows) {
+        if (is_irrelevant(win, window, desktop)) {
+            continue;
+        }
+        const int y = topEdge ? win->geometry_update.frame.bottom() + 1
+                              : win->geometry_update.frame.top() - 1;
+        if (y > newY && y < oldY
+            && !(window->geometry_update.frame.left()
+                     > win->geometry_update.frame.right() // they overlap in X direction
+                 || window->geometry_update.frame.right() < win->geometry_update.frame.left())) {
+            newY = y;
+        }
+    }
+    return newY;
+}
+
+template<typename Space>
+int get_pack_position_down(Space const& space, Toplevel const* window, int oldY, bool bottomEdge)
+{
+    int newY = space_window_area(space, MaximizeArea, window).bottom();
+    if (oldY >= newY) { // try another Xinerama screen
+        newY = space_window_area(space,
+                                 MaximizeArea,
+                                 QPoint(window->geometry_update.frame.center().x(),
+                                        window->geometry_update.frame.bottom() + 1),
+                                 window->desktop())
+                   .bottom();
+    }
+
+    auto const bottom = newY + win::frame_margins(window).bottom();
+    auto frameGeometry = window->geometry_update.frame;
+    frameGeometry.moveBottom(bottom);
+    if (base::get_intersecting_outputs(kwinApp()->get_base().get_outputs(), frameGeometry).size()
+        < 2) {
+        newY = bottom;
+    }
+
+    if (oldY >= newY) {
+        return oldY;
+    }
+    int const desktop = window->desktop() == 0 || window->isOnAllDesktops()
+        ? space.virtual_desktop_manager->current()
+        : window->desktop();
+    for (auto win : space.m_windows) {
+        if (is_irrelevant(win, window, desktop)) {
+            continue;
+        }
+        const int y = bottomEdge ? win->geometry_update.frame.top() - 1
+                                 : win->geometry_update.frame.bottom() + 1;
+        if (y < newY && y > oldY
+            && !(window->geometry_update.frame.left() > win->geometry_update.frame.right()
+                 || window->geometry_update.frame.right() < win->geometry_update.frame.left())) {
+            newY = y;
+        }
+    }
+    return newY;
+}
+
 template<typename Win>
 QSize constrain_and_adjust_size(Win* win, QSize const& size)
 {
@@ -43,14 +211,14 @@ void grow_horizontal(Win* win)
     }
 
     auto frame_geo = win->frameGeometry();
-    frame_geo.setRight(win->space.packPositionRight(win, frame_geo.right(), true));
+    frame_geo.setRight(get_pack_position_right(win->space, win, frame_geo.right(), true));
     auto const adjsize = adjusted_frame_size(win, frame_geo.size(), size_mode::fixed_width);
 
     if (win->frameGeometry().size() == adjsize && frame_geo.size() != adjsize
         && win->resizeIncrements().width() > 1) {
         // Grow by increment.
-        auto const grown_right = win->space.packPositionRight(
-            win, frame_geo.right() + win->resizeIncrements().width() - 1, true);
+        auto const grown_right = get_pack_position_right(
+            win->space, win, frame_geo.right() + win->resizeIncrements().width() - 1, true);
 
         // Check that it hasn't grown outside of the area, due to size increments.
         // TODO this may be wrong?
@@ -80,7 +248,7 @@ void shrink_horizontal(Win* win)
     }
 
     auto geom = win->frameGeometry();
-    geom.setRight(win->space.packPositionLeft(win, geom.right(), false));
+    geom.setRight(get_pack_position_left(win->space, win, geom.right(), false));
 
     if (geom.width() <= 1) {
         return;
@@ -104,14 +272,14 @@ void grow_vertical(Win* win)
     }
 
     auto frame_geo = win->frameGeometry();
-    frame_geo.setBottom(win->space.packPositionDown(win, frame_geo.bottom(), true));
+    frame_geo.setBottom(get_pack_position_down(win->space, win, frame_geo.bottom(), true));
     auto adjsize = adjusted_frame_size(win, frame_geo.size(), size_mode::fixed_height);
 
     if (win->frameGeometry().size() == adjsize && frame_geo.size() != adjsize
         && win->resizeIncrements().height() > 1) {
         // Grow by increment.
-        auto const newbottom = win->space.packPositionDown(
-            win, frame_geo.bottom() + win->resizeIncrements().height() - 1, true);
+        auto const newbottom = get_pack_position_down(
+            win->space, win, frame_geo.bottom() + win->resizeIncrements().height() - 1, true);
 
         // check that it hasn't grown outside of the area, due to size increments
         auto const area = space_window_area(
@@ -139,7 +307,7 @@ void shrink_vertical(Win* win)
     }
 
     auto frame_geo = win->frameGeometry();
-    frame_geo.setBottom(win->space.packPositionUp(win, frame_geo.bottom(), false));
+    frame_geo.setBottom(get_pack_position_up(win->space, win, frame_geo.bottom(), false));
     if (frame_geo.height() <= 1) {
         return;
     }
diff --git a/win/placement.h b/win/placement.h
index 06036bb16..0d40e8fb0 100644
--- a/win/placement.h
+++ b/win/placement.h
@@ -51,8 +51,6 @@ namespace win
 
 template<typename Win>
 static inline bool can_move(Win const* window);
-template<typename Win1, typename Win2>
-static inline bool is_irrelevant(Win1 const* window, Win2 const* regarding, int desktop);
 
 template<typename Win>
 void place(Win* window, const QRect& area);
@@ -99,30 +97,6 @@ bool can_move(Win const* window)
     return window->isMovable();
 }
 
-template<typename Win1, typename Win2>
-static inline bool is_irrelevant(Win1 const* window, Win2 const* regarding, int desktop)
-{
-    if (!window) {
-        return true;
-    }
-    if (!window->control) {
-        return true;
-    }
-    if (window == regarding) {
-        return true;
-    }
-    if (!window->isShown()) {
-        return true;
-    }
-    if (!window->isOnDesktop(desktop)) {
-        return true;
-    }
-    if (is_desktop(window)) {
-        return true;
-    }
-    return false;
-}
-
 /**
  * Places the client \a c according to the workspace's layout policy
  */
diff --git a/win/space.cpp b/win/space.cpp
index ebd666d7a..65c0a4813 100644
--- a/win/space.cpp
+++ b/win/space.cpp
@@ -989,174 +989,6 @@ std::vector<Toplevel*> space::remnants() const
     return ret;
 }
 
-#ifndef KCMRULES
-
-int space::packPositionLeft(Toplevel const* window, int oldX, bool leftEdge) const
-{
-    int newX = space_window_area(*this, MaximizeArea, window).left();
-    if (oldX <= newX) {
-        // try another Xinerama screen
-        newX = space_window_area(*this,
-                                 MaximizeArea,
-                                 QPoint(window->geometry_update.frame.left() - 1,
-                                        window->geometry_update.frame.center().y()),
-                                 window->desktop())
-                   .left();
-    }
-
-    auto const right = newX - win::frame_margins(window).left();
-    auto frameGeometry = window->geometry_update.frame;
-    frameGeometry.moveRight(right);
-    if (base::get_intersecting_outputs(kwinApp()->get_base().get_outputs(), frameGeometry).size()
-        < 2) {
-        newX = right;
-    }
-
-    if (oldX <= newX) {
-        return oldX;
-    }
-
-    const int desktop = window->desktop() == 0 || window->isOnAllDesktops()
-        ? virtual_desktop_manager->current()
-        : window->desktop();
-    for (auto win : m_windows) {
-        if (is_irrelevant(win, window, desktop)) {
-            continue;
-        }
-        const int x = leftEdge ? win->geometry_update.frame.right() + 1
-                               : win->geometry_update.frame.left() - 1;
-        if (x > newX && x < oldX
-            && !(window->geometry_update.frame.top() > win->geometry_update.frame.bottom()
-                 || window->geometry_update.frame.bottom() < win->geometry_update.frame.top())) {
-            newX = x;
-        }
-    }
-    return newX;
-}
-
-int space::packPositionRight(Toplevel const* window, int oldX, bool rightEdge) const
-{
-    int newX = space_window_area(*this, MaximizeArea, window).right();
-
-    if (oldX >= newX) {
-        // try another Xinerama screen
-        newX = space_window_area(*this,
-                                 MaximizeArea,
-                                 QPoint(window->geometry_update.frame.right() + 1,
-                                        window->geometry_update.frame.center().y()),
-                                 window->desktop())
-                   .right();
-    }
-
-    auto const right = newX + win::frame_margins(window).right();
-    auto frameGeometry = window->geometry_update.frame;
-    frameGeometry.moveRight(right);
-    if (base::get_intersecting_outputs(kwinApp()->get_base().get_outputs(), frameGeometry).size()
-        < 2) {
-        newX = right;
-    }
-
-    if (oldX >= newX) {
-        return oldX;
-    }
-
-    const int desktop = window->desktop() == 0 || window->isOnAllDesktops()
-        ? virtual_desktop_manager->current()
-        : window->desktop();
-    for (auto win : m_windows) {
-        if (is_irrelevant(win, window, desktop)) {
-            continue;
-        }
-        const int x = rightEdge ? win->geometry_update.frame.left() - 1
-                                : win->geometry_update.frame.right() + 1;
-        if (x < newX && x > oldX
-            && !(window->geometry_update.frame.top() > win->geometry_update.frame.bottom()
-                 || window->geometry_update.frame.bottom() < win->geometry_update.frame.top())) {
-            newX = x;
-        }
-    }
-    return newX;
-}
-
-int space::packPositionUp(Toplevel const* window, int oldY, bool topEdge) const
-{
-    int newY = space_window_area(*this, MaximizeArea, window).top();
-    if (oldY <= newY) {
-        // try another Xinerama screen
-        newY = space_window_area(*this,
-                                 MaximizeArea,
-                                 QPoint(window->geometry_update.frame.center().x(),
-                                        window->geometry_update.frame.top() - 1),
-                                 window->desktop())
-                   .top();
-    }
-
-    if (oldY <= newY) {
-        return oldY;
-    }
-
-    const int desktop = window->desktop() == 0 || window->isOnAllDesktops()
-        ? virtual_desktop_manager->current()
-        : window->desktop();
-    for (auto win : m_windows) {
-        if (is_irrelevant(win, window, desktop)) {
-            continue;
-        }
-        const int y = topEdge ? win->geometry_update.frame.bottom() + 1
-                              : win->geometry_update.frame.top() - 1;
-        if (y > newY && y < oldY
-            && !(window->geometry_update.frame.left()
-                     > win->geometry_update.frame.right() // they overlap in X direction
-                 || window->geometry_update.frame.right() < win->geometry_update.frame.left())) {
-            newY = y;
-        }
-    }
-    return newY;
-}
-
-int space::packPositionDown(Toplevel const* window, int oldY, bool bottomEdge) const
-{
-    int newY = space_window_area(*this, MaximizeArea, window).bottom();
-    if (oldY >= newY) { // try another Xinerama screen
-        newY = space_window_area(*this,
-                                 MaximizeArea,
-                                 QPoint(window->geometry_update.frame.center().x(),
-                                        window->geometry_update.frame.bottom() + 1),
-                                 window->desktop())
-                   .bottom();
-    }
-
-    auto const bottom = newY + win::frame_margins(window).bottom();
-    auto frameGeometry = window->geometry_update.frame;
-    frameGeometry.moveBottom(bottom);
-    if (base::get_intersecting_outputs(kwinApp()->get_base().get_outputs(), frameGeometry).size()
-        < 2) {
-        newY = bottom;
-    }
-
-    if (oldY >= newY) {
-        return oldY;
-    }
-    const int desktop = window->desktop() == 0 || window->isOnAllDesktops()
-        ? virtual_desktop_manager->current()
-        : window->desktop();
-    for (auto win : m_windows) {
-        if (is_irrelevant(win, window, desktop)) {
-            continue;
-        }
-        const int y = bottomEdge ? win->geometry_update.frame.top() - 1
-                                 : win->geometry_update.frame.bottom() + 1;
-        if (y < newY && y > oldY
-            && !(window->geometry_update.frame.left() > win->geometry_update.frame.right()
-                 || window->geometry_update.frame.right() < win->geometry_update.frame.left())) {
-            newY = y;
-        }
-    }
-    return newY;
-}
-
-#endif
-
 /**
  * Informs the space:: that the client \a c has been hidden. If it
  * was the active client (or to-become the active client),
diff --git a/win/space.h b/win/space.h
index 38e366e3c..d49b0f73c 100644
--- a/win/space.h
+++ b/win/space.h
@@ -307,11 +307,6 @@ public:
     void setWasUserInteraction();
     bool wasUserInteraction() const;
 
-    int packPositionLeft(Toplevel const* window, int oldX, bool leftEdge) const;
-    int packPositionRight(Toplevel const* window, int oldX, bool rightEdge) const;
-    int packPositionUp(Toplevel const* window, int oldY, bool topEdge) const;
-    int packPositionDown(Toplevel const* window, int oldY, bool bottomEdge) const;
-
     /**
      * Returns a client that is currently being moved or resized by the user.
      *
-- 
GitLab


From c9d326b2dac901706002fc9663c9c8f84a633976 Mon Sep 17 00:00:00 2001
From: Roman Gilg <subdiff@gmail.com>
Date: Sun, 10 Jul 2022 14:10:06 +0200
Subject: [PATCH 24/51] refactor: reimplement space event function as free
 function

This way it can be reused by different types of spaces.
---
 main_x11.cpp          |  3 ++-
 win/space.cpp         | 29 -----------------------------
 win/space.h           |  2 --
 win/x11/space_event.h | 28 ++++++++++++++++++++++++++++
 4 files changed, 30 insertions(+), 32 deletions(-)

diff --git a/main_x11.cpp b/main_x11.cpp
index 7e16b16b5..a454591e0 100644
--- a/main_x11.cpp
+++ b/main_x11.cpp
@@ -23,6 +23,7 @@
 #include "win/shortcuts_init.h"
 #include "win/space.h"
 #include "win/x11/space.h"
+#include "win/x11/space_event.h"
 
 #include <KConfigGroup>
 #include <KCrash>
@@ -285,7 +286,7 @@ void ApplicationX11::start()
 
 bool ApplicationX11::notify(QObject* o, QEvent* e)
 {
-    if (e->spontaneous() && workspace->workspaceEvent(e)) {
+    if (e->spontaneous() && win::x11::space_qt_event(*workspace, e)) {
         return true;
     }
     return QApplication::notify(o, e);
diff --git a/win/space.cpp b/win/space.cpp
index 65c0a4813..bb4bb0175 100644
--- a/win/space.cpp
+++ b/win/space.cpp
@@ -1187,33 +1187,4 @@ void space::clientAttentionChanged(Toplevel* window, bool set)
     Q_EMIT qobject->clientDemandsAttentionChanged(window, set);
 }
 
-/// X11 event handling
-
-#ifndef XCB_GE_GENERIC
-#define XCB_GE_GENERIC 35
-typedef struct xcb_ge_generic_event_t {
-    uint8_t response_type;  /**<  */
-    uint8_t extension;      /**<  */
-    uint16_t sequence;      /**<  */
-    uint32_t length;        /**<  */
-    uint16_t event_type;    /**<  */
-    uint8_t pad0[22];       /**<  */
-    uint32_t full_sequence; /**<  */
-} xcb_ge_generic_event_t;
-#endif
-
-// Used only to filter events that need to be processed by Qt first
-// (e.g. keyboard input to be composed), otherwise events are
-// handle by the XEvent filter above
-bool space::workspaceEvent(QEvent* e)
-{
-    if ((e->type() == QEvent::KeyPress || e->type() == QEvent::KeyRelease
-         || e->type() == QEvent::ShortcutOverride)
-        && render.effects && render.effects->hasKeyboardGrab()) {
-        render.effects->grabbedKeyboardEvent(static_cast<QKeyEvent*>(e));
-        return true;
-    }
-    return false;
-}
-
 }
diff --git a/win/space.h b/win/space.h
index d49b0f73c..c833fd5eb 100644
--- a/win/space.h
+++ b/win/space.h
@@ -225,8 +225,6 @@ public:
     explicit space(render::compositor& render);
     virtual ~space();
 
-    bool workspaceEvent(QEvent*);
-
     /**
      * @brief Finds a Toplevel for the internal window @p w.
      *
diff --git a/win/x11/space_event.h b/win/x11/space_event.h
index ef49c6a68..bede70f55 100644
--- a/win/x11/space_event.h
+++ b/win/x11/space_event.h
@@ -17,6 +17,19 @@
 #include <string>
 #include <vector>
 
+#ifndef XCB_GE_GENERIC
+#define XCB_GE_GENERIC 35
+typedef struct xcb_ge_generic_event_t {
+    uint8_t response_type;  /**<  */
+    uint8_t extension;      /**<  */
+    uint16_t sequence;      /**<  */
+    uint32_t length;        /**<  */
+    uint16_t event_type;    /**<  */
+    uint8_t pad0[22];       /**<  */
+    uint32_t full_sequence; /**<  */
+} xcb_ge_generic_event_t;
+#endif
+
 namespace KWin::win::x11
 {
 
@@ -328,4 +341,19 @@ bool space_event(Space& space, xcb_generic_event_t* event)
     return false;
 }
 
+// Used only to filter events that need to be processed by Qt first
+// (e.g. keyboard input to be composed), otherwise events are
+// handle by the XEvent filter above.
+template<typename Space>
+bool space_qt_event(Space& space, QEvent* event)
+{
+    auto is_key_event = event->type() == QEvent::KeyPress || event->type() == QEvent::KeyRelease
+        || event->type() == QEvent::ShortcutOverride;
+    if (is_key_event && space.render.effects && space.render.effects->hasKeyboardGrab()) {
+        space.render.effects->grabbedKeyboardEvent(static_cast<QKeyEvent*>(event));
+        return true;
+    }
+    return false;
+}
+
 }
-- 
GitLab


From 32dd67369462fd635e74a65d3bc3df715a5c2326 Mon Sep 17 00:00:00 2001
From: Roman Gilg <subdiff@gmail.com>
Date: Sun, 10 Jul 2022 23:22:12 +0200
Subject: [PATCH 25/51] refactor: make focus stealing protection levels an enum
 class

Handle FSP levels internally as enum class to improve type safety. For applying
rules we add a helper function to handle the FSP and FPP value checks via enum
index casts.
---
 base/options.cpp       | 18 +++++++++++-----
 base/options.h         |  9 ++++----
 rules/rules.cpp        | 26 +++++++++++++++++++----
 rules/rules.h          |  7 +++++--
 rules/window_rules.cpp |  4 ++--
 rules/window_rules.h   |  4 ++--
 win/space.cpp          | 47 +++++++++++++++++++++++++++---------------
 win/types.h            |  9 ++++++++
 win/x11/control.h      |  4 ++--
 9 files changed, 90 insertions(+), 38 deletions(-)

diff --git a/base/options.cpp b/base/options.cpp
index 88e073e7a..b6a4c019e 100644
--- a/base/options.cpp
+++ b/base/options.cpp
@@ -17,6 +17,7 @@
 #ifndef KCMRULES
 #include "main.h"
 #include "options_settings.h"
+#include "utils/algorithm.h"
 
 #include <kwingl/platform.h>
 
@@ -99,7 +100,6 @@ options::options()
     , m_centerSnapZone(0)
     , m_snapOnlyWhenOverlapping(false)
     , m_rollOverDesktops(false)
-    , m_focusStealingPreventionLevel(0)
     , m_killPingTimeout(0)
     , m_hideUtilityWindowsForInactive(false)
     , m_compositingMode(options::defaultCompositingMode())
@@ -299,15 +299,22 @@ void options::setRollOverDesktops(bool rollOverDesktops)
     Q_EMIT rollOverDesktopsChanged(m_rollOverDesktops);
 }
 
-void options::setFocusStealingPreventionLevel(int focusStealingPreventionLevel)
+void options::setFocusStealingPreventionLevel(win::fsp_level focusStealingPreventionLevel)
 {
     if (!focusPolicyIsReasonable()) {
-        focusStealingPreventionLevel = 0;
+        focusStealingPreventionLevel = win::fsp_level::none;
     }
     if (m_focusStealingPreventionLevel == focusStealingPreventionLevel) {
         return;
     }
-    m_focusStealingPreventionLevel = qMax(0, qMin(4, focusStealingPreventionLevel));
+
+    if (enum_index(focusStealingPreventionLevel) > enum_index(win::fsp_level::extreme)) {
+        focusStealingPreventionLevel = win::fsp_level::extreme;
+    }
+    if (enum_index(focusStealingPreventionLevel) < enum_index(win::fsp_level::none)) {
+        focusStealingPreventionLevel = win::fsp_level::none;
+    }
+
     Q_EMIT focusStealingPreventionLevelChanged();
 }
 
@@ -774,7 +781,8 @@ void options::syncFromKcfgc()
     setSeparateScreenFocus(m_settings->separateScreenFocus());
     current_output_follows_mouse = m_settings->activeMouseScreen();
     setRollOverDesktops(m_settings->rollOverDesktops());
-    setFocusStealingPreventionLevel(m_settings->focusStealingPreventionLevel());
+    setFocusStealingPreventionLevel(
+        static_cast<win::fsp_level>(m_settings->focusStealingPreventionLevel()));
 
 #if KWIN_BUILD_DECORATIONS
     setPlacement(static_cast<win::placement>(m_settings->placement()));
diff --git a/base/options.h b/base/options.h
index 10db09203..976a8b6ad 100644
--- a/base/options.h
+++ b/base/options.h
@@ -106,7 +106,7 @@ class KWIN_EXPORT options : public QObject
     /**
      * 0 - 4 , see Workspace::allowClientActivation()
      */
-    Q_PROPERTY(int focusStealingPreventionLevel READ focusStealingPreventionLevel WRITE
+    Q_PROPERTY(win::fsp_level focusStealingPreventionLevel READ focusStealingPreventionLevel WRITE
                    setFocusStealingPreventionLevel NOTIFY focusStealingPreventionLevelChanged)
     Q_PROPERTY(KWin::base::options::WindowOperation operationTitlebarDblClick READ
                    operationTitlebarDblClick WRITE setOperationTitlebarDblClick NOTIFY
@@ -355,7 +355,7 @@ public:
      *
      * @see allowClientActivation
      */
-    int focusStealingPreventionLevel() const
+    win::fsp_level focusStealingPreventionLevel() const
     {
         return m_focusStealingPreventionLevel;
     }
@@ -661,7 +661,7 @@ public:
     void setCenterSnapZone(int centerSnapZone);
     void setSnapOnlyWhenOverlapping(bool snapOnlyWhenOverlapping);
     void setRollOverDesktops(bool rollOverDesktops);
-    void setFocusStealingPreventionLevel(int focusStealingPreventionLevel);
+    void setFocusStealingPreventionLevel(win::fsp_level focusStealingPreventionLevel);
     void setOperationTitlebarDblClick(WindowOperation operationTitlebarDblClick);
     void setOperationMaxButtonLeftClick(WindowOperation op);
     void setOperationMaxButtonRightClick(WindowOperation op);
@@ -908,7 +908,7 @@ private:
     int m_centerSnapZone;
     bool m_snapOnlyWhenOverlapping;
     bool m_rollOverDesktops;
-    int m_focusStealingPreventionLevel;
+    win::fsp_level m_focusStealingPreventionLevel{win::fsp_level::none};
     int m_killPingTimeout;
     bool m_hideUtilityWindowsForInactive;
 
@@ -963,4 +963,5 @@ private:
 
 Q_DECLARE_METATYPE(KWin::base::options::WindowOperation)
 Q_DECLARE_METATYPE(KWin::OpenGLPlatformInterface)
+Q_DECLARE_METATYPE(KWin::win::fsp_level)
 Q_DECLARE_METATYPE(KWin::win::placement)
diff --git a/rules/rules.cpp b/rules/rules.cpp
index e67a5fc51..2b5557bdf 100644
--- a/rules/rules.cpp
+++ b/rules/rules.cpp
@@ -700,14 +700,32 @@ bool Rules::applyBlockCompositing(bool& block) const
     return apply_force(block, this->blockcompositing);
 }
 
-bool Rules::applyFSP(int& fsp) const
+template<typename T>
+bool Rules::apply_force_enum(force_ruler<int> const& ruler, T& apply, T min, T max) const
 {
-    return apply_force(fsp, this->fsplevel);
+    auto setting = static_cast<int>(apply);
+    if (!apply_force(setting, ruler)) {
+        return false;
+    }
+
+    // Note: this does include the max item, so doesn't work for enums with "count" as last element.
+    if (setting < enum_index(min) || setting > enum_index(max)) {
+        // Loaded value is out of bounds.
+        return false;
+    }
+
+    apply = static_cast<win::fsp_level>(setting);
+    return true;
+}
+
+bool Rules::applyFSP(win::fsp_level& fsp) const
+{
+    return apply_force_enum(fsplevel, fsp, win::fsp_level::none, win::fsp_level::extreme);
 }
 
-bool Rules::applyFPP(int& fpp) const
+bool Rules::applyFPP(win::fsp_level& fpp) const
 {
-    return apply_force(fpp, this->fpplevel);
+    return apply_force_enum(fpplevel, fpp, win::fsp_level::none, win::fsp_level::extreme);
 }
 
 bool Rules::applyAcceptFocus(bool& focus) const
diff --git a/rules/rules.h b/rules/rules.h
index 61b863ca6..5439288bb 100644
--- a/rules/rules.h
+++ b/rules/rules.h
@@ -125,8 +125,8 @@ public:
     bool applyNoBorder(bool& noborder, bool init) const;
     bool applyDecoColor(QString& schemeFile) const;
     bool applyBlockCompositing(bool& block) const;
-    bool applyFSP(int& fsp) const;
-    bool applyFPP(int& fpp) const;
+    bool applyFSP(win::fsp_level& fsp) const;
+    bool applyFPP(win::fsp_level& fpp) const;
     bool applyAcceptFocus(bool& focus) const;
     bool applyCloseable(bool& closeable) const;
     bool applyAutogrouping(bool& autogroup) const;
@@ -154,6 +154,9 @@ private:
     static bool checkForceStop(force_rule rule);
 #endif
 
+    template<typename T>
+    bool apply_force_enum(force_ruler<int> const& ruler, T& apply, T min, T max) const;
+
     template<typename T>
     bool apply_set(T& target, set_ruler<T> const& ruler, bool init) const
     {
diff --git a/rules/window_rules.cpp b/rules/window_rules.cpp
index 53f529719..ea082eee4 100644
--- a/rules/window_rules.cpp
+++ b/rules/window_rules.cpp
@@ -199,12 +199,12 @@ bool WindowRules::checkBlockCompositing(bool block) const
     return check_force(block, &Rules::applyBlockCompositing);
 }
 
-int WindowRules::checkFSP(int fsp) const
+win::fsp_level WindowRules::checkFSP(win::fsp_level fsp) const
 {
     return check_force(fsp, &Rules::applyFSP);
 }
 
-int WindowRules::checkFPP(int fpp) const
+win::fsp_level WindowRules::checkFPP(win::fsp_level fpp) const
 {
     return check_force(fpp, &Rules::applyFPP);
 }
diff --git a/rules/window_rules.h b/rules/window_rules.h
index 5f43491e6..3a5ce94c8 100644
--- a/rules/window_rules.h
+++ b/rules/window_rules.h
@@ -75,8 +75,8 @@ public:
     bool checkNoBorder(bool noborder, bool init = false) const;
     QString checkDecoColor(QString schemeFile) const;
     bool checkBlockCompositing(bool block) const;
-    int checkFSP(int fsp) const;
-    int checkFPP(int fpp) const;
+    win::fsp_level checkFSP(win::fsp_level fsp) const;
+    win::fsp_level checkFPP(win::fsp_level fpp) const;
     bool checkAcceptFocus(bool focus) const;
     bool checkCloseable(bool closeable) const;
     bool checkAutogrouping(bool autogroup) const;
diff --git a/win/space.cpp b/win/space.cpp
index bb4bb0175..7f7a43a26 100644
--- a/win/space.cpp
+++ b/win/space.cpp
@@ -1023,11 +1023,6 @@ void space::setShouldGetFocus(Toplevel* window)
     stacking_order->update_order();
 }
 
-namespace FSP
-{
-enum Level { None = 0, Low, Medium, High, Extreme };
-}
-
 // focus_in -> the window got FocusIn event
 // ignore_desktop - call comes from _NET_ACTIVE_WINDOW message, don't refuse just because of window
 //     is on a different desktop
@@ -1048,11 +1043,15 @@ bool space::allowClientActivation(Toplevel const* window,
     if (time == -1U) {
         time = window->userTime();
     }
+
     auto level
         = window->control->rules().checkFSP(kwinApp()->options->focusStealingPreventionLevel());
-    if (session_manager->state() == SessionState::Saving && level <= FSP::Medium) { // <= normal
+    if (session_manager->state() == SessionState::Saving
+        && enum_index(level) <= enum_index(fsp_level::medium)) {
+        // <= normal
         return true;
     }
+
     auto ac = most_recently_activated_window(*this);
     if (focus_in) {
         if (std::find(
@@ -1069,14 +1068,15 @@ bool space::allowClientActivation(Toplevel const* window,
         if (!window->control->rules().checkAcceptFocus(false))
             return false;
     }
-    const int protection = ac ? ac->control->rules().checkFPP(2) : 0;
+
+    auto const protection = ac ? ac->control->rules().checkFPP(fsp_level::medium) : fsp_level::none;
 
     // stealing is unconditionally allowed (NETWM behavior)
-    if (level == FSP::None || protection == FSP::None)
+    if (level == fsp_level::none || protection == fsp_level::none)
         return true;
 
     // The active client "grabs" the focus or stealing is generally forbidden
-    if (level == FSP::Extreme || protection == FSP::Extreme)
+    if (level == fsp_level::extreme || protection == fsp_level::extreme)
         return false;
 
     // Desktop switching is only allowed in the "no protection" case
@@ -1096,7 +1096,7 @@ bool space::allowClientActivation(Toplevel const* window,
     // Unconditionally allow intra-client passing around for lower stealing protections
     // unless the active client has High interest
     if (win::belong_to_same_client(window, ac, win::same_client_check::relaxed_for_active)
-        && protection < FSP::High) {
+        && protection < fsp_level::high) {
         qCDebug(KWIN_CORE) << "Activation: Belongs to active application";
         return true;
     }
@@ -1108,13 +1108,13 @@ bool space::allowClientActivation(Toplevel const* window,
     }
 
     // High FPS, not intr-client change. Only allow if the active client has only minor interest
-    if (level > FSP::Medium && protection > FSP::Low)
+    if (level > fsp_level::medium && protection > fsp_level::low)
         return false;
 
     if (time == -1U) { // no time known
         qCDebug(KWIN_CORE) << "Activation: No timestamp at all";
         // Only allow for Low protection unless active client has High interest in focus
-        if (level < FSP::Medium && protection < FSP::High)
+        if (level < fsp_level::medium && protection < fsp_level::high)
             return true;
         // no timestamp at all, don't activate - because there's also creation timestamp
         // done on CreateNotify, this case should happen only in case application
@@ -1122,7 +1122,7 @@ bool space::allowClientActivation(Toplevel const* window,
         return false;
     }
 
-    // Low or medium FSP, usertime comparism is possible
+    // Low or medium FSP level, usertime comparism is possible
     const xcb_timestamp_t user_time = ac->userTime();
     qCDebug(KWIN_CORE) << "Activation, compared:" << window << ":" << time << ":" << user_time
                        << ":" << (NET::timestampCompare(time, user_time) >= 0);
@@ -1137,28 +1137,41 @@ bool space::allowFullClientRaising(Toplevel const* window, xcb_timestamp_t time)
 {
     auto level
         = window->control->rules().checkFSP(kwinApp()->options->focusStealingPreventionLevel());
-    if (session_manager->state() == SessionState::Saving && level <= 2) { // <= normal
+    if (session_manager->state() == SessionState::Saving
+        && enum_index(level) <= enum_index(fsp_level::medium)) {
+        // <= normal
         return true;
     }
+
     auto ac = most_recently_activated_window(*this);
-    if (level == 0) // none
+
+    if (level == fsp_level::none) {
         return true;
-    if (level == 4) // extreme
+    }
+    if (level == fsp_level::extreme) {
+        // extreme
         return false;
+    }
+
     if (ac == nullptr || win::is_desktop(ac)) {
         qCDebug(KWIN_CORE) << "Raising: No client active, allowing";
         return true; // no active client -> always allow
     }
+
     // TODO window urgency  -> return true?
     if (win::belong_to_same_client(window, ac, win::same_client_check::relaxed_for_active)) {
         qCDebug(KWIN_CORE) << "Raising: Belongs to active application";
         return true;
     }
-    if (level == 3) // high
+
+    if (level == fsp_level::high) {
         return false;
+    }
+
     xcb_timestamp_t user_time = ac->userTime();
     qCDebug(KWIN_CORE) << "Raising, compared:" << time << ":" << user_time << ":"
                        << (NET::timestampCompare(time, user_time) >= 0);
+
     return NET::timestampCompare(time, user_time) >= 0; // time >= user_time
 }
 
diff --git a/win/types.h b/win/types.h
index 5d58a6937..c19d9e613 100644
--- a/win/types.h
+++ b/win/types.h
@@ -119,6 +119,15 @@ enum class focus_chain_change {
     update,
 };
 
+/// Focus Stealing Prevention Levels
+enum class fsp_level {
+    none = 0,
+    low,
+    medium,
+    high,
+    extreme,
+};
+
 }
 
 ENUM_FLAGS(KWin::win::position)
diff --git a/win/x11/control.h b/win/x11/control.h
index 398a0bb24..a605cb6e7 100644
--- a/win/x11/control.h
+++ b/win/x11/control.h
@@ -849,8 +849,8 @@ xcb_timestamp_t read_user_time_map_timestamp(Win* win,
             }
             // don't refuse if focus stealing prevention is turned off
             if (!first_window
-                && win->control->rules().checkFSP(
-                       kwinApp()->options->focusStealingPreventionLevel())
+                && enum_index(win->control->rules().checkFSP(
+                       kwinApp()->options->focusStealingPreventionLevel()))
                     > 0) {
                 qCDebug(KWIN_CORE) << "User timestamp, already exists:" << 0;
                 return 0; // refuse activation
-- 
GitLab


From 8481690eead42c772b294bcfecbc4add0ff42ea6 Mon Sep 17 00:00:00 2001
From: Roman Gilg <subdiff@gmail.com>
Date: Mon, 11 Jul 2022 10:32:32 +0200
Subject: [PATCH 26/51] refactor: remove clientAttentionChanged function

It's called only once. Have the logic there instead directly.
---
 win/activation.h | 7 ++++++-
 win/space.cpp    | 9 ---------
 win/space.h      | 1 -
 3 files changed, 6 insertions(+), 11 deletions(-)

diff --git a/win/activation.h b/win/activation.h
index d8fe953f3..a0c012fe0 100644
--- a/win/activation.h
+++ b/win/activation.h
@@ -319,7 +319,12 @@ void set_demands_attention(Win* win, bool demand)
         win->info->setState(demand ? NET::DemandsAttention : NET::States(), NET::DemandsAttention);
     }
 
-    win->space.clientAttentionChanged(win, demand);
+    remove_all(win->space.attention_chain, win);
+    if (demand) {
+        win->space.attention_chain.push_front(win);
+    }
+
+    Q_EMIT win->space.qobject->clientDemandsAttentionChanged(win, demand);
     Q_EMIT win->demandsAttentionChanged();
 }
 
diff --git a/win/space.cpp b/win/space.cpp
index 7f7a43a26..f2e109eb3 100644
--- a/win/space.cpp
+++ b/win/space.cpp
@@ -1191,13 +1191,4 @@ void space::restoreFocus()
     }
 }
 
-void space::clientAttentionChanged(Toplevel* window, bool set)
-{
-    remove_all(attention_chain, window);
-    if (set) {
-        attention_chain.push_front(window);
-    }
-    Q_EMIT qobject->clientDemandsAttentionChanged(window, set);
-}
-
 }
diff --git a/win/space.h b/win/space.h
index c833fd5eb..c91774f46 100644
--- a/win/space.h
+++ b/win/space.h
@@ -266,7 +266,6 @@ public:
     std::unique_ptr<win::session_manager> session_manager;
 
     void clientHidden(Toplevel* window);
-    void clientAttentionChanged(Toplevel* window, bool set);
 
     std::vector<Toplevel*> const& windows() const;
 
-- 
GitLab


From 61a70b015fcd21cd79affc795ce08bdf9e75d098 Mon Sep 17 00:00:00 2001
From: Roman Gilg <subdiff@gmail.com>
Date: Mon, 11 Jul 2022 11:06:03 +0200
Subject: [PATCH 27/51] refactor: remove space focus functions

These functions are only called each once from X11 code. Put the logic there
directly.
---
 win/space.cpp      | 37 -------------------------------------
 win/space.h        |  3 ---
 win/x11/event.h    | 26 +++++++++++++++++++++++---
 win/x11/window.cpp |  6 +++++-
 4 files changed, 28 insertions(+), 44 deletions(-)

diff --git a/win/space.cpp b/win/space.cpp
index f2e109eb3..5f5af4212 100644
--- a/win/space.cpp
+++ b/win/space.cpp
@@ -1002,27 +1002,6 @@ void space::clientHidden(Toplevel* window)
     activate_next_window(*this, window);
 }
 
-void space::gotFocusIn(Toplevel const* window)
-{
-    if (std::find(should_get_focus.cbegin(), should_get_focus.cend(), const_cast<Toplevel*>(window))
-        != should_get_focus.cend()) {
-        // remove also all sooner elements that should have got FocusIn,
-        // but didn't for some reason (and also won't anymore, because they were sooner)
-        while (should_get_focus.front() != window) {
-            should_get_focus.pop_front();
-        }
-        should_get_focus.pop_front(); // remove 'c'
-    }
-}
-
-void space::setShouldGetFocus(Toplevel* window)
-{
-    should_get_focus.push_back(window);
-
-    // e.g. fullscreens have different layer when active/not-active
-    stacking_order->update_order();
-}
-
 // focus_in -> the window got FocusIn event
 // ignore_desktop - call comes from _NET_ACTIVE_WINDOW message, don't refuse just because of window
 //     is on a different desktop
@@ -1175,20 +1154,4 @@ bool space::allowFullClientRaising(Toplevel const* window, xcb_timestamp_t time)
     return NET::timestampCompare(time, user_time) >= 0; // time >= user_time
 }
 
-// called from Client after FocusIn that wasn't initiated by KWin and the client
-// wasn't allowed to activate
-void space::restoreFocus()
-{
-    // this updateXTime() is necessary - as FocusIn events don't have
-    // a timestamp *sigh*, kwin's timestamp would be older than the timestamp
-    // that was used by whoever caused the focus change, and therefore
-    // the attempt to restore the focus would fail due to old timestamp
-    kwinApp()->update_x11_time_from_clock();
-    if (should_get_focus.size() > 0) {
-        request_focus(*this, should_get_focus.back());
-    } else if (last_active_client) {
-        request_focus(*this, last_active_client);
-    }
-}
-
 }
diff --git a/win/space.h b/win/space.h
index c91774f46..99b9ca363 100644
--- a/win/space.h
+++ b/win/space.h
@@ -241,9 +241,6 @@ public:
                                xcb_timestamp_t time = -1U,
                                bool focus_in = false,
                                bool ignore_desktop = false);
-    void restoreFocus();
-    void gotFocusIn(Toplevel const* window);
-    void setShouldGetFocus(Toplevel* window);
 
     QPoint
     adjustClientPosition(Toplevel* window, QPoint pos, bool unrestricted, double snapAdjust = 1.0);
diff --git a/win/x11/event.h b/win/x11/event.h
index cd1d7296a..7748258b4 100644
--- a/win/x11/event.h
+++ b/win/x11/event.h
@@ -884,12 +884,32 @@ void focus_in_event(Win* win, xcb_focus_in_event_t* e)
     // check if this client is in should_get_focus list or if activation is allowed
     bool activate = win->space.allowClientActivation(win, -1U, true);
 
-    // remove from should_get_focus list
-    win->space.gotFocusIn(win);
+    // Remove from should_get_focus list.
+    if (auto& sgf = win->space.should_get_focus; contains(sgf, win)) {
+        // Remove also all sooner elements that should have got FocusIn, but didn't for some reason
+        // (and also won't anymore, because they were sooner).
+        while (sgf.front() != win) {
+            sgf.pop_front();
+        }
+
+        // Finally remove 'win'.
+        sgf.pop_front();
+    }
+
     if (activate) {
         win::set_active(win, true);
     } else {
-        win->space.restoreFocus();
+        // this updateXTime() is necessary - as FocusIn events don't have
+        // a timestamp *sigh*, kwin's timestamp would be older than the timestamp
+        // that was used by whoever caused the focus change, and therefore
+        // the attempt to restore the focus would fail due to old timestamp
+        kwinApp()->update_x11_time_from_clock();
+        if (win->space.should_get_focus.size() > 0) {
+            request_focus(win->space, win->space.should_get_focus.back());
+        } else if (win->space.last_active_client) {
+            request_focus(win->space, win->space.last_active_client);
+        }
+
         win::set_demands_attention(win, true);
     }
 }
diff --git a/win/x11/window.cpp b/win/x11/window.cpp
index 24047fa18..160f91472 100644
--- a/win/x11/window.cpp
+++ b/win/x11/window.cpp
@@ -521,7 +521,11 @@ void window::takeFocus()
         send_client_message(xcb_window, space.atoms->wm_protocols, space.atoms->wm_take_focus);
     }
 
-    space.setShouldGetFocus(this);
+    space.should_get_focus.push_back(this);
+
+    // E.g. fullscreens have different layer when active/not-active.
+    space.stacking_order->update_order();
+
     auto breakShowingDesktop = !control->keep_above();
 
     if (breakShowingDesktop) {
-- 
GitLab


From f2802fb853ae4a0f939946e6087b9b09ab202c6b Mon Sep 17 00:00:00 2001
From: Roman Gilg <subdiff@gmail.com>
Date: Mon, 11 Jul 2022 12:52:02 +0200
Subject: [PATCH 28/51] refactor: reimplement focus stealing prevention
 functions as free functions

This way they can be reused by different types of spaces. They are only
relevant on X11 though at the moment, so move them to the win::x11 namespace.
---
 win/space.cpp            | 152 --------------------------------
 win/space.h              |   8 --
 win/x11/control.h        |   5 +-
 win/x11/event.h          |   5 +-
 win/x11/focus_stealing.h | 186 +++++++++++++++++++++++++++++++++++++++
 win/x11/netinfo.cpp      |   7 +-
 win/x11/stacking.h       |   3 +-
 win/x11/startup_info.h   |   4 +-
 8 files changed, 202 insertions(+), 168 deletions(-)
 create mode 100644 win/x11/focus_stealing.h

diff --git a/win/space.cpp b/win/space.cpp
index 5f5af4212..5e5e1e65b 100644
--- a/win/space.cpp
+++ b/win/space.cpp
@@ -1002,156 +1002,4 @@ void space::clientHidden(Toplevel* window)
     activate_next_window(*this, window);
 }
 
-// focus_in -> the window got FocusIn event
-// ignore_desktop - call comes from _NET_ACTIVE_WINDOW message, don't refuse just because of window
-//     is on a different desktop
-bool space::allowClientActivation(Toplevel const* window,
-                                  xcb_timestamp_t time,
-                                  bool focus_in,
-                                  bool ignore_desktop)
-{
-    // kwinApp()->options->focusStealingPreventionLevel :
-    // 0 - none    - old KWin behaviour, new windows always get focus
-    // 1 - low     - focus stealing prevention is applied normally, when unsure, activation is
-    // allowed 2 - normal  - focus stealing prevention is applied normally, when unsure, activation
-    // is not allowed,
-    //              this is the default
-    // 3 - high    - new window gets focus only if it belongs to the active application,
-    //              or when no window is currently active
-    // 4 - extreme - no window gets focus without user intervention
-    if (time == -1U) {
-        time = window->userTime();
-    }
-
-    auto level
-        = window->control->rules().checkFSP(kwinApp()->options->focusStealingPreventionLevel());
-    if (session_manager->state() == SessionState::Saving
-        && enum_index(level) <= enum_index(fsp_level::medium)) {
-        // <= normal
-        return true;
-    }
-
-    auto ac = most_recently_activated_window(*this);
-    if (focus_in) {
-        if (std::find(
-                should_get_focus.cbegin(), should_get_focus.cend(), const_cast<Toplevel*>(window))
-            != should_get_focus.cend()) {
-            // FocusIn was result of KWin's action
-            return true;
-        }
-        // Before getting FocusIn, the active Client already
-        // got FocusOut, and therefore got deactivated.
-        ac = last_active_client;
-    }
-    if (time == 0) { // explicitly asked not to get focus
-        if (!window->control->rules().checkAcceptFocus(false))
-            return false;
-    }
-
-    auto const protection = ac ? ac->control->rules().checkFPP(fsp_level::medium) : fsp_level::none;
-
-    // stealing is unconditionally allowed (NETWM behavior)
-    if (level == fsp_level::none || protection == fsp_level::none)
-        return true;
-
-    // The active client "grabs" the focus or stealing is generally forbidden
-    if (level == fsp_level::extreme || protection == fsp_level::extreme)
-        return false;
-
-    // Desktop switching is only allowed in the "no protection" case
-    if (!ignore_desktop && !window->isOnCurrentDesktop())
-        return false; // allow only with level == 0
-
-    // No active client, it's ok to pass focus
-    // NOTICE that extreme protection needs to be handled before to allow protection on unmanged
-    // windows
-    if (ac == nullptr || win::is_desktop(ac)) {
-        qCDebug(KWIN_CORE) << "Activation: No client active, allowing";
-        return true; // no active client -> always allow
-    }
-
-    // TODO window urgency  -> return true?
-
-    // Unconditionally allow intra-client passing around for lower stealing protections
-    // unless the active client has High interest
-    if (win::belong_to_same_client(window, ac, win::same_client_check::relaxed_for_active)
-        && protection < fsp_level::high) {
-        qCDebug(KWIN_CORE) << "Activation: Belongs to active application";
-        return true;
-    }
-
-    if (!window->isOnCurrentDesktop()) {
-        // we allowed explicit self-activation across virtual desktops
-        // inside a client or if no client was active, but not otherwise
-        return false;
-    }
-
-    // High FPS, not intr-client change. Only allow if the active client has only minor interest
-    if (level > fsp_level::medium && protection > fsp_level::low)
-        return false;
-
-    if (time == -1U) { // no time known
-        qCDebug(KWIN_CORE) << "Activation: No timestamp at all";
-        // Only allow for Low protection unless active client has High interest in focus
-        if (level < fsp_level::medium && protection < fsp_level::high)
-            return true;
-        // no timestamp at all, don't activate - because there's also creation timestamp
-        // done on CreateNotify, this case should happen only in case application
-        // maps again already used window, i.e. this won't happen after app startup
-        return false;
-    }
-
-    // Low or medium FSP level, usertime comparism is possible
-    const xcb_timestamp_t user_time = ac->userTime();
-    qCDebug(KWIN_CORE) << "Activation, compared:" << window << ":" << time << ":" << user_time
-                       << ":" << (NET::timestampCompare(time, user_time) >= 0);
-    return NET::timestampCompare(time, user_time) >= 0; // time >= user_time
-}
-
-// basically the same like allowClientActivation(), this time allowing
-// a window to be fully raised upon its own request (XRaiseWindow),
-// if refused, it will be raised only on top of windows belonging
-// to the same application
-bool space::allowFullClientRaising(Toplevel const* window, xcb_timestamp_t time)
-{
-    auto level
-        = window->control->rules().checkFSP(kwinApp()->options->focusStealingPreventionLevel());
-    if (session_manager->state() == SessionState::Saving
-        && enum_index(level) <= enum_index(fsp_level::medium)) {
-        // <= normal
-        return true;
-    }
-
-    auto ac = most_recently_activated_window(*this);
-
-    if (level == fsp_level::none) {
-        return true;
-    }
-    if (level == fsp_level::extreme) {
-        // extreme
-        return false;
-    }
-
-    if (ac == nullptr || win::is_desktop(ac)) {
-        qCDebug(KWIN_CORE) << "Raising: No client active, allowing";
-        return true; // no active client -> always allow
-    }
-
-    // TODO window urgency  -> return true?
-    if (win::belong_to_same_client(window, ac, win::same_client_check::relaxed_for_active)) {
-        qCDebug(KWIN_CORE) << "Raising: Belongs to active application";
-        return true;
-    }
-
-    if (level == fsp_level::high) {
-        return false;
-    }
-
-    xcb_timestamp_t user_time = ac->userTime();
-    qCDebug(KWIN_CORE) << "Raising, compared:" << time << ":" << user_time << ":"
-                       << (NET::timestampCompare(time, user_time) >= 0);
-
-    return NET::timestampCompare(time, user_time) >= 0; // time >= user_time
-}
-
 }
diff --git a/win/space.h b/win/space.h
index 99b9ca363..42127f1f3 100644
--- a/win/space.h
+++ b/win/space.h
@@ -237,18 +237,10 @@ public:
 
     bool initializing() const;
 
-    bool allowClientActivation(Toplevel const* window,
-                               xcb_timestamp_t time = -1U,
-                               bool focus_in = false,
-                               bool ignore_desktop = false);
-
     QPoint
     adjustClientPosition(Toplevel* window, QPoint pos, bool unrestricted, double snapAdjust = 1.0);
     QRect adjustClientSize(Toplevel* window, QRect moveResizeGeom, win::position mode);
 
-    // used by layers.cpp, defined in activation.cpp
-    bool allowFullClientRaising(Toplevel const* c, xcb_timestamp_t timestamp);
-
     /**
      * Most recently raised window.
      *
diff --git a/win/x11/control.h b/win/x11/control.h
index a605cb6e7..201cc7435 100644
--- a/win/x11/control.h
+++ b/win/x11/control.h
@@ -11,6 +11,7 @@
 #include "client_machine.h"
 #include "command.h"
 #include "deco.h"
+#include "focus_stealing.h"
 #include "placement.h"
 #include "session.h"
 #include "user_time.h"
@@ -696,7 +697,7 @@ auto create_controlled_window(xcb_window_t xcb_win, bool isMapped, Space& space)
                 && (!space.wasUserInteraction() || !space.active_client
                     || is_desktop(space.active_client));
         } else {
-            allow = space.allowClientActivation(win, win->userTime(), false);
+            allow = allow_window_activation(space, win, win->userTime(), false);
         }
 
         auto const isSessionSaving = space.session_manager->state() == SessionState::Saving;
@@ -859,7 +860,7 @@ xcb_timestamp_t read_user_time_map_timestamp(Win* win,
         // Creation time would just mess things up during session startup,
         // as possibly many apps are started up at the same time.
         // If there's no active window yet, no timestamp will be needed,
-        // as plain Workspace::allowClientActivation() will return true
+        // as plain allow_window_activation() will return true
         // in such case. And if there's already active window,
         // it's better not to activate the new one.
         // Unless it was the active window at the time
diff --git a/win/x11/event.h b/win/x11/event.h
index 7748258b4..30ab11c3a 100644
--- a/win/x11/event.h
+++ b/win/x11/event.h
@@ -8,6 +8,7 @@
 #include "actions.h"
 #include "activation.h"
 #include "client.h"
+#include "focus_stealing.h"
 #include "geo.h"
 #include "meta.h"
 #include "stacking.h"
@@ -354,7 +355,7 @@ bool map_request_event(Win* win, xcb_map_request_event_t* e)
         win::set_minimized(win, false);
     }
     if (!win->isOnCurrentDesktop()) {
-        if (win->space.allowClientActivation(win)) {
+        if (allow_window_activation(win->space, win)) {
             activate_window(win->space, win);
         } else {
             win::set_demands_attention(win, true);
@@ -882,7 +883,7 @@ void focus_in_event(Win* win, xcb_focus_in_event_t* e)
     }
 
     // check if this client is in should_get_focus list or if activation is allowed
-    bool activate = win->space.allowClientActivation(win, -1U, true);
+    bool activate = allow_window_activation(win->space, win, -1U, true);
 
     // Remove from should_get_focus list.
     if (auto& sgf = win->space.should_get_focus; contains(sgf, win)) {
diff --git a/win/x11/focus_stealing.h b/win/x11/focus_stealing.h
new file mode 100644
index 000000000..e8eb4a3fd
--- /dev/null
+++ b/win/x11/focus_stealing.h
@@ -0,0 +1,186 @@
+/*
+    SPDX-FileCopyrightText: 2022 Roman Gilg <subdiff@gmail.com>
+
+    SPDX-License-Identifier: GPL-2.0-or-later
+*/
+#pragma once
+
+#include "main.h"
+#include "utils/algorithm.h"
+#include "win/layers.h"
+#include "win/util.h"
+
+#include <xcb/xcb.h>
+
+namespace KWin::win::x11
+{
+
+// focus_in -> the window got FocusIn event
+// ignore_desktop - call comes from _NET_ACTIVE_WINDOW message, don't refuse just because of window
+//     is on a different desktop
+template<typename Space, typename Win>
+bool allow_window_activation(Space& space,
+                             Win const* window,
+                             xcb_timestamp_t time = -1U,
+                             bool focus_in = false,
+                             bool ignore_desktop = false)
+{
+    // kwinApp()->options->focusStealingPreventionLevel :
+    // 0 - none    - old KWin behaviour, new windows always get focus
+    // 1 - low     - focus stealing prevention is applied normally, when unsure, activation is
+    // allowed 2 - normal  - focus stealing prevention is applied normally, when unsure, activation
+    // is not allowed,
+    //              this is the default
+    // 3 - high    - new window gets focus only if it belongs to the active application,
+    //              or when no window is currently active
+    // 4 - extreme - no window gets focus without user intervention
+    if (time == -1U) {
+        time = window->userTime();
+    }
+
+    auto level
+        = window->control->rules().checkFSP(kwinApp()->options->focusStealingPreventionLevel());
+    if (space.session_manager->state() == SessionState::Saving
+        && enum_index(level) <= enum_index(fsp_level::medium)) {
+        // <= normal
+        return true;
+    }
+
+    auto ac = most_recently_activated_window(space);
+    if (focus_in) {
+        if (std::find(space.should_get_focus.cbegin(),
+                      space.should_get_focus.cend(),
+                      const_cast<Win*>(window))
+            != space.should_get_focus.cend()) {
+            // FocusIn was result of KWin's action
+            return true;
+        }
+        // Before getting FocusIn, the active Client already
+        // got FocusOut, and therefore got deactivated.
+        ac = space.last_active_client;
+    }
+    if (time == 0) {
+        // explicitly asked not to get focus
+        if (!window->control->rules().checkAcceptFocus(false))
+            return false;
+    }
+
+    auto const protection = ac ? ac->control->rules().checkFPP(fsp_level::medium) : fsp_level::none;
+
+    // stealing is unconditionally allowed (NETWM behavior)
+    if (level == fsp_level::none || protection == fsp_level::none) {
+        return true;
+    }
+
+    // The active client "grabs" the focus or stealing is generally forbidden
+    if (level == fsp_level::extreme || protection == fsp_level::extreme) {
+        return false;
+    }
+
+    // Desktop switching is only allowed in the "no protection" case
+    if (!ignore_desktop && !window->isOnCurrentDesktop()) {
+        // allow only with level == 0
+        return false;
+    }
+
+    // No active client, it's ok to pass focus
+    // NOTICE that extreme protection needs to be handled before to allow protection on unmanged
+    // windows
+    if (!ac || is_desktop(ac)) {
+        qCDebug(KWIN_CORE) << "Activation: No client active, allowing";
+        // no active client -> always allow
+        return true;
+    }
+
+    // TODO window urgency  -> return true?
+
+    // Unconditionally allow intra-client passing around for lower stealing protections
+    // unless the active client has High interest
+    if (belong_to_same_client(window, ac, same_client_check::relaxed_for_active)
+        && protection < fsp_level::high) {
+        qCDebug(KWIN_CORE) << "Activation: Belongs to active application";
+        return true;
+    }
+
+    if (!window->isOnCurrentDesktop()) {
+        // we allowed explicit self-activation across virtual desktops
+        // inside a client or if no client was active, but not otherwise
+        return false;
+    }
+
+    // High FPS, not intr-client change. Only allow if the active client has only minor interest
+    if (level > fsp_level::medium && protection > fsp_level::low) {
+        return false;
+    }
+
+    if (time == -1U) { // no time known
+        qCDebug(KWIN_CORE) << "Activation: No timestamp at all";
+        // Only allow for Low protection unless active client has High interest in focus
+        if (level < fsp_level::medium && protection < fsp_level::high) {
+            return true;
+        }
+
+        // no timestamp at all, don't activate - because there's also creation timestamp
+        // done on CreateNotify, this case should happen only in case application
+        // maps again already used window, i.e. this won't happen after app startup
+        return false;
+    }
+
+    // Low or medium FSP level, usertime comparism is possible
+    xcb_timestamp_t const user_time = ac->userTime();
+    qCDebug(KWIN_CORE) << "Activation, compared:" << window << ":" << time << ":" << user_time
+                       << ":" << (NET::timestampCompare(time, user_time) >= 0);
+
+    // time >= user_time
+    return NET::timestampCompare(time, user_time) >= 0;
+}
+
+// basically the same like allowClientActivation(), this time allowing
+// a window to be fully raised upon its own request (XRaiseWindow),
+// if refused, it will be raised only on top of windows belonging
+// to the same application
+template<typename Space, typename Win>
+bool allow_full_window_raising(Space& space, Win const* window, xcb_timestamp_t time)
+{
+    auto level
+        = window->control->rules().checkFSP(kwinApp()->options->focusStealingPreventionLevel());
+    if (space.session_manager->state() == SessionState::Saving
+        && enum_index(level) <= enum_index(fsp_level::medium)) {
+        // <= normal
+        return true;
+    }
+
+    auto ac = most_recently_activated_window(space);
+
+    if (level == fsp_level::none) {
+        return true;
+    }
+    if (level == fsp_level::extreme) {
+        return false;
+    }
+
+    if (!ac || is_desktop(ac)) {
+        qCDebug(KWIN_CORE) << "Raising: No client active, allowing";
+        // no active client -> always allow
+        return true;
+    }
+
+    // TODO window urgency  -> return true?
+    if (belong_to_same_client(window, ac, same_client_check::relaxed_for_active)) {
+        qCDebug(KWIN_CORE) << "Raising: Belongs to active application";
+        return true;
+    }
+
+    if (level == fsp_level::high) {
+        return false;
+    }
+
+    xcb_timestamp_t user_time = ac->userTime();
+    qCDebug(KWIN_CORE) << "Raising, compared:" << time << ":" << user_time << ":"
+                       << (NET::timestampCompare(time, user_time) >= 0);
+
+    // time >= user_time
+    return NET::timestampCompare(time, user_time) >= 0;
+}
+
+}
diff --git a/win/x11/netinfo.cpp b/win/x11/netinfo.cpp
index 9ed95f4b2..0f49338cd 100644
--- a/win/x11/netinfo.cpp
+++ b/win/x11/netinfo.cpp
@@ -209,14 +209,17 @@ void root_info::changeActiveWindow(xcb_window_t w,
             return; // WORKAROUND? With > 1 plasma activities, we cause this ourselves. bug #240673
         } else {    // NET::FromApplication
             x11::window* c2;
-            if (space.allowClientActivation(c, timestamp, false, true))
+            if (allow_window_activation(space, c, timestamp, false, true)) {
                 activate_window(space, c);
+            }
+
             // if activation of the requestor's window would be allowed, allow activation too
             else if (active_window != XCB_WINDOW_NONE
                      && (c2 = find_controlled_window<x11::window>(
                              space, predicate_match::window, active_window))
                          != nullptr
-                     && space.allowClientActivation(
+                     && allow_window_activation(
+                         space,
                          c2,
                          timestampCompare(timestamp,
                                           c2->userTime() > 0 ? timestamp : c2->userTime()),
diff --git a/win/x11/stacking.h b/win/x11/stacking.h
index 6a6ae5171..d76099687 100644
--- a/win/x11/stacking.h
+++ b/win/x11/stacking.h
@@ -5,6 +5,7 @@
 */
 #pragma once
 
+#include "focus_stealing.h"
 #include "group.h"
 #include "hide.h"
 #include "netinfo.h"
@@ -231,7 +232,7 @@ void raise_client_request(Space* space,
                           NET::RequestSource src = NET::FromApplication,
                           xcb_timestamp_t timestamp = 0)
 {
-    if (src == NET::FromTool || space->allowFullClientRaising(c, timestamp)) {
+    if (src == NET::FromTool || allow_full_window_raising(*space, c, timestamp)) {
         raise_window(space, c);
     } else {
         raise_client_within_application(space, c);
diff --git a/win/x11/startup_info.h b/win/x11/startup_info.h
index 6809220fa..8b3b7e084 100644
--- a/win/x11/startup_info.h
+++ b/win/x11/startup_info.h
@@ -5,6 +5,8 @@
 */
 #pragma once
 
+#include "focus_stealing.h"
+
 #include "base/output_helpers.h"
 #include "main.h"
 #include "win/desktop_space.h"
@@ -39,7 +41,7 @@ void startup_id_changed(Win* win)
     }
     auto const timestamp = asn_id.timestamp();
     if (timestamp != 0) {
-        auto activate = win->space.allowClientActivation(win, timestamp);
+        auto activate = allow_window_activation(win->space, win, timestamp);
         if (asn_data.desktop() != 0 && !win->isOnCurrentDesktop()) {
             // it was started on different desktop than current one
             activate = false;
-- 
GitLab


From ba2d514f1ff0f0988cc6b95e91e3a5337f4ae82d Mon Sep 17 00:00:00 2001
From: Roman Gilg <subdiff@gmail.com>
Date: Mon, 11 Jul 2022 12:56:45 +0200
Subject: [PATCH 29/51] refactor: reimplement space window hidden function as
 free function

This way it can be reused by different types of spaces.
---
 win/activation.h         | 13 +++++++++++++
 win/space.cpp            | 13 -------------
 win/space.h              |  2 --
 win/wayland/space.cpp    |  2 +-
 win/wayland/window.cpp   |  6 +++---
 win/x11/hide.h           |  4 ++--
 win/x11/window_release.h |  4 ++--
 7 files changed, 21 insertions(+), 23 deletions(-)

diff --git a/win/activation.h b/win/activation.h
index a0c012fe0..086a76f29 100644
--- a/win/activation.h
+++ b/win/activation.h
@@ -592,6 +592,19 @@ bool activate_next_window(Space& space, Toplevel* window)
     return true;
 }
 
+/**
+ * Informs the space that the \a window has been hidden. If it was the active window (or to-become
+ * the active window), the space activates another one.
+ *
+ * @note @p window may already be destroyed.
+ */
+template<typename Space, typename Win>
+void process_window_hidden(Space& space, Win* window)
+{
+    assert(!window->isShown() || !window->isOnCurrentDesktop());
+    activate_next_window(space, window);
+}
+
 template<typename Space>
 Toplevel* find_window_to_activate_on_desktop(Space& space, unsigned int desktop)
 {
diff --git a/win/space.cpp b/win/space.cpp
index 5e5e1e65b..d4bcef8ab 100644
--- a/win/space.cpp
+++ b/win/space.cpp
@@ -989,17 +989,4 @@ std::vector<Toplevel*> space::remnants() const
     return ret;
 }
 
-/**
- * Informs the space:: that the client \a c has been hidden. If it
- * was the active client (or to-become the active client),
- * the space:: activates another one.
- *
- * @note @p c may already be destroyed.
- */
-void space::clientHidden(Toplevel* window)
-{
-    Q_ASSERT(!window->isShown() || !window->isOnCurrentDesktop());
-    activate_next_window(*this, window);
-}
-
 }
diff --git a/win/space.h b/win/space.h
index 42127f1f3..2ef855f15 100644
--- a/win/space.h
+++ b/win/space.h
@@ -254,8 +254,6 @@ public:
     std::unique_ptr<base::dbus::kwin_impl<space>> dbus;
     std::unique_ptr<win::session_manager> session_manager;
 
-    void clientHidden(Toplevel* window);
-
     std::vector<Toplevel*> const& windows() const;
 
     /**
diff --git a/win/wayland/space.cpp b/win/wayland/space.cpp
index 9d361074c..65d280f80 100644
--- a/win/wayland/space.cpp
+++ b/win/wayland/space.cpp
@@ -292,7 +292,7 @@ void space::handle_window_removed(wayland::window* window)
             // Remove from client_keys.
             win::set_shortcut(window, QString());
         }
-        clientHidden(window);
+        process_window_hidden(*this, window);
         Q_EMIT qobject->clientRemoved(window);
     }
 
diff --git a/win/wayland/window.cpp b/win/wayland/window.cpp
index f9bed3c4d..f868885d4 100644
--- a/win/wayland/window.cpp
+++ b/win/wayland/window.cpp
@@ -493,7 +493,7 @@ void window::hideClient(bool hide)
 
     if (hide) {
         space.render.addRepaint(visible_rect(this));
-        space.clientHidden(this);
+        process_window_hidden(space, this);
         Q_EMIT windowHidden(this);
     } else {
         handle_shown_and_mapped();
@@ -933,7 +933,7 @@ void window::unmap()
     space.render.addRepaint(visible_rect(this));
 
     if (control) {
-        space.clientHidden(this);
+        process_window_hidden(space, this);
     }
 
     Q_EMIT windowHidden(this);
@@ -1163,7 +1163,7 @@ void window::ping(window::ping_reason reason)
 void window::doMinimize()
 {
     if (control->minimized()) {
-        space.clientHidden(this);
+        process_window_hidden(space, this);
     } else {
         Q_EMIT windowShown(this);
     }
diff --git a/win/x11/hide.h b/win/x11/hide.h
index 22ee85d0b..689e39ca8 100644
--- a/win/x11/hide.h
+++ b/win/x11/hide.h
@@ -138,7 +138,7 @@ void internal_hide(Win* win)
     }
 
     win->space.render.addRepaint(visible_rect(win));
-    win->space.clientHidden(win);
+    process_window_hidden(win->space, win);
     Q_EMIT win->windowHidden(win);
 }
 
@@ -166,7 +166,7 @@ void internal_keep(Win* win)
 
     update_hidden_preview(win);
     win->space.render.addRepaint(visible_rect(win));
-    win->space.clientHidden(win);
+    process_window_hidden(win->space, win);
 }
 
 template<typename Win>
diff --git a/win/x11/window_release.h b/win/x11/window_release.h
index 5932e2498..ff3867b1a 100644
--- a/win/x11/window_release.h
+++ b/win/x11/window_release.h
@@ -210,7 +210,7 @@ void release_window(Win* win, bool on_shutdown)
     win->hidden = true;
 
     if (!on_shutdown) {
-        win->space.clientHidden(win);
+        process_window_hidden(win->space, win);
     }
 
     // Destroying decoration would cause ugly visual effect
@@ -318,7 +318,7 @@ void destroy_window(Win* win)
     // So that it's not considered visible anymore
     win->hidden = true;
 
-    win->space.clientHidden(win);
+    process_window_hidden(win->space, win);
     win->control->destroy_decoration();
     clean_grouping(win);
     remove_controlled_window_from_space(win->space, win);
-- 
GitLab


From 5bc65f3b7ddf1391b2f2378fdfcf811bcee560f3 Mon Sep 17 00:00:00 2001
From: Roman Gilg <subdiff@gmail.com>
Date: Mon, 11 Jul 2022 18:33:37 +0200
Subject: [PATCH 30/51] refactor: reimplement special window getters as free
 functions

Create free function templates that return all unmanaged windows and all
remnants instead of using space member functions.

This way the functions can be reused by different types of spaces.
---
 debug/console/console.cpp                    |  7 ++++---
 debug/console/wayland/surface_tree_model.cpp | 10 +++++----
 input/redirect.cpp                           |  3 ++-
 render/compositor.cpp                        |  4 ++--
 render/effects.cpp                           |  6 +++---
 win/remnant.h                                | 12 +++++++++++
 win/space.cpp                                | 22 --------------------
 win/space.h                                  |  9 --------
 win/x11/space_setup.h                        |  2 +-
 win/x11/stacking.h                           | 14 ++++++++++++-
 10 files changed, 43 insertions(+), 46 deletions(-)

diff --git a/debug/console/console.cpp b/debug/console/console.cpp
index 449d8eb51..ad672424e 100644
--- a/debug/console/console.cpp
+++ b/debug/console/console.cpp
@@ -27,6 +27,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "render/scene.h"
 #include "win/internal_window.h"
 #include "win/space.h"
+#include "win/x11/stacking.h"
 #include "win/x11/window.h"
 
 #include <kwingl/platform.h>
@@ -268,10 +269,10 @@ console_model::console_model(win::space& space, QObject* parent)
             remove_window(this, s_x11ClientId - 1, m_x11Clients, c);
         });
 
-    const auto unmangeds = space.unmanagedList();
-    for (auto u : unmangeds) {
-        m_unmanageds.append(u);
+    for (auto unmanaged : win::x11::get_unmanageds<Toplevel>(space)) {
+        m_unmanageds.append(unmanaged);
     }
+
     connect(space.qobject.get(), &win::space_qobject::unmanagedAdded, this, [this](Toplevel* u) {
         add_window(this, s_x11UnmanagedId - 1, m_unmanageds, u);
     });
diff --git a/debug/console/wayland/surface_tree_model.cpp b/debug/console/wayland/surface_tree_model.cpp
index e7cede8fb..e88086fee 100644
--- a/debug/console/wayland/surface_tree_model.cpp
+++ b/debug/console/wayland/surface_tree_model.cpp
@@ -10,6 +10,7 @@
 #include "toplevel.h"
 #include "win/wayland/space.h"
 #include "win/wayland/window.h"
+#include "win/x11/stacking.h"
 #include "win/x11/window.h"
 
 #include <Wrapland/Server/buffer.h>
@@ -30,7 +31,7 @@ surface_tree_model::surface_tree_model(win::space& space, QObject* parent)
         endResetModel();
     };
 
-    const auto unmangeds = space.unmanagedList();
+    auto const unmangeds = win::x11::get_unmanageds<Toplevel>(space);
     for (auto u : unmangeds) {
         if (!u->surface) {
             continue;
@@ -107,7 +108,8 @@ int surface_tree_model::rowCount(const QModelIndex& parent) const
     }
 
     // toplevel are all windows
-    return get_windows_with_control(space.m_windows).size() + space.unmanagedList().size();
+    return get_windows_with_control(space.m_windows).size()
+        + win::x11::get_unmanageds<Toplevel>(space).size();
 }
 
 QModelIndex surface_tree_model::index(int row, int column, const QModelIndex& parent) const
@@ -137,7 +139,7 @@ QModelIndex surface_tree_model::index(int row, int column, const QModelIndex& pa
     }
 
     int reference = allClients.size();
-    const auto& unmanaged = space.unmanagedList();
+    const auto& unmanaged = win::x11::get_unmanageds<Toplevel>(space);
     if (row_u < reference + unmanaged.size()) {
         return createIndex(row_u, column, unmanaged.at(row_u - reference)->surface);
     }
@@ -184,7 +186,7 @@ QModelIndex surface_tree_model::parent(const QModelIndex& child) const
             }
         }
         row = allClients.size();
-        const auto& unmanaged = space.unmanagedList();
+        const auto& unmanaged = win::x11::get_unmanageds<Toplevel>(space);
         for (size_t i = 0; i < unmanaged.size(); i++) {
             if (unmanaged.at(i)->surface == parent) {
                 return createIndex(row + i, 0, parent);
diff --git a/input/redirect.cpp b/input/redirect.cpp
index 16166b858..a08ed6214 100644
--- a/input/redirect.cpp
+++ b/input/redirect.cpp
@@ -26,6 +26,7 @@
 #include "win/space.h"
 #include "win/stacking_order.h"
 #include "win/wayland/input.h"
+#include "win/x11/unmanaged.h"
 
 namespace KWin::input
 {
@@ -95,7 +96,7 @@ Toplevel* redirect::findToplevel(const QPoint& pos)
         if (space.render.effects && space.render.effects->isMouseInterception()) {
             return nullptr;
         }
-        auto const& unmanaged = space.unmanagedList();
+        auto const& unmanaged = win::x11::get_unmanageds<Toplevel>(space);
         for (auto const& u : unmanaged) {
             if (win::input_geometry(u).contains(pos) && win::wayland::accepts_input(u, pos)) {
                 return u;
diff --git a/render/compositor.cpp b/render/compositor.cpp
index 16d5d6f3d..2a53e3301 100644
--- a/render/compositor.cpp
+++ b/render/compositor.cpp
@@ -183,8 +183,8 @@ void compositor::stop(bool on_shutdown)
             xcb_composite_unredirect_subwindows(
                 con, kwinApp()->x11RootWindow(), XCB_COMPOSITE_REDIRECT_MANUAL);
         }
-        while (!space->remnants().empty()) {
-            auto win = space->remnants().front();
+        while (!win::get_remnants(*space).empty()) {
+            auto win = win::get_remnants(*space).front();
             win->remnant->refcount = 0;
             win::delete_window_from_space(win->space, win);
         }
diff --git a/render/effects.cpp b/render/effects.cpp
index 6e1d292eb..848eaeba3 100644
--- a/render/effects.cpp
+++ b/render/effects.cpp
@@ -53,7 +53,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "win/virtual_desktops.h"
 #include "win/window_area.h"
 #include "win/x11/group.h"
-#include "win/x11/unmanaged.h"
+#include "win/x11/stacking.h"
 #include "win/x11/window.h"
 #include "win/x11/window_find.h"
 
@@ -277,8 +277,8 @@ effects_handler_impl::effects_handler_impl(render::compositor* compositor, rende
         }
         setupClientConnections(x11_client);
     }
-    for (auto u : ws->unmanagedList()) {
-        setupUnmanagedConnections(u);
+    for (auto unmanaged : win::x11::get_unmanageds<Toplevel>(*ws)) {
+        setupUnmanagedConnections(unmanaged);
     }
     for (auto window : ws->windows()) {
         if (auto internal = qobject_cast<win::internal_window*>(window)) {
diff --git a/win/remnant.h b/win/remnant.h
index ad8c4e54b..e70ce3a60 100644
--- a/win/remnant.h
+++ b/win/remnant.h
@@ -19,6 +19,18 @@
 namespace KWin::win
 {
 
+template<typename Space>
+std::vector<Toplevel*> get_remnants(Space const& space)
+{
+    std::vector<Toplevel*> ret;
+    for (auto const& window : space.m_windows) {
+        if (window->remnant) {
+            ret.push_back(window);
+        }
+    }
+    return ret;
+}
+
 class remnant
 {
 public:
diff --git a/win/space.cpp b/win/space.cpp
index d4bcef8ab..6e697d72b 100644
--- a/win/space.cpp
+++ b/win/space.cpp
@@ -967,26 +967,4 @@ std::vector<Toplevel*> const& space::windows() const
     return m_windows;
 }
 
-std::vector<Toplevel*> space::unmanagedList() const
-{
-    std::vector<Toplevel*> ret;
-    for (auto const& window : m_windows) {
-        if (window->xcb_window && !window->control && !window->remnant) {
-            ret.push_back(window);
-        }
-    }
-    return ret;
-}
-
-std::vector<Toplevel*> space::remnants() const
-{
-    std::vector<Toplevel*> ret;
-    for (auto const& window : m_windows) {
-        if (window->remnant) {
-            ret.push_back(window);
-        }
-    }
-    return ret;
-}
-
 }
diff --git a/win/space.h b/win/space.h
index 2ef855f15..efe4e2b81 100644
--- a/win/space.h
+++ b/win/space.h
@@ -256,15 +256,6 @@ public:
 
     std::vector<Toplevel*> const& windows() const;
 
-    /**
-     * @return List of unmanaged "clients" currently registered in space
-     */
-    std::vector<Toplevel*> unmanagedList() const;
-    /**
-     * @return Remnant windows, i.e. already closed but still kept around for closing effects.
-     */
-    std::vector<Toplevel*> remnants() const;
-
     void updateTabbox();
 
     QTimer* m_quickTileCombineTimer{nullptr};
diff --git a/win/x11/space_setup.h b/win/x11/space_setup.h
index 85ec1bf50..61de2c715 100644
--- a/win/x11/space_setup.h
+++ b/win/x11/space_setup.h
@@ -211,7 +211,7 @@ void clear_space(Space& space)
         remove_all(space.m_windows, window);
     }
 
-    for (auto const& unmanaged : space.unmanagedList()) {
+    for (auto const& unmanaged : get_unmanageds<Toplevel>(space)) {
         release_window(static_cast<window*>(unmanaged), is_x11);
         remove_all(space.m_windows, unmanaged);
         remove_all(space.stacking_order->pre_stack, unmanaged);
diff --git a/win/x11/stacking.h b/win/x11/stacking.h
index d76099687..a289cee69 100644
--- a/win/x11/stacking.h
+++ b/win/x11/stacking.h
@@ -23,6 +23,18 @@
 namespace KWin::win::x11
 {
 
+template<typename Win, typename Space>
+std::vector<Win*> get_unmanageds(Space const& space)
+{
+    std::vector<Win*> ret;
+    for (auto const& window : space.m_windows) {
+        if (window->xcb_window && !window->control && !window->remnant) {
+            ret.push_back(window);
+        }
+    }
+    return ret;
+}
+
 template<typename Space>
 void render_stack_unmanaged_windows(Space& space)
 {
@@ -40,7 +52,7 @@ void render_stack_unmanaged_windows(Space& space)
     // create an vector of references instead of making a copy of each element into the vector.
     std::vector<std::reference_wrapper<xcb_window_t>> windows(
         xcbtree->children(), xcbtree->children() + xcbtree->data()->children_len);
-    auto const& unmanaged_list = space.unmanagedList();
+    auto const& unmanaged_list = get_unmanageds<Toplevel>(space);
 
     for (auto const& win : windows) {
         auto unmanaged = std::find_if(unmanaged_list.cbegin(),
-- 
GitLab


From ef7ab3c69a837d71e87e6982a3de7aa26052a724 Mon Sep 17 00:00:00 2001
From: Roman Gilg <subdiff@gmail.com>
Date: Mon, 11 Jul 2022 19:54:54 +0200
Subject: [PATCH 31/51] refactor: remove space windows getter

The windows container is public. Access it directly.
---
 autotests/integration/dont_crash_glxgears.cpp |  4 +--
 autotests/integration/input_method.cpp        |  2 +-
 autotests/integration/keyboard_keymap.cpp     |  2 +-
 autotests/integration/stacking_order_test.cpp |  2 +-
 autotests/integration/virtual_keyboard.cpp    |  2 +-
 autotests/integration/x11_client_test.cpp     |  4 +--
 .../integration/xdgshellclient_rules_test.cpp |  2 +-
 autotests/integration/xwayland_input_test.cpp |  2 +-
 base/dbus/kwin.h                              |  2 +-
 debug/console/console.cpp                     |  4 +--
 debug/console/wayland/surface_tree_model.cpp  |  8 +++---
 debug/console/wayland/wayland_console.cpp     |  2 +-
 input/filters/internal_window.cpp             |  4 +--
 input/wayland/cursor_image.cpp                |  2 +-
 input/wayland/device_redirect.h               |  2 +-
 input/wayland/input_method.cpp                |  4 +--
 input/wayland/pointer_redirect.cpp            |  2 +-
 render/compositor.cpp                         |  4 +--
 render/effects.cpp                            |  6 ++---
 render/gl/lanczos_filter.cpp                  |  2 +-
 render/thumbnail_item.cpp                     |  2 +-
 render/wayland/compositor.cpp                 |  2 +-
 render/wayland/effects.cpp                    |  2 +-
 render/x11/compositor.cpp                     |  4 +--
 scripting/space.h                             |  6 ++---
 win/activation.h                              |  2 +-
 win/appmenu.h                                 |  2 +-
 win/deco/bridge.h                             |  2 +-
 win/geo_change.h                              |  8 +++---
 win/internal_window.cpp                       |  2 +-
 win/meta.h                                    |  2 +-
 win/move.h                                    |  2 +-
 win/placement.h                               |  2 +-
 win/remnant.h                                 |  2 +-
 win/rules.h                                   |  2 +-
 win/session.h                                 |  4 +--
 win/shortcut_set.h                            |  2 +-
 win/space.cpp                                 | 23 +++++++----------
 win/space.h                                   |  4 +--
 win/space_areas_helpers.h                     |  2 +-
 win/space_reconfigure.h                       |  4 +--
 win/space_window_release.h                    |  6 ++---
 win/tabbox/tabbox.cpp                         |  6 ++---
 win/wayland/layer_shell.h                     |  6 ++---
 win/wayland/space.cpp                         | 25 +++++++++----------
 win/wayland/subsurface.h                      |  6 ++---
 win/wayland/transient.h                       |  2 +-
 win/wayland/window.cpp                        |  2 +-
 win/wayland/window_release.h                  |  2 +-
 win/wayland/xdg_shell.h                       |  4 +--
 win/x11/control.h                             |  2 +-
 win/x11/event.h                               |  2 +-
 win/x11/space.cpp                             |  4 +--
 win/x11/space_setup.h                         |  4 +--
 win/x11/stacking.h                            |  4 +--
 win/x11/sync_alarm_filter.cpp                 |  2 +-
 win/x11/tool_windows.h                        |  2 +-
 win/x11/transient.h                           |  2 +-
 win/x11/unmanaged.h                           |  4 +--
 win/x11/window_create.h                       |  2 +-
 win/x11/window_find.h                         |  2 +-
 win/x11/window_release.h                      |  4 +--
 xwl/surface.h                                 |  2 +-
 63 files changed, 115 insertions(+), 123 deletions(-)

diff --git a/autotests/integration/dont_crash_glxgears.cpp b/autotests/integration/dont_crash_glxgears.cpp
index 5075d4869..6a80319fa 100644
--- a/autotests/integration/dont_crash_glxgears.cpp
+++ b/autotests/integration/dont_crash_glxgears.cpp
@@ -63,9 +63,9 @@ void DontCrashGlxgearsTest::testGlxgears()
 
     QVERIFY(clientAddedSpy.wait());
     QCOMPARE(clientAddedSpy.count(), 1);
-    QCOMPARE(Test::app()->workspace->m_windows.size(), 1);
+    QCOMPARE(Test::app()->workspace->windows.size(), 1);
 
-    auto glxgearsClient = Test::app()->workspace->m_windows.front();
+    auto glxgearsClient = Test::app()->workspace->windows.front();
     QVERIFY(win::decoration(glxgearsClient));
     QSignalSpy closedSpy(glxgearsClient, &win::x11::window::closed);
     QVERIFY(closedSpy.isValid());
diff --git a/autotests/integration/input_method.cpp b/autotests/integration/input_method.cpp
index 5bbdaf8f0..814a274ae 100644
--- a/autotests/integration/input_method.cpp
+++ b/autotests/integration/input_method.cpp
@@ -122,7 +122,7 @@ void input_method_test::cleanup()
     }
 
     toplevel.client_surface.reset();
-    QVERIFY(Test::app()->workspace->windows().empty());
+    QVERIFY(Test::app()->workspace->windows.empty());
 
     input_method.reset();
     text_input.reset();
diff --git a/autotests/integration/keyboard_keymap.cpp b/autotests/integration/keyboard_keymap.cpp
index 3d1771d9b..56e3747cf 100644
--- a/autotests/integration/keyboard_keymap.cpp
+++ b/autotests/integration/keyboard_keymap.cpp
@@ -119,7 +119,7 @@ void keyboard_keymap_test::cleanup()
 {
     // Make sure we animate.
     QTest::qWait(1000);
-    QVERIFY(Test::app()->workspace->windows().empty());
+    QVERIFY(Test::app()->workspace->windows.empty());
 
     Test::destroy_wayland_connection();
 }
diff --git a/autotests/integration/stacking_order_test.cpp b/autotests/integration/stacking_order_test.cpp
index c1f658fad..38faa722f 100644
--- a/autotests/integration/stacking_order_test.cpp
+++ b/autotests/integration/stacking_order_test.cpp
@@ -358,7 +358,7 @@ void StackingOrderTest::testGroupTransientIsAboveWindowGroup()
     const QRect geometry = QRect(0, 0, 128, 128);
 
     // We need to wait until the remnant from previous test is gone.
-    QTRY_VERIFY(Test::app()->workspace->windows().empty());
+    QTRY_VERIFY(Test::app()->workspace->windows.empty());
 
     auto conn = create_xcb_connection();
 
diff --git a/autotests/integration/virtual_keyboard.cpp b/autotests/integration/virtual_keyboard.cpp
index 1094a8be7..b933e4bb4 100644
--- a/autotests/integration/virtual_keyboard.cpp
+++ b/autotests/integration/virtual_keyboard.cpp
@@ -135,7 +135,7 @@ void virtual_keyboard_test::cleanup()
 {
     // Make sure we animate.
     QTest::qWait(1000);
-    QVERIFY(Test::app()->workspace->windows().empty());
+    QVERIFY(Test::app()->workspace->windows.empty());
 
     vk_client = {};
     focus_client = {};
diff --git a/autotests/integration/x11_client_test.cpp b/autotests/integration/x11_client_test.cpp
index 7502977f0..d578ef23a 100644
--- a/autotests/integration/x11_client_test.cpp
+++ b/autotests/integration/x11_client_test.cpp
@@ -538,8 +538,8 @@ void X11ClientTest::testCaptionWmName()
 
     QVERIFY(clientAddedSpy.wait());
     QCOMPARE(clientAddedSpy.count(), 1);
-    QCOMPARE(Test::app()->workspace->m_windows.size(), 1);
-    auto glxgearsClient = Test::app()->workspace->m_windows.front();
+    QCOMPARE(Test::app()->workspace->windows.size(), 1);
+    auto glxgearsClient = Test::app()->workspace->windows.front();
     QCOMPARE(win::caption(glxgearsClient), QStringLiteral("glxgears"));
 
     glxgears.terminate();
diff --git a/autotests/integration/xdgshellclient_rules_test.cpp b/autotests/integration/xdgshellclient_rules_test.cpp
index 575220484..3184e2ea6 100644
--- a/autotests/integration/xdgshellclient_rules_test.cpp
+++ b/autotests/integration/xdgshellclient_rules_test.cpp
@@ -209,7 +209,7 @@ createWindow(const QByteArray& appId, int timeout = 5000)
 win::wayland::window* get_toplevel_window(QSignalSpy const& spy)
 {
     auto xdg_toplevel = spy.last().at(0).value<Wrapland::Server::XdgShellToplevel*>();
-    for (auto win : Test::app()->workspace->m_windows) {
+    for (auto win : Test::app()->workspace->windows) {
         if (auto wl_win = qobject_cast<win::wayland::window*>(win);
             wl_win && wl_win->toplevel == xdg_toplevel) {
             return wl_win;
diff --git a/autotests/integration/xwayland_input_test.cpp b/autotests/integration/xwayland_input_test.cpp
index 6e122e177..1ff50e57a 100644
--- a/autotests/integration/xwayland_input_test.cpp
+++ b/autotests/integration/xwayland_input_test.cpp
@@ -64,7 +64,7 @@ void XWaylandInputTest::initTestCase()
 void XWaylandInputTest::init()
 {
     input::get_cursor()->set_pos(QPoint(640, 512));
-    QVERIFY(Test::app()->workspace->m_windows.empty());
+    QVERIFY(Test::app()->workspace->windows.empty());
 }
 
 void xcb_connection_deleter(xcb_connection_t* pointer)
diff --git a/base/dbus/kwin.h b/base/dbus/kwin.h
index e69e92549..3ec25a651 100644
--- a/base/dbus/kwin.h
+++ b/base/dbus/kwin.h
@@ -196,7 +196,7 @@ public:
     {
         auto const id = QUuid::fromString(uuid);
 
-        for (auto win : space.m_windows) {
+        for (auto win : space.windows) {
             if (!win->control) {
                 continue;
             }
diff --git a/debug/console/console.cpp b/debug/console/console.cpp
index ad672424e..96c4cbf76 100644
--- a/debug/console/console.cpp
+++ b/debug/console/console.cpp
@@ -250,7 +250,7 @@ console_model::console_model(win::space& space, QObject* parent)
     : QAbstractItemModel(parent)
     , space{space}
 {
-    for (auto const& window : space.m_windows) {
+    for (auto const& window : space.windows) {
         if (window->control) {
             if (auto x11_client = qobject_cast<win::x11::window*>(window)) {
                 m_x11Clients.append(x11_client);
@@ -279,7 +279,7 @@ console_model::console_model(win::space& space, QObject* parent)
     connect(space.qobject.get(), &win::space_qobject::unmanagedRemoved, this, [this](Toplevel* u) {
         remove_window(this, s_x11UnmanagedId - 1, m_unmanageds, u);
     });
-    for (auto const& window : space.windows()) {
+    for (auto const& window : space.windows) {
         if (auto internal = qobject_cast<win::internal_window*>(window)) {
             m_internalClients.append(internal);
         }
diff --git a/debug/console/wayland/surface_tree_model.cpp b/debug/console/wayland/surface_tree_model.cpp
index e88086fee..c880ef6db 100644
--- a/debug/console/wayland/surface_tree_model.cpp
+++ b/debug/console/wayland/surface_tree_model.cpp
@@ -39,7 +39,7 @@ surface_tree_model::surface_tree_model(win::space& space, QObject* parent)
         QObject::connect(
             u->surface, &Wrapland::Server::Surface::subsurfaceTreeChanged, this, reset);
     }
-    for (auto c : space.m_windows) {
+    for (auto c : space.windows) {
         if (!c->control || !c->surface) {
             continue;
         }
@@ -108,7 +108,7 @@ int surface_tree_model::rowCount(const QModelIndex& parent) const
     }
 
     // toplevel are all windows
-    return get_windows_with_control(space.m_windows).size()
+    return get_windows_with_control(space.windows).size()
         + win::x11::get_unmanageds<Toplevel>(space).size();
 }
 
@@ -132,7 +132,7 @@ QModelIndex surface_tree_model::index(int row, int column, const QModelIndex& pa
     }
 
     // a window
-    auto const& allClients = get_windows_with_control(space.m_windows);
+    auto const& allClients = get_windows_with_control(space.windows);
     if (row_u < allClients.size()) {
         // references a client
         return createIndex(row_u, column, allClients.at(row_u)->surface);
@@ -179,7 +179,7 @@ QModelIndex surface_tree_model::parent(const QModelIndex& child) const
         }
         // not a subsurface, thus it's a true window
         size_t row = 0;
-        const auto& allClients = get_windows_with_control(space.m_windows);
+        const auto& allClients = get_windows_with_control(space.windows);
         for (; row < allClients.size(); row++) {
             if (allClients.at(row)->surface == parent) {
                 return createIndex(row, 0, parent);
diff --git a/debug/console/wayland/wayland_console.cpp b/debug/console/wayland/wayland_console.cpp
index 3eb23c230..3f36f6e52 100644
--- a/debug/console/wayland/wayland_console.cpp
+++ b/debug/console/wayland/wayland_console.cpp
@@ -117,7 +117,7 @@ wayland_console_model::wayland_console_model(win::space& space, QObject* parent)
 {
     auto& wlspace = static_cast<win::wayland::space&>(space);
 
-    for (auto window : space.m_windows) {
+    for (auto window : space.windows) {
         if (auto wwin = qobject_cast<win::wayland::window*>(window); wwin && !wwin->remnant) {
             m_shellClients.append(wwin);
         }
diff --git a/input/filters/internal_window.cpp b/input/filters/internal_window.cpp
index 7425b09b0..4d5d93516 100644
--- a/input/filters/internal_window.cpp
+++ b/input/filters/internal_window.cpp
@@ -178,7 +178,7 @@ QKeyEvent get_internal_key_event(key_event const& event)
 
 bool internal_window_filter::key(key_event const& event)
 {
-    auto window = get_internal_window(redirect.space.windows());
+    auto window = get_internal_window(redirect.space.windows);
     if (!window) {
         return false;
     }
@@ -194,7 +194,7 @@ bool internal_window_filter::key(key_event const& event)
 
 bool internal_window_filter::key_repeat(key_event const& event)
 {
-    auto window = get_internal_window(redirect.space.windows());
+    auto window = get_internal_window(redirect.space.windows);
     if (!window) {
         return false;
     }
diff --git a/input/wayland/cursor_image.cpp b/input/wayland/cursor_image.cpp
index fddb96c77..025affcfe 100644
--- a/input/wayland/cursor_image.cpp
+++ b/input/wayland/cursor_image.cpp
@@ -93,7 +93,7 @@ void cursor_image::setup_theme()
         });
     }
 
-    auto const clients = platform.redirect->space.m_windows;
+    auto const clients = platform.redirect->space.windows;
     std::for_each(clients.begin(), clients.end(), [this](auto win) { setup_move_resize(win); });
 
     QObject::connect(platform.redirect->space.qobject.get(),
diff --git a/input/wayland/device_redirect.h b/input/wayland/device_redirect.h
index 4833c094e..752397456 100644
--- a/input/wayland/device_redirect.h
+++ b/input/wayland/device_redirect.h
@@ -205,7 +205,7 @@ void device_redirect_update(Dev* dev)
 
     if (dev->positionValid()) {
         auto const pos = dev->position().toPoint();
-        internal_window = device_redirect_find_internal_window(dev->redirect->space.windows(), pos);
+        internal_window = device_redirect_find_internal_window(dev->redirect->space.windows, pos);
         if (internal_window) {
             toplevel = dev->redirect->space.findInternal(internal_window);
         } else {
diff --git a/input/wayland/input_method.cpp b/input/wayland/input_method.cpp
index 549a81ffb..716569e27 100644
--- a/input/wayland/input_method.cpp
+++ b/input/wayland/input_method.cpp
@@ -37,7 +37,7 @@ Toplevel* get_window(input::wayland::platform& platform,
 {
     auto input_surface = text_input->entered_surface();
 
-    for (auto win : platform.redirect->space.m_windows) {
+    for (auto win : platform.redirect->space.windows) {
         if (win->control && win->surface == input_surface) {
             return win;
         }
@@ -173,7 +173,7 @@ void input_method::handle_popup_surface_created(input_method_popup_surface_v2* p
     popup->hidden = true;
     popup->set_layer(win::layer::notification);
 
-    space->m_windows.push_back(popup);
+    space->windows.push_back(popup);
 
     QObject::connect(popup, &window::closed, this, [this](auto win) { remove_all(popups, win); });
 
diff --git a/input/wayland/pointer_redirect.cpp b/input/wayland/pointer_redirect.cpp
index ecd9ae0a1..fde01b2b5 100644
--- a/input/wayland/pointer_redirect.cpp
+++ b/input/wayland/pointer_redirect.cpp
@@ -94,7 +94,7 @@ void pointer_redirect::init()
         });
     };
 
-    auto const clients = redirect->space.m_windows;
+    auto const clients = redirect->space.windows;
     std::for_each(clients.begin(), clients.end(), setupMoveResizeConnection);
     QObject::connect(redirect->space.qobject.get(),
                      &win::space::qobject_t::clientAdded,
diff --git a/render/compositor.cpp b/render/compositor.cpp
index 2a53e3301..2081e6f33 100644
--- a/render/compositor.cpp
+++ b/render/compositor.cpp
@@ -91,7 +91,7 @@ void compositor::start_scene()
     scene = create_scene();
     space->stacking_order->render_restack_required = true;
 
-    for (auto& client : space->windows()) {
+    for (auto& client : space->windows) {
         client->setupCompositing();
     }
 
@@ -172,7 +172,7 @@ void compositor::stop(bool on_shutdown)
     effects.reset();
 
     if (space) {
-        for (auto& c : space->windows()) {
+        for (auto& c : space->windows) {
             if (c->remnant) {
                 continue;
             }
diff --git a/render/effects.cpp b/render/effects.cpp
index 848eaeba3..e12a05436 100644
--- a/render/effects.cpp
+++ b/render/effects.cpp
@@ -266,7 +266,7 @@ effects_handler_impl::effects_handler_impl(render::compositor* compositor, rende
     }
 
     // connect all clients
-    for (auto& window : ws->m_windows) {
+    for (auto& window : ws->windows) {
         // TODO: Can we merge this with the one for Wayland XdgShellClients below?
         if (!window->control) {
             continue;
@@ -280,7 +280,7 @@ effects_handler_impl::effects_handler_impl(render::compositor* compositor, rende
     for (auto unmanaged : win::x11::get_unmanageds<Toplevel>(*ws)) {
         setupUnmanagedConnections(unmanaged);
     }
-    for (auto window : ws->windows()) {
+    for (auto window : ws->windows) {
         if (auto internal = qobject_cast<win::internal_window*>(window)) {
             setupAbstractClientConnections(internal);
         }
@@ -1116,7 +1116,7 @@ EffectWindow* effects_handler_impl::find_window_by_qwindow(QWindow* w) const
 
 EffectWindow* effects_handler_impl::find_window_by_uuid(const QUuid& id) const
 {
-    for (auto win : m_compositor->space->m_windows) {
+    for (auto win : m_compositor->space->windows) {
         if (!win->remnant && win->internal_id == id) {
             return win->render->effect.get();
         }
diff --git a/render/gl/lanczos_filter.cpp b/render/gl/lanczos_filter.cpp
index ad6270712..344e064d6 100644
--- a/render/gl/lanczos_filter.cpp
+++ b/render/gl/lanczos_filter.cpp
@@ -414,7 +414,7 @@ void lanczos_filter::timerEvent(QTimerEvent* event)
         m_offscreenTarget = nullptr;
         m_offscreenTex = nullptr;
 
-        for (auto win : m_scene->compositor.space->m_windows) {
+        for (auto win : m_scene->compositor.space->windows) {
             discardCacheTexture(win->render->effect.get());
         }
 
diff --git a/render/thumbnail_item.cpp b/render/thumbnail_item.cpp
index d557067fa..bd643d4d7 100644
--- a/render/thumbnail_item.cpp
+++ b/render/thumbnail_item.cpp
@@ -140,7 +140,7 @@ window_thumbnail_item::~window_thumbnail_item()
 
 Toplevel* find_controlled_window(QUuid const& wId)
 {
-    for (auto win : win::singleton_interface::space->m_windows) {
+    for (auto win : win::singleton_interface::space->windows) {
         if (win->control && win->internal_id == wId) {
             return win;
         }
diff --git a/render/wayland/compositor.cpp b/render/wayland/compositor.cpp
index 75e45a195..1b9a159e5 100644
--- a/render/wayland/compositor.cpp
+++ b/render/wayland/compositor.cpp
@@ -133,7 +133,7 @@ void compositor::start(win::space& space)
                          &compositor::addRepaintFull);
         QObject::connect(
             &platform.base, &base::platform::output_removed, this, [this](auto output) {
-                for (auto& win : this->space->m_windows) {
+                for (auto& win : this->space->windows) {
                     remove_all(win->repaint_outputs, output);
                 }
             });
diff --git a/render/wayland/effects.cpp b/render/wayland/effects.cpp
index a04453438..39885d3ab 100644
--- a/render/wayland/effects.cpp
+++ b/render/wayland/effects.cpp
@@ -42,7 +42,7 @@ effects_handler_impl::effects_handler_impl(render::compositor* compositor, rende
         });
 
     // TODO(romangg): We do this here too for every window.
-    for (auto window : space->m_windows) {
+    for (auto window : space->windows) {
         auto wayland_window = qobject_cast<win::wayland::window*>(window);
         if (!wayland_window) {
             continue;
diff --git a/render/x11/compositor.cpp b/render/x11/compositor.cpp
index 7d1bfb89d..3d6e33cc3 100644
--- a/render/x11/compositor.cpp
+++ b/render/x11/compositor.cpp
@@ -278,7 +278,7 @@ bool compositor::prepare_composition(QRegion& repaints, std::deque<Toplevel*>& w
         win->getDamageRegionReply();
     }
 
-    if (auto const& wins = space->m_windows;
+    if (auto const& wins = space->windows;
         repaints_region.isEmpty() && !std::any_of(wins.cbegin(), wins.cend(), [](auto const& win) {
             return win->has_pending_repaints();
         })) {
@@ -437,7 +437,7 @@ void compositor::updateClientCompositeBlocking(Toplevel* window)
         // If !c we just check if we can resume in case a blocking client was lost.
         bool shouldResume = true;
 
-        for (auto const& client : space->m_windows) {
+        for (auto const& client : space->windows) {
             if (client->isBlockingCompositing()) {
                 shouldResume = false;
                 break;
diff --git a/scripting/space.h b/scripting/space.h
index d980ee92f..35d89bf7c 100644
--- a/scripting/space.h
+++ b/scripting/space.h
@@ -593,7 +593,7 @@ public:
 
         connect_legacy_screen_resize(this);
 
-        for (auto window : ref_space->m_windows) {
+        for (auto window : ref_space->windows) {
             if (window->control) {
                 Space::handle_client_added(window);
             }
@@ -623,7 +623,7 @@ public:
     std::vector<window*> windows() const override
     {
         std::vector<window*> ret;
-        for (auto const& window : ref_space->m_windows) {
+        for (auto const& window : ref_space->windows) {
             if (window->control && window->control->scripting) {
                 ret.push_back(window->control->scripting.get());
             }
@@ -983,7 +983,7 @@ protected:
 
     window* get_client_impl(qulonglong windowId) override
     {
-        for (auto& win : ref_space->m_windows) {
+        for (auto& win : ref_space->windows) {
             if (win->control && win->xcb_window == windowId) {
                 return win->control->scripting.get();
             }
diff --git a/win/activation.h b/win/activation.h
index 086a76f29..42f8d95cc 100644
--- a/win/activation.h
+++ b/win/activation.h
@@ -421,7 +421,7 @@ void set_active_window(Space& space, Toplevel* window)
         // activating a client can cause a non active fullscreen window to loose the ActiveLayer
         // status on > 1 screens
         if (kwinApp()->get_base().get_outputs().size() > 1) {
-            for (auto win : space.m_windows) {
+            for (auto win : space.windows) {
                 if (win->control && win != space.active_client && win->layer() == win::layer::active
                     && win->central_output == space.active_client->central_output) {
                     update_layer(win);
diff --git a/win/appmenu.h b/win/appmenu.h
index 196a05eae..0b70365fd 100644
--- a/win/appmenu.h
+++ b/win/appmenu.h
@@ -41,7 +41,7 @@ struct appmenu {
 template<typename Space>
 Toplevel* find_window_with_appmenu(Space const& space, appmenu_address const& address)
 {
-    for (auto win : space.m_windows) {
+    for (auto win : space.windows) {
         if (win->control && win->control->application_menu().address == address) {
             return win;
         }
diff --git a/win/deco/bridge.h b/win/deco/bridge.h
index 0c9cb154c..5bdb48c21 100644
--- a/win/deco/bridge.h
+++ b/win/deco/bridge.h
@@ -325,7 +325,7 @@ private:
 
     void recreateDecorations()
     {
-        for (auto win : space.m_windows) {
+        for (auto win : space.windows) {
             if (win->control) {
                 win->updateDecoration(true, true);
             }
diff --git a/win/geo_change.h b/win/geo_change.h
index 174c6b14c..e49f35683 100644
--- a/win/geo_change.h
+++ b/win/geo_change.h
@@ -42,7 +42,7 @@ int get_pack_position_left(Space const& space, Toplevel const* window, int oldX,
     const int desktop = window->desktop() == 0 || window->isOnAllDesktops()
         ? space.virtual_desktop_manager->current()
         : window->desktop();
-    for (auto win : space.m_windows) {
+    for (auto win : space.windows) {
         if (is_irrelevant(win, window, desktop)) {
             continue;
         }
@@ -87,7 +87,7 @@ int get_pack_position_right(Space const& space, Toplevel const* window, int oldX
     int const desktop = window->desktop() == 0 || window->isOnAllDesktops()
         ? space.virtual_desktop_manager->current()
         : window->desktop();
-    for (auto win : space.m_windows) {
+    for (auto win : space.windows) {
         if (is_irrelevant(win, window, desktop)) {
             continue;
         }
@@ -123,7 +123,7 @@ int get_pack_position_up(Space const& space, Toplevel const* window, int oldY, b
     int const desktop = window->desktop() == 0 || window->isOnAllDesktops()
         ? space.virtual_desktop_manager->current()
         : window->desktop();
-    for (auto win : space.m_windows) {
+    for (auto win : space.windows) {
         if (is_irrelevant(win, window, desktop)) {
             continue;
         }
@@ -166,7 +166,7 @@ int get_pack_position_down(Space const& space, Toplevel const* window, int oldY,
     int const desktop = window->desktop() == 0 || window->isOnAllDesktops()
         ? space.virtual_desktop_manager->current()
         : window->desktop();
-    for (auto win : space.m_windows) {
+    for (auto win : space.windows) {
         if (is_irrelevant(win, window, desktop)) {
             continue;
         }
diff --git a/win/internal_window.cpp b/win/internal_window.cpp
index 8a3040c2e..a453e86f3 100644
--- a/win/internal_window.cpp
+++ b/win/internal_window.cpp
@@ -617,7 +617,7 @@ void internal_window::markAsMapped()
 
     setReadyForPainting();
 
-    space.m_windows.push_back(this);
+    space.windows.push_back(this);
 
     setup_space_window_connections(&space, this);
     update_layer(this);
diff --git a/win/meta.h b/win/meta.h
index 997d1f8ee..90d04d5b4 100644
--- a/win/meta.h
+++ b/win/meta.h
@@ -100,7 +100,7 @@ bool is_special_window(Win* win)
 template<typename Win>
 Win* find_client_with_same_caption(Win const* win)
 {
-    for (auto candidate : win->space.m_windows) {
+    for (auto candidate : win->space.windows) {
         if (!candidate->control || candidate == win) {
             continue;
         }
diff --git a/win/move.h b/win/move.h
index ebe90a9f1..e02d2d289 100644
--- a/win/move.h
+++ b/win/move.h
@@ -907,7 +907,7 @@ void send_to_screen(Space const& space, Win* win, Output const& output)
         base::set_current_output(kwinApp()->get_base(), checked_output);
 
         // might impact the layer of a fullscreen window
-        for (auto cc : space.m_windows) {
+        for (auto cc : space.windows) {
             if (cc->control && cc->control->fullscreen() && cc->central_output == checked_output) {
                 update_layer(cc);
             }
diff --git a/win/placement.h b/win/placement.h
index 0d40e8fb0..c77f2e7f9 100644
--- a/win/placement.h
+++ b/win/placement.h
@@ -561,7 +561,7 @@ void place_maximizing(Win* window, const QRect& area, placement nextPlacement)
  */
 inline void unclutter_desktop(win::space& space)
 {
-    auto const& windows = space.m_windows;
+    auto const& windows = space.windows;
     for (int i = windows.size() - 1; i >= 0; i--) {
         auto client = windows.at(i);
         if (!client->control || !client->isOnCurrentDesktop() || client->control->minimized()
diff --git a/win/remnant.h b/win/remnant.h
index e70ce3a60..edb7281cb 100644
--- a/win/remnant.h
+++ b/win/remnant.h
@@ -23,7 +23,7 @@ template<typename Space>
 std::vector<Toplevel*> get_remnants(Space const& space)
 {
     std::vector<Toplevel*> ret;
-    for (auto const& window : space.m_windows) {
+    for (auto const& window : space.windows) {
         if (window->remnant) {
             ret.push_back(window);
         }
diff --git a/win/rules.h b/win/rules.h
index dd8443786..ec33b9003 100644
--- a/win/rules.h
+++ b/win/rules.h
@@ -17,7 +17,7 @@ template<typename Space>
 void init_rule_book(RuleBook& book, Space& space)
 {
     QObject::connect(&book, &RuleBook::updates_enabled, space.qobject.get(), [&] {
-        for (auto window : space.m_windows) {
+        for (auto window : space.windows) {
             if (window->control) {
                 window->updateWindowRules(Rules::All);
             }
diff --git a/win/session.h b/win/session.h
index f4d63046d..229aee2fe 100644
--- a/win/session.h
+++ b/win/session.h
@@ -95,7 +95,7 @@ void store_session(Space& space, QString const& sessionName, sm_save_phase phase
     int count = 0;
     int active_client = -1;
 
-    for (auto const& window : space.m_windows) {
+    for (auto const& window : space.windows) {
         if (!window->control) {
             continue;
         }
@@ -201,7 +201,7 @@ void store_subsession(Space const& space, QString const& name, QSet<QByteArray>
     int count = 0;
     int active_client = -1;
 
-    for (auto const& window : space.m_windows) {
+    for (auto const& window : space.windows) {
         if (!window->control) {
             continue;
         }
diff --git a/win/shortcut_set.h b/win/shortcut_set.h
index db0487180..28cb57c87 100644
--- a/win/shortcut_set.h
+++ b/win/shortcut_set.h
@@ -32,7 +32,7 @@ bool shortcut_available(Space& space, const QKeySequence& cut, Toplevel* ignore)
     }
 
     // Check now conflicts with activation shortcuts for current clients.
-    for (auto const win : space.m_windows) {
+    for (auto const win : space.windows) {
         if (win != ignore && win->control && win->control->shortcut() == cut) {
             return false;
         }
diff --git a/win/space.cpp b/win/space.cpp
index 6e697d72b..200b41b53 100644
--- a/win/space.cpp
+++ b/win/space.cpp
@@ -259,22 +259,22 @@ space::~space()
 
     win::x11::clear_space(*this);
 
-    for (auto const& window : m_windows) {
+    for (auto const& window : windows) {
         if (auto internal = qobject_cast<win::internal_window*>(window);
             internal && !internal->remnant) {
             internal->destroyClient();
-            remove_all(m_windows, internal);
+            remove_all(windows, internal);
         }
     }
 
     // At this point only remnants are remaining.
-    for (auto it = m_windows.begin(); it != m_windows.end();) {
+    for (auto it = windows.begin(); it != windows.end();) {
         assert((*it)->remnant);
         Q_EMIT qobject->window_deleted(*it);
-        it = m_windows.erase(it);
+        it = windows.erase(it);
     }
 
-    assert(m_windows.empty());
+    assert(windows.empty());
 
     stacking_order.reset();
 
@@ -311,7 +311,7 @@ void space::disableGlobalShortcutsForClient(bool disable)
 
     global_shortcuts_disabled_for_client = disable;
     // Update also Meta+LMB actions etc.
-    for (auto window : m_windows) {
+    for (auto window : windows) {
         if (auto& ctrl = window->control) {
             ctrl->update_mouse_grab();
         }
@@ -414,7 +414,7 @@ void space::updateOnAllDesktopsOfTransients(Toplevel* window)
 // window.
 void space::checkTransients(Toplevel* window)
 {
-    std::for_each(m_windows.cbegin(), m_windows.cend(), [&window](auto const& client) {
+    std::for_each(windows.cbegin(), windows.cend(), [&window](auto const& client) {
         client->checkTransient(window);
     });
 }
@@ -589,7 +589,7 @@ space::adjustClientPosition(Toplevel* window, QPoint pos, bool unrestricted, dou
         // windows snap
         int snap = kwinApp()->options->windowSnapZone() * snapAdjust;
         if (snap) {
-            for (auto win : m_windows) {
+            for (auto win : windows) {
                 if (!win->control) {
                     continue;
                 }
@@ -806,7 +806,7 @@ QRect space::adjustClientSize(Toplevel* window, QRect moveResizeGeom, win::posit
         if (snap) {
             deltaX = int(snap);
             deltaY = int(snap);
-            for (auto win : m_windows) {
+            for (auto win : windows) {
                 if (win->control && win->isOnDesktop(virtual_desktop_manager->current())
                     && !win->control->minimized() && win != window) {
                     lx = win->pos().x() - 1;
@@ -962,9 +962,4 @@ void space::fixPositionAfterCrash(xcb_window_t w, const xcb_get_geometry_reply_t
     }
 }
 
-std::vector<Toplevel*> const& space::windows() const
-{
-    return m_windows;
-}
-
 }
diff --git a/win/space.h b/win/space.h
index efe4e2b81..6f864312c 100644
--- a/win/space.h
+++ b/win/space.h
@@ -168,7 +168,7 @@ public:
     using qobject_t = space_qobject;
     std::unique_ptr<qobject_t> qobject;
 
-    std::vector<Toplevel*> m_windows;
+    std::vector<Toplevel*> windows;
     std::vector<win::x11::group*> groups;
 
     win::space_areas areas;
@@ -254,8 +254,6 @@ public:
     std::unique_ptr<base::dbus::kwin_impl<space>> dbus;
     std::unique_ptr<win::session_manager> session_manager;
 
-    std::vector<Toplevel*> const& windows() const;
-
     void updateTabbox();
 
     QTimer* m_quickTileCombineTimer{nullptr};
diff --git a/win/space_areas_helpers.h b/win/space_areas_helpers.h
index b35fb39a1..840c24cc9 100644
--- a/win/space_areas_helpers.h
+++ b/win/space_areas_helpers.h
@@ -88,7 +88,7 @@ void update_space_areas_impl(Space& space, bool force)
             }
         }
 
-        for (auto win : space.m_windows) {
+        for (auto win : space.windows) {
             if (win->control) {
                 check_workspace_position(win);
             }
diff --git a/win/space_reconfigure.h b/win/space_reconfigure.h
index 03fe45ea9..83361f05d 100644
--- a/win/space_reconfigure.h
+++ b/win/space_reconfigure.h
@@ -40,7 +40,7 @@ void space_reconfigure(Space& space)
     x11::update_tool_windows_visibility(&space, true);
 
     space.rule_book->load();
-    for (auto window : space.m_windows) {
+    for (auto window : space.windows) {
         if (window->supportsWindowRules()) {
             win::evaluate_rules(window);
             space.rule_book->discardUsed(window, false);
@@ -51,7 +51,7 @@ void space_reconfigure(Space& space)
         && !kwinApp()->options->borderlessMaximizedWindows()) {
         // in case borderless maximized windows option changed and new option
         // is to have borders, we need to unset the borders for all maximized windows
-        for (auto window : space.m_windows) {
+        for (auto window : space.windows) {
             if (window->maximizeMode() == win::maximize_mode::full) {
                 window->checkNoBorder();
             }
diff --git a/win/space_window_release.h b/win/space_window_release.h
index 3fbbd5f15..e76f7eb23 100644
--- a/win/space_window_release.h
+++ b/win/space_window_release.h
@@ -22,7 +22,7 @@ void remove_window_from_stacking_order(Space& space, Win* win)
 template<typename Space, typename Win>
 void remove_window_from_lists(Space& space, Win* win)
 {
-    remove_all(space.m_windows, win);
+    remove_all(space.windows, win);
     space.stacking_order->render_restack_required = true;
 }
 
@@ -44,9 +44,9 @@ template<typename Win1, typename Win2>
 void add_remnant(Win1& orig, Win2& remnant)
 {
     auto& space = orig.space;
-    assert(!contains(space.m_windows, &remnant));
+    assert(!contains(space.windows, &remnant));
 
-    space.m_windows.push_back(&remnant);
+    space.windows.push_back(&remnant);
 
     auto const unconstraintedIndex = index_of(space.stacking_order->pre_stack, &orig);
     if (unconstraintedIndex != -1) {
diff --git a/win/tabbox/tabbox.cpp b/win/tabbox/tabbox.cpp
index 985fc101d..e49a58150 100644
--- a/win/tabbox/tabbox.cpp
+++ b/win/tabbox/tabbox.cpp
@@ -647,7 +647,7 @@ Toplevel* tabbox::current_client()
 {
     if (auto client
         = static_cast<tabbox_client_impl*>(m_tabbox->client(m_tabbox->current_index()))) {
-        for (auto win : space.m_windows) {
+        for (auto win : space.windows) {
             if (win == client->client()) {
                 return win;
             }
@@ -1495,7 +1495,7 @@ std::vector<Toplevel*> get_windows_with_control(std::vector<Toplevel*>& windows)
  */
 Toplevel* tabbox::next_client_static(Toplevel* c) const
 {
-    auto const& list = get_windows_with_control(space.m_windows);
+    auto const& list = get_windows_with_control(space.windows);
     if (!c || list.empty()) {
         return nullptr;
     }
@@ -1516,7 +1516,7 @@ Toplevel* tabbox::next_client_static(Toplevel* c) const
  */
 Toplevel* tabbox::previous_client_static(Toplevel* c) const
 {
-    auto const& list = get_windows_with_control(space.m_windows);
+    auto const& list = get_windows_with_control(space.windows);
     if (!c || list.empty()) {
         return nullptr;
     }
diff --git a/win/wayland/layer_shell.h b/win/wayland/layer_shell.h
index 7cbd35c8a..46e758361 100644
--- a/win/wayland/layer_shell.h
+++ b/win/wayland/layer_shell.h
@@ -159,7 +159,7 @@ void assign_layer_surface_role(Win* win, Wrapland::Server::LayerSurfaceV1* layer
         layer_surface, &WS::LayerSurfaceV1::resourceDestroyed, win, [win] { destroy_window(win); });
 
     QObject::connect(layer_surface, &WS::LayerSurfaceV1::got_popup, win, [win](auto popup) {
-        for (auto window : static_cast<win::wayland::space&>(win->space).m_windows) {
+        for (auto window : static_cast<win::wayland::space&>(win->space).windows) {
             if (auto wayland_window = qobject_cast<win::wayland::window*>(window);
                 wayland_window && wayland_window->popup == popup) {
                 win->transient()->add_child(wayland_window);
@@ -222,11 +222,11 @@ void handle_new_layer_surface(Space* space, Wrapland::Server::LayerSurfaceV1* la
         ScreenLocker::KSldApp::self()->lockScreenShown();
     }
 
-    space->m_windows.push_back(window);
+    space->windows.push_back(window);
     QObject::connect(layer_surface,
                      &Wrapland::Server::LayerSurfaceV1::resourceDestroyed,
                      space->qobject.get(),
-                     [space, window] { remove_all(space->m_windows, window); });
+                     [space, window] { remove_all(space->windows, window); });
 
     win::wayland::assign_layer_surface_role(window, layer_surface);
 
diff --git a/win/wayland/space.cpp b/win/wayland/space.cpp
index 65d280f80..8d796a51f 100644
--- a/win/wayland/space.cpp
+++ b/win/wayland/space.cpp
@@ -76,7 +76,7 @@ space::space(render::compositor& render, base::wayland::server* server)
     virtual_desktop_manager->setVirtualDesktopManagement(plasma_virtual_desktop_manager.get());
 
     QObject::connect(stacking_order.get(), &stacking_order::render_restack, qobject.get(), [this] {
-        for (auto win : m_windows) {
+        for (auto win : windows) {
             if (auto iwin = qobject_cast<internal_window*>(win); iwin && iwin->isShown()) {
                 stacking_order->render_overlays.push_back(iwin);
             }
@@ -121,7 +121,7 @@ space::space(render::compositor& render, base::wayland::server* server)
 
     QObject::connect(
         qobject.get(), &space::qobject_t::currentDesktopChanged, kde_idle.get(), [this] {
-            for (auto win : m_windows) {
+            for (auto win : windows) {
                 if (!win->control) {
                     continue;
                 }
@@ -187,10 +187,10 @@ space::~space()
 {
     stacking_order->lock();
 
-    for (auto const& window : m_windows) {
+    for (auto const& window : windows) {
         if (auto win = qobject_cast<win::wayland::window*>(window); win && !win->remnant) {
             destroy_window(win);
-            remove_all(m_windows, win);
+            remove_all(windows, win);
         }
     }
 }
@@ -202,10 +202,9 @@ window* space::find_window(Wrapland::Server::Surface* surface) const
         return nullptr;
     }
 
-    auto it = std::find_if(m_windows.cbegin(), m_windows.cend(), [surface](auto win) {
-        return win->surface == surface;
-    });
-    return it != m_windows.cend() ? qobject_cast<window*>(*it) : nullptr;
+    auto it = std::find_if(
+        windows.cbegin(), windows.cend(), [surface](auto win) { return win->surface == surface; });
+    return it != windows.cend() ? qobject_cast<window*>(*it) : nullptr;
 }
 
 void space::handle_window_added(wayland::window* window)
@@ -273,7 +272,7 @@ void space::handle_window_added(wayland::window* window)
 
 void space::handle_window_removed(wayland::window* window)
 {
-    remove_all(m_windows, window);
+    remove_all(windows, window);
 
     if (window->control) {
         if (window == most_recently_raised) {
@@ -319,7 +318,7 @@ void space::handle_x11_window_added(x11::window* window)
 
 void space::handle_desktop_removed(virtual_desktop* desktop)
 {
-    for (auto const& client : m_windows) {
+    for (auto const& client : windows) {
         if (!client->control) {
             continue;
         }
@@ -345,7 +344,7 @@ Toplevel* space::findInternal(QWindow* window) const
         return nullptr;
     }
 
-    for (auto win : m_windows) {
+    for (auto win : windows) {
         if (auto internal = qobject_cast<internal_window*>(win);
             internal && internal->internalWindow() == window) {
             return internal;
@@ -392,7 +391,7 @@ void space::update_space_area_from_windows(QRect const& desktop_area,
                                            std::vector<QRect> const& screens_geos,
                                            win::space_areas& areas)
 {
-    for (auto const& window : m_windows) {
+    for (auto const& window : windows) {
         if (!window->control) {
             continue;
         }
@@ -402,7 +401,7 @@ void space::update_space_area_from_windows(QRect const& desktop_area,
     }
 
     // TODO(romangg): Combine this and above loop.
-    for (auto win : m_windows) {
+    for (auto win : windows) {
         // TODO(romangg): check on control like in the previous loop?
         if (auto wl_win = qobject_cast<win::wayland::window*>(win)) {
             update_space_areas(wl_win, desktop_area, screens_geos, areas);
diff --git a/win/wayland/subsurface.h b/win/wayland/subsurface.h
index 9a8c90e48..6d82b02e7 100644
--- a/win/wayland/subsurface.h
+++ b/win/wayland/subsurface.h
@@ -131,15 +131,15 @@ void handle_new_subsurface(Space* space, Wrapland::Server::Subsurface* subsurfac
 {
     auto window = new Window(subsurface->surface(), *space);
 
-    space->m_windows.push_back(window);
+    space->windows.push_back(window);
     QObject::connect(subsurface,
                      &Wrapland::Server::Subsurface::resourceDestroyed,
                      space->qobject.get(),
-                     [space, window] { remove_all(space->m_windows, window); });
+                     [space, window] { remove_all(space->windows, window); });
 
     assign_subsurface_role(window);
 
-    for (auto& win : space->m_windows) {
+    for (auto& win : space->windows) {
         if (win->surface == subsurface->parentSurface()) {
             win::wayland::set_subsurface_parent(window, win);
             if (window->ready_for_painting) {
diff --git a/win/wayland/transient.h b/win/wayland/transient.h
index 9b61616c4..95ad22d13 100644
--- a/win/wayland/transient.h
+++ b/win/wayland/transient.h
@@ -13,7 +13,7 @@ namespace KWin::win::wayland
 template<typename Window, typename Space>
 void adopt_transient_children(Space* space, Window* window)
 {
-    auto const& wins = space->m_windows;
+    auto const& wins = space->windows;
     std::for_each(wins.cbegin(), wins.cend(), [&window](auto win) {
         // Children can only be of same window type.
         // TODO(romangg): Make this cast unnecessary, i.e. check in the checkTransient functions.
diff --git a/win/wayland/window.cpp b/win/wayland/window.cpp
index f868885d4..6c30d14b5 100644
--- a/win/wayland/window.cpp
+++ b/win/wayland/window.cpp
@@ -832,7 +832,7 @@ void window::do_set_fullscreen(bool full)
 
 bool window::belongsToDesktop() const
 {
-    auto const windows = static_cast<win::wayland::space&>(space).m_windows;
+    auto const windows = static_cast<win::wayland::space&>(space).windows;
 
     return std::any_of(windows.cbegin(), windows.cend(), [this](auto const& win) {
         if (belongsToSameApplication(win, flags<same_client_check>())) {
diff --git a/win/wayland/window_release.h b/win/wayland/window_release.h
index 324676dfe..9fd093167 100644
--- a/win/wayland/window_release.h
+++ b/win/wayland/window_release.h
@@ -34,7 +34,7 @@ void destroy_window(Win* win)
         // With the lead gone there is no way - and no need - for remnant effects. Delete directly.
         Q_EMIT win->closed(win);
         space.handle_window_removed(win);
-        remove_all(space.m_windows, win);
+        remove_all(space.windows, win);
         remove_all(space.stacking_order->pre_stack, win);
         remove_all(space.stacking_order->stack, win);
         delete win;
diff --git a/win/wayland/xdg_shell.h b/win/wayland/xdg_shell.h
index 838e24a14..37256188b 100644
--- a/win/wayland/xdg_shell.h
+++ b/win/wayland/xdg_shell.h
@@ -597,7 +597,7 @@ void handle_new_toplevel(Space* space, Wrapland::Server::XdgShellToplevel* tople
         win::wayland::install_palette(window, palette);
     }
 
-    space->m_windows.push_back(window);
+    space->windows.push_back(window);
 
     if (window->ready_for_painting) {
         space->handle_window_added(window);
@@ -619,7 +619,7 @@ template<typename Window, typename Space>
 void handle_new_popup(Space* space, Wrapland::Server::XdgShellPopup* popup)
 {
     auto window = win::wayland::create_popup_window(space, popup);
-    space->m_windows.push_back(window);
+    space->windows.push_back(window);
 
     if (window->ready_for_painting) {
         space->handle_window_added(window);
diff --git a/win/x11/control.h b/win/x11/control.h
index 201cc7435..f3e4ca30b 100644
--- a/win/x11/control.h
+++ b/win/x11/control.h
@@ -841,7 +841,7 @@ xcb_timestamp_t read_user_time_map_timestamp(Win* win,
                 else
                     first_window = false;
             } else {
-                for (auto win : win->space.m_windows) {
+                for (auto win : win->space.windows) {
                     if (win->control && sameApplicationActiveHackPredicate(win)) {
                         first_window = false;
                         break;
diff --git a/win/x11/event.h b/win/x11/event.h
index 30ab11c3a..a4ba6fd42 100644
--- a/win/x11/event.h
+++ b/win/x11/event.h
@@ -876,7 +876,7 @@ void focus_in_event(Win* win, xcb_focus_in_event_t* e)
         return;
     }
 
-    for (auto win : win->space.m_windows) {
+    for (auto win : win->space.windows) {
         if (auto x11_win = qobject_cast<window*>(win)) {
             cancel_focus_out_timer(x11_win);
         }
diff --git a/win/x11/space.cpp b/win/x11/space.cpp
index 861a2813a..ec07d3c08 100644
--- a/win/x11/space.cpp
+++ b/win/x11/space.cpp
@@ -28,7 +28,7 @@ space::space(render::compositor& render)
                      [this] {
                          auto const desktop_count
                              = static_cast<int>(virtual_desktop_manager->count());
-                         for (auto const& window : m_windows) {
+                         for (auto const& window : windows) {
                              if (!window->control) {
                                  continue;
                              }
@@ -82,7 +82,7 @@ void space::update_space_area_from_windows(QRect const& desktop_area,
                                            std::vector<QRect> const& screens_geos,
                                            win::space_areas& areas)
 {
-    for (auto const& window : m_windows) {
+    for (auto const& window : windows) {
         if (!window->control) {
             continue;
         }
diff --git a/win/x11/space_setup.h b/win/x11/space_setup.h
index 61de2c715..e9cb7ddef 100644
--- a/win/x11/space_setup.h
+++ b/win/x11/space_setup.h
@@ -208,12 +208,12 @@ void clear_space(Space& space)
 
         // No removeClient() is called, it does more than just removing.
         // However, remove from some lists to e.g. prevent performTransiencyCheck() from crashing.
-        remove_all(space.m_windows, window);
+        remove_all(space.windows, window);
     }
 
     for (auto const& unmanaged : get_unmanageds<Toplevel>(space)) {
         release_window(static_cast<window*>(unmanaged), is_x11);
-        remove_all(space.m_windows, unmanaged);
+        remove_all(space.windows, unmanaged);
         remove_all(space.stacking_order->pre_stack, unmanaged);
     }
 
diff --git a/win/x11/stacking.h b/win/x11/stacking.h
index a289cee69..cb9c39548 100644
--- a/win/x11/stacking.h
+++ b/win/x11/stacking.h
@@ -27,7 +27,7 @@ template<typename Win, typename Space>
 std::vector<Win*> get_unmanageds(Space const& space)
 {
     std::vector<Win*> ret;
-    for (auto const& window : space.m_windows) {
+    for (auto const& window : space.windows) {
         if (window->xcb_window && !window->control && !window->remnant) {
             ret.push_back(window);
         }
@@ -135,7 +135,7 @@ void propagate_clients(Space& space, bool propagate_new_clients)
                   order.manual_overlays.end(),
                   std::back_inserter(clients));
 
-        for (auto const& window : space.m_windows) {
+        for (auto const& window : space.windows) {
             if (!window->control) {
                 continue;
             }
diff --git a/win/x11/sync_alarm_filter.cpp b/win/x11/sync_alarm_filter.cpp
index d7bf0fbd4..5159baa6e 100644
--- a/win/x11/sync_alarm_filter.cpp
+++ b/win/x11/sync_alarm_filter.cpp
@@ -40,7 +40,7 @@ bool sync_alarm_filter::event(xcb_generic_event_t* event)
 {
     auto alarmEvent = reinterpret_cast<xcb_sync_alarm_notify_event_t*>(event);
 
-    for (auto win : space.m_windows) {
+    for (auto win : space.windows) {
         if (!win->control) {
             continue;
         }
diff --git a/win/x11/tool_windows.h b/win/x11/tool_windows.h
index f8df76a18..8e01d47e6 100644
--- a/win/x11/tool_windows.h
+++ b/win/x11/tool_windows.h
@@ -28,7 +28,7 @@ template<typename Space>
 void update_tool_windows_visibility(Space* space, bool also_hide)
 {
     if (!kwinApp()->options->isHideUtilityWindowsForInactive()) {
-        for (auto const& window : space->m_windows) {
+        for (auto const& window : space->windows) {
             if (window->control) {
                 window->hideClient(false);
             }
diff --git a/win/x11/transient.h b/win/x11/transient.h
index 91d1af612..fdcbb4682 100644
--- a/win/x11/transient.h
+++ b/win/x11/transient.h
@@ -424,7 +424,7 @@ group* find_client_leader_group(Win const* win)
 {
     group* ret = nullptr;
 
-    for (auto const& other : win->space.m_windows) {
+    for (auto const& other : win->space.windows) {
         if (!other->control) {
             continue;
         }
diff --git a/win/x11/unmanaged.h b/win/x11/unmanaged.h
index 5bc012198..e5d9663e2 100644
--- a/win/x11/unmanaged.h
+++ b/win/x11/unmanaged.h
@@ -19,7 +19,7 @@ namespace KWin::win::x11
 template<typename Win, typename Space>
 Win* find_unmanaged(Space&& space, xcb_window_t xcb_win)
 {
-    for (auto win : space.m_windows) {
+    for (auto win : space.windows) {
         if (!win->remnant && !win->control && win->xcb_window == xcb_win) {
             return static_cast<Win*>(win);
         }
@@ -111,7 +111,7 @@ auto create_unmanaged_window(xcb_window_t xcb_win, Space& space) -> typename Spa
     QObject::connect(
         win, &Win::needsRepaint, &space.render, [win] { win->space.render.schedule_repaint(win); });
 
-    space.m_windows.push_back(win);
+    space.windows.push_back(win);
     space.stacking_order->render_restack_required = true;
     Q_EMIT space.qobject->unmanagedAdded(win);
 
diff --git a/win/x11/window_create.h b/win/x11/window_create.h
index 9422c4421..a27fd1252 100644
--- a/win/x11/window_create.h
+++ b/win/x11/window_create.h
@@ -18,7 +18,7 @@ void add_controlled_window_to_space(Space& space, Win* win)
 {
     auto grp = find_group(space, win->xcb_window);
 
-    space.m_windows.push_back(win);
+    space.windows.push_back(win);
     Q_EMIT space.qobject->clientAdded(win);
 
     if (grp) {
diff --git a/win/x11/window_find.h b/win/x11/window_find.h
index 0489d5f79..21a20b025 100644
--- a/win/x11/window_find.h
+++ b/win/x11/window_find.h
@@ -17,7 +17,7 @@ template<typename Win, typename Space>
 Win* find_controlled_window(Space& space, predicate_match predicate, xcb_window_t w)
 {
     auto find_window = [&](std::function<bool(Win const*)> const& func) -> Win* {
-        for (auto win : space.m_windows) {
+        for (auto win : space.windows) {
             if (!win->control) {
                 continue;
             }
diff --git a/win/x11/window_release.h b/win/x11/window_release.h
index ff3867b1a..a49d3fc35 100644
--- a/win/x11/window_release.h
+++ b/win/x11/window_release.h
@@ -43,7 +43,7 @@ void remove_controlled_window_from_space(Space& space, Win* win)
         window_shortcut_updated(space, win);
     }
 
-    assert(contains(space.m_windows, win));
+    assert(contains(space.windows, win));
 
     // TODO: if marked client is removed, notify the marked list
     remove_window_from_lists(space, win);
@@ -98,7 +98,7 @@ template<typename Win>
 void finish_unmanaged_removal(Win* win, Toplevel* remnant)
 {
     auto& space = win->space;
-    assert(contains(space.m_windows, win));
+    assert(contains(space.windows, win));
 
     remove_window_from_lists(space, win);
     space.render.addRepaint(visible_rect(win));
diff --git a/xwl/surface.h b/xwl/surface.h
index 8cdcb0376..d730b6ad4 100644
--- a/xwl/surface.h
+++ b/xwl/surface.h
@@ -21,7 +21,7 @@ void handle_new_surface(Space* space, Wrapland::Server::Surface* surface)
         return;
     }
 
-    for (auto win : space->m_windows) {
+    for (auto win : space->windows) {
         // Match on surface id and exclude windows already having a surface. This way we only find
         // Xwayland windows. Wayland native windows always have a surface.
         if (!win->remnant && win->surface_id == surface->id() && !win->surface) {
-- 
GitLab


From 3b7971a3d3e20b7c1540bc895c493ec3e92c621c Mon Sep 17 00:00:00 2001
From: Roman Gilg <subdiff@gmail.com>
Date: Mon, 11 Jul 2022 20:23:51 +0200
Subject: [PATCH 32/51] refactor: reimplement geometry adjust functions as free
 functions

This way they can be reused by different types of spaces.
---
 .../integration/move_resize_window_test.cpp   |  12 +-
 render/effects.cpp                            |   4 +-
 win/geo_restrict.h                            | 487 +++++++++++++++++
 win/move.h                                    |   6 +-
 win/space.cpp                                 | 497 ------------------
 win/space.h                                   |   5 -
 win/x11/placement.h                           |  20 +
 win/x11/space_setup.h                         |   3 +-
 8 files changed, 521 insertions(+), 513 deletions(-)

diff --git a/autotests/integration/move_resize_window_test.cpp b/autotests/integration/move_resize_window_test.cpp
index 1fc279e92..0afbe880d 100644
--- a/autotests/integration/move_resize_window_test.cpp
+++ b/autotests/integration/move_resize_window_test.cpp
@@ -856,7 +856,7 @@ void MoveResizeWindowTest::testAdjustClientGeometryOfAutohidingX11Panel()
     QVERIFY(testWindow->isMovable());
     // panel is not yet hidden, we should snap against it
     QFETCH(QPoint, targetPoint);
-    QTEST(Test::app()->workspace->adjustClientPosition(testWindow, targetPoint, false),
+    QTEST(win::adjust_window_position(*Test::app()->workspace, *testWindow, targetPoint, false),
           "expectedAdjustedPoint");
 
     // now let's hide the panel
@@ -875,7 +875,7 @@ void MoveResizeWindowTest::testAdjustClientGeometryOfAutohidingX11Panel()
     QVERIFY(panelHiddenSpy.wait());
 
     // now try to snap again
-    QCOMPARE(Test::app()->workspace->adjustClientPosition(testWindow, targetPoint, false),
+    QCOMPARE(win::adjust_window_position(*Test::app()->workspace, *testWindow, targetPoint, false),
              targetPoint);
 
     // and destroy the panel again
@@ -889,7 +889,7 @@ void MoveResizeWindowTest::testAdjustClientGeometryOfAutohidingX11Panel()
     QVERIFY(panelClosedSpy.wait());
 
     // snap once more
-    QCOMPARE(Test::app()->workspace->adjustClientPosition(testWindow, targetPoint, false),
+    QCOMPARE(win::adjust_window_position(*Test::app()->workspace, *testWindow, targetPoint, false),
              targetPoint);
 
     // and close
@@ -951,7 +951,7 @@ void MoveResizeWindowTest::testAdjustClientGeometryOfAutohidingWaylandPanel()
     QVERIFY(testWindow->isMovable());
     // panel is not yet hidden, we should snap against it
     QFETCH(QPoint, targetPoint);
-    QTEST(Test::app()->workspace->adjustClientPosition(testWindow, targetPoint, false),
+    QTEST(win::adjust_window_position(*Test::app()->workspace, *testWindow, targetPoint, false),
           "expectedAdjustedPoint");
 
     // now let's hide the panel
@@ -961,7 +961,7 @@ void MoveResizeWindowTest::testAdjustClientGeometryOfAutohidingWaylandPanel()
     QVERIFY(panelHiddenSpy.wait());
 
     // now try to snap again
-    QCOMPARE(Test::app()->workspace->adjustClientPosition(testWindow, targetPoint, false),
+    QCOMPARE(win::adjust_window_position(*Test::app()->workspace, *testWindow, targetPoint, false),
              targetPoint);
 
     // and destroy the panel again
@@ -973,7 +973,7 @@ void MoveResizeWindowTest::testAdjustClientGeometryOfAutohidingWaylandPanel()
     QVERIFY(panelClosedSpy.wait());
 
     // snap once more
-    QCOMPARE(Test::app()->workspace->adjustClientPosition(testWindow, targetPoint, false),
+    QCOMPARE(win::adjust_window_position(*Test::app()->workspace, *testWindow, targetPoint, false),
              targetPoint);
 
     // and close
diff --git a/render/effects.cpp b/render/effects.cpp
index e12a05436..43031e047 100644
--- a/render/effects.cpp
+++ b/render/effects.cpp
@@ -920,7 +920,9 @@ void effects_handler_impl::moveWindow(EffectWindow* w,
     }
 
     if (snap) {
-        win::move(window, m_compositor->space->adjustClientPosition(window, pos, true, snapAdjust));
+        win::move(
+            window,
+            win::adjust_window_position(*m_compositor->space, *window, pos, true, snapAdjust));
     } else {
         win::move(window, pos);
     }
diff --git a/win/geo_restrict.h b/win/geo_restrict.h
index fa5b4f257..bf9443e86 100644
--- a/win/geo_restrict.h
+++ b/win/geo_restrict.h
@@ -329,4 +329,491 @@ void check_workspace_position(Win* win,
     win->setFrameGeometry(frame_geo);
 }
 
+/**
+ * Client \a c is moved around to position \a pos. This gives the
+ * space:: the opportunity to interveniate and to implement
+ * snap-to-windows functionality.
+ *
+ * The parameter \a snapAdjust is a multiplier used to calculate the
+ * effective snap zones. When 1.0, it means that the snap zones will be
+ * used without change.
+ */
+template<typename Space, typename Win>
+QPoint adjust_window_position(Space const& space,
+                              Win const& window,
+                              QPoint pos,
+                              bool unrestricted,
+                              double snapAdjust = 1.0)
+{
+    QSize borderSnapZone(kwinApp()->options->borderSnapZone(),
+                         kwinApp()->options->borderSnapZone());
+    QRect maxRect;
+    auto guideMaximized = maximize_mode::restore;
+
+    if (window.maximizeMode() != maximize_mode::restore) {
+        maxRect = space_window_area(
+            space, MaximizeArea, pos + QRect(QPoint(), window.size()).center(), window.desktop());
+        QRect geo = window.frameGeometry();
+        if (flags(window.maximizeMode() & maximize_mode::horizontal)
+            && (geo.x() == maxRect.left() || geo.right() == maxRect.right())) {
+            guideMaximized |= maximize_mode::horizontal;
+            borderSnapZone.setWidth(qMax(borderSnapZone.width() + 2, maxRect.width() / 16));
+        }
+        if (flags(window.maximizeMode() & maximize_mode::vertical)
+            && (geo.y() == maxRect.top() || geo.bottom() == maxRect.bottom())) {
+            guideMaximized |= maximize_mode::vertical;
+            borderSnapZone.setHeight(qMax(borderSnapZone.height() + 2, maxRect.height() / 16));
+        }
+    }
+
+    if (kwinApp()->options->windowSnapZone() || !borderSnapZone.isNull()
+        || kwinApp()->options->centerSnapZone()) {
+        auto const& outputs = kwinApp()->get_base().get_outputs();
+        const bool sOWO = kwinApp()->options->isSnapOnlyWhenOverlapping();
+        auto output
+            = base::get_nearest_output(outputs, pos + QRect(QPoint(), window.size()).center());
+
+        if (maxRect.isNull()) {
+            maxRect = space_window_area(space, MovementArea, output, window.desktop());
+        }
+
+        const int xmin = maxRect.left();
+        const int xmax = maxRect.right() + 1; // desk size
+        const int ymin = maxRect.top();
+        const int ymax = maxRect.bottom() + 1;
+
+        const int cx(pos.x());
+        const int cy(pos.y());
+        const int cw(window.size().width());
+        const int ch(window.size().height());
+        const int rx(cx + cw);
+        const int ry(cy + ch); // these don't change
+
+        int nx(cx), ny(cy); // buffers
+        int deltaX(xmax);
+        int deltaY(ymax); // minimum distance to other clients
+
+        int lx, ly, lrx, lry; // coords and size for the comparison client, l
+
+        // border snap
+        const int snapX = borderSnapZone.width() * snapAdjust; // snap trigger
+        const int snapY = borderSnapZone.height() * snapAdjust;
+        if (snapX || snapY) {
+            auto geo = window.frameGeometry();
+            auto frameMargins = frame_margins(&window);
+
+            // snap to titlebar / snap to window borders on inner screen edges
+            if (frameMargins.left()
+                && (flags(window.maximizeMode() & maximize_mode::horizontal)
+                    || base::get_intersecting_outputs(
+                           outputs,
+                           geo.translated(maxRect.x() - (frameMargins.left() + geo.x()), 0))
+                            .size()
+                        > 1)) {
+                frameMargins.setLeft(0);
+            }
+            if (frameMargins.right()
+                && (flags(window.maximizeMode() & maximize_mode::horizontal)
+                    || base::get_intersecting_outputs(
+                           outputs,
+                           geo.translated(maxRect.right() + frameMargins.right() - geo.right(), 0))
+                            .size()
+                        > 1)) {
+                frameMargins.setRight(0);
+            }
+            if (frameMargins.top()) {
+                frameMargins.setTop(0);
+            }
+            if (frameMargins.bottom()
+                && (flags(window.maximizeMode() & maximize_mode::vertical)
+                    || base::get_intersecting_outputs(
+                           outputs,
+                           geo.translated(0,
+                                          maxRect.bottom() + frameMargins.bottom() - geo.bottom()))
+                            .size()
+                        > 1)) {
+                frameMargins.setBottom(0);
+            }
+            if ((sOWO ? (cx < xmin) : true) && (qAbs(xmin - cx) < snapX)) {
+                deltaX = xmin - cx;
+                nx = xmin - frameMargins.left();
+            }
+            if ((sOWO ? (rx > xmax) : true) && (qAbs(rx - xmax) < snapX)
+                && (qAbs(xmax - rx) < deltaX)) {
+                deltaX = rx - xmax;
+                nx = xmax - cw + frameMargins.right();
+            }
+
+            if ((sOWO ? (cy < ymin) : true) && (qAbs(ymin - cy) < snapY)) {
+                deltaY = ymin - cy;
+                ny = ymin - frameMargins.top();
+            }
+            if ((sOWO ? (ry > ymax) : true) && (qAbs(ry - ymax) < snapY)
+                && (qAbs(ymax - ry) < deltaY)) {
+                deltaY = ry - ymax;
+                ny = ymax - ch + frameMargins.bottom();
+            }
+        }
+
+        // windows snap
+        int snap = kwinApp()->options->windowSnapZone() * snapAdjust;
+        if (snap) {
+            for (auto win : space.windows) {
+                if (!win->control) {
+                    continue;
+                }
+
+                if (win == &window) {
+                    continue;
+                }
+                if (win->control->minimized()) {
+                    continue;
+                }
+                if (!win->isShown()) {
+                    continue;
+                }
+                if (!win->isOnDesktop(window.desktop()) && !window.isOnDesktop(win->desktop())) {
+                    // wrong virtual desktop
+                    continue;
+                }
+                if (is_desktop(win) || is_splash(win)) {
+                    continue;
+                }
+
+                lx = win->pos().x();
+                ly = win->pos().y();
+                lrx = lx + win->size().width();
+                lry = ly + win->size().height();
+
+                if (!flags(guideMaximized & maximize_mode::horizontal)
+                    && (((cy <= lry) && (cy >= ly)) || ((ry >= ly) && (ry <= lry))
+                        || ((cy <= ly) && (ry >= lry)))) {
+                    if ((sOWO ? (cx < lrx) : true) && (qAbs(lrx - cx) < snap)
+                        && (qAbs(lrx - cx) < deltaX)) {
+                        deltaX = qAbs(lrx - cx);
+                        nx = lrx;
+                    }
+                    if ((sOWO ? (rx > lx) : true) && (qAbs(rx - lx) < snap)
+                        && (qAbs(rx - lx) < deltaX)) {
+                        deltaX = qAbs(rx - lx);
+                        nx = lx - cw;
+                    }
+                }
+
+                if (!flags(guideMaximized & maximize_mode::vertical)
+                    && (((cx <= lrx) && (cx >= lx)) || ((rx >= lx) && (rx <= lrx))
+                        || ((cx <= lx) && (rx >= lrx)))) {
+                    if ((sOWO ? (cy < lry) : true) && (qAbs(lry - cy) < snap)
+                        && (qAbs(lry - cy) < deltaY)) {
+                        deltaY = qAbs(lry - cy);
+                        ny = lry;
+                    }
+                    // if ( (qAbs( ry-ly ) < snap) && (qAbs( ry - ly ) < deltaY ))
+                    if ((sOWO ? (ry > ly) : true) && (qAbs(ry - ly) < snap)
+                        && (qAbs(ry - ly) < deltaY)) {
+                        deltaY = qAbs(ry - ly);
+                        ny = ly - ch;
+                    }
+                }
+
+                // Corner snapping
+                if (!flags(guideMaximized & maximize_mode::vertical)
+                    && (nx == lrx || nx + cw == lx)) {
+                    if ((sOWO ? (ry > lry) : true) && (qAbs(lry - ry) < snap)
+                        && (qAbs(lry - ry) < deltaY)) {
+                        deltaY = qAbs(lry - ry);
+                        ny = lry - ch;
+                    }
+                    if ((sOWO ? (cy < ly) : true) && (qAbs(cy - ly) < snap)
+                        && (qAbs(cy - ly) < deltaY)) {
+                        deltaY = qAbs(cy - ly);
+                        ny = ly;
+                    }
+                }
+                if (!flags(guideMaximized & maximize_mode::horizontal)
+                    && (ny == lry || ny + ch == ly)) {
+                    if ((sOWO ? (rx > lrx) : true) && (qAbs(lrx - rx) < snap)
+                        && (qAbs(lrx - rx) < deltaX)) {
+                        deltaX = qAbs(lrx - rx);
+                        nx = lrx - cw;
+                    }
+                    if ((sOWO ? (cx < lx) : true) && (qAbs(cx - lx) < snap)
+                        && (qAbs(cx - lx) < deltaX)) {
+                        deltaX = qAbs(cx - lx);
+                        nx = lx;
+                    }
+                }
+            }
+        }
+
+        // center snap
+        snap = kwinApp()->options->centerSnapZone() * snapAdjust; // snap trigger
+        if (snap) {
+            int diffX = qAbs((xmin + xmax) / 2 - (cx + cw / 2));
+            int diffY = qAbs((ymin + ymax) / 2 - (cy + ch / 2));
+            if (diffX < snap && diffY < snap && diffX < deltaX && diffY < deltaY) {
+                // Snap to center of screen
+                nx = (xmin + xmax) / 2 - cw / 2;
+                ny = (ymin + ymax) / 2 - ch / 2;
+            } else if (kwinApp()->options->borderSnapZone()) {
+                // Enhance border snap
+                if ((nx == xmin || nx == xmax - cw) && diffY < snap && diffY < deltaY) {
+                    // Snap to vertical center on screen edge
+                    ny = (ymin + ymax) / 2 - ch / 2;
+                } else if (((unrestricted ? ny == ymin : ny <= ymin) || ny == ymax - ch)
+                           && diffX < snap && diffX < deltaX) {
+                    // Snap to horizontal center on screen edge
+                    nx = (xmin + xmax) / 2 - cw / 2;
+                }
+            }
+        }
+
+        pos = QPoint(nx, ny);
+    }
+    return pos;
+}
+
+template<typename Space, typename Win>
+QRect adjust_window_size(Space const& space, Win const& window, QRect moveResizeGeom, position mode)
+{
+    // adapted from adjustClientPosition on 29May2004
+    // this function is called when resizing a window and will modify
+    // the new dimensions to snap to other windows/borders if appropriate
+    if (kwinApp()->options->windowSnapZone()
+        || kwinApp()->options->borderSnapZone()) { // || kwinApp()->options->centerSnapZone )
+        const bool sOWO = kwinApp()->options->isSnapOnlyWhenOverlapping();
+
+        auto const maxRect = space_window_area(
+            space, MovementArea, QRect(QPoint(0, 0), window.size()).center(), window.desktop());
+        const int xmin = maxRect.left();
+        const int xmax = maxRect.right(); // desk size
+        const int ymin = maxRect.top();
+        const int ymax = maxRect.bottom();
+
+        const int cx(moveResizeGeom.left());
+        const int cy(moveResizeGeom.top());
+        const int rx(moveResizeGeom.right());
+        const int ry(moveResizeGeom.bottom());
+
+        int newcx(cx), newcy(cy); // buffers
+        int newrx(rx), newry(ry);
+        int deltaX(xmax);
+        int deltaY(ymax); // minimum distance to other clients
+
+        int lx, ly, lrx, lry; // coords and size for the comparison client, l
+
+        // border snap
+        int snap = kwinApp()->options->borderSnapZone(); // snap trigger
+        if (snap) {
+            deltaX = int(snap);
+            deltaY = int(snap);
+
+            auto snap_border_top = [&] {
+                if ((sOWO ? (newcy < ymin) : true) && (qAbs(ymin - newcy) < deltaY)) {
+                    deltaY = qAbs(ymin - newcy);
+                    newcy = ymin;
+                }
+            };
+
+            auto snap_border_bottom = [&] {
+                if ((sOWO ? (newry > ymax) : true) && (qAbs(ymax - newry) < deltaY)) {
+                    deltaY = qAbs(ymax - newcy);
+                    newry = ymax;
+                }
+            };
+
+            auto snap_border_left = [&] {
+                if ((sOWO ? (newcx < xmin) : true) && (qAbs(xmin - newcx) < deltaX)) {
+                    deltaX = qAbs(xmin - newcx);
+                    newcx = xmin;
+                }
+            };
+
+            auto snap_border_right = [&] {
+                if ((sOWO ? (newrx > xmax) : true) && (qAbs(xmax - newrx) < deltaX)) {
+                    deltaX = qAbs(xmax - newrx);
+                    newrx = xmax;
+                }
+            };
+
+            switch (mode) {
+            case position::bottom_right:
+                snap_border_bottom();
+                snap_border_right();
+                break;
+            case position::right:
+                snap_border_right();
+                break;
+            case position::bottom:
+                snap_border_bottom();
+                break;
+            case position::top_left:
+                snap_border_top();
+                snap_border_left();
+                break;
+            case position::left:
+                snap_border_left();
+                break;
+            case position::top:
+                snap_border_top();
+                break;
+            case position::top_right:
+                snap_border_top();
+                snap_border_right();
+                break;
+            case position::bottom_left:
+                snap_border_bottom();
+                snap_border_left();
+                break;
+            default:
+                abort();
+                break;
+            }
+        }
+
+        // windows snap
+        snap = kwinApp()->options->windowSnapZone();
+        if (snap) {
+            deltaX = int(snap);
+            deltaY = int(snap);
+            for (auto win : space.windows) {
+                if (win->control && win->isOnDesktop(space.virtual_desktop_manager->current())
+                    && !win->control->minimized() && win != &window) {
+                    lx = win->pos().x() - 1;
+                    ly = win->pos().y() - 1;
+                    lrx = win->pos().x() + win->size().width();
+                    lry = win->pos().y() + win->size().height();
+
+                    auto within_height = [&] {
+                        return ((newcy <= lry) && (newcy >= ly))
+                            || ((newry >= ly) && (newry <= lry))
+                            || ((newcy <= ly) && (newry >= lry));
+                    };
+                    auto within_width = [&] {
+                        return ((cx <= lrx) && (cx >= lx)) || ((rx >= lx) && (rx <= lrx))
+                            || ((cx <= lx) && (rx >= lrx));
+                    };
+
+                    auto snap_window_top = [&] {
+                        if ((sOWO ? (newcy < lry) : true) && within_width()
+                            && (qAbs(lry - newcy) < deltaY)) {
+                            deltaY = qAbs(lry - newcy);
+                            newcy = lry;
+                        }
+                    };
+                    auto snap_window_bottom = [&] {
+                        if ((sOWO ? (newry > ly) : true) && within_width()
+                            && (qAbs(ly - newry) < deltaY)) {
+                            deltaY = qAbs(ly - newry);
+                            newry = ly;
+                        }
+                    };
+                    auto snap_window_left = [&] {
+                        if ((sOWO ? (newcx < lrx) : true) && within_height()
+                            && (qAbs(lrx - newcx) < deltaX)) {
+                            deltaX = qAbs(lrx - newcx);
+                            newcx = lrx;
+                        }
+                    };
+                    auto snap_window_right = [&] {
+                        if ((sOWO ? (newrx > lx) : true) && within_height()
+                            && (qAbs(lx - newrx) < deltaX)) {
+                            deltaX = qAbs(lx - newrx);
+                            newrx = lx;
+                        }
+                    };
+                    auto snap_window_c_top = [&] {
+                        if ((sOWO ? (newcy < ly) : true) && (newcx == lrx || newrx == lx)
+                            && qAbs(ly - newcy) < deltaY) {
+                            deltaY = qAbs(ly - newcy + 1);
+                            newcy = ly + 1;
+                        }
+                    };
+                    auto snap_window_c_bottom = [&] {
+                        if ((sOWO ? (newry > lry) : true) && (newcx == lrx || newrx == lx)
+                            && qAbs(lry - newry) < deltaY) {
+                            deltaY = qAbs(lry - newry - 1);
+                            newry = lry - 1;
+                        }
+                    };
+                    auto snap_window_c_left = [&] {
+                        if ((sOWO ? (newcx < lx) : true) && (newcy == lry || newry == ly)
+                            && qAbs(lx - newcx) < deltaX) {
+                            deltaX = qAbs(lx - newcx + 1);
+                            newcx = lx + 1;
+                        }
+                    };
+                    auto snap_window_c_right = [&] {
+                        if ((sOWO ? (newrx > lrx) : true) && (newcy == lry || newry == ly)
+                            && qAbs(lrx - newrx) < deltaX) {
+                            deltaX = qAbs(lrx - newrx - 1);
+                            newrx = lrx - 1;
+                        }
+                    };
+
+                    switch (mode) {
+                    case position::bottom_right:
+                        snap_window_bottom();
+                        snap_window_right();
+                        snap_window_c_bottom();
+                        snap_window_c_right();
+                        break;
+                    case position::right:
+                        snap_window_right();
+                        snap_window_c_right();
+                        break;
+                    case position::bottom:
+                        snap_window_bottom();
+                        snap_window_c_bottom();
+                        break;
+                    case position::top_left:
+                        snap_window_top();
+                        snap_window_left();
+                        snap_window_c_top();
+                        snap_window_c_left();
+                        break;
+                    case position::left:
+                        snap_window_left();
+                        snap_window_c_left();
+                        break;
+                    case position::top:
+                        snap_window_top();
+                        snap_window_c_top();
+                        break;
+                    case position::top_right:
+                        snap_window_top();
+                        snap_window_right();
+                        snap_window_c_top();
+                        snap_window_c_right();
+                        break;
+                    case position::bottom_left:
+                        snap_window_bottom();
+                        snap_window_left();
+                        snap_window_c_bottom();
+                        snap_window_c_left();
+                        break;
+                    default:
+                        abort();
+                        break;
+                    }
+                }
+            }
+        }
+
+        // center snap
+        // snap = kwinApp()->options->centerSnapZone;
+        // if (snap)
+        //    {
+        //    // Don't resize snap to center as it interferes too much
+        //    // There are two ways of implementing this if wanted:
+        //    // 1) Snap only to the same points that the move snap does, and
+        //    // 2) Snap to the horizontal and vertical center lines of the screen
+        //    }
+
+        moveResizeGeom = QRect(QPoint(newcx, newcy), QPoint(newrx, newry));
+    }
+
+    return moveResizeGeom;
+}
+
 }
diff --git a/win/move.h b/win/move.h
index e02d2d289..b38179618 100644
--- a/win/move.h
+++ b/win/move.h
@@ -420,7 +420,7 @@ auto move_resize_impl(Win* win, int x, int y, int x_root, int y_root)
         calculateMoveResizeGeom();
 
         // adjust new size to snap to other windows/borders
-        mov_res.geometry = win->space.adjustClientSize(win, mov_res.geometry, mode);
+        mov_res.geometry = adjust_window_size(win->space, *win, mov_res.geometry, mode);
 
         if (!mov_res.unrestricted) {
             // Make sure the titlebar isn't behind a restricted area. We don't need to restrict
@@ -561,8 +561,8 @@ auto move_resize_impl(Win* win, int x, int y, int x_root, int y_root)
             // first move, then snap, then check bounds
             auto moveResizeGeom = mov_res.geometry;
             moveResizeGeom.moveTopLeft(topleft);
-            moveResizeGeom.moveTopLeft(win->space.adjustClientPosition(
-                win, moveResizeGeom.topLeft(), mov_res.unrestricted));
+            moveResizeGeom.moveTopLeft(adjust_window_position(
+                win->space, *win, moveResizeGeom.topLeft(), mov_res.unrestricted));
             mov_res.geometry = moveResizeGeom;
 
             if (!mov_res.unrestricted) {
diff --git a/win/space.cpp b/win/space.cpp
index 200b41b53..6b550279b 100644
--- a/win/space.cpp
+++ b/win/space.cpp
@@ -465,501 +465,4 @@ void space::update_space_area_from_windows(QRect const& /*desktop_area*/,
     // Can't be pure virtual because the function might be called from the ctor.
 }
 
-/**
- * Client \a c is moved around to position \a pos. This gives the
- * space:: the opportunity to interveniate and to implement
- * snap-to-windows functionality.
- *
- * The parameter \a snapAdjust is a multiplier used to calculate the
- * effective snap zones. When 1.0, it means that the snap zones will be
- * used without change.
- */
-QPoint
-space::adjustClientPosition(Toplevel* window, QPoint pos, bool unrestricted, double snapAdjust)
-{
-    QSize borderSnapZone(kwinApp()->options->borderSnapZone(),
-                         kwinApp()->options->borderSnapZone());
-    QRect maxRect;
-    auto guideMaximized = win::maximize_mode::restore;
-    if (window->maximizeMode() != win::maximize_mode::restore) {
-        maxRect = space_window_area(
-            *this, MaximizeArea, pos + QRect(QPoint(), window->size()).center(), window->desktop());
-        QRect geo = window->frameGeometry();
-        if (flags(window->maximizeMode() & win::maximize_mode::horizontal)
-            && (geo.x() == maxRect.left() || geo.right() == maxRect.right())) {
-            guideMaximized |= win::maximize_mode::horizontal;
-            borderSnapZone.setWidth(qMax(borderSnapZone.width() + 2, maxRect.width() / 16));
-        }
-        if (flags(window->maximizeMode() & win::maximize_mode::vertical)
-            && (geo.y() == maxRect.top() || geo.bottom() == maxRect.bottom())) {
-            guideMaximized |= win::maximize_mode::vertical;
-            borderSnapZone.setHeight(qMax(borderSnapZone.height() + 2, maxRect.height() / 16));
-        }
-    }
-
-    if (kwinApp()->options->windowSnapZone() || !borderSnapZone.isNull()
-        || kwinApp()->options->centerSnapZone()) {
-        auto const& outputs = kwinApp()->get_base().get_outputs();
-        const bool sOWO = kwinApp()->options->isSnapOnlyWhenOverlapping();
-        auto output
-            = base::get_nearest_output(outputs, pos + QRect(QPoint(), window->size()).center());
-
-        if (maxRect.isNull()) {
-            maxRect = space_window_area(*this, MovementArea, output, window->desktop());
-        }
-
-        const int xmin = maxRect.left();
-        const int xmax = maxRect.right() + 1; // desk size
-        const int ymin = maxRect.top();
-        const int ymax = maxRect.bottom() + 1;
-
-        const int cx(pos.x());
-        const int cy(pos.y());
-        const int cw(window->size().width());
-        const int ch(window->size().height());
-        const int rx(cx + cw);
-        const int ry(cy + ch); // these don't change
-
-        int nx(cx), ny(cy); // buffers
-        int deltaX(xmax);
-        int deltaY(ymax); // minimum distance to other clients
-
-        int lx, ly, lrx, lry; // coords and size for the comparison client, l
-
-        // border snap
-        const int snapX = borderSnapZone.width() * snapAdjust; // snap trigger
-        const int snapY = borderSnapZone.height() * snapAdjust;
-        if (snapX || snapY) {
-            auto geo = window->frameGeometry();
-            auto frameMargins = win::frame_margins(window);
-
-            // snap to titlebar / snap to window borders on inner screen edges
-            if (frameMargins.left()
-                && (flags(window->maximizeMode() & win::maximize_mode::horizontal)
-                    || base::get_intersecting_outputs(
-                           outputs,
-                           geo.translated(maxRect.x() - (frameMargins.left() + geo.x()), 0))
-                            .size()
-                        > 1)) {
-                frameMargins.setLeft(0);
-            }
-            if (frameMargins.right()
-                && (flags(window->maximizeMode() & win::maximize_mode::horizontal)
-                    || base::get_intersecting_outputs(
-                           outputs,
-                           geo.translated(maxRect.right() + frameMargins.right() - geo.right(), 0))
-                            .size()
-                        > 1)) {
-                frameMargins.setRight(0);
-            }
-            if (frameMargins.top()) {
-                frameMargins.setTop(0);
-            }
-            if (frameMargins.bottom()
-                && (flags(window->maximizeMode() & win::maximize_mode::vertical)
-                    || base::get_intersecting_outputs(
-                           outputs,
-                           geo.translated(0,
-                                          maxRect.bottom() + frameMargins.bottom() - geo.bottom()))
-                            .size()
-                        > 1)) {
-                frameMargins.setBottom(0);
-            }
-            if ((sOWO ? (cx < xmin) : true) && (qAbs(xmin - cx) < snapX)) {
-                deltaX = xmin - cx;
-                nx = xmin - frameMargins.left();
-            }
-            if ((sOWO ? (rx > xmax) : true) && (qAbs(rx - xmax) < snapX)
-                && (qAbs(xmax - rx) < deltaX)) {
-                deltaX = rx - xmax;
-                nx = xmax - cw + frameMargins.right();
-            }
-
-            if ((sOWO ? (cy < ymin) : true) && (qAbs(ymin - cy) < snapY)) {
-                deltaY = ymin - cy;
-                ny = ymin - frameMargins.top();
-            }
-            if ((sOWO ? (ry > ymax) : true) && (qAbs(ry - ymax) < snapY)
-                && (qAbs(ymax - ry) < deltaY)) {
-                deltaY = ry - ymax;
-                ny = ymax - ch + frameMargins.bottom();
-            }
-        }
-
-        // windows snap
-        int snap = kwinApp()->options->windowSnapZone() * snapAdjust;
-        if (snap) {
-            for (auto win : windows) {
-                if (!win->control) {
-                    continue;
-                }
-
-                if (win == window) {
-                    continue;
-                }
-                if (win->control->minimized()) {
-                    continue;
-                }
-                if (!win->isShown()) {
-                    continue;
-                }
-                if (!win->isOnDesktop(window->desktop()) && !window->isOnDesktop(win->desktop())) {
-                    // wrong virtual desktop
-                    continue;
-                }
-                if (is_desktop(win) || is_splash(win)) {
-                    continue;
-                }
-
-                lx = win->pos().x();
-                ly = win->pos().y();
-                lrx = lx + win->size().width();
-                lry = ly + win->size().height();
-
-                if (!flags(guideMaximized & win::maximize_mode::horizontal)
-                    && (((cy <= lry) && (cy >= ly)) || ((ry >= ly) && (ry <= lry))
-                        || ((cy <= ly) && (ry >= lry)))) {
-                    if ((sOWO ? (cx < lrx) : true) && (qAbs(lrx - cx) < snap)
-                        && (qAbs(lrx - cx) < deltaX)) {
-                        deltaX = qAbs(lrx - cx);
-                        nx = lrx;
-                    }
-                    if ((sOWO ? (rx > lx) : true) && (qAbs(rx - lx) < snap)
-                        && (qAbs(rx - lx) < deltaX)) {
-                        deltaX = qAbs(rx - lx);
-                        nx = lx - cw;
-                    }
-                }
-
-                if (!flags(guideMaximized & win::maximize_mode::vertical)
-                    && (((cx <= lrx) && (cx >= lx)) || ((rx >= lx) && (rx <= lrx))
-                        || ((cx <= lx) && (rx >= lrx)))) {
-                    if ((sOWO ? (cy < lry) : true) && (qAbs(lry - cy) < snap)
-                        && (qAbs(lry - cy) < deltaY)) {
-                        deltaY = qAbs(lry - cy);
-                        ny = lry;
-                    }
-                    // if ( (qAbs( ry-ly ) < snap) && (qAbs( ry - ly ) < deltaY ))
-                    if ((sOWO ? (ry > ly) : true) && (qAbs(ry - ly) < snap)
-                        && (qAbs(ry - ly) < deltaY)) {
-                        deltaY = qAbs(ry - ly);
-                        ny = ly - ch;
-                    }
-                }
-
-                // Corner snapping
-                if (!flags(guideMaximized & win::maximize_mode::vertical)
-                    && (nx == lrx || nx + cw == lx)) {
-                    if ((sOWO ? (ry > lry) : true) && (qAbs(lry - ry) < snap)
-                        && (qAbs(lry - ry) < deltaY)) {
-                        deltaY = qAbs(lry - ry);
-                        ny = lry - ch;
-                    }
-                    if ((sOWO ? (cy < ly) : true) && (qAbs(cy - ly) < snap)
-                        && (qAbs(cy - ly) < deltaY)) {
-                        deltaY = qAbs(cy - ly);
-                        ny = ly;
-                    }
-                }
-                if (!flags(guideMaximized & win::maximize_mode::horizontal)
-                    && (ny == lry || ny + ch == ly)) {
-                    if ((sOWO ? (rx > lrx) : true) && (qAbs(lrx - rx) < snap)
-                        && (qAbs(lrx - rx) < deltaX)) {
-                        deltaX = qAbs(lrx - rx);
-                        nx = lrx - cw;
-                    }
-                    if ((sOWO ? (cx < lx) : true) && (qAbs(cx - lx) < snap)
-                        && (qAbs(cx - lx) < deltaX)) {
-                        deltaX = qAbs(cx - lx);
-                        nx = lx;
-                    }
-                }
-            }
-        }
-
-        // center snap
-        snap = kwinApp()->options->centerSnapZone() * snapAdjust; // snap trigger
-        if (snap) {
-            int diffX = qAbs((xmin + xmax) / 2 - (cx + cw / 2));
-            int diffY = qAbs((ymin + ymax) / 2 - (cy + ch / 2));
-            if (diffX < snap && diffY < snap && diffX < deltaX && diffY < deltaY) {
-                // Snap to center of screen
-                nx = (xmin + xmax) / 2 - cw / 2;
-                ny = (ymin + ymax) / 2 - ch / 2;
-            } else if (kwinApp()->options->borderSnapZone()) {
-                // Enhance border snap
-                if ((nx == xmin || nx == xmax - cw) && diffY < snap && diffY < deltaY) {
-                    // Snap to vertical center on screen edge
-                    ny = (ymin + ymax) / 2 - ch / 2;
-                } else if (((unrestricted ? ny == ymin : ny <= ymin) || ny == ymax - ch)
-                           && diffX < snap && diffX < deltaX) {
-                    // Snap to horizontal center on screen edge
-                    nx = (xmin + xmax) / 2 - cw / 2;
-                }
-            }
-        }
-
-        pos = QPoint(nx, ny);
-    }
-    return pos;
-}
-
-QRect space::adjustClientSize(Toplevel* window, QRect moveResizeGeom, win::position mode)
-{
-    // adapted from adjustClientPosition on 29May2004
-    // this function is called when resizing a window and will modify
-    // the new dimensions to snap to other windows/borders if appropriate
-    if (kwinApp()->options->windowSnapZone()
-        || kwinApp()->options->borderSnapZone()) { // || kwinApp()->options->centerSnapZone )
-        const bool sOWO = kwinApp()->options->isSnapOnlyWhenOverlapping();
-
-        auto const maxRect = space_window_area(
-            *this, MovementArea, QRect(QPoint(0, 0), window->size()).center(), window->desktop());
-        const int xmin = maxRect.left();
-        const int xmax = maxRect.right(); // desk size
-        const int ymin = maxRect.top();
-        const int ymax = maxRect.bottom();
-
-        const int cx(moveResizeGeom.left());
-        const int cy(moveResizeGeom.top());
-        const int rx(moveResizeGeom.right());
-        const int ry(moveResizeGeom.bottom());
-
-        int newcx(cx), newcy(cy); // buffers
-        int newrx(rx), newry(ry);
-        int deltaX(xmax);
-        int deltaY(ymax); // minimum distance to other clients
-
-        int lx, ly, lrx, lry; // coords and size for the comparison client, l
-
-        // border snap
-        int snap = kwinApp()->options->borderSnapZone(); // snap trigger
-        if (snap) {
-            deltaX = int(snap);
-            deltaY = int(snap);
-
-            auto snap_border_top = [&] {
-                if ((sOWO ? (newcy < ymin) : true) && (qAbs(ymin - newcy) < deltaY)) {
-                    deltaY = qAbs(ymin - newcy);
-                    newcy = ymin;
-                }
-            };
-
-            auto snap_border_bottom = [&] {
-                if ((sOWO ? (newry > ymax) : true) && (qAbs(ymax - newry) < deltaY)) {
-                    deltaY = qAbs(ymax - newcy);
-                    newry = ymax;
-                }
-            };
-
-            auto snap_border_left = [&] {
-                if ((sOWO ? (newcx < xmin) : true) && (qAbs(xmin - newcx) < deltaX)) {
-                    deltaX = qAbs(xmin - newcx);
-                    newcx = xmin;
-                }
-            };
-
-            auto snap_border_right = [&] {
-                if ((sOWO ? (newrx > xmax) : true) && (qAbs(xmax - newrx) < deltaX)) {
-                    deltaX = qAbs(xmax - newrx);
-                    newrx = xmax;
-                }
-            };
-
-            switch (mode) {
-            case win::position::bottom_right:
-                snap_border_bottom();
-                snap_border_right();
-                break;
-            case win::position::right:
-                snap_border_right();
-                break;
-            case win::position::bottom:
-                snap_border_bottom();
-                break;
-            case win::position::top_left:
-                snap_border_top();
-                snap_border_left();
-                break;
-            case win::position::left:
-                snap_border_left();
-                break;
-            case win::position::top:
-                snap_border_top();
-                break;
-            case win::position::top_right:
-                snap_border_top();
-                snap_border_right();
-                break;
-            case win::position::bottom_left:
-                snap_border_bottom();
-                snap_border_left();
-                break;
-            default:
-                abort();
-                break;
-            }
-        }
-
-        // windows snap
-        snap = kwinApp()->options->windowSnapZone();
-        if (snap) {
-            deltaX = int(snap);
-            deltaY = int(snap);
-            for (auto win : windows) {
-                if (win->control && win->isOnDesktop(virtual_desktop_manager->current())
-                    && !win->control->minimized() && win != window) {
-                    lx = win->pos().x() - 1;
-                    ly = win->pos().y() - 1;
-                    lrx = win->pos().x() + win->size().width();
-                    lry = win->pos().y() + win->size().height();
-
-                    auto within_height = [&] {
-                        return ((newcy <= lry) && (newcy >= ly))
-                            || ((newry >= ly) && (newry <= lry))
-                            || ((newcy <= ly) && (newry >= lry));
-                    };
-                    auto within_width = [&] {
-                        return ((cx <= lrx) && (cx >= lx)) || ((rx >= lx) && (rx <= lrx))
-                            || ((cx <= lx) && (rx >= lrx));
-                    };
-
-                    auto snap_window_top = [&] {
-                        if ((sOWO ? (newcy < lry) : true) && within_width()
-                            && (qAbs(lry - newcy) < deltaY)) {
-                            deltaY = qAbs(lry - newcy);
-                            newcy = lry;
-                        }
-                    };
-                    auto snap_window_bottom = [&] {
-                        if ((sOWO ? (newry > ly) : true) && within_width()
-                            && (qAbs(ly - newry) < deltaY)) {
-                            deltaY = qAbs(ly - newry);
-                            newry = ly;
-                        }
-                    };
-                    auto snap_window_left = [&] {
-                        if ((sOWO ? (newcx < lrx) : true) && within_height()
-                            && (qAbs(lrx - newcx) < deltaX)) {
-                            deltaX = qAbs(lrx - newcx);
-                            newcx = lrx;
-                        }
-                    };
-                    auto snap_window_right = [&] {
-                        if ((sOWO ? (newrx > lx) : true) && within_height()
-                            && (qAbs(lx - newrx) < deltaX)) {
-                            deltaX = qAbs(lx - newrx);
-                            newrx = lx;
-                        }
-                    };
-                    auto snap_window_c_top = [&] {
-                        if ((sOWO ? (newcy < ly) : true) && (newcx == lrx || newrx == lx)
-                            && qAbs(ly - newcy) < deltaY) {
-                            deltaY = qAbs(ly - newcy + 1);
-                            newcy = ly + 1;
-                        }
-                    };
-                    auto snap_window_c_bottom = [&] {
-                        if ((sOWO ? (newry > lry) : true) && (newcx == lrx || newrx == lx)
-                            && qAbs(lry - newry) < deltaY) {
-                            deltaY = qAbs(lry - newry - 1);
-                            newry = lry - 1;
-                        }
-                    };
-                    auto snap_window_c_left = [&] {
-                        if ((sOWO ? (newcx < lx) : true) && (newcy == lry || newry == ly)
-                            && qAbs(lx - newcx) < deltaX) {
-                            deltaX = qAbs(lx - newcx + 1);
-                            newcx = lx + 1;
-                        }
-                    };
-                    auto snap_window_c_right = [&] {
-                        if ((sOWO ? (newrx > lrx) : true) && (newcy == lry || newry == ly)
-                            && qAbs(lrx - newrx) < deltaX) {
-                            deltaX = qAbs(lrx - newrx - 1);
-                            newrx = lrx - 1;
-                        }
-                    };
-
-                    switch (mode) {
-                    case win::position::bottom_right:
-                        snap_window_bottom();
-                        snap_window_right();
-                        snap_window_c_bottom();
-                        snap_window_c_right();
-                        break;
-                    case win::position::right:
-                        snap_window_right();
-                        snap_window_c_right();
-                        break;
-                    case win::position::bottom:
-                        snap_window_bottom();
-                        snap_window_c_bottom();
-                        break;
-                    case win::position::top_left:
-                        snap_window_top();
-                        snap_window_left();
-                        snap_window_c_top();
-                        snap_window_c_left();
-                        break;
-                    case win::position::left:
-                        snap_window_left();
-                        snap_window_c_left();
-                        break;
-                    case win::position::top:
-                        snap_window_top();
-                        snap_window_c_top();
-                        break;
-                    case win::position::top_right:
-                        snap_window_top();
-                        snap_window_right();
-                        snap_window_c_top();
-                        snap_window_c_right();
-                        break;
-                    case win::position::bottom_left:
-                        snap_window_bottom();
-                        snap_window_left();
-                        snap_window_c_bottom();
-                        snap_window_c_left();
-                        break;
-                    default:
-                        abort();
-                        break;
-                    }
-                }
-            }
-        }
-
-        // center snap
-        // snap = kwinApp()->options->centerSnapZone;
-        // if (snap)
-        //    {
-        //    // Don't resize snap to center as it interferes too much
-        //    // There are two ways of implementing this if wanted:
-        //    // 1) Snap only to the same points that the move snap does, and
-        //    // 2) Snap to the horizontal and vertical center lines of the screen
-        //    }
-
-        moveResizeGeom = QRect(QPoint(newcx, newcy), QPoint(newrx, newry));
-    }
-    return moveResizeGeom;
-}
-
-// When kwin crashes, windows will not be gravitated back to their original position
-// and will remain offset by the size of the decoration. So when restarting, fix this
-// (the property with the size of the frame remains on the window after the crash).
-void space::fixPositionAfterCrash(xcb_window_t w, const xcb_get_geometry_reply_t* geometry)
-{
-    NETWinInfo i(connection(), w, rootWindow(), NET::WMFrameExtents, NET::Properties2());
-    NETStrut frame = i.frameExtents();
-
-    if (frame.left != 0 || frame.top != 0) {
-        // left and top needed due to narrowing conversations restrictions in C++11
-        const uint32_t left = frame.left;
-        const uint32_t top = frame.top;
-        const uint32_t values[] = {geometry->x - left, geometry->y - top};
-        xcb_configure_window(connection(), w, XCB_CONFIG_WINDOW_X | XCB_CONFIG_WINDOW_Y, values);
-    }
-}
-
 }
diff --git a/win/space.h b/win/space.h
index 6f864312c..9d5e8cffb 100644
--- a/win/space.h
+++ b/win/space.h
@@ -237,10 +237,6 @@ public:
 
     bool initializing() const;
 
-    QPoint
-    adjustClientPosition(Toplevel* window, QPoint pos, bool unrestricted, double snapAdjust = 1.0);
-    QRect adjustClientSize(Toplevel* window, QRect moveResizeGeom, win::position mode);
-
     /**
      * Most recently raised window.
      *
@@ -303,7 +299,6 @@ public:
     virtual win::screen_edge* create_screen_edge(win::screen_edger& edger);
     virtual QRect get_icon_geometry(Toplevel const* win) const;
 
-    void fixPositionAfterCrash(xcb_window_t w, const xcb_get_geometry_reply_t* geom);
     void saveOldScreenSizes();
     void desktopResized();
 
diff --git a/win/x11/placement.h b/win/x11/placement.h
index c2b0b71b5..1ee699f8e 100644
--- a/win/x11/placement.h
+++ b/win/x11/placement.h
@@ -354,4 +354,24 @@ QRect place_on_taking_control(Win* win,
     return place_unmapped(win, frame_geo, asn_data);
 }
 
+// When kwin crashes, windows will not be gravitated back to their original position
+// and will remain offset by the size of the decoration. So when restarting, fix this
+// (the property with the size of the frame remains on the window after the crash).
+template<typename Space>
+void fix_position_after_crash(Space& /*space*/,
+                              xcb_window_t w,
+                              const xcb_get_geometry_reply_t* geometry)
+{
+    NETWinInfo i(connection(), w, rootWindow(), NET::WMFrameExtents, NET::Properties2());
+    NETStrut frame = i.frameExtents();
+
+    if (frame.left != 0 || frame.top != 0) {
+        // left and top needed due to narrowing conversations restrictions in C++11
+        const uint32_t left = frame.left;
+        const uint32_t top = frame.top;
+        const uint32_t values[] = {geometry->x - left, geometry->y - top};
+        xcb_configure_window(connection(), w, XCB_CONFIG_WINDOW_X | XCB_CONFIG_WINDOW_Y, values);
+    }
+}
+
 }
diff --git a/win/x11/space_setup.h b/win/x11/space_setup.h
index e9cb7ddef..4ed3a9130 100644
--- a/win/x11/space_setup.h
+++ b/win/x11/space_setup.h
@@ -8,6 +8,7 @@
 #include "color_mapper.h"
 #include "control.h"
 #include "moving_window_filter.h"
+#include "placement.h"
 #include "space_event.h"
 #include "sync_alarm_filter.h"
 
@@ -132,7 +133,7 @@ void init_space(Space& space)
                     create_unmanaged_window(wins[i], space);
             } else if (attr->map_state != XCB_MAP_STATE_UNMAPPED) {
                 if (Application::wasCrash()) {
-                    space.fixPositionAfterCrash(wins[i], windowGeometries.at(i).data());
+                    fix_position_after_crash(space, wins[i], windowGeometries.at(i).data());
                 }
 
                 // ### This will request the attributes again
-- 
GitLab


From a1201ae100e35d30fb7907fa40462608135720e8 Mon Sep 17 00:00:00 2001
From: Roman Gilg <subdiff@gmail.com>
Date: Mon, 11 Jul 2022 20:41:24 +0200
Subject: [PATCH 33/51] refactor: reimplement on desktop resize functions as
 free functions

This way they can be reused by different types of spaces.
---
 win/desktop_space.h   | 39 +++++++++++++++++++++++++++++++++++++++
 win/space.cpp         | 41 +----------------------------------------
 win/space.h           |  3 ---
 win/x11/space_setup.h |  2 +-
 4 files changed, 41 insertions(+), 44 deletions(-)

diff --git a/win/desktop_space.h b/win/desktop_space.h
index 3ec24be93..32b379e72 100644
--- a/win/desktop_space.h
+++ b/win/desktop_space.h
@@ -153,4 +153,43 @@ void window_to_prev_desktop(Win& window)
     window_to_desktop<win::virtual_desktop_previous>(window);
 }
 
+template<typename Space>
+void save_old_output_sizes(Space& space)
+{
+    auto&& base = kwinApp()->get_base();
+    auto const& outputs = base.get_outputs();
+
+    space.olddisplaysize = base.topology.size;
+    space.oldscreensizes.clear();
+
+    for (auto output : outputs) {
+        space.oldscreensizes.push_back(output->geometry());
+    }
+}
+
+/// After an output topology change.
+template<typename Space>
+void handle_desktop_resize(Space& space)
+{
+    auto geom = QRect({}, kwinApp()->get_base().topology.size);
+    if (x11::rootInfo()) {
+        NETSize desktop_geometry;
+        desktop_geometry.width = geom.width();
+        desktop_geometry.height = geom.height();
+        x11::rootInfo()->setDesktopGeometry(desktop_geometry);
+    }
+
+    update_space_areas(space);
+
+    // after updateClientArea(), so that one still uses the previous one
+    save_old_output_sizes(space);
+
+    // TODO: emit a signal instead and remove the deep function calls into edges and effects
+    space.edges->recreateEdges();
+
+    if (auto& effects = space.render.effects) {
+        effects->desktopResized(geom.size());
+    }
+}
+
 }
diff --git a/win/space.cpp b/win/space.cpp
index 6b550279b..601daaa67 100644
--- a/win/space.cpp
+++ b/win/space.cpp
@@ -162,7 +162,7 @@ space::space(render::compositor& render)
     QObject::connect(
         &base, &base::platform::topology_changed, qobject.get(), [this](auto old, auto topo) {
             if (old.size != topo.size) {
-                desktopResized();
+                handle_desktop_resize(*this);
             }
         });
 
@@ -419,45 +419,6 @@ void space::checkTransients(Toplevel* window)
     });
 }
 
-/**
- * Resizes the space:: after an XRANDR screen size change
- */
-void space::desktopResized()
-{
-    auto geom = QRect({}, kwinApp()->get_base().topology.size);
-    if (win::x11::rootInfo()) {
-        NETSize desktop_geometry;
-        desktop_geometry.width = geom.width();
-        desktop_geometry.height = geom.height();
-        win::x11::rootInfo()->setDesktopGeometry(desktop_geometry);
-    }
-
-    update_space_areas(*this);
-
-    // after updateClientArea(), so that one still uses the previous one
-    saveOldScreenSizes();
-
-    // TODO: emit a signal instead and remove the deep function calls into edges and effects
-    edges->recreateEdges();
-
-    if (auto& effects = render.effects) {
-        effects->desktopResized(geom.size());
-    }
-}
-
-void space::saveOldScreenSizes()
-{
-    auto&& base = kwinApp()->get_base();
-    auto const& outputs = base.get_outputs();
-
-    olddisplaysize = base.topology.size;
-    oldscreensizes.clear();
-
-    for (auto output : outputs) {
-        oldscreensizes.push_back(output->geometry());
-    }
-}
-
 void space::update_space_area_from_windows(QRect const& /*desktop_area*/,
                                            std::vector<QRect> const& /*screens_geos*/,
                                            win::space_areas& /*areas*/)
diff --git a/win/space.h b/win/space.h
index 9d5e8cffb..ffc007d51 100644
--- a/win/space.h
+++ b/win/space.h
@@ -299,9 +299,6 @@ public:
     virtual win::screen_edge* create_screen_edge(win::screen_edger& edger);
     virtual QRect get_icon_geometry(Toplevel const* win) const;
 
-    void saveOldScreenSizes();
-    void desktopResized();
-
     virtual void update_space_area_from_windows(QRect const& desktop_area,
                                                 std::vector<QRect> const& screens_geos,
                                                 win::space_areas& areas);
diff --git a/win/x11/space_setup.h b/win/x11/space_setup.h
index 4ed3a9130..315a7b630 100644
--- a/win/x11/space_setup.h
+++ b/win/x11/space_setup.h
@@ -144,7 +144,7 @@ void init_space(Space& space)
         // Propagate clients, will really happen at the end of the updates blocker block
         space.stacking_order->update_count();
 
-        space.saveOldScreenSizes();
+        save_old_output_sizes(space);
         update_space_areas(space);
 
         // NETWM spec says we have to set it to (0,0) if we don't support it
-- 
GitLab


From f64fb3174153e6e07b2cc2cd728e41ea8b32452f Mon Sep 17 00:00:00 2001
From: Roman Gilg <subdiff@gmail.com>
Date: Mon, 11 Jul 2022 20:45:16 +0200
Subject: [PATCH 34/51] refactor: remove check transients helper

It's only called once. Instead just do a simple ranged loop there.
---
 win/space.cpp           | 9 ---------
 win/space.h             | 1 -
 win/x11/window_create.h | 5 ++++-
 3 files changed, 4 insertions(+), 11 deletions(-)

diff --git a/win/space.cpp b/win/space.cpp
index 601daaa67..cf6dc9f18 100644
--- a/win/space.cpp
+++ b/win/space.cpp
@@ -410,15 +410,6 @@ void space::updateOnAllDesktopsOfTransients(Toplevel* window)
     }
 }
 
-// A new window has been mapped. Check if it's not a mainwindow for some already existing transient
-// window.
-void space::checkTransients(Toplevel* window)
-{
-    std::for_each(windows.cbegin(), windows.cend(), [&window](auto const& client) {
-        client->checkTransient(window);
-    });
-}
-
 void space::update_space_area_from_windows(QRect const& /*desktop_area*/,
                                            std::vector<QRect> const& /*screens_geos*/,
                                            win::space_areas& /*areas*/)
diff --git a/win/space.h b/win/space.h
index ffc007d51..76c756ed4 100644
--- a/win/space.h
+++ b/win/space.h
@@ -264,7 +264,6 @@ public:
 
     void updateMinimizedOfTransients(Toplevel*);
     void updateOnAllDesktopsOfTransients(Toplevel* window);
-    void checkTransients(Toplevel* window);
 
     bool showingDesktop() const;
 
diff --git a/win/x11/window_create.h b/win/x11/window_create.h
index a27fd1252..5f7c6ff19 100644
--- a/win/x11/window_create.h
+++ b/win/x11/window_create.h
@@ -56,7 +56,10 @@ void add_controlled_window_to_space(Space& space, Win* win)
     }
 
     check_active_modal<Win>(space);
-    space.checkTransients(win);
+
+    for (auto window : space.windows) {
+        window->checkTransient(win);
+    }
 
     // Propagate new client
     space.stacking_order->update_count();
-- 
GitLab


From 1d569c3a11c659a9f9dff4b4eb890b3294d16715 Mon Sep 17 00:00:00 2001
From: Roman Gilg <subdiff@gmail.com>
Date: Mon, 11 Jul 2022 21:41:53 +0200
Subject: [PATCH 35/51] refactor: reimplement transient space helper functions
 as free functions

They are actually not dependent on the space. We template them only over the
window type.
---
 win/actions.h          | 42 ++++++++++++++++++++++++++++++
 win/desktop_set.h      | 15 ++++++++++-
 win/space.cpp          | 58 ------------------------------------------
 win/space.h            |  3 ---
 win/wayland/window.cpp |  2 +-
 win/x11/control.h      |  2 +-
 win/x11/window.cpp     |  2 +-
 7 files changed, 59 insertions(+), 65 deletions(-)

diff --git a/win/actions.h b/win/actions.h
index 03f4f2854..7b144f887 100644
--- a/win/actions.h
+++ b/win/actions.h
@@ -96,4 +96,46 @@ void set_minimized(Win* win, bool set, bool avoid_animation = false)
     }
 }
 
+template<typename Win>
+void propagate_minimized_to_transients(Win& window)
+{
+    if (window.control->minimized()) {
+        for (auto win : window.transient()->children) {
+            if (!win->control) {
+                continue;
+            }
+            if (win->transient()->modal()) {
+                // There's no reason to hide modal dialogs with the main client...
+                continue;
+            }
+            // ... but to keep them to eg. watch progress or whatever.
+            if (!win->control->minimized()) {
+                set_minimized(win, true);
+                propagate_minimized_to_transients(*win);
+            }
+        }
+        if (window.transient()->modal()) {
+            // If a modal dialog is minimized, minimize its mainwindow too.
+            for (auto c2 : window.transient()->leads()) {
+                set_minimized(c2, true);
+            }
+        }
+    } else {
+        for (auto win : window.transient()->children) {
+            if (!win->control) {
+                continue;
+            }
+            if (win->control->minimized()) {
+                set_minimized(win, false);
+                propagate_minimized_to_transients(*win);
+            }
+        }
+        if (window.transient()->modal()) {
+            for (auto c2 : window.transient()->leads()) {
+                set_minimized(c2, false);
+            }
+        }
+    }
+}
+
 }
diff --git a/win/desktop_set.h b/win/desktop_set.h
index f9c56b41c..dada74aeb 100644
--- a/win/desktop_set.h
+++ b/win/desktop_set.h
@@ -17,6 +17,9 @@
 namespace KWin::win
 {
 
+template<typename Win>
+void propagate_on_all_desktops_to_children(Win& window);
+
 template<typename Win>
 void set_desktops(Win* win, QVector<virtual_desktop*> desktops)
 {
@@ -59,7 +62,7 @@ void set_desktops(Win* win, QVector<virtual_desktop*> desktops)
 
     if ((was_desk == NET::OnAllDesktops) != (win->desktop() == NET::OnAllDesktops)) {
         // OnAllDesktops changed
-        win->space.updateOnAllDesktopsOfTransients(win);
+        propagate_on_all_desktops_to_children(*win);
     }
 
     auto transients_stacking_order
@@ -153,4 +156,14 @@ void leave_desktop(Win* win, virtual_desktop* virtualDesktop)
     set_desktops(win, desktops);
 }
 
+template<typename Win>
+void propagate_on_all_desktops_to_children(Win& window)
+{
+    for (auto const& transient : window.transient()->children) {
+        if (transient->isOnAllDesktops() != window.isOnAllDesktops()) {
+            set_on_all_desktops(transient, window.isOnAllDesktops());
+        }
+    }
+}
+
 }
diff --git a/win/space.cpp b/win/space.cpp
index cf6dc9f18..d1f0f04a2 100644
--- a/win/space.cpp
+++ b/win/space.cpp
@@ -352,64 +352,6 @@ QRect space::get_icon_geometry(Toplevel const* /*win*/) const
     return QRect();
 }
 
-void space::updateMinimizedOfTransients(Toplevel* c)
-{
-    // if mainwindow is minimized or shaded, minimize transients too
-    auto const transients = c->transient()->children;
-
-    if (c->control->minimized()) {
-        for (auto it = transients.cbegin(); it != transients.cend(); ++it) {
-            auto abstract_client = *it;
-            if (abstract_client->transient()->modal())
-                continue; // there's no reason to hide modal dialogs with the main client
-            if (!(*it)->control) {
-                continue;
-            }
-            // but to keep them to eg. watch progress or whatever
-            if (!(*it)->control->minimized()) {
-                win::set_minimized(abstract_client, true);
-                updateMinimizedOfTransients(abstract_client);
-            }
-        }
-        if (c->transient()
-                ->modal()) { // if a modal dialog is minimized, minimize its mainwindow too
-            for (auto c2 : c->transient()->leads()) {
-                win::set_minimized(c2, true);
-            }
-        }
-    } else {
-        // else unmiminize the transients
-        for (auto it = transients.cbegin(); it != transients.cend(); ++it) {
-            auto abstract_client = *it;
-            if (!(*it)->control) {
-                continue;
-            }
-            if ((*it)->control->minimized()) {
-                win::set_minimized(abstract_client, false);
-                updateMinimizedOfTransients(abstract_client);
-            }
-        }
-        if (c->transient()->modal()) {
-            for (auto c2 : c->transient()->leads()) {
-                win::set_minimized(c2, false);
-            }
-        }
-    }
-}
-
-/**
- * Sets the client \a c's transient windows' on_all_desktops property to \a on_all_desktops.
- */
-void space::updateOnAllDesktopsOfTransients(Toplevel* window)
-{
-    auto const transients = window->transient()->children;
-    for (auto const& transient : transients) {
-        if (transient->isOnAllDesktops() != window->isOnAllDesktops()) {
-            win::set_on_all_desktops(transient, window->isOnAllDesktops());
-        }
-    }
-}
-
 void space::update_space_area_from_windows(QRect const& /*desktop_area*/,
                                            std::vector<QRect> const& /*screens_geos*/,
                                            win::space_areas& /*areas*/)
diff --git a/win/space.h b/win/space.h
index 76c756ed4..bffe3e6b8 100644
--- a/win/space.h
+++ b/win/space.h
@@ -262,9 +262,6 @@ public:
 
     Toplevel* active_client{nullptr};
 
-    void updateMinimizedOfTransients(Toplevel*);
-    void updateOnAllDesktopsOfTransients(Toplevel* window);
-
     bool showingDesktop() const;
 
     bool checkStartupNotification(xcb_window_t w, KStartupInfoId& id, KStartupInfoData& data);
diff --git a/win/wayland/window.cpp b/win/wayland/window.cpp
index 6c30d14b5..47bc8b7a5 100644
--- a/win/wayland/window.cpp
+++ b/win/wayland/window.cpp
@@ -1167,7 +1167,7 @@ void window::doMinimize()
     } else {
         Q_EMIT windowShown(this);
     }
-    space.updateMinimizedOfTransients(this);
+    propagate_minimized_to_transients(*this);
 }
 
 void window::placeIn(QRect const& area)
diff --git a/win/x11/control.h b/win/x11/control.h
index f3e4ca30b..02b3d66a0 100644
--- a/win/x11/control.h
+++ b/win/x11/control.h
@@ -530,7 +530,7 @@ auto create_controlled_window(xcb_window_t xcb_win, bool isMapped, Space& space)
     set_desktop(win, desk);
     win->info->setDesktop(desk);
 
-    space.updateOnAllDesktopsOfTransients(win);
+    propagate_on_all_desktops_to_children(*win);
 
     win->client_frame_extents = gtk_frame_extents(win);
     win->geometry_update.original.client_frame_extents = win->client_frame_extents;
diff --git a/win/x11/window.cpp b/win/x11/window.cpp
index 160f91472..3c3f1d2ae 100644
--- a/win/x11/window.cpp
+++ b/win/x11/window.cpp
@@ -1097,7 +1097,7 @@ void window::doMinimize()
 {
     update_visibility(this);
     update_allowed_actions(this);
-    space.updateMinimizedOfTransients(this);
+    propagate_minimized_to_transients(*this);
 }
 
 void window::showOnScreenEdge()
-- 
GitLab


From ddbf74301bbf26c8fa1886d46cc0ba4bf69c1755 Mon Sep 17 00:00:00 2001
From: Roman Gilg <subdiff@gmail.com>
Date: Mon, 11 Jul 2022 23:53:08 +0200
Subject: [PATCH 36/51] refactor: remove space compositing boolean getter

Instead check on the render scene directly.
---
 toplevel.cpp          | 10 +++++-----
 win/scene.h           |  2 +-
 win/space.cpp         |  5 -----
 win/space.h           |  5 -----
 win/tabbox/tabbox.cpp |  2 +-
 win/x11/control.h     |  2 +-
 win/x11/event.h       |  2 +-
 win/x11/geo.h         |  2 +-
 win/x11/hide.h        | 10 +++++-----
 win/x11/space.cpp     |  2 +-
 win/x11/unmanaged.h   |  2 +-
 11 files changed, 17 insertions(+), 27 deletions(-)

diff --git a/toplevel.cpp b/toplevel.cpp
index 40515771d..b0af7cead 100644
--- a/toplevel.cpp
+++ b/toplevel.cpp
@@ -181,7 +181,7 @@ void Toplevel::setOpacity(double new_opacity)
     if (old_opacity == new_opacity)
         return;
     info->setOpacity(static_cast< unsigned long >(new_opacity * 0xffffffff));
-    if (space.compositing()) {
+    if (space.render.scene) {
         addRepaintFull();
         Q_EMIT opacityChanged(this, old_opacity);
     }
@@ -311,7 +311,7 @@ void Toplevel::getDamageRegionReply()
 
 void Toplevel::addDamageFull()
 {
-    if (!space.compositing()) {
+    if (!space.render.scene) {
         return;
     }
 
@@ -337,7 +337,7 @@ void Toplevel::resetDamage()
 
 void Toplevel::addRepaint(QRegion const& region)
 {
-    if (!space.compositing()) {
+    if (!space.render.scene) {
         return;
     }
     repaints_region += region;
@@ -347,7 +347,7 @@ void Toplevel::addRepaint(QRegion const& region)
 
 void Toplevel::addLayerRepaint(QRegion const& region)
 {
-    if (!space.compositing()) {
+    if (!space.render.scene) {
         return;
     }
     layer_repaints_region += region;
@@ -432,7 +432,7 @@ void Toplevel::setReadyForPainting()
 {
     if (!ready_for_painting) {
         ready_for_painting = true;
-        if (space.compositing()) {
+        if (space.render.scene) {
             addRepaintFull();
             Q_EMIT windowShown(this);
         }
diff --git a/win/scene.h b/win/scene.h
index ef7793948..9e2078d44 100644
--- a/win/scene.h
+++ b/win/scene.h
@@ -149,7 +149,7 @@ bool setup_compositing(Win& win, bool add_full_damage)
     static_assert(!Win::is_toplevel);
     assert(!win.remnant);
 
-    if (!win.space.compositing()) {
+    if (!win.space.render.scene) {
         return false;
     }
 
diff --git a/win/space.cpp b/win/space.cpp
index d1f0f04a2..864ac054e 100644
--- a/win/space.cpp
+++ b/win/space.cpp
@@ -318,11 +318,6 @@ void space::disableGlobalShortcutsForClient(bool disable)
     }
 }
 
-bool space::compositing() const
-{
-    return static_cast<bool>(render.scene);
-}
-
 void space::setWasUserInteraction()
 {
     if (was_user_interaction) {
diff --git a/win/space.h b/win/space.h
index bffe3e6b8..57e0d533e 100644
--- a/win/space.h
+++ b/win/space.h
@@ -282,11 +282,6 @@ public:
         return movingClient;
     }
 
-    /**
-     * @returns Whether we have a compositor and it is active (Scene created)
-     */
-    bool compositing() const;
-
     win::shortcut_dialog* shortcutDialog() const
     {
         return client_keys_dialog;
diff --git a/win/tabbox/tabbox.cpp b/win/tabbox/tabbox.cpp
index e49a58150..919e8e300 100644
--- a/win/tabbox/tabbox.cpp
+++ b/win/tabbox/tabbox.cpp
@@ -299,7 +299,7 @@ tabbox_client_list tabbox_handler_impl::stacking_order() const
 
 bool tabbox_handler_impl::is_kwin_compositing() const
 {
-    return m_tabbox->space.compositing();
+    return static_cast<bool>(m_tabbox->space.render.scene);
 }
 
 void tabbox_handler_impl::raise_client(tabbox_client* c) const
diff --git a/win/x11/control.h b/win/x11/control.h
index 02b3d66a0..562d5de5f 100644
--- a/win/x11/control.h
+++ b/win/x11/control.h
@@ -685,7 +685,7 @@ auto create_controlled_window(xcb_window_t xcb_win, bool isMapped, Space& space)
         restore_session_stacking_order(&space, win);
     }
 
-    if (!win->space.compositing()) {
+    if (!win->space.render.scene) {
         // set to true in case compositing is turned on later. bug #160393
         win->ready_for_painting = true;
     }
diff --git a/win/x11/event.h b/win/x11/event.h
index a4ba6fd42..107810b4e 100644
--- a/win/x11/event.h
+++ b/win/x11/event.h
@@ -136,7 +136,7 @@ bool window_event(Win* win, xcb_generic_event_t* e)
             startup_id_changed(win);
         }
         if (dirtyProperties2 & NET::WM2Opacity) {
-            if (win->space.compositing()) {
+            if (win->space.render.scene) {
                 win->addRepaintFull();
                 Q_EMIT win->opacityChanged(win, old_opacity);
             } else {
diff --git a/win/x11/geo.h b/win/x11/geo.h
index 4b8c4b4be..a506fbb90 100644
--- a/win/x11/geo.h
+++ b/win/x11/geo.h
@@ -898,7 +898,7 @@ bool update_server_geometry(Win* win, QRect const& frame_geo)
     }
 
     if (win->control->move_resize().enabled) {
-        if (win->space.compositing()) {
+        if (win->space.render.scene) {
             // Defer the X server update until we leave this mode.
             win->move_needs_server_update = true;
         } else {
diff --git a/win/x11/hide.h b/win/x11/hide.h
index 689e39ca8..a373d2262 100644
--- a/win/x11/hide.h
+++ b/win/x11/hide.h
@@ -26,7 +26,7 @@ void map(Win* win)
     // XComposite invalidates backing pixmaps on unmap (minimize, different
     // virtual desktop, etc.).  We kept the last known good pixmap around
     // for use in effects, but now we want to have access to the new pixmap
-    if (win->space.compositing()) {
+    if (win->space.render.scene) {
         win->discard_buffer();
     }
 
@@ -145,7 +145,7 @@ void internal_hide(Win* win)
 template<typename Win>
 void internal_keep(Win* win)
 {
-    assert(win->space.compositing());
+    assert(win->space.render.scene);
 
     if (win->mapping == mapping_state::kept) {
         return;
@@ -181,7 +181,7 @@ void update_visibility(Win* win)
     if (win->hidden) {
         win->info->setState(NET::Hidden, NET::Hidden);
         win::set_skip_taskbar(win, true);
-        if (win->space.compositing()
+        if (win->space.render.scene
             && kwinApp()->options->hiddenPreviews() == base::HiddenPreviewsAlways) {
             internal_keep(win);
         } else {
@@ -194,7 +194,7 @@ void update_visibility(Win* win)
 
     if (win->control->minimized()) {
         win->info->setState(NET::Hidden, NET::Hidden);
-        if (win->space.compositing()
+        if (win->space.render.scene
             && kwinApp()->options->hiddenPreviews() == base::HiddenPreviewsAlways) {
             internal_keep(win);
         } else {
@@ -205,7 +205,7 @@ void update_visibility(Win* win)
 
     win->info->setState(NET::States(), NET::Hidden);
     if (!win->isOnCurrentDesktop()) {
-        if (win->space.compositing()
+        if (win->space.render.scene
             && kwinApp()->options->hiddenPreviews() != base::HiddenPreviewsNever) {
             internal_keep(win);
         } else {
diff --git a/win/x11/space.cpp b/win/x11/space.cpp
index ec07d3c08..09c97af3b 100644
--- a/win/x11/space.cpp
+++ b/win/x11/space.cpp
@@ -44,7 +44,7 @@ space::space(render::compositor& render)
 
     QObject::connect(
         &kwinApp()->get_base(), &base::platform::topology_changed, qobject.get(), [this] {
-            if (!compositing()) {
+            if (!this->render.scene) {
                 return;
             }
             // desktopResized() should take care of when the size or
diff --git a/win/x11/unmanaged.h b/win/x11/unmanaged.h
index e5d9663e2..84ceaf68b 100644
--- a/win/x11/unmanaged.h
+++ b/win/x11/unmanaged.h
@@ -153,7 +153,7 @@ bool unmanaged_event(Win* win, xcb_generic_event_t* event)
     win->info->event(event, &dirtyProperties, &dirtyProperties2);
 
     if (dirtyProperties2 & NET::WM2Opacity) {
-        if (win->space.compositing()) {
+        if (win->space.render.scene) {
             win->addRepaintFull();
             Q_EMIT win->opacityChanged(win, old_opacity);
         }
-- 
GitLab


From d31c9918b08189b98eb12f66a3cd30ccc56273ab Mon Sep 17 00:00:00 2001
From: Roman Gilg <subdiff@gmail.com>
Date: Tue, 12 Jul 2022 01:09:55 +0200
Subject: [PATCH 37/51] refactor: replace remaining non-virtual space member
 functions

Replace all remaining non-virtual member functions of the win::space class
either with function templates in the win namespace or by direct access to the
variables they were getting.

This further reduces the need for an abstract parent space class.
---
 .../integration/globalshortcuts_test.cpp      |  2 +-
 autotests/integration/lockscreen.cpp          |  6 +-
 .../modifier_only_shortcut_test.cpp           | 10 ++--
 .../integration/move_resize_window_test.cpp   | 44 +++++++-------
 autotests/integration/pointer_input.cpp       | 16 +++---
 autotests/integration/quick_tiling_test.cpp   | 12 ++--
 .../integration/scripting/screenedge_test.cpp |  8 +--
 .../integration/showing_desktop_test.cpp      |  8 +--
 autotests/integration/struts_test.cpp         |  4 +-
 .../integration/xdgshellclient_rules_test.cpp | 46 +++++++--------
 autotests/integration/xdgshellclient_test.cpp |  6 +-
 input/filters/helpers.cpp                     |  4 +-
 input/filters/move_resize.cpp                 | 16 +++---
 input/spies/modifier_only_shortcuts.cpp       |  2 +-
 input/wayland/cursor_image.cpp                |  4 +-
 input/wayland/pointer_redirect.cpp            |  2 +-
 rules/window_rules.cpp                        |  3 +-
 win/activation.h                              | 13 +++--
 win/desktop_space.h                           |  8 +--
 win/input.h                                   | 27 +++++++++
 win/layers.h                                  |  6 +-
 win/move.h                                    |  6 +-
 win/screen_edges.cpp                          |  8 +--
 win/space.cpp                                 | 44 --------------
 win/space.h                                   | 57 +------------------
 win/tabbox.h                                  | 23 ++++++++
 win/tabbox/tabbox.cpp                         |  2 +-
 win/wayland/plasma_window.h                   |  2 +-
 win/wayland/space.cpp                         |  5 +-
 win/x11/control.h                             |  7 ++-
 win/x11/event.h                               |  2 +-
 win/x11/group.cpp                             |  7 ++-
 win/x11/input.h                               | 13 +++++
 win/x11/moving_window_filter.h                |  2 +-
 win/x11/space_setup.h                         |  2 +-
 win/x11/startup_info.h                        | 15 ++++-
 win/x11/window_create.h                       |  3 +-
 win/x11/window_release.h                      |  3 +-
 38 files changed, 217 insertions(+), 231 deletions(-)
 create mode 100644 win/tabbox.h

diff --git a/autotests/integration/globalshortcuts_test.cpp b/autotests/integration/globalshortcuts_test.cpp
index aeccbad49..788a3f450 100644
--- a/autotests/integration/globalshortcuts_test.cpp
+++ b/autotests/integration/globalshortcuts_test.cpp
@@ -466,7 +466,7 @@ void GlobalShortcutsTest::testSetupWindowShortcut()
     auto dialog = shortcutDialogAddedSpy.first().first().value<win::internal_window*>();
     QVERIFY(dialog);
     QVERIFY(dialog->isInternal());
-    auto sequenceEdit = Test::app()->workspace->shortcutDialog()->findChild<QKeySequenceEdit*>();
+    auto sequenceEdit = Test::app()->workspace->client_keys_dialog->findChild<QKeySequenceEdit*>();
     QVERIFY(sequenceEdit);
 
     // the QKeySequenceEdit field does not get focus, we need to pass it focus manually
diff --git a/autotests/integration/lockscreen.cpp b/autotests/integration/lockscreen.cpp
index ac7db16cf..1f13493ee 100644
--- a/autotests/integration/lockscreen.cpp
+++ b/autotests/integration/lockscreen.cpp
@@ -607,7 +607,7 @@ void LockScreenTest::testMoveWindow()
     quint32 timestamp = 1;
 
     win::active_window_move(*Test::app()->workspace);
-    QCOMPARE(Test::app()->workspace->moveResizeClient(), c);
+    QCOMPARE(Test::app()->workspace->move_resize_window, c);
     QVERIFY(win::is_move(c));
 
     Test::keyboard_key_pressed(KEY_RIGHT, timestamp++);
@@ -621,14 +621,14 @@ void LockScreenTest::testMoveWindow()
     QCOMPARE(clientStepUserMovedResizedSpy.count(), 1);
 
     // While locking our window should continue to be in move resize.
-    LOCK QCOMPARE(Test::app()->workspace->moveResizeClient(), c);
+    LOCK QCOMPARE(Test::app()->workspace->move_resize_window, c);
     QVERIFY(win::is_move(c));
     Test::keyboard_key_pressed(KEY_RIGHT, timestamp++);
     Test::keyboard_key_released(KEY_RIGHT, timestamp++);
     QCOMPARE(clientStepUserMovedResizedSpy.count(), 1);
 
     UNLOCK
-    QCOMPARE(Test::app()->workspace->moveResizeClient(), c);
+    QCOMPARE(Test::app()->workspace->move_resize_window, c);
     QVERIFY(win::is_move(c));
 
     Test::keyboard_key_pressed(KEY_RIGHT, timestamp++);
diff --git a/autotests/integration/modifier_only_shortcut_test.cpp b/autotests/integration/modifier_only_shortcut_test.cpp
index e214087dc..81dfb7c2b 100644
--- a/autotests/integration/modifier_only_shortcut_test.cpp
+++ b/autotests/integration/modifier_only_shortcut_test.cpp
@@ -418,15 +418,15 @@ void ModifierOnlyShortcutTest::testGlobalShortcutsDisabled()
     // trigger once to verify the shortcut works
     quint32 timestamp = 1;
     QFETCH(int, modifier);
-    QVERIFY(!Test::app()->workspace->globalShortcutsDisabled());
+    QVERIFY(!Test::app()->workspace->global_shortcuts_disabled);
     Test::keyboard_key_pressed(modifier, timestamp++);
     Test::keyboard_key_released(modifier, timestamp++);
     QTRY_COMPARE(triggeredSpy.count(), 1);
     triggeredSpy.clear();
 
     // now disable global shortcuts
-    Test::app()->workspace->disableGlobalShortcutsForClient(true);
-    QVERIFY(Test::app()->workspace->globalShortcutsDisabled());
+    win::set_global_shortcuts_disabled(*Test::app()->workspace, true);
+    QVERIFY(Test::app()->workspace->global_shortcuts_disabled);
     // Should not get triggered
     Test::keyboard_key_pressed(modifier, timestamp++);
     Test::keyboard_key_released(modifier, timestamp++);
@@ -434,8 +434,8 @@ void ModifierOnlyShortcutTest::testGlobalShortcutsDisabled()
     triggeredSpy.clear();
 
     // enable again
-    Test::app()->workspace->disableGlobalShortcutsForClient(false);
-    QVERIFY(!Test::app()->workspace->globalShortcutsDisabled());
+    win::set_global_shortcuts_disabled(*Test::app()->workspace, false);
+    QVERIFY(!Test::app()->workspace->global_shortcuts_disabled);
     // should get triggered again
     Test::keyboard_key_pressed(modifier, timestamp++);
     Test::keyboard_key_released(modifier, timestamp++);
diff --git a/autotests/integration/move_resize_window_test.cpp b/autotests/integration/move_resize_window_test.cpp
index 0afbe880d..ccb89316b 100644
--- a/autotests/integration/move_resize_window_test.cpp
+++ b/autotests/integration/move_resize_window_test.cpp
@@ -150,12 +150,12 @@ void MoveResizeWindowTest::testMove()
                                                &EffectsHandler::windowFinishUserMovedResized);
     QVERIFY(windowFinishUserMovedResizedSpy.isValid());
 
-    QVERIFY(Test::app()->workspace->moveResizeClient() == nullptr);
+    QVERIFY(Test::app()->workspace->move_resize_window == nullptr);
     QCOMPARE(win::is_move(c), false);
 
     // begin move
     win::active_window_move(*Test::app()->workspace);
-    QCOMPARE(Test::app()->workspace->moveResizeClient(), c);
+    QCOMPARE(Test::app()->workspace->move_resize_window, c);
     QCOMPARE(startMoveResizedSpy.count(), 1);
     QCOMPARE(moveResizedChangedSpy.count(), 1);
     QCOMPARE(windowStartUserMovedResizedSpy.count(), 1);
@@ -193,7 +193,7 @@ void MoveResizeWindowTest::testMove()
     QCOMPARE(windowFinishUserMovedResizedSpy.count(), 1);
     QCOMPARE(c->frameGeometry(), QRect(16, 32, 100, 50));
     QCOMPARE(win::is_move(c), false);
-    QVERIFY(Test::app()->workspace->moveResizeClient() == nullptr);
+    QVERIFY(Test::app()->workspace->move_resize_window == nullptr);
     surface.reset();
     QVERIFY(Test::wait_for_destroyed(c));
 }
@@ -250,11 +250,11 @@ void MoveResizeWindowTest::testResize()
     QVERIFY(clientFinishUserMovedResizedSpy.isValid());
 
     // begin resize
-    QCOMPARE(Test::app()->workspace->moveResizeClient(), nullptr);
+    QCOMPARE(Test::app()->workspace->move_resize_window, nullptr);
     QCOMPARE(win::is_move(c), false);
     QCOMPARE(win::is_resize(c), false);
     win::active_window_resize(*Test::app()->workspace);
-    QCOMPARE(Test::app()->workspace->moveResizeClient(), c);
+    QCOMPARE(Test::app()->workspace->move_resize_window, c);
     QCOMPARE(startMoveResizedSpy.count(), 1);
     QCOMPARE(moveResizedChangedSpy.count(), 1);
     QCOMPARE(win::is_resize(c), true);
@@ -314,7 +314,7 @@ void MoveResizeWindowTest::testResize()
     QCOMPARE(clientFinishUserMovedResizedSpy.count(), 1);
     QCOMPARE(moveResizedChangedSpy.count(), 2);
     QCOMPARE(win::is_resize(c), false);
-    QCOMPARE(Test::app()->workspace->moveResizeClient(), nullptr);
+    QCOMPARE(Test::app()->workspace->move_resize_window, nullptr);
     QEXPECT_FAIL("", "XdgShellClient currently doesn't send final configure event", Abort);
     QVERIFY(configureRequestedSpy.wait(500));
     QCOMPARE(configureRequestedSpy.count(), 6);
@@ -747,7 +747,7 @@ void MoveResizeWindowTest::testNetMove()
     QVERIFY(moveEndSpy.isValid());
     QSignalSpy moveStepSpy(client, &win::x11::window::clientStepUserMovedResized);
     QVERIFY(moveStepSpy.isValid());
-    QVERIFY(!Test::app()->workspace->moveResizeClient());
+    QVERIFY(!Test::app()->workspace->move_resize_window);
 
     // use NETRootInfo to trigger a move request
     NETRootInfo root(c.get(), NET::Properties());
@@ -755,7 +755,7 @@ void MoveResizeWindowTest::testNetMove()
     xcb_flush(c.get());
 
     QVERIFY(moveStartSpy.wait());
-    QCOMPARE(Test::app()->workspace->moveResizeClient(), client);
+    QCOMPARE(Test::app()->workspace->move_resize_window, client);
     QVERIFY(win::is_move(client));
     QCOMPARE(client->restore_geometries.maximize, origGeo);
     QCOMPARE(input::get_cursor()->pos(), origGeo.center());
@@ -1004,12 +1004,12 @@ void MoveResizeWindowTest::testDestroyMoveClient()
     QSignalSpy clientFinishUserMovedResizedSpy(client, &Toplevel::clientFinishUserMovedResized);
     QVERIFY(clientFinishUserMovedResizedSpy.isValid());
 
-    QCOMPARE(Test::app()->workspace->moveResizeClient(), nullptr);
+    QCOMPARE(Test::app()->workspace->move_resize_window, nullptr);
     QCOMPARE(win::is_move(client), false);
     QCOMPARE(win::is_resize(client), false);
     win::active_window_move(*Test::app()->workspace);
     QCOMPARE(clientStartMoveResizedSpy.count(), 1);
-    QCOMPARE(Test::app()->workspace->moveResizeClient(), client);
+    QCOMPARE(Test::app()->workspace->move_resize_window, client);
     QCOMPARE(win::is_move(client), true);
     QCOMPARE(win::is_resize(client), false);
 
@@ -1018,7 +1018,7 @@ void MoveResizeWindowTest::testDestroyMoveClient()
     surface.reset();
     QVERIFY(Test::wait_for_destroyed(client));
     QCOMPARE(clientFinishUserMovedResizedSpy.count(), 0);
-    QCOMPARE(Test::app()->workspace->moveResizeClient(), nullptr);
+    QCOMPARE(Test::app()->workspace->move_resize_window, nullptr);
 }
 
 void MoveResizeWindowTest::testDestroyResizeClient()
@@ -1041,12 +1041,12 @@ void MoveResizeWindowTest::testDestroyResizeClient()
     QSignalSpy clientFinishUserMovedResizedSpy(client, &Toplevel::clientFinishUserMovedResized);
     QVERIFY(clientFinishUserMovedResizedSpy.isValid());
 
-    QCOMPARE(Test::app()->workspace->moveResizeClient(), nullptr);
+    QCOMPARE(Test::app()->workspace->move_resize_window, nullptr);
     QCOMPARE(win::is_move(client), false);
     QCOMPARE(win::is_resize(client), false);
     win::active_window_resize(*Test::app()->workspace);
     QCOMPARE(clientStartMoveResizedSpy.count(), 1);
-    QCOMPARE(Test::app()->workspace->moveResizeClient(), client);
+    QCOMPARE(Test::app()->workspace->move_resize_window, client);
     QCOMPARE(win::is_move(client), false);
     QCOMPARE(win::is_resize(client), true);
 
@@ -1055,7 +1055,7 @@ void MoveResizeWindowTest::testDestroyResizeClient()
     surface.reset();
     QVERIFY(Test::wait_for_destroyed(client));
     QCOMPARE(clientFinishUserMovedResizedSpy.count(), 0);
-    QCOMPARE(Test::app()->workspace->moveResizeClient(), nullptr);
+    QCOMPARE(Test::app()->workspace->move_resize_window, nullptr);
 }
 
 void MoveResizeWindowTest::testUnmapMoveClient()
@@ -1078,12 +1078,12 @@ void MoveResizeWindowTest::testUnmapMoveClient()
     QSignalSpy clientFinishUserMovedResizedSpy(client, &Toplevel::clientFinishUserMovedResized);
     QVERIFY(clientFinishUserMovedResizedSpy.isValid());
 
-    QCOMPARE(Test::app()->workspace->moveResizeClient(), nullptr);
+    QCOMPARE(Test::app()->workspace->move_resize_window, nullptr);
     QCOMPARE(win::is_move(client), false);
     QCOMPARE(win::is_resize(client), false);
     win::active_window_move(*Test::app()->workspace);
     QCOMPARE(clientStartMoveResizedSpy.count(), 1);
-    QCOMPARE(Test::app()->workspace->moveResizeClient(), client);
+    QCOMPARE(Test::app()->workspace->move_resize_window, client);
     QCOMPARE(win::is_move(client), true);
     QCOMPARE(win::is_resize(client), false);
 
@@ -1094,7 +1094,7 @@ void MoveResizeWindowTest::testUnmapMoveClient()
     surface->commit(Surface::CommitFlag::None);
     QVERIFY(hiddenSpy.wait());
     QCOMPARE(clientFinishUserMovedResizedSpy.count(), 0);
-    QCOMPARE(Test::app()->workspace->moveResizeClient(), nullptr);
+    QCOMPARE(Test::app()->workspace->move_resize_window, nullptr);
     QCOMPARE(win::is_move(client), false);
     QCOMPARE(win::is_resize(client), false);
 
@@ -1124,12 +1124,12 @@ void MoveResizeWindowTest::testUnmapResizeClient()
     QSignalSpy clientFinishUserMovedResizedSpy(client, &Toplevel::clientFinishUserMovedResized);
     QVERIFY(clientFinishUserMovedResizedSpy.isValid());
 
-    QCOMPARE(Test::app()->workspace->moveResizeClient(), nullptr);
+    QCOMPARE(Test::app()->workspace->move_resize_window, nullptr);
     QCOMPARE(win::is_move(client), false);
     QCOMPARE(win::is_resize(client), false);
     win::active_window_resize(*Test::app()->workspace);
     QCOMPARE(clientStartMoveResizedSpy.count(), 1);
-    QCOMPARE(Test::app()->workspace->moveResizeClient(), client);
+    QCOMPARE(Test::app()->workspace->move_resize_window, client);
     QCOMPARE(win::is_move(client), false);
     QCOMPARE(win::is_resize(client), true);
 
@@ -1140,7 +1140,7 @@ void MoveResizeWindowTest::testUnmapResizeClient()
     surface->commit(Surface::CommitFlag::None);
     QVERIFY(hiddenSpy.wait());
     QCOMPARE(clientFinishUserMovedResizedSpy.count(), 0);
-    QCOMPARE(Test::app()->workspace->moveResizeClient(), nullptr);
+    QCOMPARE(Test::app()->workspace->move_resize_window, nullptr);
     QCOMPARE(win::is_move(client), false);
     QCOMPARE(win::is_resize(client), false);
 
@@ -1202,7 +1202,7 @@ void MoveResizeWindowTest::testSetFullScreenWhenMoving()
 
     QCOMPARE(client->control->fullscreen(), true);
     QCOMPARE(win::is_move(client), false);
-    QCOMPARE(Test::app()->workspace->moveResizeClient(), nullptr);
+    QCOMPARE(Test::app()->workspace->move_resize_window, nullptr);
 
     // Let's pretend that the client crashed.
     shellSurface.reset();
@@ -1231,7 +1231,7 @@ void MoveResizeWindowTest::testSetMaximizeWhenMoving()
 
     QEXPECT_FAIL("", "The client is still in move state at this point. Is this correct?", Abort);
     QCOMPARE(win::is_move(client), false);
-    QCOMPARE(Test::app()->workspace->moveResizeClient(), nullptr);
+    QCOMPARE(Test::app()->workspace->move_resize_window, nullptr);
     // Let's pretend that the client crashed.
     shellSurface.reset();
     surface.reset();
diff --git a/autotests/integration/pointer_input.cpp b/autotests/integration/pointer_input.cpp
index 3a5cab1ca..78595b9e2 100644
--- a/autotests/integration/pointer_input.cpp
+++ b/autotests/integration/pointer_input.cpp
@@ -533,9 +533,9 @@ void PointerInputTest::testModifierClickUnrestrictedMoveGlobalShortcutsDisabled(
     QVERIFY(window);
 
     // disable global shortcuts
-    QVERIFY(!Test::app()->workspace->globalShortcutsDisabled());
-    Test::app()->workspace->disableGlobalShortcutsForClient(true);
-    QVERIFY(Test::app()->workspace->globalShortcutsDisabled());
+    QVERIFY(!Test::app()->workspace->global_shortcuts_disabled);
+    win::set_global_shortcuts_disabled(*Test::app()->workspace, true);
+    QVERIFY(Test::app()->workspace->global_shortcuts_disabled);
 
     // move cursor on window
     input::get_cursor()->set_pos(window->frameGeometry().center());
@@ -551,7 +551,7 @@ void PointerInputTest::testModifierClickUnrestrictedMoveGlobalShortcutsDisabled(
     QVERIFY(!win::is_move(window));
     Test::pointer_button_released(BTN_LEFT, timestamp++);
 
-    Test::app()->workspace->disableGlobalShortcutsForClient(false);
+    win::set_global_shortcuts_disabled(*Test::app()->workspace, false);
 }
 
 void PointerInputTest::testModifierScrollOpacity_data()
@@ -673,9 +673,9 @@ void PointerInputTest::testModifierScrollOpacityGlobalShortcutsDisabled()
     input::get_cursor()->set_pos(window->frameGeometry().center());
 
     // disable global shortcuts
-    QVERIFY(!Test::app()->workspace->globalShortcutsDisabled());
-    Test::app()->workspace->disableGlobalShortcutsForClient(true);
-    QVERIFY(Test::app()->workspace->globalShortcutsDisabled());
+    QVERIFY(!Test::app()->workspace->global_shortcuts_disabled);
+    win::set_global_shortcuts_disabled(*Test::app()->workspace, true);
+    QVERIFY(Test::app()->workspace->global_shortcuts_disabled);
 
     // simulate modifier+wheel
     quint32 timestamp = 1;
@@ -686,7 +686,7 @@ void PointerInputTest::testModifierScrollOpacityGlobalShortcutsDisabled()
     QCOMPARE(window->opacity(), 0.5);
     Test::keyboard_key_released(KEY_LEFTMETA, timestamp++);
 
-    Test::app()->workspace->disableGlobalShortcutsForClient(false);
+    win::set_global_shortcuts_disabled(*Test::app()->workspace, false);
 }
 
 void PointerInputTest::testScrollAction()
diff --git a/autotests/integration/quick_tiling_test.cpp b/autotests/integration/quick_tiling_test.cpp
index 94adb92b1..085fccd0c 100644
--- a/autotests/integration/quick_tiling_test.cpp
+++ b/autotests/integration/quick_tiling_test.cpp
@@ -428,7 +428,7 @@ void QuickTilingTest::testQuickTilingKeyboardMove()
     QVERIFY(quickTileChangedSpy.isValid());
 
     win::perform_window_operation(*Test::app()->workspace, c, base::options::UnrestrictedMoveOp);
-    QCOMPARE(c, Test::app()->workspace->moveResizeClient());
+    QCOMPARE(c, Test::app()->workspace->move_resize_window);
     QCOMPARE(input::get_cursor()->pos(), QPoint(49, 24));
 
     QFETCH(QPoint, targetPos);
@@ -454,7 +454,7 @@ void QuickTilingTest::testQuickTilingKeyboardMove()
     Test::keyboard_key_pressed(KEY_ENTER, timestamp++);
     Test::keyboard_key_released(KEY_ENTER, timestamp++);
     QCOMPARE(input::get_cursor()->pos(), targetPos);
-    QVERIFY(!Test::app()->workspace->moveResizeClient());
+    QVERIFY(!Test::app()->workspace->move_resize_window);
 
     QCOMPARE(quickTileChangedSpy.count(), 1);
     QTEST(c->control->quicktiling(), "expectedMode");
@@ -511,7 +511,7 @@ void QuickTilingTest::testQuickTilingPointerMove()
     QVERIFY(quickTileChangedSpy.isValid());
 
     win::perform_window_operation(*Test::app()->workspace, c, base::options::UnrestrictedMoveOp);
-    QCOMPARE(c, Test::app()->workspace->moveResizeClient());
+    QCOMPARE(c, Test::app()->workspace->move_resize_window);
     QCOMPARE(input::get_cursor()->pos(), QPoint(49, 24));
     QVERIFY(configureRequestedSpy.wait());
     QCOMPARE(configureRequestedSpy.count(), 3);
@@ -522,7 +522,7 @@ void QuickTilingTest::testQuickTilingPointerMove()
     Test::pointer_button_pressed(BTN_LEFT, timestamp++);
     Test::pointer_button_released(BTN_LEFT, timestamp++);
     QCOMPARE(input::get_cursor()->pos(), targetPos);
-    QVERIFY(!Test::app()->workspace->moveResizeClient());
+    QVERIFY(!Test::app()->workspace->move_resize_window);
 
     QCOMPARE(quickTileChangedSpy.count(), 1);
     QTEST(c->control->quicktiling(), "expectedMode");
@@ -604,13 +604,13 @@ void QuickTilingTest::testQuickTilingTouchMove()
                              c->frameGeometry().y() + decoration->borderTop() / 2),
                      timestamp++);
     QVERIFY(configureRequestedSpy.wait());
-    QCOMPARE(c, Test::app()->workspace->moveResizeClient());
+    QCOMPARE(c, Test::app()->workspace->move_resize_window);
     QCOMPARE(configureRequestedSpy.count(), 3);
 
     QFETCH(QPoint, targetPos);
     Test::touch_motion(0, targetPos, timestamp++);
     Test::touch_up(0, timestamp++);
-    QVERIFY(!Test::app()->workspace->moveResizeClient());
+    QVERIFY(!Test::app()->workspace->move_resize_window);
 
     // When there are no borders, there is no change to them when quick-tiling.
     // TODO: we should test both cases with fixed fake decoration for autotests.
diff --git a/autotests/integration/scripting/screenedge_test.cpp b/autotests/integration/scripting/screenedge_test.cpp
index e2c81a89a..0e147f64d 100644
--- a/autotests/integration/scripting/screenedge_test.cpp
+++ b/autotests/integration/scripting/screenedge_test.cpp
@@ -90,10 +90,10 @@ void ScreenEdgeTest::initTestCase()
 void ScreenEdgeTest::init()
 {
     input::get_cursor()->set_pos(640, 512);
-    if (Test::app()->workspace->showingDesktop()) {
+    if (Test::app()->workspace->showing_desktop) {
         win::toggle_show_desktop(*Test::app()->workspace);
     }
-    QVERIFY(!Test::app()->workspace->showingDesktop());
+    QVERIFY(!Test::app()->workspace->showing_desktop);
 }
 
 void ScreenEdgeTest::cleanup()
@@ -163,7 +163,7 @@ void ScreenEdgeTest::testEdge()
     QFETCH(QPoint, triggerPos);
     input::get_cursor()->set_pos(triggerPos);
     QCOMPARE(showDesktopSpy.count(), 1);
-    QVERIFY(Test::app()->workspace->showingDesktop());
+    QVERIFY(Test::app()->workspace->showing_desktop);
 }
 
 void ScreenEdgeTest::testTouchEdge_data()
@@ -218,7 +218,7 @@ void ScreenEdgeTest::testTouchEdge()
     Test::touch_up(0, timestamp++);
     QVERIFY(showDesktopSpy.wait());
     QCOMPARE(showDesktopSpy.count(), 1);
-    QVERIFY(Test::app()->workspace->showingDesktop());
+    QVERIFY(Test::app()->workspace->showing_desktop);
 }
 
 void ScreenEdgeTest::triggerConfigReload()
diff --git a/autotests/integration/showing_desktop_test.cpp b/autotests/integration/showing_desktop_test.cpp
index 6bf4e89ab..456445804 100644
--- a/autotests/integration/showing_desktop_test.cpp
+++ b/autotests/integration/showing_desktop_test.cpp
@@ -76,9 +76,9 @@ void ShowingDesktopTest::testRestoreFocus()
 
     QCOMPARE(Test::app()->workspace->active_client, client2);
     win::toggle_show_desktop(*Test::app()->workspace);
-    QVERIFY(Test::app()->workspace->showingDesktop());
+    QVERIFY(Test::app()->workspace->showing_desktop);
     win::toggle_show_desktop(*Test::app()->workspace);
-    QVERIFY(!Test::app()->workspace->showingDesktop());
+    QVERIFY(!Test::app()->workspace->showing_desktop);
 
     QVERIFY(Test::app()->workspace->active_client);
     QCOMPARE(Test::app()->workspace->active_client, client2);
@@ -113,10 +113,10 @@ void ShowingDesktopTest::testRestoreFocusWithDesktopWindow()
 
     QCOMPARE(Test::app()->workspace->active_client, client2);
     win::toggle_show_desktop(*Test::app()->workspace);
-    QVERIFY(Test::app()->workspace->showingDesktop());
+    QVERIFY(Test::app()->workspace->showing_desktop);
     QCOMPARE(Test::app()->workspace->active_client, desktop);
     win::toggle_show_desktop(*Test::app()->workspace);
-    QVERIFY(!Test::app()->workspace->showingDesktop());
+    QVERIFY(!Test::app()->workspace->showing_desktop);
 
     QVERIFY(Test::app()->workspace->active_client);
     QCOMPARE(Test::app()->workspace->active_client, client2);
diff --git a/autotests/integration/struts_test.cpp b/autotests/integration/struts_test.cpp
index af7910ae7..d3e2776db 100644
--- a/autotests/integration/struts_test.cpp
+++ b/autotests/integration/struts_test.cpp
@@ -1064,7 +1064,7 @@ void StrutsTest::testWindowMoveWithPanelBetweenScreens()
     input::get_cursor()->set_pos(origGeo.center());
     win::perform_window_operation(*Test::app()->workspace, client2, base::options::MoveOp);
 
-    QTRY_COMPARE(Test::app()->workspace->moveResizeClient(), client2);
+    QTRY_COMPARE(Test::app()->workspace->move_resize_window, client2);
     QVERIFY(win::is_move(client2));
 
     // move to next screen - step is 8 pixel, so 800 pixel
@@ -1075,7 +1075,7 @@ void StrutsTest::testWindowMoveWithPanelBetweenScreens()
 
     win::key_press_event(client2, Qt::Key_Enter);
     QCOMPARE(win::is_move(client2), false);
-    QVERIFY(Test::app()->workspace->moveResizeClient() == nullptr);
+    QVERIFY(Test::app()->workspace->move_resize_window == nullptr);
     QCOMPARE(client2->frameGeometry(), QRect(origGeo.translated(-800, 0)));
 
     // Destroy window again.
diff --git a/autotests/integration/xdgshellclient_rules_test.cpp b/autotests/integration/xdgshellclient_rules_test.cpp
index 3184e2ea6..77aa9af89 100644
--- a/autotests/integration/xdgshellclient_rules_test.cpp
+++ b/autotests/integration/xdgshellclient_rules_test.cpp
@@ -289,11 +289,11 @@ void TestXdgShellClientRules::testPositionApply()
     QSignalSpy clientFinishUserMovedResizedSpy(client, &Toplevel::clientFinishUserMovedResized);
     QVERIFY(clientFinishUserMovedResizedSpy.isValid());
 
-    QCOMPARE(Test::app()->workspace->moveResizeClient(), nullptr);
+    QCOMPARE(Test::app()->workspace->move_resize_window, nullptr);
     QVERIFY(!win::is_move(client));
     QVERIFY(!win::is_resize(client));
     win::active_window_move(*Test::app()->workspace);
-    QCOMPARE(Test::app()->workspace->moveResizeClient(), client);
+    QCOMPARE(Test::app()->workspace->move_resize_window, client);
     QCOMPARE(clientStartMoveResizedSpy.count(), 1);
     QVERIFY(win::is_move(client));
     QVERIFY(!win::is_resize(client));
@@ -307,7 +307,7 @@ void TestXdgShellClientRules::testPositionApply()
 
     win::key_press_event(client, Qt::Key_Enter);
     QCOMPARE(clientFinishUserMovedResizedSpy.count(), 1);
-    QCOMPARE(Test::app()->workspace->moveResizeClient(), nullptr);
+    QCOMPARE(Test::app()->workspace->move_resize_window, nullptr);
     QVERIFY(!win::is_move(client));
     QVERIFY(!win::is_resize(client));
     QCOMPARE(client->pos(), QPoint(50, 42));
@@ -365,11 +365,11 @@ void TestXdgShellClientRules::testPositionRemember()
     QSignalSpy clientFinishUserMovedResizedSpy(client, &Toplevel::clientFinishUserMovedResized);
     QVERIFY(clientFinishUserMovedResizedSpy.isValid());
 
-    QCOMPARE(Test::app()->workspace->moveResizeClient(), nullptr);
+    QCOMPARE(Test::app()->workspace->move_resize_window, nullptr);
     QVERIFY(!win::is_move(client));
     QVERIFY(!win::is_resize(client));
     win::active_window_move(*Test::app()->workspace);
-    QCOMPARE(Test::app()->workspace->moveResizeClient(), client);
+    QCOMPARE(Test::app()->workspace->move_resize_window, client);
     QCOMPARE(clientStartMoveResizedSpy.count(), 1);
     QVERIFY(win::is_move(client));
     QVERIFY(!win::is_resize(client));
@@ -383,7 +383,7 @@ void TestXdgShellClientRules::testPositionRemember()
 
     win::key_press_event(client, Qt::Key_Enter);
     QCOMPARE(clientFinishUserMovedResizedSpy.count(), 1);
-    QCOMPARE(Test::app()->workspace->moveResizeClient(), nullptr);
+    QCOMPARE(Test::app()->workspace->move_resize_window, nullptr);
     QVERIFY(!win::is_move(client));
     QVERIFY(!win::is_resize(client));
     QCOMPARE(client->pos(), QPoint(50, 42));
@@ -436,11 +436,11 @@ void TestXdgShellClientRules::testPositionForce()
     // User should not be able to move the client.
     QSignalSpy clientStartMoveResizedSpy(client, &Toplevel::clientStartUserMovedResized);
     QVERIFY(clientStartMoveResizedSpy.isValid());
-    QCOMPARE(Test::app()->workspace->moveResizeClient(), nullptr);
+    QCOMPARE(Test::app()->workspace->move_resize_window, nullptr);
     QVERIFY(!win::is_move(client));
     QVERIFY(!win::is_resize(client));
     win::active_window_move(*Test::app()->workspace);
-    QCOMPARE(Test::app()->workspace->moveResizeClient(), nullptr);
+    QCOMPARE(Test::app()->workspace->move_resize_window, nullptr);
     QCOMPARE(clientStartMoveResizedSpy.count(), 0);
     QVERIFY(!win::is_move(client));
     QVERIFY(!win::is_resize(client));
@@ -507,11 +507,11 @@ void TestXdgShellClientRules::testPositionApplyNow()
     QSignalSpy clientFinishUserMovedResizedSpy(client, &Toplevel::clientFinishUserMovedResized);
     QVERIFY(clientFinishUserMovedResizedSpy.isValid());
 
-    QCOMPARE(Test::app()->workspace->moveResizeClient(), nullptr);
+    QCOMPARE(Test::app()->workspace->move_resize_window, nullptr);
     QVERIFY(!win::is_move(client));
     QVERIFY(!win::is_resize(client));
     win::active_window_move(*Test::app()->workspace);
-    QCOMPARE(Test::app()->workspace->moveResizeClient(), client);
+    QCOMPARE(Test::app()->workspace->move_resize_window, client);
     QCOMPARE(clientStartMoveResizedSpy.count(), 1);
     QVERIFY(win::is_move(client));
     QVERIFY(!win::is_resize(client));
@@ -525,7 +525,7 @@ void TestXdgShellClientRules::testPositionApplyNow()
 
     win::key_press_event(client, Qt::Key_Enter);
     QCOMPARE(clientFinishUserMovedResizedSpy.count(), 1);
-    QCOMPARE(Test::app()->workspace->moveResizeClient(), nullptr);
+    QCOMPARE(Test::app()->workspace->move_resize_window, nullptr);
     QVERIFY(!win::is_move(client));
     QVERIFY(!win::is_resize(client));
     QCOMPARE(client->pos(), QPoint(50, 42));
@@ -571,11 +571,11 @@ void TestXdgShellClientRules::testPositionForceTemporarily()
     // User should not be able to move the client.
     QSignalSpy clientStartMoveResizedSpy(client, &Toplevel::clientStartUserMovedResized);
     QVERIFY(clientStartMoveResizedSpy.isValid());
-    QCOMPARE(Test::app()->workspace->moveResizeClient(), nullptr);
+    QCOMPARE(Test::app()->workspace->move_resize_window, nullptr);
     QVERIFY(!win::is_move(client));
     QVERIFY(!win::is_resize(client));
     win::active_window_move(*Test::app()->workspace);
-    QCOMPARE(Test::app()->workspace->moveResizeClient(), nullptr);
+    QCOMPARE(Test::app()->workspace->move_resize_window, nullptr);
     QCOMPARE(clientStartMoveResizedSpy.count(), 0);
     QVERIFY(!win::is_move(client));
     QVERIFY(!win::is_resize(client));
@@ -706,11 +706,11 @@ void TestXdgShellClientRules::testSizeApply()
     QSignalSpy surfaceSizeChangedSpy(shellSurface.get(), &XdgShellToplevel::sizeChanged);
     QVERIFY(surfaceSizeChangedSpy.isValid());
 
-    QCOMPARE(Test::app()->workspace->moveResizeClient(), nullptr);
+    QCOMPARE(Test::app()->workspace->move_resize_window, nullptr);
     QVERIFY(!win::is_move(client));
     QVERIFY(!win::is_resize(client));
     win::active_window_resize(*Test::app()->workspace);
-    QCOMPARE(Test::app()->workspace->moveResizeClient(), client);
+    QCOMPARE(Test::app()->workspace->move_resize_window, client);
     QCOMPARE(clientStartMoveResizedSpy.count(), 1);
     QVERIFY(!win::is_move(client));
     QVERIFY(win::is_resize(client));
@@ -741,7 +741,7 @@ void TestXdgShellClientRules::testSizeApply()
 
     win::key_press_event(client, Qt::Key_Enter);
     QCOMPARE(clientFinishUserMovedResizedSpy.count(), 1);
-    QCOMPARE(Test::app()->workspace->moveResizeClient(), nullptr);
+    QCOMPARE(Test::app()->workspace->move_resize_window, nullptr);
     QVERIFY(!win::is_move(client));
     QVERIFY(!win::is_resize(client));
 
@@ -841,11 +841,11 @@ void TestXdgShellClientRules::testSizeRemember()
     QSignalSpy surfaceSizeChangedSpy(shellSurface.get(), &XdgShellToplevel::sizeChanged);
     QVERIFY(surfaceSizeChangedSpy.isValid());
 
-    QCOMPARE(Test::app()->workspace->moveResizeClient(), nullptr);
+    QCOMPARE(Test::app()->workspace->move_resize_window, nullptr);
     QVERIFY(!win::is_move(client));
     QVERIFY(!win::is_resize(client));
     win::active_window_resize(*Test::app()->workspace);
-    QCOMPARE(Test::app()->workspace->moveResizeClient(), client);
+    QCOMPARE(Test::app()->workspace->move_resize_window, client);
     QCOMPARE(clientStartMoveResizedSpy.count(), 1);
     QVERIFY(!win::is_move(client));
     QVERIFY(win::is_resize(client));
@@ -876,7 +876,7 @@ void TestXdgShellClientRules::testSizeRemember()
 
     win::key_press_event(client, Qt::Key_Enter);
     QCOMPARE(clientFinishUserMovedResizedSpy.count(), 1);
-    QCOMPARE(Test::app()->workspace->moveResizeClient(), nullptr);
+    QCOMPARE(Test::app()->workspace->move_resize_window, nullptr);
     QVERIFY(!win::is_move(client));
     QVERIFY(!win::is_resize(client));
 
@@ -960,11 +960,11 @@ void TestXdgShellClientRules::testSizeForce()
     // Any attempt to resize the client should not succeed.
     QSignalSpy clientStartMoveResizedSpy(client, &Toplevel::clientStartUserMovedResized);
     QVERIFY(clientStartMoveResizedSpy.isValid());
-    QCOMPARE(Test::app()->workspace->moveResizeClient(), nullptr);
+    QCOMPARE(Test::app()->workspace->move_resize_window, nullptr);
     QVERIFY(!win::is_move(client));
     QVERIFY(!win::is_resize(client));
     win::active_window_resize(*Test::app()->workspace);
-    QCOMPARE(Test::app()->workspace->moveResizeClient(), nullptr);
+    QCOMPARE(Test::app()->workspace->move_resize_window, nullptr);
     QCOMPARE(clientStartMoveResizedSpy.count(), 0);
     QVERIFY(!win::is_move(client));
     QVERIFY(!win::is_resize(client));
@@ -1110,11 +1110,11 @@ void TestXdgShellClientRules::testSizeForceTemporarily()
     // Any attempt to resize the client should not succeed.
     QSignalSpy clientStartMoveResizedSpy(client, &Toplevel::clientStartUserMovedResized);
     QVERIFY(clientStartMoveResizedSpy.isValid());
-    QCOMPARE(Test::app()->workspace->moveResizeClient(), nullptr);
+    QCOMPARE(Test::app()->workspace->move_resize_window, nullptr);
     QVERIFY(!win::is_move(client));
     QVERIFY(!win::is_resize(client));
     win::active_window_resize(*Test::app()->workspace);
-    QCOMPARE(Test::app()->workspace->moveResizeClient(), nullptr);
+    QCOMPARE(Test::app()->workspace->move_resize_window, nullptr);
     QCOMPARE(clientStartMoveResizedSpy.count(), 0);
     QVERIFY(!win::is_move(client));
     QVERIFY(!win::is_resize(client));
diff --git a/autotests/integration/xdgshellclient_test.cpp b/autotests/integration/xdgshellclient_test.cpp
index 06f841104..31bc5e254 100644
--- a/autotests/integration/xdgshellclient_test.cpp
+++ b/autotests/integration/xdgshellclient_test.cpp
@@ -1535,9 +1535,9 @@ void TestXdgShellClient::testXdgWindowGeometryInteractiveResize()
     QVERIFY(clientFinishUserMovedResizedSpy.isValid());
 
     // Start interactively resizing the client.
-    QCOMPARE(Test::app()->workspace->moveResizeClient(), nullptr);
+    QCOMPARE(Test::app()->workspace->move_resize_window, nullptr);
     win::active_window_resize(*Test::app()->workspace);
-    QCOMPARE(Test::app()->workspace->moveResizeClient(), client);
+    QCOMPARE(Test::app()->workspace->move_resize_window, client);
     QCOMPARE(clientStartMoveResizedSpy.count(), 1);
     QVERIFY(configureRequestedSpy.wait());
     QCOMPARE(configureRequestedSpy.count(), 2);
@@ -1584,7 +1584,7 @@ void TestXdgShellClient::testXdgWindowGeometryInteractiveResize()
     // Finish resizing the client.
     win::key_press_event(client, Qt::Key_Enter);
     QCOMPARE(clientFinishUserMovedResizedSpy.count(), 1);
-    QCOMPARE(Test::app()->workspace->moveResizeClient(), nullptr);
+    QCOMPARE(Test::app()->workspace->move_resize_window, nullptr);
 #if 0
     QEXPECT_FAIL("", "XdgShellClient currently doesn't send final configure event", Abort);
     QVERIFY(configureRequestedSpy.wait());
diff --git a/input/filters/helpers.cpp b/input/filters/helpers.cpp
index 39b013138..4580909a5 100644
--- a/input/filters/helpers.cpp
+++ b/input/filters/helpers.cpp
@@ -33,7 +33,7 @@ bool get_modifier_command(uint32_t key, base::options::MouseCommand& command)
     if (kwinApp()->input->redirect->pointer()->isConstrained()) {
         return false;
     }
-    if (kwinApp()->input->redirect->space.globalShortcutsDisabled()) {
+    if (kwinApp()->input->redirect->space.global_shortcuts_disabled) {
         return false;
     }
     auto qt_key = button_to_qt_mouse_button(key);
@@ -94,7 +94,7 @@ bool get_wheel_modifier_command(axis_orientation orientation,
     if (kwinApp()->input->redirect->pointer()->isConstrained()) {
         return false;
     }
-    if (kwinApp()->input->redirect->space.globalShortcutsDisabled()) {
+    if (kwinApp()->input->redirect->space.global_shortcuts_disabled) {
         return false;
     }
 
diff --git a/input/filters/move_resize.cpp b/input/filters/move_resize.cpp
index 5a1ecc967..ef6795e5d 100644
--- a/input/filters/move_resize.cpp
+++ b/input/filters/move_resize.cpp
@@ -27,7 +27,7 @@ move_resize_filter::move_resize_filter(input::redirect& redirect)
 
 bool move_resize_filter::button([[maybe_unused]] button_event const& event)
 {
-    auto window = redirect.space.moveResizeClient();
+    auto window = redirect.space.move_resize_window;
     if (!window) {
         return false;
     }
@@ -39,7 +39,7 @@ bool move_resize_filter::button([[maybe_unused]] button_event const& event)
 
 bool move_resize_filter::motion([[maybe_unused]] motion_event const& event)
 {
-    auto window = redirect.space.moveResizeClient();
+    auto window = redirect.space.move_resize_window;
     if (!window) {
         return false;
     }
@@ -50,7 +50,7 @@ bool move_resize_filter::motion([[maybe_unused]] motion_event const& event)
 
 bool move_resize_filter::axis([[maybe_unused]] axis_event const& event)
 {
-    return redirect.space.moveResizeClient() != nullptr;
+    return redirect.space.move_resize_window != nullptr;
 }
 
 void process_key_press(Toplevel* window, key_event const& event)
@@ -69,7 +69,7 @@ void process_key_press(Toplevel* window, key_event const& event)
 
 bool move_resize_filter::key(key_event const& event)
 {
-    auto window = redirect.space.moveResizeClient();
+    auto window = redirect.space.move_resize_window;
     if (!window) {
         return false;
     }
@@ -82,7 +82,7 @@ bool move_resize_filter::key(key_event const& event)
 
 bool move_resize_filter::key_repeat(key_event const& event)
 {
-    auto window = redirect.space.moveResizeClient();
+    auto window = redirect.space.move_resize_window;
     if (!window) {
         return false;
     }
@@ -93,7 +93,7 @@ bool move_resize_filter::key_repeat(key_event const& event)
 
 bool move_resize_filter::touch_down(touch_down_event const& /*event*/)
 {
-    auto c = redirect.space.moveResizeClient();
+    auto c = redirect.space.move_resize_window;
     if (!c) {
         return false;
     }
@@ -103,7 +103,7 @@ bool move_resize_filter::touch_down(touch_down_event const& /*event*/)
 bool move_resize_filter::touch_motion(touch_motion_event const& event)
 {
     Q_UNUSED(time)
-    auto c = redirect.space.moveResizeClient();
+    auto c = redirect.space.move_resize_window;
     if (!c) {
         return false;
     }
@@ -119,7 +119,7 @@ bool move_resize_filter::touch_motion(touch_motion_event const& event)
 
 bool move_resize_filter::touch_up(touch_up_event const& event)
 {
-    auto c = redirect.space.moveResizeClient();
+    auto c = redirect.space.move_resize_window;
     if (!c) {
         return false;
     }
diff --git a/input/spies/modifier_only_shortcuts.cpp b/input/spies/modifier_only_shortcuts.cpp
index 366cc86ad..395bc458c 100644
--- a/input/spies/modifier_only_shortcuts.cpp
+++ b/input/spies/modifier_only_shortcuts.cpp
@@ -64,7 +64,7 @@ void modifier_only_shortcuts_spy::key(key_event const& event)
     } else if (!m_pressedKeys.isEmpty()) {
         m_pressedKeys.remove(event.keycode);
         if (m_pressedKeys.isEmpty() && mods == Qt::NoModifier
-            && !redirect.space.globalShortcutsDisabled()) {
+            && !redirect.space.global_shortcuts_disabled) {
             if (m_modifier != Qt::NoModifier) {
                 const auto list = kwinApp()->options->modifierOnlyDBusShortcut(m_modifier);
                 if (list.size() >= 4) {
diff --git a/input/wayland/cursor_image.cpp b/input/wayland/cursor_image.cpp
index 025affcfe..c73b75a69 100644
--- a/input/wayland/cursor_image.cpp
+++ b/input/wayland/cursor_image.cpp
@@ -213,7 +213,7 @@ void cursor_image::updateMoveResize()
 {
     m_moveResizeCursor.image = QImage();
     m_moveResizeCursor.hotSpot = QPoint();
-    if (auto window = platform.redirect->space.moveResizeClient()) {
+    if (auto window = platform.redirect->space.move_resize_window) {
         loadThemeCursor(window->control->move_resize().cursor, &m_moveResizeCursor);
         if (m_currentSource == CursorSource::MoveResize) {
             Q_EMIT changed();
@@ -488,7 +488,7 @@ void cursor_image::reevaluteSource()
         setSource(CursorSource::EffectsOverride);
         return;
     }
-    if (platform.redirect->space.moveResizeClient()) {
+    if (platform.redirect->space.move_resize_window) {
         setSource(CursorSource::MoveResize);
         return;
     }
diff --git a/input/wayland/pointer_redirect.cpp b/input/wayland/pointer_redirect.cpp
index fde01b2b5..1715377da 100644
--- a/input/wayland/pointer_redirect.cpp
+++ b/input/wayland/pointer_redirect.cpp
@@ -513,7 +513,7 @@ void pointer_redirect::focusUpdate(Toplevel* focusOld, Toplevel* focusNow)
               }
 
               // TODO: can we check on the client instead?
-              if (redirect->space.moveResizeClient()) {
+              if (redirect->space.move_resize_window) {
                   // don't update while moving
                   return;
               }
diff --git a/rules/window_rules.cpp b/rules/window_rules.cpp
index ea082eee4..3b2d9cf17 100644
--- a/rules/window_rules.cpp
+++ b/rules/window_rules.cpp
@@ -328,7 +328,8 @@ void Toplevel::applyWindowRules()
     // see also X11Client::setActive()
     if (control->active()) {
         setOpacity(control->rules().checkOpacityActive(qRound(opacity() * 100.0)) / 100.0);
-        space.disableGlobalShortcutsForClient(control->rules().checkDisableGlobalShortcuts(false));
+        win::set_global_shortcuts_disabled(space,
+                                           control->rules().checkDisableGlobalShortcuts(false));
     } else {
         setOpacity(control->rules().checkOpacityInactive(qRound(opacity() * 100.0)) / 100.0);
     }
diff --git a/win/activation.h b/win/activation.h
index 42f8d95cc..29db76578 100644
--- a/win/activation.h
+++ b/win/activation.h
@@ -8,6 +8,7 @@
 #include "actions.h"
 #include "desktop_set.h"
 #include "focus_chain_find.h"
+#include "input.h"
 #include "layers.h"
 #include "screen.h"
 #include "stacking.h"
@@ -432,10 +433,10 @@ void set_active_window(Space& space, Toplevel* window)
 
     x11::update_tool_windows_visibility(&space, false);
     if (window) {
-        space.disableGlobalShortcutsForClient(
-            window->control->rules().checkDisableGlobalShortcuts(false));
+        set_global_shortcuts_disabled(space,
+                                      window->control->rules().checkDisableGlobalShortcuts(false));
     } else {
-        space.disableGlobalShortcutsForClient(false);
+        set_global_shortcuts_disabled(space, false);
     }
 
     // e.g. fullscreens have different layer when active/not-active
@@ -544,7 +545,7 @@ bool activate_next_window(Space& space, Toplevel* window)
 
     int const desktop = space.virtual_desktop_manager->current();
 
-    if (!get_focus && space.showingDesktop()) {
+    if (!get_focus && space.showing_desktop) {
         // to not break the state
         get_focus = find_desktop(&space, true, desktop);
     }
@@ -608,7 +609,7 @@ void process_window_hidden(Space& space, Win* window)
 template<typename Space>
 Toplevel* find_window_to_activate_on_desktop(Space& space, unsigned int desktop)
 {
-    if (space.movingClient != nullptr && space.active_client == space.movingClient
+    if (space.move_resize_window && space.active_client == space.move_resize_window
         && focus_chain_at_desktop_contains(space.focus_chain, space.active_client, desktop)
         && space.active_client->isShown() && space.active_client->isOnCurrentDesktop()) {
         // A requestFocus call will fail, as the client is already active
@@ -862,7 +863,7 @@ void set_showing_desktop(Space& space, bool showing)
 template<typename Space>
 void toggle_show_desktop(Space& space)
 {
-    set_showing_desktop(space, !space.showingDesktop());
+    set_showing_desktop(space, !space.showing_desktop);
 }
 
 }
diff --git a/win/desktop_space.h b/win/desktop_space.h
index 32b379e72..f6a773b4b 100644
--- a/win/desktop_space.h
+++ b/win/desktop_space.h
@@ -69,7 +69,7 @@ void update_client_visibility_on_desktop_change(Space* space, uint newDesktop)
             continue;
         }
 
-        if (!client->isOnDesktop(newDesktop) && client != space->moveResizeClient()) {
+        if (!client->isOnDesktop(newDesktop) && client != space->move_resize_window) {
             update_visibility(client);
         }
     }
@@ -79,7 +79,7 @@ void update_client_visibility_on_desktop_change(Space* space, uint newDesktop)
         x11::rootInfo()->setCurrentDesktop(space->virtual_desktop_manager->current());
     }
 
-    if (auto move_resize_client = space->moveResizeClient()) {
+    if (auto move_resize_client = space->move_resize_window) {
         if (!move_resize_client->isOnDesktop(newDesktop)) {
             win::set_desktop(move_resize_client, newDesktop);
         }
@@ -96,7 +96,7 @@ void update_client_visibility_on_desktop_change(Space* space, uint newDesktop)
         }
     }
 
-    if (space->showingDesktop()) {
+    if (space->showing_desktop) {
         // Do this only after desktop change to avoid flicker.
         set_showing_desktop(*space, false);
     }
@@ -115,7 +115,7 @@ void handle_current_desktop_changed(Space& space, unsigned int oldDesktop, unsig
     --space.block_focus;
 
     activate_window_on_new_desktop(space, newDesktop);
-    Q_EMIT space.qobject->currentDesktopChanged(oldDesktop, space.movingClient);
+    Q_EMIT space.qobject->currentDesktopChanged(oldDesktop, space.move_resize_window);
 }
 
 template<typename Space>
diff --git a/win/input.h b/win/input.h
index 91b8531a7..58ded79de 100644
--- a/win/input.h
+++ b/win/input.h
@@ -20,6 +20,9 @@
 #include "base/options.h"
 #include "utils/blocker.h"
 
+#include <QDBusConnection>
+#include <QDBusMessage>
+#include <QDBusPendingCall>
 #include <QMouseEvent>
 #include <QStyleHints>
 
@@ -508,4 +511,28 @@ base::options::MouseCommand get_wheel_command(Win* win, Qt::Orientation orientat
     return base::options::MouseNothing;
 }
 
+template<typename Space>
+void set_global_shortcuts_disabled(Space& space, bool disable)
+{
+    if (space.global_shortcuts_disabled == disable) {
+        return;
+    }
+
+    QDBusMessage message = QDBusMessage::createMethodCall(QStringLiteral("org.kde.kglobalaccel"),
+                                                          QStringLiteral("/kglobalaccel"),
+                                                          QStringLiteral("org.kde.KGlobalAccel"),
+                                                          QStringLiteral("blockGlobalShortcuts"));
+    message.setArguments(QList<QVariant>() << disable);
+    QDBusConnection::sessionBus().asyncCall(message);
+
+    space.global_shortcuts_disabled = disable;
+
+    // Update also Meta+LMB actions etc.
+    for (auto window : space.windows) {
+        if (auto& ctrl = window->control) {
+            ctrl->update_mouse_grab();
+        }
+    }
+}
+
 }
diff --git a/win/layers.h b/win/layers.h
index 0148d38aa..d4da5c176 100644
--- a/win/layers.h
+++ b/win/layers.h
@@ -62,13 +62,13 @@ layer belong_to_layer(Win* win)
         return win::layer::unmanaged;
     }
     if (is_desktop(win)) {
-        return win->space.showingDesktop() ? win::layer::above : win::layer::desktop;
+        return win->space.showing_desktop ? win::layer::above : win::layer::desktop;
     }
     if (is_splash(win)) {
         return win::layer::normal;
     }
     if (is_dock(win)) {
-        if (win->space.showingDesktop()) {
+        if (win->space.showing_desktop) {
             return win::layer::notification;
         }
         return win->layer_for_dock();
@@ -82,7 +82,7 @@ layer belong_to_layer(Win* win)
     if (is_critical_notification(win)) {
         return win::layer::critical_notification;
     }
-    if (win->space.showingDesktop() && win->belongsToDesktop()) {
+    if (win->space.showing_desktop && win->belongsToDesktop()) {
         return win::layer::above;
     }
     if (win->control->keep_below()) {
diff --git a/win/move.h b/win/move.h
index b38179618..ff2fd5c0f 100644
--- a/win/move.h
+++ b/win/move.h
@@ -71,12 +71,12 @@ template<typename Space>
 void set_move_resize_window(Space& space, Toplevel* window)
 {
     // Catch attempts to move a second
-    assert(!window || !space.movingClient);
+    assert(!window || !space.move_resize_window);
 
     // window while still moving the first one.
-    space.movingClient = window;
+    space.move_resize_window = window;
 
-    if (space.movingClient) {
+    if (space.move_resize_window) {
         ++space.block_focus;
     } else {
         --space.block_focus;
diff --git a/win/screen_edges.cpp b/win/screen_edges.cpp
index ee9e19fa3..de8f157a2 100644
--- a/win/screen_edges.cpp
+++ b/win/screen_edges.cpp
@@ -152,7 +152,7 @@ bool screen_edge::activatesForPointer() const
         return true;
     }
     if (edger->desktop_switching.when_moving_client) {
-        auto c = edger->space.moveResizeClient();
+        auto c = edger->space.move_resize_window;
         if (c && !win::is_resize(c)) {
             return true;
         }
@@ -278,7 +278,7 @@ bool screen_edge::canActivate(QPoint const& cursorPos, QDateTime const& triggerT
 
 void screen_edge::handle(QPoint const& cursorPos)
 {
-    auto movingClient = edger->space.moveResizeClient();
+    auto movingClient = edger->space.move_resize_window;
 
     if ((edger->desktop_switching.when_moving_client && movingClient
          && !win::is_resize(movingClient))
@@ -319,7 +319,7 @@ bool screen_edge::handleAction(ElectricBorderAction action)
 {
     switch (action) {
     case ElectricActionShowDesktop: {
-        set_showing_desktop(edger->space, !edger->space.showingDesktop());
+        set_showing_desktop(edger->space, !edger->space.showing_desktop);
         return true;
     }
     case ElectricActionLockScreen: { // Lock the screen
@@ -412,7 +412,7 @@ void screen_edge::switchDesktop(QPoint const& cursorPos)
             pos.setY(OFFSET);
     }
 
-    if (auto c = edger->space.moveResizeClient()) {
+    if (auto c = edger->space.move_resize_window) {
         if (c->control->rules().checkDesktop(desktop) != int(desktop)) {
             // user attempts to move a client to another desktop where it is ruleforced to not be
             return;
diff --git a/win/space.cpp b/win/space.cpp
index 864ac054e..cd101d351 100644
--- a/win/space.cpp
+++ b/win/space.cpp
@@ -293,55 +293,11 @@ space::~space()
     singleton_interface::space = nullptr;
 }
 
-bool space::checkStartupNotification(xcb_window_t w, KStartupInfoId& id, KStartupInfoData& data)
-{
-    return startup->checkStartup(w, id, data) == KStartupInfo::Match;
-}
-
-void space::disableGlobalShortcutsForClient(bool disable)
-{
-    if (global_shortcuts_disabled_for_client == disable)
-        return;
-    QDBusMessage message = QDBusMessage::createMethodCall(QStringLiteral("org.kde.kglobalaccel"),
-                                                          QStringLiteral("/kglobalaccel"),
-                                                          QStringLiteral("org.kde.KGlobalAccel"),
-                                                          QStringLiteral("blockGlobalShortcuts"));
-    message.setArguments(QList<QVariant>() << disable);
-    QDBusConnection::sessionBus().asyncCall(message);
-
-    global_shortcuts_disabled_for_client = disable;
-    // Update also Meta+LMB actions etc.
-    for (auto window : windows) {
-        if (auto& ctrl = window->control) {
-            ctrl->update_mouse_grab();
-        }
-    }
-}
-
-void space::setWasUserInteraction()
-{
-    if (was_user_interaction) {
-        return;
-    }
-    was_user_interaction = true;
-    // might be called from within the filter, so delay till we now the filter returned
-    QTimer::singleShot(0, qobject.get(), [this] { m_wasUserInteractionFilter.reset(); });
-}
-
 win::screen_edge* space::create_screen_edge(win::screen_edger& edger)
 {
     return new win::screen_edge(&edger);
 }
 
-void space::updateTabbox()
-{
-#if KWIN_BUILD_TABBOX
-    if (tabbox->is_displayed()) {
-        tabbox->reset(true);
-    }
-#endif
-}
-
 QRect space::get_icon_geometry(Toplevel const* /*win*/) const
 {
     return QRect();
diff --git a/win/space.h b/win/space.h
index 57e0d533e..35c04c60e 100644
--- a/win/space.h
+++ b/win/space.h
@@ -217,7 +217,7 @@ public:
     QTimer reconfigureTimer;
     QTimer updateToolWindowsTimer;
 
-    Toplevel* movingClient{nullptr};
+    Toplevel* move_resize_window{nullptr};
 
     // Array of the previous restricted areas that window cannot be moved into
     std::vector<win::strut_rects> oldrestrictedmovearea;
@@ -235,8 +235,6 @@ public:
      */
     virtual Toplevel* findInternal(QWindow* w) const = 0;
 
-    bool initializing() const;
-
     /**
      * Most recently raised window.
      *
@@ -250,43 +248,12 @@ public:
     std::unique_ptr<base::dbus::kwin_impl<space>> dbus;
     std::unique_ptr<win::session_manager> session_manager;
 
-    void updateTabbox();
-
     QTimer* m_quickTileCombineTimer{nullptr};
     win::quicktiles m_lastTilingMode{win::quicktiles::none};
 
 public:
-    // True when performing space::updateClientArea().
-    // The calls below are valid only in that case.
-    bool inUpdateClientArea() const;
-
     Toplevel* active_client{nullptr};
 
-    bool showingDesktop() const;
-
-    bool checkStartupNotification(xcb_window_t w, KStartupInfoId& id, KStartupInfoData& data);
-
-    bool globalShortcutsDisabled() const;
-    void disableGlobalShortcutsForClient(bool disable);
-
-    void setWasUserInteraction();
-    bool wasUserInteraction() const;
-
-    /**
-     * Returns a client that is currently being moved or resized by the user.
-     *
-     * If none of clients is being moved or resized, @c null will be returned.
-     */
-    Toplevel* moveResizeClient()
-    {
-        return movingClient;
-    }
-
-    win::shortcut_dialog* shortcutDialog() const
-    {
-        return client_keys_dialog;
-    }
-
     virtual win::screen_edge* create_screen_edge(win::screen_edger& edger);
     virtual QRect get_icon_geometry(Toplevel const* win) const;
 
@@ -307,10 +274,8 @@ public:
     int session_active_client;
     int session_desktop;
 
-    void modalActionsSwitch(bool enabled);
-
     win::shortcut_dialog* client_keys_dialog{nullptr};
-    bool global_shortcuts_disabled_for_client{false};
+    bool global_shortcuts_disabled{false};
 
     // array of previous sizes of xinerama screens
     std::vector<QRect> oldscreensizes;
@@ -321,26 +286,8 @@ public:
     int set_active_client_recursion{0};
 
     std::unique_ptr<kill_window<space>> window_killer;
-
-private:
-    friend bool performTransiencyCheck();
 };
 
-inline bool space::wasUserInteraction() const
-{
-    return was_user_interaction;
-}
-
-inline bool space::showingDesktop() const
-{
-    return showing_desktop;
-}
-
-inline bool space::globalShortcutsDisabled() const
-{
-    return global_shortcuts_disabled_for_client;
-}
-
 }
 
 }
diff --git a/win/tabbox.h b/win/tabbox.h
new file mode 100644
index 000000000..a29af1d73
--- /dev/null
+++ b/win/tabbox.h
@@ -0,0 +1,23 @@
+/*
+    SPDX-FileCopyrightText: 2022 Roman Gilg <subdiff@gmail.com>
+
+    SPDX-License-Identifier: GPL-2.0-or-later
+*/
+#pragma once
+
+#include <config-kwin.h>
+
+namespace KWin::win
+{
+
+template<typename Space>
+void update_tabbox(Space& space)
+{
+#if KWIN_BUILD_TABBOX
+    if (space.tabbox->is_displayed()) {
+        space.tabbox->reset(true);
+    }
+#endif
+}
+
+}
diff --git a/win/tabbox/tabbox.cpp b/win/tabbox/tabbox.cpp
index 919e8e300..48eb4a345 100644
--- a/win/tabbox/tabbox.cpp
+++ b/win/tabbox/tabbox.cpp
@@ -1440,7 +1440,7 @@ void tabbox::accept(bool closeTabBox)
     if (c) {
         activate_window(space, c);
         if (win::is_desktop(c))
-            set_showing_desktop(space, !space.showingDesktop());
+            set_showing_desktop(space, !space.showing_desktop);
     }
 }
 
diff --git a/win/wayland/plasma_window.h b/win/wayland/plasma_window.h
index 9eee74982..34b576c27 100644
--- a/win/wayland/plasma_window.h
+++ b/win/wayland/plasma_window.h
@@ -35,7 +35,7 @@ void handle_change_showing_desktop(Space* space,
         assert(false);
         break;
     }
-    if (set == space->showingDesktop()) {
+    if (set == space->showing_desktop) {
         return;
     }
     set_showing_desktop(*space, set);
diff --git a/win/wayland/space.cpp b/win/wayland/space.cpp
index 8d796a51f..7532eaf85 100644
--- a/win/wayland/space.cpp
+++ b/win/wayland/space.cpp
@@ -26,6 +26,7 @@
 #include "win/screen.h"
 #include "win/setup.h"
 #include "win/stacking_order.h"
+#include "win/tabbox.h"
 #include "win/virtual_desktops.h"
 #include "win/x11/space_areas.h"
 #include "xwl/surface.h"
@@ -247,7 +248,7 @@ void space::handle_window_added(wayland::window* window)
             activate_window(*this, window);
         }
 
-        updateTabbox();
+        update_tabbox(*this);
 
         QObject::connect(window, &win::wayland::window::windowShown, qobject.get(), [this, window] {
             win::update_layer(window);
@@ -299,7 +300,7 @@ void space::handle_window_removed(wayland::window* window)
 
     if (window->control) {
         win::update_space_areas(*this);
-        updateTabbox();
+        update_tabbox(*this);
     }
 
     Q_EMIT qobject->wayland_window_removed(window);
diff --git a/win/x11/control.h b/win/x11/control.h
index 562d5de5f..2e1e2a2d7 100644
--- a/win/x11/control.h
+++ b/win/x11/control.h
@@ -14,6 +14,7 @@
 #include "focus_stealing.h"
 #include "placement.h"
 #include "session.h"
+#include "startup_info.h"
 #include "user_time.h"
 #include "window_create.h"
 #include "xcb.h"
@@ -101,7 +102,7 @@ public:
         // client will receive funky EnterNotify and LeaveNotify events, but there is nothing that
         // we can do about it, unfortunately.
 
-        if (!m_window->space.globalShortcutsDisabled()) {
+        if (!m_window->space.global_shortcuts_disabled) {
             if (kwinApp()->options->commandAll1() != base::options::MouseNothing) {
                 establish_command_all_grab(m_window, XCB_BUTTON_INDEX_1);
             }
@@ -438,7 +439,7 @@ auto create_controlled_window(xcb_window_t xcb_win, bool isMapped, Space& space)
 
     KStartupInfoId asn_id;
     KStartupInfoData asn_data;
-    auto asn_valid = space.checkStartupNotification(win->xcb_window, asn_id, asn_data);
+    auto asn_valid = check_startup_notification(space, win->xcb_window, asn_id, asn_data);
 
     // Make sure that the input window is created before we update the stacking order
     // TODO(romangg): Does it matter that the frame geometry is not set yet here?
@@ -694,7 +695,7 @@ auto create_controlled_window(xcb_window_t xcb_win, bool isMapped, Space& space)
         bool allow;
         if (session) {
             allow = session->active
-                && (!space.wasUserInteraction() || !space.active_client
+                && (!space.was_user_interaction || !space.active_client
                     || is_desktop(space.active_client));
         } else {
             allow = allow_window_activation(space, win, win->userTime(), false);
diff --git a/win/x11/event.h b/win/x11/event.h
index 107810b4e..ce7bc7a62 100644
--- a/win/x11/event.h
+++ b/win/x11/event.h
@@ -129,7 +129,7 @@ bool window_event(Win* win, xcb_generic_event_t* e)
         // info->userTime() is the value of the property, userTime() also includes
         // updates of the time done by KWin (ButtonPress on windowrapper etc.).
         if ((dirtyProperties2 & NET::WM2UserTime) != 0) {
-            win->space.setWasUserInteraction();
+            mark_as_user_interaction(win->space);
             update_user_time(win, win->info->userTime());
         }
         if ((dirtyProperties2 & NET::WM2StartupId) != 0) {
diff --git a/win/x11/group.cpp b/win/x11/group.cpp
index 7d71d8901..bc822d3cb 100644
--- a/win/x11/group.cpp
+++ b/win/x11/group.cpp
@@ -20,6 +20,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *********************************************************************/
 #include "group.h"
 
+#include "startup_info.h"
 #include "window.h"
 #include "window_find.h"
 
@@ -140,9 +141,11 @@ void group::startupIdChanged()
 {
     KStartupInfoId asn_id;
     KStartupInfoData asn_data;
-    bool asn_valid = space.checkStartupNotification(xcb_leader, asn_id, asn_data);
-    if (!asn_valid)
+    auto asn_valid = check_startup_notification(space, xcb_leader, asn_id, asn_data);
+    if (!asn_valid) {
         return;
+    }
+
     if (asn_id.timestamp() != 0 && user_time != -1U
         && NET::timestampCompare(asn_id.timestamp(), user_time) > 0) {
         user_time = asn_id.timestamp();
diff --git a/win/x11/input.h b/win/x11/input.h
index 75c01b6b7..0c864baf8 100644
--- a/win/x11/input.h
+++ b/win/x11/input.h
@@ -87,4 +87,17 @@ bool perform_mouse_command(Win* win, base::options::MouseCommand command, QPoint
     return static_cast<Toplevel*>(win)->Toplevel::performMouseCommand(command, globalPos);
 }
 
+template<typename Space>
+void mark_as_user_interaction(Space& space)
+{
+    if (space.was_user_interaction) {
+        return;
+    }
+
+    space.was_user_interaction = true;
+
+    // might be called from within the filter, so delay till we now the filter returned
+    QTimer::singleShot(0, space.qobject.get(), [&] { space.m_wasUserInteractionFilter.reset(); });
+}
+
 }
diff --git a/win/x11/moving_window_filter.h b/win/x11/moving_window_filter.h
index 63d5b83eb..b693e4b45 100644
--- a/win/x11/moving_window_filter.h
+++ b/win/x11/moving_window_filter.h
@@ -30,7 +30,7 @@ public:
 
     bool event(xcb_generic_event_t* event) override
     {
-        auto mr_win = dynamic_cast<window*>(space.moveResizeClient());
+        auto mr_win = dynamic_cast<window*>(space.move_resize_window);
         if (!mr_win) {
             return false;
         }
diff --git a/win/x11/space_setup.h b/win/x11/space_setup.h
index 315a7b630..858a271d4 100644
--- a/win/x11/space_setup.h
+++ b/win/x11/space_setup.h
@@ -65,7 +65,7 @@ void init_space(Space& space)
 
     if (kwinApp()->operationMode() == Application::OperationModeX11) {
         space.m_wasUserInteractionFilter.reset(
-            new base::x11::user_interaction_filter([&space] { space.setWasUserInteraction(); }));
+            new base::x11::user_interaction_filter([&space] { mark_as_user_interaction(space); }));
         space.m_movingClientFilter.reset(new moving_window_filter(space));
     }
     if (base::x11::xcb::extensions::self()->is_sync_available()) {
diff --git a/win/x11/startup_info.h b/win/x11/startup_info.h
index 8b3b7e084..a6ffe6498 100644
--- a/win/x11/startup_info.h
+++ b/win/x11/startup_info.h
@@ -16,14 +16,25 @@
 namespace KWin::win::x11
 {
 
+template<typename Space>
+bool check_startup_notification(Space& space,
+                                xcb_window_t w,
+                                KStartupInfoId& id,
+                                KStartupInfoData& data)
+{
+    return space.startup->checkStartup(w, id, data) == KStartupInfo::Match;
+}
+
 template<typename Win>
 void startup_id_changed(Win* win)
 {
     KStartupInfoId asn_id;
     KStartupInfoData asn_data;
-    bool asn_valid = win->space.checkStartupNotification(win->xcb_window, asn_id, asn_data);
-    if (!asn_valid)
+    auto asn_valid = check_startup_notification(win->space, win->xcb_window, asn_id, asn_data);
+    if (!asn_valid) {
         return;
+    }
+
     // If the ASN contains desktop, move it to the desktop, otherwise move it to the current
     // desktop (since the new ASN should make the window act like if it's a new application
     // launched). However don't affect the window's desktop if it's set to be on all desktops.
diff --git a/win/x11/window_create.h b/win/x11/window_create.h
index 5f7c6ff19..506bf6261 100644
--- a/win/x11/window_create.h
+++ b/win/x11/window_create.h
@@ -9,6 +9,7 @@
 #include "transient.h"
 
 #include "win/space_areas_helpers.h"
+#include "win/tabbox.h"
 
 namespace KWin::win::x11
 {
@@ -68,7 +69,7 @@ void add_controlled_window_to_space(Space& space, Win* win)
         update_tool_windows_visibility(&space, true);
     }
 
-    space.updateTabbox();
+    update_tabbox(space);
 }
 
 }
diff --git a/win/x11/window_release.h b/win/x11/window_release.h
index a49d3fc35..5dc315566 100644
--- a/win/x11/window_release.h
+++ b/win/x11/window_release.h
@@ -12,6 +12,7 @@
 #include "win/rules.h"
 #include "win/shortcut_set.h"
 #include "win/space_areas_helpers.h"
+#include "win/tabbox.h"
 #include "win/window_release.h"
 
 #if KWIN_BUILD_TABBOX
@@ -73,7 +74,7 @@ void remove_controlled_window_from_space(Space& space, Win* win)
 
     space.stacking_order->update_count();
     update_space_areas(space);
-    space.updateTabbox();
+    update_tabbox(space);
 }
 
 template<typename Win>
-- 
GitLab


From d9e4ef1a9d2238c000d04b913af9cb2b81ea7100 Mon Sep 17 00:00:00 2001
From: Roman Gilg <subdiff@gmail.com>
Date: Tue, 12 Jul 2022 22:55:03 +0200
Subject: [PATCH 38/51] refactor: implement space ctor and dtor logic in free
 function templates

This way it can be reused by different types of spaces.
---
 win/space.cpp     | 175 +-------------------------------------
 win/space_setup.h | 212 ++++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 215 insertions(+), 172 deletions(-)
 create mode 100644 win/space_setup.h

diff --git a/win/space.cpp b/win/space.cpp
index cd101d351..e1e99d498 100644
--- a/win/space.cpp
+++ b/win/space.cpp
@@ -29,6 +29,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "session.h"
 #include "singleton_interface.h"
 #include "space_areas_helpers.h"
+#include "space_setup.h"
 #include "window_area.h"
 #include "x11/tool_windows.h"
 
@@ -115,182 +116,12 @@ space::space(render::compositor& render)
     , dbus{std::make_unique<base::dbus::kwin_impl<space>>(*this)}
     , session_manager{std::make_unique<win::session_manager>()}
 {
-    // For invoke methods of user_actions_menu.
-    qRegisterMetaType<Toplevel*>();
-
-    singleton_interface::space = this;
-
-    m_quickTileCombineTimer = new QTimer(qobject.get());
-    m_quickTileCombineTimer->setSingleShot(true);
-
-    init_rule_book(*rule_book, *this);
-
-    // dbus interface
-    new win::dbus::virtual_desktop_manager(virtual_desktop_manager.get());
-
-#if KWIN_BUILD_TABBOX
-    // need to create the tabbox before compositing scene is setup
-    tabbox = std::make_unique<win::tabbox>(*this);
-#endif
-
-    QObject::connect(qobject.get(),
-                     &space_qobject::currentDesktopChanged,
-                     &render,
-                     &render::compositor::addRepaintFull);
-
-    deco->init();
-    QObject::connect(qobject.get(), &space_qobject::configChanged, deco->qobject.get(), [this] {
-        deco->reconfigure();
-    });
-
-    QObject::connect(session_manager.get(),
-                     &win::session_manager::loadSessionRequested,
-                     qobject.get(),
-                     [this](auto&& session_name) { load_session_info(*this, session_name); });
-    QObject::connect(
-        session_manager.get(),
-        &win::session_manager::prepareSessionSaveRequested,
-        qobject.get(),
-        [this](const QString& name) { store_session(*this, name, win::sm_save_phase0); });
-    QObject::connect(
-        session_manager.get(),
-        &win::session_manager::finishSessionSaveRequested,
-        qobject.get(),
-        [this](const QString& name) { store_session(*this, name, win::sm_save_phase2); });
-
-    auto& base = kwinApp()->get_base();
-    QObject::connect(
-        &base, &base::platform::topology_changed, qobject.get(), [this](auto old, auto topo) {
-            if (old.size != topo.size) {
-                handle_desktop_resize(*this);
-            }
-        });
-
-    QObject::connect(qobject.get(), &qobject_t::clientRemoved, qobject.get(), [this](auto window) {
-        focus_chain_remove(focus_chain, window);
-    });
-    QObject::connect(qobject.get(),
-                     &qobject_t::clientActivated,
-                     qobject.get(),
-                     [this](auto window) { focus_chain.active_window = window; });
-    QObject::connect(virtual_desktop_manager.get(),
-                     &win::virtual_desktop_manager::countChanged,
-                     qobject.get(),
-                     [this](auto prev, auto next) { focus_chain_resize(focus_chain, prev, next); });
-    QObject::connect(virtual_desktop_manager.get(),
-                     &win::virtual_desktop_manager::currentChanged,
-                     qobject.get(),
-                     [this](auto /*prev*/, auto next) { focus_chain.current_desktop = next; });
-    QObject::connect(kwinApp()->options.get(),
-                     &base::options::separateScreenFocusChanged,
-                     qobject.get(),
-                     [this](auto enable) { focus_chain.has_separate_screen_focus = enable; });
-    focus_chain.has_separate_screen_focus = kwinApp()->options->isSeparateScreenFocus();
-
-    auto vds = virtual_desktop_manager.get();
-    QObject::connect(
-        vds,
-        &win::virtual_desktop_manager::countChanged,
-        qobject.get(),
-        [this](auto prev, auto next) { handle_desktop_count_changed(*this, prev, next); });
-    QObject::connect(
-        vds,
-        &win::virtual_desktop_manager::currentChanged,
-        qobject.get(),
-        [this](auto prev, auto next) { handle_current_desktop_changed(*this, prev, next); });
-    vds->setNavigationWrappingAround(kwinApp()->options->isRollOverDesktops());
-    QObject::connect(kwinApp()->options.get(),
-                     &base::options::rollOverDesktopsChanged,
-                     vds,
-                     &win::virtual_desktop_manager::setNavigationWrappingAround);
-
-    auto config = kwinApp()->config();
-    vds->setConfig(config);
-
-    // positioning object needs to be created before the virtual desktops are loaded.
-    vds->load();
-    vds->updateLayout();
-
-    // makes sure any autogenerated id is saved, necessary as in case of xwayland, load will be
-    // called 2 times
-    // load is needed to be called again when starting xwayalnd to sync to RootInfo, see BUG 385260
-    vds->save();
-
-    if (!vds->setCurrent(m_initialDesktop)) {
-        vds->setCurrent(1);
-    }
-
-    reconfigureTimer.setSingleShot(true);
-    updateToolWindowsTimer.setSingleShot(true);
-
-    QObject::connect(
-        &reconfigureTimer, &QTimer::timeout, qobject.get(), [this] { space_reconfigure(*this); });
-    QObject::connect(&updateToolWindowsTimer, &QTimer::timeout, qobject.get(), [this] {
-        x11::update_tool_windows_visibility(this, true);
-    });
-
-    // TODO: do we really need to reconfigure everything when fonts change?
-    // maybe just reconfigure the decorations? Move this into libkdecoration?
-    QDBusConnection::sessionBus().connect(QString(),
-                                          QStringLiteral("/KDEPlatformTheme"),
-                                          QStringLiteral("org.kde.KDEPlatformTheme"),
-                                          QStringLiteral("refreshFonts"),
-                                          qobject.get(),
-                                          SLOT(reconfigure()));
-
-    active_client = nullptr;
-    QObject::connect(
-        stacking_order.get(), &stacking_order::changed, qobject.get(), [this](auto count_changed) {
-            x11::propagate_clients(*this, count_changed);
-            if (active_client) {
-                active_client->control->update_mouse_grab();
-            }
-        });
-    QObject::connect(stacking_order.get(), &stacking_order::render_restack, qobject.get(), [this] {
-        x11::render_stack_unmanaged_windows(*this);
-    });
+    init_space(*this);
 }
 
 space::~space()
 {
-    stacking_order->lock();
-
-    // TODO: grabXServer();
-
-    win::x11::clear_space(*this);
-
-    for (auto const& window : windows) {
-        if (auto internal = qobject_cast<win::internal_window*>(window);
-            internal && !internal->remnant) {
-            internal->destroyClient();
-            remove_all(windows, internal);
-        }
-    }
-
-    // At this point only remnants are remaining.
-    for (auto it = windows.begin(); it != windows.end();) {
-        assert((*it)->remnant);
-        Q_EMIT qobject->window_deleted(*it);
-        it = windows.erase(it);
-    }
-
-    assert(windows.empty());
-
-    stacking_order.reset();
-
-    rule_book.reset();
-    kwinApp()->config()->sync();
-
-    win::x11::root_info::destroy();
-    delete startup;
-    delete client_keys_dialog;
-    for (auto const& s : session)
-        delete s;
-
-    // TODO: ungrabXServer();
-
-    base::x11::xcb::extensions::destroy();
-    singleton_interface::space = nullptr;
+    clear_space(*this);
 }
 
 win::screen_edge* space::create_screen_edge(win::screen_edger& edger)
diff --git a/win/space_setup.h b/win/space_setup.h
new file mode 100644
index 000000000..88341e976
--- /dev/null
+++ b/win/space_setup.h
@@ -0,0 +1,212 @@
+/*
+    SPDX-FileCopyrightText: 2022 Roman Gilg <subdiff@gmail.com>
+
+    SPDX-License-Identifier: GPL-2.0-or-later
+*/
+#pragma once
+
+#include <config-kwin.h>
+
+#include "dbus/virtual_desktop_manager.h"
+#include "rules.h"
+#include "singleton_interface.h"
+#include "space.h"
+#include "x11/space_setup.h"
+#include "x11/stacking.h"
+
+#include "base/platform.h"
+#include "toplevel.h"
+
+#include <QObject>
+
+namespace KWin::win
+{
+
+template<typename Space>
+void init_space(Space& space)
+{
+    // For invoke methods of user_actions_menu.
+    qRegisterMetaType<Toplevel*>();
+
+    singleton_interface::space = &space;
+
+    space.m_quickTileCombineTimer = new QTimer(space.qobject.get());
+    space.m_quickTileCombineTimer->setSingleShot(true);
+
+    init_rule_book(*space.rule_book, space);
+
+    // dbus interface
+    new dbus::virtual_desktop_manager(space.virtual_desktop_manager.get());
+
+#if KWIN_BUILD_TABBOX
+    // need to create the tabbox before compositing scene is setup
+    space.tabbox = std::make_unique<win::tabbox>(space);
+#endif
+
+    QObject::connect(space.qobject.get(),
+                     &space_qobject::currentDesktopChanged,
+                     &space.render,
+                     &render::compositor::addRepaintFull);
+
+    space.deco->init();
+    QObject::connect(space.qobject.get(),
+                     &space_qobject::configChanged,
+                     space.deco->qobject.get(),
+                     [&] { space.deco->reconfigure(); });
+
+    QObject::connect(space.session_manager.get(),
+                     &session_manager::loadSessionRequested,
+                     space.qobject.get(),
+                     [&](auto&& session_name) { load_session_info(space, session_name); });
+    QObject::connect(space.session_manager.get(),
+                     &session_manager::prepareSessionSaveRequested,
+                     space.qobject.get(),
+                     [&](auto const& name) { store_session(space, name, sm_save_phase0); });
+    QObject::connect(space.session_manager.get(),
+                     &session_manager::finishSessionSaveRequested,
+                     space.qobject.get(),
+                     [&](auto const& name) { store_session(space, name, sm_save_phase2); });
+
+    auto& base = kwinApp()->get_base();
+    QObject::connect(
+        &base, &base::platform::topology_changed, space.qobject.get(), [&](auto old, auto topo) {
+            if (old.size != topo.size) {
+                handle_desktop_resize(space);
+            }
+        });
+
+    QObject::connect(space.qobject.get(),
+                     &Space::qobject_t::clientRemoved,
+                     space.qobject.get(),
+                     [&](auto window) { focus_chain_remove(space.focus_chain, window); });
+    QObject::connect(space.qobject.get(),
+                     &Space::qobject_t::clientActivated,
+                     space.qobject.get(),
+                     [&](auto window) { space.focus_chain.active_window = window; });
+    QObject::connect(
+        space.virtual_desktop_manager.get(),
+        &virtual_desktop_manager::countChanged,
+        space.qobject.get(),
+        [&](auto prev, auto next) { focus_chain_resize(space.focus_chain, prev, next); });
+    QObject::connect(space.virtual_desktop_manager.get(),
+                     &win::virtual_desktop_manager::currentChanged,
+                     space.qobject.get(),
+                     [&](auto /*prev*/, auto next) { space.focus_chain.current_desktop = next; });
+    QObject::connect(kwinApp()->options.get(),
+                     &base::options::separateScreenFocusChanged,
+                     space.qobject.get(),
+                     [&](auto enable) { space.focus_chain.has_separate_screen_focus = enable; });
+    space.focus_chain.has_separate_screen_focus = kwinApp()->options->isSeparateScreenFocus();
+
+    auto vds = space.virtual_desktop_manager.get();
+    QObject::connect(
+        vds,
+        &win::virtual_desktop_manager::countChanged,
+        space.qobject.get(),
+        [&](auto prev, auto next) { handle_desktop_count_changed(space, prev, next); });
+    QObject::connect(
+        vds,
+        &win::virtual_desktop_manager::currentChanged,
+        space.qobject.get(),
+        [&](auto prev, auto next) { handle_current_desktop_changed(space, prev, next); });
+    vds->setNavigationWrappingAround(kwinApp()->options->isRollOverDesktops());
+    QObject::connect(kwinApp()->options.get(),
+                     &base::options::rollOverDesktopsChanged,
+                     vds,
+                     &win::virtual_desktop_manager::setNavigationWrappingAround);
+
+    auto config = kwinApp()->config();
+    vds->setConfig(config);
+
+    // positioning object needs to be created before the virtual desktops are loaded.
+    vds->load();
+    vds->updateLayout();
+
+    // makes sure any autogenerated id is saved, necessary as in case of xwayland, load will be
+    // called 2 times
+    // load is needed to be called again when starting xwayalnd to sync to RootInfo, see BUG 385260
+    vds->save();
+
+    if (!vds->setCurrent(space.m_initialDesktop)) {
+        vds->setCurrent(1);
+    }
+
+    space.reconfigureTimer.setSingleShot(true);
+    space.updateToolWindowsTimer.setSingleShot(true);
+
+    QObject::connect(&space.reconfigureTimer, &QTimer::timeout, space.qobject.get(), [&] {
+        space_reconfigure(space);
+    });
+    QObject::connect(&space.updateToolWindowsTimer, &QTimer::timeout, space.qobject.get(), [&] {
+        x11::update_tool_windows_visibility(&space, true);
+    });
+
+    // TODO: do we really need to reconfigure everything when fonts change?
+    // maybe just reconfigure the decorations? Move this into libkdecoration?
+    QDBusConnection::sessionBus().connect(QString(),
+                                          QStringLiteral("/KDEPlatformTheme"),
+                                          QStringLiteral("org.kde.KDEPlatformTheme"),
+                                          QStringLiteral("refreshFonts"),
+                                          space.qobject.get(),
+                                          SLOT(reconfigure()));
+
+    space.active_client = nullptr;
+    QObject::connect(space.stacking_order.get(),
+                     &stacking_order::changed,
+                     space.qobject.get(),
+                     [&](auto count_changed) {
+                         x11::propagate_clients(space, count_changed);
+                         if (space.active_client) {
+                             space.active_client->control->update_mouse_grab();
+                         }
+                     });
+    QObject::connect(space.stacking_order.get(),
+                     &stacking_order::render_restack,
+                     space.qobject.get(),
+                     [&] { x11::render_stack_unmanaged_windows(space); });
+}
+
+template<typename Space>
+void clear_space(Space& space)
+{
+    space.stacking_order->lock();
+
+    // TODO: grabXServer();
+
+    x11::clear_space(space);
+
+    for (auto const& window : space.windows) {
+        if (auto internal = qobject_cast<internal_window*>(window);
+            internal && !internal->remnant) {
+            internal->destroyClient();
+            remove_all(space.windows, internal);
+        }
+    }
+
+    // At this point only remnants are remaining.
+    for (auto it = space.windows.begin(); it != space.windows.end();) {
+        assert((*it)->remnant);
+        Q_EMIT space.qobject->window_deleted(*it);
+        it = space.windows.erase(it);
+    }
+
+    assert(space.windows.empty());
+
+    space.stacking_order.reset();
+
+    space.rule_book.reset();
+    kwinApp()->config()->sync();
+
+    x11::root_info::destroy();
+    delete space.startup;
+    delete space.client_keys_dialog;
+    for (auto const& s : space.session)
+        delete s;
+
+    // TODO: ungrabXServer();
+
+    base::x11::xcb::extensions::destroy();
+    singleton_interface::space = nullptr;
+}
+
+}
-- 
GitLab


From bcaee109db8e4bb0cf2c0bf131a8115e91c78b91 Mon Sep 17 00:00:00 2001
From: Roman Gilg <subdiff@gmail.com>
Date: Wed, 13 Jul 2022 01:12:43 +0200
Subject: [PATCH 39/51] fix: remove unneeded space references

Some space includes are not necessary anymore due to the usage of templates.
Also in some cases the space was not templated albeit it can.
---
 base/dbus/kwin.h          | 2 +-
 win/deco/bridge.h         | 1 -
 win/placement.h           | 4 ++--
 win/wayland/space_areas.h | 1 -
 win/x11/event.h           | 1 -
 5 files changed, 3 insertions(+), 6 deletions(-)

diff --git a/base/dbus/kwin.h b/base/dbus/kwin.h
index 3ec25a651..d598abd93 100644
--- a/base/dbus/kwin.h
+++ b/base/dbus/kwin.h
@@ -126,7 +126,7 @@ template<typename Space>
 class kwin_impl : public kwin
 {
 public:
-    explicit kwin_impl(win::space& space)
+    explicit kwin_impl(Space& space)
         : kwin(*space.qobject)
         , space{space}
     {
diff --git a/win/deco/bridge.h b/win/deco/bridge.h
index 5bdb48c21..018c4656b 100644
--- a/win/deco/bridge.h
+++ b/win/deco/bridge.h
@@ -33,7 +33,6 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "toplevel.h"
 #include "win/control.h"
 #include "win/deco.h"
-#include "win/space.h"
 
 #include <kwineffects/effect_plugin_factory.h>
 
diff --git a/win/placement.h b/win/placement.h
index c77f2e7f9..e8dd77e93 100644
--- a/win/placement.h
+++ b/win/placement.h
@@ -33,7 +33,6 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "meta.h"
 #include "move.h"
 #include "net.h"
-#include "space.h"
 #include "stacking_order.h"
 #include "transient.h"
 #include "window_area.h"
@@ -559,7 +558,8 @@ void place_maximizing(Win* window, const QRect& area, placement nextPlacement)
 /**
  * Unclutters the current desktop by smart-placing all windows again.
  */
-inline void unclutter_desktop(win::space& space)
+template<typename Space>
+void unclutter_desktop(Space& space)
 {
     auto const& windows = space.windows;
     for (int i = windows.size() - 1; i >= 0; i--) {
diff --git a/win/wayland/space_areas.h b/win/wayland/space_areas.h
index 5aaf82481..5a178fdcd 100644
--- a/win/wayland/space_areas.h
+++ b/win/wayland/space_areas.h
@@ -8,7 +8,6 @@
 #include "base/output_helpers.h"
 #include "base/platform.h"
 #include "main.h"
-#include "win/space.h"
 #include "win/space_areas.h"
 #include "win/virtual_desktops.h"
 
diff --git a/win/x11/event.h b/win/x11/event.h
index ce7bc7a62..f87e36c72 100644
--- a/win/x11/event.h
+++ b/win/x11/event.h
@@ -22,7 +22,6 @@
 #include "win/desktop_space.h"
 #include "win/input.h"
 #include "win/meta.h"
-#include "win/space.h"
 
 #include <kkeyserver.h>
 
-- 
GitLab


From 04b1e6d850ce7a02d70cd5f061b9d59f5316badb Mon Sep 17 00:00:00 2001
From: Roman Gilg <subdiff@gmail.com>
Date: Thu, 14 Jul 2022 00:03:59 +0200
Subject: [PATCH 40/51] refactor: remove desktop integration getter and setter

Instead make the variable public. Rename it too.
---
 win/control.cpp              | 18 ++++--------------
 win/control.h                |  7 ++-----
 win/desktop_set.h            |  2 +-
 win/wayland/setup.h          |  8 ++++----
 win/wayland/space.cpp        |  2 +-
 win/wayland/window.cpp       |  2 +-
 win/wayland/window_release.h |  2 +-
 win/wayland/xdg_activation.h |  2 +-
 win/x11/window_release.h     |  4 ++--
 9 files changed, 17 insertions(+), 30 deletions(-)

diff --git a/win/control.cpp b/win/control.cpp
index a6e7b9971..5e8bdcd99 100644
--- a/win/control.cpp
+++ b/win/control.cpp
@@ -264,21 +264,11 @@ void control::update_mouse_grab()
 {
 }
 
-Wrapland::Server::PlasmaWindow* control::wayland_management() const
+void control::destroy_plasma_wayland_integration()
 {
-    return m_wayland_management;
-}
-
-void control::set_wayland_management(Wrapland::Server::PlasmaWindow* plasma_window)
-{
-    m_wayland_management = plasma_window;
-}
-
-void control::destroy_wayland_management()
-{
-    if (m_wayland_management) {
-        m_wayland_management->unmap();
-        m_wayland_management = nullptr;
+    if (plasma_wayland_integration) {
+        plasma_wayland_integration->unmap();
+        plasma_wayland_integration = nullptr;
     }
 }
 
diff --git a/win/control.h b/win/control.h
index e250df6ea..612fe9189 100644
--- a/win/control.h
+++ b/win/control.h
@@ -109,9 +109,7 @@ public:
 
     virtual void update_mouse_grab();
 
-    Wrapland::Server::PlasmaWindow* wayland_management() const;
-    void set_wayland_management(Wrapland::Server::PlasmaWindow* plasma_window);
-    void destroy_wayland_management();
+    void destroy_plasma_wayland_integration();
 
     bool have_resize_effect() const;
     void update_have_resize_effect();
@@ -150,6 +148,7 @@ public:
     void discard_temporary_rules();
 
     std::unique_ptr<scripting::window> scripting;
+    Wrapland::Server::PlasmaWindow* plasma_wayland_integration{nullptr};
 
 private:
     void minimize(bool avoid_animation);
@@ -178,8 +177,6 @@ private:
     QTimer* m_auto_raise_timer{nullptr};
     bool m_minimized{false};
 
-    Wrapland::Server::PlasmaWindow* m_wayland_management{nullptr};
-
     bool m_have_resize_effect{false};
 
     quicktiles m_quicktiling{quicktiles::none};
diff --git a/win/desktop_set.h b/win/desktop_set.h
index dada74aeb..9fa15a993 100644
--- a/win/desktop_set.h
+++ b/win/desktop_set.h
@@ -37,7 +37,7 @@ void set_desktops(Win* win, QVector<virtual_desktop*> desktops)
 
     win->set_desktops(desktops);
 
-    if (auto management = win->control->wayland_management()) {
+    if (auto management = win->control->plasma_wayland_integration) {
         if (desktops.isEmpty()) {
             management->setOnAllDesktops(true);
         } else {
diff --git a/win/wayland/setup.h b/win/wayland/setup.h
index 5c958e4d2..8f630e83e 100644
--- a/win/wayland/setup.h
+++ b/win/wayland/setup.h
@@ -22,7 +22,7 @@ namespace KWin::win::wayland
 template<typename Space, typename Win>
 void setup_plasma_management(Space* space, Win* win)
 {
-    if (win->control->wayland_management()) {
+    if (win->control->plasma_wayland_integration) {
         // Already setup.
         return;
     }
@@ -63,7 +63,7 @@ void setup_plasma_management(Space* space, Win* win)
     plasma_win->setVirtualDesktopChangeable(true);
 
     auto transient_lead = win->transient()->lead();
-    plasma_win->setParentWindow(transient_lead ? transient_lead->control->wayland_management()
+    plasma_win->setParentWindow(transient_lead ? transient_lead->control->plasma_wayland_integration
                                                : nullptr);
     plasma_win->setGeometry(win->frameGeometry());
     QObject::connect(win, &Win::skipTaskbarChanged, plasma_win, [plasma_win, win] {
@@ -110,7 +110,7 @@ void setup_plasma_management(Space* space, Win* win)
             // When lead becomes remnant.
             lead = nullptr;
         }
-        plasma_win->setParentWindow(lead ? lead->control->wayland_management() : nullptr);
+        plasma_win->setParentWindow(lead ? lead->control->plasma_wayland_integration : nullptr);
     });
     QObject::connect(win, &Win::applicationMenuChanged, plasma_win, [plasma_win, win] {
         auto const appmenu = win->control->application_menu();
@@ -212,7 +212,7 @@ void setup_plasma_management(Space* space, Win* win)
                          }
                      });
 
-    win->control->set_wayland_management(plasma_win);
+    win->control->plasma_wayland_integration = plasma_win;
 }
 
 }
diff --git a/win/wayland/space.cpp b/win/wayland/space.cpp
index 7532eaf85..c4f78705a 100644
--- a/win/wayland/space.cpp
+++ b/win/wayland/space.cpp
@@ -357,7 +357,7 @@ Toplevel* space::findInternal(QWindow* window) const
 
 QRect space::get_icon_geometry(Toplevel const* win) const
 {
-    auto management = win->control->wayland_management();
+    auto management = win->control->plasma_wayland_integration;
     if (!management || !waylandServer()) {
         // window management interface is only available if the surface is mapped
         return QRect();
diff --git a/win/wayland/window.cpp b/win/wayland/window.cpp
index 47bc8b7a5..1982b2d55 100644
--- a/win/wayland/window.cpp
+++ b/win/wayland/window.cpp
@@ -927,7 +927,7 @@ void window::unmap()
         if (control->move_resize().enabled) {
             leaveMoveResize();
         }
-        control->destroy_wayland_management();
+        control->destroy_plasma_wayland_integration();
     }
 
     space.render.addRepaint(visible_rect(this));
diff --git a/win/wayland/window_release.h b/win/wayland/window_release.h
index 9fd093167..a35ad1f68 100644
--- a/win/wayland/window_release.h
+++ b/win/wayland/window_release.h
@@ -57,7 +57,7 @@ void destroy_window(Win* win)
 
         win->space.rule_book->discardUsed(win, true);
 
-        win->control->destroy_wayland_management();
+        win->control->destroy_plasma_wayland_integration();
         win->control->destroy_decoration();
     }
 
diff --git a/win/wayland/xdg_activation.h b/win/wayland/xdg_activation.h
index 8579727f9..859869a5e 100644
--- a/win/wayland/xdg_activation.h
+++ b/win/wayland/xdg_activation.h
@@ -116,7 +116,7 @@ void xdg_activation_handle_token_request(Space& space, TokenRequest& token)
             return false;
         }
 
-        if (win->control && win->control->wayland_management()) {
+        if (win->control && win->control->plasma_wayland_integration) {
             // Privileged windows are always allowed.
             return true;
         }
diff --git a/win/x11/window_release.h b/win/x11/window_release.h
index 5dc315566..cc553149a 100644
--- a/win/x11/window_release.h
+++ b/win/x11/window_release.h
@@ -166,7 +166,7 @@ void release_window(Win* win, bool on_shutdown)
     }
 #endif
 
-    win->control->destroy_wayland_management();
+    win->control->destroy_plasma_wayland_integration();
     destroy_damage_handle(*win);
     reset_have_resize_effect(*win);
 
@@ -290,7 +290,7 @@ void destroy_window(Win* win)
     }
 #endif
 
-    win->control->destroy_wayland_management();
+    win->control->destroy_plasma_wayland_integration();
     reset_have_resize_effect(*win);
 
     auto del = create_remnant_window<Win>(*win);
-- 
GitLab


From 662a6500fd3acfb034160d904dde809372a182a5 Mon Sep 17 00:00:00 2001
From: Roman Gilg <subdiff@gmail.com>
Date: Thu, 14 Jul 2022 15:52:39 +0200
Subject: [PATCH 41/51] fix: remove activation of any window with control
 desktop integration

Any window with control on Wayland has a Plasma window attached to it. So these
windows are not "privileged" special windows but rather any window and we make
our activation check meaningless by returning true on it.
---
 win/wayland/xdg_activation.h | 5 -----
 1 file changed, 5 deletions(-)

diff --git a/win/wayland/xdg_activation.h b/win/wayland/xdg_activation.h
index 859869a5e..630c69a21 100644
--- a/win/wayland/xdg_activation.h
+++ b/win/wayland/xdg_activation.h
@@ -116,11 +116,6 @@ void xdg_activation_handle_token_request(Space& space, TokenRequest& token)
             return false;
         }
 
-        if (win->control && win->control->plasma_wayland_integration) {
-            // Privileged windows are always allowed.
-            return true;
-        }
-
         if (win != space.active_client) {
             qCDebug(KWIN_WL) << "Requesting window" << win << "currently not active.";
             return false;
-- 
GitLab


From c7dd77707cb10ca20a369064444bda0ffe59d090 Mon Sep 17 00:00:00 2001
From: Roman Gilg <subdiff@gmail.com>
Date: Thu, 14 Jul 2022 16:51:11 +0200
Subject: [PATCH 42/51] style: rename X11 control header

We want to split out the control. For that rename the header first.
---
 win/space.cpp                           | 2 +-
 win/x11/{control.h => control_create.h} | 0
 win/x11/space_event.h                   | 2 +-
 win/x11/space_setup.h                   | 2 +-
 4 files changed, 3 insertions(+), 3 deletions(-)
 rename win/x11/{control.h => control_create.h} (100%)

diff --git a/win/space.cpp b/win/space.cpp
index e1e99d498..ade63f719 100644
--- a/win/space.cpp
+++ b/win/space.cpp
@@ -63,7 +63,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "win/user_actions_menu.h"
 #include "win/util.h"
 #include "win/virtual_desktops.h"
-#include "win/x11/control.h"
+#include "win/x11/control_create.h"
 #include "win/x11/event.h"
 #include "win/x11/group.h"
 #include "win/x11/moving_window_filter.h"
diff --git a/win/x11/control.h b/win/x11/control_create.h
similarity index 100%
rename from win/x11/control.h
rename to win/x11/control_create.h
diff --git a/win/x11/space_event.h b/win/x11/space_event.h
index bede70f55..e55377cc2 100644
--- a/win/x11/space_event.h
+++ b/win/x11/space_event.h
@@ -5,7 +5,7 @@
 */
 #pragma once
 
-#include "control.h"
+#include "control_create.h"
 #include "event.h"
 #include "unmanaged.h"
 
diff --git a/win/x11/space_setup.h b/win/x11/space_setup.h
index 858a271d4..efcc1e52b 100644
--- a/win/x11/space_setup.h
+++ b/win/x11/space_setup.h
@@ -6,7 +6,7 @@
 #pragma once
 
 #include "color_mapper.h"
-#include "control.h"
+#include "control_create.h"
 #include "moving_window_filter.h"
 #include "placement.h"
 #include "space_event.h"
-- 
GitLab


From ebbdff3bdbb99ddc6fd25460400505759aac372a Mon Sep 17 00:00:00 2001
From: Roman Gilg <subdiff@gmail.com>
Date: Sun, 17 Jul 2022 11:48:16 +0200
Subject: [PATCH 43/51] refactor: define X11 control in separate header

Move the definition to a separate header. Remove the unnecessary x11 prefix in
the class name.
---
 win/x11/control.h        | 148 +++++++++++++++++++++++++++++++++++++++
 win/x11/control_create.h | 130 +---------------------------------
 2 files changed, 150 insertions(+), 128 deletions(-)
 create mode 100644 win/x11/control.h

diff --git a/win/x11/control.h b/win/x11/control.h
new file mode 100644
index 000000000..178c5f627
--- /dev/null
+++ b/win/x11/control.h
@@ -0,0 +1,148 @@
+/*
+    SPDX-FileCopyrightText: 2022 Roman Gilg <subdiff@gmail.com>
+
+    SPDX-License-Identifier: GPL-2.0-or-later
+*/
+#pragma once
+
+#include "command.h"
+
+#include "win/control.h"
+#include "win/input.h"
+#include "win/meta.h"
+#include "win/move.h"
+
+#if KWIN_BUILD_TABBOX
+#include "win/tabbox/tabbox.h"
+#endif
+
+namespace KWin::win::x11
+{
+
+template<typename Win>
+class control : public win::control
+{
+public:
+    control(Win* window)
+        : win::control(window)
+        , m_window{window}
+    {
+    }
+
+    void set_skip_pager(bool set) override
+    {
+        win::control::set_skip_pager(set);
+        m_window->info->setState(skip_pager() ? NET::SkipPager : NET::States(), NET::SkipPager);
+    }
+
+    void set_skip_switcher(bool set) override
+    {
+        win::control::set_skip_switcher(set);
+        m_window->info->setState(skip_switcher() ? NET::SkipSwitcher : NET::States(),
+                                 NET::SkipSwitcher);
+    }
+
+    void set_skip_taskbar(bool set) override
+    {
+        win::control::set_skip_taskbar(set);
+        m_window->info->setState(skip_taskbar() ? NET::SkipTaskbar : NET::States(),
+                                 NET::SkipTaskbar);
+    }
+
+    void update_mouse_grab() override
+    {
+        xcb_ungrab_button(
+            connection(), XCB_BUTTON_INDEX_ANY, m_window->xcb_windows.wrapper, XCB_MOD_MASK_ANY);
+
+        if (m_window->space.tabbox->forced_global_mouse_grab()) {
+            // see TabBox::establishTabBoxGrab()
+            m_window->xcb_windows.wrapper.grab_button(XCB_GRAB_MODE_SYNC, XCB_GRAB_MODE_ASYNC);
+            return;
+        }
+
+        // When a passive grab is activated or deactivated, the X server will generate crossing
+        // events as if the pointer were suddenly to warp from its current position to some position
+        // in the grab window. Some /broken/ X11 clients do get confused by such EnterNotify and
+        // LeaveNotify events so we release the passive grab for the active window.
+        //
+        // The passive grab below is established so the window can be raised or activated when it
+        // is clicked.
+        if ((kwinApp()->options->focusPolicyIsReasonable() && !active())
+            || (kwinApp()->options->isClickRaise() && !is_most_recently_raised(m_window))) {
+            if (kwinApp()->options->commandWindow1() != base::options::MouseNothing) {
+                establish_command_window_grab(m_window, XCB_BUTTON_INDEX_1);
+            }
+            if (kwinApp()->options->commandWindow2() != base::options::MouseNothing) {
+                establish_command_window_grab(m_window, XCB_BUTTON_INDEX_2);
+            }
+            if (kwinApp()->options->commandWindow3() != base::options::MouseNothing) {
+                establish_command_window_grab(m_window, XCB_BUTTON_INDEX_3);
+            }
+            if (kwinApp()->options->commandWindowWheel() != base::options::MouseNothing) {
+                establish_command_window_grab(m_window, XCB_BUTTON_INDEX_4);
+                establish_command_window_grab(m_window, XCB_BUTTON_INDEX_5);
+            }
+        }
+
+        // We want to grab <command modifier> + buttons no matter what state the window is in. The
+        // client will receive funky EnterNotify and LeaveNotify events, but there is nothing that
+        // we can do about it, unfortunately.
+
+        if (!m_window->space.global_shortcuts_disabled) {
+            if (kwinApp()->options->commandAll1() != base::options::MouseNothing) {
+                establish_command_all_grab(m_window, XCB_BUTTON_INDEX_1);
+            }
+            if (kwinApp()->options->commandAll2() != base::options::MouseNothing) {
+                establish_command_all_grab(m_window, XCB_BUTTON_INDEX_2);
+            }
+            if (kwinApp()->options->commandAll3() != base::options::MouseNothing) {
+                establish_command_all_grab(m_window, XCB_BUTTON_INDEX_3);
+            }
+            if (kwinApp()->options->commandAllWheel() != base::options::MouseWheelNothing) {
+                establish_command_all_grab(m_window, XCB_BUTTON_INDEX_4);
+                establish_command_all_grab(m_window, XCB_BUTTON_INDEX_5);
+            }
+        }
+    }
+
+    void destroy_decoration() override
+    {
+        if (decoration(m_window)) {
+            auto const grav = calculate_gravitation(m_window, true);
+            win::control::destroy_decoration();
+            move(m_window, grav);
+        }
+        m_window->xcb_windows.input.reset();
+    }
+
+    QSize adjusted_frame_size(QSize const& frame_size, size_mode mode) override
+    {
+        auto const client_size = frame_to_client_size(m_window, frame_size);
+        return size_for_client_size(m_window, client_size, mode, false);
+    }
+
+    bool can_fullscreen() const override
+    {
+        if (!rules().checkFullScreen(true)) {
+            return false;
+        }
+        if (rules().checkStrictGeometry(true)) {
+            // check geometry constraints (rule to obey is set)
+            const QRect fsarea = space_window_area(m_window->space, FullScreenArea, m_window);
+            if (size_for_client_size(m_window, fsarea.size(), win::size_mode::any, true)
+                != fsarea.size()) {
+                // the app wouldn't fit exactly fullscreen geometry due to its strict geometry
+                // requirements
+                return false;
+            }
+        }
+        // don't check size constrains - some apps request fullscreen despite requesting fixed size
+        // also better disallow weird types to go fullscreen
+        return !is_special_window(m_window);
+    }
+
+private:
+    Win* m_window;
+};
+
+}
diff --git a/win/x11/control_create.h b/win/x11/control_create.h
index 2e1e2a2d7..49e85cf8b 100644
--- a/win/x11/control_create.h
+++ b/win/x11/control_create.h
@@ -9,7 +9,7 @@
 #include "activation.h"
 #include "appmenu.h"
 #include "client_machine.h"
-#include "command.h"
+#include "control.h"
 #include "deco.h"
 #include "focus_stealing.h"
 #include "placement.h"
@@ -33,132 +33,6 @@
 namespace KWin::win::x11
 {
 
-template<typename Win>
-class x11_control : public win::control
-{
-public:
-    x11_control(Win* window)
-        : win::control(window)
-        , m_window{window}
-    {
-    }
-
-    void set_skip_pager(bool set) override
-    {
-        win::control::set_skip_pager(set);
-        m_window->info->setState(skip_pager() ? NET::SkipPager : NET::States(), NET::SkipPager);
-    }
-
-    void set_skip_switcher(bool set) override
-    {
-        win::control::set_skip_switcher(set);
-        m_window->info->setState(skip_switcher() ? NET::SkipSwitcher : NET::States(),
-                                 NET::SkipSwitcher);
-    }
-
-    void set_skip_taskbar(bool set) override
-    {
-        win::control::set_skip_taskbar(set);
-        m_window->info->setState(skip_taskbar() ? NET::SkipTaskbar : NET::States(),
-                                 NET::SkipTaskbar);
-    }
-
-    void update_mouse_grab() override
-    {
-        xcb_ungrab_button(
-            connection(), XCB_BUTTON_INDEX_ANY, m_window->xcb_windows.wrapper, XCB_MOD_MASK_ANY);
-
-        if (m_window->space.tabbox->forced_global_mouse_grab()) {
-            // see TabBox::establishTabBoxGrab()
-            m_window->xcb_windows.wrapper.grab_button(XCB_GRAB_MODE_SYNC, XCB_GRAB_MODE_ASYNC);
-            return;
-        }
-
-        // When a passive grab is activated or deactivated, the X server will generate crossing
-        // events as if the pointer were suddenly to warp from its current position to some position
-        // in the grab window. Some /broken/ X11 clients do get confused by such EnterNotify and
-        // LeaveNotify events so we release the passive grab for the active window.
-        //
-        // The passive grab below is established so the window can be raised or activated when it
-        // is clicked.
-        if ((kwinApp()->options->focusPolicyIsReasonable() && !active())
-            || (kwinApp()->options->isClickRaise() && !is_most_recently_raised(m_window))) {
-            if (kwinApp()->options->commandWindow1() != base::options::MouseNothing) {
-                establish_command_window_grab(m_window, XCB_BUTTON_INDEX_1);
-            }
-            if (kwinApp()->options->commandWindow2() != base::options::MouseNothing) {
-                establish_command_window_grab(m_window, XCB_BUTTON_INDEX_2);
-            }
-            if (kwinApp()->options->commandWindow3() != base::options::MouseNothing) {
-                establish_command_window_grab(m_window, XCB_BUTTON_INDEX_3);
-            }
-            if (kwinApp()->options->commandWindowWheel() != base::options::MouseNothing) {
-                establish_command_window_grab(m_window, XCB_BUTTON_INDEX_4);
-                establish_command_window_grab(m_window, XCB_BUTTON_INDEX_5);
-            }
-        }
-
-        // We want to grab <command modifier> + buttons no matter what state the window is in. The
-        // client will receive funky EnterNotify and LeaveNotify events, but there is nothing that
-        // we can do about it, unfortunately.
-
-        if (!m_window->space.global_shortcuts_disabled) {
-            if (kwinApp()->options->commandAll1() != base::options::MouseNothing) {
-                establish_command_all_grab(m_window, XCB_BUTTON_INDEX_1);
-            }
-            if (kwinApp()->options->commandAll2() != base::options::MouseNothing) {
-                establish_command_all_grab(m_window, XCB_BUTTON_INDEX_2);
-            }
-            if (kwinApp()->options->commandAll3() != base::options::MouseNothing) {
-                establish_command_all_grab(m_window, XCB_BUTTON_INDEX_3);
-            }
-            if (kwinApp()->options->commandAllWheel() != base::options::MouseWheelNothing) {
-                establish_command_all_grab(m_window, XCB_BUTTON_INDEX_4);
-                establish_command_all_grab(m_window, XCB_BUTTON_INDEX_5);
-            }
-        }
-    }
-
-    void destroy_decoration() override
-    {
-        if (decoration(m_window)) {
-            auto const grav = calculate_gravitation(m_window, true);
-            win::control::destroy_decoration();
-            move(m_window, grav);
-        }
-        m_window->xcb_windows.input.reset();
-    }
-
-    QSize adjusted_frame_size(QSize const& frame_size, size_mode mode) override
-    {
-        auto const client_size = frame_to_client_size(m_window, frame_size);
-        return size_for_client_size(m_window, client_size, mode, false);
-    }
-
-    bool can_fullscreen() const override
-    {
-        if (!rules().checkFullScreen(true)) {
-            return false;
-        }
-        if (rules().checkStrictGeometry(true)) {
-            // check geometry constraints (rule to obey is set)
-            const QRect fsarea = space_window_area(m_window->space, FullScreenArea, m_window);
-            if (size_for_client_size(m_window, fsarea.size(), win::size_mode::any, true)
-                != fsarea.size()) {
-                // the app wouldn't fit exactly fullscreen geometry due to its strict geometry
-                // requirements
-                return false;
-            }
-        }
-        // don't check size constrains - some apps request fullscreen despite requesting fixed size
-        // also better disallow weird types to go fullscreen
-        return !is_special_window(m_window);
-    }
-
-private:
-    Win* m_window;
-};
-
 template<typename Win>
 void embed_client(Win* win, xcb_visualid_t visualid, xcb_colormap_t colormap, uint8_t depth)
 {
@@ -307,7 +181,7 @@ auto create_controlled_window(xcb_window_t xcb_win, bool isMapped, Space& space)
                      &screen_edger::checkBlocking);
 
     // From this place on, manage() must not return false
-    win->control.reset(new x11_control(win));
+    win->control.reset(new x11::control(win));
 
     win->supported_default_types = supported_managed_window_types_mask;
     win->has_in_content_deco = true;
-- 
GitLab


From 0598f26a4e7249b736b244f0109f8e1c7f915a79 Mon Sep 17 00:00:00 2001
From: Roman Gilg <subdiff@gmail.com>
Date: Wed, 20 Jul 2022 20:54:12 +0200
Subject: [PATCH 44/51] refactor: identify fullscreen group layers by lead

Instead of using the group index and identify common group layers by the top
lead of a group window. This allows us to remove the x11/window.h include in
this common code.
---
 win/stacking.h  | 25 +++++++++++--------------
 win/transient.h |  9 +++++++++
 2 files changed, 20 insertions(+), 14 deletions(-)

diff --git a/win/stacking.h b/win/stacking.h
index f372c794b..7c78ea58e 100644
--- a/win/stacking.h
+++ b/win/stacking.h
@@ -27,6 +27,8 @@
 
 #include "rules/rules.h"
 
+#include <map>
+
 /**
  This file contains things relevant to stacking order and layers.
 
@@ -346,34 +348,29 @@ template<typename Container>
 std::vector<Toplevel*> sort_windows_by_layer(Container const& list)
 {
     std::deque<Toplevel*> layers[enum_index(layer::count)];
-    auto const& outputs = kwinApp()->get_base().get_outputs();
 
     // Build the order from layers.
 
     // This is needed as a workaround for group windows with fullscreen members, such that other
     // group members are moved per output to the active (fullscreen) level too.
-    QVector<QMap<x11::group*, layer>> fs_group_layers(std::max<size_t>(outputs.size(), 1));
+    using key = std::pair<base::output const*, Toplevel*>;
+    std::map<key, layer> lead_layers;
 
     for (auto const& win : list) {
         auto lay = win->layer();
+        auto lead = get_top_lead(win);
+        auto search = lead_layers.find({win->central_output, lead});
 
-        auto const output_index
-            = win->central_output ? base::get_output_index(outputs, *win->central_output) : 0;
-        auto x11_win = qobject_cast<x11::window*>(win);
-
-        auto group_layer_it
-            = fs_group_layers[output_index].find(x11_win ? x11_win->group() : nullptr);
-
-        if (group_layer_it != fs_group_layers[output_index].end()) {
+        if (search != lead_layers.end()) {
             // If a window is raised above some other window in the same window group
             // which is in the ActiveLayer (i.e. it's fulscreened), make sure it stays
             // above that window (see #95731).
-            if (*group_layer_it == layer::active && (enum_index(lay) > enum_index(layer::below))) {
+            if (search->second == layer::active && (enum_index(lay) > enum_index(layer::below))) {
                 lay = layer::active;
             }
-            *group_layer_it = lay;
-        } else if (x11_win) {
-            fs_group_layers[output_index].insertMulti(x11_win->group(), lay);
+            search->second = lay;
+        } else {
+            lead_layers[{win->central_output, lead}] = lay;
         }
 
         layers[enum_index(lay)].push_back(win);
diff --git a/win/transient.h b/win/transient.h
index 20321a1a6..ffc734c65 100644
--- a/win/transient.h
+++ b/win/transient.h
@@ -16,6 +16,15 @@ class Toplevel;
 namespace win
 {
 
+template<typename Win>
+Toplevel* get_top_lead(Win* win)
+{
+    if (auto lead = win->transient()->lead()) {
+        return get_top_lead(lead);
+    }
+    return win;
+}
+
 template<typename Win>
 Toplevel* lead_of_annexed_transient(Win* win)
 {
-- 
GitLab


From 07bba82b9f9b631283cb6be97965250b9cdd0c18 Mon Sep 17 00:00:00 2001
From: Roman Gilg <subdiff@gmail.com>
Date: Wed, 20 Jul 2022 21:02:36 +0200
Subject: [PATCH 45/51] refactor: remove x11/window.h include in stacking
 header

The include is not needed anymore. We need to fix transient includes in other
files though.
---
 win/activation.h     | 1 +
 win/stacking.h       | 5 +----
 win/window_release.h | 1 +
 win/x11/geo.h        | 1 +
 win/x11/user_time.h  | 1 +
 5 files changed, 5 insertions(+), 4 deletions(-)

diff --git a/win/activation.h b/win/activation.h
index 29db76578..df1234099 100644
--- a/win/activation.h
+++ b/win/activation.h
@@ -18,6 +18,7 @@
 #include "x11/netinfo.h"
 #include "x11/tool_windows.h"
 #include "x11/user_time.h"
+#include "x11/window.h"
 
 #include "utils/blocker.h"
 
diff --git a/win/stacking.h b/win/stacking.h
index 7c78ea58e..b451696ca 100644
--- a/win/stacking.h
+++ b/win/stacking.h
@@ -10,15 +10,12 @@
 #include "focus_chain_edit.h"
 #include "geo.h"
 #include "layers.h"
+#include "meta.h"
 #include "stacking_order.h"
 #include "util.h"
 #include "x11/group.h"
 #include "x11/netinfo.h"
 
-// Required for casts between Toplevel and window in some template functions.
-// TODO(romangg): Remove these casts and this include to make the functions truly generic.
-#include "x11/window.h"
-
 #include "base/output_helpers.h"
 #include "base/platform.h"
 #include "main.h"
diff --git a/win/window_release.h b/win/window_release.h
index de2ce81e0..f0e1f795a 100644
--- a/win/window_release.h
+++ b/win/window_release.h
@@ -9,6 +9,7 @@
 #include "remnant.h"
 #include "space_window_release.h"
 #include "x11/netinfo.h"
+#include "x11/window.h"
 
 #include "toplevel.h"
 
diff --git a/win/x11/geo.h b/win/x11/geo.h
index a506fbb90..c8feab418 100644
--- a/win/x11/geo.h
+++ b/win/x11/geo.h
@@ -9,6 +9,7 @@
 
 #include "win/setup.h"
 
+#include <xcb/sync.h>
 #include <xcb/xcb_icccm.h>
 
 namespace KWin::win::x11
diff --git a/win/x11/user_time.h b/win/x11/user_time.h
index c1504159f..fab636bce 100644
--- a/win/x11/user_time.h
+++ b/win/x11/user_time.h
@@ -5,6 +5,7 @@
 */
 #pragma once
 
+#include "base/x11/xcb/property.h"
 #include "base/x11/xcb/proto.h"
 #include "main.h"
 
-- 
GitLab


From 3a8186445e30cb54b14304d8739f0168d1ad35d0 Mon Sep 17 00:00:00 2001
From: Roman Gilg <subdiff@gmail.com>
Date: Wed, 20 Jul 2022 21:38:51 +0200
Subject: [PATCH 46/51] refactor: check isClient for remnant

Instead of doing a qobject_cast. This allows to remove the x11/window.h include
in the generic code.
---
 win/window_release.h | 3 +--
 1 file changed, 1 insertion(+), 2 deletions(-)

diff --git a/win/window_release.h b/win/window_release.h
index f0e1f795a..f0a706030 100644
--- a/win/window_release.h
+++ b/win/window_release.h
@@ -9,7 +9,6 @@
 #include "remnant.h"
 #include "space_window_release.h"
 #include "x11/netinfo.h"
-#include "x11/window.h"
 
 #include "toplevel.h"
 
@@ -58,7 +57,7 @@ win::remnant create_remnant(Win& source)
     remnant.data.was_group_transient = source.groupTransient();
 
     remnant.data.was_wayland_client = source.is_wayland_window();
-    remnant.data.was_x11_client = qobject_cast<win::x11::window*>(&source) != nullptr;
+    remnant.data.was_x11_client = source.isClient();
     remnant.data.was_popup_window = win::is_popup(&source);
     remnant.data.was_outline = source.isOutline();
     remnant.data.was_lock_screen = source.isLockScreen();
-- 
GitLab


From ffa906f21aa849860e3d60f73a06c4cf586fc2ac Mon Sep 17 00:00:00 2001
From: Roman Gilg <subdiff@gmail.com>
Date: Wed, 20 Jul 2022 21:53:14 +0200
Subject: [PATCH 47/51] feat: follow focus mouse precedent on Wayland

The code should be generic enough to also work for Wayland windows. Remove the
x11::window cast for that.
---
 win/activation.h | 14 +++++++-------
 1 file changed, 7 insertions(+), 7 deletions(-)

diff --git a/win/activation.h b/win/activation.h
index df1234099..1246176db 100644
--- a/win/activation.h
+++ b/win/activation.h
@@ -621,19 +621,19 @@ Toplevel* find_window_to_activate_on_desktop(Space& space, unsigned int desktop)
     if (kwinApp()->options->isNextFocusPrefersMouse()) {
         auto it = space.stacking_order->stack.cend();
         while (it != space.stacking_order->stack.cbegin()) {
-            auto client = qobject_cast<win::x11::window*>(*(--it));
-            if (!client) {
+            auto window = *(--it);
+            if (!window->control) {
                 continue;
             }
 
-            if (!(client->isShown() && client->isOnDesktop(desktop) && on_active_screen(client)))
+            if (!(window->isShown() && window->isOnDesktop(desktop) && on_active_screen(window)))
                 continue;
 
-            if (client->frameGeometry().contains(input::get_cursor()->pos())) {
-                if (!is_desktop(client)) {
-                    return client;
+            if (window->frameGeometry().contains(input::get_cursor()->pos())) {
+                if (!is_desktop(window)) {
+                    return window;
                 }
-                // Unconditional break, we don't pass focus to some client below an unusable one.
+                // Unconditional break, we don't pass focus to some window below an unusable one.
                 break;
             }
         }
-- 
GitLab


From 974c74df14f9e3289a58ce9987e88ed3880ffb00 Mon Sep 17 00:00:00 2001
From: Roman Gilg <subdiff@gmail.com>
Date: Wed, 20 Jul 2022 22:38:35 +0200
Subject: [PATCH 48/51] refactor: update user time on activation in virtual
 call

This allows to remove a cast to the X11 window type in the generic activation
code.
---
 toplevel.cpp       |  4 ++++
 toplevel.h         |  1 +
 win/activation.h   | 13 +------------
 win/stacking.h     |  1 +
 win/x11/window.cpp |  5 +++++
 win/x11/window.h   |  2 ++
 6 files changed, 14 insertions(+), 12 deletions(-)

diff --git a/toplevel.cpp b/toplevel.cpp
index b0af7cead..16cdce110 100644
--- a/toplevel.cpp
+++ b/toplevel.cpp
@@ -738,6 +738,10 @@ win::maximize_mode Toplevel::maximizeMode() const
     return win::maximize_mode::restore;
 }
 
+void Toplevel::handle_activated()
+{
+}
+
 bool Toplevel::wantsInput() const
 {
     return false;
diff --git a/toplevel.h b/toplevel.h
index 43e161054..7746ec71c 100644
--- a/toplevel.h
+++ b/toplevel.h
@@ -444,6 +444,7 @@ public:
      */
     virtual bool isMovableAcrossScreens() const = 0;
 
+    virtual void handle_activated();
     virtual void takeFocus() = 0;
     virtual bool wantsInput() const;
 
diff --git a/win/activation.h b/win/activation.h
index 1246176db..c2a4d9d69 100644
--- a/win/activation.h
+++ b/win/activation.h
@@ -18,7 +18,6 @@
 #include "x11/netinfo.h"
 #include "x11/tool_windows.h"
 #include "x11/user_time.h"
-#include "x11/window.h"
 
 #include "utils/blocker.h"
 
@@ -478,17 +477,7 @@ void activate_window_impl(Space& space, Win* window, bool force)
         request_focus(space, window, false, force);
     }
 
-    // Don't update user time for clients that have focus stealing workaround.
-    // As they usually belong to the current active window but fail to provide
-    // this information, updating their user time would make the user time
-    // of the currently active window old, and reject further activation for it.
-    // E.g. typing URL in minicli which will show kio_uiserver dialog (with workaround),
-    // and then kdesktop shows dialog about SSL certificate.
-    // This needs also avoiding user creation time in x11::window::readUserTimeMapTimestamp().
-    if (auto client = dynamic_cast<x11::window*>(window)) {
-        // updateUserTime is X11 specific
-        x11::update_user_time(client);
-    }
+    window->handle_activated();
 }
 
 template<typename Space>
diff --git a/win/stacking.h b/win/stacking.h
index b451696ca..842d1d75a 100644
--- a/win/stacking.h
+++ b/win/stacking.h
@@ -15,6 +15,7 @@
 #include "util.h"
 #include "x11/group.h"
 #include "x11/netinfo.h"
+#include "x11/window.h"
 
 #include "base/output_helpers.h"
 #include "base/platform.h"
diff --git a/win/x11/window.cpp b/win/x11/window.cpp
index 3c3f1d2ae..905020fe4 100644
--- a/win/x11/window.cpp
+++ b/win/x11/window.cpp
@@ -507,6 +507,11 @@ bool window::groupTransient() const
     return static_cast<win::x11::transient*>(transient())->lead_id == rootWindow();
 }
 
+void window::handle_activated()
+{
+    update_user_time(this);
+}
+
 void window::takeFocus()
 {
     if (control->rules().checkAcceptFocus(info->input())) {
diff --git a/win/x11/window.h b/win/x11/window.h
index 4037c12bd..19ffdd302 100644
--- a/win/x11/window.h
+++ b/win/x11/window.h
@@ -201,6 +201,8 @@ public:
     void setNoBorder(bool set) override;
     void layoutDecorationRects(QRect& left, QRect& top, QRect& right, QRect& bottom) const override;
     void updateDecoration(bool check_workspace_pos, bool force = false) override;
+
+    void handle_activated() override;
     void takeFocus() override;
     bool userCanSetNoBorder() const override;
     bool wantsInput() const override;
-- 
GitLab


From f807f14ee018ef549d2479956fdc2ff6ca11b9eb Mon Sep 17 00:00:00 2001
From: Roman Gilg <subdiff@gmail.com>
Date: Thu, 21 Jul 2022 00:55:20 +0200
Subject: [PATCH 49/51] refactor: loop transient family instead of group
 members

Add helper functions to get all windows in a transient hierarchy. This is
equivalent to iterating over all group members in an X11 group. Using the
more generic concept of transients we can get rid of some X11 spill into
our generic code.
---
 win/activation.h |  6 ++----
 win/stacking.h   |  4 +---
 win/transient.h  | 27 +++++++++++++++++++++++++++
 3 files changed, 30 insertions(+), 7 deletions(-)

diff --git a/win/activation.h b/win/activation.h
index c2a4d9d69..602006fcc 100644
--- a/win/activation.h
+++ b/win/activation.h
@@ -826,10 +826,8 @@ void set_showing_desktop(Space& space, bool showing)
                     lower_window(&space, c);
                     if (!topDesk)
                         topDesk = c;
-                    if (auto group = c->group()) {
-                        for (auto cm : group->members) {
-                            update_layer(cm);
-                        }
+                    for (auto cm : get_transient_family(c)) {
+                        update_layer(cm);
                     }
                 }
             }
diff --git a/win/stacking.h b/win/stacking.h
index 842d1d75a..0eec2b45d 100644
--- a/win/stacking.h
+++ b/win/stacking.h
@@ -13,9 +13,7 @@
 #include "meta.h"
 #include "stacking_order.h"
 #include "util.h"
-#include "x11/group.h"
 #include "x11/netinfo.h"
-#include "x11/window.h"
 
 #include "base/output_helpers.h"
 #include "base/platform.h"
@@ -188,7 +186,7 @@ void lower_window(Space* space, Window* window)
 
     if (window->transient()->lead() && window->group()) {
         // Lower also all windows in the group, in reversed stacking order.
-        auto const wins = restacked_by_space_stacking_order(space, window->group()->members);
+        auto const wins = restacked_by_space_stacking_order(space, get_transient_family(window));
 
         for (auto it = wins.crbegin(); it != wins.crend(); it++) {
             auto gwin = *it;
diff --git a/win/transient.h b/win/transient.h
index ffc734c65..1cd11f05d 100644
--- a/win/transient.h
+++ b/win/transient.h
@@ -6,6 +6,7 @@
 #pragma once
 
 #include "kwin_export.h"
+#include "utils/algorithm.h"
 
 #include <vector>
 
@@ -25,6 +26,32 @@ Toplevel* get_top_lead(Win* win)
     return win;
 }
 
+template<typename Win>
+std::vector<Toplevel*> get_transient_descendants(Win* win)
+{
+    std::vector<Toplevel*> descendants;
+
+    for (auto child : win->transient()->children) {
+        descendants.push_back(child);
+    }
+
+    for (auto child : win->transient()->children) {
+        auto const child_desc = get_transient_descendants(child);
+        descendants.insert(descendants.end(), child_desc.begin(), child_desc.end());
+    }
+
+    return descendants;
+}
+
+template<typename Win>
+std::vector<Toplevel*> get_transient_family(Win* win)
+{
+    auto top_lead = get_top_lead(win);
+    auto relatives = get_transient_descendants(top_lead);
+    relatives.push_back(top_lead);
+    return relatives;
+}
+
 template<typename Win>
 Toplevel* lead_of_annexed_transient(Win* win)
 {
-- 
GitLab


From ef8f6b4768650295f9623b71d0a7477dd1535426 Mon Sep 17 00:00:00 2001
From: Roman Gilg <subdiff@gmail.com>
Date: Wed, 20 Jul 2022 17:40:33 +0200
Subject: [PATCH 50/51] refactor: set desktops in control overrides

Move the windowing system specific management of desktop setting to control
overrides. The new Xwayland control handles both.
---
 win/control.h             |  2 ++
 win/desktop_set.h         | 26 +---------------------
 win/internal_window.cpp   |  4 ++++
 win/wayland/control.h     | 34 +++++++++++++++++++++++++++++
 win/wayland/desktop_set.h | 46 +++++++++++++++++++++++++++++++++++++++
 win/wayland/layer_shell.h |  3 ++-
 win/wayland/xdg_shell.h   | 16 ++++++++------
 win/wayland/xwl_control.h | 35 +++++++++++++++++++++++++++++
 win/wayland/xwl_window.h  |  4 ++++
 win/x11/command.h         |  6 ++++-
 win/x11/control.h         |  7 ++++++
 win/x11/control_create.h  |  2 +-
 win/x11/window.h          |  2 ++
 13 files changed, 152 insertions(+), 35 deletions(-)
 create mode 100644 win/wayland/control.h
 create mode 100644 win/wayland/desktop_set.h
 create mode 100644 win/wayland/xwl_control.h

diff --git a/win/control.h b/win/control.h
index 612fe9189..56078ba67 100644
--- a/win/control.h
+++ b/win/control.h
@@ -51,6 +51,8 @@ public:
 
     void setup_tabbox();
 
+    virtual void set_desktops(QVector<virtual_desktop*> desktops) = 0;
+
     bool skip_pager() const;
     virtual void set_skip_pager(bool set);
 
diff --git a/win/desktop_set.h b/win/desktop_set.h
index 9fa15a993..b3a94187c 100644
--- a/win/desktop_set.h
+++ b/win/desktop_set.h
@@ -12,8 +12,6 @@
 
 #include "main.h"
 
-#include <Wrapland/Server/plasma_window.h>
-
 namespace KWin::win
 {
 
@@ -36,29 +34,7 @@ void set_desktops(Win* win, QVector<virtual_desktop*> desktops)
     auto const wasOnCurrentDesktop = on_current_desktop(win) && was_desk >= 0;
 
     win->set_desktops(desktops);
-
-    if (auto management = win->control->plasma_wayland_integration) {
-        if (desktops.isEmpty()) {
-            management->setOnAllDesktops(true);
-        } else {
-            management->setOnAllDesktops(false);
-            auto currentDesktops = management->plasmaVirtualDesktops();
-            for (auto desktop : desktops) {
-                auto id = desktop->id().toStdString();
-                if (!contains(currentDesktops, id)) {
-                    management->addPlasmaVirtualDesktop(id);
-                } else {
-                    remove_all(currentDesktops, id);
-                }
-            }
-            for (auto desktop : currentDesktops) {
-                management->removePlasmaVirtualDesktop(desktop);
-            }
-        }
-    }
-    if (win->info) {
-        win->info->setDesktop(win->desktop());
-    }
+    win->control->set_desktops(desktops);
 
     if ((was_desk == NET::OnAllDesktops) != (win->desktop() == NET::OnAllDesktops)) {
         // OnAllDesktops changed
diff --git a/win/internal_window.cpp b/win/internal_window.cpp
index a453e86f3..41300efab 100644
--- a/win/internal_window.cpp
+++ b/win/internal_window.cpp
@@ -55,6 +55,10 @@ public:
     {
     }
 
+    void set_desktops(QVector<virtual_desktop*> /*desktops*/) override
+    {
+    }
+
     void destroy_decoration() override
     {
         if (!win::decoration(m_client)) {
diff --git a/win/wayland/control.h b/win/wayland/control.h
new file mode 100644
index 000000000..199202725
--- /dev/null
+++ b/win/wayland/control.h
@@ -0,0 +1,34 @@
+/*
+    SPDX-FileCopyrightText: 2022 Roman Gilg <subdiff@gmail.com>
+
+    SPDX-License-Identifier: GPL-2.0-or-later
+*/
+#pragma once
+
+#include "desktop_set.h"
+
+#include "win/control.h"
+
+namespace KWin::win::wayland
+{
+
+template<typename Win>
+class control : public win::control
+{
+public:
+    control(Win& window)
+        : win::control(&window)
+        , window{window}
+    {
+    }
+
+    void set_desktops(QVector<virtual_desktop*> desktops) override
+    {
+        wayland::set_desktops(window, desktops);
+    }
+
+private:
+    Win& window;
+};
+
+}
diff --git a/win/wayland/desktop_set.h b/win/wayland/desktop_set.h
new file mode 100644
index 000000000..c10240a3e
--- /dev/null
+++ b/win/wayland/desktop_set.h
@@ -0,0 +1,46 @@
+/*
+    SPDX-FileCopyrightText: 2022 Roman Gilg <subdiff@gmail.com>
+
+    SPDX-License-Identifier: GPL-2.0-or-later
+*/
+#pragma once
+
+#include "utils/algorithm.h"
+#include "win/virtual_desktops.h"
+
+#include <Wrapland/Server/plasma_window.h>
+
+namespace KWin::win::wayland
+{
+
+template<typename Win>
+void set_desktops(Win& win, QVector<virtual_desktop*> desktops)
+{
+    auto management = win.control->plasma_wayland_integration;
+    if (!management) {
+        return;
+    }
+
+    if (desktops.isEmpty()) {
+        management->setOnAllDesktops(true);
+        return;
+    }
+
+    management->setOnAllDesktops(false);
+
+    auto currentDesktops = management->plasmaVirtualDesktops();
+    for (auto desktop : desktops) {
+        auto id = desktop->id().toStdString();
+        if (!contains(currentDesktops, id)) {
+            management->addPlasmaVirtualDesktop(id);
+        } else {
+            remove_all(currentDesktops, id);
+        }
+    }
+
+    for (auto desktop : currentDesktops) {
+        management->removePlasmaVirtualDesktop(desktop);
+    }
+}
+
+}
diff --git a/win/wayland/layer_shell.h b/win/wayland/layer_shell.h
index 46e758361..084b187bc 100644
--- a/win/wayland/layer_shell.h
+++ b/win/wayland/layer_shell.h
@@ -5,6 +5,7 @@
 */
 #pragma once
 
+#include "control.h"
 #include "space.h"
 #include "window_release.h"
 
@@ -148,7 +149,7 @@ void assign_layer_surface_role(Win* win, Wrapland::Server::LayerSurfaceV1* layer
     assert(win->surface);
     assert(layer_surface->surface() == win->surface);
 
-    win->control.reset(new control(win));
+    win->control.reset(new wayland::control(*win));
     win->layer_surface = layer_surface;
     block_geometry_updates(win, true);
 
diff --git a/win/wayland/xdg_shell.h b/win/wayland/xdg_shell.h
index 37256188b..3d6de6b40 100644
--- a/win/wayland/xdg_shell.h
+++ b/win/wayland/xdg_shell.h
@@ -5,6 +5,7 @@
 */
 #pragma once
 
+#include "control.h"
 #include "popup_placement.h"
 #include "space.h"
 #include "window.h"
@@ -41,25 +42,26 @@
 namespace KWin::win::wayland
 {
 
-class xdg_shell_control : public control
+template<typename Win>
+class xdg_shell_control : public wayland::control<Win>
 {
 public:
-    xdg_shell_control(window* win)
-        : control(win)
+    xdg_shell_control(Win& win)
+        : wayland::control<Win>(win)
         , m_window{win}
     {
     }
 
     bool can_fullscreen() const override
     {
-        if (!rules().checkFullScreen(true)) {
+        if (!this->rules().checkFullScreen(true)) {
             return false;
         }
-        return !is_special_window(m_window);
+        return !is_special_window(&m_window);
     }
 
 private:
-    window* m_window;
+    wayland::window& m_window;
 };
 
 template<typename Space>
@@ -205,7 +207,7 @@ window* create_toplevel_window(Space* space, Wrapland::Server::XdgShellToplevel*
     auto win = create_shell_window(*space, toplevel->surface());
     win->toplevel = toplevel;
 
-    win->control = std::make_unique<xdg_shell_control>(win);
+    win->control = std::make_unique<xdg_shell_control<window>>(*win);
     win->control->setup_tabbox();
     win->control->setup_color_scheme();
 
diff --git a/win/wayland/xwl_control.h b/win/wayland/xwl_control.h
new file mode 100644
index 000000000..ae05ca9e3
--- /dev/null
+++ b/win/wayland/xwl_control.h
@@ -0,0 +1,35 @@
+/*
+    SPDX-FileCopyrightText: 2022 Roman Gilg <subdiff@gmail.com>
+
+    SPDX-License-Identifier: GPL-2.0-or-later
+*/
+#pragma once
+
+#include "desktop_set.h"
+
+#include "win/x11/control.h"
+
+namespace KWin::win::wayland
+{
+
+template<typename Win>
+class xwl_control : public x11::control<Win>
+{
+public:
+    xwl_control(Win* window)
+        : x11::control<Win>(window)
+        , window{window}
+    {
+    }
+
+    void set_desktops(QVector<virtual_desktop*> desktops) override
+    {
+        wayland::set_desktops(*window, desktops);
+        x11::control<Win>::set_desktops(desktops);
+    }
+
+private:
+    Win* window;
+};
+
+}
diff --git a/win/wayland/xwl_window.h b/win/wayland/xwl_window.h
index b7b84bffc..56093ef0a 100644
--- a/win/wayland/xwl_window.h
+++ b/win/wayland/xwl_window.h
@@ -5,6 +5,8 @@
 */
 #pragma once
 
+#include "xwl_control.h"
+
 #include "win/x11/window.h"
 
 namespace KWin::win::wayland
@@ -14,6 +16,8 @@ class KWIN_EXPORT xwl_window : public x11::window
 {
     Q_OBJECT
 public:
+    using control_t = xwl_control<xwl_window>;
+
     xwl_window(xcb_window_t xcb_win, win::space& space);
 
     qreal bufferScale() const override;
diff --git a/win/x11/command.h b/win/x11/command.h
index 726d77db0..60a0d74a8 100644
--- a/win/x11/command.h
+++ b/win/x11/command.h
@@ -8,7 +8,11 @@
 #include "base/options.h"
 #include "main.h"
 
-#include <kkeyserver.h>
+// Needs to be included before KKeyServer, because KKeyServer includes XLib whose macros collide
+// with Qt declarations in QDBus, in particular the "True" and "False" names.
+#include <QtCore>
+
+#include <KKeyServer>
 
 namespace KWin::win::x11
 {
diff --git a/win/x11/control.h b/win/x11/control.h
index 178c5f627..7f126afad 100644
--- a/win/x11/control.h
+++ b/win/x11/control.h
@@ -7,6 +7,7 @@
 
 #include "command.h"
 
+#include "main.h"
 #include "win/control.h"
 #include "win/input.h"
 #include "win/meta.h"
@@ -29,6 +30,12 @@ public:
     {
     }
 
+    void set_desktops(QVector<virtual_desktop*> /*desktops*/) override
+    {
+        assert(m_window->info);
+        m_window->info->setDesktop(m_window->desktop());
+    }
+
     void set_skip_pager(bool set) override
     {
         win::control::set_skip_pager(set);
diff --git a/win/x11/control_create.h b/win/x11/control_create.h
index 49e85cf8b..2b7a46ab5 100644
--- a/win/x11/control_create.h
+++ b/win/x11/control_create.h
@@ -181,7 +181,7 @@ auto create_controlled_window(xcb_window_t xcb_win, bool isMapped, Space& space)
                      &screen_edger::checkBlocking);
 
     // From this place on, manage() must not return false
-    win->control.reset(new x11::control(win));
+    win->control = std::make_unique<typename Win::control_t>(win);
 
     win->supported_default_types = supported_managed_window_types_mask;
     win->has_in_content_deco = true;
diff --git a/win/x11/window.h b/win/x11/window.h
index 19ffdd302..0cd0b9623 100644
--- a/win/x11/window.h
+++ b/win/x11/window.h
@@ -5,6 +5,7 @@
 */
 #pragma once
 
+#include "control.h"
 #include "types.h"
 
 #include "toplevel.h"
@@ -46,6 +47,7 @@ class KWIN_EXPORT window : public Toplevel
 {
     Q_OBJECT
 public:
+    using control_t = x11::control<window>;
     constexpr static bool is_toplevel{false};
 
     window(win::remnant remnant, win::space& space);
-- 
GitLab


From ce249577c83ba5e1fa4e3d41886ce79566d575be Mon Sep 17 00:00:00 2001
From: Roman Gilg <subdiff@gmail.com>
Date: Wed, 13 Jul 2022 00:57:30 +0200
Subject: [PATCH 51/51] refactor: define space functions in header

Move all definitions of the abstract space class to the header.
---
 autotests/tabbox/CMakeLists.txt         |  20 ++++
 autotests/test_x11_timestamp_update.cpp |   5 +-
 base/dbus/kwin.h                        |   3 +-
 base/os/kkeyserver.h                    |  12 ++
 base/x11/xcb/qt_types.h                 |   3 +-
 input/filters/decoration_event.cpp      |   1 +
 input/filters/window_action.cpp         |   1 +
 input/x11/window_selector.cpp           |   4 +
 render/x11/shadow.h                     |   1 +
 scripting/effect.cpp                    |   1 +
 scripting/window.cpp                    |   1 +
 win/control.cpp                         |   1 +
 win/dbus/virtual_desktop_manager.h      |   3 +-
 win/deco/bridge.h                       |  13 +--
 win/deco/settings.h                     |   4 +-
 win/input.h                             |   1 -
 win/layers.h                            |   1 -
 win/meta.h                              |   1 -
 win/move.h                              |   1 -
 win/shortcut_set.h                      |   1 +
 win/space.cpp                           | 107 ------------------
 win/space.h                             | 144 ++++++++++--------------
 win/space_setup.h                       |   6 +-
 win/tabbox/tabbox.cpp                   |   2 +-
 win/tabbox/tabbox_x11_filter.cpp        |   3 +-
 win/wayland/xwl_window.cpp              |   2 +
 win/x11/color_mapper.cpp                |   2 +
 win/x11/command.h                       |   7 +-
 win/x11/event.h                         |   3 +-
 win/x11/moving_window_filter.h          |   2 +-
 win/x11/placement.h                     |   1 +
 win/x11/space.cpp                       |   2 +-
 win/x11/space_setup.h                   |   2 +-
 win/x11/window.cpp                      |   1 +
 34 files changed, 133 insertions(+), 229 deletions(-)
 create mode 100644 base/os/kkeyserver.h

diff --git a/autotests/tabbox/CMakeLists.txt b/autotests/tabbox/CMakeLists.txt
index 8300e7451..affa74608 100644
--- a/autotests/tabbox/CMakeLists.txt
+++ b/autotests/tabbox/CMakeLists.txt
@@ -14,10 +14,15 @@ set(testTabBoxClientModel_SRCS
     test_tabbox_clientmodel.cpp
 )
 
+ki18n_wrap_ui(testTabBoxClientModel_SRCS
+    ../../win/shortcut_dialog.ui
+)
+
 add_executable(testTabBoxClientModel ${testTabBoxClientModel_SRCS})
 set_target_properties(testTabBoxClientModel PROPERTIES COMPILE_DEFINITIONS "NO_NONE_WINDOW")
 target_link_libraries(testTabBoxClientModel
     Qt::Core
+    Qt::Concurrent
     Qt::DBus
     Qt::Quick
     Qt::Test
@@ -26,10 +31,15 @@ target_link_libraries(testTabBoxClientModel
     Qt::GuiPrivate
 
     KF5::ConfigCore
+    KF5::ConfigWidgets
+    KF5::GlobalAccel
     KF5::I18n
     KF5::Package
+    KF5::Service
     KF5::WindowSystem
 
+    KDecoration2::KDecoration
+
     XCB::XCB
 )
 add_test(NAME kwin-testTabBoxClientModel COMMAND testTabBoxClientModel)
@@ -49,10 +59,15 @@ set(testTabBoxHandler_SRCS
     test_tabbox_handler.cpp
 )
 
+ki18n_wrap_ui(testTabBoxHandler_SRCS
+    ../../win/shortcut_dialog.ui
+)
+
 add_executable(testTabBoxHandler ${testTabBoxHandler_SRCS})
 set_target_properties(testTabBoxHandler PROPERTIES COMPILE_DEFINITIONS "NO_NONE_WINDOW")
 target_link_libraries(testTabBoxHandler
     Qt::Core
+    Qt::Concurrent
     Qt::DBus
     Qt::Quick
     Qt::Test
@@ -61,10 +76,15 @@ target_link_libraries(testTabBoxHandler
     Qt::GuiPrivate
 
     KF5::ConfigCore
+    KF5::ConfigWidgets
+    KF5::GlobalAccel
     KF5::I18n
     KF5::Package
+    KF5::Service
     KF5::WindowSystem
 
+    KDecoration2::KDecoration
+
     XCB::XCB
 )
 add_test(NAME kwin-testTabBoxHandler COMMAND testTabBoxHandler)
diff --git a/autotests/test_x11_timestamp_update.cpp b/autotests/test_x11_timestamp_update.cpp
index 42667bfb4..6acb4aed6 100644
--- a/autotests/test_x11_timestamp_update.cpp
+++ b/autotests/test_x11_timestamp_update.cpp
@@ -17,8 +17,11 @@ GNU General Public License for more details.
 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *********************************************************************/
-
 #include <QTest>
+
+// Included here because later includes pull in XLib which collides with some defintions in QtCore.
+#include <QtCore>
+
 #include <QX11Info>
 
 #include <KPluginMetaData>
diff --git a/base/dbus/kwin.h b/base/dbus/kwin.h
index d598abd93..628ebfc51 100644
--- a/base/dbus/kwin.h
+++ b/base/dbus/kwin.h
@@ -8,6 +8,7 @@
 
 #include "debug/support_info.h"
 #include "input/platform.h"
+#include "kwin_export.h"
 #include "main.h"
 #include "toplevel.h"
 #include "win/kill_window.h"
@@ -41,7 +42,7 @@ namespace base::dbus
  *
  * @author Martin Gräßlin <mgraesslin@kde.org>
  */
-class kwin : public QObject, protected QDBusContext
+class KWIN_EXPORT kwin : public QObject, protected QDBusContext
 {
     Q_OBJECT
     Q_CLASSINFO("D-Bus Interface", "org.kde.KWin")
diff --git a/base/os/kkeyserver.h b/base/os/kkeyserver.h
new file mode 100644
index 000000000..7f3d64e77
--- /dev/null
+++ b/base/os/kkeyserver.h
@@ -0,0 +1,12 @@
+/*
+    SPDX-FileCopyrightText: 2022 Roman Gilg <subdiff@gmail.com>
+
+    SPDX-License-Identifier: GPL-2.0-or-later
+*/
+#pragma once
+
+// Needs to be included before KKeyServer, because KKeyServer includes XLib whose macros collide
+// with Qt declarations in QDBus, in particular the "True" and "False" names.
+#include <QtCore>
+
+#include <KKeyServer>
diff --git a/base/x11/xcb/qt_types.h b/base/x11/xcb/qt_types.h
index bd1274c7e..3b93f7791 100644
--- a/base/x11/xcb/qt_types.h
+++ b/base/x11/xcb/qt_types.h
@@ -5,7 +5,8 @@
 */
 #pragma once
 
-#include <kkeyserver.h>
+#include "base/os/kkeyserver.h"
+
 #include <xcb/xcb.h>
 
 namespace KWin::base::x11::xcb
diff --git a/input/filters/decoration_event.cpp b/input/filters/decoration_event.cpp
index 8c2c1ecb4..19835d994 100644
--- a/input/filters/decoration_event.cpp
+++ b/input/filters/decoration_event.cpp
@@ -18,6 +18,7 @@
 #include "main.h"
 #include "win/deco.h"
 #include "win/input.h"
+#include "win/space.h"
 
 #include <Wrapland/Server/seat.h>
 #include <Wrapland/Server/touch_pool.h>
diff --git a/input/filters/window_action.cpp b/input/filters/window_action.cpp
index 047631b35..10d4d5c80 100644
--- a/input/filters/window_action.cpp
+++ b/input/filters/window_action.cpp
@@ -15,6 +15,7 @@
 #include "main.h"
 #include "toplevel.h"
 #include "win/input.h"
+#include "win/space.h"
 #include "win/transient.h"
 
 #include <Wrapland/Server/seat.h>
diff --git a/input/x11/window_selector.cpp b/input/x11/window_selector.cpp
index 49614462b..d9d1f43d1 100644
--- a/input/x11/window_selector.cpp
+++ b/input/x11/window_selector.cpp
@@ -19,6 +19,10 @@
 #include "win/x11/window.h"
 #include "win/x11/window_find.h"
 
+// Needs to be included before Xutil, because XLib whose macros collide with Qt declarations in
+// QDBus, in particular the "True" and "False" names.
+#include <QtCore>
+
 #include <X11/Xutil.h>
 #include <X11/cursorfont.h>
 #include <fixx11h.h>
diff --git a/render/x11/shadow.h b/render/x11/shadow.h
index 39973087c..e321d0d3b 100644
--- a/render/x11/shadow.h
+++ b/render/x11/shadow.h
@@ -6,6 +6,7 @@
 */
 #pragma once
 
+#include "base/x11/xcb/atom.h"
 #include "base/x11/xcb/proto.h"
 #include "render/compositor.h"
 #include "render/scene.h"
diff --git a/scripting/effect.cpp b/scripting/effect.cpp
index 29d02679a..824b1b8bc 100644
--- a/scripting/effect.cpp
+++ b/scripting/effect.cpp
@@ -15,6 +15,7 @@
 #include "base/options.h"
 #include "input/platform.h"
 #include "win/screen_edges.h"
+#include "win/space.h"
 
 #include <kwineffects/effect_window.h>
 #include <kwineffects/effects_handler.h>
diff --git a/scripting/window.cpp b/scripting/window.cpp
index 55b86ba46..16c8ce353 100644
--- a/scripting/window.cpp
+++ b/scripting/window.cpp
@@ -14,6 +14,7 @@
 #include "win/desktop_get.h"
 #include "win/meta.h"
 #include "win/screen.h"
+#include "win/space.h"
 #include "win/transient.h"
 #include "win/x11/window.h"
 
diff --git a/win/control.cpp b/win/control.cpp
index 5e8bdcd99..74a7d4394 100644
--- a/win/control.cpp
+++ b/win/control.cpp
@@ -9,6 +9,7 @@
 #include "deco/client_impl.h"
 #include "deco/palette.h"
 #include "deco/window.h"
+#include "space.h"
 #include "stacking.h"
 
 #include <config-kwin.h>
diff --git a/win/dbus/virtual_desktop_manager.h b/win/dbus/virtual_desktop_manager.h
index d5a701a4d..af2ca5842 100644
--- a/win/dbus/virtual_desktop_manager.h
+++ b/win/dbus/virtual_desktop_manager.h
@@ -6,6 +6,7 @@
 */
 #pragma once
 
+#include "kwin_export.h"
 #include "virtual_desktop_types.h"
 
 #include <QObject>
@@ -21,7 +22,7 @@ namespace dbus
 
 // TODO: disable all of this in case of kiosk?
 
-class virtual_desktop_manager : public QObject
+class KWIN_EXPORT virtual_desktop_manager : public QObject
 {
     Q_OBJECT
     Q_CLASSINFO("D-Bus Interface", "org.kde.KWin.VirtualDesktopManager")
diff --git a/win/deco/bridge.h b/win/deco/bridge.h
index 018c4656b..f78ff015c 100644
--- a/win/deco/bridge.h
+++ b/win/deco/bridge.h
@@ -54,17 +54,12 @@ namespace KWin
 
 class Toplevel;
 
-namespace win
-{
-class space;
-}
-
 namespace win::deco
 {
 
 class window;
 
-class bridge_qobject : public QObject
+class KWIN_EXPORT bridge_qobject : public QObject
 {
     Q_OBJECT
 public:
@@ -309,13 +304,13 @@ private:
     {
         const KPluginMetaData metaData = KPluginMetaData::findPluginById(s_pluginName, m_plugin);
         if (!metaData.isValid()) {
-            qCWarning(KWIN_DECORATIONS) << "Could not locate decoration plugin" << m_plugin;
+            qCWarning(KWIN_CORE) << "Could not locate decoration plugin" << m_plugin;
             return;
         }
-        qCDebug(KWIN_DECORATIONS) << "Trying to load decoration plugin: " << metaData.fileName();
+        qCDebug(KWIN_CORE) << "Trying to load decoration plugin: " << metaData.fileName();
         auto factoryResult = KPluginFactory::loadFactory(metaData);
         if (!factoryResult) {
-            qCWarning(KWIN_DECORATIONS) << "Error loading plugin:" << factoryResult.errorText;
+            qCWarning(KWIN_CORE) << "Error loading plugin:" << factoryResult.errorText;
         } else {
             m_factory = factoryResult.plugin;
             loadMetaData(metaData.rawData());
diff --git a/win/deco/settings.h b/win/deco/settings.h
index 469d1228f..e3d99a80f 100644
--- a/win/deco/settings.h
+++ b/win/deco/settings.h
@@ -19,6 +19,8 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *********************************************************************/
 #pragma once
 
+#include "kwin_export.h"
+
 #include <KDecoration2/Private/DecorationSettingsPrivate>
 
 #include <QObject>
@@ -33,7 +35,7 @@ class space;
 namespace deco
 {
 
-class settings : public QObject, public KDecoration2::DecorationSettingsPrivate
+class KWIN_EXPORT settings : public QObject, public KDecoration2::DecorationSettingsPrivate
 {
     Q_OBJECT
 public:
diff --git a/win/input.h b/win/input.h
index 58ded79de..34d16ccae 100644
--- a/win/input.h
+++ b/win/input.h
@@ -10,7 +10,6 @@
 #include "move.h"
 #include "net.h"
 #include "screen.h"
-#include "space.h"
 #include "stacking_order.h"
 #include "toplevel.h"
 #include "types.h"
diff --git a/win/layers.h b/win/layers.h
index d4da5c176..b5c7a7aa7 100644
--- a/win/layers.h
+++ b/win/layers.h
@@ -6,7 +6,6 @@
 #pragma once
 
 #include "net.h"
-#include "space.h"
 #include "transient.h"
 
 #include "toplevel.h"
diff --git a/win/meta.h b/win/meta.h
index 90d04d5b4..fcd54a35a 100644
--- a/win/meta.h
+++ b/win/meta.h
@@ -8,7 +8,6 @@
 #include "control.h"
 #include "net.h"
 #include "remnant.h"
-#include "space.h"
 
 #include "rules/rules.h"
 
diff --git a/win/move.h b/win/move.h
index ff2fd5c0f..9358b03de 100644
--- a/win/move.h
+++ b/win/move.h
@@ -12,7 +12,6 @@
 #include "geo_move.h"
 #include "net.h"
 #include "quicktile.h"
-#include "space.h"
 #include "stacking.h"
 #include "types.h"
 #include "window_area.h"
diff --git a/win/shortcut_set.h b/win/shortcut_set.h
index 28cb57c87..b2e8ab62c 100644
--- a/win/shortcut_set.h
+++ b/win/shortcut_set.h
@@ -6,6 +6,7 @@
 #pragma once
 
 #include "activation.h"
+#include "meta.h"
 #include "shortcut_dialog.h"
 #include "shortcut_set.h"
 
diff --git a/win/space.cpp b/win/space.cpp
index ade63f719..6b4bb9643 100644
--- a/win/space.cpp
+++ b/win/space.cpp
@@ -21,74 +21,6 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *********************************************************************/
 #include "space.h"
 
-#include "activation.h"
-#include "active_window.h"
-#include "deco/bridge.h"
-#include "desktop_space.h"
-#include "output_space.h"
-#include "session.h"
-#include "singleton_interface.h"
-#include "space_areas_helpers.h"
-#include "space_setup.h"
-#include "window_area.h"
-#include "x11/tool_windows.h"
-
-#include "base/dbus/kwin.h"
-#include "base/output_helpers.h"
-#include "base/x11/user_interaction_filter.h"
-#include "base/x11/xcb/extensions.h"
-#include "input/cursor.h"
-#include "main.h"
-#include "render/effects.h"
-#include "render/outline.h"
-#include "render/platform.h"
-#include "render/post/night_color_manager.h"
-#include "rules/rule_book.h"
-#include "rules/rules.h"
-#include "scripting/platform.h"
-#include "utils/blocker.h"
-#include "win/controlling.h"
-#include "win/dbus/appmenu.h"
-#include "win/dbus/virtual_desktop_manager.h"
-#include "win/input.h"
-#include "win/internal_window.h"
-#include "win/kill_window.h"
-#include "win/layers.h"
-#include "win/remnant.h"
-#include "win/screen_edges.h"
-#include "win/setup.h"
-#include "win/shortcut_dialog.h"
-#include "win/stacking.h"
-#include "win/stacking_order.h"
-#include "win/user_actions_menu.h"
-#include "win/util.h"
-#include "win/virtual_desktops.h"
-#include "win/x11/control_create.h"
-#include "win/x11/event.h"
-#include "win/x11/group.h"
-#include "win/x11/moving_window_filter.h"
-#include "win/x11/netinfo.h"
-#include "win/x11/space_areas.h"
-#include "win/x11/space_setup.h"
-#include "win/x11/stacking.h"
-#include "win/x11/sync_alarm_filter.h"
-#include "win/x11/transient.h"
-#include "win/x11/unmanaged.h"
-#include "win/x11/window.h"
-
-#if KWIN_BUILD_TABBOX
-#include "tabbox/tabbox.h"
-#endif
-
-// TODO(romangg): For now this needs to be included late because of some conflict with Qt libraries.
-#include "space_reconfigure.h"
-
-#include <KStartupInfo>
-#include <QAction>
-#include <QtConcurrentRun>
-#include <cassert>
-#include <memory>
-
 namespace KWin::win
 {
 
@@ -102,43 +34,4 @@ void space_qobject::reconfigure()
     reconfigure_callback();
 }
 
-space::space(render::compositor& render)
-    : qobject{std::make_unique<space_qobject>([this] { space_start_reconfigure_timer(*this); })}
-    , outline{std::make_unique<render::outline>(render)}
-    , render{render}
-    , deco{std::make_unique<deco::bridge<space>>(*this)}
-    , appmenu{std::make_unique<dbus::appmenu>(dbus::create_appmenu_callbacks(*this))}
-    , rule_book{std::make_unique<RuleBook>()}
-    , user_actions_menu{std::make_unique<win::user_actions_menu<space>>(*this)}
-    , stacking_order{std::make_unique<win::stacking_order>()}
-    , focus_chain{win::focus_chain<space>(*this)}
-    , virtual_desktop_manager{std::make_unique<win::virtual_desktop_manager>()}
-    , dbus{std::make_unique<base::dbus::kwin_impl<space>>(*this)}
-    , session_manager{std::make_unique<win::session_manager>()}
-{
-    init_space(*this);
-}
-
-space::~space()
-{
-    clear_space(*this);
-}
-
-win::screen_edge* space::create_screen_edge(win::screen_edger& edger)
-{
-    return new win::screen_edge(&edger);
-}
-
-QRect space::get_icon_geometry(Toplevel const* /*win*/) const
-{
-    return QRect();
-}
-
-void space::update_space_area_from_windows(QRect const& /*desktop_area*/,
-                                           std::vector<QRect> const& /*screens_geos*/,
-                                           win::space_areas& /*areas*/)
-{
-    // Can't be pure virtual because the function might be called from the ctor.
-}
-
 }
diff --git a/win/space.h b/win/space.h
index 35c04c60e..f9863086d 100644
--- a/win/space.h
+++ b/win/space.h
@@ -22,15 +22,29 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *********************************************************************/
 #pragma once
 
+#include "appmenu.h"
+#include "dbus/appmenu.h"
+#include "dbus/virtual_desktop_manager.h"
+#include "deco/bridge.h"
 #include "focus_chain.h"
-
-#include "base/options.h"
+#include "kill_window.h"
+#include "screen_edges.h"
+#include "session_manager.h"
+#include "space_areas.h"
+#include "space_reconfigure.h"
+#include "space_setup.h"
+#include "stacking_order.h"
+#include "strut_rect.h"
+#include "user_actions_menu.h"
+
+#include "base/dbus/kwin.h"
 #include "base/output.h"
 #include "base/x11/atoms.h"
-#include "utils/algorithm.h"
-#include "win/session_manager.h"
-#include "win/space_areas.h"
-#include "win/strut_rect.h"
+#include "base/x11/event_filter.h"
+#include "input/redirect.h"
+#include "render/outline.h"
+#include "rules/rule_book.h"
+#include "scripting/platform.h"
 
 #include <QTimer>
 
@@ -39,54 +53,14 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include <memory>
 #include <vector>
 
-class KConfig;
-class KConfigGroup;
 class KStartupInfo;
-class KStartupInfoData;
-class KStartupInfoId;
-class QAction;
-class QStringList;
 
 namespace KWin
 {
 
-class RuleBook;
-
-namespace base
-{
-
-namespace dbus
-{
-template<typename Space>
-class kwin_impl;
-}
-
-namespace x11
-{
-namespace xcb
-{
-class tree;
-class window;
-}
-class event_filter;
-}
-
-}
-
-namespace input
-{
-class redirect;
-}
-
 namespace render
 {
 class compositor;
-class outline;
-}
-
-namespace scripting
-{
-class platform;
 }
 
 class Toplevel;
@@ -94,42 +68,10 @@ class Toplevel;
 namespace win
 {
 
-namespace dbus
-{
-class appmenu;
-}
-
-namespace deco
-{
-template<typename Space>
-class bridge;
-}
-
-namespace x11
-{
-enum class predicate_match;
-class color_mapper;
-class window;
-class group;
-}
-
-enum class activation;
 class internal_window;
-
-template<typename Space>
-class kill_window;
-class screen_edge;
-class screen_edger;
 class shortcut_dialog;
-class stacking_order;
 class tabbox;
 
-template<typename Space>
-class user_actions_menu;
-class virtual_desktop_manager;
-
-class space;
-
 class KWIN_EXPORT space_qobject : public QObject
 {
     Q_OBJECT
@@ -222,8 +164,27 @@ public:
     // Array of the previous restricted areas that window cannot be moved into
     std::vector<win::strut_rects> oldrestrictedmovearea;
 
-    explicit space(render::compositor& render);
-    virtual ~space();
+    explicit space(render::compositor& render)
+        : qobject{std::make_unique<space_qobject>([this] { space_start_reconfigure_timer(*this); })}
+        , outline{std::make_unique<render::outline>(render)}
+        , render{render}
+        , deco{std::make_unique<deco::bridge<space>>(*this)}
+        , appmenu{std::make_unique<dbus::appmenu>(dbus::create_appmenu_callbacks(*this))}
+        , rule_book{std::make_unique<RuleBook>()}
+        , user_actions_menu{std::make_unique<win::user_actions_menu<space>>(*this)}
+        , stacking_order{std::make_unique<win::stacking_order>()}
+        , focus_chain{win::focus_chain<space>(*this)}
+        , virtual_desktop_manager{std::make_unique<win::virtual_desktop_manager>()}
+        , dbus{std::make_unique<base::dbus::kwin_impl<space>>(*this)}
+        , session_manager{std::make_unique<win::session_manager>()}
+    {
+        init_space(*this);
+    }
+
+    virtual ~space()
+    {
+        clear_space(*this);
+    }
 
     /**
      * @brief Finds a Toplevel for the internal window @p w.
@@ -251,15 +212,24 @@ public:
     QTimer* m_quickTileCombineTimer{nullptr};
     win::quicktiles m_lastTilingMode{win::quicktiles::none};
 
-public:
     Toplevel* active_client{nullptr};
 
-    virtual win::screen_edge* create_screen_edge(win::screen_edger& edger);
-    virtual QRect get_icon_geometry(Toplevel const* win) const;
-
-    virtual void update_space_area_from_windows(QRect const& desktop_area,
-                                                std::vector<QRect> const& screens_geos,
-                                                win::space_areas& areas);
+    virtual win::screen_edge* create_screen_edge(win::screen_edger& edger)
+    {
+        return new win::screen_edge(&edger);
+    }
+
+    virtual QRect get_icon_geometry(Toplevel const* /*win*/) const
+    {
+        return {};
+    }
+
+    virtual void update_space_area_from_windows(QRect const& /*desktop_area*/,
+                                                std::vector<QRect> const& /*screens_geos*/,
+                                                win::space_areas& /*areas*/)
+    {
+        // Can't be pure virtual because the function might be called from the ctor.
+    }
 
     QWidget* active_popup{nullptr};
 
diff --git a/win/space_setup.h b/win/space_setup.h
index 88341e976..33950d880 100644
--- a/win/space_setup.h
+++ b/win/space_setup.h
@@ -8,9 +8,9 @@
 #include <config-kwin.h>
 
 #include "dbus/virtual_desktop_manager.h"
+#include "internal_window.h"
 #include "rules.h"
 #include "singleton_interface.h"
-#include "space.h"
 #include "x11/space_setup.h"
 #include "x11/stacking.h"
 
@@ -44,13 +44,13 @@ void init_space(Space& space)
 #endif
 
     QObject::connect(space.qobject.get(),
-                     &space_qobject::currentDesktopChanged,
+                     &Space::qobject_t::currentDesktopChanged,
                      &space.render,
                      &render::compositor::addRepaintFull);
 
     space.deco->init();
     QObject::connect(space.qobject.get(),
-                     &space_qobject::configChanged,
+                     &Space::qobject_t::configChanged,
                      space.deco->qobject.get(),
                      [&] { space.deco->reconfigure(); });
 
diff --git a/win/tabbox/tabbox.cpp b/win/tabbox/tabbox.cpp
index 48eb4a345..447f5bc86 100644
--- a/win/tabbox/tabbox.cpp
+++ b/win/tabbox/tabbox.cpp
@@ -29,6 +29,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "tabbox_logging.h"
 #include "tabbox_x11_filter.h"
 
+#include "base/os/kkeyserver.h"
 #include "base/platform.h"
 #include "base/x11/grabs.h"
 #include "base/x11/xcb/proto.h"
@@ -58,7 +59,6 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include <KGlobalAccel>
 #include <KLazyLocalizedString>
 #include <KLocalizedString>
-#include <kkeyserver.h>
 // X11
 #include <X11/keysym.h>
 #include <X11/keysymdef.h>
diff --git a/win/tabbox/tabbox_x11_filter.cpp b/win/tabbox/tabbox_x11_filter.cpp
index 1a9cfcb1e..fc5335a75 100644
--- a/win/tabbox/tabbox_x11_filter.cpp
+++ b/win/tabbox/tabbox_x11_filter.cpp
@@ -21,14 +21,13 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
 #include "tabbox.h"
 
+#include "base/os/kkeyserver.h"
 #include "base/x11/xcb/proto.h"
 #include "render/compositor.h"
 #include "render/effects.h"
 #include "win/screen_edges.h"
 #include "win/space.h"
 
-#include <KKeyServer>
-
 #include <xcb/xcb.h>
 
 namespace KWin
diff --git a/win/wayland/xwl_window.cpp b/win/wayland/xwl_window.cpp
index 5225cd432..5b1de174c 100644
--- a/win/wayland/xwl_window.cpp
+++ b/win/wayland/xwl_window.cpp
@@ -5,6 +5,8 @@
 */
 #include "xwl_window.h"
 
+#include "space.h"
+
 #include "render/wayland/buffer.h"
 #include "scene.h"
 #include "win/x11/scene.h"
diff --git a/win/x11/color_mapper.cpp b/win/x11/color_mapper.cpp
index f8bfa80bc..ef17d638f 100644
--- a/win/x11/color_mapper.cpp
+++ b/win/x11/color_mapper.cpp
@@ -7,6 +7,8 @@
 
 #include "window.h"
 
+#include "win/space.h"
+
 #include "kwinglobals.h"
 
 namespace KWin::win::x11
diff --git a/win/x11/command.h b/win/x11/command.h
index 60a0d74a8..b303e935e 100644
--- a/win/x11/command.h
+++ b/win/x11/command.h
@@ -6,14 +6,9 @@
 #pragma once
 
 #include "base/options.h"
+#include "base/os/kkeyserver.h"
 #include "main.h"
 
-// Needs to be included before KKeyServer, because KKeyServer includes XLib whose macros collide
-// with Qt declarations in QDBus, in particular the "True" and "False" names.
-#include <QtCore>
-
-#include <KKeyServer>
-
 namespace KWin::win::x11
 {
 
diff --git a/win/x11/event.h b/win/x11/event.h
index f87e36c72..6a4ffeee9 100644
--- a/win/x11/event.h
+++ b/win/x11/event.h
@@ -17,14 +17,13 @@
 #include "user_time.h"
 #include "window_release.h"
 
+#include "base/os/kkeyserver.h"
 #include "base/x11/xcb/qt_types.h"
 #include "win/activation.h"
 #include "win/desktop_space.h"
 #include "win/input.h"
 #include "win/meta.h"
 
-#include <kkeyserver.h>
-
 namespace KWin::win::x11
 {
 
diff --git a/win/x11/moving_window_filter.h b/win/x11/moving_window_filter.h
index b693e4b45..28cd2d489 100644
--- a/win/x11/moving_window_filter.h
+++ b/win/x11/moving_window_filter.h
@@ -7,11 +7,11 @@
 
 #include "base/x11/event_filter.h"
 
+#include "base/os/kkeyserver.h"
 #include "win/x11/event.h"
 #include "win/x11/stacking.h"
 #include "win/x11/window.h"
 
-#include <KKeyServer>
 #include <xcb/xcb.h>
 
 namespace KWin::win::x11
diff --git a/win/x11/placement.h b/win/x11/placement.h
index 1ee699f8e..6b61b431a 100644
--- a/win/x11/placement.h
+++ b/win/x11/placement.h
@@ -9,6 +9,7 @@
 #include "utils/geo.h"
 #include "win/geo.h"
 #include "win/placement.h"
+#include "win/session_manager.h"
 
 #include <KStartupInfo>
 
diff --git a/win/x11/space.cpp b/win/x11/space.cpp
index 09c97af3b..d5395874e 100644
--- a/win/x11/space.cpp
+++ b/win/x11/space.cpp
@@ -55,7 +55,7 @@ space::space(render::compositor& render)
             this->render.reinitialize();
         });
 
-    init_space(*this);
+    x11::init_space(*this);
 }
 
 space::~space()
diff --git a/win/x11/space_setup.h b/win/x11/space_setup.h
index efcc1e52b..e73280246 100644
--- a/win/x11/space_setup.h
+++ b/win/x11/space_setup.h
@@ -23,7 +23,7 @@
 namespace KWin::win::x11
 {
 
-static void select_wm_input_event_mask()
+inline static void select_wm_input_event_mask()
 {
     uint32_t presentMask = 0;
     base::x11::xcb::window_attributes attr(rootWindow());
diff --git a/win/x11/window.cpp b/win/x11/window.cpp
index 905020fe4..17f71a4ff 100644
--- a/win/x11/window.cpp
+++ b/win/x11/window.cpp
@@ -13,6 +13,7 @@
 #include "hide.h"
 #include "maximize.h"
 #include "meta.h"
+#include "space.h"
 #include "transient.h"
 #include "unmanaged.h"
 #include "window_release.h"
-- 
GitLab

