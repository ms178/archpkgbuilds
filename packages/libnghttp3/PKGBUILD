pkgname=libnghttp3
pkgver=1.12.0
pkgrel=2.4
pkgdesc="HTTP/3 library written in C"
url='https://github.com/ngtcp2/nghttp3'
arch=('x86_64')
license=('MIT')
provides=('libnghttp3.so')
depends=('glibc')
makedepends=('git' 'llvm' 'clang' 'openssl')
validpgpkeys=('F4F3B91474D1EB29889BD0EF7E8403D5D673C366') # Tatsuhiro Tsujikawa
source=("https://github.com/ngtcp2/nghttp3/releases/download/v${pkgver}/nghttp3-${pkgver}.tar.xz"{,.asc})
sha256sums=('6cd2c9dc48f308a490469b827da57d281da6c0872c6be5f0a0e9d4d34ea2ad37'
            'SKIP')

prepare() {
  cd nghttp3-${pkgver}
  autoreconf -vfi
}

build() {
  cd nghttp3-${pkgver}

  # PGO directories
  local pgo_dir="$srcdir/pgo-data"
  mkdir -p "$pgo_dir"

  # Store original flags
  local orig_cflags="$CFLAGS"
  local orig_cxxflags="$CXXFLAGS"
  local orig_ldflags="$LDFLAGS"

  # Use clang
  export CC=clang
  export CXX=clang++

  ######################################################################
  # STAGE 1: Standard PGO Instrumentation
  ######################################################################
  msg2 "════════════════════════════════════════════════════════════"
  msg2 "STAGE 1/3: Standard PGO Instrumentation"
  msg2 "════════════════════════════════════════════════════════════"

  export CFLAGS="$orig_cflags -fprofile-generate"
  export CXXFLAGS="$orig_cxxflags -fprofile-generate"
  export LDFLAGS="$orig_ldflags -fprofile-generate"
  export LLVM_PROFILE_FILE="$pgo_dir/stage1-%p-%m.profraw"

  ./configure --prefix=/usr
  make -j"$(nproc)"

  # Run comprehensive QPACK/HTTP3 training workload
  msg2 "Running Stage 1 training workload..."

  # Built-in tests
  msg2 "→ Running built-in tests..."
  make -j1 check 2>&1 | head -100 || true

  # Custom QPACK workload
  if [[ -x examples/qpack ]]; then
    msg2 "→ Running QPACK encoding/decoding workload..."

    local test_dir="$srcdir/test-stage1"
    mkdir -p "$test_dir"
    cd "$test_dir"

    local qpack="$srcdir/nghttp3-${pkgver}/examples/qpack"

    # Helper functions
    add_header() {
      printf '%s\t%s\n' "$2" "$3" >> "$1"
    }

    roundtrip() {
      local file=$1
      local base="${file%.*}"
      "$qpack" encode "$file" "$base.enc" 2>/dev/null || true
      "$qpack" decode "$base.enc" "$base.dec" 2>/dev/null || true
    }

    # Test 1: Typical HTTP/3 headers
    msg2 "  [1/10] Typical HTTP/3 headers..."
    local typical="typical.txt"
    : >"$typical"
    add_header "$typical" :method GET
    add_header "$typical" :scheme https
    add_header "$typical" :path /index.html
    add_header "$typical" :authority localhost:8443
    add_header "$typical" accept 'text/html,application/xhtml+xml'
    add_header "$typical" accept-encoding 'gzip, deflate, br'
    add_header "$typical" user-agent 'Mozilla/5.0'

    for i in {1..10}; do
      roundtrip "$typical"
    done

    # Test 2: Many headers
    msg2 "  [2/10] Many headers..."
    local many="many.txt"
    : >"$many"
    add_header "$many" :method GET
    add_header "$many" :scheme https
    add_header "$many" :path /many.html
    add_header "$many" :authority localhost:8443
    for i in {1..50}; do
      add_header "$many" "x-header-$i" "value-$i"
    done

    for i in {1..5}; do
      roundtrip "$many"
    done

    # Test 3: Large header values
    msg2 "  [3/10] Large header values..."
    local large="large.txt"
    : >"$large"
    add_header "$large" :method POST
    add_header "$large" :scheme https
    add_header "$large" :path /upload
    add_header "$large" :authority localhost:8443
    printf 'x-large\t%s\n' "$(head -c 8192 /dev/zero | tr '\0' 'A')" >> "$large"

    for i in {1..5}; do
      roundtrip "$large"
    done

    # Test 4: Different table capacities
    msg2 "  [4/10] Dynamic table capacities..."
    for cap in 0 256 1024 4096 16384; do
      "$qpack" --max-table-capacity=$cap encode "$typical" "cap_${cap}.enc" 2>/dev/null || true
      "$qpack" --max-table-capacity=$cap decode "cap_${cap}.enc" "cap_${cap}.dec" 2>/dev/null || true
    done

    # Test 5: Blocked streams
    msg2 "  [5/10] Blocked streams..."
    for blk in 0 1 8 16; do
      "$qpack" --max-blocked-streams=$blk encode "$many" "blk_${blk}.enc" 2>/dev/null || true
      "$qpack" --max-blocked-streams=$blk decode "blk_${blk}.enc" "blk_${blk}.dec" 2>/dev/null || true
    done

    # Test 6: Random headers
    msg2 "  [6/10] Random headers..."
    for i in {1..20}; do
      local rnd="rnd_${i}.txt"
      : >"$rnd"
      add_header "$rnd" :method GET
      add_header "$rnd" :scheme https
      add_header "$rnd" :path "/random/$i"
      add_header "$rnd" :authority "example$i.com"

      local num_headers=$((RANDOM % 30 + 5))
      for j in $(seq 1 $num_headers); do
        local val=$(head -c $((RANDOM % 100 + 10)) /dev/urandom | base64 -w0)
        add_header "$rnd" "x-rand-$j" "$val"
      done

      roundtrip "$rnd"
    done

    # Test 7: POST/PUT methods
    msg2 "  [7/10] POST/PUT methods..."
    local post="post.txt"
    : >"$post"
    add_header "$post" :method POST
    add_header "$post" :scheme https
    add_header "$post" :path /api/data
    add_header "$post" :authority api.example.com
    add_header "$post" content-type 'application/json'
    add_header "$post" content-length 1024

    for i in {1..5}; do
      roundtrip "$post"
    done

    # Test 8: Compression patterns
    msg2 "  [8/10] Compression patterns..."
    local comp="compression.txt"
    : >"$comp"
    add_header "$comp" :method GET
    add_header "$comp" :scheme https
    add_header "$comp" :path /compressed
    add_header "$comp" :authority cdn.example.com
    add_header "$comp" accept-encoding 'gzip, br, zstd'

    # Repeated patterns to test HPACK-like compression
    for i in {1..20}; do
      roundtrip "$comp"
    done

    # Test 9: Edge cases
    msg2 "  [9/10] Edge cases..."
    local edge="edge.txt"
    : >"$edge"
    add_header "$edge" :method DELETE
    add_header "$edge" :scheme https
    add_header "$edge" :path /
    add_header "$edge" :authority localhost

    roundtrip "$edge"

    # Empty-ish headers
    local minimal="minimal.txt"
    : >"$minimal"
    add_header "$minimal" :method GET
    add_header "$minimal" :scheme http
    add_header "$minimal" :path /
    add_header "$minimal" :authority localhost

    for i in {1..5}; do
      roundtrip "$minimal"
    done

    # Test 10: Stress test - rapid encoding
    msg2 "  [10/10] Stress test..."
    for i in {1..50}; do
      roundtrip "$typical" &
      [[ $((i % 10)) -eq 0 ]] && sleep 0.1
    done
    wait

    cd "$srcdir/nghttp3-${pkgver}"
    msg2 "✓ Stage 1 QPACK workload complete"
  fi

  # Collect and merge Stage 1 profiles
  msg2 "Collecting Stage 1 profiles..."
  local prof_count=$(find "$pgo_dir" -name "stage1-*.profraw" 2>/dev/null | wc -l)
  msg2 "  Found $prof_count profile files"

  if [[ $prof_count -eq 0 ]]; then
    error "No Stage 1 profiles generated!"
    return 1
  fi

  llvm-profdata merge -output="$pgo_dir/stage1.profdata" "$pgo_dir"/stage1-*.profraw || {
    error "Failed to merge Stage 1 profiles"
    return 1
  }

  msg2 "✓ Stage 1: $(stat -c%s "$pgo_dir/stage1.profdata" 2>/dev/null || echo '0') bytes"

  ######################################################################
  # STAGE 2: Context-Sensitive PGO
  ######################################################################
  msg2 "════════════════════════════════════════════════════════════"
  msg2 "STAGE 2/3: CS-PGO Instrumentation"
  msg2 "════════════════════════════════════════════════════════════"

  make clean

  export CFLAGS="$orig_cflags -fprofile-use=$pgo_dir/stage1.profdata -fcs-profile-generate"
  export CXXFLAGS="$orig_cxxflags -fprofile-use=$pgo_dir/stage1.profdata -fcs-profile-generate"
  export LDFLAGS="$orig_ldflags -fprofile-use=$pgo_dir/stage1.profdata -fcs-profile-generate"
  export LLVM_PROFILE_FILE="$pgo_dir/stage2-%p-%m.profraw"

  ./configure --prefix=/usr
  make -j"$(nproc)"

  # Run abbreviated workload for CS-PGO
  msg2 "Running Stage 2 training workload..."
  make -j1 check 2>&1 | head -50 || true

  if [[ -x examples/qpack ]]; then
    msg2 "→ CS-PGO QPACK tests..."
    cd "$srcdir/test-stage1"  # Reuse test directory

    local qpack="$srcdir/nghttp3-${pkgver}/examples/qpack"

    for test in {1..10}; do
      roundtrip typical.txt
      roundtrip many.txt
    done

    cd "$srcdir/nghttp3-${pkgver}"
  fi

  # Merge CS profiles
  msg2 "Collecting Stage 2 profiles..."
  local cs_count=$(find "$pgo_dir" -name "stage2-*.profraw" 2>/dev/null | wc -l)
  msg2 "  Found $cs_count CS profile files"

  if [[ $cs_count -gt 0 ]]; then
    llvm-profdata merge -output="$pgo_dir/stage2.profdata" "$pgo_dir"/stage2-*.profraw || {
      msg2 "⚠ Failed to merge Stage 2 profiles, using Stage 1"
      cp "$pgo_dir/stage1.profdata" "$pgo_dir/merged.profdata"
    }

    if [[ -f "$pgo_dir/stage2.profdata" ]]; then
      llvm-profdata merge \
        -output="$pgo_dir/merged.profdata" \
        "$pgo_dir/stage1.profdata" \
        "$pgo_dir/stage2.profdata" || {
        msg2 "⚠ Failed to merge combined profiles, using Stage 1"
        cp "$pgo_dir/stage1.profdata" "$pgo_dir/merged.profdata"
      }
      msg2 "✓ Merged: $(stat -c%s "$pgo_dir/merged.profdata" 2>/dev/null || echo '0') bytes"
    fi
  else
    msg2 "⚠ No CS profiles, using Stage 1"
    cp "$pgo_dir/stage1.profdata" "$pgo_dir/merged.profdata"
  fi

  ######################################################################
  # STAGE 3: Final Optimized Build
  ######################################################################
  msg2 "════════════════════════════════════════════════════════════"
  msg2 "STAGE 3/3: Final Optimized Build"
  msg2 "════════════════════════════════════════════════════════════"

  make clean

  unset LLVM_PROFILE_FILE

  export CFLAGS="$orig_cflags -fprofile-use=$pgo_dir/merged.profdata"
  export CXXFLAGS="$orig_cxxflags -fprofile-use=$pgo_dir/merged.profdata"
  export LDFLAGS="$orig_ldflags -fprofile-use=$pgo_dir/merged.profdata"

  ./configure --prefix=/usr
  make -j"$(nproc)"

  msg2 "✓ PGO optimization complete"
  msg2 "════════════════════════════════════════════════════════════"
}

check() {
  cd nghttp3-${pkgver}
  make check
}

package() {
  cd nghttp3-${pkgver}
  make DESTDIR="${pkgdir}" install
  install -Dm644 COPYING "$pkgdir/usr/share/licenses/$pkgname/COPYING"
}

# vim:set sw=2 sts=-1 et:
