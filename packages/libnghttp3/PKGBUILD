pkgname=libnghttp3
pkgver=1.9.0
pkgrel=2.3
pkgdesc="HTTP/3 library written in C"
url='https://github.com/ngtcp2/nghttp3'
arch=('x86_64')
license=('MIT')
provides=('libnghttp3.so')
depends=('glibc')
makedepends=('git' 'llvm' 'clang' 'openssl')
source=("https://github.com/ngtcp2/nghttp3/releases/download/v${pkgver}/nghttp3-${pkgver}.tar.xz"{,.asc})
sha256sums=('SKIP')

prepare() {
  cd nghttp3-${pkgver}
  autoreconf -vfi

  # Create PGO workload script   (outer delimiter must be unique)
  cat > "$srcdir/pgo-workload.sh" << 'PGO_EOF'
#!/bin/bash
set -e

WORKDIR="$1"
BINDIR="$2"
cd "$WORKDIR"

echo "Setting up HTTP/3 QPACK test environment..."

# Generate test files for QPACK testing
echo "Generating test files..."

cat > typical-headers.txt << 'HEADERS'
:method: GET
:scheme: https
:path: /index.html
:authority: localhost:8443
accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
accept-encoding: gzip, deflate, br
accept-language: en-US,en;q=0.5
user-agent: Mozilla/5.0 (X11; Linux x86_64; rv:91.0) Gecko/20100101 Firefox/91.0
HEADERS

cat > large-headers.txt << EOF
:method: GET
:scheme: https
:path: /index.html
:authority: localhost:8443
x-large-header: $(head -c 16000 < /dev/zero | tr '\0' 'A')
EOF

cat > invalid-headers.txt << 'HEADERS'
:method: GET
:scheme: https
:path: /index.html
:authority: localhost:8443
x-broken-header: \xFF\xFF
HEADERS

cat > many-headers.txt << 'HEADERS'
:method: GET
:scheme: https
:path: /index.html
:authority: localhost:8443
accept: text/html
accept-encoding: gzip
accept-language: en-US
user-agent: Mozilla/5.0
x-custom-header-1: value1
x-custom-header-2: value2
x-custom-header-3: value3
x-custom-header-4: value4
x-custom-header-5: value5
x-custom-header-6: value6
x-custom-header-7: value7
x-custom-header-8: value8
x-custom-header-9: value9
x-custom-header-10: value10
HEADERS

echo "Running HTTP/3 QPACK tests..."

QPACK_BIN="$BINDIR/qpack"
[[ -x "$QPACK_BIN" ]] || QPACK_BIN="$BINDIR/nghttp3-qpack"

"$QPACK_BIN" --encode < typical-headers.txt > encoded-typical.bin 2>&1 | tee -a test.log
"$QPACK_BIN" --decode < encoded-typical.bin > decoded-typical.txt 2>&1 | tee -a test.log

"$QPACK_BIN" --encode --max-table-capacity=1024 < typical-headers.txt > encoded-small-table.bin 2>&1 | tee -a test.log
"$QPACK_BIN" --decode --max-table-capacity=1024 < encoded-small-table.bin > decoded-small-table.txt 2>&1 | tee -a test.log

"$QPACK_BIN" --encode --max-table-capacity=8192 < typical-headers.txt > encoded-large-table.bin 2>&1 | tee -a test.log
"$QPACK_BIN" --decode --max-table-capacity=8192 < encoded-large-table.bin > decoded-large-table.txt 2>&1 | tee -a test.log

"$QPACK_BIN" --encode --max-blocked-streams=5 < typical-headers.txt > encoded-blocked.bin 2>&1 | tee -a test.log
"$QPACK_BIN" --decode --max-blocked-streams=5 < encoded-blocked.bin > decoded-blocked.txt 2>&1 | tee -a test.log

"$QPACK_BIN" --encode < large-headers.txt > encoded-large.bin 2>&1 | tee -a test.log || true
"$QPACK_BIN" --decode < encoded-large.bin > decoded-large.txt 2>&1 | tee -a test.log || true

"$QPACK_BIN" --encode < invalid-headers.txt > encoded-invalid.bin 2>&1 | tee -a test.log || true
"$QPACK_BIN" --decode < encoded-invalid.bin > decoded-invalid.txt 2>&1 | tee -a test.log || true

"$QPACK_BIN" --encode < many-headers.txt > encoded-many.bin 2>&1 | tee -a test.log
"$QPACK_BIN" --decode < encoded-many.bin > decoded-many.txt 2>&1 | tee -a test.log

for i in {1..10}; do
    "$QPACK_BIN" --encode < typical-headers.txt > "encoded-seq-$i.bin" 2>&1 | tee -a test.log
    "$QPACK_BIN" --decode < "encoded-seq-$i.bin" > "decoded-seq-$i.txt" 2>&1 | tee -a test.log
done

"$QPACK_BIN" --encode --verbose < typical-headers.txt > encoded-verbose.bin 2>&1 | tee -a test.log
"$QPACK_BIN" --decode --verbose < encoded-verbose.bin > decoded-verbose.txt 2>&1 | tee -a test.log

echo "HTTP/3 QPACK tests completed"
PGO_EOF

  chmod +x "$srcdir/pgo-workload.sh"
}

build() {
  cd nghttp3-${pkgver}

  pgo_dir="$srcdir/pgo-data"
  mkdir -p "${pgo_dir}/standard" "${pgo_dir}/cs"

  orig_cflags="$CFLAGS"
  orig_cxxflags="$CXXFLAGS"
  orig_ldflags="$LDFLAGS"

  export CC=clang
  export CXX=clang++

  # Phase 1: standard instrumentation
  msg2 "== Building with standard PGO instrumentation"
  export CFLAGS="${orig_cflags} -fprofile-generate=${pgo_dir}/standard -g3 -fno-omit-frame-pointer -Xclang -mllvm -Xclang -vp-counters-per-site=50 -Xclang -mllvm -Xclang -runtime-counter-relocation -Xclang -mllvm -Xclang -enable-value-profiling"
  export CXXFLAGS="${orig_cxxflags} -fprofile-generate=${pgo_dir}/standard -g3 -fno-omit-frame-pointer -Xclang -mllvm -Xclang -vp-counters-per-site=50 -Xclang -mllvm -Xclang -runtime-counter-relocation -Xclang -mllvm -Xclang -enable-value-profiling"
  export LDFLAGS="${orig_ldflags} -fprofile-generate=${pgo_dir}/standard -g3 -fno-omit-frame-pointer -Xclang -mllvm -Xclang -vp-counters-per-site=50 -Xclang -mllvm -Xclang -runtime-counter-relocation -Xclang -mllvm -Xclang -enable-value-profiling"

  ./configure --prefix=/usr
  make clean
  make
  make check || true

  msg2 "Running custom workload (standard)"
  mkdir -p "$srcdir/http3-test"
  "$srcdir/pgo-workload.sh" "$srcdir/http3-test" "$(pwd)/examples" || true
  llvm-profdata merge -output="${pgo_dir}/standard.profdata" "${pgo_dir}/standard/"

  # Phase 2: CS instrumentation
  msg2 "== Building with context-sensitive PGO instrumentation"
  export CFLAGS="${orig_cflags} -fprofile-use=${pgo_dir}/standard.profdata -fcs-profile-generate=${pgo_dir}/cs -g3 -fno-omit-frame-pointer -Xclang -mllvm -Xclang -vp-counters-per-site=50 -Xclang -mllvm -Xclang -runtime-counter-relocation -Xclang -mllvm -Xclang -enable-value-profiling"
  export CXXFLAGS="${orig_cxxflags} -fprofile-use=${pgo_dir}/standard.profdata -fcs-profile-generate=${pgo_dir}/cs -g3 -fno-omit-frame-pointer -Xclang -mllvm -Xclang -vp-counters-per-site=50 -Xclang -mllvm -Xclang -runtime-counter-relocation -Xclang -mllvm -Xclang -enable-value-profiling"
  export LDFLAGS="${orig_ldflags} -fprofile-use=${pgo_dir}/standard.profdata -fcs-profile-generate=${pgo_dir}/cs -g3 -fno-omit-frame-pointer -Xclang -mllvm -Xclang -vp-counters-per-site=50 -Xclang -mllvm -Xclang -runtime-counter-relocation -Xclang -mllvm -Xclang -enable-value-profiling"

  ./configure --prefix=/usr
  make clean
  make
  make check || true

  msg2 "Running custom workload (CS)"
  rm -rf "$srcdir/http3-test"
  mkdir -p "$srcdir/http3-test"
  "$srcdir/pgo-workload.sh" "$srcdir/http3-test" "$(pwd)/examples" || true
  llvm-profdata merge -output="${pgo_dir}/merged.profdata" "${pgo_dir}/cs/" "${pgo_dir}/standard.profdata"

  # Phase 3: final optimized build
  msg2 "== Building final optimized version with PGO data"
  export CFLAGS="${orig_cflags} -fprofile-use=${pgo_dir}/merged.profdata"
  export CXXFLAGS="${orig_cxxflags} -fprofile-use=${pgo_dir}/merged.profdata"
  export LDFLAGS="${orig_ldflags} -fprofile-use=${pgo_dir}/merged.profdata"

  ./configure --prefix=/usr
  make clean
  make
}

check() {
  cd nghttp3-${pkgver}
  make check
}

package() {
  cd nghttp3-${pkgver}/lib
  make DESTDIR="${pkgdir}" install
  install -Dm644 ../COPYING -t "${pkgdir}/usr/share/licenses/${pkgname}"
}
