pkgbase=sqlite
pkgname=('sqlite')
_srcver=3500400
pkgver=3.50.4
pkgrel=12.1
pkgdesc="A C library that implements an SQL database engine (PGO + BOLT; advanced instrumentation)"
arch=('x86_64')
license=('LicenseRef-Sqlite')
url="https://www.sqlite.org/"
makedepends=('tcl' 'readline' 'zlib' 'clang' 'llvm' 'lld' 'pigz' 'curl' 'git')
options=('!emptydirs' '!strip' '!lto')
source=(
  "https://www.sqlite.org/2025/sqlite-src-${_srcver}.zip"
  "sqlite-lemon-system-template.patch"
  "license.txt"
  "ClickBench::git+https://github.com/ClickHouse/ClickBench.git"
)
sha256sums=(
  '2d7b032b6fdfe8c442aa809f850687a81d06381deecd7be3312601d28612e640'
  '3dc137fcd7c6acb326af60a61b9844dd15d3773cb05e7a9ce276c41f713d765a'
  '4e57d9ac979f1c9872e69799c2597eeef4c6ce7224f3ede0bf9dc8d217b1e65d'
  'SKIP'
)

# Provide SONAME virtual expected by Arch dependents; plus common virtuals
provides=("libsqlite3.so=0-64" "sqlite=${pkgver}" "sqlite3=${pkgver}")
conflicts=('sqlite')

# Advanced compile-time instrumentation for higher quality PGO
_extra_instr='-g3 -fno-omit-frame-pointer -Xclang -mllvm -Xclang -vp-counters-per-site=150 -Xclang -mllvm -Xclang -runtime-counter-relocation -Xclang -mllvm -Xclang -enable-value-profiling'

# Feature defines (append-only)
_sqlite_cppflags=(
  -DSQLITE_ENABLE_COLUMN_METADATA=1
  -DSQLITE_ENABLE_UNLOCK_NOTIFY
  -DSQLITE_ENABLE_DBSTAT_VTAB=1
  -DSQLITE_ENABLE_FTS3_TOKENIZER=1
  -DSQLITE_ENABLE_FTS3_PARENTHESIS
  -DSQLITE_SECURE_DELETE
  -DSQLITE_ENABLE_STMTVTAB
  -DSQLITE_ENABLE_STAT4
  -DSQLITE_MAX_VARIABLE_NUMBER=250000
  -DSQLITE_MAX_EXPR_DEPTH=10000
  -DSQLITE_ENABLE_MATH_FUNCTIONS
)

# Strip pre-existing -fprofile-* from user flags to avoid mixing passes
_strip_profile_flags() {
  local out=() tok
  for tok in "$@"; do
    case "$tok" in
      -fprofile-generate|-fprofile-generate=*|-fprofile-use|-fprofile-use=*|-fprofile-sample-use=*|-fauto-profile=*|-fcs-profile-generate=*)
        ;;
      *) out+=("$tok");;
    esac
  done
  printf '%s ' "${out[@]}"
}

# optional dataset fetch (set SQLITE_PGO_FETCH=1 to allow network)
_fetch_dataset() {
  local dataset_dir="$srcdir/dataset"
  local gz="$dataset_dir/hits.csv.gz"
  local csv="$dataset_dir/hits.csv"
  mkdir -p "$dataset_dir"
  [[ -f "$csv" ]] && return 0
  if [[ "${SQLITE_PGO_FETCH:-0}" == "1" ]]; then
    echo "Fetching ClickBench hits.csv.gz..."
    curl -L -o "$gz" "https://datasets.clickhouse.com/hits_compatible/hits.csv.gz" || return 1
    pigz -dc -p "$(nproc)" "$gz" > "$csv" || return 1
  fi
  [[ -f "$csv" ]]
}

prepare() {
  cd "$srcdir/sqlite-src-$_srcver"
  patch -Np1 -i "$srcdir/sqlite-lemon-system-template.patch"
  cd "$srcdir"
  rm -rf build-gen build-opt
}

# Build runtime env pointing to build dirs so we use the just-built lib
_env_with_build_libs() {
  local bin_dir="$1"
  local lib_dir="$bin_dir/.libs"
  echo "LD_LIBRARY_PATH=$lib_dir:$bin_dir:${LD_LIBRARY_PATH:-}"
}

# PGO training using dataset if present
_pgo_train_dataset() {
  local sqlite3_bin="$1" dataset="$2" pgo_dir="$3"
  [[ -x "$sqlite3_bin" && -f "$dataset" ]] || return 1
  local env_ld; env_ld="$(_env_with_build_libs "$(dirname "$sqlite3_bin")")"
  local click="$srcdir/ClickBench/sqlite"
  cp -f "$dataset" "$click/hits.csv" || return 1
  pushd "$click" >/dev/null || return 1
  sed -i '/REGEXP_REPLACE/d' queries.sql || true
  rm -f mydb sample.csv
  env $env_ld LLVM_PROFILE_FILE="$pgo_dir/sqlite3.%p.profraw" "$sqlite3_bin" mydb < create.sql
  local LINES="${SQLITE_PGO_SAMPLE_LINES:-2000000}"
  head -n "$LINES" hits.csv > sample.csv
  env $env_ld LLVM_PROFILE_FILE="$pgo_dir/sqlite3.%p.profraw" "$sqlite3_bin" mydb '.import --csv sample.csv hits'
  local TRIES="${SQLITE_PGO_TRIES:-3}"
  while IFS= read -r q; do
    [[ -n "$q" ]] || continue
    sync
    for _ in $(seq 1 "$TRIES"); do
      env $env_ld LLVM_PROFILE_FILE="$pgo_dir/sqlite3.%p.profraw" "$sqlite3_bin" mydb <<<"$q"
    done
  done < queries.sql
  rm -f sample.csv hits.csv
  popd >/dev/null
}

# Synthetic, bounded workload
_pgo_train_synth() {
  local sqlite3_bin="$1" pgo_dir="$2"
  [[ -x "$sqlite3_bin" ]] || return 1
  local env_ld; env_ld="$(_env_with_build_libs "$(dirname "$sqlite3_bin")")"
  local db="train.db"
  rm -f "$db"
  env $env_ld LLVM_PROFILE_FILE="$pgo_dir/sqlite3.%p.profraw" "$sqlite3_bin" "$db" <<'SQL'
PRAGMA journal_mode=WAL;
PRAGMA synchronous=OFF;
CREATE TABLE t(a INTEGER, b TEXT, c REAL, d BLOB);
WITH RECURSIVE cnt(x) AS (VALUES(1) UNION ALL SELECT x+1 FROM cnt LIMIT 100000)
INSERT INTO t(a,b,c,d) SELECT x, printf('row_%d',x), x/3.0, randomblob(16) FROM cnt;
CREATE INDEX i_t_a ON t(a);
CREATE INDEX i_t_b ON t(b);
ANALYZE;
SELECT count(*) FROM t;
SELECT avg(c) FROM t;
SELECT b FROM t WHERE a BETWEEN 100 AND 200 LIMIT 50;
SELECT count(*) FROM t WHERE b LIKE 'row_1%';
SELECT sum(a) FROM t WHERE a < 50000;
SELECT b, count(*) FROM t GROUP BY b HAVING count(*)>0 ORDER BY b LIMIT 100;
BEGIN;
UPDATE t SET c = c + 1.5 WHERE a % 1000 = 0;
DELETE FROM t WHERE a % 12345 = 0;
INSERT INTO t VALUES(999999, 'row_999999', 1.2345, randomblob(16));
COMMIT;
VACUUM;
SQL
  for _ in 1 2; do
    env $env_ld LLVM_PROFILE_FILE="$pgo_dir/sqlite3.%p.profraw" "$sqlite3_bin" "$db" "SELECT sum(a), avg(c) FROM t;"
    env $env_ld LLVM_PROFILE_FILE="$pgo_dir/sqlite3.%p.profraw" "$sqlite3_bin" "$db" "SELECT * FROM t WHERE b LIKE 'row_2%' ORDER BY a DESC LIMIT 200;"
  done
  rm -f "$db"
}

# BOLT training (force loading the instrumented lib via LD_PRELOAD)
_bolt_train() {
  local sqlite3_bin="$1" dataset="$2" lib_preload="$3"
  local env_ld; env_ld="$(_env_with_build_libs "$(dirname "$sqlite3_bin")")"
  local preload_env=""
  if [[ -n "$lib_preload" && -f "$lib_preload" ]]; then
    preload_env="LD_PRELOAD=$lib_preload"
  fi

  if [[ -f "$dataset" ]]; then
    local click="$srcdir/ClickBench/sqlite"
    cp -f "$dataset" "$click/hits.csv" || return 1
    pushd "$click" >/dev/null || return 1
    sed -i '/REGEXP_REPLACE/d' queries.sql || true
    rm -f mydb sample.csv
    env $env_ld $preload_env "$sqlite3_bin" mydb < create.sql
    local LINES="${SQLITE_PGO_SAMPLE_LINES:-2000000}"
    head -n "$LINES" hits.csv > sample.csv
    env $env_ld $preload_env "$sqlite3_bin" mydb '.import --csv sample.csv hits'
    local TRIES="${SQLITE_PGO_TRIES:-3}"
    while IFS= read -r q; do
      [[ -n "$q" ]] || continue
      sync
      for _ in $(seq 1 "$TRIES"); do env $env_ld $preload_env "$sqlite3_bin" mydb <<<"$q"; done
    done < queries.sql
    rm -f sample.csv hits.csv
    popd >/dev/null
  else
    local db="bolttrain.db"
    rm -f "$db"
    env $env_ld $preload_env "$sqlite3_bin" "$db" "CREATE TABLE t(a INT,b TEXT); INSERT INTO t VALUES(1,'a'),(2,'b'); SELECT * FROM t;"
    env $env_ld $preload_env "$sqlite3_bin" "$db" "WITH RECURSIVE c(x) AS (VALUES(1) UNION ALL SELECT x+1 FROM c LIMIT 10000) SELECT sum(x) FROM c;"
    rm -f "$db"
  fi
}

build() {
  export CC=clang
  export AR=llvm-ar
  export NM=llvm-nm
  export RANLIB=llvm-ranlib

  local BASE_CFLAGS; BASE_CFLAGS="$(_strip_profile_flags $CFLAGS)"
  local BASE_LDFLAGS="$LDFLAGS"
  local CPPFLAGS_FEAT="${CPPFLAGS:-} ${_sqlite_cppflags[*]}"

  # PASS 1: instrumented
  local gen_dir="$srcdir/pgo-gen"; mkdir -p "$gen_dir"
  local CFLAGS_GEN="$BASE_CFLAGS ${_extra_instr} -fprofile-generate=$gen_dir"
  local LDFLAGS_GEN="$BASE_LDFLAGS -fprofile-generate=$gen_dir"

  mkdir -p "$srcdir/build-gen"; cd "$srcdir/build-gen"
  CPPFLAGS="$CPPFLAGS_FEAT" CFLAGS="$CFLAGS_GEN" LDFLAGS="$LDFLAGS_GEN" \
  "$srcdir/sqlite-src-$_srcver/configure" \
    --prefix=/usr \
    --disable-static \
    --enable-fts4 \
    --enable-fts5 \
    --enable-rtree \
    --enable-readline
  make -j"$(nproc)"

  echo "==> PGO training..."
  _fetch_dataset || true
  local sqlite3_gen="$PWD/sqlite3"
  local dataset_csv="$srcdir/dataset/hits.csv"
  if [[ -f "$dataset_csv" ]]; then
    _pgo_train_dataset "$sqlite3_gen" "$dataset_csv" "$gen_dir" || _pgo_train_synth "$sqlite3_gen" "$gen_dir"
  else
    _pgo_train_synth "$sqlite3_gen" "$gen_dir"
  fi

  if compgen -G "$gen_dir"/*.profraw >/dev/null; then
    llvm-profdata merge -o "$srcdir/pgo-merged.profdata" "$gen_dir"/*.profraw
  else
    echo "Warning: no PGO .profraw; continuing without profile-use."
    : > "$srcdir/pgo-merged.profdata" || true
  fi

  # PASS 2: optimized with emit-relocs (propagates via LDFLAGS to both binary and lib)
  cd "$srcdir"; mkdir -p "$srcdir/build-opt"; cd "$srcdir/build-opt"
  local CFLAGS_USE="$BASE_CFLAGS"
  local LDFLAGS_USE="$BASE_LDFLAGS -Wl,--emit-relocs"
  if [[ -s "$srcdir/pgo-merged.profdata" ]]; then
    CFLAGS_USE+=" -fprofile-use=$srcdir/pgo-merged.profdata -Wno-profile-instr-out-of-date -Wno-profile-instr-missing"
    LDFLAGS_USE+=" -fprofile-use=$srcdir/pgo-merged.profdata"
  fi

  CPPFLAGS="$CPPFLAGS_FEAT" CFLAGS="$CFLAGS_USE" LDFLAGS="$LDFLAGS_USE" \
  "$srcdir/sqlite-src-$_srcver/configure" \
    --prefix=/usr \
    --disable-static \
    --enable-fts4 \
    --enable-fts5 \
    --enable-rtree \
    --enable-readline
  make -j"$(nproc)"
  make -j"$(nproc)" dbdump dbhash dbtotxt index_usage scrub showdb showjournal showshm showstat4 showwal sqldiff sqlite3_analyzer sqlite3_checker || true

  # ---------------- BOLT both sqlite3 and libsqlite3.so ----------------
  if command -v llvm-bolt >/dev/null 2>&1; then
    echo "==> BOLT: instrumenting & optimizing sqlite3 and libsqlite3.so"
    local bolt_dir="$srcdir/bolt"; mkdir -p "$bolt_dir"
    cd "$srcdir/build-opt"

    # locate the real shared object under .libs
    local lib_real
    lib_real="$(readlink -f libsqlite3.so 2>/dev/null || true)"
    [[ -z "$lib_real" || ! -f "$lib_real" ]] && lib_real="$(find . -path './.libs/libsqlite3.so*' -type f -print -quit 2>/dev/null || true)"

    cp -f sqlite3 "$bolt_dir/sqlite3.orig"
    [[ -n "$lib_real" ]] && cp -f "$lib_real" "$bolt_dir/libsqlite3.so.orig"

    # Instrument each with separate fdata files (baked-in paths)
    if llvm-bolt sqlite3 \
          --relocs --lite=false \
          --instrument --instrumentation-file="$bolt_dir/sqlite3.fdata" --instrumentation-file-append-pid \
          -o "$bolt_dir/sqlite3.inst"; then
      install -m755 "$bolt_dir/sqlite3.inst" sqlite3
    else
      echo "BOLT: instrumentation failed for sqlite3; skipping BOLT."
      return 0
    fi

    local lib_present=0
    if [[ -n "$lib_real" && -f "$lib_real" ]]; then
      lib_present=1
      if llvm-bolt "$lib_real" \
            --relocs --lite=false \
            --instrument --instrumentation-file="$bolt_dir/libsqlite3.fdata" --instrumentation-file-append-pid \
            -o "$bolt_dir/libsqlite3.so.inst"; then
        install -m755 "$bolt_dir/libsqlite3.so.inst" "$lib_real"
      else
        echo "BOLT: instrumentation failed for libsqlite3.so; continuing without lib."
        lib_present=0
        [[ -f "$bolt_dir/libsqlite3.so.orig" ]] && install -m755 "$bolt_dir/libsqlite3.so.orig" "$lib_real"
      fi
    fi

    # Training (force loading instrumented lib via LD_PRELOAD)
    _bolt_train "$PWD/sqlite3" "$dataset_csv" "$lib_real" || true

    # Merge fdata shards (sqlite3)
    local merged_sqlite3="$bolt_dir/sqlite3.merged.fdata"
    if compgen -G "$bolt_dir/sqlite3.fdata".* >/dev/null; then
      if command -v merge-fdata >/dev/null 2>&1; then
        merge-fdata "$bolt_dir/sqlite3.fdata".* -o "$merged_sqlite3" || true
      else
        cat "$bolt_dir/sqlite3.fdata".* > "$merged_sqlite3" || true
      fi
    elif [[ -s "$bolt_dir/sqlite3.fdata" ]]; then
      cp -f "$bolt_dir/sqlite3.fdata" "$merged_sqlite3"
    fi

    # Merge fdata shards (lib)
    local merged_lib="$bolt_dir/libsqlite3.merged.fdata"
    if [[ $lib_present -eq 1 ]]; then
      if compgen -G "$bolt_dir/libsqlite3.fdata".* >/dev/null; then
        if command -v merge-fdata >/dev/null 2>&1; then
          merge-fdata "$bolt_dir/libsqlite3.fdata".* -o "$merged_lib" || true
        else
          cat "$bolt_dir/libsqlite3.fdata".* > "$merged_lib" || true
        fi
      elif [[ -s "$bolt_dir/libsqlite3.fdata" ]]; then
        cp -f "$bolt_dir/libsqlite3.fdata" "$merged_lib"
      fi
    fi

    # Optimize sqlite3 with its profile and install back
    if [[ -s "$merged_sqlite3" ]]; then
      local bolt_help; bolt_help="$(llvm-bolt --help 2>&1 || true)"
      local align_flags=(--align-blocks)
      grep -q -- '--block-alignment' <<<"$bolt_help" && align_flags=(--align-blocks --block-alignment=32)
      if llvm-bolt "$bolt_dir/sqlite3.orig" \
            --relocs --data="$merged_sqlite3" \
            --reorder-blocks=ext-tsp --reorder-functions=cdsort \
            --split-functions --split-strategy=cdsplit \
            --icf=all --jump-tables=move --peepholes=all \
            --reg-reassign --use-aggr-reg-reassign \
            "${align_flags[@]}" --dyno-stats \
            -o "$bolt_dir/sqlite3.bolt"; then
        install -m755 "$bolt_dir/sqlite3.bolt" sqlite3
      else
        echo "BOLT: sqlite3 optimization failed; restoring PGO binary"
        install -m755 "$bolt_dir/sqlite3.orig" sqlite3
      fi
    else
      echo "BOLT: no sqlite3 fdata; restoring PGO binary"
      install -m755 "$bolt_dir/sqlite3.orig" sqlite3
    fi

    # Optimize lib with its own profile (if present) and install to the real .libs path
    if [[ $lib_present -eq 1 && -s "$merged_lib" ]]; then
      if llvm-bolt "$bolt_dir/libsqlite3.so.orig" \
            --relocs --data="$merged_lib" \
            --reorder-blocks=ext-tsp --reorder-functions=cdsort \
            --split-functions --split-strategy=cdsplit \
            --icf=all --jump-tables=move --peepholes=all \
            --reg-reassign --use-aggr-reg-reassign \
            "${align_flags[@]}" --dyno-stats \
            -o "$bolt_dir/libsqlite3.so.bolt"; then
        install -m755 "$bolt_dir/libsqlite3.so.bolt" "$lib_real"
      else
        echo "BOLT: lib optimization failed; restoring PGO DSO"
        install -m755 "$bolt_dir/libsqlite3.so.orig" "$lib_real"
      fi
    elif [[ $lib_present -eq 1 ]]; then
      echo "BOLT: no lib fdata; restoring PGO DSO"
      install -m755 "$bolt_dir/libsqlite3.so.orig" "$lib_real"
    fi
  fi
}

package() {
  cd "$srcdir/build-opt"
  make DESTDIR="${pkgdir}" install

  install -m755 -d "${pkgdir}"/usr/share/man/man1
  install -m644 "$srcdir/sqlite-src-$_srcver/sqlite3.1" "${pkgdir}"/usr/share/man/man1/

  # Manual strip (since !strip)
  find "${pkgdir}" -type f KATEX_INLINE_OPEN -name '*.so*' -o -name 'sqlite3' -o -executable KATEX_INLINE_CLOSE -print0 \
    | xargs -0 --no-run-if-empty llvm-strip --strip-unneeded 2>/dev/null || true

  install -D -m644 "${srcdir}/license.txt" "${pkgdir}/usr/share/licenses/${pkgbase}/license.txt"
}
