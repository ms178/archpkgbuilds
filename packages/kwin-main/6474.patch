From a53733caccebf9aa73ea50bee3898a1aecbb9eae Mon Sep 17 00:00:00 2001
From: David Redondo <kde@david-redondo.de>
Date: Fri, 12 Jul 2024 11:11:34 +0200
Subject: [PATCH 1/5] Allow passing extra environment variables to Xwayland

---
 src/main_wayland.cpp              | 1 +
 src/main_wayland.h                | 5 +++++
 src/xwayland/xwaylandlauncher.cpp | 9 +++++++++
 src/xwayland/xwaylandlauncher.h   | 4 ++++
 4 files changed, 19 insertions(+)

diff --git a/src/main_wayland.cpp b/src/main_wayland.cpp
index 26d51b4..85b0777 100644
--- a/src/main_wayland.cpp
+++ b/src/main_wayland.cpp
@@ -162,6 +162,7 @@ void ApplicationWayland::performStartup()
         m_xwayland->xwaylandLauncher()->setListenFDs(m_xwaylandListenFds);
         m_xwayland->xwaylandLauncher()->setDisplayName(m_xwaylandDisplay);
         m_xwayland->xwaylandLauncher()->setXauthority(m_xwaylandXauthority);
+        m_xwayland->xwaylandLauncher()->addEnvironmentVariables(m_xwaylandExtraEnvironment);
         m_xwayland->init();
         connect(m_xwayland.get(), &Xwl::Xwayland::started, this, &ApplicationWayland::applyXwaylandScale);
     }
diff --git a/src/main_wayland.h b/src/main_wayland.h
index 5f5408a..c4686dc 100644
--- a/src/main_wayland.h
+++ b/src/main_wayland.h
@@ -42,6 +42,10 @@ public:
     {
         m_xwaylandXauthority = xauthority;
     }
+    void addExtraXWaylandEnvrionmentVariable(const QString &variable, const QString &value)
+    {
+        m_xwaylandExtraEnvironment.insert(variable, value);
+    }
     XwaylandInterface *xwayland() const override;
 #endif
     void setApplicationsToStart(const QStringList &applications)
@@ -74,6 +78,7 @@ private:
     QList<int> m_xwaylandListenFds;
     QString m_xwaylandDisplay;
     QString m_xwaylandXauthority;
+    QMap<QString, QString> m_xwaylandExtraEnvironment;
 #endif
     KConfigWatcher::Ptr m_settingsWatcher;
 };
diff --git a/src/xwayland/xwaylandlauncher.cpp b/src/xwayland/xwaylandlauncher.cpp
index ab27713..1621a6f 100644
--- a/src/xwayland/xwaylandlauncher.cpp
+++ b/src/xwayland/xwaylandlauncher.cpp
@@ -72,6 +72,11 @@ void XwaylandLauncher::setXauthority(const QString &xauthority)
     m_xAuthority = xauthority;
 }
 
+void XwaylandLauncher::addEnvironmentVariables(const QMap<QString, QString> &extraEnvironment)
+{
+    m_extraEnvironment.insert(extraEnvironment);
+}
+
 void XwaylandLauncher::enable()
 {
     if (m_enabled) {
@@ -176,6 +181,10 @@ bool XwaylandLauncher::start()
         env.insert("WAYLAND_DEBUG", QByteArrayLiteral("1"));
     }
 
+    for (const auto &[variable, value] : m_extraEnvironment.asKeyValueRange()) {
+        env.insert(variable, value);
+    }
+
     m_xwaylandProcess = new QProcess(this);
     m_xwaylandProcess->setProgram(QStandardPaths::findExecutable("Xwayland"));
     m_xwaylandProcess->setArguments(arguments);
diff --git a/src/xwayland/xwaylandlauncher.h b/src/xwayland/xwaylandlauncher.h
index 7e54d65..e499800 100644
--- a/src/xwayland/xwaylandlauncher.h
+++ b/src/xwayland/xwaylandlauncher.h
@@ -13,6 +13,7 @@
 #include "utils/filedescriptor.h"
 
 #include <QList>
+#include <QMap>
 #include <QObject>
 #include <QProcess>
 #include <QSocketNotifier>
@@ -58,6 +59,8 @@ public:
      */
     void setXauthority(const QString &xauthority);
 
+    void addEnvironmentVariables(const QMap<QString, QString> &extraEnvironment);
+
     void enable();
     void disable();
     bool start();
@@ -103,6 +106,7 @@ private:
     QList<int> m_listenFds;
     QString m_displayName;
     QString m_xAuthority;
+    QMap<QString, QString> m_extraEnvironment;
 
     bool m_enabled = false;
     int m_crashCount = 0;
-- 
2.48.1


From a6f5639b6664e5e592c19b2c367eb1f4e0631e76 Mon Sep 17 00:00:00 2001
From: David Redondo <kde@david-redondo.de>
Date: Tue, 30 Jul 2024 14:35:30 +0200
Subject: [PATCH 2/5] Allow specifying file descriptors that are passed to
 Xwayland

---
 src/main_wayland.cpp              |  1 +
 src/main_wayland.h                |  9 +++++++++
 src/xwayland/xwaylandlauncher.cpp | 13 +++++++++++++
 src/xwayland/xwaylandlauncher.h   |  3 +++
 4 files changed, 26 insertions(+)

diff --git a/src/main_wayland.cpp b/src/main_wayland.cpp
index 85b0777..f961760 100644
--- a/src/main_wayland.cpp
+++ b/src/main_wayland.cpp
@@ -163,6 +163,7 @@ void ApplicationWayland::performStartup()
         m_xwayland->xwaylandLauncher()->setDisplayName(m_xwaylandDisplay);
         m_xwayland->xwaylandLauncher()->setXauthority(m_xwaylandXauthority);
         m_xwayland->xwaylandLauncher()->addEnvironmentVariables(m_xwaylandExtraEnvironment);
+        m_xwayland->xwaylandLauncher()->passFileDescriptors(std::move(m_xwaylandFds));
         m_xwayland->init();
         connect(m_xwayland.get(), &Xwl::Xwayland::started, this, &ApplicationWayland::applyXwaylandScale);
     }
diff --git a/src/main_wayland.h b/src/main_wayland.h
index c4686dc..b7ea152 100644
--- a/src/main_wayland.h
+++ b/src/main_wayland.h
@@ -11,6 +11,10 @@
 #include <KConfigWatcher>
 #include <QTimer>
 
+#include "utils/filedescriptor.h"
+
+#include <vector>
+
 namespace KWin
 {
 namespace Xwl
@@ -46,6 +50,10 @@ public:
     {
         m_xwaylandExtraEnvironment.insert(variable, value);
     }
+    void passFdToXwayland(FileDescriptor &&fd)
+    {
+        m_xwaylandFds.push_back(std::move(fd));
+    }
     XwaylandInterface *xwayland() const override;
 #endif
     void setApplicationsToStart(const QStringList &applications)
@@ -79,6 +87,7 @@ private:
     QString m_xwaylandDisplay;
     QString m_xwaylandXauthority;
     QMap<QString, QString> m_xwaylandExtraEnvironment;
+    std::vector<FileDescriptor> m_xwaylandFds;
 #endif
     KConfigWatcher::Ptr m_settingsWatcher;
 };
diff --git a/src/xwayland/xwaylandlauncher.cpp b/src/xwayland/xwaylandlauncher.cpp
index 1621a6f..da7ba01 100644
--- a/src/xwayland/xwaylandlauncher.cpp
+++ b/src/xwayland/xwaylandlauncher.cpp
@@ -37,6 +37,7 @@
 #include <cerrno>
 #include <cstring>
 #include <fcntl.h>
+#include <ranges>
 #include <sys/socket.h>
 #include <unistd.h>
 
@@ -77,6 +78,14 @@ void XwaylandLauncher::addEnvironmentVariables(const QMap<QString, QString> &ext
     m_extraEnvironment.insert(extraEnvironment);
 }
 
+void XwaylandLauncher::passFileDescriptors(std::vector<FileDescriptor> &&fds)
+{
+    m_fdsToPreserve.reserve(m_fdsToPreserve.size() + fds.size());
+    for (auto & fd : fds) {
+        m_fdsToPreserve.emplace_back(std::move(fd));
+    }
+}
+
 void XwaylandLauncher::enable()
 {
     if (m_enabled) {
@@ -191,6 +200,10 @@ bool XwaylandLauncher::start()
     m_xwaylandProcess->setProcessChannelMode(QProcess::ForwardedErrorChannel);
     m_xwaylandProcess->setProcessEnvironment(env);
     m_xwaylandProcess->setChildProcessModifier([this, fdsToPass]() {
+        for (const auto &fd : m_fdsToPreserve) {
+            int flags = fcntl(fd.get(), F_GETFD);
+            fcntl(fd.get(), F_SETFD, flags & ~FD_CLOEXEC);
+        }
         for (const int &fd : fdsToPass) {
             const int originalFlags = fcntl(fd, F_GETFD);
             if (originalFlags < 0) {
diff --git a/src/xwayland/xwaylandlauncher.h b/src/xwayland/xwaylandlauncher.h
index e499800..df5d3be 100644
--- a/src/xwayland/xwaylandlauncher.h
+++ b/src/xwayland/xwaylandlauncher.h
@@ -61,6 +61,8 @@ public:
 
     void addEnvironmentVariables(const QMap<QString, QString> &extraEnvironment);
 
+    void passFileDescriptors(std::vector<FileDescriptor> &&fds);
+
     void enable();
     void disable();
     bool start();
@@ -107,6 +109,7 @@ private:
     QString m_displayName;
     QString m_xAuthority;
     QMap<QString, QString> m_extraEnvironment;
+    std::vector<FileDescriptor> m_fdsToPreserve;
 
     bool m_enabled = false;
     int m_crashCount = 0;
-- 
2.48.1


From fce5bad8cd526f7bf6caf3fa2bee9b36d181af2b Mon Sep 17 00:00:00 2001
From: David Redondo <kde@david-redondo.de>
Date: Fri, 12 Jul 2024 14:58:34 +0200
Subject: [PATCH 3/5] Enable Xwayland xtest input emulation without going
 through the portal

Due to the limited libei(s) API a trick is used. Let it create
a socket with an absolute path, open that path again to get a fd
referring to the socket, unlink the file and specify the socket
that Xwayland should use in the form of /proc/self/fd/$fd.
---
 src/plugins/eis/eisbackend.cpp    | 34 +++++++++++++++++++++++++++----
 src/plugins/eis/eisbackend.h      |  6 ++++--
 src/plugins/eis/eiscontext.cpp    | 30 +++++++++++++++++++--------
 src/plugins/eis/eiscontext.h      | 26 ++++++++++++++++++-----
 src/xwayland/xwaylandlauncher.cpp |  3 ---
 5 files changed, 76 insertions(+), 23 deletions(-)

diff --git a/src/plugins/eis/eisbackend.cpp b/src/plugins/eis/eisbackend.cpp
index 43eca32..e1c2547 100644
--- a/src/plugins/eis/eisbackend.cpp
+++ b/src/plugins/eis/eisbackend.cpp
@@ -14,7 +14,7 @@
 #include "input.h"
 #include "keyboard_input.h"
 #include "keyboard_layout.h"
-#include "main.h"
+#include "main_wayland.h"
 #include "workspace.h"
 #include "xkb.h"
 
@@ -26,19 +26,45 @@
 
 #include <libeis.h>
 
+#include <fcntl.h>
+
 #include <ranges>
 
 namespace KWin
 {
 
+#define typeName(T)                                       \
+    [] {                                                  \
+        static_assert(                                    \
+            requires { typename T; }, "T is not a type"); \
+        return #T;                                        \
+        }()
+
 EisBackend::EisBackend(QObject *parent)
     : KWin::InputBackend(parent)
     , m_serviceWatcher(new QDBusServiceWatcher(this))
+
 {
+#if HAVE_XWAYLAND_ENABLE_EI_PORTAL
+    if (kwinApp()->operationMode() == Application::OperationModeWayland) {
+        // Unfortunately there is no way to pass a connected socket fd to libei like WAYLAND_SOCKET
+        // in libwayland so we are resorting to this hack
+        // https://gitlab.freedesktop.org/libinput/libei/-/issues/63
+        m_xWaylandContext = std::make_unique<XWaylandEisContext>(this);
+        FileDescriptor fd(open(m_xWaylandContext->socketName.constData(), O_PATH | O_CLOEXEC));
+        unlink(m_xWaylandContext->socketName.constData());
+        if (QByteArray(kwinApp()->metaObject()->className()) == typeName(KWin::ApplicationWayland)) {
+            auto appWayland = static_cast<ApplicationWayland *>(kwinApp());
+            appWayland->addExtraXWaylandEnvrionmentVariable(QStringLiteral("LIBEI_SOCKET"), QStringLiteral("/proc/self/fd/%1").arg(fd.get()));
+            appWayland->passFdToXwayland(std::move(fd));
+        }
+    }
+#endif
+
     m_serviceWatcher->setConnection(QDBusConnection::sessionBus());
     m_serviceWatcher->setWatchMode(QDBusServiceWatcher::WatchForUnregistration);
     connect(m_serviceWatcher, &QDBusServiceWatcher::serviceUnregistered, this, [this](const QString &service) {
-        std::erase_if(m_contexts, [&service](const std::unique_ptr<EisContext> &context) {
+        std::erase_if(m_contexts, [&service](const std::unique_ptr<DbusEisContext> &context) {
             return context->dbusService == service;
         });
         m_serviceWatcher->removeWatchedService(service);
@@ -92,14 +118,14 @@ QDBusUnixFileDescriptor EisBackend::connectToEIS(const int &capabilities, int &c
     const QString dbusService = message().service();
     static int s_cookie = 0;
     cookie = ++s_cookie;
-    m_contexts.push_back(std::make_unique<EisContext>(this, eisCapabilities, cookie, dbusService));
+    m_contexts.push_back(std::make_unique<DbusEisContext>(this, eisCapabilities, cookie, dbusService));
     m_serviceWatcher->addWatchedService(dbusService);
     return QDBusUnixFileDescriptor(m_contexts.back()->addClient());
 }
 
 void EisBackend::disconnect(int cookie)
 {
-    auto it = std::ranges::find(m_contexts, cookie, [](const std::unique_ptr<EisContext> &context) {
+    auto it = std::ranges::find(m_contexts, cookie, [](const std::unique_ptr<DbusEisContext> &context) {
         return context->cookie;
     });
     if (it != std::ranges::end(m_contexts)) {
diff --git a/src/plugins/eis/eisbackend.h b/src/plugins/eis/eisbackend.h
index a34d403..f04282e 100644
--- a/src/plugins/eis/eisbackend.h
+++ b/src/plugins/eis/eisbackend.h
@@ -24,7 +24,8 @@ class QDBusServiceWatcher;
 
 namespace KWin
 {
-class EisContext;
+class DbusEisContext;
+class XWaylandEisContext;
 
 class EisBackend : public KWin::InputBackend, public QDBusContext
 {
@@ -46,7 +47,8 @@ public:
 private:
     QDBusServiceWatcher *m_serviceWatcher;
     RamFile m_keymapFile;
-    std::vector<std::unique_ptr<EisContext>> m_contexts;
+    std::unique_ptr<XWaylandEisContext> m_xWaylandContext;
+    std::vector<std::unique_ptr<DbusEisContext>> m_contexts;
 };
 
 }
diff --git a/src/plugins/eis/eiscontext.cpp b/src/plugins/eis/eiscontext.cpp
index 015e041..c312f1e 100644
--- a/src/plugins/eis/eiscontext.cpp
+++ b/src/plugins/eis/eiscontext.cpp
@@ -52,15 +52,32 @@ public:
     std::unique_ptr<EisDevice> keyboard;
 };
 
-EisContext::EisContext(KWin::EisBackend *backend, QFlags<eis_device_capability> allowedCapabilities, int cookie, const QString &dbusService)
-    : cookie(cookie)
+DbusEisContext::DbusEisContext(KWin::EisBackend *backend, QFlags<eis_device_capability> allowedCapabilities, int cookie, const QString &dbusService)
+    : EisContext(backend, allowedCapabilities)
+    , cookie(cookie)
     , dbusService(dbusService)
+{
+    eis_setup_backend_fd(m_eisContext);
+}
+
+int DbusEisContext::addClient()
+{
+    return eis_backend_fd_add_client(m_eisContext);
+}
+
+XWaylandEisContext::XWaylandEisContext(KWin::EisBackend *backend)
+    : EisContext(backend, {EIS_DEVICE_CAP_POINTER | EIS_DEVICE_CAP_POINTER_ABSOLUTE | EIS_DEVICE_CAP_KEYBOARD | EIS_DEVICE_CAP_TOUCH | EIS_DEVICE_CAP_SCROLL | EIS_DEVICE_CAP_BUTTON})
+    , socketName(qgetenv("XDG_RUNTIME_DIR") + QByteArrayLiteral("/kwin-xwayland-eis-socket.") + QByteArray::number(getpid()))
+{
+    eis_setup_backend_socket(m_eisContext, socketName.constData());
+}
+
+EisContext::EisContext(KWin::EisBackend *backend, QFlags<eis_device_capability> allowedCapabilities)
+    : m_eisContext(eis_new(this))
     , m_backend(backend)
-    , m_eisContext(eis_new(this))
     , m_allowedCapabilities(allowedCapabilities)
     , m_socketNotifier(eis_get_fd(m_eisContext), QSocketNotifier::Read)
 {
-    eis_setup_backend_fd(m_eisContext);
     eis_log_set_priority(m_eisContext, EIS_LOG_PRIORITY_DEBUG);
     eis_log_set_handler(m_eisContext, eis_log_handler);
     QObject::connect(&m_socketNotifier, &QSocketNotifier::activated, [this] {
@@ -101,11 +118,6 @@ void EisContext::updateKeymap()
     }
 }
 
-int EisContext::addClient()
-{
-    return eis_backend_fd_add_client(m_eisContext);
-}
-
 static std::chrono::microseconds currentTime()
 {
     return std::chrono::duration_cast<std::chrono::microseconds>(std::chrono::steady_clock::now().time_since_epoch());
diff --git a/src/plugins/eis/eiscontext.h b/src/plugins/eis/eiscontext.h
index fd8f676..50de947 100644
--- a/src/plugins/eis/eiscontext.h
+++ b/src/plugins/eis/eiscontext.h
@@ -24,24 +24,40 @@ struct EisClient;
 class EisContext
 {
 public:
-    EisContext(EisBackend *backend, QFlags<eis_device_capability> allowedCapabilities, int cookie, const QString &dbusService);
+    EisContext(EisBackend *backend, QFlags<eis_device_capability> allowedCapabilities);
     ~EisContext();
 
-    int addClient();
     void updateScreens();
     void updateKeymap();
 
-    const int cookie;
-    const QString dbusService;
+protected:
+    eis *m_eisContext;
 
 private:
     void handleEvents();
 
     EisBackend *m_backend;
-    eis *m_eisContext;
     QFlags<eis_device_capability> m_allowedCapabilities;
     QSocketNotifier m_socketNotifier;
     std::vector<std::unique_ptr<EisClient>> m_clients;
 };
 
+class DbusEisContext : public EisContext
+{
+public:
+    DbusEisContext(EisBackend *backend, QFlags<eis_device_capability> allowedCapabilities, int cookie, const QString &dbusService);
+
+    int addClient();
+
+    const int cookie;
+    const QString dbusService;
+};
+
+class XWaylandEisContext : public EisContext
+{
+public:
+    XWaylandEisContext(EisBackend *backend);
+
+    const QByteArray socketName;
+};
 }
diff --git a/src/xwayland/xwaylandlauncher.cpp b/src/xwayland/xwaylandlauncher.cpp
index da7ba01..195000f 100644
--- a/src/xwayland/xwaylandlauncher.cpp
+++ b/src/xwayland/xwaylandlauncher.cpp
@@ -177,9 +177,6 @@ bool XwaylandLauncher::start()
     fdsToPass << wmfd->fds[1].get();
 
     arguments << QStringLiteral("-rootless");
-#if HAVE_XWAYLAND_ENABLE_EI_PORTAL
-    arguments << QStringLiteral("-enable-ei-portal");
-#endif
 
     QProcessEnvironment env = QProcessEnvironment::systemEnvironment();
 
-- 
2.48.1


From 563719694984e91189e9f2ee0b68c2cd98c48a91 Mon Sep 17 00:00:00 2001
From: David Redondo <kde@david-redondo.de>
Date: Fri, 12 Jul 2024 15:55:59 +0200
Subject: [PATCH 4/5] Add option to control whether xwayland xtest will prompt
 or not

Users may want to enable this for example if they often use things
which rely on xtest.
Instead of the portal showing a dialog, KWin will show a dialog
when it should ask.
This approach allows us even to show more information to the user
as we can get the client binary name from the eis client compared
to the portal which receives nothing.
Because the Options class does not write through to the config file
seperate Settings class is generated.
---
 src/kcms/xwayland/kwinxwaylandsettings.kcfg |  3 +
 src/kcms/xwayland/ui/main.qml               | 14 ++++
 src/kwin.kcfg                               |  3 +
 src/options.cpp                             | 11 +++
 src/options.h                               | 11 +++
 src/plugins/eis/CMakeLists.txt              |  3 +-
 src/plugins/eis/eisbackend.cpp              |  3 +-
 src/plugins/eis/eiscontext.cpp              | 39 ++++++-----
 src/plugins/eis/eiscontext.h                | 13 ++--
 src/plugins/eis/xwaylandeiscontext.cpp      | 76 +++++++++++++++++++++
 src/plugins/eis/xwaylandeiscontext.h        | 23 +++++++
 src/settings.kcfgc                          |  1 +
 12 files changed, 173 insertions(+), 27 deletions(-)
 create mode 100644 src/plugins/eis/xwaylandeiscontext.cpp
 create mode 100644 src/plugins/eis/xwaylandeiscontext.h

diff --git a/src/kcms/xwayland/kwinxwaylandsettings.kcfg b/src/kcms/xwayland/kwinxwaylandsettings.kcfg
index 93ecbbf..930d31a 100644
--- a/src/kcms/xwayland/kwinxwaylandsettings.kcfg
+++ b/src/kcms/xwayland/kwinxwaylandsettings.kcfg
@@ -17,5 +17,8 @@
         <entry name="xwaylandEavesdropsMouse" key="XwaylandEavesdropsMouse" type="Bool">
             <default>false</default>
         </entry>
+        <entry name="XwaylandEisNoPrompt" type="Bool">
+            <default>false</default>
+        </entry>
     </group>
 </kcfg>
diff --git a/src/kcms/xwayland/ui/main.qml b/src/kcms/xwayland/ui/main.qml
index 8b5acce..6207434 100644
--- a/src/kcms/xwayland/ui/main.qml
+++ b/src/kcms/xwayland/ui/main.qml
@@ -40,6 +40,7 @@ KCM.SimpleKCM {
         }
 
         Kirigami.FormLayout {
+            id: eavesdropLayout
             Layout.leftMargin: Kirigami.Units.gridUnit
             Layout.rightMargin: Kirigami.Units.gridUnit
 
@@ -114,5 +115,18 @@ KCM.SimpleKCM {
             text: i18n("Note that using this setting will reduce system security to that of the X11 session by permitting malicious software to steal passwords and spy on the text that you type. Make sure you understand and accept this risk.")
             visible: always.checked
         }
+
+        Kirigami.Separator {
+            Layout.fillWidth: true
+            Layout.leftMargin: Kirigami.Units.gridUnit
+            Layout.rightMargin: Kirigami.Units.gridUnit
+        }
+
+        QQC2.CheckBox {
+            Layout.margins: Kirigami.Units.gridUnit
+            text: i18nc("@option:check", "Allow controlling the pointer and keyboard without asking for permission")
+            checked: kcm.settings.xwaylandEisNoPrompt
+            onToggled: kcm.settings.xwaylandEisNoPrompt = checked
+        }
     }
 }
diff --git a/src/kwin.kcfg b/src/kwin.kcfg
index bba731c..183e5a0 100644
--- a/src/kwin.kcfg
+++ b/src/kwin.kcfg
@@ -352,5 +352,8 @@
         <entry name="XwaylandEavesdropsMouse" type="Bool">
             <default>false</default>
         </entry>
+        <entry name="XwaylandEisNoPrompt" type="Bool">
+            <default>false</default>
+        </entry>
     </group>
 </kcfg>
diff --git a/src/options.cpp b/src/options.cpp
index 16771dc..d114163 100644
--- a/src/options.cpp
+++ b/src/options.cpp
@@ -56,6 +56,7 @@ Options::Options(QObject *parent)
     , m_xwaylandMaxCrashCount(Options::defaultXwaylandMaxCrashCount())
     , m_xwaylandEavesdrops(Options::defaultXwaylandEavesdrops())
     , m_xwaylandEavesdropsMouse(Options::defaultXwaylandEavesdropsMouse())
+    , m_xwaylandEisNoPrompt(Options::defaultXwaylandEisNoPrompt())
     , m_compositingMode(Options::defaultCompositingMode())
     , m_useCompositing(Options::defaultUseCompositing())
     , m_hiddenPreviews(Options::defaultHiddenPreviews())
@@ -166,6 +167,15 @@ void Options::setXwaylandEavesdropsMouse(bool eavesdropsMouse)
     Q_EMIT xwaylandEavesdropsChanged();
 }
 
+void Options::setXWaylandEisNoPrompt(bool doNotPrompt)
+{
+    if (m_xwaylandEisNoPrompt == doNotPrompt) {
+        return;
+    }
+    m_xwaylandEisNoPrompt = doNotPrompt;
+    Q_EMIT xwaylandEisNoPromptChanged();
+}
+
 void Options::setClickRaise(bool clickRaise)
 {
     if (m_autoRaise) {
@@ -847,6 +857,7 @@ void Options::syncFromKcfgc()
     setXwaylandMaxCrashCount(m_settings->xwaylandMaxCrashCount());
     setXwaylandEavesdrops(XwaylandEavesdropsMode(m_settings->xwaylandEavesdrops()));
     setXwaylandEavesdropsMouse(m_settings->xwaylandEavesdropsMouse());
+    setXWaylandEisNoPrompt(m_settings->xwaylandEisNoPrompt());
     setPlacement(m_settings->placement());
     setAutoRaise(m_settings->autoRaise());
     setAutoRaiseInterval(m_settings->autoRaiseInterval());
diff --git a/src/options.h b/src/options.h
index f7f63e2..cea1043 100644
--- a/src/options.h
+++ b/src/options.h
@@ -271,6 +271,10 @@ public:
     {
         return m_xwaylandEavesdropsMouse;
     }
+    bool xwaylandEisNoPrompt() const
+    {
+        return m_xwaylandEisNoPrompt;
+    }
 
     /**
      * Whether clicking on a window raises it in FocusFollowsMouse
@@ -711,6 +715,7 @@ public:
     void setXwaylandMaxCrashCount(int maxCrashCount);
     void setXwaylandEavesdrops(XwaylandEavesdropsMode mode);
     void setXwaylandEavesdropsMouse(bool eavesdropsMouse);
+    void setXWaylandEisNoPrompt(bool doNotPrompt);
     void setNextFocusPrefersMouse(bool nextFocusPrefersMouse);
     void setClickRaise(bool clickRaise);
     void setAutoRaise(bool autoRaise);
@@ -895,6 +900,10 @@ public:
     {
         return false;
     }
+    static bool defaultXwaylandEisNoPrompt()
+    {
+        return false;
+    }
     static ActivationDesktopPolicy defaultActivationDesktopPolicy()
     {
         return ActivationDesktopPolicy::SwitchToOtherDesktop;
@@ -914,6 +923,7 @@ Q_SIGNALS:
     void xwaylandMaxCrashCountChanged();
     void xwaylandEavesdropsChanged();
     void xwaylandEavesdropsMouseChanged();
+    void xwaylandEisNoPromptChanged();
     void nextFocusPrefersMouseChanged();
     void clickRaiseChanged();
     void autoRaiseChanged();
@@ -1001,6 +1011,7 @@ private:
     int m_xwaylandMaxCrashCount;
     XwaylandEavesdropsMode m_xwaylandEavesdrops;
     bool m_xwaylandEavesdropsMouse;
+    bool m_xwaylandEisNoPrompt;
 
     CompositingType m_compositingMode;
     bool m_useCompositing;
diff --git a/src/plugins/eis/CMakeLists.txt b/src/plugins/eis/CMakeLists.txt
index 61ac515..4ed468c 100644
--- a/src/plugins/eis/CMakeLists.txt
+++ b/src/plugins/eis/CMakeLists.txt
@@ -26,6 +26,7 @@ target_sources(eis PRIVATE
     eisinputcapture.cpp
     eisinputcapturemanager.cpp
     eisinputcapturefilter.cpp
+    xwaylandeiscontext.cpp
 )
 
-target_link_libraries(eis PRIVATE kwin KF6::I18n KF6::GlobalAccel Libeis::Libeis XKB::XKB)
+target_link_libraries(eis PRIVATE kwin KF6::I18n KF6::ConfigGui KF6::GlobalAccel Libeis::Libeis XKB::XKB)
diff --git a/src/plugins/eis/eisbackend.cpp b/src/plugins/eis/eisbackend.cpp
index e1c2547..ce6a9e0 100644
--- a/src/plugins/eis/eisbackend.cpp
+++ b/src/plugins/eis/eisbackend.cpp
@@ -9,6 +9,7 @@
 #include "eiscontext.h"
 #include "eisdevice.h"
 #include "libeis_logging.h"
+#include "xwaylandeiscontext.h"
 
 #include "core/output.h"
 #include "input.h"
@@ -27,6 +28,7 @@
 #include <libeis.h>
 
 #include <fcntl.h>
+#include <unistd.h>
 
 #include <ranges>
 
@@ -43,7 +45,6 @@ namespace KWin
 EisBackend::EisBackend(QObject *parent)
     : KWin::InputBackend(parent)
     , m_serviceWatcher(new QDBusServiceWatcher(this))
-
 {
 #if HAVE_XWAYLAND_ENABLE_EI_PORTAL
     if (kwinApp()->operationMode() == Application::OperationModeWayland) {
diff --git a/src/plugins/eis/eiscontext.cpp b/src/plugins/eis/eiscontext.cpp
index c312f1e..a05c94e 100644
--- a/src/plugins/eis/eiscontext.cpp
+++ b/src/plugins/eis/eiscontext.cpp
@@ -65,11 +65,9 @@ int DbusEisContext::addClient()
     return eis_backend_fd_add_client(m_eisContext);
 }
 
-XWaylandEisContext::XWaylandEisContext(KWin::EisBackend *backend)
-    : EisContext(backend, {EIS_DEVICE_CAP_POINTER | EIS_DEVICE_CAP_POINTER_ABSOLUTE | EIS_DEVICE_CAP_KEYBOARD | EIS_DEVICE_CAP_TOUCH | EIS_DEVICE_CAP_SCROLL | EIS_DEVICE_CAP_BUTTON})
-    , socketName(qgetenv("XDG_RUNTIME_DIR") + QByteArrayLiteral("/kwin-xwayland-eis-socket.") + QByteArray::number(getpid()))
+void DbusEisContext::connectionRequested(eis_client *client)
 {
-    eis_setup_backend_socket(m_eisContext, socketName.constData());
+    connectToClient(client);
 }
 
 EisContext::EisContext(KWin::EisBackend *backend, QFlags<eis_device_capability> allowedCapabilities)
@@ -118,6 +116,25 @@ void EisContext::updateKeymap()
     }
 }
 
+void EisContext::connectToClient(eis_client *client)
+{
+    eis_client_connect(client);
+
+    const char *clientName = eis_client_get_name(client);
+
+    auto seat = eis_client_new_seat(client, QByteArrayLiteral(" seat").prepend(clientName));
+    constexpr std::array allCapabilities{EIS_DEVICE_CAP_POINTER, EIS_DEVICE_CAP_POINTER_ABSOLUTE, EIS_DEVICE_CAP_KEYBOARD, EIS_DEVICE_CAP_TOUCH, EIS_DEVICE_CAP_SCROLL, EIS_DEVICE_CAP_BUTTON};
+    for (auto capability : allCapabilities) {
+        if (m_allowedCapabilities & capability) {
+            eis_seat_configure_capability(seat, capability);
+        }
+    }
+    eis_seat_add(seat);
+
+    m_clients.emplace_back(std::make_unique<EisClient>(client, seat));
+    qCDebug(KWIN_EIS) << "New eis client" << clientName;
+}
+
 static std::chrono::microseconds currentTime()
 {
     return std::chrono::duration_cast<std::chrono::microseconds>(std::chrono::steady_clock::now().time_since_epoch());
@@ -141,19 +158,7 @@ void EisContext::handleEvents()
                 eis_client_disconnect(client);
                 break;
             }
-            eis_client_connect(client);
-
-            auto seat = eis_client_new_seat(client, QByteArrayLiteral(" seat").prepend(clientName));
-            constexpr std::array allCapabilities{EIS_DEVICE_CAP_POINTER, EIS_DEVICE_CAP_POINTER_ABSOLUTE, EIS_DEVICE_CAP_KEYBOARD, EIS_DEVICE_CAP_TOUCH, EIS_DEVICE_CAP_SCROLL, EIS_DEVICE_CAP_BUTTON};
-            for (auto capability : allCapabilities) {
-                if (m_allowedCapabilities & capability) {
-                    eis_seat_configure_capability(seat, capability);
-                }
-            }
-
-            eis_seat_add(seat);
-            m_clients.emplace_back(std::make_unique<EisClient>(client, seat));
-            qCDebug(KWIN_EIS) << "New eis client" << clientName;
+            connectionRequested(client);
             break;
         }
         case EIS_EVENT_CLIENT_DISCONNECT: {
diff --git a/src/plugins/eis/eiscontext.h b/src/plugins/eis/eiscontext.h
index 50de947..c14b17f 100644
--- a/src/plugins/eis/eiscontext.h
+++ b/src/plugins/eis/eiscontext.h
@@ -25,13 +25,15 @@ class EisContext
 {
 public:
     EisContext(EisBackend *backend, QFlags<eis_device_capability> allowedCapabilities);
-    ~EisContext();
+    virtual ~EisContext();
 
     void updateScreens();
     void updateKeymap();
 
 protected:
     eis *m_eisContext;
+    void connectToClient(eis_client *client);
+    virtual void connectionRequested(eis_client *client) = 0;
 
 private:
     void handleEvents();
@@ -51,13 +53,8 @@ public:
 
     const int cookie;
     const QString dbusService;
-};
 
-class XWaylandEisContext : public EisContext
-{
-public:
-    XWaylandEisContext(EisBackend *backend);
-
-    const QByteArray socketName;
+private:
+    void connectionRequested(eis_client *client) override;
 };
 }
diff --git a/src/plugins/eis/xwaylandeiscontext.cpp b/src/plugins/eis/xwaylandeiscontext.cpp
new file mode 100644
index 0000000..b26d06f
--- /dev/null
+++ b/src/plugins/eis/xwaylandeiscontext.cpp
@@ -0,0 +1,76 @@
+/*
+    SPDX-FileCopyrightText: 2024 David Redondo <kde@david-redono.de>
+
+    SPDX-License-Identifier: GPL-2.0-only OR GPL-3.0-only OR LicenseRef-KDE-Accepted-GPL
+*/
+
+#include "xwaylandeiscontext.h"
+
+#include "options.h"
+
+#include <KLocalizedString>
+
+#include <QCheckBox>
+#include <QDialog>
+#include <QDialogButtonBox>
+#include <QLabel>
+#include <QPushButton>
+#include <QStyle>
+#include <QVBoxLayout>
+
+#include <unistd.h>
+
+namespace KWin
+{
+
+XWaylandEisContext::XWaylandEisContext(EisBackend *backend)
+    : EisContext(backend, {EIS_DEVICE_CAP_POINTER | EIS_DEVICE_CAP_POINTER_ABSOLUTE | EIS_DEVICE_CAP_KEYBOARD | EIS_DEVICE_CAP_TOUCH | EIS_DEVICE_CAP_SCROLL | EIS_DEVICE_CAP_BUTTON})
+    , socketName(qgetenv("XDG_RUNTIME_DIR") + QByteArrayLiteral("/kwin-xwayland-eis-socket.") + QByteArray::number(getpid()))
+{
+    eis_setup_backend_socket(m_eisContext, socketName.constData());
+}
+
+void XWaylandEisContext::connectionRequested(eis_client *client)
+{
+    if (options->xwaylandEisNoPrompt()) {
+        connectToClient(client);
+        return;
+    }
+
+    auto dialog = new QDialog;
+    dialog->setAttribute(Qt::WA_DeleteOnClose);
+    dialog->setWindowTitle(i18nc("@title:window", "Remote control requested"));
+    dialog->setWindowIcon(QIcon::fromTheme(QStringLiteral("krfb")));
+    auto mainLayout = new QVBoxLayout(dialog);
+    auto iconTextLayout = new QHBoxLayout();
+    mainLayout->addLayout(iconTextLayout);
+    const int iconSize = dialog->style()->pixelMetric(QStyle::PM_MessageBoxIconSize);
+    auto icon = new QLabel(dialog);
+    icon->setPixmap(QIcon::fromTheme(QStringLiteral("krfb")).pixmap(iconSize));
+    iconTextLayout->addWidget(icon);
+    iconTextLayout->addWidget(new QLabel(i18nc("%1 is the app/binary", "%1 wants to control the pointer and keyboard", eis_client_get_name(client)), dialog));
+    auto alwaysAllowCheckbox = new QCheckBox(i18nc("@option:check", "Always allow for legacy applications"), dialog);
+    mainLayout->addWidget(alwaysAllowCheckbox);
+    auto buttonBox = new QDialogButtonBox(dialog);
+    mainLayout->addWidget(buttonBox);
+    auto allowButton = buttonBox->addButton(i18nc("@action:button", "Allow"), QDialogButtonBox::AcceptRole);
+    allowButton->setIcon(QIcon::fromTheme(QStringLiteral("dialog-ok")));
+    buttonBox->addButton(QDialogButtonBox::Cancel);
+    dialog->show();
+    QObject::connect(buttonBox, &QDialogButtonBox::accepted, dialog, &QDialog::accept);
+    QObject::connect(buttonBox, &QDialogButtonBox::rejected, dialog, &QDialog::reject);
+    QObject::connect(dialog, &QDialog::finished, [client, alwaysAllowCheckbox, this](int result) {
+        if (result == QDialog::Accepted) {
+            connectToClient(client);
+            if (alwaysAllowCheckbox->isChecked()) {
+                kwinApp()->config()->group(QStringLiteral("Xwayland")).writeEntry(QStringLiteral("XwaylandEisNoPrompt"), true, KConfig::Notify);
+                kwinApp()->config()->sync();
+            }
+        } else {
+            eis_client_disconnect(client);
+        }
+    });
+    dialog->show();
+}
+
+}
diff --git a/src/plugins/eis/xwaylandeiscontext.h b/src/plugins/eis/xwaylandeiscontext.h
new file mode 100644
index 0000000..44eea5b
--- /dev/null
+++ b/src/plugins/eis/xwaylandeiscontext.h
@@ -0,0 +1,23 @@
+/*
+    SPDX-FileCopyrightText: 2024 David Redondo <kde@david-redono.de>
+
+    SPDX-License-Identifier: GPL-2.0-only OR GPL-3.0-only OR LicenseRef-KDE-Accepted-GPL
+*/
+
+#pragma once
+
+#include <eiscontext.h>
+
+namespace KWin
+{
+class XWaylandEisContext : public EisContext
+{
+public:
+    XWaylandEisContext(EisBackend *backend);
+
+    const QByteArray socketName;
+
+private:
+    void connectionRequested(eis_client *client) override;
+};
+}
diff --git a/src/settings.kcfgc b/src/settings.kcfgc
index 8ed482e..2a73387 100644
--- a/src/settings.kcfgc
+++ b/src/settings.kcfgc
@@ -4,3 +4,4 @@ ClassName=Settings
 # options.h is needed for FocusPolicy and PlacementPolicy
 IncludeFiles=\"options.h\"
 UseEnumTypes=true
+Mutators=true
-- 
2.48.1


From 4927eeed4beacca5254a2c3db5bca24548019ff4 Mon Sep 17 00:00:00 2001
From: David Redondo <kde@david-redondo.de>
Date: Mon, 26 Aug 2024 17:19:58 +0200
Subject: [PATCH 5/5] Add per app Xwayland eis settings

Allows the user to manage the permissions in a  more fine grained.
Can allow for a specific application in the dialog and review and
revoke in the KCM.
---
 src/kcms/xwayland/kwinxwaylandsettings.kcfg |  1 +
 src/kcms/xwayland/ui/main.qml               | 43 ++++++++++++++++++++-
 src/kwin.kcfg                               |  1 +
 src/options.cpp                             | 11 ++++++
 src/options.h                               | 11 ++++++
 src/plugins/eis/xwaylandeiscontext.cpp      | 16 ++++++--
 6 files changed, 78 insertions(+), 5 deletions(-)

diff --git a/src/kcms/xwayland/kwinxwaylandsettings.kcfg b/src/kcms/xwayland/kwinxwaylandsettings.kcfg
index 930d31a..9301291 100644
--- a/src/kcms/xwayland/kwinxwaylandsettings.kcfg
+++ b/src/kcms/xwayland/kwinxwaylandsettings.kcfg
@@ -20,5 +20,6 @@
         <entry name="XwaylandEisNoPrompt" type="Bool">
             <default>false</default>
         </entry>
+        <entry name="XwaylandEisNoPromptApps" type="StringList" />
     </group>
 </kcfg>
diff --git a/src/kcms/xwayland/ui/main.qml b/src/kcms/xwayland/ui/main.qml
index 6207434..49f5e26 100644
--- a/src/kcms/xwayland/ui/main.qml
+++ b/src/kcms/xwayland/ui/main.qml
@@ -123,10 +123,51 @@ KCM.SimpleKCM {
         }
 
         QQC2.CheckBox {
-            Layout.margins: Kirigami.Units.gridUnit
+            Layout.leftMargin: Kirigami.Units.gridUnit
+            Layout.rightMargin: Kirigami.Units.gridUnit
             text: i18nc("@option:check", "Allow controlling the pointer and keyboard without asking for permission")
             checked: kcm.settings.xwaylandEisNoPrompt
             onToggled: kcm.settings.xwaylandEisNoPrompt = checked
         }
+        QQC2.Button {
+            Layout.leftMargin: Kirigami.Units.gridUnit
+            Layout.rightMargin: Kirigami.Units.gridUnit
+            text: i18nc("@action:button", "Configure applicationsâ€¦")
+            enabled: !kcm.settings.xwaylandEisNoPrompt && kcm.settings.xwaylandEisNoPromptApps.length > 0
+            onClicked: {
+                kcm.push(appsPage)
+            }
+            KCM.ScrollViewKCM {
+                id: appsPage
+                visible: false
+                title: i18n("Applications allowed to control the pointer and keyboard")
+                view: ListView {
+                    model: kcm.settings.xwaylandEisNoPromptApps
+                    delegate: QQC2.ItemDelegate {
+                        id: delegate
+                        width: ListView.view.width
+                        text: modelData
+                        icon.name: modelData
+                        contentItem: RowLayout {
+                            spacing: Kirigami.Theme.smallSpacing
+                            Kirigami.IconTitleSubtitle {
+                                Layout.fillWidth: true
+                                icon: icon.fromControlsIcon(delegate.icon)
+                                title: delegate.text
+                                selected: delegate.highlighted || delegate.down
+                                font: delegate.font
+                            }
+                            QQC2.ToolButton {
+                                icon.name: "list-remove-symbolic"
+                                QQC2.ToolTip {
+                                    text: i18nc("@info:tooltip %1 is the name of the app/binary", "Do not allow %1 to control the pointer and keyboard without asking", modelData)
+                                }
+                                onClicked: kcm.settings.xwaylandEisNoPromptApps = kcm.settings.xwaylandEisNoPromptApps.filter(app => app != modelData)
+                            }
+                        }
+                    }
+                }
+            }
+        }
     }
 }
diff --git a/src/kwin.kcfg b/src/kwin.kcfg
index 183e5a0..0816194 100644
--- a/src/kwin.kcfg
+++ b/src/kwin.kcfg
@@ -355,5 +355,6 @@
         <entry name="XwaylandEisNoPrompt" type="Bool">
             <default>false</default>
         </entry>
+        <entry name="XwaylandEisNoPromptApps" type="StringList" />
     </group>
 </kcfg>
diff --git a/src/options.cpp b/src/options.cpp
index d114163..0b5a986 100644
--- a/src/options.cpp
+++ b/src/options.cpp
@@ -57,6 +57,7 @@ Options::Options(QObject *parent)
     , m_xwaylandEavesdrops(Options::defaultXwaylandEavesdrops())
     , m_xwaylandEavesdropsMouse(Options::defaultXwaylandEavesdropsMouse())
     , m_xwaylandEisNoPrompt(Options::defaultXwaylandEisNoPrompt())
+    , m_xwaylandEisNoPromptApps(Options::defaultXwaylandEisNotPromptApps())
     , m_compositingMode(Options::defaultCompositingMode())
     , m_useCompositing(Options::defaultUseCompositing())
     , m_hiddenPreviews(Options::defaultHiddenPreviews())
@@ -176,6 +177,15 @@ void Options::setXWaylandEisNoPrompt(bool doNotPrompt)
     Q_EMIT xwaylandEisNoPromptChanged();
 }
 
+void Options::setXWaylandEisNoPromptApps(const QStringList &apps)
+{
+    if (m_xwaylandEisNoPromptApps == apps) {
+        return;
+    }
+    m_xwaylandEisNoPromptApps = apps;
+    Q_EMIT xwaylandEisNoPromptAppsChanged();
+}
+
 void Options::setClickRaise(bool clickRaise)
 {
     if (m_autoRaise) {
@@ -858,6 +868,7 @@ void Options::syncFromKcfgc()
     setXwaylandEavesdrops(XwaylandEavesdropsMode(m_settings->xwaylandEavesdrops()));
     setXwaylandEavesdropsMouse(m_settings->xwaylandEavesdropsMouse());
     setXWaylandEisNoPrompt(m_settings->xwaylandEisNoPrompt());
+    setXWaylandEisNoPromptApps(m_settings->xwaylandEisNoPromptApps());
     setPlacement(m_settings->placement());
     setAutoRaise(m_settings->autoRaise());
     setAutoRaiseInterval(m_settings->autoRaiseInterval());
diff --git a/src/options.h b/src/options.h
index cea1043..dfa65a2 100644
--- a/src/options.h
+++ b/src/options.h
@@ -275,6 +275,10 @@ public:
     {
         return m_xwaylandEisNoPrompt;
     }
+    QStringList xwaylandEisNoPromptApps() const
+    {
+        return m_xwaylandEisNoPromptApps;
+    }
 
     /**
      * Whether clicking on a window raises it in FocusFollowsMouse
@@ -716,6 +720,7 @@ public:
     void setXwaylandEavesdrops(XwaylandEavesdropsMode mode);
     void setXwaylandEavesdropsMouse(bool eavesdropsMouse);
     void setXWaylandEisNoPrompt(bool doNotPrompt);
+    void setXWaylandEisNoPromptApps(const QStringList &apps);
     void setNextFocusPrefersMouse(bool nextFocusPrefersMouse);
     void setClickRaise(bool clickRaise);
     void setAutoRaise(bool autoRaise);
@@ -904,6 +909,10 @@ public:
     {
         return false;
     }
+    static QStringList defaultXwaylandEisNotPromptApps()
+    {
+        return QStringList();
+    }
     static ActivationDesktopPolicy defaultActivationDesktopPolicy()
     {
         return ActivationDesktopPolicy::SwitchToOtherDesktop;
@@ -924,6 +933,7 @@ Q_SIGNALS:
     void xwaylandEavesdropsChanged();
     void xwaylandEavesdropsMouseChanged();
     void xwaylandEisNoPromptChanged();
+    void xwaylandEisNoPromptAppsChanged();
     void nextFocusPrefersMouseChanged();
     void clickRaiseChanged();
     void autoRaiseChanged();
@@ -1012,6 +1022,7 @@ private:
     XwaylandEavesdropsMode m_xwaylandEavesdrops;
     bool m_xwaylandEavesdropsMouse;
     bool m_xwaylandEisNoPrompt;
+    QStringList m_xwaylandEisNoPromptApps;
 
     CompositingType m_compositingMode;
     bool m_useCompositing;
diff --git a/src/plugins/eis/xwaylandeiscontext.cpp b/src/plugins/eis/xwaylandeiscontext.cpp
index b26d06f..55c93a0 100644
--- a/src/plugins/eis/xwaylandeiscontext.cpp
+++ b/src/plugins/eis/xwaylandeiscontext.cpp
@@ -32,7 +32,8 @@ XWaylandEisContext::XWaylandEisContext(EisBackend *backend)
 
 void XWaylandEisContext::connectionRequested(eis_client *client)
 {
-    if (options->xwaylandEisNoPrompt()) {
+    const QString clientName = QString::fromUtf8(eis_client_get_name(client));
+    if (options->xwaylandEisNoPrompt() || options->xwaylandEisNoPromptApps().contains(clientName)) {
         connectToClient(client);
         return;
     }
@@ -49,6 +50,8 @@ void XWaylandEisContext::connectionRequested(eis_client *client)
     icon->setPixmap(QIcon::fromTheme(QStringLiteral("krfb")).pixmap(iconSize));
     iconTextLayout->addWidget(icon);
     iconTextLayout->addWidget(new QLabel(i18nc("%1 is the app/binary", "%1 wants to control the pointer and keyboard", eis_client_get_name(client)), dialog));
+    auto allowAppCheckbox = new QCheckBox(i18nc("@option:check %1 is the app/binary", "Always allow for %1", clientName), dialog);
+    mainLayout->addWidget(allowAppCheckbox);
     auto alwaysAllowCheckbox = new QCheckBox(i18nc("@option:check", "Always allow for legacy applications"), dialog);
     mainLayout->addWidget(alwaysAllowCheckbox);
     auto buttonBox = new QDialogButtonBox(dialog);
@@ -59,13 +62,18 @@ void XWaylandEisContext::connectionRequested(eis_client *client)
     dialog->show();
     QObject::connect(buttonBox, &QDialogButtonBox::accepted, dialog, &QDialog::accept);
     QObject::connect(buttonBox, &QDialogButtonBox::rejected, dialog, &QDialog::reject);
-    QObject::connect(dialog, &QDialog::finished, [client, alwaysAllowCheckbox, this](int result) {
+    QObject::connect(dialog, &QDialog::finished, [client, clientName, alwaysAllowCheckbox, allowAppCheckbox, this](int result) {
         if (result == QDialog::Accepted) {
             connectToClient(client);
+            auto xwaylandGroup = kwinApp()->config()->group(QStringLiteral("Xwayland"));
             if (alwaysAllowCheckbox->isChecked()) {
-                kwinApp()->config()->group(QStringLiteral("Xwayland")).writeEntry(QStringLiteral("XwaylandEisNoPrompt"), true, KConfig::Notify);
-                kwinApp()->config()->sync();
+                xwaylandGroup.writeEntry(QStringLiteral("XwaylandEisNoPrompt"), true, KConfig::Notify);
             }
+            if (allowAppCheckbox->isChecked()) {
+                auto allowedApps = options->xwaylandEisNoPromptApps() << clientName;
+                xwaylandGroup.writeEntry(QStringLiteral("XwaylandEisNoPromptApps"), allowedApps, KConfig::Notify);
+            }
+            kwinApp()->config()->sync();
         } else {
             eis_client_disconnect(client);
         }
-- 
2.48.1

From 2621daec73317be6f19ab9ec8be51b509cab554b Mon Sep 17 00:00:00 2001
From: Eric Naim <dnaim@cachyos.org>
Date: Mon, 3 Feb 2025 21:47:29 +0800
Subject: [PATCH] fifo-v1

Signed-off-by: Eric Naim <dnaim@cachyos.org>
---
 autotests/integration/CMakeLists.txt      |   3 +
 autotests/integration/kwin_wayland_test.h |  20 ++
 autotests/integration/test_fifo.cpp       | 259 ++++++++++++++++++++++
 autotests/integration/test_helpers.cpp    |  44 ++++
 src/compositor_wayland.cpp                |  19 +-
 src/core/renderlayerdelegate.cpp          |   4 +
 src/core/renderlayerdelegate.h            |   5 +
 src/core/renderloop.cpp                   |   4 +-
 src/scene/cursorscene.cpp                 |  10 +
 src/scene/cursorscene.h                   |   1 +
 src/scene/item.cpp                        |   7 +
 src/scene/item.h                          |   1 +
 src/scene/scene.cpp                       |   5 +
 src/scene/scene.h                         |   2 +
 src/scene/surfaceitem_wayland.cpp         |  34 +++
 src/scene/surfaceitem_wayland.h           |   6 +
 src/scene/workspacescene.cpp              |  10 +
 src/scene/workspacescene.h                |   1 +
 src/wayland/CMakeLists.txt                |  10 +-
 src/wayland/fifo_v1.cpp                   |  75 +++++++
 src/wayland/fifo_v1.h                     |  40 ++++
 src/wayland/surface.cpp                   |  32 +++
 src/wayland/surface.h                     |  13 ++
 src/wayland/surface_p.h                   |   6 +
 src/wayland/transaction.cpp               |  30 +++
 src/wayland/transaction.h                 |   2 +
 src/wayland/transaction_p.h               |  12 +
 src/wayland_server.cpp                    |   2 +
 src/wayland_server.h                      |   2 +
 29 files changed, 656 insertions(+), 3 deletions(-)
 create mode 100644 autotests/integration/test_fifo.cpp
 create mode 100644 src/wayland/fifo_v1.cpp
 create mode 100644 src/wayland/fifo_v1.h

diff --git a/autotests/integration/CMakeLists.txt b/autotests/integration/CMakeLists.txt
index 872ba038bb..8dbb7350fa 100644
--- a/autotests/integration/CMakeLists.txt
+++ b/autotests/integration/CMakeLists.txt
@@ -16,8 +16,10 @@ qt6_generate_wayland_protocol_client_sources(KWinIntegrationTestFramework
     FILES
         ${CMAKE_SOURCE_DIR}/src/wayland/protocols/wlr-layer-shell-unstable-v1.xml
         ${PROJECT_SOURCE_DIR}/src/wayland/protocols/color-management-v1.xml
+        ${WaylandProtocols_DATADIR}/stable/presentation-time/presentation-time.xml
         ${WaylandProtocols_DATADIR}/stable/xdg-shell/xdg-shell.xml
         ${WaylandProtocols_DATADIR}/staging/cursor-shape/cursor-shape-v1.xml
+        ${WaylandProtocols_DATADIR}/staging/fifo/fifo-v1.xml
         ${WaylandProtocols_DATADIR}/staging/fractional-scale/fractional-scale-v1.xml
         ${WaylandProtocols_DATADIR}/staging/security-context/security-context-v1.xml
         ${WaylandProtocols_DATADIR}/staging/xdg-dialog/xdg-dialog-v1.xml
@@ -144,6 +146,7 @@ integrationTest(NAME testStickyKeys SRCS sticky_keys_test.cpp)
 integrationTest(NAME testWorkspace SRCS workspace_test.cpp)
 integrationTest(NAME testMouseActions SRCS mouseactions_test.cpp LIBS)
 integrationTest(NAME testColorManagement SRCS test_colormanagement.cpp)
+integrationTest(NAME testFifo SRCS test_fifo.cpp)
 integrationTest(NAME testKeyboardInput SRCS keyboard_input_test.cpp)
 
 if(KWIN_BUILD_X11)
diff --git a/autotests/integration/kwin_wayland_test.h b/autotests/integration/kwin_wayland_test.h
index 646a95d691..e53d3ddb21 100644
--- a/autotests/integration/kwin_wayland_test.h
+++ b/autotests/integration/kwin_wayland_test.h
@@ -23,12 +23,14 @@
 #include "qwayland-color-management-v1.h"
 #include "qwayland-cursor-shape-v1.h"
 #include "qwayland-fake-input.h"
+#include "qwayland-fifo-v1.h"
 #include "qwayland-fractional-scale-v1.h"
 #include "qwayland-idle-inhibit-unstable-v1.h"
 #include "qwayland-input-method-unstable-v1.h"
 #include "qwayland-kde-output-device-v2.h"
 #include "qwayland-kde-output-management-v2.h"
 #include "qwayland-kde-screen-edge-v1.h"
+#include "qwayland-presentation-time.h"
 #include "qwayland-security-context-v1.h"
 #include "qwayland-text-input-unstable-v3.h"
 #include "qwayland-wlr-layer-shell-unstable-v1.h"
@@ -605,6 +607,8 @@ enum class AdditionalWaylandInterface {
     SecurityContextManagerV1 = 1 << 20,
     XdgDialogV1 = 1 << 21,
     ColorManagement = 1 << 22,
+    FifoV1 = 1 << 23,
+    PresentationTime = 1 << 24,
 };
 Q_DECLARE_FLAGS(AdditionalWaylandInterfaces, AdditionalWaylandInterface)
 
@@ -681,6 +685,20 @@ public:
     ~ColorManagerV1() override;
 };
 
+class FifoManagerV1 : public QtWayland::wp_fifo_manager_v1
+{
+public:
+    explicit FifoManagerV1(::wl_registry *registry, uint32_t id, int version);
+    ~FifoManagerV1() override;
+};
+
+class PresentationTime : public QtWayland::wp_presentation
+{
+public:
+    explicit PresentationTime(::wl_registry *registry, uint32_t id, int version);
+    ~PresentationTime() override;
+};
+
 void keyboardKeyPressed(quint32 key, quint32 time);
 void keyboardKeyReleased(quint32 key, quint32 time);
 void pointerAxisHorizontal(qreal delta,
@@ -740,6 +758,8 @@ QList<WaylandOutputDeviceV2 *> waylandOutputDevicesV2();
 FakeInput *waylandFakeInput();
 SecurityContextManagerV1 *waylandSecurityContextManagerV1();
 ColorManagerV1 *colorManager();
+FifoManagerV1 *fifoManager();
+PresentationTime *presentationTime();
 
 bool waitForWaylandSurface(Window *window);
 
diff --git a/autotests/integration/test_fifo.cpp b/autotests/integration/test_fifo.cpp
new file mode 100644
index 0000000000..7ce6397b32
--- /dev/null
+++ b/autotests/integration/test_fifo.cpp
@@ -0,0 +1,259 @@
+
+/*
+    SPDX-FileCopyrightText: 2024 Xaver Hugl <xaver.hugl@gmail.com>
+
+    SPDX-License-Identifier: GPL-2.0-or-later
+*/
+
+#include "kwin_wayland_test.h"
+
+#include "core/colorpipeline.h"
+#include "core/output.h"
+#include "core/outputbackend.h"
+#include "core/outputconfiguration.h"
+#include "outputconfigurationstore.h"
+#include "pointer_input.h"
+#include "tiles/tilemanager.h"
+#include "wayland/surface.h"
+#include "wayland_server.h"
+#include "window.h"
+#include "workspace.h"
+
+#include <KWayland/Client/connection_thread.h>
+#include <KWayland/Client/surface.h>
+#include <format>
+
+using namespace std::chrono_literals;
+
+namespace KWin
+{
+
+static const QString s_socketName = QStringLiteral("wayland_test_fifo-0");
+
+class FifoTest : public QObject
+{
+    Q_OBJECT
+
+private Q_SLOTS:
+    void initTestCase();
+    void init();
+    void cleanup();
+
+    void testFifo_data();
+    void testFifo();
+    void testFifoInitiallyHidden();
+};
+
+class FifoV1Surface : public QObject, public QtWayland::wp_fifo_v1
+{
+    Q_OBJECT
+public:
+    explicit FifoV1Surface(::wp_fifo_v1 *obj)
+        : QtWayland::wp_fifo_v1(obj)
+    {
+    }
+
+    ~FifoV1Surface() override
+    {
+        wp_fifo_v1_destroy(object());
+    }
+};
+
+class WpPresentationFeedback : public QObject, public QtWayland::wp_presentation_feedback
+{
+    Q_OBJECT
+public:
+    explicit WpPresentationFeedback(struct ::wp_presentation_feedback *obj)
+        : QtWayland::wp_presentation_feedback(obj)
+    {
+    }
+
+    ~WpPresentationFeedback() override
+    {
+        wp_presentation_feedback_destroy(object());
+    }
+
+Q_SIGNALS:
+    void presented(std::chrono::nanoseconds timestamp, std::chrono::nanoseconds refreshDuration);
+    void discarded();
+
+private:
+    void wp_presentation_feedback_presented(uint32_t tv_sec_hi, uint32_t tv_sec_lo, uint32_t tv_nsec, uint32_t refresh, uint32_t seq_hi, uint32_t seq_lo, uint32_t flags) override
+    {
+        const std::chrono::nanoseconds timestamp = std::chrono::seconds((uint64_t(tv_sec_hi) << 32) | tv_sec_lo) + std::chrono::nanoseconds(tv_nsec);
+        Q_EMIT presented(timestamp, std::chrono::nanoseconds(refresh));
+    }
+
+    void wp_presentation_feedback_discarded() override
+    {
+        Q_EMIT discarded();
+    }
+};
+
+void FifoTest::initTestCase()
+{
+    qRegisterMetaType<Window *>();
+
+    QVERIFY(waylandServer()->init(s_socketName));
+    kwinApp()->start();
+}
+
+void FifoTest::init()
+{
+    QVERIFY(Test::setupWaylandConnection(Test::AdditionalWaylandInterface::FifoV1 | Test::AdditionalWaylandInterface::PresentationTime));
+    Test::setupWaylandConnection();
+
+    workspace()->setActiveOutput(QPoint(640, 512));
+    input()->pointer()->warp(QPoint(640, 512));
+}
+
+void FifoTest::cleanup()
+{
+    Test::destroyWaylandConnection();
+}
+
+void FifoTest::testFifo_data()
+{
+    QTest::addColumn<uint32_t>("refreshRate");
+
+    QTest::addRow("60Hz") << 60'000u;
+    QTest::addRow("24Hz") << 24'000u;
+}
+
+void FifoTest::testFifo()
+{
+    QFETCH(uint32_t, refreshRate);
+    Test::setOutputConfig({
+        Test::OutputInfo{
+            .geometry = QRect(0, 0, 1280, 1024),
+            .modes = {
+                std::make_tuple(QSize(1280, 1024), refreshRate, OutputMode::Flag::Preferred),
+            },
+        },
+    });
+
+    std::unique_ptr<KWayland::Client::Surface> surface(Test::createSurface());
+    std::unique_ptr<Test::XdgToplevel> shellSurface(Test::createXdgToplevelSurface(surface.get()));
+    auto window = Test::renderAndWaitForShown(surface.get(), QSize(100, 50), Qt::blue);
+    QVERIFY(window);
+
+    auto fifo = std::make_unique<FifoV1Surface>(Test::fifoManager()->get_fifo(*surface));
+
+    std::array<std::unique_ptr<WpPresentationFeedback>, 3> frames;
+
+    // commit 3 frames in quick succession: without fifo, the first two should be discarded, and the last should be presented
+    for (size_t i = 0; i < frames.size(); i++) {
+        frames[i] = std::make_unique<WpPresentationFeedback>(Test::presentationTime()->feedback(*surface));
+        surface->damage(QRect(QPoint(), QSize(1, 1)));
+        surface->commit(KWayland::Client::Surface::CommitFlag::None);
+    }
+
+    {
+        QSignalSpy discarded1(frames[0].get(), &WpPresentationFeedback::discarded);
+        QSignalSpy discarded2(frames[1].get(), &WpPresentationFeedback::discarded);
+        QSignalSpy presented(frames[2].get(), &WpPresentationFeedback::presented);
+
+        QVERIFY(presented.wait(100));
+        QVERIFY(discarded1.count());
+        QVERIFY(discarded2.count());
+    }
+
+    // do it again; this time with fifo, all frames should be presented
+    fifo->set_barrier();
+    surface->commit(KWayland::Client::Surface::CommitFlag::None);
+    for (size_t i = 0; i < frames.size(); i++) {
+        frames[i] = std::make_unique<WpPresentationFeedback>(Test::presentationTime()->feedback(*surface));
+        fifo->set_barrier();
+        fifo->wait_barrier();
+        surface->commit(KWayland::Client::Surface::CommitFlag::None);
+    }
+
+    {
+        std::array<QSignalSpy, frames.size()> spies = {
+            QSignalSpy(frames[0].get(), &WpPresentationFeedback::presented),
+            QSignalSpy(frames[1].get(), &WpPresentationFeedback::presented),
+            QSignalSpy(frames[2].get(), &WpPresentationFeedback::presented),
+        };
+        for (size_t i = 0; i < frames.size(); i++) {
+            QVERIFY(spies[i].wait(100));
+            if (i > 0) {
+                // each frame should be presented in the refresh cycle after the last one
+                const auto thisTimestamp = spies[i].last().at(0).value<std::chrono::nanoseconds>();
+                const auto lastTimestamp = spies[i - 1].last().at(0).value<std::chrono::nanoseconds>();
+                const auto refreshDuration = spies[i].last().at(1).value<std::chrono::nanoseconds>();
+                QCOMPARE_GT(thisTimestamp, lastTimestamp + refreshDuration / 2);
+                QCOMPARE_LT(thisTimestamp, lastTimestamp + refreshDuration * 3 / 2);
+            }
+        }
+    }
+
+    // even if the window is hidden, forward progress must be guaranteed
+    window->setMinimized(true);
+    // fifo->set_barrier();
+    surface->commit(KWayland::Client::Surface::CommitFlag::None);
+    for (size_t i = 0; i < frames.size(); i++) {
+        frames[i] = std::make_unique<WpPresentationFeedback>(Test::presentationTime()->feedback(*surface));
+        fifo->set_barrier();
+        fifo->wait_barrier();
+        surface->commit(KWayland::Client::Surface::CommitFlag::None);
+    }
+
+    {
+        const std::chrono::nanoseconds targetRefreshDuration = std::chrono::nanoseconds(1'000'000'000'000 / std::min(30'000u, refreshRate));
+        std::array<QSignalSpy, frames.size()> spies = {
+            QSignalSpy(frames[0].get(), &WpPresentationFeedback::discarded),
+            QSignalSpy(frames[1].get(), &WpPresentationFeedback::discarded),
+            QSignalSpy(frames[2].get(), &WpPresentationFeedback::discarded),
+        };
+        for (size_t i = 0; i < frames.size() - 1; i++) {
+            const auto before = std::chrono::steady_clock::now();
+            QVERIFY(spies[i].wait(100));
+            const auto after = std::chrono::steady_clock::now();
+            QCOMPARE_GT(after, before + targetRefreshDuration * 2 / 3);
+            QCOMPARE_LT(after, before + targetRefreshDuration * 2);
+        }
+    }
+}
+
+void FifoTest::testFifoInitiallyHidden()
+{
+    // this test verifies that even when the window has never been presented once,
+    // we still ensure forward progress
+
+    std::unique_ptr<KWayland::Client::Surface> surface(Test::createSurface());
+    std::unique_ptr<Test::XdgToplevel> shellSurface(Test::createXdgToplevelSurface(surface.get()));
+    auto window = Test::renderAndWaitForShown(surface.get(), QSize(100, 50), Qt::blue);
+    QVERIFY(window);
+    window->setMinimized(true);
+
+    auto fifo = std::make_unique<FifoV1Surface>(Test::fifoManager()->get_fifo(*surface));
+
+    std::array<std::unique_ptr<WpPresentationFeedback>, 3> frames;
+
+    for (size_t i = 0; i < frames.size(); i++) {
+        frames[i] = std::make_unique<WpPresentationFeedback>(Test::presentationTime()->feedback(*surface));
+        fifo->set_barrier();
+        fifo->wait_barrier();
+        surface->commit(KWayland::Client::Surface::CommitFlag::None);
+    }
+
+    {
+        std::array<QSignalSpy, frames.size()> spies = {
+            QSignalSpy(frames[0].get(), &WpPresentationFeedback::discarded),
+            QSignalSpy(frames[1].get(), &WpPresentationFeedback::discarded),
+            QSignalSpy(frames[2].get(), &WpPresentationFeedback::discarded),
+        };
+        for (size_t i = 0; i < frames.size() - 1; i++) {
+            const auto before = std::chrono::steady_clock::now();
+            QVERIFY(spies[i].wait(100));
+            const auto after = std::chrono::steady_clock::now();
+            QCOMPARE_GT(after, before + std::chrono::milliseconds(30));
+            QCOMPARE_LT(after, before + std::chrono::milliseconds(100));
+        }
+    }
+}
+
+}
+
+WAYLANDTEST_MAIN(KWin::FifoTest)
+#include "test_fifo.moc"
diff --git a/autotests/integration/test_helpers.cpp b/autotests/integration/test_helpers.cpp
index 21eaeee420..3b3bccc6b3 100644
--- a/autotests/integration/test_helpers.cpp
+++ b/autotests/integration/test_helpers.cpp
@@ -320,6 +320,8 @@ static struct
     SecurityContextManagerV1 *securityContextManagerV1 = nullptr;
     XdgWmDialogV1 *xdgWmDialogV1;
     std::unique_ptr<ColorManagerV1> colorManager;
+    std::unique_ptr<FifoManagerV1> fifoManager;
+    std::unique_ptr<PresentationTime> presentationTime;
 } s_waylandConnection;
 
 MockInputMethod *inputMethod()
@@ -546,6 +548,16 @@ bool setupWaylandConnection(AdditionalWaylandInterfaces flags)
                 s_waylandConnection.colorManager = std::make_unique<ColorManagerV1>(*registry, name, version);
             }
         }
+        if (flags & AdditionalWaylandInterface::FifoV1) {
+            if (interface == wp_fifo_manager_v1_interface.name) {
+                s_waylandConnection.fifoManager = std::make_unique<FifoManagerV1>(*registry, name, version);
+            }
+        }
+        if (flags & AdditionalWaylandInterface::PresentationTime) {
+            if (interface == wp_presentation_interface.name) {
+                s_waylandConnection.presentationTime = std::make_unique<PresentationTime>(*registry, name, version);
+            }
+        }
     });
 
     QSignalSpy allAnnounced(registry, &KWayland::Client::Registry::interfacesAnnounced);
@@ -674,6 +686,8 @@ void destroyWaylandConnection()
     delete s_waylandConnection.xdgWmDialogV1;
     s_waylandConnection.xdgWmDialogV1 = nullptr;
     s_waylandConnection.colorManager.reset();
+    s_waylandConnection.fifoManager.reset();
+    s_waylandConnection.presentationTime.reset();
 
     delete s_waylandConnection.queue; // Must be destroyed last
     s_waylandConnection.queue = nullptr;
@@ -795,6 +809,16 @@ ColorManagerV1 *colorManager()
     return s_waylandConnection.colorManager.get();
 }
 
+FifoManagerV1 *fifoManager()
+{
+    return s_waylandConnection.fifoManager.get();
+}
+
+PresentationTime *presentationTime()
+{
+    return s_waylandConnection.presentationTime.get();
+}
+
 bool waitForWaylandSurface(Window *window)
 {
     if (window->surface()) {
@@ -1766,6 +1790,26 @@ ColorManagerV1::~ColorManagerV1()
     wp_color_manager_v1_destroy(object());
 }
 
+FifoManagerV1::FifoManagerV1(::wl_registry *registry, uint32_t id, int version)
+    : QtWayland::wp_fifo_manager_v1(registry, id, version)
+{
+}
+
+FifoManagerV1::~FifoManagerV1()
+{
+    wp_fifo_manager_v1_destroy(object());
+}
+
+PresentationTime::PresentationTime(::wl_registry *registry, uint32_t id, int version)
+    : QtWayland::wp_presentation(registry, id, version)
+{
+}
+
+PresentationTime::~PresentationTime()
+{
+    wp_presentation_destroy(object());
+}
+
 void keyboardKeyPressed(quint32 key, quint32 time)
 {
     auto virtualKeyboard = static_cast<WaylandTestApplication *>(kwinApp())->virtualKeyboard();
diff --git a/src/compositor_wayland.cpp b/src/compositor_wayland.cpp
index 87c728af3b..5ae74f5649 100644
--- a/src/compositor_wayland.cpp
+++ b/src/compositor_wayland.cpp
@@ -316,6 +316,18 @@ static bool checkForBlackBackground(SurfaceItem *background)
     return nits.lengthSquared() <= (0.1 * 0.1);
 }
 
+static void preFifoPass(RenderLayer *layer, std::chrono::nanoseconds refreshDuration)
+{
+    layer->delegate()->prepareFifoPresentation(refreshDuration);
+
+    const auto sublayers = layer->sublayers();
+    for (RenderLayer *sublayer : sublayers) {
+        if (sublayer->isVisible()) {
+            preFifoPass(sublayer, refreshDuration);
+        }
+    }
+}
+
 void WaylandCompositor::composite(RenderLoop *renderLoop)
 {
     if (m_backend->checkGraphicsReset()) {
@@ -335,7 +347,8 @@ void WaylandCompositor::composite(RenderLoop *renderLoop)
     superLayer->setOutputLayer(primaryLayer);
 
     renderLoop->prepareNewFrame();
-    auto frame = std::make_shared<OutputFrame>(renderLoop, std::chrono::nanoseconds(1'000'000'000'000 / output->refreshRate()));
+    const auto refreshDuration = std::chrono::nanoseconds(1'000'000'000'000 / output->refreshRate());
+    auto frame = std::make_shared<OutputFrame>(renderLoop, refreshDuration);
     bool directScanout = false;
     std::optional<double> desiredArtificalHdrHeadroom;
 
@@ -355,6 +368,10 @@ void WaylandCompositor::composite(RenderLoop *renderLoop)
         frame->setBrightness(std::pow(std::clamp(std::pow(output->brightnessSetting() * output->dimming(), 1.0 / 2.2), current - maxChangePerFrame, current + maxChangePerFrame), 2.2));
     }
 
+    // TODO do something smarter about tearing presentation here
+    // like, only do one preFifoPass once per refresh cycle?
+    preFifoPass(superLayer, refreshDuration);
+
     if (primaryLayer->needsRepaint() || superLayer->needsRepaint()) {
         auto totalTimeQuery = std::make_unique<CpuRenderTimeQuery>();
         renderLoop->beginPaint();
diff --git a/src/core/renderlayerdelegate.cpp b/src/core/renderlayerdelegate.cpp
index 340e3f09ff..5dd341a6e3 100644
--- a/src/core/renderlayerdelegate.cpp
+++ b/src/core/renderlayerdelegate.cpp
@@ -23,6 +23,10 @@ void RenderLayerDelegate::frame(OutputFrame *frame)
 {
 }
 
+void RenderLayerDelegate::prepareFifoPresentation(std::chrono::nanoseconds refreshDuration)
+{
+}
+
 QRegion RenderLayerDelegate::prePaint()
 {
     return QRegion();
diff --git a/src/core/renderlayerdelegate.h b/src/core/renderlayerdelegate.h
index 42a9c9cf9d..0e13b8ab07 100644
--- a/src/core/renderlayerdelegate.h
+++ b/src/core/renderlayerdelegate.h
@@ -37,6 +37,11 @@ public:
      */
     virtual void frame(OutputFrame *frame);
 
+    /**
+     * This method is called by the compositor before starting painting for a FIFO frame
+     */
+    virtual void prepareFifoPresentation(std::chrono::nanoseconds refreshDuration);
+
     /**
      * This function is called by the compositor before starting painting. Reimplement
      * this function to do frame initialization.
diff --git a/src/core/renderloop.cpp b/src/core/renderloop.cpp
index 077d846405..be7db21038 100644
--- a/src/core/renderloop.cpp
+++ b/src/core/renderloop.cpp
@@ -190,7 +190,9 @@ void RenderLoopPrivate::dispatch()
 {
     // On X11, we want to ignore repaints that are scheduled by windows right before
     // the Compositor starts repainting.
-    pendingRepaint = true;
+    if (kwinApp()->operationMode() == Application::OperationModeX11) {
+        pendingRepaint = true;
+    }
 
     Q_EMIT q->frameRequested(q);
 
diff --git a/src/scene/cursorscene.cpp b/src/scene/cursorscene.cpp
index 7c9c271ce4..0c2acaac0d 100644
--- a/src/scene/cursorscene.cpp
+++ b/src/scene/cursorscene.cpp
@@ -44,6 +44,16 @@ static void resetRepaintsHelper(Item *item, SceneDelegate *delegate)
     }
 }
 
+void CursorScene::prepareFifoPresentation(SceneDelegate *delegate, std::chrono::nanoseconds refreshDuration)
+{
+    if (!delegate->output() || !m_cursorItem->isVisible()) {
+        return;
+    }
+    if (m_cursorItem->mapToScene(m_cursorItem->boundingRect()).intersects(delegate->output()->geometry())) {
+        m_cursorItem->prepareFifoPresentation(refreshDuration);
+    }
+}
+
 QRegion CursorScene::prePaint(SceneDelegate *delegate)
 {
     resetRepaintsHelper(m_rootItem.get(), delegate);
diff --git a/src/scene/cursorscene.h b/src/scene/cursorscene.h
index db01f41099..00202cb62a 100644
--- a/src/scene/cursorscene.h
+++ b/src/scene/cursorscene.h
@@ -23,6 +23,7 @@ public:
     explicit CursorScene(std::unique_ptr<ItemRenderer> &&renderer);
     ~CursorScene() override;
 
+    void prepareFifoPresentation(SceneDelegate *delegate, std::chrono::nanoseconds refreshDuration) override;
     QRegion prePaint(SceneDelegate *delegate) override;
     void postPaint() override;
     void paint(const RenderTarget &renderTarget, const QRegion &region) override;
diff --git a/src/scene/item.cpp b/src/scene/item.cpp
index 8d7b9897ba..87eba9666f 100644
--- a/src/scene/item.cpp
+++ b/src/scene/item.cpp
@@ -466,6 +466,13 @@ void Item::scheduleSceneRepaintInternal(const QRegion &region)
     }
 }
 
+void Item::prepareFifoPresentation(std::chrono::nanoseconds refreshDuration)
+{
+    for (const auto &child : m_childItems) {
+        child->prepareFifoPresentation(refreshDuration);
+    }
+}
+
 void Item::preprocess()
 {
 }
diff --git a/src/scene/item.h b/src/scene/item.h
index 7187eac683..c42781de7a 100644
--- a/src/scene/item.h
+++ b/src/scene/item.h
@@ -133,6 +133,7 @@ public:
     void resetRepaints(SceneDelegate *delegate);
 
     WindowQuadList quads() const;
+    virtual void prepareFifoPresentation(std::chrono::nanoseconds refreshDuration);
     virtual void preprocess();
     const ColorDescription &colorDescription() const;
     RenderingIntent renderingIntent() const;
diff --git a/src/scene/scene.cpp b/src/scene/scene.cpp
index 7bdf18b6b3..4e4000d882 100644
--- a/src/scene/scene.cpp
+++ b/src/scene/scene.cpp
@@ -29,6 +29,11 @@ QList<SurfaceItem *> SceneDelegate::scanoutCandidates(ssize_t maxCount) const
     return m_scene->scanoutCandidates(maxCount);
 }
 
+void SceneDelegate::prepareFifoPresentation(std::chrono::nanoseconds refreshDuration)
+{
+    m_scene->prepareFifoPresentation(this, refreshDuration);
+}
+
 QRegion SceneDelegate::prePaint()
 {
     return m_scene->prePaint(this);
diff --git a/src/scene/scene.h b/src/scene/scene.h
index 6eaadc2551..e29480e1a2 100644
--- a/src/scene/scene.h
+++ b/src/scene/scene.h
@@ -31,6 +31,7 @@ public:
 
     QList<SurfaceItem *> scanoutCandidates(ssize_t maxCount) const override;
     void frame(OutputFrame *frame) override;
+    void prepareFifoPresentation(std::chrono::nanoseconds refreshDuration) override;
     QRegion prePaint() override;
     void postPaint() override;
     void paint(const RenderTarget &renderTarget, const QRegion &region) override;
@@ -84,6 +85,7 @@ public:
     void removeDelegate(SceneDelegate *delegate);
 
     virtual QList<SurfaceItem *> scanoutCandidates(ssize_t maxCount) const;
+    virtual void prepareFifoPresentation(SceneDelegate *delegate, std::chrono::nanoseconds refreshDuration) = 0;
     virtual QRegion prePaint(SceneDelegate *delegate) = 0;
     virtual void postPaint() = 0;
     virtual void paint(const RenderTarget &renderTarget, const QRegion &region) = 0;
diff --git a/src/scene/surfaceitem_wayland.cpp b/src/scene/surfaceitem_wayland.cpp
index 4a307565c0..d7fcacc303 100644
--- a/src/scene/surfaceitem_wayland.cpp
+++ b/src/scene/surfaceitem_wayland.cpp
@@ -48,6 +48,7 @@ SurfaceItemWayland::SurfaceItemWayland(SurfaceInterface *surface, Item *parent)
             this, &SurfaceItemWayland::handlePresentationModeHintChanged);
     connect(surface, &SurfaceInterface::bufferReleasePointChanged, this, &SurfaceItemWayland::handleReleasePointChanged);
     connect(surface, &SurfaceInterface::alphaMultiplierChanged, this, &SurfaceItemWayland::handleAlphaMultiplierChanged);
+    connect(surface, &SurfaceInterface::waitingOnFifo, this, &SurfaceItemWayland::handleWaitingOnFifo);
 
     SubSurfaceInterface *subsurface = surface->subSurface();
     if (subsurface) {
@@ -68,6 +69,10 @@ SurfaceItemWayland::SurfaceItemWayland(SurfaceInterface *surface, Item *parent)
     setBufferSize(surface->bufferSize());
     setColorDescription(surface->colorDescription());
     setOpacity(surface->alphaMultiplier());
+
+    m_fifoFallbackTimer.setInterval(1000 / 20);
+    m_fifoFallbackTimer.setSingleShot(true);
+    connect(&m_fifoFallbackTimer, &QTimer::timeout, this, &SurfaceItemWayland::handleFifoFallback);
 }
 
 QList<QRectF> SurfaceItemWayland::shape() const
@@ -200,6 +205,7 @@ void SurfaceItemWayland::freeze()
     }
 
     m_surface = nullptr;
+    m_fifoFallbackTimer.stop();
 }
 
 void SurfaceItemWayland::handleColorDescriptionChanged()
@@ -223,6 +229,34 @@ void SurfaceItemWayland::handleAlphaMultiplierChanged()
     setOpacity(m_surface->alphaMultiplier());
 }
 
+void SurfaceItemWayland::prepareFifoPresentation(std::chrono::nanoseconds refreshDuration)
+{
+    if (m_surface) {
+        m_surface->prepareFifoPresentation();
+        if (m_fifoFallbackTimer.isActive()) {
+            // some games don't work properly if the refresh rate goes too low with FIFO. 30Hz is assumed to be fine here.
+            // this must still be slower than the actual screen though, or fifo behavior would be broken!
+            const auto fallbackRefreshDuration = std::max(refreshDuration * 5 / 4, std::chrono::nanoseconds(1'000'000'000) / 30);
+            // reset the timer, it should only trigger if we don't present fast enough
+            m_fifoFallbackTimer.start(std::chrono::duration_cast<std::chrono::milliseconds>(fallbackRefreshDuration));
+        }
+    }
+    Item::prepareFifoPresentation(refreshDuration);
+}
+
+void SurfaceItemWayland::handleWaitingOnFifo()
+{
+    m_fifoFallbackTimer.start();
+    scheduleFrame();
+}
+
+void SurfaceItemWayland::handleFifoFallback()
+{
+    if (m_surface) {
+        m_surface->prepareFifoPresentation();
+    }
+}
+
 SurfacePixmapWayland::SurfacePixmapWayland(SurfaceItemWayland *item, QObject *parent)
     : SurfacePixmap(Compositor::self()->backend()->createSurfaceTextureWayland(this), parent)
     , m_item(item)
diff --git a/src/scene/surfaceitem_wayland.h b/src/scene/surfaceitem_wayland.h
index f769284172..64689a02e1 100644
--- a/src/scene/surfaceitem_wayland.h
+++ b/src/scene/surfaceitem_wayland.h
@@ -8,6 +8,7 @@
 
 #include "scene/surfaceitem.h"
 
+#include <QTimer>
 #include <unordered_map>
 
 namespace KWin
@@ -33,6 +34,7 @@ public:
     ContentType contentType() const override;
     void setScanoutHint(DrmDevice *device, const QHash<uint32_t, QList<uint64_t>> &drmFormats) override;
     void freeze() override;
+    void prepareFifoPresentation(std::chrono::nanoseconds refreshDuration) override;
 
     SurfaceInterface *surface() const;
 
@@ -52,6 +54,9 @@ private Q_SLOTS:
     void handleReleasePointChanged();
     void handleAlphaMultiplierChanged();
 
+    void handleWaitingOnFifo();
+    void handleFifoFallback();
+
 protected:
     std::unique_ptr<SurfacePixmap> createPixmap() override;
 
@@ -66,6 +71,7 @@ private:
     };
     std::optional<ScanoutFeedback> m_scanoutFeedback;
     std::unordered_map<SubSurfaceInterface *, std::unique_ptr<SurfaceItemWayland>> m_subsurfaces;
+    QTimer m_fifoFallbackTimer;
 };
 
 class KWIN_EXPORT SurfacePixmapWayland final : public SurfacePixmap
diff --git a/src/scene/workspacescene.cpp b/src/scene/workspacescene.cpp
index 9cbd551308..41fb20acea 100644
--- a/src/scene/workspacescene.cpp
+++ b/src/scene/workspacescene.cpp
@@ -288,6 +288,16 @@ void WorkspaceScene::frame(SceneDelegate *delegate, OutputFrame *frame)
     }
 }
 
+void WorkspaceScene::prepareFifoPresentation(SceneDelegate *delegate, std::chrono::nanoseconds refreshDuration)
+{
+    const auto items = m_containerItem->sortedChildItems();
+    for (const auto &item : items) {
+        if (item->isVisible() && item->mapToScene(item->boundingRect()).intersects(delegate->output()->geometry())) {
+            item->prepareFifoPresentation(refreshDuration);
+        }
+    }
+}
+
 QRegion WorkspaceScene::prePaint(SceneDelegate *delegate)
 {
     createStackingOrder();
diff --git a/src/scene/workspacescene.h b/src/scene/workspacescene.h
index 97f00e05f5..fc3f6542cb 100644
--- a/src/scene/workspacescene.h
+++ b/src/scene/workspacescene.h
@@ -50,6 +50,7 @@ public:
     Item *overlayItem() const;
 
     QList<SurfaceItem *> scanoutCandidates(ssize_t maxCount) const override;
+    void prepareFifoPresentation(SceneDelegate *delegate, std::chrono::nanoseconds refreshDuration) override;
     QRegion prePaint(SceneDelegate *delegate) override;
     void postPaint() override;
     void paint(const RenderTarget &renderTarget, const QRegion &region) override;
diff --git a/src/wayland/CMakeLists.txt b/src/wayland/CMakeLists.txt
index b4123a5007..5d0683269f 100644
--- a/src/wayland/CMakeLists.txt
+++ b/src/wayland/CMakeLists.txt
@@ -307,12 +307,16 @@ ecm_add_qtwayland_server_protocol_kde(WaylandProtocols_xml
     PROTOCOL ${WaylandProtocols_DATADIR}/staging/xdg-system-bell/xdg-system-bell-v1.xml
     BASENAME xdg-system-bell-v1
 )
-
 ecm_add_qtwayland_server_protocol_kde(WaylandProtocols_xml
     PRIVATE_CODE
     PROTOCOL ${WaylandProtocols_DATADIR}/staging/xdg-toplevel-icon/xdg-toplevel-icon-v1.xml
     BASENAME xdg-toplevel-icon-v1
 )
+ecm_add_qtwayland_server_protocol_kde(WaylandProtocols_xml
+    PRIVATE_CODE
+    PROTOCOL ${WaylandProtocols_DATADIR}/staging/fifo/fifo-v1.xml
+    BASENAME fifo-v1
+)
 
 target_sources(kwin PRIVATE
     abstract_data_source.cpp
@@ -339,6 +343,7 @@ target_sources(kwin PRIVATE
     drmclientbuffer.cpp
     drmlease_v1.cpp
     externalbrightness_v1.cpp
+    fifo_v1.cpp
     filtered_display.cpp
     fixes.cpp
     fractionalscale_v1.cpp
@@ -426,6 +431,7 @@ install(FILES
     dpms.h
     drmlease_v1.h
     externalbrightness_v1.h
+    fifo_v1.h
     fractionalscale_v1.h
     frog_colormanagement_v1.h
     idle.h
@@ -486,6 +492,7 @@ install(FILES
     ${CMAKE_CURRENT_BINARY_DIR}/qwayland-server-alpha-modifier-v1.h
     ${CMAKE_CURRENT_BINARY_DIR}/qwayland-server-color-management-v1.h
     ${CMAKE_CURRENT_BINARY_DIR}/qwayland-server-content-type-v1.h
+    ${CMAKE_CURRENT_BINARY_DIR}/qwayland-server-fifo-v1.h
     ${CMAKE_CURRENT_BINARY_DIR}/qwayland-server-frog-color-management-v1.h
     ${CMAKE_CURRENT_BINARY_DIR}/qwayland-server-kde-external-brightness-v1.h
     ${CMAKE_CURRENT_BINARY_DIR}/qwayland-server-linux-drm-syncobj-v1.h
@@ -493,6 +500,7 @@ install(FILES
     ${CMAKE_CURRENT_BINARY_DIR}/wayland-alpha-modifier-v1-server-protocol.h
     ${CMAKE_CURRENT_BINARY_DIR}/wayland-color-management-v1-server-protocol.h
     ${CMAKE_CURRENT_BINARY_DIR}/wayland-content-type-v1-server-protocol.h
+    ${CMAKE_CURRENT_BINARY_DIR}/wayland-fifo-v1-server-protocol.h
     ${CMAKE_CURRENT_BINARY_DIR}/wayland-frog-color-management-v1-server-protocol.h
     ${CMAKE_CURRENT_BINARY_DIR}/wayland-kde-external-brightness-v1-server-protocol.h
     ${CMAKE_CURRENT_BINARY_DIR}/wayland-linux-drm-syncobj-v1-server-protocol.h
diff --git a/src/wayland/fifo_v1.cpp b/src/wayland/fifo_v1.cpp
new file mode 100644
index 0000000000..a0e2908dec
--- /dev/null
+++ b/src/wayland/fifo_v1.cpp
@@ -0,0 +1,75 @@
+#include "fifo_v1.h"
+
+#include "display.h"
+#include "surface_p.h"
+#include "transaction_p.h"
+
+namespace KWin
+{
+
+static constexpr uint32_t s_version = 1;
+
+FifoManagerV1::FifoManagerV1(Display *display, QObject *parent)
+    : QObject(parent)
+    , QtWaylandServer::wp_fifo_manager_v1(*display, s_version)
+{
+}
+
+void FifoManagerV1::wp_fifo_manager_v1_destroy(Resource *resource)
+{
+    wl_resource_destroy(resource->handle);
+}
+
+void FifoManagerV1::wp_fifo_manager_v1_get_fifo(Resource *resource, uint32_t id, struct ::wl_resource *wlSurface)
+{
+    const auto surface = SurfaceInterface::get(wlSurface);
+    const auto surfacePrivate = SurfaceInterfacePrivate::get(surface);
+    if (surfacePrivate->fifoSurface) {
+        wl_resource_post_error(resource->handle, error_already_exists, "Attempted to create a second fifo surface for the wl_surface");
+        return;
+    }
+    surfacePrivate->fifoSurface = new FifoV1Surface(resource->client(), id, resource->version(), surface);
+}
+
+FifoV1Surface::FifoV1Surface(wl_client *client, uint32_t id, uint32_t version, SurfaceInterface *surface)
+    : QtWaylandServer::wp_fifo_v1(client, id, version)
+    , m_surface(surface)
+{
+}
+
+FifoV1Surface::~FifoV1Surface()
+{
+    if (m_surface) {
+        SurfaceInterfacePrivate::get(m_surface)->fifoSurface = nullptr;
+    }
+}
+
+void FifoV1Surface::wp_fifo_v1_destroy_resource(Resource *resource)
+{
+    delete this;
+}
+
+void FifoV1Surface::wp_fifo_v1_destroy(Resource *resource)
+{
+    wl_resource_destroy(resource->handle);
+}
+
+void FifoV1Surface::wp_fifo_v1_set_barrier(Resource *resource)
+{
+    if (!m_surface) {
+        wl_resource_post_error(resource->handle, error_surface_destroyed, "called set_barrier on a destroyed surface");
+        return;
+    }
+    SurfaceInterfacePrivate::get(m_surface)->pending->fifoBarrier = std::make_unique<FifoBarrier>();
+}
+
+void FifoV1Surface::wp_fifo_v1_wait_barrier(Resource *resource)
+{
+    if (!m_surface) {
+        wl_resource_post_error(resource->handle, error_surface_destroyed, "called wait_barrier on a destroyed surface");
+        return;
+    }
+    SurfaceInterfacePrivate::get(m_surface)->pending->hasFifoWaitCondition = true;
+}
+
+}
diff --git a/src/wayland/fifo_v1.h b/src/wayland/fifo_v1.h
new file mode 100644
index 0000000000..b962d17bef
--- /dev/null
+++ b/src/wayland/fifo_v1.h
@@ -0,0 +1,40 @@
+#pragma once
+#include <QObject>
+#include <QPointer>
+
+#include "wayland/qwayland-server-fifo-v1.h"
+
+namespace KWin
+{
+
+class Display;
+class SurfaceInterface;
+class Transaction;
+
+class FifoManagerV1 : public QObject, public QtWaylandServer::wp_fifo_manager_v1
+{
+    Q_OBJECT
+public:
+    explicit FifoManagerV1(Display *display, QObject *parent);
+
+private:
+    void wp_fifo_manager_v1_destroy(Resource *resource) override;
+    void wp_fifo_manager_v1_get_fifo(Resource *resource, uint32_t id, struct ::wl_resource *surface) override;
+};
+
+class FifoV1Surface : public QtWaylandServer::wp_fifo_v1
+{
+public:
+    explicit FifoV1Surface(wl_client *client, uint32_t id, uint32_t version, SurfaceInterface *surface);
+    ~FifoV1Surface();
+
+private:
+    void wp_fifo_v1_destroy_resource(Resource *resource) override;
+    void wp_fifo_v1_destroy(Resource *resource) override;
+    void wp_fifo_v1_set_barrier(Resource *resource) override;
+    void wp_fifo_v1_wait_barrier(Resource *resource) override;
+
+    const QPointer<SurfaceInterface> m_surface;
+};
+
+}
diff --git a/src/wayland/surface.cpp b/src/wayland/surface.cpp
index 8e3d3252a9..75263b808e 100644
--- a/src/wayland/surface.cpp
+++ b/src/wayland/surface.cpp
@@ -25,6 +25,7 @@
 #include "subcompositor.h"
 #include "surface_p.h"
 #include "transaction.h"
+#include "transaction_p.h"
 #include "utils/resource.h"
 
 #include <wayland-server.h>
@@ -429,6 +430,13 @@ SurfaceInterface::SurfaceInterface(CompositorInterface *compositor, wl_resource
 
 SurfaceInterface::~SurfaceInterface()
 {
+    // ensure that we won't wait on any pending transactions
+    Transaction *transaction = firstTransaction();
+    while (transaction) {
+        transaction->entryFor(this)->state->hasFifoWaitCondition = false;
+        transaction = transaction->next(this);
+    }
+    d->fifoBarrier.reset();
 }
 
 SurfaceRole *SurfaceInterface::role() const
@@ -593,6 +601,8 @@ void SurfaceState::mergeInto(SurfaceState *target)
         target->alphaMultiplier = alphaMultiplier;
         target->alphaMultiplierIsSet = true;
     }
+    target->fifoBarrier = std::move(fifoBarrier);
+    target->hasFifoWaitCondition = hasFifoWaitCondition;
     target->presentationFeedback = std::move(presentationFeedback);
 
     *this = SurfaceState{};
@@ -666,6 +676,8 @@ void SurfaceInterfacePrivate::applyState(SurfaceState *next)
         opaqueRegion = QRegion();
     }
 
+    fifoBarrier = std::move(current->fifoBarrier);
+
     if (opaqueRegionChanged) {
         Q_EMIT q->opaqueChanged(opaqueRegion);
     }
@@ -1194,6 +1206,15 @@ Transaction *SurfaceInterface::firstTransaction() const
 void SurfaceInterface::setFirstTransaction(Transaction *transaction)
 {
     d->firstTransaction = transaction;
+    if (d->fifoBarrier) {
+        const auto entry = transaction ? transaction->entryFor(this) : nullptr;
+        if (entry && entry->state->hasFifoWaitCondition && (!subSurface() || !subSurface()->isSynchronized())) {
+            d->fifoBarrier->setTransaction(transaction);
+            Q_EMIT waitingOnFifo();
+        } else {
+            d->fifoBarrier->setTransaction(nullptr);
+        }
+    }
 }
 
 Transaction *SurfaceInterface::lastTransaction() const
@@ -1228,6 +1249,17 @@ double SurfaceInterface::alphaMultiplier() const
     return d->current->alphaMultiplier;
 }
 
+void SurfaceInterface::prepareFifoPresentation()
+{
+    d->fifoBarrier.reset();
+    for (const auto &subsurface : d->current->subsurface.below) {
+        subsurface->surface()->prepareFifoPresentation();
+    }
+    for (const auto &subsurface : d->current->subsurface.above) {
+        subsurface->surface()->prepareFifoPresentation();
+    }
+}
+
 } // namespace KWin
 
 #include "moc_surface.cpp"
diff --git a/src/wayland/surface.h b/src/wayland/surface.h
index 021f91cac6..9a2986c0ea 100644
--- a/src/wayland/surface.h
+++ b/src/wayland/surface.h
@@ -364,6 +364,13 @@ public:
      */
     SurfaceInterface *mainSurface();
 
+    /**
+     * Should be called immediately before compositing the next non-tearing frame
+     * but always at a minimum rate that guarantees forward progress for the application
+     * (for example 30Hz)
+     */
+    void prepareFifoPresentation();
+
 Q_SIGNALS:
     /**
      * This signal is emitted when the underlying wl_surface resource is about to be freed.
@@ -466,6 +473,12 @@ Q_SIGNALS:
      */
     void stateApplied(quint32 serial);
 
+    /**
+     * This signal is emitted when the surface is waiting on the compositor to call
+     * prepareFifoPresentation before processing the next commit
+     */
+    void waitingOnFifo();
+
 private:
     std::unique_ptr<SurfaceInterfacePrivate> d;
     friend class SurfaceInterfacePrivate;
diff --git a/src/wayland/surface_p.h b/src/wayland/surface_p.h
index 243f05529b..d43b7e89e7 100644
--- a/src/wayland/surface_p.h
+++ b/src/wayland/surface_p.h
@@ -31,6 +31,8 @@ class ColorSurfaceV1;
 class ColorFeedbackSurfaceV1;
 class LinuxDrmSyncObjSurfaceV1;
 class AlphaModifierSurfaceV1;
+class FifoV1Surface;
+class FifoBarrier;
 
 struct SurfaceState
 {
@@ -83,6 +85,8 @@ struct SurfaceState
     } acquirePoint;
     std::shared_ptr<SyncReleasePoint> releasePoint;
     double alphaMultiplier = 1;
+    std::unique_ptr<FifoBarrier> fifoBarrier;
+    bool hasFifoWaitCondition = false;
 
     struct
     {
@@ -161,6 +165,7 @@ public:
 
     Transaction *firstTransaction = nullptr;
     Transaction *lastTransaction = nullptr;
+    std::unique_ptr<FifoBarrier> fifoBarrier;
 
     QList<OutputInterface *> outputs;
     QPointer<OutputInterface> primaryOutput;
@@ -185,6 +190,7 @@ public:
     QList<ColorFeedbackSurfaceV1 *> colorFeedbackSurfaces;
     LinuxDrmSyncObjSurfaceV1 *syncObjV1 = nullptr;
     AlphaModifierSurfaceV1 *alphaModifier = nullptr;
+    FifoV1Surface *fifoSurface = nullptr;
 
     struct
     {
diff --git a/src/wayland/transaction.cpp b/src/wayland/transaction.cpp
index fd53284cff..027ad67b25 100644
--- a/src/wayland/transaction.cpp
+++ b/src/wayland/transaction.cpp
@@ -96,6 +96,28 @@ void TransactionEventFdLocker::unlock()
     delete this;
 }
 
+FifoBarrier::FifoBarrier()
+{
+}
+
+FifoBarrier::~FifoBarrier()
+{
+    if (m_nextTransaction) {
+        m_nextTransaction->unlock();
+    }
+}
+
+void FifoBarrier::setTransaction(Transaction *transaction)
+{
+    if (m_nextTransaction) {
+        m_nextTransaction->unlock();
+    }
+    m_nextTransaction = transaction;
+    if (transaction) {
+        transaction->lock();
+    }
+}
+
 Transaction::Transaction()
 {
 }
@@ -304,6 +326,14 @@ void Transaction::commit()
     }
 }
 
+const TransactionEntry *Transaction::entryFor(SurfaceInterface *surface) const
+{
+    const auto it = std::ranges::find_if(m_entries, [surface](const TransactionEntry &entry) {
+        return entry.surface == surface;
+    });
+    return it == m_entries.end() ? nullptr : &(*it);
+}
+
 } // namespace KWin
 
 #include "moc_transaction.cpp"
diff --git a/src/wayland/transaction.h b/src/wayland/transaction.h
index d138dc8422..da3cf7b5db 100644
--- a/src/wayland/transaction.h
+++ b/src/wayland/transaction.h
@@ -110,6 +110,8 @@ public:
      */
     void commit();
 
+    const TransactionEntry *entryFor(SurfaceInterface *surface) const;
+
 private:
     void apply();
     bool tryApply();
diff --git a/src/wayland/transaction_p.h b/src/wayland/transaction_p.h
index 29a9921e81..d2b64323e1 100644
--- a/src/wayland/transaction_p.h
+++ b/src/wayland/transaction_p.h
@@ -48,4 +48,16 @@ private:
     QSocketNotifier m_notifier;
 };
 
+class FifoBarrier
+{
+public:
+    explicit FifoBarrier();
+    ~FifoBarrier();
+
+    void setTransaction(Transaction *transaction);
+
+private:
+    Transaction *m_nextTransaction = nullptr;
+};
+
 } // namespace KWin
diff --git a/src/wayland_server.cpp b/src/wayland_server.cpp
index 1278713b8d..8b5fd2f79a 100644
--- a/src/wayland_server.cpp
+++ b/src/wayland_server.cpp
@@ -38,6 +38,7 @@
 #include "wayland/drmclientbuffer.h"
 #include "wayland/drmlease_v1.h"
 #include "wayland/externalbrightness_v1.h"
+#include "wayland/fifo_v1.h"
 #include "wayland/filtered_display.h"
 #include "wayland/fixes.h"
 #include "wayland/fractionalscale_v1.h"
@@ -510,6 +511,7 @@ bool WaylandServer::init()
 #if HAVE_WL_FIXES
     new FixesInterface(m_display, m_display);
 #endif
+    m_fifoManager = new FifoManagerV1(m_display, m_display);
     return true;
 }
 
diff --git a/src/wayland_server.h b/src/wayland_server.h
index c0dc30a2fc..762af34505 100644
--- a/src/wayland_server.h
+++ b/src/wayland_server.h
@@ -65,6 +65,7 @@ class ColorManagerV1;
 class LinuxDrmSyncObjV1Interface;
 class RenderBackend;
 class AlphaModifierManagerV1;
+class FifoManagerV1;
 
 class KWIN_EXPORT WaylandServer : public QObject
 {
@@ -294,6 +295,7 @@ private:
     XdgDialogWmV1Interface *m_xdgDialogWm = nullptr;
     ExternalBrightnessV1 *m_externalBrightness = nullptr;
     AlphaModifierManagerV1 *m_alphaModifierManager = nullptr;
+    FifoManagerV1 *m_fifoManager = nullptr;
     KWIN_SINGLETON(WaylandServer)
 };
 
-- 
2.48.1

From 84fab6a044d044f0205dfd13636cbc2e095fb508 Mon Sep 17 00:00:00 2001
From: Xaver Hugl <xaver.hugl@gmail.com>
Date: Mon, 10 Mar 2025 13:23:50 +0000
Subject: [PATCH] backends/drm: let DrmGpu do modesets for dpms off

This unifies the code paths for all modesets, and means that we asynchronously wait
for the output to be idle rather than relying on waitIdle.

Should address some more cases of https://crash-reports.kde.org/organizations/kde/issues/4603


(cherry picked from commit 6da815b30c2ff8ffe8478428f4c0f2505b7117d7)

Co-authored-by: Xaver Hugl <xaver.hugl@gmail.com>
---
 src/backends/drm/drm_output.cpp | 8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)

diff --git a/src/backends/drm/drm_output.cpp b/src/backends/drm/drm_output.cpp
index ab25f74839..22c96808f7 100644
--- a/src/backends/drm/drm_output.cpp
+++ b/src/backends/drm/drm_output.cpp
@@ -178,11 +178,8 @@ bool DrmOutput::setDrmDpmsMode(DpmsMode mode)
         updateDpmsMode(mode);
         return true;
     }
-    if (!active) {
-        m_gpu->waitIdle();
-    }
     m_pipeline->setActive(active);
-    if (DrmPipeline::commitPipelines({m_pipeline}, active ? DrmPipeline::CommitMode::TestAllowModeset : DrmPipeline::CommitMode::CommitModeset) == DrmPipeline::Error::None) {
+    if (DrmPipeline::commitPipelines({m_pipeline}, DrmPipeline::CommitMode::TestAllowModeset) == DrmPipeline::Error::None) {
         m_pipeline->applyPendingChanges();
         updateDpmsMode(mode);
         if (active) {
@@ -192,6 +189,9 @@ bool DrmOutput::setDrmDpmsMode(DpmsMode mode)
             tryKmsColorOffloading();
         } else {
             m_renderLoop->inhibit();
+            // with the renderloop inhibited, there won't be a new frame
+            // to trigger this automatically
+            m_gpu->maybeModeset(m_pipeline, nullptr);
         }
         return true;
     } else {
-- 
GitLab

From eb2f578d8abf651fb04be477df86f1e6eee62384 Mon Sep 17 00:00:00 2001
From: Xaver Hugl <xaver.hugl@gmail.com>
Date: Fri, 7 Mar 2025 18:39:24 +0100
Subject: [PATCH 1/3] backends/drm: create pipelines for outputs, not for all
 connectors

Now the pipeline and commit thread always have the same life time as
the output, rather than sometimes matching and sometimes not.

This makes it a lot easier to track and deal with pending pageflips
and the lifetime of commit objects

(cherry picked from commit 7dcedf62842acdc130d2ab55b9d7f440afecc900)
---
 src/backends/drm/drm_connector.cpp |  6 -----
 src/backends/drm/drm_connector.h   |  3 ---
 src/backends/drm/drm_gpu.cpp       | 35 +++++++++++++++++-------------
 src/backends/drm/drm_gpu.h         |  1 +
 src/backends/drm/drm_output.cpp    |  9 ++------
 src/backends/drm/drm_output.h      |  3 +--
 src/backends/drm/drm_pipeline.cpp  |  6 ++---
 7 files changed, 26 insertions(+), 37 deletions(-)

diff --git a/src/backends/drm/drm_connector.cpp b/src/backends/drm/drm_connector.cpp
index a8a0476fb5d..09a6c85e2d4 100644
--- a/src/backends/drm/drm_connector.cpp
+++ b/src/backends/drm/drm_connector.cpp
@@ -157,7 +157,6 @@ bool DrmConnector::init()
     }
 
     m_possibleCrtcs = drmModeConnectorGetPossibleCrtcs(gpu()->fd(), m_conn.get());
-    m_pipeline = std::make_unique<DrmPipeline>(this);
 
     return true;
 }
@@ -343,11 +342,6 @@ const Edid *DrmConnector::edid() const
     return &m_edid;
 }
 
-DrmPipeline *DrmConnector::pipeline() const
-{
-    return m_pipeline.get();
-}
-
 void DrmConnector::disable(DrmAtomicCommit *commit)
 {
     commit->addProperty(crtcId, 0);
diff --git a/src/backends/drm/drm_connector.h b/src/backends/drm/drm_connector.h
index 6db28cd3ea1..5860d9e3542 100644
--- a/src/backends/drm/drm_connector.h
+++ b/src/backends/drm/drm_connector.h
@@ -23,7 +23,6 @@
 namespace KWin
 {
 
-class DrmPipeline;
 class DrmConnector;
 class DrmCrtc;
 
@@ -62,7 +61,6 @@ public:
     bool isConnected() const;
     bool isNonDesktop() const;
     bool isInternal() const;
-    DrmPipeline *pipeline() const;
 
     const Edid *edid() const;
     QString connectorName() const;
@@ -148,7 +146,6 @@ private:
     std::shared_ptr<DrmConnectorMode> generateMode(const QSize &size, float refreshRate);
 
     DrmUniquePtr<drmModeConnector> m_conn;
-    std::unique_ptr<DrmPipeline> m_pipeline;
     Edid m_edid;
     QSize m_physicalSize = QSize(-1, -1);
     QList<std::shared_ptr<DrmConnectorMode>> m_driverModes;
diff --git a/src/backends/drm/drm_gpu.cpp b/src/backends/drm/drm_gpu.cpp
index 3107ed51732..64f86b8c621 100644
--- a/src/backends/drm/drm_gpu.cpp
+++ b/src/backends/drm/drm_gpu.cpp
@@ -309,9 +309,10 @@ bool DrmGpu::updateOutputs()
             }
         } else if (!output) {
             qCDebug(KWIN_DRM, "New %soutput on GPU %s: %s", conn->isNonDesktop() ? "non-desktop " : "", qPrintable(m_drmDevice->path()), qPrintable(conn->modelName()));
-            const auto pipeline = conn->pipeline();
-            m_pipelines << pipeline;
-            auto output = new DrmOutput(*it);
+            auto &pipeline = m_pipelineMap[conn];
+            pipeline = std::make_unique<DrmPipeline>(conn);
+            m_pipelines.push_back(pipeline.get());
+            auto output = new DrmOutput(*it, pipeline.get());
             m_drmOutputs << output;
             addedOutputs << output;
             Q_EMIT outputAdded(output);
@@ -352,7 +353,12 @@ DrmPipeline::Error DrmGpu::checkCrtcAssignment(QList<DrmConnector *> connectors,
     }
     qCDebug(KWIN_DRM) << "Attempting to match" << connectors << "with" << crtcs;
     auto connector = connectors.takeFirst();
-    auto pipeline = connector->pipeline();
+    auto pipelineIt = m_pipelineMap.find(connector);
+    if (pipelineIt == m_pipelineMap.end()) {
+        // this connector doesn't even have a connected output
+        return checkCrtcAssignment(connectors, crtcs);
+    }
+    auto pipeline = pipelineIt->second.get();
     if (!pipeline->enabled() || !connector->isConnected()) {
         // disabled pipelines don't need CRTCs
         pipeline->setCrtc(nullptr);
@@ -433,16 +439,14 @@ DrmPipeline::Error DrmGpu::testPendingConfiguration()
         if (!pipeline->primaryLayer()) {
             pipeline->setLayers(m_platform->renderBackend()->createDrmPlaneLayer(pipeline, DrmPlane::TypeIndex::Primary), m_platform->renderBackend()->createDrmPlaneLayer(pipeline, DrmPlane::TypeIndex::Cursor));
         }
-    }
-    // reset all outputs to their most basic configuration (primary plane without scaling)
-    // for the test, and set the target rects appropriately
-    for (const auto output : std::as_const(m_drmOutputs)) {
-        if (!output->lease()) {
-            const auto primary = output->primaryLayer();
-            primary->setTargetRect(QRect(QPoint(0, 0), output->connector()->pipeline()->mode()->size()));
-            primary->setSourceRect(QRect(QPoint(0, 0), output->connector()->pipeline()->mode()->size()));
+        if (!pipeline->output()->lease()) {
+            // reset all outputs to their most basic configuration (primary plane without scaling)
+            // for the test, and set the target rects appropriately
+            const auto primary = pipeline->output()->primaryLayer();
+            primary->setTargetRect(QRect(QPoint(0, 0), pipeline->mode()->size()));
+            primary->setSourceRect(QRect(QPoint(0, 0), pipeline->mode()->size()));
             primary->setEnabled(true);
-            output->cursorLayer()->setEnabled(false);
+            pipeline->output()->cursorLayer()->setEnabled(false);
         }
     }
     return checkCrtcAssignment(connectors, crtcs);
@@ -450,12 +454,12 @@ DrmPipeline::Error DrmGpu::testPendingConfiguration()
 
 DrmPipeline::Error DrmGpu::testPipelines()
 {
-    if (m_pipelines.isEmpty()) {
+    if (m_pipelines.empty()) {
         // nothing to do
         return DrmPipeline::Error::None;
     }
     QList<DrmPipeline *> inactivePipelines;
-    std::copy_if(m_pipelines.constBegin(), m_pipelines.constEnd(), std::back_inserter(inactivePipelines), [](const auto pipeline) {
+    std::ranges::copy_if(m_pipelines, std::back_inserter(inactivePipelines), [](const auto pipeline) {
         return pipeline->enabled() && !pipeline->active();
     });
     DrmPipeline::Error test = DrmPipeline::commitPipelines(m_pipelines, DrmPipeline::CommitMode::TestAllowModeset, unusedObjects());
@@ -584,6 +588,7 @@ void DrmGpu::removeOutput(DrmOutput *output)
     output->pipeline()->setLayers(nullptr, nullptr);
     m_drmOutputs.removeOne(output);
     Q_EMIT outputRemoved(output);
+    m_pipelineMap.erase(output->connector());
     output->unref();
     // force a modeset to make sure unused objects are cleaned up
     m_forceModeset = true;
diff --git a/src/backends/drm/drm_gpu.h b/src/backends/drm/drm_gpu.h
index 1fc7d8b4f22..d33b35738dd 100644
--- a/src/backends/drm/drm_gpu.h
+++ b/src/backends/drm/drm_gpu.h
@@ -160,6 +160,7 @@ private:
     std::vector<std::unique_ptr<DrmPlane>> m_planes;
     std::vector<std::unique_ptr<DrmCrtc>> m_crtcs;
     std::vector<std::shared_ptr<DrmConnector>> m_connectors;
+    std::unordered_map<DrmConnector *, std::unique_ptr<DrmPipeline>> m_pipelineMap;
     QList<DrmObject *> m_allObjects;
     QList<DrmPipeline *> m_pipelines;
 
diff --git a/src/backends/drm/drm_output.cpp b/src/backends/drm/drm_output.cpp
index 9fe608d16a7..912f0e9abe5 100644
--- a/src/backends/drm/drm_output.cpp
+++ b/src/backends/drm/drm_output.cpp
@@ -40,9 +40,9 @@ namespace KWin
 static bool s_disableTripleBufferingSet = false;
 static const bool s_disableTripleBuffering = qEnvironmentVariableIntValue("KWIN_DRM_DISABLE_TRIPLE_BUFFERING", &s_disableTripleBufferingSet) == 1;
 
-DrmOutput::DrmOutput(const std::shared_ptr<DrmConnector> &conn)
+DrmOutput::DrmOutput(const std::shared_ptr<DrmConnector> &conn, DrmPipeline *pipeline)
     : m_gpu(conn->gpu())
-    , m_pipeline(conn->pipeline())
+    , m_pipeline(pipeline)
     , m_connector(conn)
 {
     m_pipeline->setOutput(this);
@@ -81,11 +81,6 @@ DrmOutput::DrmOutput(const std::shared_ptr<DrmConnector> &conn)
     });
 }
 
-DrmOutput::~DrmOutput()
-{
-    m_pipeline->setOutput(nullptr);
-}
-
 bool DrmOutput::addLeaseObjects(QList<uint32_t> &objectList)
 {
     if (!m_pipeline->crtc()) {
diff --git a/src/backends/drm/drm_output.h b/src/backends/drm/drm_output.h
index 432cf63b526..ae91ab62b53 100644
--- a/src/backends/drm/drm_output.h
+++ b/src/backends/drm/drm_output.h
@@ -35,8 +35,7 @@ class KWIN_EXPORT DrmOutput : public DrmAbstractOutput
 {
     Q_OBJECT
 public:
-    explicit DrmOutput(const std::shared_ptr<DrmConnector> &connector);
-    ~DrmOutput() override;
+    explicit DrmOutput(const std::shared_ptr<DrmConnector> &connector, DrmPipeline *pipeline);
 
     DrmConnector *connector() const;
     DrmPipeline *pipeline() const;
diff --git a/src/backends/drm/drm_pipeline.cpp b/src/backends/drm/drm_pipeline.cpp
index 46e7ec22ee1..48e363bfc3e 100644
--- a/src/backends/drm/drm_pipeline.cpp
+++ b/src/backends/drm/drm_pipeline.cpp
@@ -420,10 +420,8 @@ void DrmPipeline::applyPendingChanges()
 {
     m_next = m_pending;
     m_commitThread->setModeInfo(m_pending.mode->refreshRate(), m_pending.mode->vblankTime());
-    if (m_output) {
-        m_output->renderLoop()->setPresentationSafetyMargin(m_commitThread->safetyMargin());
-        m_output->renderLoop()->setRefreshRate(m_pending.mode->refreshRate());
-    }
+    m_output->renderLoop()->setPresentationSafetyMargin(m_commitThread->safetyMargin());
+    m_output->renderLoop()->setRefreshRate(m_pending.mode->refreshRate());
 }
 
 DrmConnector *DrmPipeline::connector() const
-- 
GitLab


From 4576145588b87488e9396c68cd5e300b757bb5a9 Mon Sep 17 00:00:00 2001
From: Xaver Hugl <xaver.hugl@gmail.com>
Date: Fri, 7 Mar 2025 16:56:05 +0100
Subject: [PATCH 2/3] backends/drm: don't crash if there's a pending pageflip
 when a pipeline gets deleted

We avoided this situation as much as possible so far, but the effort to do that is greater than
handling it gracefully this way.

To ensure we don't access dangling pointers, the commits and OutputFrame objects get marked as
"defunct", which prevents them from modifying more state than absolutely necessary.

This shouhld fix the remaining cases of https://crash-reports.kde.org/organizations/kde/issues/4603

(cherry picked from commit 41433a29b9c0fcec5532525e13632fa3ccf14b37)
---
 src/backends/drm/drm_commit.cpp        | 11 +++++++++++
 src/backends/drm/drm_commit.h          |  2 ++
 src/backends/drm/drm_commit_thread.cpp |  4 ++++
 src/backends/drm/drm_gpu.cpp           | 11 +++++++++++
 src/backends/drm/drm_gpu.h             |  4 ++++
 src/backends/drm/drm_pipeline.cpp      |  3 +++
 6 files changed, 35 insertions(+)

diff --git a/src/backends/drm/drm_commit.cpp b/src/backends/drm/drm_commit.cpp
index fc2e4053557..6b201f9d88d 100644
--- a/src/backends/drm/drm_commit.cpp
+++ b/src/backends/drm/drm_commit.cpp
@@ -39,6 +39,11 @@ DrmGpu *DrmCommit::gpu() const
     return m_gpu;
 }
 
+void DrmCommit::setDefunct()
+{
+    m_defunct = true;
+}
+
 DrmAtomicCommit::DrmAtomicCommit(DrmGpu *gpu)
     : DrmCommit(gpu)
 {
@@ -166,6 +171,9 @@ void DrmAtomicCommit::pageFlipped(std::chrono::nanoseconds timestamp)
     for (const auto &[plane, buffer] : m_buffers) {
         plane->setCurrentBuffer(buffer);
     }
+    if (m_defunct) {
+        return;
+    }
     for (const auto &[plane, frame] : m_frames) {
         if (frame) {
             frame->presented(timestamp, m_mode);
@@ -295,6 +303,9 @@ void DrmLegacyCommit::pageFlipped(std::chrono::nanoseconds timestamp)
 {
     Q_ASSERT(QThread::currentThread() == QCoreApplication::instance()->thread());
     m_crtc->setCurrent(m_buffer);
+    if (m_defunct) {
+        return;
+    }
     if (m_frame) {
         m_frame->presented(timestamp, m_mode);
         m_frame.reset();
diff --git a/src/backends/drm/drm_commit.h b/src/backends/drm/drm_commit.h
index 6f623c1f82a..337ea460ba6 100644
--- a/src/backends/drm/drm_commit.h
+++ b/src/backends/drm/drm_commit.h
@@ -41,11 +41,13 @@ public:
 
     DrmGpu *gpu() const;
     virtual void pageFlipped(std::chrono::nanoseconds timestamp) = 0;
+    void setDefunct();
 
 protected:
     DrmCommit(DrmGpu *gpu);
 
     DrmGpu *const m_gpu;
+    bool m_defunct = false;
 };
 
 class DrmAtomicCommit : public DrmCommit
diff --git a/src/backends/drm/drm_commit_thread.cpp b/src/backends/drm/drm_commit_thread.cpp
index 91c0ba24500..2b23b59bb35 100644
--- a/src/backends/drm/drm_commit_thread.cpp
+++ b/src/backends/drm/drm_commit_thread.cpp
@@ -301,6 +301,10 @@ DrmCommitThread::~DrmCommitThread()
             m_pong.notify_all();
         }
         m_thread->wait();
+        if (m_committed) {
+            m_committed->setDefunct();
+            m_gpu->addDefunctCommit(std::move(m_committed));
+        }
     }
 }
 
diff --git a/src/backends/drm/drm_gpu.cpp b/src/backends/drm/drm_gpu.cpp
index 64f86b8c621..9ac1a88398c 100644
--- a/src/backends/drm/drm_gpu.cpp
+++ b/src/backends/drm/drm_gpu.cpp
@@ -557,6 +557,12 @@ void DrmGpu::pageFlipHandler(int fd, unsigned int sequence, unsigned int sec, un
 {
     const auto commit = static_cast<DrmCommit *>(user_data);
     const auto gpu = commit->gpu();
+    const bool defunct = std::erase_if(gpu->m_defunctCommits, [commit](const auto &defunct) {
+        return defunct.get() == commit;
+    }) != 0;
+    if (defunct) {
+        return;
+    }
 
     // The static_cast<> here are for a 32-bit environment where
     // sizeof(time_t) == sizeof(unsigned int) == 4 . Putting @p sec
@@ -581,6 +587,11 @@ void DrmGpu::dispatchEvents()
     drmHandleEvent(m_fd, &context);
 }
 
+void DrmGpu::addDefunctCommit(std::unique_ptr<DrmCommit> &&commit)
+{
+    m_defunctCommits.push_back(std::move(commit));
+}
+
 void DrmGpu::removeOutput(DrmOutput *output)
 {
     qCDebug(KWIN_DRM) << "Removing output" << output;
diff --git a/src/backends/drm/drm_gpu.h b/src/backends/drm/drm_gpu.h
index d33b35738dd..e76a1119dbb 100644
--- a/src/backends/drm/drm_gpu.h
+++ b/src/backends/drm/drm_gpu.h
@@ -39,6 +39,7 @@ class EglDisplay;
 class GraphicsBuffer;
 class GraphicsBufferAllocator;
 class OutputFrame;
+class DrmCommit;
 
 class DrmLease : public QObject
 {
@@ -121,6 +122,8 @@ public:
     bool isIdle() const;
     void dispatchEvents();
 
+    void addDefunctCommit(std::unique_ptr<DrmCommit> &&commit);
+
 Q_SIGNALS:
     void activeChanged(bool active);
     void outputAdded(DrmAbstractOutput *output);
@@ -170,6 +173,7 @@ private:
     QSize m_cursorSize;
     std::unordered_map<DrmPipeline *, std::shared_ptr<OutputFrame>> m_pendingModesetFrames;
     bool m_inModeset = false;
+    std::vector<std::unique_ptr<DrmCommit>> m_defunctCommits;
 };
 
 }
diff --git a/src/backends/drm/drm_pipeline.cpp b/src/backends/drm/drm_pipeline.cpp
index 48e363bfc3e..d210a59a250 100644
--- a/src/backends/drm/drm_pipeline.cpp
+++ b/src/backends/drm/drm_pipeline.cpp
@@ -46,6 +46,9 @@ DrmPipeline::DrmPipeline(DrmConnector *conn)
 
 DrmPipeline::~DrmPipeline()
 {
+    // the commit thread may still access the pipeline until it's stopped
+    // so it must be deleted before everything else
+    m_commitThread.reset();
 }
 
 DrmPipeline::Error DrmPipeline::present(const std::shared_ptr<OutputFrame> &frame)
-- 
GitLab


From 94bcabf67ebc861764efa2c0ad576449180b6ac5 Mon Sep 17 00:00:00 2001
From: Xaver Hugl <xaver.hugl@gmail.com>
Date: Fri, 7 Mar 2025 18:50:10 +0100
Subject: [PATCH 3/3] backends/drm: remove DrmGpu::waitIdle

As pending pageflip events are now always handled gracefully, even when an output
is deleted, we don't have to wait for them before updating outputs anymore.

With that change, the last user of DrmGpu::waitIdle is gone, and the method can
be removed entirely.

(cherry picked from commit 0f146a6f258708761d2ecfcc6fbb0e4abe5068b6)
---
 src/backends/drm/drm_gpu.cpp | 37 ------------------------------------
 src/backends/drm/drm_gpu.h   |  1 -
 2 files changed, 38 deletions(-)

diff --git a/src/backends/drm/drm_gpu.cpp b/src/backends/drm/drm_gpu.cpp
index 9ac1a88398c..0bf2b27a43f 100644
--- a/src/backends/drm/drm_gpu.cpp
+++ b/src/backends/drm/drm_gpu.cpp
@@ -245,7 +245,6 @@ bool DrmGpu::updateOutputs()
     if (!m_isActive) {
         return false;
     }
-    waitIdle();
     DrmUniquePtr<drmModeRes> resources(drmModeGetResources(m_fd));
     if (!resources) {
         qCWarning(KWIN_DRM) << "drmModeGetResources failed:" << strerror(errno);
@@ -488,42 +487,6 @@ DrmOutput *DrmGpu::findOutput(quint32 connector)
     return nullptr;
 }
 
-void DrmGpu::waitIdle()
-{
-    m_socketNotifier->setEnabled(false);
-
-    // CLOCK_MONOTONIC should not count the time when the system is suspended, however the Linux kernel
-    // does not follow this part of the POSIX standard. So a timeout can be reported when it must not be.
-    // As a workaround, multiple poll() attempts are made.
-    int attempt = 0;
-    while (attempt < 5) {
-        const bool hasPendingCommit = std::ranges::any_of(m_pipelines, [](DrmPipeline *pipeline) {
-            return pipeline->commitThread()->drain();
-        });
-        if (!hasPendingCommit) {
-            break;
-        }
-        pollfd pfds[1];
-        pfds[0].fd = m_fd;
-        pfds[0].events = POLLIN;
-
-        const int ready = poll(pfds, 1, s_pageflipTimeout.count());
-        if (ready < 0) {
-            if (errno != EINTR) {
-                qCWarning(KWIN_DRM) << Q_FUNC_INFO << "poll() failed:" << strerror(errno);
-                break;
-            }
-        } else if (ready == 0) {
-            qCWarning(KWIN_DRM) << "No drm events for gpu" << this << "within last 1 second";
-            attempt++;
-        } else {
-            dispatchEvents();
-        }
-    };
-
-    m_socketNotifier->setEnabled(true);
-}
-
 bool DrmGpu::isIdle() const
 {
     return std::ranges::none_of(m_pipelines, [](DrmPipeline *pipeline) {
diff --git a/src/backends/drm/drm_gpu.h b/src/backends/drm/drm_gpu.h
index e76a1119dbb..efff4078b52 100644
--- a/src/backends/drm/drm_gpu.h
+++ b/src/backends/drm/drm_gpu.h
@@ -118,7 +118,6 @@ public:
 
     FileDescriptor createNonMasterFd() const;
     std::unique_ptr<DrmLease> leaseOutputs(const QList<DrmOutput *> &outputs);
-    void waitIdle();
     bool isIdle() const;
     void dispatchEvents();
 
-- 
GitLab
