From a53733caccebf9aa73ea50bee3898a1aecbb9eae Mon Sep 17 00:00:00 2001
From: David Redondo <kde@david-redondo.de>
Date: Fri, 12 Jul 2024 11:11:34 +0200
Subject: [PATCH 1/5] Allow passing extra environment variables to Xwayland

---
 src/main_wayland.cpp              | 1 +
 src/main_wayland.h                | 5 +++++
 src/xwayland/xwaylandlauncher.cpp | 9 +++++++++
 src/xwayland/xwaylandlauncher.h   | 4 ++++
 4 files changed, 19 insertions(+)

diff --git a/src/main_wayland.cpp b/src/main_wayland.cpp
index 26d51b4..85b0777 100644
--- a/src/main_wayland.cpp
+++ b/src/main_wayland.cpp
@@ -162,6 +162,7 @@ void ApplicationWayland::performStartup()
         m_xwayland->xwaylandLauncher()->setListenFDs(m_xwaylandListenFds);
         m_xwayland->xwaylandLauncher()->setDisplayName(m_xwaylandDisplay);
         m_xwayland->xwaylandLauncher()->setXauthority(m_xwaylandXauthority);
+        m_xwayland->xwaylandLauncher()->addEnvironmentVariables(m_xwaylandExtraEnvironment);
         m_xwayland->init();
         connect(m_xwayland.get(), &Xwl::Xwayland::started, this, &ApplicationWayland::applyXwaylandScale);
     }
diff --git a/src/main_wayland.h b/src/main_wayland.h
index 5f5408a..c4686dc 100644
--- a/src/main_wayland.h
+++ b/src/main_wayland.h
@@ -42,6 +42,10 @@ public:
     {
         m_xwaylandXauthority = xauthority;
     }
+    void addExtraXWaylandEnvrionmentVariable(const QString &variable, const QString &value)
+    {
+        m_xwaylandExtraEnvironment.insert(variable, value);
+    }
     XwaylandInterface *xwayland() const override;
 #endif
     void setApplicationsToStart(const QStringList &applications)
@@ -74,6 +78,7 @@ private:
     QList<int> m_xwaylandListenFds;
     QString m_xwaylandDisplay;
     QString m_xwaylandXauthority;
+    QMap<QString, QString> m_xwaylandExtraEnvironment;
 #endif
     KConfigWatcher::Ptr m_settingsWatcher;
 };
diff --git a/src/xwayland/xwaylandlauncher.cpp b/src/xwayland/xwaylandlauncher.cpp
index ab27713..1621a6f 100644
--- a/src/xwayland/xwaylandlauncher.cpp
+++ b/src/xwayland/xwaylandlauncher.cpp
@@ -72,6 +72,11 @@ void XwaylandLauncher::setXauthority(const QString &xauthority)
     m_xAuthority = xauthority;
 }
 
+void XwaylandLauncher::addEnvironmentVariables(const QMap<QString, QString> &extraEnvironment)
+{
+    m_extraEnvironment.insert(extraEnvironment);
+}
+
 void XwaylandLauncher::enable()
 {
     if (m_enabled) {
@@ -176,6 +181,10 @@ bool XwaylandLauncher::start()
         env.insert("WAYLAND_DEBUG", QByteArrayLiteral("1"));
     }
 
+    for (const auto &[variable, value] : m_extraEnvironment.asKeyValueRange()) {
+        env.insert(variable, value);
+    }
+
     m_xwaylandProcess = new QProcess(this);
     m_xwaylandProcess->setProgram(QStandardPaths::findExecutable("Xwayland"));
     m_xwaylandProcess->setArguments(arguments);
diff --git a/src/xwayland/xwaylandlauncher.h b/src/xwayland/xwaylandlauncher.h
index 7e54d65..e499800 100644
--- a/src/xwayland/xwaylandlauncher.h
+++ b/src/xwayland/xwaylandlauncher.h
@@ -13,6 +13,7 @@
 #include "utils/filedescriptor.h"
 
 #include <QList>
+#include <QMap>
 #include <QObject>
 #include <QProcess>
 #include <QSocketNotifier>
@@ -58,6 +59,8 @@ public:
      */
     void setXauthority(const QString &xauthority);
 
+    void addEnvironmentVariables(const QMap<QString, QString> &extraEnvironment);
+
     void enable();
     void disable();
     bool start();
@@ -103,6 +106,7 @@ private:
     QList<int> m_listenFds;
     QString m_displayName;
     QString m_xAuthority;
+    QMap<QString, QString> m_extraEnvironment;
 
     bool m_enabled = false;
     int m_crashCount = 0;
-- 
2.48.1


From a6f5639b6664e5e592c19b2c367eb1f4e0631e76 Mon Sep 17 00:00:00 2001
From: David Redondo <kde@david-redondo.de>
Date: Tue, 30 Jul 2024 14:35:30 +0200
Subject: [PATCH 2/5] Allow specifying file descriptors that are passed to
 Xwayland

---
 src/main_wayland.cpp              |  1 +
 src/main_wayland.h                |  9 +++++++++
 src/xwayland/xwaylandlauncher.cpp | 13 +++++++++++++
 src/xwayland/xwaylandlauncher.h   |  3 +++
 4 files changed, 26 insertions(+)

diff --git a/src/main_wayland.cpp b/src/main_wayland.cpp
index 85b0777..f961760 100644
--- a/src/main_wayland.cpp
+++ b/src/main_wayland.cpp
@@ -163,6 +163,7 @@ void ApplicationWayland::performStartup()
         m_xwayland->xwaylandLauncher()->setDisplayName(m_xwaylandDisplay);
         m_xwayland->xwaylandLauncher()->setXauthority(m_xwaylandXauthority);
         m_xwayland->xwaylandLauncher()->addEnvironmentVariables(m_xwaylandExtraEnvironment);
+        m_xwayland->xwaylandLauncher()->passFileDescriptors(std::move(m_xwaylandFds));
         m_xwayland->init();
         connect(m_xwayland.get(), &Xwl::Xwayland::started, this, &ApplicationWayland::applyXwaylandScale);
     }
diff --git a/src/main_wayland.h b/src/main_wayland.h
index c4686dc..b7ea152 100644
--- a/src/main_wayland.h
+++ b/src/main_wayland.h
@@ -11,6 +11,10 @@
 #include <KConfigWatcher>
 #include <QTimer>
 
+#include "utils/filedescriptor.h"
+
+#include <vector>
+
 namespace KWin
 {
 namespace Xwl
@@ -46,6 +50,10 @@ public:
     {
         m_xwaylandExtraEnvironment.insert(variable, value);
     }
+    void passFdToXwayland(FileDescriptor &&fd)
+    {
+        m_xwaylandFds.push_back(std::move(fd));
+    }
     XwaylandInterface *xwayland() const override;
 #endif
     void setApplicationsToStart(const QStringList &applications)
@@ -79,6 +87,7 @@ private:
     QString m_xwaylandDisplay;
     QString m_xwaylandXauthority;
     QMap<QString, QString> m_xwaylandExtraEnvironment;
+    std::vector<FileDescriptor> m_xwaylandFds;
 #endif
     KConfigWatcher::Ptr m_settingsWatcher;
 };
diff --git a/src/xwayland/xwaylandlauncher.cpp b/src/xwayland/xwaylandlauncher.cpp
index 1621a6f..da7ba01 100644
--- a/src/xwayland/xwaylandlauncher.cpp
+++ b/src/xwayland/xwaylandlauncher.cpp
@@ -37,6 +37,7 @@
 #include <cerrno>
 #include <cstring>
 #include <fcntl.h>
+#include <ranges>
 #include <sys/socket.h>
 #include <unistd.h>
 
@@ -77,6 +78,14 @@ void XwaylandLauncher::addEnvironmentVariables(const QMap<QString, QString> &ext
     m_extraEnvironment.insert(extraEnvironment);
 }
 
+void XwaylandLauncher::passFileDescriptors(std::vector<FileDescriptor> &&fds)
+{
+    m_fdsToPreserve.reserve(m_fdsToPreserve.size() + fds.size());
+    for (auto & fd : fds) {
+        m_fdsToPreserve.emplace_back(std::move(fd));
+    }
+}
+
 void XwaylandLauncher::enable()
 {
     if (m_enabled) {
@@ -191,6 +200,10 @@ bool XwaylandLauncher::start()
     m_xwaylandProcess->setProcessChannelMode(QProcess::ForwardedErrorChannel);
     m_xwaylandProcess->setProcessEnvironment(env);
     m_xwaylandProcess->setChildProcessModifier([this, fdsToPass]() {
+        for (const auto &fd : m_fdsToPreserve) {
+            int flags = fcntl(fd.get(), F_GETFD);
+            fcntl(fd.get(), F_SETFD, flags & ~FD_CLOEXEC);
+        }
         for (const int &fd : fdsToPass) {
             const int originalFlags = fcntl(fd, F_GETFD);
             if (originalFlags < 0) {
diff --git a/src/xwayland/xwaylandlauncher.h b/src/xwayland/xwaylandlauncher.h
index e499800..df5d3be 100644
--- a/src/xwayland/xwaylandlauncher.h
+++ b/src/xwayland/xwaylandlauncher.h
@@ -61,6 +61,8 @@ public:
 
     void addEnvironmentVariables(const QMap<QString, QString> &extraEnvironment);
 
+    void passFileDescriptors(std::vector<FileDescriptor> &&fds);
+
     void enable();
     void disable();
     bool start();
@@ -107,6 +109,7 @@ private:
     QString m_displayName;
     QString m_xAuthority;
     QMap<QString, QString> m_extraEnvironment;
+    std::vector<FileDescriptor> m_fdsToPreserve;
 
     bool m_enabled = false;
     int m_crashCount = 0;
-- 
2.48.1


From fce5bad8cd526f7bf6caf3fa2bee9b36d181af2b Mon Sep 17 00:00:00 2001
From: David Redondo <kde@david-redondo.de>
Date: Fri, 12 Jul 2024 14:58:34 +0200
Subject: [PATCH 3/5] Enable Xwayland xtest input emulation without going
 through the portal

Due to the limited libei(s) API a trick is used. Let it create
a socket with an absolute path, open that path again to get a fd
referring to the socket, unlink the file and specify the socket
that Xwayland should use in the form of /proc/self/fd/$fd.
---
 src/plugins/eis/eisbackend.cpp    | 34 +++++++++++++++++++++++++++----
 src/plugins/eis/eisbackend.h      |  6 ++++--
 src/plugins/eis/eiscontext.cpp    | 30 +++++++++++++++++++--------
 src/plugins/eis/eiscontext.h      | 26 ++++++++++++++++++-----
 src/xwayland/xwaylandlauncher.cpp |  3 ---
 5 files changed, 76 insertions(+), 23 deletions(-)

diff --git a/src/plugins/eis/eisbackend.cpp b/src/plugins/eis/eisbackend.cpp
index 43eca32..e1c2547 100644
--- a/src/plugins/eis/eisbackend.cpp
+++ b/src/plugins/eis/eisbackend.cpp
@@ -14,7 +14,7 @@
 #include "input.h"
 #include "keyboard_input.h"
 #include "keyboard_layout.h"
-#include "main.h"
+#include "main_wayland.h"
 #include "workspace.h"
 #include "xkb.h"
 
@@ -26,19 +26,45 @@
 
 #include <libeis.h>
 
+#include <fcntl.h>
+
 #include <ranges>
 
 namespace KWin
 {
 
+#define typeName(T)                                       \
+    [] {                                                  \
+        static_assert(                                    \
+            requires { typename T; }, "T is not a type"); \
+        return #T;                                        \
+        }()
+
 EisBackend::EisBackend(QObject *parent)
     : KWin::InputBackend(parent)
     , m_serviceWatcher(new QDBusServiceWatcher(this))
+
 {
+#if HAVE_XWAYLAND_ENABLE_EI_PORTAL
+    if (kwinApp()->operationMode() == Application::OperationModeWayland) {
+        // Unfortunately there is no way to pass a connected socket fd to libei like WAYLAND_SOCKET
+        // in libwayland so we are resorting to this hack
+        // https://gitlab.freedesktop.org/libinput/libei/-/issues/63
+        m_xWaylandContext = std::make_unique<XWaylandEisContext>(this);
+        FileDescriptor fd(open(m_xWaylandContext->socketName.constData(), O_PATH | O_CLOEXEC));
+        unlink(m_xWaylandContext->socketName.constData());
+        if (QByteArray(kwinApp()->metaObject()->className()) == typeName(KWin::ApplicationWayland)) {
+            auto appWayland = static_cast<ApplicationWayland *>(kwinApp());
+            appWayland->addExtraXWaylandEnvrionmentVariable(QStringLiteral("LIBEI_SOCKET"), QStringLiteral("/proc/self/fd/%1").arg(fd.get()));
+            appWayland->passFdToXwayland(std::move(fd));
+        }
+    }
+#endif
+
     m_serviceWatcher->setConnection(QDBusConnection::sessionBus());
     m_serviceWatcher->setWatchMode(QDBusServiceWatcher::WatchForUnregistration);
     connect(m_serviceWatcher, &QDBusServiceWatcher::serviceUnregistered, this, [this](const QString &service) {
-        std::erase_if(m_contexts, [&service](const std::unique_ptr<EisContext> &context) {
+        std::erase_if(m_contexts, [&service](const std::unique_ptr<DbusEisContext> &context) {
             return context->dbusService == service;
         });
         m_serviceWatcher->removeWatchedService(service);
@@ -92,14 +118,14 @@ QDBusUnixFileDescriptor EisBackend::connectToEIS(const int &capabilities, int &c
     const QString dbusService = message().service();
     static int s_cookie = 0;
     cookie = ++s_cookie;
-    m_contexts.push_back(std::make_unique<EisContext>(this, eisCapabilities, cookie, dbusService));
+    m_contexts.push_back(std::make_unique<DbusEisContext>(this, eisCapabilities, cookie, dbusService));
     m_serviceWatcher->addWatchedService(dbusService);
     return QDBusUnixFileDescriptor(m_contexts.back()->addClient());
 }
 
 void EisBackend::disconnect(int cookie)
 {
-    auto it = std::ranges::find(m_contexts, cookie, [](const std::unique_ptr<EisContext> &context) {
+    auto it = std::ranges::find(m_contexts, cookie, [](const std::unique_ptr<DbusEisContext> &context) {
         return context->cookie;
     });
     if (it != std::ranges::end(m_contexts)) {
diff --git a/src/plugins/eis/eisbackend.h b/src/plugins/eis/eisbackend.h
index a34d403..f04282e 100644
--- a/src/plugins/eis/eisbackend.h
+++ b/src/plugins/eis/eisbackend.h
@@ -24,7 +24,8 @@ class QDBusServiceWatcher;
 
 namespace KWin
 {
-class EisContext;
+class DbusEisContext;
+class XWaylandEisContext;
 
 class EisBackend : public KWin::InputBackend, public QDBusContext
 {
@@ -46,7 +47,8 @@ public:
 private:
     QDBusServiceWatcher *m_serviceWatcher;
     RamFile m_keymapFile;
-    std::vector<std::unique_ptr<EisContext>> m_contexts;
+    std::unique_ptr<XWaylandEisContext> m_xWaylandContext;
+    std::vector<std::unique_ptr<DbusEisContext>> m_contexts;
 };
 
 }
diff --git a/src/plugins/eis/eiscontext.cpp b/src/plugins/eis/eiscontext.cpp
index 015e041..c312f1e 100644
--- a/src/plugins/eis/eiscontext.cpp
+++ b/src/plugins/eis/eiscontext.cpp
@@ -52,15 +52,32 @@ public:
     std::unique_ptr<EisDevice> keyboard;
 };
 
-EisContext::EisContext(KWin::EisBackend *backend, QFlags<eis_device_capability> allowedCapabilities, int cookie, const QString &dbusService)
-    : cookie(cookie)
+DbusEisContext::DbusEisContext(KWin::EisBackend *backend, QFlags<eis_device_capability> allowedCapabilities, int cookie, const QString &dbusService)
+    : EisContext(backend, allowedCapabilities)
+    , cookie(cookie)
     , dbusService(dbusService)
+{
+    eis_setup_backend_fd(m_eisContext);
+}
+
+int DbusEisContext::addClient()
+{
+    return eis_backend_fd_add_client(m_eisContext);
+}
+
+XWaylandEisContext::XWaylandEisContext(KWin::EisBackend *backend)
+    : EisContext(backend, {EIS_DEVICE_CAP_POINTER | EIS_DEVICE_CAP_POINTER_ABSOLUTE | EIS_DEVICE_CAP_KEYBOARD | EIS_DEVICE_CAP_TOUCH | EIS_DEVICE_CAP_SCROLL | EIS_DEVICE_CAP_BUTTON})
+    , socketName(qgetenv("XDG_RUNTIME_DIR") + QByteArrayLiteral("/kwin-xwayland-eis-socket.") + QByteArray::number(getpid()))
+{
+    eis_setup_backend_socket(m_eisContext, socketName.constData());
+}
+
+EisContext::EisContext(KWin::EisBackend *backend, QFlags<eis_device_capability> allowedCapabilities)
+    : m_eisContext(eis_new(this))
     , m_backend(backend)
-    , m_eisContext(eis_new(this))
     , m_allowedCapabilities(allowedCapabilities)
     , m_socketNotifier(eis_get_fd(m_eisContext), QSocketNotifier::Read)
 {
-    eis_setup_backend_fd(m_eisContext);
     eis_log_set_priority(m_eisContext, EIS_LOG_PRIORITY_DEBUG);
     eis_log_set_handler(m_eisContext, eis_log_handler);
     QObject::connect(&m_socketNotifier, &QSocketNotifier::activated, [this] {
@@ -101,11 +118,6 @@ void EisContext::updateKeymap()
     }
 }
 
-int EisContext::addClient()
-{
-    return eis_backend_fd_add_client(m_eisContext);
-}
-
 static std::chrono::microseconds currentTime()
 {
     return std::chrono::duration_cast<std::chrono::microseconds>(std::chrono::steady_clock::now().time_since_epoch());
diff --git a/src/plugins/eis/eiscontext.h b/src/plugins/eis/eiscontext.h
index fd8f676..50de947 100644
--- a/src/plugins/eis/eiscontext.h
+++ b/src/plugins/eis/eiscontext.h
@@ -24,24 +24,40 @@ struct EisClient;
 class EisContext
 {
 public:
-    EisContext(EisBackend *backend, QFlags<eis_device_capability> allowedCapabilities, int cookie, const QString &dbusService);
+    EisContext(EisBackend *backend, QFlags<eis_device_capability> allowedCapabilities);
     ~EisContext();
 
-    int addClient();
     void updateScreens();
     void updateKeymap();
 
-    const int cookie;
-    const QString dbusService;
+protected:
+    eis *m_eisContext;
 
 private:
     void handleEvents();
 
     EisBackend *m_backend;
-    eis *m_eisContext;
     QFlags<eis_device_capability> m_allowedCapabilities;
     QSocketNotifier m_socketNotifier;
     std::vector<std::unique_ptr<EisClient>> m_clients;
 };
 
+class DbusEisContext : public EisContext
+{
+public:
+    DbusEisContext(EisBackend *backend, QFlags<eis_device_capability> allowedCapabilities, int cookie, const QString &dbusService);
+
+    int addClient();
+
+    const int cookie;
+    const QString dbusService;
+};
+
+class XWaylandEisContext : public EisContext
+{
+public:
+    XWaylandEisContext(EisBackend *backend);
+
+    const QByteArray socketName;
+};
 }
diff --git a/src/xwayland/xwaylandlauncher.cpp b/src/xwayland/xwaylandlauncher.cpp
index da7ba01..195000f 100644
--- a/src/xwayland/xwaylandlauncher.cpp
+++ b/src/xwayland/xwaylandlauncher.cpp
@@ -177,9 +177,6 @@ bool XwaylandLauncher::start()
     fdsToPass << wmfd->fds[1].get();
 
     arguments << QStringLiteral("-rootless");
-#if HAVE_XWAYLAND_ENABLE_EI_PORTAL
-    arguments << QStringLiteral("-enable-ei-portal");
-#endif
 
     QProcessEnvironment env = QProcessEnvironment::systemEnvironment();
 
-- 
2.48.1


From 563719694984e91189e9f2ee0b68c2cd98c48a91 Mon Sep 17 00:00:00 2001
From: David Redondo <kde@david-redondo.de>
Date: Fri, 12 Jul 2024 15:55:59 +0200
Subject: [PATCH 4/5] Add option to control whether xwayland xtest will prompt
 or not

Users may want to enable this for example if they often use things
which rely on xtest.
Instead of the portal showing a dialog, KWin will show a dialog
when it should ask.
This approach allows us even to show more information to the user
as we can get the client binary name from the eis client compared
to the portal which receives nothing.
Because the Options class does not write through to the config file
seperate Settings class is generated.
---
 src/kcms/xwayland/kwinxwaylandsettings.kcfg |  3 +
 src/kcms/xwayland/ui/main.qml               | 14 ++++
 src/kwin.kcfg                               |  3 +
 src/options.cpp                             | 11 +++
 src/options.h                               | 11 +++
 src/plugins/eis/CMakeLists.txt              |  3 +-
 src/plugins/eis/eisbackend.cpp              |  3 +-
 src/plugins/eis/eiscontext.cpp              | 39 ++++++-----
 src/plugins/eis/eiscontext.h                | 13 ++--
 src/plugins/eis/xwaylandeiscontext.cpp      | 76 +++++++++++++++++++++
 src/plugins/eis/xwaylandeiscontext.h        | 23 +++++++
 src/settings.kcfgc                          |  1 +
 12 files changed, 173 insertions(+), 27 deletions(-)
 create mode 100644 src/plugins/eis/xwaylandeiscontext.cpp
 create mode 100644 src/plugins/eis/xwaylandeiscontext.h

diff --git a/src/kcms/xwayland/kwinxwaylandsettings.kcfg b/src/kcms/xwayland/kwinxwaylandsettings.kcfg
index 93ecbbf..930d31a 100644
--- a/src/kcms/xwayland/kwinxwaylandsettings.kcfg
+++ b/src/kcms/xwayland/kwinxwaylandsettings.kcfg
@@ -17,5 +17,8 @@
         <entry name="xwaylandEavesdropsMouse" key="XwaylandEavesdropsMouse" type="Bool">
             <default>false</default>
         </entry>
+        <entry name="XwaylandEisNoPrompt" type="Bool">
+            <default>false</default>
+        </entry>
     </group>
 </kcfg>
diff --git a/src/kcms/xwayland/ui/main.qml b/src/kcms/xwayland/ui/main.qml
index 8b5acce..6207434 100644
--- a/src/kcms/xwayland/ui/main.qml
+++ b/src/kcms/xwayland/ui/main.qml
@@ -40,6 +40,7 @@ KCM.SimpleKCM {
         }
 
         Kirigami.FormLayout {
+            id: eavesdropLayout
             Layout.leftMargin: Kirigami.Units.gridUnit
             Layout.rightMargin: Kirigami.Units.gridUnit
 
@@ -114,5 +115,18 @@ KCM.SimpleKCM {
             text: i18n("Note that using this setting will reduce system security to that of the X11 session by permitting malicious software to steal passwords and spy on the text that you type. Make sure you understand and accept this risk.")
             visible: always.checked
         }
+
+        Kirigami.Separator {
+            Layout.fillWidth: true
+            Layout.leftMargin: Kirigami.Units.gridUnit
+            Layout.rightMargin: Kirigami.Units.gridUnit
+        }
+
+        QQC2.CheckBox {
+            Layout.margins: Kirigami.Units.gridUnit
+            text: i18nc("@option:check", "Allow controlling the pointer and keyboard without asking for permission")
+            checked: kcm.settings.xwaylandEisNoPrompt
+            onToggled: kcm.settings.xwaylandEisNoPrompt = checked
+        }
     }
 }
diff --git a/src/kwin.kcfg b/src/kwin.kcfg
index bba731c..183e5a0 100644
--- a/src/kwin.kcfg
+++ b/src/kwin.kcfg
@@ -352,5 +352,8 @@
         <entry name="XwaylandEavesdropsMouse" type="Bool">
             <default>false</default>
         </entry>
+        <entry name="XwaylandEisNoPrompt" type="Bool">
+            <default>false</default>
+        </entry>
     </group>
 </kcfg>
diff --git a/src/options.cpp b/src/options.cpp
index 16771dc..d114163 100644
--- a/src/options.cpp
+++ b/src/options.cpp
@@ -56,6 +56,7 @@ Options::Options(QObject *parent)
     , m_xwaylandMaxCrashCount(Options::defaultXwaylandMaxCrashCount())
     , m_xwaylandEavesdrops(Options::defaultXwaylandEavesdrops())
     , m_xwaylandEavesdropsMouse(Options::defaultXwaylandEavesdropsMouse())
+    , m_xwaylandEisNoPrompt(Options::defaultXwaylandEisNoPrompt())
     , m_compositingMode(Options::defaultCompositingMode())
     , m_useCompositing(Options::defaultUseCompositing())
     , m_hiddenPreviews(Options::defaultHiddenPreviews())
@@ -166,6 +167,15 @@ void Options::setXwaylandEavesdropsMouse(bool eavesdropsMouse)
     Q_EMIT xwaylandEavesdropsChanged();
 }
 
+void Options::setXWaylandEisNoPrompt(bool doNotPrompt)
+{
+    if (m_xwaylandEisNoPrompt == doNotPrompt) {
+        return;
+    }
+    m_xwaylandEisNoPrompt = doNotPrompt;
+    Q_EMIT xwaylandEisNoPromptChanged();
+}
+
 void Options::setClickRaise(bool clickRaise)
 {
     if (m_autoRaise) {
@@ -847,6 +857,7 @@ void Options::syncFromKcfgc()
     setXwaylandMaxCrashCount(m_settings->xwaylandMaxCrashCount());
     setXwaylandEavesdrops(XwaylandEavesdropsMode(m_settings->xwaylandEavesdrops()));
     setXwaylandEavesdropsMouse(m_settings->xwaylandEavesdropsMouse());
+    setXWaylandEisNoPrompt(m_settings->xwaylandEisNoPrompt());
     setPlacement(m_settings->placement());
     setAutoRaise(m_settings->autoRaise());
     setAutoRaiseInterval(m_settings->autoRaiseInterval());
diff --git a/src/options.h b/src/options.h
index f7f63e2..cea1043 100644
--- a/src/options.h
+++ b/src/options.h
@@ -271,6 +271,10 @@ public:
     {
         return m_xwaylandEavesdropsMouse;
     }
+    bool xwaylandEisNoPrompt() const
+    {
+        return m_xwaylandEisNoPrompt;
+    }
 
     /**
      * Whether clicking on a window raises it in FocusFollowsMouse
@@ -711,6 +715,7 @@ public:
     void setXwaylandMaxCrashCount(int maxCrashCount);
     void setXwaylandEavesdrops(XwaylandEavesdropsMode mode);
     void setXwaylandEavesdropsMouse(bool eavesdropsMouse);
+    void setXWaylandEisNoPrompt(bool doNotPrompt);
     void setNextFocusPrefersMouse(bool nextFocusPrefersMouse);
     void setClickRaise(bool clickRaise);
     void setAutoRaise(bool autoRaise);
@@ -895,6 +900,10 @@ public:
     {
         return false;
     }
+    static bool defaultXwaylandEisNoPrompt()
+    {
+        return false;
+    }
     static ActivationDesktopPolicy defaultActivationDesktopPolicy()
     {
         return ActivationDesktopPolicy::SwitchToOtherDesktop;
@@ -914,6 +923,7 @@ Q_SIGNALS:
     void xwaylandMaxCrashCountChanged();
     void xwaylandEavesdropsChanged();
     void xwaylandEavesdropsMouseChanged();
+    void xwaylandEisNoPromptChanged();
     void nextFocusPrefersMouseChanged();
     void clickRaiseChanged();
     void autoRaiseChanged();
@@ -1001,6 +1011,7 @@ private:
     int m_xwaylandMaxCrashCount;
     XwaylandEavesdropsMode m_xwaylandEavesdrops;
     bool m_xwaylandEavesdropsMouse;
+    bool m_xwaylandEisNoPrompt;
 
     CompositingType m_compositingMode;
     bool m_useCompositing;
diff --git a/src/plugins/eis/CMakeLists.txt b/src/plugins/eis/CMakeLists.txt
index 61ac515..4ed468c 100644
--- a/src/plugins/eis/CMakeLists.txt
+++ b/src/plugins/eis/CMakeLists.txt
@@ -26,6 +26,7 @@ target_sources(eis PRIVATE
     eisinputcapture.cpp
     eisinputcapturemanager.cpp
     eisinputcapturefilter.cpp
+    xwaylandeiscontext.cpp
 )
 
-target_link_libraries(eis PRIVATE kwin KF6::I18n KF6::GlobalAccel Libeis::Libeis XKB::XKB)
+target_link_libraries(eis PRIVATE kwin KF6::I18n KF6::ConfigGui KF6::GlobalAccel Libeis::Libeis XKB::XKB)
diff --git a/src/plugins/eis/eisbackend.cpp b/src/plugins/eis/eisbackend.cpp
index e1c2547..ce6a9e0 100644
--- a/src/plugins/eis/eisbackend.cpp
+++ b/src/plugins/eis/eisbackend.cpp
@@ -9,6 +9,7 @@
 #include "eiscontext.h"
 #include "eisdevice.h"
 #include "libeis_logging.h"
+#include "xwaylandeiscontext.h"
 
 #include "core/output.h"
 #include "input.h"
@@ -27,6 +28,7 @@
 #include <libeis.h>
 
 #include <fcntl.h>
+#include <unistd.h>
 
 #include <ranges>
 
@@ -43,7 +45,6 @@ namespace KWin
 EisBackend::EisBackend(QObject *parent)
     : KWin::InputBackend(parent)
     , m_serviceWatcher(new QDBusServiceWatcher(this))
-
 {
 #if HAVE_XWAYLAND_ENABLE_EI_PORTAL
     if (kwinApp()->operationMode() == Application::OperationModeWayland) {
diff --git a/src/plugins/eis/eiscontext.cpp b/src/plugins/eis/eiscontext.cpp
index c312f1e..a05c94e 100644
--- a/src/plugins/eis/eiscontext.cpp
+++ b/src/plugins/eis/eiscontext.cpp
@@ -65,11 +65,9 @@ int DbusEisContext::addClient()
     return eis_backend_fd_add_client(m_eisContext);
 }
 
-XWaylandEisContext::XWaylandEisContext(KWin::EisBackend *backend)
-    : EisContext(backend, {EIS_DEVICE_CAP_POINTER | EIS_DEVICE_CAP_POINTER_ABSOLUTE | EIS_DEVICE_CAP_KEYBOARD | EIS_DEVICE_CAP_TOUCH | EIS_DEVICE_CAP_SCROLL | EIS_DEVICE_CAP_BUTTON})
-    , socketName(qgetenv("XDG_RUNTIME_DIR") + QByteArrayLiteral("/kwin-xwayland-eis-socket.") + QByteArray::number(getpid()))
+void DbusEisContext::connectionRequested(eis_client *client)
 {
-    eis_setup_backend_socket(m_eisContext, socketName.constData());
+    connectToClient(client);
 }
 
 EisContext::EisContext(KWin::EisBackend *backend, QFlags<eis_device_capability> allowedCapabilities)
@@ -118,6 +116,25 @@ void EisContext::updateKeymap()
     }
 }
 
+void EisContext::connectToClient(eis_client *client)
+{
+    eis_client_connect(client);
+
+    const char *clientName = eis_client_get_name(client);
+
+    auto seat = eis_client_new_seat(client, QByteArrayLiteral(" seat").prepend(clientName));
+    constexpr std::array allCapabilities{EIS_DEVICE_CAP_POINTER, EIS_DEVICE_CAP_POINTER_ABSOLUTE, EIS_DEVICE_CAP_KEYBOARD, EIS_DEVICE_CAP_TOUCH, EIS_DEVICE_CAP_SCROLL, EIS_DEVICE_CAP_BUTTON};
+    for (auto capability : allCapabilities) {
+        if (m_allowedCapabilities & capability) {
+            eis_seat_configure_capability(seat, capability);
+        }
+    }
+    eis_seat_add(seat);
+
+    m_clients.emplace_back(std::make_unique<EisClient>(client, seat));
+    qCDebug(KWIN_EIS) << "New eis client" << clientName;
+}
+
 static std::chrono::microseconds currentTime()
 {
     return std::chrono::duration_cast<std::chrono::microseconds>(std::chrono::steady_clock::now().time_since_epoch());
@@ -141,19 +158,7 @@ void EisContext::handleEvents()
                 eis_client_disconnect(client);
                 break;
             }
-            eis_client_connect(client);
-
-            auto seat = eis_client_new_seat(client, QByteArrayLiteral(" seat").prepend(clientName));
-            constexpr std::array allCapabilities{EIS_DEVICE_CAP_POINTER, EIS_DEVICE_CAP_POINTER_ABSOLUTE, EIS_DEVICE_CAP_KEYBOARD, EIS_DEVICE_CAP_TOUCH, EIS_DEVICE_CAP_SCROLL, EIS_DEVICE_CAP_BUTTON};
-            for (auto capability : allCapabilities) {
-                if (m_allowedCapabilities & capability) {
-                    eis_seat_configure_capability(seat, capability);
-                }
-            }
-
-            eis_seat_add(seat);
-            m_clients.emplace_back(std::make_unique<EisClient>(client, seat));
-            qCDebug(KWIN_EIS) << "New eis client" << clientName;
+            connectionRequested(client);
             break;
         }
         case EIS_EVENT_CLIENT_DISCONNECT: {
diff --git a/src/plugins/eis/eiscontext.h b/src/plugins/eis/eiscontext.h
index 50de947..c14b17f 100644
--- a/src/plugins/eis/eiscontext.h
+++ b/src/plugins/eis/eiscontext.h
@@ -25,13 +25,15 @@ class EisContext
 {
 public:
     EisContext(EisBackend *backend, QFlags<eis_device_capability> allowedCapabilities);
-    ~EisContext();
+    virtual ~EisContext();
 
     void updateScreens();
     void updateKeymap();
 
 protected:
     eis *m_eisContext;
+    void connectToClient(eis_client *client);
+    virtual void connectionRequested(eis_client *client) = 0;
 
 private:
     void handleEvents();
@@ -51,13 +53,8 @@ public:
 
     const int cookie;
     const QString dbusService;
-};
 
-class XWaylandEisContext : public EisContext
-{
-public:
-    XWaylandEisContext(EisBackend *backend);
-
-    const QByteArray socketName;
+private:
+    void connectionRequested(eis_client *client) override;
 };
 }
diff --git a/src/plugins/eis/xwaylandeiscontext.cpp b/src/plugins/eis/xwaylandeiscontext.cpp
new file mode 100644
index 0000000..b26d06f
--- /dev/null
+++ b/src/plugins/eis/xwaylandeiscontext.cpp
@@ -0,0 +1,76 @@
+/*
+    SPDX-FileCopyrightText: 2024 David Redondo <kde@david-redono.de>
+
+    SPDX-License-Identifier: GPL-2.0-only OR GPL-3.0-only OR LicenseRef-KDE-Accepted-GPL
+*/
+
+#include "xwaylandeiscontext.h"
+
+#include "options.h"
+
+#include <KLocalizedString>
+
+#include <QCheckBox>
+#include <QDialog>
+#include <QDialogButtonBox>
+#include <QLabel>
+#include <QPushButton>
+#include <QStyle>
+#include <QVBoxLayout>
+
+#include <unistd.h>
+
+namespace KWin
+{
+
+XWaylandEisContext::XWaylandEisContext(EisBackend *backend)
+    : EisContext(backend, {EIS_DEVICE_CAP_POINTER | EIS_DEVICE_CAP_POINTER_ABSOLUTE | EIS_DEVICE_CAP_KEYBOARD | EIS_DEVICE_CAP_TOUCH | EIS_DEVICE_CAP_SCROLL | EIS_DEVICE_CAP_BUTTON})
+    , socketName(qgetenv("XDG_RUNTIME_DIR") + QByteArrayLiteral("/kwin-xwayland-eis-socket.") + QByteArray::number(getpid()))
+{
+    eis_setup_backend_socket(m_eisContext, socketName.constData());
+}
+
+void XWaylandEisContext::connectionRequested(eis_client *client)
+{
+    if (options->xwaylandEisNoPrompt()) {
+        connectToClient(client);
+        return;
+    }
+
+    auto dialog = new QDialog;
+    dialog->setAttribute(Qt::WA_DeleteOnClose);
+    dialog->setWindowTitle(i18nc("@title:window", "Remote control requested"));
+    dialog->setWindowIcon(QIcon::fromTheme(QStringLiteral("krfb")));
+    auto mainLayout = new QVBoxLayout(dialog);
+    auto iconTextLayout = new QHBoxLayout();
+    mainLayout->addLayout(iconTextLayout);
+    const int iconSize = dialog->style()->pixelMetric(QStyle::PM_MessageBoxIconSize);
+    auto icon = new QLabel(dialog);
+    icon->setPixmap(QIcon::fromTheme(QStringLiteral("krfb")).pixmap(iconSize));
+    iconTextLayout->addWidget(icon);
+    iconTextLayout->addWidget(new QLabel(i18nc("%1 is the app/binary", "%1 wants to control the pointer and keyboard", eis_client_get_name(client)), dialog));
+    auto alwaysAllowCheckbox = new QCheckBox(i18nc("@option:check", "Always allow for legacy applications"), dialog);
+    mainLayout->addWidget(alwaysAllowCheckbox);
+    auto buttonBox = new QDialogButtonBox(dialog);
+    mainLayout->addWidget(buttonBox);
+    auto allowButton = buttonBox->addButton(i18nc("@action:button", "Allow"), QDialogButtonBox::AcceptRole);
+    allowButton->setIcon(QIcon::fromTheme(QStringLiteral("dialog-ok")));
+    buttonBox->addButton(QDialogButtonBox::Cancel);
+    dialog->show();
+    QObject::connect(buttonBox, &QDialogButtonBox::accepted, dialog, &QDialog::accept);
+    QObject::connect(buttonBox, &QDialogButtonBox::rejected, dialog, &QDialog::reject);
+    QObject::connect(dialog, &QDialog::finished, [client, alwaysAllowCheckbox, this](int result) {
+        if (result == QDialog::Accepted) {
+            connectToClient(client);
+            if (alwaysAllowCheckbox->isChecked()) {
+                kwinApp()->config()->group(QStringLiteral("Xwayland")).writeEntry(QStringLiteral("XwaylandEisNoPrompt"), true, KConfig::Notify);
+                kwinApp()->config()->sync();
+            }
+        } else {
+            eis_client_disconnect(client);
+        }
+    });
+    dialog->show();
+}
+
+}
diff --git a/src/plugins/eis/xwaylandeiscontext.h b/src/plugins/eis/xwaylandeiscontext.h
new file mode 100644
index 0000000..44eea5b
--- /dev/null
+++ b/src/plugins/eis/xwaylandeiscontext.h
@@ -0,0 +1,23 @@
+/*
+    SPDX-FileCopyrightText: 2024 David Redondo <kde@david-redono.de>
+
+    SPDX-License-Identifier: GPL-2.0-only OR GPL-3.0-only OR LicenseRef-KDE-Accepted-GPL
+*/
+
+#pragma once
+
+#include <eiscontext.h>
+
+namespace KWin
+{
+class XWaylandEisContext : public EisContext
+{
+public:
+    XWaylandEisContext(EisBackend *backend);
+
+    const QByteArray socketName;
+
+private:
+    void connectionRequested(eis_client *client) override;
+};
+}
diff --git a/src/settings.kcfgc b/src/settings.kcfgc
index 8ed482e..2a73387 100644
--- a/src/settings.kcfgc
+++ b/src/settings.kcfgc
@@ -4,3 +4,4 @@ ClassName=Settings
 # options.h is needed for FocusPolicy and PlacementPolicy
 IncludeFiles=\"options.h\"
 UseEnumTypes=true
+Mutators=true
-- 
2.48.1


From 4927eeed4beacca5254a2c3db5bca24548019ff4 Mon Sep 17 00:00:00 2001
From: David Redondo <kde@david-redondo.de>
Date: Mon, 26 Aug 2024 17:19:58 +0200
Subject: [PATCH 5/5] Add per app Xwayland eis settings

Allows the user to manage the permissions in a  more fine grained.
Can allow for a specific application in the dialog and review and
revoke in the KCM.
---
 src/kcms/xwayland/kwinxwaylandsettings.kcfg |  1 +
 src/kcms/xwayland/ui/main.qml               | 43 ++++++++++++++++++++-
 src/kwin.kcfg                               |  1 +
 src/options.cpp                             | 11 ++++++
 src/options.h                               | 11 ++++++
 src/plugins/eis/xwaylandeiscontext.cpp      | 16 ++++++--
 6 files changed, 78 insertions(+), 5 deletions(-)

diff --git a/src/kcms/xwayland/kwinxwaylandsettings.kcfg b/src/kcms/xwayland/kwinxwaylandsettings.kcfg
index 930d31a..9301291 100644
--- a/src/kcms/xwayland/kwinxwaylandsettings.kcfg
+++ b/src/kcms/xwayland/kwinxwaylandsettings.kcfg
@@ -20,5 +20,6 @@
         <entry name="XwaylandEisNoPrompt" type="Bool">
             <default>false</default>
         </entry>
+        <entry name="XwaylandEisNoPromptApps" type="StringList" />
     </group>
 </kcfg>
diff --git a/src/kcms/xwayland/ui/main.qml b/src/kcms/xwayland/ui/main.qml
index 6207434..49f5e26 100644
--- a/src/kcms/xwayland/ui/main.qml
+++ b/src/kcms/xwayland/ui/main.qml
@@ -123,10 +123,51 @@ KCM.SimpleKCM {
         }
 
         QQC2.CheckBox {
-            Layout.margins: Kirigami.Units.gridUnit
+            Layout.leftMargin: Kirigami.Units.gridUnit
+            Layout.rightMargin: Kirigami.Units.gridUnit
             text: i18nc("@option:check", "Allow controlling the pointer and keyboard without asking for permission")
             checked: kcm.settings.xwaylandEisNoPrompt
             onToggled: kcm.settings.xwaylandEisNoPrompt = checked
         }
+        QQC2.Button {
+            Layout.leftMargin: Kirigami.Units.gridUnit
+            Layout.rightMargin: Kirigami.Units.gridUnit
+            text: i18nc("@action:button", "Configure applicationsâ€¦")
+            enabled: !kcm.settings.xwaylandEisNoPrompt && kcm.settings.xwaylandEisNoPromptApps.length > 0
+            onClicked: {
+                kcm.push(appsPage)
+            }
+            KCM.ScrollViewKCM {
+                id: appsPage
+                visible: false
+                title: i18n("Applications allowed to control the pointer and keyboard")
+                view: ListView {
+                    model: kcm.settings.xwaylandEisNoPromptApps
+                    delegate: QQC2.ItemDelegate {
+                        id: delegate
+                        width: ListView.view.width
+                        text: modelData
+                        icon.name: modelData
+                        contentItem: RowLayout {
+                            spacing: Kirigami.Theme.smallSpacing
+                            Kirigami.IconTitleSubtitle {
+                                Layout.fillWidth: true
+                                icon: icon.fromControlsIcon(delegate.icon)
+                                title: delegate.text
+                                selected: delegate.highlighted || delegate.down
+                                font: delegate.font
+                            }
+                            QQC2.ToolButton {
+                                icon.name: "list-remove-symbolic"
+                                QQC2.ToolTip {
+                                    text: i18nc("@info:tooltip %1 is the name of the app/binary", "Do not allow %1 to control the pointer and keyboard without asking", modelData)
+                                }
+                                onClicked: kcm.settings.xwaylandEisNoPromptApps = kcm.settings.xwaylandEisNoPromptApps.filter(app => app != modelData)
+                            }
+                        }
+                    }
+                }
+            }
+        }
     }
 }
diff --git a/src/kwin.kcfg b/src/kwin.kcfg
index 183e5a0..0816194 100644
--- a/src/kwin.kcfg
+++ b/src/kwin.kcfg
@@ -355,5 +355,6 @@
         <entry name="XwaylandEisNoPrompt" type="Bool">
             <default>false</default>
         </entry>
+        <entry name="XwaylandEisNoPromptApps" type="StringList" />
     </group>
 </kcfg>
diff --git a/src/options.cpp b/src/options.cpp
index d114163..0b5a986 100644
--- a/src/options.cpp
+++ b/src/options.cpp
@@ -57,6 +57,7 @@ Options::Options(QObject *parent)
     , m_xwaylandEavesdrops(Options::defaultXwaylandEavesdrops())
     , m_xwaylandEavesdropsMouse(Options::defaultXwaylandEavesdropsMouse())
     , m_xwaylandEisNoPrompt(Options::defaultXwaylandEisNoPrompt())
+    , m_xwaylandEisNoPromptApps(Options::defaultXwaylandEisNotPromptApps())
     , m_compositingMode(Options::defaultCompositingMode())
     , m_useCompositing(Options::defaultUseCompositing())
     , m_hiddenPreviews(Options::defaultHiddenPreviews())
@@ -176,6 +177,15 @@ void Options::setXWaylandEisNoPrompt(bool doNotPrompt)
     Q_EMIT xwaylandEisNoPromptChanged();
 }
 
+void Options::setXWaylandEisNoPromptApps(const QStringList &apps)
+{
+    if (m_xwaylandEisNoPromptApps == apps) {
+        return;
+    }
+    m_xwaylandEisNoPromptApps = apps;
+    Q_EMIT xwaylandEisNoPromptAppsChanged();
+}
+
 void Options::setClickRaise(bool clickRaise)
 {
     if (m_autoRaise) {
@@ -858,6 +868,7 @@ void Options::syncFromKcfgc()
     setXwaylandEavesdrops(XwaylandEavesdropsMode(m_settings->xwaylandEavesdrops()));
     setXwaylandEavesdropsMouse(m_settings->xwaylandEavesdropsMouse());
     setXWaylandEisNoPrompt(m_settings->xwaylandEisNoPrompt());
+    setXWaylandEisNoPromptApps(m_settings->xwaylandEisNoPromptApps());
     setPlacement(m_settings->placement());
     setAutoRaise(m_settings->autoRaise());
     setAutoRaiseInterval(m_settings->autoRaiseInterval());
diff --git a/src/options.h b/src/options.h
index cea1043..dfa65a2 100644
--- a/src/options.h
+++ b/src/options.h
@@ -275,6 +275,10 @@ public:
     {
         return m_xwaylandEisNoPrompt;
     }
+    QStringList xwaylandEisNoPromptApps() const
+    {
+        return m_xwaylandEisNoPromptApps;
+    }
 
     /**
      * Whether clicking on a window raises it in FocusFollowsMouse
@@ -716,6 +720,7 @@ public:
     void setXwaylandEavesdrops(XwaylandEavesdropsMode mode);
     void setXwaylandEavesdropsMouse(bool eavesdropsMouse);
     void setXWaylandEisNoPrompt(bool doNotPrompt);
+    void setXWaylandEisNoPromptApps(const QStringList &apps);
     void setNextFocusPrefersMouse(bool nextFocusPrefersMouse);
     void setClickRaise(bool clickRaise);
     void setAutoRaise(bool autoRaise);
@@ -904,6 +909,10 @@ public:
     {
         return false;
     }
+    static QStringList defaultXwaylandEisNotPromptApps()
+    {
+        return QStringList();
+    }
     static ActivationDesktopPolicy defaultActivationDesktopPolicy()
     {
         return ActivationDesktopPolicy::SwitchToOtherDesktop;
@@ -924,6 +933,7 @@ Q_SIGNALS:
     void xwaylandEavesdropsChanged();
     void xwaylandEavesdropsMouseChanged();
     void xwaylandEisNoPromptChanged();
+    void xwaylandEisNoPromptAppsChanged();
     void nextFocusPrefersMouseChanged();
     void clickRaiseChanged();
     void autoRaiseChanged();
@@ -1012,6 +1022,7 @@ private:
     XwaylandEavesdropsMode m_xwaylandEavesdrops;
     bool m_xwaylandEavesdropsMouse;
     bool m_xwaylandEisNoPrompt;
+    QStringList m_xwaylandEisNoPromptApps;
 
     CompositingType m_compositingMode;
     bool m_useCompositing;
diff --git a/src/plugins/eis/xwaylandeiscontext.cpp b/src/plugins/eis/xwaylandeiscontext.cpp
index b26d06f..55c93a0 100644
--- a/src/plugins/eis/xwaylandeiscontext.cpp
+++ b/src/plugins/eis/xwaylandeiscontext.cpp
@@ -32,7 +32,8 @@ XWaylandEisContext::XWaylandEisContext(EisBackend *backend)
 
 void XWaylandEisContext::connectionRequested(eis_client *client)
 {
-    if (options->xwaylandEisNoPrompt()) {
+    const QString clientName = QString::fromUtf8(eis_client_get_name(client));
+    if (options->xwaylandEisNoPrompt() || options->xwaylandEisNoPromptApps().contains(clientName)) {
         connectToClient(client);
         return;
     }
@@ -49,6 +50,8 @@ void XWaylandEisContext::connectionRequested(eis_client *client)
     icon->setPixmap(QIcon::fromTheme(QStringLiteral("krfb")).pixmap(iconSize));
     iconTextLayout->addWidget(icon);
     iconTextLayout->addWidget(new QLabel(i18nc("%1 is the app/binary", "%1 wants to control the pointer and keyboard", eis_client_get_name(client)), dialog));
+    auto allowAppCheckbox = new QCheckBox(i18nc("@option:check %1 is the app/binary", "Always allow for %1", clientName), dialog);
+    mainLayout->addWidget(allowAppCheckbox);
     auto alwaysAllowCheckbox = new QCheckBox(i18nc("@option:check", "Always allow for legacy applications"), dialog);
     mainLayout->addWidget(alwaysAllowCheckbox);
     auto buttonBox = new QDialogButtonBox(dialog);
@@ -59,13 +62,18 @@ void XWaylandEisContext::connectionRequested(eis_client *client)
     dialog->show();
     QObject::connect(buttonBox, &QDialogButtonBox::accepted, dialog, &QDialog::accept);
     QObject::connect(buttonBox, &QDialogButtonBox::rejected, dialog, &QDialog::reject);
-    QObject::connect(dialog, &QDialog::finished, [client, alwaysAllowCheckbox, this](int result) {
+    QObject::connect(dialog, &QDialog::finished, [client, clientName, alwaysAllowCheckbox, allowAppCheckbox, this](int result) {
         if (result == QDialog::Accepted) {
             connectToClient(client);
+            auto xwaylandGroup = kwinApp()->config()->group(QStringLiteral("Xwayland"));
             if (alwaysAllowCheckbox->isChecked()) {
-                kwinApp()->config()->group(QStringLiteral("Xwayland")).writeEntry(QStringLiteral("XwaylandEisNoPrompt"), true, KConfig::Notify);
-                kwinApp()->config()->sync();
+                xwaylandGroup.writeEntry(QStringLiteral("XwaylandEisNoPrompt"), true, KConfig::Notify);
             }
+            if (allowAppCheckbox->isChecked()) {
+                auto allowedApps = options->xwaylandEisNoPromptApps() << clientName;
+                xwaylandGroup.writeEntry(QStringLiteral("XwaylandEisNoPromptApps"), allowedApps, KConfig::Notify);
+            }
+            kwinApp()->config()->sync();
         } else {
             eis_client_disconnect(client);
         }
-- 
2.48.1

From 2621daec73317be6f19ab9ec8be51b509cab554b Mon Sep 17 00:00:00 2001
From: Eric Naim <dnaim@cachyos.org>
Date: Mon, 3 Feb 2025 21:47:29 +0800
Subject: [PATCH] fifo-v1

Signed-off-by: Eric Naim <dnaim@cachyos.org>
---
 autotests/integration/CMakeLists.txt      |   3 +
 autotests/integration/kwin_wayland_test.h |  20 ++
 autotests/integration/test_fifo.cpp       | 259 ++++++++++++++++++++++
 autotests/integration/test_helpers.cpp    |  44 ++++
 src/compositor_wayland.cpp                |  19 +-
 src/core/renderlayerdelegate.cpp          |   4 +
 src/core/renderlayerdelegate.h            |   5 +
 src/core/renderloop.cpp                   |   4 +-
 src/scene/cursorscene.cpp                 |  10 +
 src/scene/cursorscene.h                   |   1 +
 src/scene/item.cpp                        |   7 +
 src/scene/item.h                          |   1 +
 src/scene/scene.cpp                       |   5 +
 src/scene/scene.h                         |   2 +
 src/scene/surfaceitem_wayland.cpp         |  34 +++
 src/scene/surfaceitem_wayland.h           |   6 +
 src/scene/workspacescene.cpp              |  10 +
 src/scene/workspacescene.h                |   1 +
 src/wayland/CMakeLists.txt                |  10 +-
 src/wayland/fifo_v1.cpp                   |  75 +++++++
 src/wayland/fifo_v1.h                     |  40 ++++
 src/wayland/surface.cpp                   |  32 +++
 src/wayland/surface.h                     |  13 ++
 src/wayland/surface_p.h                   |   6 +
 src/wayland/transaction.cpp               |  30 +++
 src/wayland/transaction.h                 |   2 +
 src/wayland/transaction_p.h               |  12 +
 src/wayland_server.cpp                    |   2 +
 src/wayland_server.h                      |   2 +
 29 files changed, 656 insertions(+), 3 deletions(-)
 create mode 100644 autotests/integration/test_fifo.cpp
 create mode 100644 src/wayland/fifo_v1.cpp
 create mode 100644 src/wayland/fifo_v1.h

diff --git a/autotests/integration/CMakeLists.txt b/autotests/integration/CMakeLists.txt
index 872ba038bb..8dbb7350fa 100644
--- a/autotests/integration/CMakeLists.txt
+++ b/autotests/integration/CMakeLists.txt
@@ -16,8 +16,10 @@ qt6_generate_wayland_protocol_client_sources(KWinIntegrationTestFramework
     FILES
         ${CMAKE_SOURCE_DIR}/src/wayland/protocols/wlr-layer-shell-unstable-v1.xml
         ${PROJECT_SOURCE_DIR}/src/wayland/protocols/color-management-v1.xml
+        ${WaylandProtocols_DATADIR}/stable/presentation-time/presentation-time.xml
         ${WaylandProtocols_DATADIR}/stable/xdg-shell/xdg-shell.xml
         ${WaylandProtocols_DATADIR}/staging/cursor-shape/cursor-shape-v1.xml
+        ${WaylandProtocols_DATADIR}/staging/fifo/fifo-v1.xml
         ${WaylandProtocols_DATADIR}/staging/fractional-scale/fractional-scale-v1.xml
         ${WaylandProtocols_DATADIR}/staging/security-context/security-context-v1.xml
         ${WaylandProtocols_DATADIR}/staging/xdg-dialog/xdg-dialog-v1.xml
@@ -144,6 +146,7 @@ integrationTest(NAME testStickyKeys SRCS sticky_keys_test.cpp)
 integrationTest(NAME testWorkspace SRCS workspace_test.cpp)
 integrationTest(NAME testMouseActions SRCS mouseactions_test.cpp LIBS)
 integrationTest(NAME testColorManagement SRCS test_colormanagement.cpp)
+integrationTest(NAME testFifo SRCS test_fifo.cpp)
 integrationTest(NAME testKeyboardInput SRCS keyboard_input_test.cpp)
 
 if(KWIN_BUILD_X11)
diff --git a/autotests/integration/kwin_wayland_test.h b/autotests/integration/kwin_wayland_test.h
index 646a95d691..e53d3ddb21 100644
--- a/autotests/integration/kwin_wayland_test.h
+++ b/autotests/integration/kwin_wayland_test.h
@@ -23,12 +23,14 @@
 #include "qwayland-color-management-v1.h"
 #include "qwayland-cursor-shape-v1.h"
 #include "qwayland-fake-input.h"
+#include "qwayland-fifo-v1.h"
 #include "qwayland-fractional-scale-v1.h"
 #include "qwayland-idle-inhibit-unstable-v1.h"
 #include "qwayland-input-method-unstable-v1.h"
 #include "qwayland-kde-output-device-v2.h"
 #include "qwayland-kde-output-management-v2.h"
 #include "qwayland-kde-screen-edge-v1.h"
+#include "qwayland-presentation-time.h"
 #include "qwayland-security-context-v1.h"
 #include "qwayland-text-input-unstable-v3.h"
 #include "qwayland-wlr-layer-shell-unstable-v1.h"
@@ -605,6 +607,8 @@ enum class AdditionalWaylandInterface {
     SecurityContextManagerV1 = 1 << 20,
     XdgDialogV1 = 1 << 21,
     ColorManagement = 1 << 22,
+    FifoV1 = 1 << 23,
+    PresentationTime = 1 << 24,
 };
 Q_DECLARE_FLAGS(AdditionalWaylandInterfaces, AdditionalWaylandInterface)
 
@@ -681,6 +685,20 @@ public:
     ~ColorManagerV1() override;
 };
 
+class FifoManagerV1 : public QtWayland::wp_fifo_manager_v1
+{
+public:
+    explicit FifoManagerV1(::wl_registry *registry, uint32_t id, int version);
+    ~FifoManagerV1() override;
+};
+
+class PresentationTime : public QtWayland::wp_presentation
+{
+public:
+    explicit PresentationTime(::wl_registry *registry, uint32_t id, int version);
+    ~PresentationTime() override;
+};
+
 void keyboardKeyPressed(quint32 key, quint32 time);
 void keyboardKeyReleased(quint32 key, quint32 time);
 void pointerAxisHorizontal(qreal delta,
@@ -740,6 +758,8 @@ QList<WaylandOutputDeviceV2 *> waylandOutputDevicesV2();
 FakeInput *waylandFakeInput();
 SecurityContextManagerV1 *waylandSecurityContextManagerV1();
 ColorManagerV1 *colorManager();
+FifoManagerV1 *fifoManager();
+PresentationTime *presentationTime();
 
 bool waitForWaylandSurface(Window *window);
 
diff --git a/autotests/integration/test_fifo.cpp b/autotests/integration/test_fifo.cpp
new file mode 100644
index 0000000000..7ce6397b32
--- /dev/null
+++ b/autotests/integration/test_fifo.cpp
@@ -0,0 +1,259 @@
+
+/*
+    SPDX-FileCopyrightText: 2024 Xaver Hugl <xaver.hugl@gmail.com>
+
+    SPDX-License-Identifier: GPL-2.0-or-later
+*/
+
+#include "kwin_wayland_test.h"
+
+#include "core/colorpipeline.h"
+#include "core/output.h"
+#include "core/outputbackend.h"
+#include "core/outputconfiguration.h"
+#include "outputconfigurationstore.h"
+#include "pointer_input.h"
+#include "tiles/tilemanager.h"
+#include "wayland/surface.h"
+#include "wayland_server.h"
+#include "window.h"
+#include "workspace.h"
+
+#include <KWayland/Client/connection_thread.h>
+#include <KWayland/Client/surface.h>
+#include <format>
+
+using namespace std::chrono_literals;
+
+namespace KWin
+{
+
+static const QString s_socketName = QStringLiteral("wayland_test_fifo-0");
+
+class FifoTest : public QObject
+{
+    Q_OBJECT
+
+private Q_SLOTS:
+    void initTestCase();
+    void init();
+    void cleanup();
+
+    void testFifo_data();
+    void testFifo();
+    void testFifoInitiallyHidden();
+};
+
+class FifoV1Surface : public QObject, public QtWayland::wp_fifo_v1
+{
+    Q_OBJECT
+public:
+    explicit FifoV1Surface(::wp_fifo_v1 *obj)
+        : QtWayland::wp_fifo_v1(obj)
+    {
+    }
+
+    ~FifoV1Surface() override
+    {
+        wp_fifo_v1_destroy(object());
+    }
+};
+
+class WpPresentationFeedback : public QObject, public QtWayland::wp_presentation_feedback
+{
+    Q_OBJECT
+public:
+    explicit WpPresentationFeedback(struct ::wp_presentation_feedback *obj)
+        : QtWayland::wp_presentation_feedback(obj)
+    {
+    }
+
+    ~WpPresentationFeedback() override
+    {
+        wp_presentation_feedback_destroy(object());
+    }
+
+Q_SIGNALS:
+    void presented(std::chrono::nanoseconds timestamp, std::chrono::nanoseconds refreshDuration);
+    void discarded();
+
+private:
+    void wp_presentation_feedback_presented(uint32_t tv_sec_hi, uint32_t tv_sec_lo, uint32_t tv_nsec, uint32_t refresh, uint32_t seq_hi, uint32_t seq_lo, uint32_t flags) override
+    {
+        const std::chrono::nanoseconds timestamp = std::chrono::seconds((uint64_t(tv_sec_hi) << 32) | tv_sec_lo) + std::chrono::nanoseconds(tv_nsec);
+        Q_EMIT presented(timestamp, std::chrono::nanoseconds(refresh));
+    }
+
+    void wp_presentation_feedback_discarded() override
+    {
+        Q_EMIT discarded();
+    }
+};
+
+void FifoTest::initTestCase()
+{
+    qRegisterMetaType<Window *>();
+
+    QVERIFY(waylandServer()->init(s_socketName));
+    kwinApp()->start();
+}
+
+void FifoTest::init()
+{
+    QVERIFY(Test::setupWaylandConnection(Test::AdditionalWaylandInterface::FifoV1 | Test::AdditionalWaylandInterface::PresentationTime));
+    Test::setupWaylandConnection();
+
+    workspace()->setActiveOutput(QPoint(640, 512));
+    input()->pointer()->warp(QPoint(640, 512));
+}
+
+void FifoTest::cleanup()
+{
+    Test::destroyWaylandConnection();
+}
+
+void FifoTest::testFifo_data()
+{
+    QTest::addColumn<uint32_t>("refreshRate");
+
+    QTest::addRow("60Hz") << 60'000u;
+    QTest::addRow("24Hz") << 24'000u;
+}
+
+void FifoTest::testFifo()
+{
+    QFETCH(uint32_t, refreshRate);
+    Test::setOutputConfig({
+        Test::OutputInfo{
+            .geometry = QRect(0, 0, 1280, 1024),
+            .modes = {
+                std::make_tuple(QSize(1280, 1024), refreshRate, OutputMode::Flag::Preferred),
+            },
+        },
+    });
+
+    std::unique_ptr<KWayland::Client::Surface> surface(Test::createSurface());
+    std::unique_ptr<Test::XdgToplevel> shellSurface(Test::createXdgToplevelSurface(surface.get()));
+    auto window = Test::renderAndWaitForShown(surface.get(), QSize(100, 50), Qt::blue);
+    QVERIFY(window);
+
+    auto fifo = std::make_unique<FifoV1Surface>(Test::fifoManager()->get_fifo(*surface));
+
+    std::array<std::unique_ptr<WpPresentationFeedback>, 3> frames;
+
+    // commit 3 frames in quick succession: without fifo, the first two should be discarded, and the last should be presented
+    for (size_t i = 0; i < frames.size(); i++) {
+        frames[i] = std::make_unique<WpPresentationFeedback>(Test::presentationTime()->feedback(*surface));
+        surface->damage(QRect(QPoint(), QSize(1, 1)));
+        surface->commit(KWayland::Client::Surface::CommitFlag::None);
+    }
+
+    {
+        QSignalSpy discarded1(frames[0].get(), &WpPresentationFeedback::discarded);
+        QSignalSpy discarded2(frames[1].get(), &WpPresentationFeedback::discarded);
+        QSignalSpy presented(frames[2].get(), &WpPresentationFeedback::presented);
+
+        QVERIFY(presented.wait(100));
+        QVERIFY(discarded1.count());
+        QVERIFY(discarded2.count());
+    }
+
+    // do it again; this time with fifo, all frames should be presented
+    fifo->set_barrier();
+    surface->commit(KWayland::Client::Surface::CommitFlag::None);
+    for (size_t i = 0; i < frames.size(); i++) {
+        frames[i] = std::make_unique<WpPresentationFeedback>(Test::presentationTime()->feedback(*surface));
+        fifo->set_barrier();
+        fifo->wait_barrier();
+        surface->commit(KWayland::Client::Surface::CommitFlag::None);
+    }
+
+    {
+        std::array<QSignalSpy, frames.size()> spies = {
+            QSignalSpy(frames[0].get(), &WpPresentationFeedback::presented),
+            QSignalSpy(frames[1].get(), &WpPresentationFeedback::presented),
+            QSignalSpy(frames[2].get(), &WpPresentationFeedback::presented),
+        };
+        for (size_t i = 0; i < frames.size(); i++) {
+            QVERIFY(spies[i].wait(100));
+            if (i > 0) {
+                // each frame should be presented in the refresh cycle after the last one
+                const auto thisTimestamp = spies[i].last().at(0).value<std::chrono::nanoseconds>();
+                const auto lastTimestamp = spies[i - 1].last().at(0).value<std::chrono::nanoseconds>();
+                const auto refreshDuration = spies[i].last().at(1).value<std::chrono::nanoseconds>();
+                QCOMPARE_GT(thisTimestamp, lastTimestamp + refreshDuration / 2);
+                QCOMPARE_LT(thisTimestamp, lastTimestamp + refreshDuration * 3 / 2);
+            }
+        }
+    }
+
+    // even if the window is hidden, forward progress must be guaranteed
+    window->setMinimized(true);
+    // fifo->set_barrier();
+    surface->commit(KWayland::Client::Surface::CommitFlag::None);
+    for (size_t i = 0; i < frames.size(); i++) {
+        frames[i] = std::make_unique<WpPresentationFeedback>(Test::presentationTime()->feedback(*surface));
+        fifo->set_barrier();
+        fifo->wait_barrier();
+        surface->commit(KWayland::Client::Surface::CommitFlag::None);
+    }
+
+    {
+        const std::chrono::nanoseconds targetRefreshDuration = std::chrono::nanoseconds(1'000'000'000'000 / std::min(30'000u, refreshRate));
+        std::array<QSignalSpy, frames.size()> spies = {
+            QSignalSpy(frames[0].get(), &WpPresentationFeedback::discarded),
+            QSignalSpy(frames[1].get(), &WpPresentationFeedback::discarded),
+            QSignalSpy(frames[2].get(), &WpPresentationFeedback::discarded),
+        };
+        for (size_t i = 0; i < frames.size() - 1; i++) {
+            const auto before = std::chrono::steady_clock::now();
+            QVERIFY(spies[i].wait(100));
+            const auto after = std::chrono::steady_clock::now();
+            QCOMPARE_GT(after, before + targetRefreshDuration * 2 / 3);
+            QCOMPARE_LT(after, before + targetRefreshDuration * 2);
+        }
+    }
+}
+
+void FifoTest::testFifoInitiallyHidden()
+{
+    // this test verifies that even when the window has never been presented once,
+    // we still ensure forward progress
+
+    std::unique_ptr<KWayland::Client::Surface> surface(Test::createSurface());
+    std::unique_ptr<Test::XdgToplevel> shellSurface(Test::createXdgToplevelSurface(surface.get()));
+    auto window = Test::renderAndWaitForShown(surface.get(), QSize(100, 50), Qt::blue);
+    QVERIFY(window);
+    window->setMinimized(true);
+
+    auto fifo = std::make_unique<FifoV1Surface>(Test::fifoManager()->get_fifo(*surface));
+
+    std::array<std::unique_ptr<WpPresentationFeedback>, 3> frames;
+
+    for (size_t i = 0; i < frames.size(); i++) {
+        frames[i] = std::make_unique<WpPresentationFeedback>(Test::presentationTime()->feedback(*surface));
+        fifo->set_barrier();
+        fifo->wait_barrier();
+        surface->commit(KWayland::Client::Surface::CommitFlag::None);
+    }
+
+    {
+        std::array<QSignalSpy, frames.size()> spies = {
+            QSignalSpy(frames[0].get(), &WpPresentationFeedback::discarded),
+            QSignalSpy(frames[1].get(), &WpPresentationFeedback::discarded),
+            QSignalSpy(frames[2].get(), &WpPresentationFeedback::discarded),
+        };
+        for (size_t i = 0; i < frames.size() - 1; i++) {
+            const auto before = std::chrono::steady_clock::now();
+            QVERIFY(spies[i].wait(100));
+            const auto after = std::chrono::steady_clock::now();
+            QCOMPARE_GT(after, before + std::chrono::milliseconds(30));
+            QCOMPARE_LT(after, before + std::chrono::milliseconds(100));
+        }
+    }
+}
+
+}
+
+WAYLANDTEST_MAIN(KWin::FifoTest)
+#include "test_fifo.moc"
diff --git a/autotests/integration/test_helpers.cpp b/autotests/integration/test_helpers.cpp
index 21eaeee420..3b3bccc6b3 100644
--- a/autotests/integration/test_helpers.cpp
+++ b/autotests/integration/test_helpers.cpp
@@ -320,6 +320,8 @@ static struct
     SecurityContextManagerV1 *securityContextManagerV1 = nullptr;
     XdgWmDialogV1 *xdgWmDialogV1;
     std::unique_ptr<ColorManagerV1> colorManager;
+    std::unique_ptr<FifoManagerV1> fifoManager;
+    std::unique_ptr<PresentationTime> presentationTime;
 } s_waylandConnection;
 
 MockInputMethod *inputMethod()
@@ -546,6 +548,16 @@ bool setupWaylandConnection(AdditionalWaylandInterfaces flags)
                 s_waylandConnection.colorManager = std::make_unique<ColorManagerV1>(*registry, name, version);
             }
         }
+        if (flags & AdditionalWaylandInterface::FifoV1) {
+            if (interface == wp_fifo_manager_v1_interface.name) {
+                s_waylandConnection.fifoManager = std::make_unique<FifoManagerV1>(*registry, name, version);
+            }
+        }
+        if (flags & AdditionalWaylandInterface::PresentationTime) {
+            if (interface == wp_presentation_interface.name) {
+                s_waylandConnection.presentationTime = std::make_unique<PresentationTime>(*registry, name, version);
+            }
+        }
     });
 
     QSignalSpy allAnnounced(registry, &KWayland::Client::Registry::interfacesAnnounced);
@@ -674,6 +686,8 @@ void destroyWaylandConnection()
     delete s_waylandConnection.xdgWmDialogV1;
     s_waylandConnection.xdgWmDialogV1 = nullptr;
     s_waylandConnection.colorManager.reset();
+    s_waylandConnection.fifoManager.reset();
+    s_waylandConnection.presentationTime.reset();
 
     delete s_waylandConnection.queue; // Must be destroyed last
     s_waylandConnection.queue = nullptr;
@@ -795,6 +809,16 @@ ColorManagerV1 *colorManager()
     return s_waylandConnection.colorManager.get();
 }
 
+FifoManagerV1 *fifoManager()
+{
+    return s_waylandConnection.fifoManager.get();
+}
+
+PresentationTime *presentationTime()
+{
+    return s_waylandConnection.presentationTime.get();
+}
+
 bool waitForWaylandSurface(Window *window)
 {
     if (window->surface()) {
@@ -1766,6 +1790,26 @@ ColorManagerV1::~ColorManagerV1()
     wp_color_manager_v1_destroy(object());
 }
 
+FifoManagerV1::FifoManagerV1(::wl_registry *registry, uint32_t id, int version)
+    : QtWayland::wp_fifo_manager_v1(registry, id, version)
+{
+}
+
+FifoManagerV1::~FifoManagerV1()
+{
+    wp_fifo_manager_v1_destroy(object());
+}
+
+PresentationTime::PresentationTime(::wl_registry *registry, uint32_t id, int version)
+    : QtWayland::wp_presentation(registry, id, version)
+{
+}
+
+PresentationTime::~PresentationTime()
+{
+    wp_presentation_destroy(object());
+}
+
 void keyboardKeyPressed(quint32 key, quint32 time)
 {
     auto virtualKeyboard = static_cast<WaylandTestApplication *>(kwinApp())->virtualKeyboard();
diff --git a/src/compositor_wayland.cpp b/src/compositor_wayland.cpp
index 87c728af3b..5ae74f5649 100644
--- a/src/compositor_wayland.cpp
+++ b/src/compositor_wayland.cpp
@@ -316,6 +316,18 @@ static bool checkForBlackBackground(SurfaceItem *background)
     return nits.lengthSquared() <= (0.1 * 0.1);
 }
 
+static void preFifoPass(RenderLayer *layer, std::chrono::nanoseconds refreshDuration)
+{
+    layer->delegate()->prepareFifoPresentation(refreshDuration);
+
+    const auto sublayers = layer->sublayers();
+    for (RenderLayer *sublayer : sublayers) {
+        if (sublayer->isVisible()) {
+            preFifoPass(sublayer, refreshDuration);
+        }
+    }
+}
+
 void WaylandCompositor::composite(RenderLoop *renderLoop)
 {
     if (m_backend->checkGraphicsReset()) {
@@ -335,7 +347,8 @@ void WaylandCompositor::composite(RenderLoop *renderLoop)
     superLayer->setOutputLayer(primaryLayer);
 
     renderLoop->prepareNewFrame();
-    auto frame = std::make_shared<OutputFrame>(renderLoop, std::chrono::nanoseconds(1'000'000'000'000 / output->refreshRate()));
+    const auto refreshDuration = std::chrono::nanoseconds(1'000'000'000'000 / output->refreshRate());
+    auto frame = std::make_shared<OutputFrame>(renderLoop, refreshDuration);
     bool directScanout = false;
     std::optional<double> desiredArtificalHdrHeadroom;
 
@@ -355,6 +368,10 @@ void WaylandCompositor::composite(RenderLoop *renderLoop)
         frame->setBrightness(std::pow(std::clamp(std::pow(output->brightnessSetting() * output->dimming(), 1.0 / 2.2), current - maxChangePerFrame, current + maxChangePerFrame), 2.2));
     }
 
+    // TODO do something smarter about tearing presentation here
+    // like, only do one preFifoPass once per refresh cycle?
+    preFifoPass(superLayer, refreshDuration);
+
     if (primaryLayer->needsRepaint() || superLayer->needsRepaint()) {
         auto totalTimeQuery = std::make_unique<CpuRenderTimeQuery>();
         renderLoop->beginPaint();
diff --git a/src/core/renderlayerdelegate.cpp b/src/core/renderlayerdelegate.cpp
index 340e3f09ff..5dd341a6e3 100644
--- a/src/core/renderlayerdelegate.cpp
+++ b/src/core/renderlayerdelegate.cpp
@@ -23,6 +23,10 @@ void RenderLayerDelegate::frame(OutputFrame *frame)
 {
 }
 
+void RenderLayerDelegate::prepareFifoPresentation(std::chrono::nanoseconds refreshDuration)
+{
+}
+
 QRegion RenderLayerDelegate::prePaint()
 {
     return QRegion();
diff --git a/src/core/renderlayerdelegate.h b/src/core/renderlayerdelegate.h
index 42a9c9cf9d..0e13b8ab07 100644
--- a/src/core/renderlayerdelegate.h
+++ b/src/core/renderlayerdelegate.h
@@ -37,6 +37,11 @@ public:
      */
     virtual void frame(OutputFrame *frame);
 
+    /**
+     * This method is called by the compositor before starting painting for a FIFO frame
+     */
+    virtual void prepareFifoPresentation(std::chrono::nanoseconds refreshDuration);
+
     /**
      * This function is called by the compositor before starting painting. Reimplement
      * this function to do frame initialization.
diff --git a/src/core/renderloop.cpp b/src/core/renderloop.cpp
index 077d846405..be7db21038 100644
--- a/src/core/renderloop.cpp
+++ b/src/core/renderloop.cpp
@@ -190,7 +190,9 @@ void RenderLoopPrivate::dispatch()
 {
     // On X11, we want to ignore repaints that are scheduled by windows right before
     // the Compositor starts repainting.
-    pendingRepaint = true;
+    if (kwinApp()->operationMode() == Application::OperationModeX11) {
+        pendingRepaint = true;
+    }
 
     Q_EMIT q->frameRequested(q);
 
diff --git a/src/scene/cursorscene.cpp b/src/scene/cursorscene.cpp
index 7c9c271ce4..0c2acaac0d 100644
--- a/src/scene/cursorscene.cpp
+++ b/src/scene/cursorscene.cpp
@@ -44,6 +44,16 @@ static void resetRepaintsHelper(Item *item, SceneDelegate *delegate)
     }
 }
 
+void CursorScene::prepareFifoPresentation(SceneDelegate *delegate, std::chrono::nanoseconds refreshDuration)
+{
+    if (!delegate->output() || !m_cursorItem->isVisible()) {
+        return;
+    }
+    if (m_cursorItem->mapToScene(m_cursorItem->boundingRect()).intersects(delegate->output()->geometry())) {
+        m_cursorItem->prepareFifoPresentation(refreshDuration);
+    }
+}
+
 QRegion CursorScene::prePaint(SceneDelegate *delegate)
 {
     resetRepaintsHelper(m_rootItem.get(), delegate);
diff --git a/src/scene/cursorscene.h b/src/scene/cursorscene.h
index db01f41099..00202cb62a 100644
--- a/src/scene/cursorscene.h
+++ b/src/scene/cursorscene.h
@@ -23,6 +23,7 @@ public:
     explicit CursorScene(std::unique_ptr<ItemRenderer> &&renderer);
     ~CursorScene() override;
 
+    void prepareFifoPresentation(SceneDelegate *delegate, std::chrono::nanoseconds refreshDuration) override;
     QRegion prePaint(SceneDelegate *delegate) override;
     void postPaint() override;
     void paint(const RenderTarget &renderTarget, const QRegion &region) override;
diff --git a/src/scene/item.cpp b/src/scene/item.cpp
index 8d7b9897ba..87eba9666f 100644
--- a/src/scene/item.cpp
+++ b/src/scene/item.cpp
@@ -466,6 +466,13 @@ void Item::scheduleSceneRepaintInternal(const QRegion &region)
     }
 }
 
+void Item::prepareFifoPresentation(std::chrono::nanoseconds refreshDuration)
+{
+    for (const auto &child : m_childItems) {
+        child->prepareFifoPresentation(refreshDuration);
+    }
+}
+
 void Item::preprocess()
 {
 }
diff --git a/src/scene/item.h b/src/scene/item.h
index 7187eac683..c42781de7a 100644
--- a/src/scene/item.h
+++ b/src/scene/item.h
@@ -133,6 +133,7 @@ public:
     void resetRepaints(SceneDelegate *delegate);
 
     WindowQuadList quads() const;
+    virtual void prepareFifoPresentation(std::chrono::nanoseconds refreshDuration);
     virtual void preprocess();
     const ColorDescription &colorDescription() const;
     RenderingIntent renderingIntent() const;
diff --git a/src/scene/scene.cpp b/src/scene/scene.cpp
index 7bdf18b6b3..4e4000d882 100644
--- a/src/scene/scene.cpp
+++ b/src/scene/scene.cpp
@@ -29,6 +29,11 @@ QList<SurfaceItem *> SceneDelegate::scanoutCandidates(ssize_t maxCount) const
     return m_scene->scanoutCandidates(maxCount);
 }
 
+void SceneDelegate::prepareFifoPresentation(std::chrono::nanoseconds refreshDuration)
+{
+    m_scene->prepareFifoPresentation(this, refreshDuration);
+}
+
 QRegion SceneDelegate::prePaint()
 {
     return m_scene->prePaint(this);
diff --git a/src/scene/scene.h b/src/scene/scene.h
index 6eaadc2551..e29480e1a2 100644
--- a/src/scene/scene.h
+++ b/src/scene/scene.h
@@ -31,6 +31,7 @@ public:
 
     QList<SurfaceItem *> scanoutCandidates(ssize_t maxCount) const override;
     void frame(OutputFrame *frame) override;
+    void prepareFifoPresentation(std::chrono::nanoseconds refreshDuration) override;
     QRegion prePaint() override;
     void postPaint() override;
     void paint(const RenderTarget &renderTarget, const QRegion &region) override;
@@ -84,6 +85,7 @@ public:
     void removeDelegate(SceneDelegate *delegate);
 
     virtual QList<SurfaceItem *> scanoutCandidates(ssize_t maxCount) const;
+    virtual void prepareFifoPresentation(SceneDelegate *delegate, std::chrono::nanoseconds refreshDuration) = 0;
     virtual QRegion prePaint(SceneDelegate *delegate) = 0;
     virtual void postPaint() = 0;
     virtual void paint(const RenderTarget &renderTarget, const QRegion &region) = 0;
diff --git a/src/scene/surfaceitem_wayland.cpp b/src/scene/surfaceitem_wayland.cpp
index 4a307565c0..d7fcacc303 100644
--- a/src/scene/surfaceitem_wayland.cpp
+++ b/src/scene/surfaceitem_wayland.cpp
@@ -48,6 +48,7 @@ SurfaceItemWayland::SurfaceItemWayland(SurfaceInterface *surface, Item *parent)
             this, &SurfaceItemWayland::handlePresentationModeHintChanged);
     connect(surface, &SurfaceInterface::bufferReleasePointChanged, this, &SurfaceItemWayland::handleReleasePointChanged);
     connect(surface, &SurfaceInterface::alphaMultiplierChanged, this, &SurfaceItemWayland::handleAlphaMultiplierChanged);
+    connect(surface, &SurfaceInterface::waitingOnFifo, this, &SurfaceItemWayland::handleWaitingOnFifo);
 
     SubSurfaceInterface *subsurface = surface->subSurface();
     if (subsurface) {
@@ -68,6 +69,10 @@ SurfaceItemWayland::SurfaceItemWayland(SurfaceInterface *surface, Item *parent)
     setBufferSize(surface->bufferSize());
     setColorDescription(surface->colorDescription());
     setOpacity(surface->alphaMultiplier());
+
+    m_fifoFallbackTimer.setInterval(1000 / 20);
+    m_fifoFallbackTimer.setSingleShot(true);
+    connect(&m_fifoFallbackTimer, &QTimer::timeout, this, &SurfaceItemWayland::handleFifoFallback);
 }
 
 QList<QRectF> SurfaceItemWayland::shape() const
@@ -200,6 +205,7 @@ void SurfaceItemWayland::freeze()
     }
 
     m_surface = nullptr;
+    m_fifoFallbackTimer.stop();
 }
 
 void SurfaceItemWayland::handleColorDescriptionChanged()
@@ -223,6 +229,34 @@ void SurfaceItemWayland::handleAlphaMultiplierChanged()
     setOpacity(m_surface->alphaMultiplier());
 }
 
+void SurfaceItemWayland::prepareFifoPresentation(std::chrono::nanoseconds refreshDuration)
+{
+    if (m_surface) {
+        m_surface->prepareFifoPresentation();
+        if (m_fifoFallbackTimer.isActive()) {
+            // some games don't work properly if the refresh rate goes too low with FIFO. 30Hz is assumed to be fine here.
+            // this must still be slower than the actual screen though, or fifo behavior would be broken!
+            const auto fallbackRefreshDuration = std::max(refreshDuration * 5 / 4, std::chrono::nanoseconds(1'000'000'000) / 30);
+            // reset the timer, it should only trigger if we don't present fast enough
+            m_fifoFallbackTimer.start(std::chrono::duration_cast<std::chrono::milliseconds>(fallbackRefreshDuration));
+        }
+    }
+    Item::prepareFifoPresentation(refreshDuration);
+}
+
+void SurfaceItemWayland::handleWaitingOnFifo()
+{
+    m_fifoFallbackTimer.start();
+    scheduleFrame();
+}
+
+void SurfaceItemWayland::handleFifoFallback()
+{
+    if (m_surface) {
+        m_surface->prepareFifoPresentation();
+    }
+}
+
 SurfacePixmapWayland::SurfacePixmapWayland(SurfaceItemWayland *item, QObject *parent)
     : SurfacePixmap(Compositor::self()->backend()->createSurfaceTextureWayland(this), parent)
     , m_item(item)
diff --git a/src/scene/surfaceitem_wayland.h b/src/scene/surfaceitem_wayland.h
index f769284172..64689a02e1 100644
--- a/src/scene/surfaceitem_wayland.h
+++ b/src/scene/surfaceitem_wayland.h
@@ -8,6 +8,7 @@
 
 #include "scene/surfaceitem.h"
 
+#include <QTimer>
 #include <unordered_map>
 
 namespace KWin
@@ -33,6 +34,7 @@ public:
     ContentType contentType() const override;
     void setScanoutHint(DrmDevice *device, const QHash<uint32_t, QList<uint64_t>> &drmFormats) override;
     void freeze() override;
+    void prepareFifoPresentation(std::chrono::nanoseconds refreshDuration) override;
 
     SurfaceInterface *surface() const;
 
@@ -52,6 +54,9 @@ private Q_SLOTS:
     void handleReleasePointChanged();
     void handleAlphaMultiplierChanged();
 
+    void handleWaitingOnFifo();
+    void handleFifoFallback();
+
 protected:
     std::unique_ptr<SurfacePixmap> createPixmap() override;
 
@@ -66,6 +71,7 @@ private:
     };
     std::optional<ScanoutFeedback> m_scanoutFeedback;
     std::unordered_map<SubSurfaceInterface *, std::unique_ptr<SurfaceItemWayland>> m_subsurfaces;
+    QTimer m_fifoFallbackTimer;
 };
 
 class KWIN_EXPORT SurfacePixmapWayland final : public SurfacePixmap
diff --git a/src/scene/workspacescene.cpp b/src/scene/workspacescene.cpp
index 9cbd551308..41fb20acea 100644
--- a/src/scene/workspacescene.cpp
+++ b/src/scene/workspacescene.cpp
@@ -288,6 +288,16 @@ void WorkspaceScene::frame(SceneDelegate *delegate, OutputFrame *frame)
     }
 }
 
+void WorkspaceScene::prepareFifoPresentation(SceneDelegate *delegate, std::chrono::nanoseconds refreshDuration)
+{
+    const auto items = m_containerItem->sortedChildItems();
+    for (const auto &item : items) {
+        if (item->isVisible() && item->mapToScene(item->boundingRect()).intersects(delegate->output()->geometry())) {
+            item->prepareFifoPresentation(refreshDuration);
+        }
+    }
+}
+
 QRegion WorkspaceScene::prePaint(SceneDelegate *delegate)
 {
     createStackingOrder();
diff --git a/src/scene/workspacescene.h b/src/scene/workspacescene.h
index 97f00e05f5..fc3f6542cb 100644
--- a/src/scene/workspacescene.h
+++ b/src/scene/workspacescene.h
@@ -50,6 +50,7 @@ public:
     Item *overlayItem() const;
 
     QList<SurfaceItem *> scanoutCandidates(ssize_t maxCount) const override;
+    void prepareFifoPresentation(SceneDelegate *delegate, std::chrono::nanoseconds refreshDuration) override;
     QRegion prePaint(SceneDelegate *delegate) override;
     void postPaint() override;
     void paint(const RenderTarget &renderTarget, const QRegion &region) override;
diff --git a/src/wayland/CMakeLists.txt b/src/wayland/CMakeLists.txt
index b4123a5007..5d0683269f 100644
--- a/src/wayland/CMakeLists.txt
+++ b/src/wayland/CMakeLists.txt
@@ -307,12 +307,16 @@ ecm_add_qtwayland_server_protocol_kde(WaylandProtocols_xml
     PROTOCOL ${WaylandProtocols_DATADIR}/staging/xdg-system-bell/xdg-system-bell-v1.xml
     BASENAME xdg-system-bell-v1
 )
-
 ecm_add_qtwayland_server_protocol_kde(WaylandProtocols_xml
     PRIVATE_CODE
     PROTOCOL ${WaylandProtocols_DATADIR}/staging/xdg-toplevel-icon/xdg-toplevel-icon-v1.xml
     BASENAME xdg-toplevel-icon-v1
 )
+ecm_add_qtwayland_server_protocol_kde(WaylandProtocols_xml
+    PRIVATE_CODE
+    PROTOCOL ${WaylandProtocols_DATADIR}/staging/fifo/fifo-v1.xml
+    BASENAME fifo-v1
+)
 
 target_sources(kwin PRIVATE
     abstract_data_source.cpp
@@ -339,6 +343,7 @@ target_sources(kwin PRIVATE
     drmclientbuffer.cpp
     drmlease_v1.cpp
     externalbrightness_v1.cpp
+    fifo_v1.cpp
     filtered_display.cpp
     fixes.cpp
     fractionalscale_v1.cpp
@@ -426,6 +431,7 @@ install(FILES
     dpms.h
     drmlease_v1.h
     externalbrightness_v1.h
+    fifo_v1.h
     fractionalscale_v1.h
     frog_colormanagement_v1.h
     idle.h
@@ -486,6 +492,7 @@ install(FILES
     ${CMAKE_CURRENT_BINARY_DIR}/qwayland-server-alpha-modifier-v1.h
     ${CMAKE_CURRENT_BINARY_DIR}/qwayland-server-color-management-v1.h
     ${CMAKE_CURRENT_BINARY_DIR}/qwayland-server-content-type-v1.h
+    ${CMAKE_CURRENT_BINARY_DIR}/qwayland-server-fifo-v1.h
     ${CMAKE_CURRENT_BINARY_DIR}/qwayland-server-frog-color-management-v1.h
     ${CMAKE_CURRENT_BINARY_DIR}/qwayland-server-kde-external-brightness-v1.h
     ${CMAKE_CURRENT_BINARY_DIR}/qwayland-server-linux-drm-syncobj-v1.h
@@ -493,6 +500,7 @@ install(FILES
     ${CMAKE_CURRENT_BINARY_DIR}/wayland-alpha-modifier-v1-server-protocol.h
     ${CMAKE_CURRENT_BINARY_DIR}/wayland-color-management-v1-server-protocol.h
     ${CMAKE_CURRENT_BINARY_DIR}/wayland-content-type-v1-server-protocol.h
+    ${CMAKE_CURRENT_BINARY_DIR}/wayland-fifo-v1-server-protocol.h
     ${CMAKE_CURRENT_BINARY_DIR}/wayland-frog-color-management-v1-server-protocol.h
     ${CMAKE_CURRENT_BINARY_DIR}/wayland-kde-external-brightness-v1-server-protocol.h
     ${CMAKE_CURRENT_BINARY_DIR}/wayland-linux-drm-syncobj-v1-server-protocol.h
diff --git a/src/wayland/fifo_v1.cpp b/src/wayland/fifo_v1.cpp
new file mode 100644
index 0000000000..a0e2908dec
--- /dev/null
+++ b/src/wayland/fifo_v1.cpp
@@ -0,0 +1,75 @@
+#include "fifo_v1.h"
+
+#include "display.h"
+#include "surface_p.h"
+#include "transaction_p.h"
+
+namespace KWin
+{
+
+static constexpr uint32_t s_version = 1;
+
+FifoManagerV1::FifoManagerV1(Display *display, QObject *parent)
+    : QObject(parent)
+    , QtWaylandServer::wp_fifo_manager_v1(*display, s_version)
+{
+}
+
+void FifoManagerV1::wp_fifo_manager_v1_destroy(Resource *resource)
+{
+    wl_resource_destroy(resource->handle);
+}
+
+void FifoManagerV1::wp_fifo_manager_v1_get_fifo(Resource *resource, uint32_t id, struct ::wl_resource *wlSurface)
+{
+    const auto surface = SurfaceInterface::get(wlSurface);
+    const auto surfacePrivate = SurfaceInterfacePrivate::get(surface);
+    if (surfacePrivate->fifoSurface) {
+        wl_resource_post_error(resource->handle, error_already_exists, "Attempted to create a second fifo surface for the wl_surface");
+        return;
+    }
+    surfacePrivate->fifoSurface = new FifoV1Surface(resource->client(), id, resource->version(), surface);
+}
+
+FifoV1Surface::FifoV1Surface(wl_client *client, uint32_t id, uint32_t version, SurfaceInterface *surface)
+    : QtWaylandServer::wp_fifo_v1(client, id, version)
+    , m_surface(surface)
+{
+}
+
+FifoV1Surface::~FifoV1Surface()
+{
+    if (m_surface) {
+        SurfaceInterfacePrivate::get(m_surface)->fifoSurface = nullptr;
+    }
+}
+
+void FifoV1Surface::wp_fifo_v1_destroy_resource(Resource *resource)
+{
+    delete this;
+}
+
+void FifoV1Surface::wp_fifo_v1_destroy(Resource *resource)
+{
+    wl_resource_destroy(resource->handle);
+}
+
+void FifoV1Surface::wp_fifo_v1_set_barrier(Resource *resource)
+{
+    if (!m_surface) {
+        wl_resource_post_error(resource->handle, error_surface_destroyed, "called set_barrier on a destroyed surface");
+        return;
+    }
+    SurfaceInterfacePrivate::get(m_surface)->pending->fifoBarrier = std::make_unique<FifoBarrier>();
+}
+
+void FifoV1Surface::wp_fifo_v1_wait_barrier(Resource *resource)
+{
+    if (!m_surface) {
+        wl_resource_post_error(resource->handle, error_surface_destroyed, "called wait_barrier on a destroyed surface");
+        return;
+    }
+    SurfaceInterfacePrivate::get(m_surface)->pending->hasFifoWaitCondition = true;
+}
+
+}
diff --git a/src/wayland/fifo_v1.h b/src/wayland/fifo_v1.h
new file mode 100644
index 0000000000..b962d17bef
--- /dev/null
+++ b/src/wayland/fifo_v1.h
@@ -0,0 +1,40 @@
+#pragma once
+#include <QObject>
+#include <QPointer>
+
+#include "wayland/qwayland-server-fifo-v1.h"
+
+namespace KWin
+{
+
+class Display;
+class SurfaceInterface;
+class Transaction;
+
+class FifoManagerV1 : public QObject, public QtWaylandServer::wp_fifo_manager_v1
+{
+    Q_OBJECT
+public:
+    explicit FifoManagerV1(Display *display, QObject *parent);
+
+private:
+    void wp_fifo_manager_v1_destroy(Resource *resource) override;
+    void wp_fifo_manager_v1_get_fifo(Resource *resource, uint32_t id, struct ::wl_resource *surface) override;
+};
+
+class FifoV1Surface : public QtWaylandServer::wp_fifo_v1
+{
+public:
+    explicit FifoV1Surface(wl_client *client, uint32_t id, uint32_t version, SurfaceInterface *surface);
+    ~FifoV1Surface();
+
+private:
+    void wp_fifo_v1_destroy_resource(Resource *resource) override;
+    void wp_fifo_v1_destroy(Resource *resource) override;
+    void wp_fifo_v1_set_barrier(Resource *resource) override;
+    void wp_fifo_v1_wait_barrier(Resource *resource) override;
+
+    const QPointer<SurfaceInterface> m_surface;
+};
+
+}
diff --git a/src/wayland/surface.cpp b/src/wayland/surface.cpp
index 8e3d3252a9..75263b808e 100644
--- a/src/wayland/surface.cpp
+++ b/src/wayland/surface.cpp
@@ -25,6 +25,7 @@
 #include "subcompositor.h"
 #include "surface_p.h"
 #include "transaction.h"
+#include "transaction_p.h"
 #include "utils/resource.h"
 
 #include <wayland-server.h>
@@ -429,6 +430,13 @@ SurfaceInterface::SurfaceInterface(CompositorInterface *compositor, wl_resource
 
 SurfaceInterface::~SurfaceInterface()
 {
+    // ensure that we won't wait on any pending transactions
+    Transaction *transaction = firstTransaction();
+    while (transaction) {
+        transaction->entryFor(this)->state->hasFifoWaitCondition = false;
+        transaction = transaction->next(this);
+    }
+    d->fifoBarrier.reset();
 }
 
 SurfaceRole *SurfaceInterface::role() const
@@ -593,6 +601,8 @@ void SurfaceState::mergeInto(SurfaceState *target)
         target->alphaMultiplier = alphaMultiplier;
         target->alphaMultiplierIsSet = true;
     }
+    target->fifoBarrier = std::move(fifoBarrier);
+    target->hasFifoWaitCondition = hasFifoWaitCondition;
     target->presentationFeedback = std::move(presentationFeedback);
 
     *this = SurfaceState{};
@@ -666,6 +676,8 @@ void SurfaceInterfacePrivate::applyState(SurfaceState *next)
         opaqueRegion = QRegion();
     }
 
+    fifoBarrier = std::move(current->fifoBarrier);
+
     if (opaqueRegionChanged) {
         Q_EMIT q->opaqueChanged(opaqueRegion);
     }
@@ -1194,6 +1206,15 @@ Transaction *SurfaceInterface::firstTransaction() const
 void SurfaceInterface::setFirstTransaction(Transaction *transaction)
 {
     d->firstTransaction = transaction;
+    if (d->fifoBarrier) {
+        const auto entry = transaction ? transaction->entryFor(this) : nullptr;
+        if (entry && entry->state->hasFifoWaitCondition && (!subSurface() || !subSurface()->isSynchronized())) {
+            d->fifoBarrier->setTransaction(transaction);
+            Q_EMIT waitingOnFifo();
+        } else {
+            d->fifoBarrier->setTransaction(nullptr);
+        }
+    }
 }
 
 Transaction *SurfaceInterface::lastTransaction() const
@@ -1228,6 +1249,17 @@ double SurfaceInterface::alphaMultiplier() const
     return d->current->alphaMultiplier;
 }
 
+void SurfaceInterface::prepareFifoPresentation()
+{
+    d->fifoBarrier.reset();
+    for (const auto &subsurface : d->current->subsurface.below) {
+        subsurface->surface()->prepareFifoPresentation();
+    }
+    for (const auto &subsurface : d->current->subsurface.above) {
+        subsurface->surface()->prepareFifoPresentation();
+    }
+}
+
 } // namespace KWin
 
 #include "moc_surface.cpp"
diff --git a/src/wayland/surface.h b/src/wayland/surface.h
index 021f91cac6..9a2986c0ea 100644
--- a/src/wayland/surface.h
+++ b/src/wayland/surface.h
@@ -364,6 +364,13 @@ public:
      */
     SurfaceInterface *mainSurface();
 
+    /**
+     * Should be called immediately before compositing the next non-tearing frame
+     * but always at a minimum rate that guarantees forward progress for the application
+     * (for example 30Hz)
+     */
+    void prepareFifoPresentation();
+
 Q_SIGNALS:
     /**
      * This signal is emitted when the underlying wl_surface resource is about to be freed.
@@ -466,6 +473,12 @@ Q_SIGNALS:
      */
     void stateApplied(quint32 serial);
 
+    /**
+     * This signal is emitted when the surface is waiting on the compositor to call
+     * prepareFifoPresentation before processing the next commit
+     */
+    void waitingOnFifo();
+
 private:
     std::unique_ptr<SurfaceInterfacePrivate> d;
     friend class SurfaceInterfacePrivate;
diff --git a/src/wayland/surface_p.h b/src/wayland/surface_p.h
index 243f05529b..d43b7e89e7 100644
--- a/src/wayland/surface_p.h
+++ b/src/wayland/surface_p.h
@@ -31,6 +31,8 @@ class ColorSurfaceV1;
 class ColorFeedbackSurfaceV1;
 class LinuxDrmSyncObjSurfaceV1;
 class AlphaModifierSurfaceV1;
+class FifoV1Surface;
+class FifoBarrier;
 
 struct SurfaceState
 {
@@ -83,6 +85,8 @@ struct SurfaceState
     } acquirePoint;
     std::shared_ptr<SyncReleasePoint> releasePoint;
     double alphaMultiplier = 1;
+    std::unique_ptr<FifoBarrier> fifoBarrier;
+    bool hasFifoWaitCondition = false;
 
     struct
     {
@@ -161,6 +165,7 @@ public:
 
     Transaction *firstTransaction = nullptr;
     Transaction *lastTransaction = nullptr;
+    std::unique_ptr<FifoBarrier> fifoBarrier;
 
     QList<OutputInterface *> outputs;
     QPointer<OutputInterface> primaryOutput;
@@ -185,6 +190,7 @@ public:
     QList<ColorFeedbackSurfaceV1 *> colorFeedbackSurfaces;
     LinuxDrmSyncObjSurfaceV1 *syncObjV1 = nullptr;
     AlphaModifierSurfaceV1 *alphaModifier = nullptr;
+    FifoV1Surface *fifoSurface = nullptr;
 
     struct
     {
diff --git a/src/wayland/transaction.cpp b/src/wayland/transaction.cpp
index fd53284cff..027ad67b25 100644
--- a/src/wayland/transaction.cpp
+++ b/src/wayland/transaction.cpp
@@ -96,6 +96,28 @@ void TransactionEventFdLocker::unlock()
     delete this;
 }
 
+FifoBarrier::FifoBarrier()
+{
+}
+
+FifoBarrier::~FifoBarrier()
+{
+    if (m_nextTransaction) {
+        m_nextTransaction->unlock();
+    }
+}
+
+void FifoBarrier::setTransaction(Transaction *transaction)
+{
+    if (m_nextTransaction) {
+        m_nextTransaction->unlock();
+    }
+    m_nextTransaction = transaction;
+    if (transaction) {
+        transaction->lock();
+    }
+}
+
 Transaction::Transaction()
 {
 }
@@ -304,6 +326,14 @@ void Transaction::commit()
     }
 }
 
+const TransactionEntry *Transaction::entryFor(SurfaceInterface *surface) const
+{
+    const auto it = std::ranges::find_if(m_entries, [surface](const TransactionEntry &entry) {
+        return entry.surface == surface;
+    });
+    return it == m_entries.end() ? nullptr : &(*it);
+}
+
 } // namespace KWin
 
 #include "moc_transaction.cpp"
diff --git a/src/wayland/transaction.h b/src/wayland/transaction.h
index d138dc8422..da3cf7b5db 100644
--- a/src/wayland/transaction.h
+++ b/src/wayland/transaction.h
@@ -110,6 +110,8 @@ public:
      */
     void commit();
 
+    const TransactionEntry *entryFor(SurfaceInterface *surface) const;
+
 private:
     void apply();
     bool tryApply();
diff --git a/src/wayland/transaction_p.h b/src/wayland/transaction_p.h
index 29a9921e81..d2b64323e1 100644
--- a/src/wayland/transaction_p.h
+++ b/src/wayland/transaction_p.h
@@ -48,4 +48,16 @@ private:
     QSocketNotifier m_notifier;
 };
 
+class FifoBarrier
+{
+public:
+    explicit FifoBarrier();
+    ~FifoBarrier();
+
+    void setTransaction(Transaction *transaction);
+
+private:
+    Transaction *m_nextTransaction = nullptr;
+};
+
 } // namespace KWin
diff --git a/src/wayland_server.cpp b/src/wayland_server.cpp
index 1278713b8d..8b5fd2f79a 100644
--- a/src/wayland_server.cpp
+++ b/src/wayland_server.cpp
@@ -38,6 +38,7 @@
 #include "wayland/drmclientbuffer.h"
 #include "wayland/drmlease_v1.h"
 #include "wayland/externalbrightness_v1.h"
+#include "wayland/fifo_v1.h"
 #include "wayland/filtered_display.h"
 #include "wayland/fixes.h"
 #include "wayland/fractionalscale_v1.h"
@@ -510,6 +511,7 @@ bool WaylandServer::init()
 #if HAVE_WL_FIXES
     new FixesInterface(m_display, m_display);
 #endif
+    m_fifoManager = new FifoManagerV1(m_display, m_display);
     return true;
 }
 
diff --git a/src/wayland_server.h b/src/wayland_server.h
index c0dc30a2fc..762af34505 100644
--- a/src/wayland_server.h
+++ b/src/wayland_server.h
@@ -65,6 +65,7 @@ class ColorManagerV1;
 class LinuxDrmSyncObjV1Interface;
 class RenderBackend;
 class AlphaModifierManagerV1;
+class FifoManagerV1;
 
 class KWIN_EXPORT WaylandServer : public QObject
 {
@@ -294,6 +295,7 @@ private:
     XdgDialogWmV1Interface *m_xdgDialogWm = nullptr;
     ExternalBrightnessV1 *m_externalBrightness = nullptr;
     AlphaModifierManagerV1 *m_alphaModifierManager = nullptr;
+    FifoManagerV1 *m_fifoManager = nullptr;
     KWIN_SINGLETON(WaylandServer)
 };
 
-- 
2.48.1
