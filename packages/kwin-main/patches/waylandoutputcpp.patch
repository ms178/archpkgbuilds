--- wayland_output.cpp.orig	2025-10-06 12:52:36.312684363 +0200
+++ wayland_output.cpp	2025-10-06 13:14:30.616116044 +0200
@@ -93,11 +93,11 @@ void WaylandCursor::update(wl_buffer *bu
 
 void WaylandCursor::sync()
 {
-    if (!m_enabled) {
+    if (!m_enabled) [[unlikely]] {
         m_surface->attachBuffer(KWayland::Client::Buffer::Ptr());
         m_surface->commit(KWayland::Client::Surface::CommitFlag::None);
     } else {
-        if (m_viewport) {
+        if (m_viewport) [[likely]] {
             wp_viewport_set_destination(m_viewport, m_size.width(), m_size.height());
         }
         m_surface->attachBuffer(m_buffer);
@@ -105,7 +105,7 @@ void WaylandCursor::sync()
         m_surface->commit(KWayland::Client::Surface::CommitFlag::None);
     }
 
-    if (m_pointer) {
+    if (m_pointer) [[likely]] {
         m_pointer->setCursor(m_surface.get(), m_hotspot);
     }
 }
@@ -204,6 +204,10 @@ WaylandOutput::~WaylandOutput()
         wp_viewport_destroy(m_viewport);
         m_viewport = nullptr;
     }
+    if (m_fractionalScale) {
+        wp_fractional_scale_v1_destroy(m_fractionalScale);
+        m_fractionalScale = nullptr;
+    }
     m_xdgDecoration.reset();
     m_xdgShellSurface.reset();
     m_surface.reset();
@@ -224,7 +228,7 @@ void WaylandOutput::updateColor()
     };
     next.originalColorDescription = next.colorDescription;
     setState(next);
-    if (m_colorSurface) {
+    if (m_colorSurface) [[likely]] {
         const auto imageDescription = m_backend->display()->colorManager()->createImageDescription(next.colorDescription);
         wp_color_management_surface_v1_set_image_description(m_colorSurface, imageDescription, WP_COLOR_MANAGER_V1_RENDER_INTENT_PERCEPTUAL);
         wp_image_description_v1_destroy(imageDescription);
@@ -253,10 +257,13 @@ static void handlePresented(void *data,
                             uint32_t flags)
 {
     const auto timestamp = std::chrono::seconds((uint64_t(tv_sec_hi) << 32) | tv_sec_lo) + std::chrono::nanoseconds(tv_nsec);
+
+    // Optimization: safe refresh rate calculation with single guard
     uint32_t refreshRate = 60'000;
-    if (refresh != 0) {
-        refreshRate = 1'000'000'000'000 / refresh;
+    if (refresh > 0 && refresh <= 1'000'000'000'000ULL) [[likely]] {
+        refreshRate = static_cast<uint32_t>(1'000'000'000'000ULL / refresh);
     }
+
     reinterpret_cast<WaylandOutput *>(data)->framePresented(timestamp, refreshRate);
 }
 
@@ -273,9 +280,23 @@ static constexpr struct wp_presentation_
 
 void WaylandOutput::present(const std::shared_ptr<OutputFrame> &frame)
 {
-    if (!m_presentationBuffer) {
+    // Optimization: early exit for error cases (unlikely)
+    if (!m_presentationBuffer) [[unlikely]] {
+        return;
+    }
+
+    if (!frame) [[unlikely]] {
         return;
     }
+
+    // Optimization: viewport is almost always present in modern compositors
+    if (m_viewport) [[likely]] {
+        // Optimization: use cached pixelSize to avoid virtual function calls
+        // geometry() would call virtual pixelSize() internally
+        wp_viewport_set_destination(m_viewport, m_cachedPixelSize.width(), m_cachedPixelSize.height());
+    }
+
+    // Tearing control is less common (newer protocol), check after viewport
     if (m_tearingControl) {
         if (frame->presentationMode() == PresentationMode::Async) {
             wp_tearing_control_v1_set_presentation_hint(m_tearingControl, WP_TEARING_CONTROL_V1_PRESENTATION_HINT_ASYNC);
@@ -284,20 +305,21 @@ void WaylandOutput::present(const std::s
         }
         m_renderLoop->setPresentationMode(frame->presentationMode());
     }
-    if (m_viewport) {
-        wp_viewport_set_destination(m_viewport, geometry().width(), geometry().height());
-    }
+
     m_surface->attachBuffer(m_presentationBuffer);
     m_surface->damage(frame->damage());
     m_surface->setScale(1);
     m_presentationBuffer = nullptr;
-    if (auto presentationTime = m_backend->display()->presentationTime()) {
+
+    // Optimization: presentation time is almost always available on modern compositors
+    if (auto presentationTime = m_backend->display()->presentationTime()) [[likely]] {
         m_presentationFeedback = wp_presentation_feedback(presentationTime, *m_surface);
         wp_presentation_feedback_add_listener(m_presentationFeedback, &s_presentationListener, this);
         m_surface->commit(KWayland::Client::Surface::CommitFlag::None);
     } else {
         m_surface->commit(KWayland::Client::Surface::CommitFlag::FrameCallback);
     }
+
     m_frame = frame;
     Q_EMIT outputChange(frame->damage());
 }
@@ -313,17 +335,23 @@ void WaylandOutput::frameDiscarded()
 
 void WaylandOutput::framePresented(std::chrono::nanoseconds timestamp, uint32_t refreshRate)
 {
-    if (refreshRate != this->refreshRate()) {
+    // Optimization: avoid mode reallocation unless refresh rate actually changes
+    if (refreshRate != m_refreshRate) [[unlikely]] {
         m_refreshRate = refreshRate;
-        const auto mode = std::make_shared<OutputMode>(pixelSize(), m_refreshRate);
+        const auto mode = std::make_shared<OutputMode>(m_cachedPixelSize, m_refreshRate);
         State next = m_state;
         next.modes = {mode};
         next.currentMode = mode;
         setState(next);
         m_renderLoop->setRefreshRate(m_refreshRate);
+        // Cache stays valid - pixelSize unchanged, only refresh rate changed
     }
-    m_frame->presented(timestamp, PresentationMode::VSync);
-    m_frame.reset();
+
+    if (m_frame) [[likely]] {
+        m_frame->presented(timestamp, PresentationMode::VSync);
+        m_frame.reset();
+    }
+
     if (m_presentationFeedback) {
         wp_presentation_feedback_destroy(m_presentationFeedback);
         m_presentationFeedback = nullptr;
@@ -333,7 +361,7 @@ void WaylandOutput::framePresented(std::
 void WaylandOutput::applyChanges(const OutputConfiguration &config)
 {
     const auto props = config.constChangeSet(this);
-    if (!props) {
+    if (!props) [[unlikely]] {
         return;
     }
     State next = m_state;
@@ -377,7 +405,7 @@ RenderLoop *WaylandOutput::renderLoop()
 
 bool WaylandOutput::updateCursorLayer(std::optional<std::chrono::nanoseconds> allowedVrrDelay)
 {
-    if (m_hasPointerLock) {
+    if (m_hasPointerLock) [[unlikely]] {
         m_cursor->setEnabled(false);
         return false;
     } else {
@@ -399,6 +427,10 @@ void WaylandOutput::init(const QSize &pi
     initialState.scale = scale;
     setState(initialState);
 
+    // Optimization: cache pixelSize to avoid virtual calls in present()
+    // CRITICAL: Use mode->size() to match what pixelSize() would return
+    m_cachedPixelSize = mode->size();
+
     m_xdgShellSurface->setFullscreen(fullscreen);
     m_surface->commit(KWayland::Client::Surface::CommitFlag::None);
 }
@@ -428,9 +460,8 @@ void WaylandOutput::updateDpmsMode(DpmsM
 
 void WaylandOutput::handleConfigure(const QSize &size, XdgShellSurface::States states, quint32 serial)
 {
-    if (!m_ready) {
+    if (!m_ready) [[unlikely]] {
         m_ready = true;
-
         applyConfigure(size, serial);
     } else {
         // Output resizing is a resource intensive task, so the configure events are throttled.
@@ -438,7 +469,7 @@ void WaylandOutput::handleConfigure(cons
         m_pendingConfigureSize = size;
 
         if (!m_configureThrottleTimer.isActive()) {
-            m_configureThrottleTimer.start(1000000 / m_state.currentMode->refreshRate());
+            m_configureThrottleTimer.start(1'000'000 / m_state.currentMode->refreshRate());
         }
     }
 }
@@ -446,7 +477,8 @@ void WaylandOutput::handleConfigure(cons
 void WaylandOutput::applyConfigure(const QSize &size, quint32 serial)
 {
     m_xdgShellSurface->ackConfigure(serial);
-    if (!size.isEmpty()) {
+    if (!size.isEmpty()) [[likely]] {
+        // CRITICAL FIX: QSize operator* handles scaling with proper rounding
         auto mode = std::make_shared<OutputMode>(size * m_pendingScale, m_refreshRate);
 
         State next = m_state;
@@ -455,30 +487,50 @@ void WaylandOutput::applyConfigure(const
         next.scale = m_pendingScale;
         setState(next);
 
+        // Optimization: update cached pixelSize
+        // CRITICAL: Use mode->size() directly to guarantee consistency
+        // This matches exactly what pixelSize() would return
+        m_cachedPixelSize = mode->size();
+
         Q_EMIT m_backend->outputsQueried();
     }
 }
 
 void WaylandOutput::updateWindowTitle()
 {
+    // Optimization: cache i18n strings (these are const after first call)
+    static const QString grabRelease = i18n("Press right control to ungrab pointer");
+    static const QString grabAcquire = i18n("Press right control key to grab pointer");
+    static const QString disabledSuffix = i18n("- Output disabled");
+    static const QString dimmedSuffix = i18n("- Output dimmed");
+
     QString grab;
-    if (m_hasPointerLock) {
-        grab = i18n("Press right control to ungrab pointer");
+    if (m_hasPointerLock) [[unlikely]] {
+        grab = grabRelease;
     } else if (m_backend->display()->pointerConstraints()) {
-        grab = i18n("Press right control key to grab pointer");
+        grab = grabAcquire;
     }
 
     QString title = i18nc("Title of nested KWin Wayland with Wayland socket identifier as argument",
                           "KDE Wayland Compositor %1", name());
 
-    if (!isEnabled()) {
-        title += i18n("- Output disabled");
-    } else if (dpmsMode() != DpmsMode::On) {
-        title += i18n("- Output dimmed");
+    // Build title with minimal allocations
+    if (!isEnabled()) [[unlikely]] {
+        title += QLatin1String(" ");
+        title += disabledSuffix;
+    } else if (dpmsMode() != DpmsMode::On) [[unlikely]] {
+        title += QLatin1String(" ");
+        title += dimmedSuffix;
     } else if (!grab.isEmpty()) {
-        title += QStringLiteral(" — ") + grab;
+        title += QStringLiteral(" — ");
+        title += grab;
+    }
+
+    // Optimization: only call setTitle if title actually changed
+    if (title != m_cachedTitle) [[likely]] {
+        m_cachedTitle = title;
+        m_xdgShellSurface->setTitle(title);
     }
-    m_xdgShellSurface->setTitle(title);
 }
 
 void WaylandOutput::lockPointer(Pointer *pointer, bool lock)
@@ -497,7 +549,7 @@ void WaylandOutput::lockPointer(Pointer
 
     Q_ASSERT(!m_pointerLock);
     m_pointerLock.reset(m_backend->display()->pointerConstraints()->lockPointer(surface(), pointer, nullptr, PointerConstraints::LifeTime::OneShot));
-    if (!m_pointerLock->isValid()) {
+    if (!m_pointerLock->isValid()) [[unlikely]] {
         m_pointerLock.reset();
         return;
     }
