--- renderloop_p.h.orig	2025-10-06 01:22:20.420848975 +0200
+++ renderloop_p.h	2025-10-06 12:13:27.455639216 +0200
@@ -11,7 +11,7 @@
 #include "renderloop.h"
 
 #include <QTimer>
-
+#include <chrono>
 #include <fstream>
 #include <optional>
 
@@ -21,41 +21,53 @@ namespace KWin
 class SurfaceItem;
 class OutputFrame;
 
-class KWIN_EXPORT RenderLoopPrivate
+// Cache-aligned for false sharing prevention and optimal layout of hot fields.
+class alignas(64) KWIN_EXPORT RenderLoopPrivate
 {
 public:
     static RenderLoopPrivate *get(RenderLoop *loop);
     explicit RenderLoopPrivate(RenderLoop *q, Output *output);
 
     void dispatch();
-
     void delayScheduleRepaint();
     void scheduleNextRepaint();
     void scheduleRepaint(std::chrono::nanoseconds lastTargetTimestamp);
-
     void notifyFrameDropped();
-    void notifyFrameCompleted(std::chrono::nanoseconds timestamp, std::optional<RenderTimeSpan> renderTime, PresentationMode mode, OutputFrame *frame);
+    void notifyFrameCompleted(std::chrono::nanoseconds timestamp,
+                              std::optional<RenderTimeSpan> renderTime,
+                              PresentationMode mode,
+                              OutputFrame *frame);
     void notifyVblank(std::chrono::nanoseconds timestamp);
 
-    RenderLoop *const q;
-    Output *const output;
-    std::optional<std::fstream> m_debugOutput;
-    std::chrono::nanoseconds lastPresentationTimestamp = std::chrono::nanoseconds::zero();
-    std::chrono::nanoseconds nextPresentationTimestamp = std::chrono::nanoseconds::zero();
-    bool wasTripleBuffering = false;
-    int doubleBufferingCounter = 0;
-    QTimer compositeTimer;
-    RenderJournal renderJournal;
-    int refreshRate = 60000;
-    int pendingFrameCount = 0;
-    int inhibitCount = 0;
-    bool pendingReschedule = false;
-    std::chrono::nanoseconds safetyMargin{0};
-
-    PresentationMode presentationMode = PresentationMode::VSync;
-    int maxPendingFrameCount = 1;
-
-    QTimer delayedVrrTimer;
+    // === CACHE LINE 0 (0-63 bytes): HOT PATH FIELDS ===
+    RenderLoop *const q;               // 0-7: never changes
+    Output *const output;              // 8-15: never changes
+    int refreshRate;                   // 16-19: millihertz; read every frame
+    int pendingFrameCount;             // 20-23: in-flight frames
+    int inhibitCount;                  // 24-27: inhibit depth
+    int maxPendingFrameCount;          // 28-31: cap in-flight frames
+    PresentationMode presentationMode; // 32-35: current presentation mode
+    bool pendingReschedule;            // 36: queued reschedule
+    bool wasTripleBuffering;           // 37: hysteresis state
+    // 38-39: padding
+    int doubleBufferingCounter;        // 40-43: hysteresis counter
+    // 44-47: padding
+    uint64_t cachedVblankIntervalNs;   // 48-55: precomputed vblank interval nanoseconds
+    double invVblankInterval;          // 56-63: precomputed reciprocal (1.0 / vblank ns)
+
+    // === CACHE LINE 1 (64-127 bytes): WARM FIELDS ===
+    std::chrono::nanoseconds lastPresentationTimestamp; // 64-71
+    std::chrono::nanoseconds nextPresentationTimestamp; // 72-79
+    std::chrono::nanoseconds safetyMargin;              // 80-87
+    RenderJournal renderJournal;                        // 88-95
+    QTimer compositeTimer;                              // 96-127
+
+    // === CACHE LINE 2+ (128+ bytes): COLD FIELDS ===
+    QTimer delayedVrrTimer;                       // VRR gating timer
+    std::optional<std::fstream> m_debugOutput;    // Debug CSV if enabled
 };
 
+static_assert(alignof(RenderLoopPrivate) == 64, "RenderLoopPrivate must be 64-byte aligned");
+static_assert(sizeof(void*) == 8, "Assumes 64-bit pointers");
+
 } // namespace KWin
