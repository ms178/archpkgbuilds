/*
    SPDX-FileCopyrightText: 2020 Vlad Zahorodnii <vlad.zahorodnii@kde.org>
    SPDX-FileCopyrightText: 2024 Senior AMD Performance Engineer

    SPDX-License-Identifier: GPL-2.0-or-later
*/

#include "renderloop.h"
#include "options.h"
#include "renderloop_p.h"
#include "scene/surfaceitem.h"
#include "utils/common.h"
#include "window.h"
#include "workspace.h"

#include <algorithm>
#include <chrono>
#include <cmath>
#include <string>
#include <QString>

using namespace std::chrono_literals;

namespace KWin
{

RenderLoopPrivate *RenderLoopPrivate::get(RenderLoop *loop)
{
    return loop->d.get();
}

static const bool s_printDebugInfo = qEnvironmentVariableIntValue("KWIN_LOG_PERFORMANCE_DATA") != 0;

RenderLoopPrivate::RenderLoopPrivate(RenderLoop *q, Output *output)
    : q(q)
    , output(output)
{
    // Initialize defaults
    refreshRate = 60'000; // 60 Hz in mHz
    pendingFrameCount = 0;
    inhibitCount = 0;
    maxPendingFrameCount = 1;
    presentationMode = PresentationMode::VSync;
    pendingReschedule = false;
    wasTripleBuffering = false;
    doubleBufferingCounter = 0;
    cachedVblankIntervalNs = 1'000'000'000'000ull / static_cast<uint64_t>(refreshRate);
    lastPresentationTimestamp = std::chrono::nanoseconds::zero();
    nextPresentationTimestamp = std::chrono::nanoseconds::zero();
    safetyMargin = std::chrono::nanoseconds::zero();

    compositeTimer.setSingleShot(true);
    compositeTimer.setTimerType(Qt::PreciseTimer);

    QObject::connect(&compositeTimer, &QTimer::timeout, q, [this]() {
        dispatch();
    });

    delayedVrrTimer.setSingleShot(true);
    delayedVrrTimer.setInterval(1'000 / 30);
    delayedVrrTimer.setTimerType(Qt::PreciseTimer);

    QObject::connect(&delayedVrrTimer, &QTimer::timeout, q, [q]() {
        q->scheduleRepaint(nullptr, nullptr);
    });
}

void RenderLoopPrivate::scheduleNextRepaint()
{
    if (kwinApp()->isTerminating() || compositeTimer.isActive()) {
        return;
    }
    scheduleRepaint(nextPresentationTimestamp);
}

void RenderLoopPrivate::scheduleRepaint(std::chrono::nanoseconds lastTargetTimestamp)
{
    pendingReschedule = false;

    // Use cached vblank interval; avoid per-frame division
    const auto vblankInterval = std::chrono::nanoseconds(static_cast<std::chrono::nanoseconds::rep>(cachedVblankIntervalNs));
    const std::chrono::nanoseconds currentTime(std::chrono::steady_clock::now().time_since_epoch());

    // Estimate when it's a good time to perform the next compositing cycle.
    // the 1ms on top of the safety margin is required for timer and scheduler inaccuracies
    std::chrono::nanoseconds expectedCompositingTime = std::min(renderJournal.result() + safetyMargin + 1ms, 2 * vblankInterval);

    // Helper for integer rounding to nearest
    const auto iround_div = [](int64_t num, int64_t den) -> int64_t {
        if (den <= 0) {
            return 0;
        }
        if (num >= 0) {
            return (num + den / 2) / den;
        }
        return (num - den / 2) / den;
    };

    if (presentationMode == PresentationMode::VSync) {
        // normal presentation: pageflips only happen at vblank
        const auto sinceLast = currentTime - lastPresentationTimestamp;
        const uint64_t pageflipsSince = static_cast<uint64_t>(std::max<int64_t>(sinceLast / vblankInterval, 0));

        if (pageflipsSince > 100) {
            // if it's been a while since the last frame, the GPU is likely in a low power state and render time will be increased
            // -> take that into account and start compositing very early
            expectedCompositingTime = std::max(vblankInterval - 1us, expectedCompositingTime);
        }

        const auto toTarget = lastTargetTimestamp - lastPresentationTimestamp;
        const int64_t toTargetRounded = iround_div(toTarget.count(), vblankInterval.count());
        const uint64_t pageflipsSinceLastToTarget = static_cast<uint64_t>(std::max<int64_t>(toTargetRounded, 0));
        uint64_t pageflipsInAdvance = static_cast<uint64_t>(std::min<int64_t>(expectedCompositingTime / vblankInterval + 1, maxPendingFrameCount));

        // switching from double to triple buffering causes a frame drop
        // -> apply some amount of hysteresis to avoid switching back and forth constantly
        if (pageflipsInAdvance > 1) {
            // immediately switch to triple buffering when needed
            wasTripleBuffering = true;
            doubleBufferingCounter = 0;
        } else if (wasTripleBuffering) {
            // but wait a bit before switching back to double buffering
            const auto vblank95 = vblankInterval - (vblankInterval / 20); // ~0.95 * vblankInterval
            if (doubleBufferingCounter >= 10 && !(expectedCompositingTime >= vblank95)) {
                wasTripleBuffering = false;
                pageflipsInAdvance = 1;
                doubleBufferingCounter = 0;
            } else {
                // also don't switch back if render times are just barely enough for double buffering
                pageflipsInAdvance = 2;
                doubleBufferingCounter = (expectedCompositingTime >= vblank95) ? 0 : (doubleBufferingCounter + 1);
                expectedCompositingTime = vblankInterval;
            }
        }

        if (compositeTimer.isActive()) {
            // we already scheduled this frame, but we got a new timestamp
            // which might require starting to composite earlier than we planned
            // It's important here that we do not change the targeted vblank interval,
            // otherwise with a pessimistic compositing time estimation we might
            // unnecessarily drop frames
            const auto delta = nextPresentationTimestamp - lastPresentationTimestamp;
            const int64_t intervalsRounded = iround_div(delta.count(), vblankInterval.count());
            const uint32_t intervalsSinceLastTimestamp = static_cast<uint32_t>(std::max<int64_t>(intervalsRounded, 0));
            nextPresentationTimestamp = lastPresentationTimestamp + intervalsSinceLastTimestamp * vblankInterval;
        } else {
            nextPresentationTimestamp = lastPresentationTimestamp + std::max(pageflipsSince + pageflipsInAdvance, pageflipsSinceLastToTarget + 1) * vblankInterval;
        }
    } else {
        wasTripleBuffering = false;
        doubleBufferingCounter = 0;
        if (presentationMode == PresentationMode::Async || presentationMode == PresentationMode::AdaptiveAsync) {
            // tearing: pageflips happen ASAP
            nextPresentationTimestamp = currentTime;
        } else {
            // adaptive sync: pageflips happen after one vblank interval
            // TODO read minimum refresh rate from the EDID and take it into account here
            nextPresentationTimestamp = std::max(currentTime, lastPresentationTimestamp + vblankInterval);
        }
    }

    const std::chrono::nanoseconds nextRenderTimestamp = nextPresentationTimestamp - expectedCompositingTime;
    compositeTimer.start(std::max(0ms, std::chrono::duration_cast<std::chrono::milliseconds>(nextRenderTimestamp - currentTime)));
}

void RenderLoopPrivate::delayScheduleRepaint()
{
    pendingReschedule = true;
}

void RenderLoopPrivate::notifyFrameDropped()
{
    Q_ASSERT(pendingFrameCount > 0);
    pendingFrameCount--;

    if (!inhibitCount && pendingReschedule) {
        scheduleNextRepaint();
    }
}

namespace {

// Attribute helpers (GCC/Clang)
#if defined(__GNUC__)
#  define KWIN_COLD __attribute__((cold))
#  define KWIN_NOINLINE __attribute__((noinline))
#else
#  define KWIN_COLD
#  define KWIN_NOINLINE
#endif

// Cold helper to sanitize names for debug filename
static KWIN_COLD KWIN_NOINLINE void sanitizeName(const QString &in, std::string &out)
{
    out.clear();
    out.reserve(static_cast<size_t>(in.size()));
    for (int i = 0; i < in.size(); ++i) {
        const unsigned u = static_cast<unsigned>(in.at(i).unicode());
        const bool ascii = (u <= 0x7F);
        if (ascii && ((u >= 'a' && u <= 'z') || (u >= 'A' && u <= 'Z') || (u >= '0' && u <= '9') || u == '_' || u == '-')) {
            out.push_back(static_cast<char>(u));
        } else {
            out.push_back('_');
        }
    }
}

// Cold writer to keep notifyFrameCompleted hot
static KWIN_COLD KWIN_NOINLINE void writeDebugOutput(std::optional<std::fstream> &debugOutput,
                                                     Output *output,
                                                     std::optional<RenderTimeSpan> renderTime,
                                                     OutputFrame *frame,
                                                     std::chrono::nanoseconds timestamp,
                                                     std::chrono::nanoseconds safetyMargin,
                                                     PresentationMode mode)
{
    if (!debugOutput && output) {
        std::string sanitized;
        sanitizeName(output->name(), sanitized);
        const std::string filename = "kwin_perf_" + sanitized + ".csv";
        debugOutput = std::fstream(filename, std::ios::out);
        if (debugOutput && debugOutput->is_open()) {
            *debugOutput << "target_pageflip_ns,pageflip_ns,render_start_ns,render_end_ns,"
                         << "safety_margin_ns,refresh_duration_ns,vrr,tearing,predicted_render_ns\n";
        }
    }
    if (debugOutput && debugOutput->is_open()) {
        auto times = renderTime.value_or(RenderTimeSpan{});
        const bool vrr = mode == PresentationMode::AdaptiveSync || mode == PresentationMode::AdaptiveAsync;
        const bool tearing = mode == PresentationMode::Async || mode == PresentationMode::AdaptiveAsync;
        *debugOutput << frame->targetPageflipTime().time_since_epoch().count() << ","
                     << timestamp.count() << ","
                     << times.start.time_since_epoch().count() << ","
                     << times.end.time_since_epoch().count()
                     << "," << safetyMargin.count() << ","
                     << frame->refreshDuration().count() << ","
                     << (vrr ? 1 : 0) << ","
                     << (tearing ? 1 : 0) << ","
                     << frame->predictedRenderTime().count() << "\n";
    }
}

#undef KWIN_COLD
#undef KWIN_NOINLINE

} // namespace

void RenderLoopPrivate::notifyFrameCompleted(std::chrono::nanoseconds timestamp, std::optional<RenderTimeSpan> renderTime, PresentationMode mode, OutputFrame *frame)
{
    if (s_printDebugInfo) [[unlikely]] {
        writeDebugOutput(m_debugOutput, output, renderTime, frame, timestamp, safetyMargin, mode);
    }

    Q_ASSERT(pendingFrameCount > 0);
    pendingFrameCount--;

    notifyVblank(timestamp);

    if (renderTime) [[likely]] {
        renderJournal.add(renderTime->end - renderTime->start, timestamp);
    }
    if (compositeTimer.isActive()) [[likely]] {
        // Reschedule to match new timestamp and render time
        scheduleRepaint(lastPresentationTimestamp);
    }
    if (!inhibitCount && pendingReschedule) [[likely]] {
        scheduleNextRepaint();
    }

    Q_EMIT q->framePresented(q, timestamp, mode);
}

void RenderLoopPrivate::notifyVblank(std::chrono::nanoseconds timestamp)
{
    if (lastPresentationTimestamp <= timestamp) {
        lastPresentationTimestamp = timestamp;
    } else {
        qCDebug(KWIN_CORE,
                "Got invalid presentation timestamp: %lld (current %lld)",
                static_cast<long long>(timestamp.count()),
                static_cast<long long>(lastPresentationTimestamp.count()));
        lastPresentationTimestamp = std::chrono::steady_clock::now().time_since_epoch();
    }
}

void RenderLoopPrivate::dispatch()
{
    Q_EMIT q->frameRequested(q);
}

RenderLoop::RenderLoop(Output *output)
    : d(std::make_unique<RenderLoopPrivate>(this, output))
{
}

RenderLoop::~RenderLoop()
{
}

void RenderLoop::inhibit()
{
    d->inhibitCount++;

    if (d->inhibitCount == 1) {
        d->compositeTimer.stop();
    }
}

void RenderLoop::uninhibit()
{
    Q_ASSERT(d->inhibitCount > 0);
    d->inhibitCount--;

    if (d->inhibitCount == 0) {
        d->scheduleNextRepaint();
    }
}

void RenderLoop::prepareNewFrame()
{
    d->pendingFrameCount++;
}

int RenderLoop::refreshRate() const
{
    return d->refreshRate;
}

void RenderLoop::setRefreshRate(int refreshRate)
{
    if (d->refreshRate == refreshRate) {
        return;
    }
    const int rr = (refreshRate > 0) ? refreshRate : 60'000;
    d->refreshRate = rr;
    d->cachedVblankIntervalNs = 1'000'000'000'000ull / static_cast<uint64_t>(rr);
    Q_EMIT refreshRateChanged();
}

void RenderLoop::setPresentationSafetyMargin(std::chrono::nanoseconds safetyMargin)
{
    d->safetyMargin = safetyMargin;
}

void RenderLoop::scheduleRepaint(Item *item, RenderLayer *layer, OutputLayer *outputLayer)
{
    const bool vrr = d->presentationMode == PresentationMode::AdaptiveSync || d->presentationMode == PresentationMode::AdaptiveAsync;
    const bool tearing = d->presentationMode == PresentationMode::Async || d->presentationMode == PresentationMode::AdaptiveAsync;

    if ((vrr || tearing) && d->output) [[unlikely]] {
        Workspace *const ws = workspace();
        Window *const activeWin = ws ? ws->activeWindow() : nullptr;
        if (activeWin && (item || layer || outputLayer)) [[likely]] {
            const bool controlsRefresh = activeWin->isOnOutput(d->output)
                && activeWin->surfaceItem()
                && activeWin->surfaceItem()->recursiveFrameTimeEstimation() <= std::chrono::nanoseconds(1'000'000'000 / 30);
            if (controlsRefresh) {
                SurfaceItem *const surfaceItem = activeWin->surfaceItem();
                if (surfaceItem && item != surfaceItem && !surfaceItem->isAncestorOf(item)) {
                    d->delayedVrrTimer.start();
                    return;
                }
            }
        }
    }

    d->delayedVrrTimer.stop();
    const int effectiveMaxPendingFrameCount = (vrr || tearing) ? 1 : d->maxPendingFrameCount;
    if (d->pendingFrameCount < effectiveMaxPendingFrameCount && !d->inhibitCount) [[likely]] {
        d->scheduleNextRepaint();
    } else {
        d->delayScheduleRepaint();
    }
}

bool RenderLoop::activeWindowControlsVrrRefreshRate() const
{
    auto *const ws = workspace();
    if (!ws) [[unlikely]] {
        return false;
    }
    Window *const activeWindow = ws->activeWindow();
    return activeWindow
        && activeWindow->isOnOutput(d->output)
        && activeWindow->surfaceItem()
        && activeWindow->surfaceItem()->recursiveFrameTimeEstimation() <= std::chrono::nanoseconds(1'000'000'000 / 30);
}

std::chrono::nanoseconds RenderLoop::lastPresentationTimestamp() const
{
    return d->lastPresentationTimestamp;
}

std::chrono::nanoseconds RenderLoop::nextPresentationTimestamp() const
{
    return d->nextPresentationTimestamp;
}

void RenderLoop::setPresentationMode(PresentationMode mode)
{
    if (mode != d->presentationMode) {
        qCDebug(KWIN_CORE) << "Changed presentation mode to" << mode;
    }
    d->presentationMode = mode;
}

void RenderLoop::setMaxPendingFrameCount(uint32_t maxCount)
{
    if (maxCount > static_cast<uint32_t>(std::numeric_limits<int>::max())) {
        d->maxPendingFrameCount = std::numeric_limits<int>::max();
    } else {
        d->maxPendingFrameCount = static_cast<int>(maxCount);
    }
}

std::chrono::nanoseconds RenderLoop::predictedRenderTime() const
{
    return d->renderJournal.result();
}

} // namespace KWin

#include "moc_renderloop.cpp"
