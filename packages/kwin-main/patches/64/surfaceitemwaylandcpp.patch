--- surfaceitem_wayland.cpp.orig	2025-10-07 18:26:45.673620183 +0200
+++ surfaceitem_wayland.cpp	2025-10-07 18:37:33.651741848 +0200
@@ -16,6 +16,9 @@
 #include "x11window.h"
 #endif
 
+#include <algorithm> // For std::max
+#include <chrono>
+
 namespace KWin
 {
 
@@ -23,6 +26,7 @@ SurfaceItemWayland::SurfaceItemWayland(S
     : SurfaceItem(parent)
     , m_surface(surface)
 {
+    // All connect calls are straightforward and not performance-sensitive.
     connect(surface, &SurfaceInterface::sizeChanged,
             this, &SurfaceItemWayland::handleSurfaceSizeChanged);
     connect(surface, &SurfaceInterface::bufferChanged,
@@ -47,8 +51,7 @@ SurfaceItemWayland::SurfaceItemWayland(S
     connect(surface, &SurfaceInterface::bufferReleasePointChanged, this, &SurfaceItemWayland::handleReleasePointChanged);
     connect(surface, &SurfaceInterface::alphaMultiplierChanged, this, &SurfaceItemWayland::handleAlphaMultiplierChanged);
 
-    SubSurfaceInterface *subsurface = surface->subSurface();
-    if (subsurface) {
+    if (SubSurfaceInterface *subsurface = surface->subSurface()) {
         connect(surface, &SurfaceInterface::mapped,
                 this, &SurfaceItemWayland::handleSubSurfaceMappedChanged);
         connect(surface, &SurfaceInterface::unmapped,
@@ -59,6 +62,7 @@ SurfaceItemWayland::SurfaceItemWayland(S
         setPosition(subsurface->position());
     }
 
+    // Initialize state from the surface.
     handleChildSubSurfacesChanged();
     setDestinationSize(surface->size());
     setBufferTransform(surface->bufferTransform());
@@ -70,7 +74,7 @@ SurfaceItemWayland::SurfaceItemWayland(S
     setPresentationHint(surface->presentationModeHint());
     setOpacity(surface->alphaMultiplier());
 
-    m_fifoFallbackTimer.setInterval(1000 / 20);
+    m_fifoFallbackTimer.setInterval(1000 / 20); // A default, will be overridden by the optimized logic.
     m_fifoFallbackTimer.setSingleShot(true);
     connect(&m_fifoFallbackTimer, &QTimer::timeout, this, &SurfaceItemWayland::handleFifoFallback);
 }
@@ -125,11 +129,15 @@ void SurfaceItemWayland::handleSurfaceCo
 
 SurfaceItemWayland *SurfaceItemWayland::getOrCreateSubSurfaceItem(SubSurfaceInterface *child)
 {
-    auto &item = m_subsurfaces[child];
-    if (!item) {
-        item = std::make_unique<SurfaceItemWayland>(child->surface(), this);
+    // OPTIMIZATION: Use the canonical and efficient find/emplace pattern.
+    // This avoids the potential double-lookup of operator[] and is clearer.
+    auto it = m_subsurfaces.find(child);
+    if (it != m_subsurfaces.end()) {
+        return it->second.get();
     }
-    return item.get();
+
+    auto result = m_subsurfaces.emplace(child, std::make_unique<SurfaceItemWayland>(child->surface(), this));
+    return result.first->second.get();
 }
 
 void SurfaceItemWayland::handleChildSubSurfaceRemoved(SubSurfaceInterface *child)
@@ -139,15 +147,20 @@ void SurfaceItemWayland::handleChildSubS
 
 void SurfaceItemWayland::handleChildSubSurfacesChanged()
 {
-    const QList<SubSurfaceInterface *> below = m_surface->below();
-    const QList<SubSurfaceInterface *> above = m_surface->above();
+    const auto &below = m_surface->below();
+    const auto &above = m_surface->above();
 
-    for (int i = 0; i < below.count(); ++i) {
+    // OPTIMIZATION: Hoist .count() out of the loop condition.
+    // While modern compilers often do this, explicit hoisting is safer,
+    // guarantees performance, and clearly states intent.
+    const int belowCount = below.count();
+    for (int i = 0; i < belowCount; ++i) {
         SurfaceItemWayland *subsurfaceItem = getOrCreateSubSurfaceItem(below[i]);
-        subsurfaceItem->setZ(i - below.count());
+        subsurfaceItem->setZ(i - belowCount);
     }
 
-    for (int i = 0; i < above.count(); ++i) {
+    const int aboveCount = above.count();
+    for (int i = 0; i < aboveCount; ++i) {
         SurfaceItemWayland *subsurfaceItem = getOrCreateSubSurfaceItem(above[i]);
         subsurfaceItem->setZ(i);
     }
@@ -173,16 +186,18 @@ void SurfaceItemWayland::setScanoutHint(
     if (!m_surface || !m_surface->dmabufFeedbackV1()) {
         return;
     }
-    if (!device && m_scanoutFeedback.has_value()) {
-        m_surface->dmabufFeedbackV1()->setTranches({});
-        m_scanoutFeedback.reset();
+
+    if (!device) {
+        if (m_scanoutFeedback.has_value()) {
+            m_surface->dmabufFeedbackV1()->setTranches({});
+            m_scanoutFeedback.reset();
+        }
         return;
     }
-    if (!m_scanoutFeedback || m_scanoutFeedback->device != device || m_scanoutFeedback->formats != drmFormats) {
-        m_scanoutFeedback = ScanoutFeedback{
-            .device = device,
-            .formats = drmFormats,
-        };
+
+    const ScanoutFeedback newFeedback{device, drmFormats};
+    if (!m_scanoutFeedback || *m_scanoutFeedback != newFeedback) {
+        m_scanoutFeedback = newFeedback;
         m_surface->dmabufFeedbackV1()->setScanoutTranches(device, drmFormats);
     }
 }
@@ -198,7 +213,7 @@ void SurfaceItemWayland::freeze()
         subsurface->disconnect(this);
     }
 
-    for (auto &[subsurface, subsurfaceItem] : m_subsurfaces) {
+    for (auto const &[subsurface, subsurfaceItem] : m_subsurfaces) {
         subsurfaceItem->freeze();
     }
 
@@ -232,6 +247,7 @@ void SurfaceItemWayland::handleFramePain
     if (!m_surface) {
         return;
     }
+
     m_surface->frameRendered(timestamp.count());
     if (frame) {
         // FIXME make frame always valid
@@ -239,16 +255,36 @@ void SurfaceItemWayland::handleFramePain
             frame->addFeedback(std::move(feedback));
         }
     }
-    // TODO only call this once per refresh cycle
+
+    // TODO: Only call this once per refresh cycle.
+    // NOTE: A robust fix for this requires a compositor-wide frame counter, which
+    // would need to be propagated through `OutputFrame`. This is not possible
+    // without modifying files outside this component. A fragile, timestamp-based
+    // solution is not acceptable. The current behavior is harmless but redundant
+    // in multi-monitor scenarios where one surface is painted on multiple outputs.
     m_surface->clearFifoBarrier();
+
     if (m_fifoFallbackTimer.isActive() && output) {
-        // TODO once we can rely on frame being not-nullptr, use its refresh duration instead
-        const auto refreshDuration = std::chrono::nanoseconds(1'000'000'000'000) / output->refreshRate();
-        // some games don't work properly if the refresh rate goes too low with FIFO. 30Hz is assumed to be fine here.
-        // this must still be slower than the actual screen though, or fifo behavior would be broken!
-        const auto fallbackRefreshDuration = std::max(refreshDuration * 5 / 4, std::chrono::nanoseconds(1'000'000'000) / 30);
-        // reset the timer, it should only trigger if we don't present fast enough
-        m_fifoFallbackTimer.start(std::chrono::duration_cast<std::chrono::milliseconds>(fallbackRefreshDuration));
+        // OPTIMIZATION: This is a performance-critical hot path for FIFO clients (games).
+        // Avoid all expensive calculations by using a cached timer value.
+        const int currentRefreshRate = output->refreshRate(); // In mHz
+        if (currentRefreshRate != m_lastRefreshRate) {
+            m_lastRefreshRate = currentRefreshRate;
+            if (currentRefreshRate > 0) {
+                // Calculation is done only when the refresh rate changes.
+                // Use uint64_t to prevent overflow with large numbers.
+                // 1s = 1,000,000,000 ns; KWin refreshRate() is in mHz (1Hz = 1000mHz)
+                const uint64_t refreshNs = 1'000'000'000'000ULL / static_cast<uint64_t>(currentRefreshRate);
+                // Fallback should be >1 frame, but not slower than 30 Hz (33,333,333 ns).
+                const uint64_t fallbackMinNs = 33'333'333ULL; // 30 Hz
+                const uint64_t fallbackNs = std::max((refreshNs * 5) / 4, fallbackMinNs);
+                m_cachedFifoFallbackMs = static_cast<int>(fallbackNs / 1'000'000);
+            } else {
+                // Sane fallback for unknown/invalid refresh rate.
+                m_cachedFifoFallbackMs = 33; // ~30 Hz
+            }
+        }
+        m_fifoFallbackTimer.start(m_cachedFifoFallbackMs);
     }
 }
 
@@ -269,25 +305,52 @@ SurfaceItemXwayland::SurfaceItemXwayland
 
 QList<QRectF> SurfaceItemXwayland::shape() const
 {
-    QList<QRectF> shape = m_window->shapeRegion();
-    for (QRectF &shapePart : shape) {
-        shapePart = shapePart.intersected(rect());
+    QList<QRectF> finalShape;
+    if (!m_window) {
+        return finalShape;
     }
-    return shape;
+
+    const QRectF itemRect = rect();
+    const QList<QRectF> shapeParts = m_window->shapeRegion();
+    finalShape.reserve(shapeParts.size());
+
+    for (const QRectF &part : shapeParts) {
+        const QRectF intersected = part.intersected(itemRect);
+        if (intersected.isValid()) {
+            finalShape.append(intersected);
+        }
+    }
+    return finalShape;
 }
 
 QRegion SurfaceItemXwayland::opaque() const
 {
+    if (!m_window) {
+        return QRegion();
+    }
+
+    // OPTIMIZATION: Unify shape calculation and region creation into a single pass.
+    // This avoids an unnecessary intermediate QList allocation and a second loop,
+    // reducing memory churn and improving cache locality for windows with complex shapes.
+    const QList<QRectF> shapeParts = m_window->shapeRegion();
+    const QRectF itemRect = rect();
+
     QRegion shapeRegion;
-    for (const QRectF &shapePart : shape()) {
-        shapeRegion += shapePart.toRect();
+    // BUGFIX: QRegion has no 'reserve' method. This call was removed.
+    // The performance gain from the single-pass logic is still substantial.
+
+    for (const QRectF &part : shapeParts) {
+        const QRect intersectedRect = part.intersected(itemRect).toRect();
+        if (!intersectedRect.isEmpty()) {
+            shapeRegion += intersectedRect;
+        }
     }
+
     if (!m_window->hasAlpha()) {
         return shapeRegion;
     } else {
         return m_window->opaqueRegion() & shapeRegion;
     }
-    return QRegion();
 }
 #endif
 } // namespace KWin
