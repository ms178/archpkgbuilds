--- workspacescene.h.orig	2025-10-06 18:53:00.948890020 +0200
+++ workspacescene.h	2025-10-06 19:03:34.764863993 +0200
@@ -11,6 +11,9 @@
 
 #include "scene/scene.h"
 
+#include <vector>
+#include <cstddef>
+
 namespace KWin
 {
 
@@ -22,6 +25,29 @@ class SurfaceItem;
 class WindowItem;
 class WindowPaintData;
 
+/**
+ * Main workspace scene coordinator.
+ * Manages window stacking, damage tracking, and render dispatch.
+ *
+ * CRITICAL HOT PATHS (called every frame @ 60-360 Hz):
+ * - prePaint() - Damage calculation and effect coordination
+ * - paint() - Main render dispatch
+ * - createStackingOrder() / clearStackingOrder() - Window list management (O(n))
+ * - scanoutCandidates() - Direct scanout eligibility (O(n√óm))
+ *
+ * PERFORMANCE OPTIMIZATIONS:
+ * - stacking_order: std::vector with pre-reserved capacity (avoids realloc)
+ * - phase2Data: std::vector pre-allocated to typical scene size
+ * - Tree traversals: Iterative DFS to avoid stack overhead and cache misses
+ * - Branch hints: [[likely]]/[[unlikely]] guide CPU predictor
+ * - const correctness: Enables compiler optimizations
+ *
+ * SAFETY GUARANTEES:
+ * - Depth-limited recursion (max 64 levels) prevents stack overflow
+ * - Null pointer checks on all dereferences
+ * - Type-safe casts with validation
+ * - No raw pointer ownership (RAII via smart pointers)
+ */
 class KWIN_EXPORT WorkspaceScene : public Scene
 {
     Q_OBJECT
@@ -30,6 +56,12 @@ public:
     explicit WorkspaceScene(std::unique_ptr<ItemRenderer> renderer);
     ~WorkspaceScene() override;
 
+    // Non-copyable, non-movable (contains Qt signal/slot machinery)
+    WorkspaceScene(const WorkspaceScene &) = delete;
+    WorkspaceScene &operator=(const WorkspaceScene &) = delete;
+    WorkspaceScene(WorkspaceScene &&) = delete;
+    WorkspaceScene &operator=(WorkspaceScene &&) = delete;
+
     void initialize();
 
     Item *containerItem() const;
@@ -46,9 +78,7 @@ public:
 
     /**
      * Whether the Scene is able to drive animations.
-     * This is used as a hint to the effects system which effects can be supported.
-     * If the Scene performs software rendering it is supposed to return @c false,
-     * if rendering is hardware accelerated it should return @c true.
+     * Returns false for software rendering, true for hardware acceleration.
      */
     bool animationsSupported() const;
 
@@ -59,24 +89,22 @@ Q_SIGNALS:
 protected:
     void createStackingOrder();
     void clearStackingOrder();
+
     friend class EffectsHandler;
-    // called after all effects had their paintScreen() called
+
     void finalPaintScreen(const RenderTarget &renderTarget, const RenderViewport &viewport, int mask, const QRegion &region, Output *screen);
-    // shared implementation of painting the screen in the generic
-    // (unoptimized) way
     void preparePaintGenericScreen();
     void paintGenericScreen(const RenderTarget &renderTarget, const RenderViewport &viewport, int mask, Output *screen);
-    // shared implementation of painting the screen in an optimized way
     void preparePaintSimpleScreen();
     void paintSimpleScreen(const RenderTarget &renderTarget, const RenderViewport &viewport, int mask, const QRegion &region);
-    // called after all effects had their paintWindow() called
     void finalPaintWindow(const RenderTarget &renderTarget, const RenderViewport &viewport, EffectWindow *w, int mask, const QRegion &region, WindowPaintData &data);
-    // shared implementation, starts painting the window
     void paintWindow(const RenderTarget &renderTarget, const RenderViewport &viewport, WindowItem *w, int mask, const QRegion &region);
-    // called after all effects had their drawWindow() called
     void finalDrawWindow(const RenderTarget &renderTarget, const RenderViewport &viewport, EffectWindow *w, int mask, const QRegion &region, WindowPaintData &data);
 
-    // saved data for 2nd pass of optimized screen painting
+    /**
+     * Phase2 paint data (pre-allocated to avoid per-frame heap churn).
+     * Stores per-window state for the optimized paint pass.
+     */
     struct Phase2Data
     {
         WindowItem *item = nullptr;
@@ -89,22 +117,26 @@ protected:
     {
         QRegion damage;
         int mask = 0;
-        QList<Phase2Data> phase2Data;
+        std::vector<Phase2Data> phase2Data;
     };
 
-    // The screen that is being currently painted
+    // Current output being painted
     Output *painted_screen = nullptr;
     SceneDelegate *painted_delegate = nullptr;
 
-    // windows in their stacking order
-    QList<WindowItem *> stacking_order;
+    // Windows in Z-order (bottom to top)
+    // OPTIMIZATION: std::vector provides:
+    // - Contiguous memory (better cache locality)
+    // - O(1) random access
+    // - Reserve capacity to avoid reallocation
+    // Typical size: 5-20 windows, reserved: 48 (next power-of-2 above 32)
+    std::vector<WindowItem *> stacking_order;
 
 private:
     void createDndIconItem();
     void destroyDndIconItem();
 
     std::chrono::milliseconds m_expectedPresentTimestamp = std::chrono::milliseconds::zero();
-    // how many times finalPaintScreen() has been called
     int m_paintScreenCount = 0;
     PaintContext m_paintContext;
     std::unique_ptr<Item> m_containerItem;
@@ -112,4 +144,4 @@ private:
     std::unique_ptr<DragAndDropIconItem> m_dndIcon;
 };
 
-} // namespace
+} // namespace KWin
