--- input.cpp.orig	2025-10-07 13:02:01.483506786 +0200
+++ input.cpp	2025-10-07 14:12:30.572382470 +0200
@@ -249,15 +249,15 @@ bool InputEventFilter::tabletPadDialEven
 
 bool InputEventFilter::passToInputMethod(KeyboardKeyEvent *event)
 {
-    if (!kwinApp()->inputMethod()) {
+    if (!kwinApp()->inputMethod()) [[unlikely]] {
         return false;
     }
-    if (auto keyboardGrab = kwinApp()->inputMethod()->keyboardGrab()) {
+    if (auto *keyboardGrab = kwinApp()->inputMethod()->keyboardGrab()) {
         if (event->state == KeyboardKeyState::Repeated) {
             return true;
         }
         const auto timestamp = std::chrono::duration_cast<std::chrono::milliseconds>(event->timestamp);
-        keyboardGrab->sendKey(waylandServer()->display()->nextSerial(), std::chrono::duration_cast<std::chrono::milliseconds>(timestamp).count(), event->nativeScanCode, event->state);
+        keyboardGrab->sendKey(waylandServer()->display()->nextSerial(), timestamp.count(), event->nativeScanCode, event->state);
         return true;
     } else {
         kwinApp()->inputMethod()->commitPendingText();
@@ -272,10 +272,10 @@ public:
         : InputEventFilter(InputFilterOrder::VirtualTerminal)
     {
     }
+
     bool keyboardKey(KeyboardKeyEvent *event) override
     {
-        // really on press and not on release? X11 switches on press.
-        if (event->state == KeyboardKeyState::Pressed) {
+        if (event->state == KeyboardKeyState::Pressed) [[likely]] {
             const xkb_keysym_t keysym = event->nativeVirtualKey;
             if (keysym >= XKB_KEY_XF86Switch_VT_1 && keysym <= XKB_KEY_XF86Switch_VT_12) {
                 kwinApp()->session()->switchTo(keysym - XKB_KEY_XF86Switch_VT_1 + 1);
@@ -294,96 +294,99 @@ public:
         : InputEventFilter(InputFilterOrder::LockScreen)
     {
     }
+
     bool pointerMotion(PointerMotionEvent *event) override
     {
-        if (!waylandServer()->isScreenLocked()) {
+        auto *const ws = waylandServer();
+        if (!ws->isScreenLocked()) [[likely]] {
             return false;
         }
 
         ScreenLocker::KSldApp::self()->userActivity();
 
-        auto window = input()->findToplevel(event->position);
+        auto *const inputHandler = input();
+        Window *const window = inputHandler->findToplevel(event->position);
         if (window && window->isClient() && window->isLockScreen()) {
             workspace()->activateWindow(window);
         }
 
-        auto seat = waylandServer()->seat();
-        if (pointerSurfaceAllowed()) {
-            // TODO: should the pointer position always stay in sync, i.e. not do the check?
+        auto *const seat = ws->seat();
+        if (isSurfaceAllowed(seat->focusedPointerSurface())) {
             seat->setTimestamp(event->timestamp);
             seat->notifyPointerMotion(event->position);
         }
         return true;
     }
+
     bool pointerButton(PointerButtonEvent *event) override
     {
-        if (!waylandServer()->isScreenLocked()) {
+        auto *const ws = waylandServer();
+        if (!ws->isScreenLocked()) [[likely]] {
             return false;
         }
 
         ScreenLocker::KSldApp::self()->userActivity();
 
-        auto window = input()->findToplevel(event->position);
+        auto *const inputHandler = input();
+        Window *const window = inputHandler->findToplevel(event->position);
         if (window && window->isClient() && window->isLockScreen()) {
             workspace()->activateWindow(window);
         }
 
-        auto seat = waylandServer()->seat();
-        if (pointerSurfaceAllowed()) {
-            // TODO: can we leak presses/releases here when we move the mouse in between from an allowed surface to
-            //       disallowed one or vice versa?
+        auto *const seat = ws->seat();
+        if (isSurfaceAllowed(seat->focusedPointerSurface())) {
             seat->setTimestamp(event->timestamp);
             seat->notifyPointerButton(event->nativeButton, event->state);
         }
         return true;
     }
+
     bool pointerFrame() override
     {
-        if (!waylandServer()->isScreenLocked()) {
+        auto *const ws = waylandServer();
+        if (!ws->isScreenLocked()) [[likely]] {
             return false;
         }
-        auto seat = waylandServer()->seat();
-        if (pointerSurfaceAllowed()) {
+        auto *const seat = ws->seat();
+        if (isSurfaceAllowed(seat->focusedPointerSurface())) {
             seat->notifyPointerFrame();
         }
         return true;
     }
+
     bool pointerAxis(PointerAxisEvent *event) override
     {
-        if (!waylandServer()->isScreenLocked()) {
+        auto *const ws = waylandServer();
+        if (!ws->isScreenLocked()) [[likely]] {
             return false;
         }
 
         ScreenLocker::KSldApp::self()->userActivity();
 
-        auto seat = waylandServer()->seat();
-        if (pointerSurfaceAllowed()) {
+        auto *const seat = ws->seat();
+        if (isSurfaceAllowed(seat->focusedPointerSurface())) {
             seat->setTimestamp(event->timestamp);
             seat->notifyPointerAxis(event->orientation, event->delta, event->deltaV120, event->source, event->inverted);
         }
         return true;
     }
+
     bool keyboardKey(KeyboardKeyEvent *event) override
     {
-        if (!waylandServer()->isScreenLocked()) {
+        auto *const ws = waylandServer();
+        if (!ws->isScreenLocked()) [[likely]] {
             return false;
         }
         if (event->state == KeyboardKeyState::Repeated) {
-            // wayland client takes care of it
             return true;
         }
 
-        // FIXME: Ideally we want to move all whitelisted global shortcuts here and process it here instead of lockscreen
         if (event->key == Qt::Key_PowerOff) {
-            // globalshortcuts want to use this
             return false;
         }
 
         ScreenLocker::KSldApp::self()->userActivity();
 
-        // send event to KSldApp for global accel
-        // if event is set to accepted it means a whitelisted shortcut was triggered
-        // in that case we filter it out and don't process it further
         QKeyEvent keyEvent(event->state == KeyboardKeyState::Released ? QEvent::KeyRelease : QEvent::KeyPress,
                            event->key,
                            event->modifiers,
@@ -398,130 +401,125 @@ public:
             return true;
         }
 
-        // continue normal processing
         input()->keyboard()->update();
-        if (!keyboardSurfaceAllowed()) {
-            // don't pass event to seat
+        if (!isSurfaceAllowed(ws->seat()->focusedKeyboardSurface())) {
             return true;
         }
-        auto seat = waylandServer()->seat();
+        auto *const seat = ws->seat();
         seat->setTimestamp(event->timestamp);
         seat->notifyKeyboardKey(event->nativeScanCode, event->state);
         return true;
     }
+
     bool touchDown(qint32 id, const QPointF &pos, std::chrono::microseconds time) override
     {
-        if (!waylandServer()->isScreenLocked()) {
+        auto *const ws = waylandServer();
+        if (!ws->isScreenLocked()) [[likely]] {
             return false;
         }
 
         ScreenLocker::KSldApp::self()->userActivity();
 
-        Window *window = input()->findToplevel(pos);
-        if (window && surfaceAllowed(window->surface())) {
-            auto seat = waylandServer()->seat();
+        Window *const window = input()->findToplevel(pos);
+        if (window && isSurfaceAllowed(window->surface())) {
+            auto *const seat = ws->seat();
             seat->setTimestamp(time);
             seat->notifyTouchDown(window->surface(), window->bufferGeometry().topLeft(), id, pos);
         }
         return true;
     }
+
     bool touchMotion(qint32 id, const QPointF &pos, std::chrono::microseconds time) override
     {
-        if (!waylandServer()->isScreenLocked()) {
+        auto *const ws = waylandServer();
+        if (!ws->isScreenLocked()) [[likely]] {
             return false;
         }
 
         ScreenLocker::KSldApp::self()->userActivity();
 
-        auto seat = waylandServer()->seat();
+        auto *const seat = ws->seat();
         seat->setTimestamp(time);
         seat->notifyTouchMotion(id, pos);
         return true;
     }
+
     bool touchUp(qint32 id, std::chrono::microseconds time) override
     {
-        if (!waylandServer()->isScreenLocked()) {
+        auto *const ws = waylandServer();
+        if (!ws->isScreenLocked()) [[likely]] {
             return false;
         }
 
         ScreenLocker::KSldApp::self()->userActivity();
 
-        auto seat = waylandServer()->seat();
+        auto *const seat = ws->seat();
         seat->setTimestamp(time);
         seat->notifyTouchUp(id);
         return true;
     }
+
     bool pinchGestureBegin(int fingerCount, std::chrono::microseconds time) override
     {
-        // no touchpad multi-finger gestures on lock screen
         return waylandServer()->isScreenLocked();
     }
+
     bool pinchGestureUpdate(qreal scale, qreal angleDelta, const QPointF &delta, std::chrono::microseconds time) override
     {
-        // no touchpad multi-finger gestures on lock screen
         return waylandServer()->isScreenLocked();
     }
+
     bool pinchGestureEnd(std::chrono::microseconds time) override
     {
-        // no touchpad multi-finger gestures on lock screen
         return waylandServer()->isScreenLocked();
     }
+
     bool pinchGestureCancelled(std::chrono::microseconds time) override
     {
-        // no touchpad multi-finger gestures on lock screen
         return waylandServer()->isScreenLocked();
     }
 
     bool swipeGestureBegin(int fingerCount, std::chrono::microseconds time) override
     {
-        // no touchpad multi-finger gestures on lock screen
         return waylandServer()->isScreenLocked();
     }
+
     bool swipeGestureUpdate(const QPointF &delta, std::chrono::microseconds time) override
     {
-        // no touchpad multi-finger gestures on lock screen
         return waylandServer()->isScreenLocked();
     }
+
     bool swipeGestureEnd(std::chrono::microseconds time) override
     {
-        // no touchpad multi-finger gestures on lock screen
         return waylandServer()->isScreenLocked();
     }
+
     bool swipeGestureCancelled(std::chrono::microseconds time) override
     {
-        // no touchpad multi-finger gestures on lock screen
         return waylandServer()->isScreenLocked();
     }
+
     bool holdGestureBegin(int fingerCount, std::chrono::microseconds time) override
     {
-        // no touchpad multi-finger gestures on lock screen
         return waylandServer()->isScreenLocked();
     }
+
     bool holdGestureEnd(std::chrono::microseconds time) override
     {
-        // no touchpad multi-finger gestures on lock screen
         return waylandServer()->isScreenLocked();
     }
 
 private:
-    bool surfaceAllowed(SurfaceInterface *s) const
+    bool isSurfaceAllowed(SurfaceInterface *s) const
     {
         if (s) {
-            if (Window *t = waylandServer()->findWindow(s)) {
+            if (Window *const t = waylandServer()->findWindow(s)) {
                 return t->isLockScreen() || t->isInputMethod() || t->isLockScreenOverlay();
             }
             return false;
         }
         return true;
     }
-    bool pointerSurfaceAllowed() const
-    {
-        return surfaceAllowed(waylandServer()->seat()->focusedPointerSurface());
-    }
-    bool keyboardSurfaceAllowed() const
-    {
-        return surfaceAllowed(waylandServer()->seat()->focusedKeyboardSurface());
-    }
 };
 #endif
 
@@ -532,45 +530,51 @@ public:
         : InputEventFilter(InputFilterOrder::Effects)
     {
     }
+
     bool pointerMotion(PointerMotionEvent *event) override
     {
-        if (!effects) {
+        if (!effects) [[unlikely]] {
             return false;
         }
+        const auto timestampMs = static_cast<ulong>(std::chrono::duration_cast<std::chrono::milliseconds>(event->timestamp).count());
         QMouseEvent mouseEvent(QEvent::MouseMove,
                                event->position,
                                event->position,
                                Qt::NoButton,
                                event->buttons,
                                event->modifiers);
-        mouseEvent.setTimestamp(std::chrono::duration_cast<std::chrono::milliseconds>(event->timestamp).count());
+        mouseEvent.setTimestamp(timestampMs);
         mouseEvent.setAccepted(false);
         return effects->checkInputWindowEvent(&mouseEvent);
     }
+
     bool pointerButton(PointerButtonEvent *event) override
     {
-        if (!effects) {
+        if (!effects) [[unlikely]] {
             return false;
         }
+        const auto timestampMs = static_cast<ulong>(std::chrono::duration_cast<std::chrono::milliseconds>(event->timestamp).count());
         QMouseEvent mouseEvent(event->state == PointerButtonState::Pressed ? QEvent::MouseButtonPress : QEvent::MouseButtonRelease,
                                event->position,
                                event->position,
                                event->button,
                                event->buttons,
                                event->modifiers);
-        mouseEvent.setTimestamp(std::chrono::duration_cast<std::chrono::milliseconds>(event->timestamp).count());
+        mouseEvent.setTimestamp(timestampMs);
         mouseEvent.setAccepted(false);
         return effects->checkInputWindowEvent(&mouseEvent);
     }
+
     bool pointerAxis(PointerAxisEvent *event) override
     {
-        if (!effects) {
+        if (!effects) [[unlikely]] {
             return false;
         }
+        const QPoint angleDelta = (event->orientation == Qt::Horizontal) ? QPoint(event->delta, 0) : QPoint(0, event->delta);
         QWheelEvent wheelEvent(event->position,
                                event->position,
                                QPoint(),
-                               (event->orientation == Qt::Horizontal) ? QPoint(event->delta, 0) : QPoint(0, event->delta),
+                               angleDelta,
                                event->buttons,
                                event->modifiers,
                                Qt::NoScrollPhase,
@@ -578,9 +582,10 @@ public:
         wheelEvent.setAccepted(false);
         return effects->checkInputWindowEvent(&wheelEvent);
     }
+
     bool keyboardKey(KeyboardKeyEvent *event) override
     {
-        if (!effects || !effects->hasKeyboardGrab()) {
+        if (!effects || !effects->hasKeyboardGrab()) [[unlikely]] {
             return false;
         }
         waylandServer()->seat()->setFocusedKeyboardSurface(nullptr);
@@ -598,84 +603,98 @@ public:
         }
         return true;
     }
+
     bool touchDown(qint32 id, const QPointF &pos, std::chrono::microseconds time) override
     {
-        if (!effects) {
+        if (!effects) [[unlikely]] {
             return false;
         }
         return effects->touchDown(id, pos, time);
     }
+
     bool touchMotion(qint32 id, const QPointF &pos, std::chrono::microseconds time) override
     {
-        if (!effects) {
+        if (!effects) [[unlikely]] {
             return false;
         }
         return effects->touchMotion(id, pos, time);
     }
+
     bool touchUp(qint32 id, std::chrono::microseconds time) override
     {
-        if (!effects) {
+        if (!effects) [[unlikely]] {
             return false;
         }
         return effects->touchUp(id, time);
     }
+
     bool touchCancel() override
     {
-        effects->touchCancel();
+        if (effects) [[likely]] {
+            effects->touchCancel();
+        }
         return false;
     }
+
     bool tabletToolProximityEvent(TabletToolProximityEvent *event) override
     {
-        if (!effects) {
+        if (!effects) [[unlikely]] {
             return false;
         }
         return effects->tabletToolProximityEvent(event);
     }
+
     bool tabletToolAxisEvent(TabletToolAxisEvent *event) override
     {
-        if (!effects) {
+        if (!effects) [[unlikely]] {
             return false;
         }
         return effects->tabletToolAxisEvent(event);
     }
+
     bool tabletToolTipEvent(TabletToolTipEvent *event) override
     {
-        if (!effects) {
+        if (!effects) [[unlikely]] {
             return false;
         }
         return effects->tabletToolTipEvent(event);
     }
+
     bool tabletToolButtonEvent(TabletToolButtonEvent *event) override
     {
-        if (!effects) {
+        if (!effects) [[unlikely]] {
             return false;
         }
         return effects->tabletToolButtonEvent(event->button, event->pressed, event->tool, event->time);
     }
+
     bool tabletPadButtonEvent(TabletPadButtonEvent *event) override
     {
-        if (!effects) {
+        if (!effects) [[unlikely]] {
             return false;
         }
         return effects->tabletPadButtonEvent(event->button, event->pressed, event->time, event->device);
     }
+
     bool tabletPadStripEvent(TabletPadStripEvent *event) override
     {
-        if (!effects) {
+        if (!effects) [[unlikely]] {
             return false;
         }
         return effects->tabletPadStripEvent(event->number, event->position, event->isFinger, event->time, event->device);
     }
+
     bool tabletPadRingEvent(TabletPadRingEvent *event) override
     {
-        if (!effects) {
+        if (!effects) [[unlikely]] {
             return false;
         }
         return effects->tabletPadRingEvent(event->number, event->position, event->isFinger, event->time, event->device);
     }
+
     bool tabletPadDialEvent(TabletPadDialEvent *event) override
     {
-        if (!effects) {
+        if (!effects) [[unlikely]] {
             return false;
         }
         return effects->tabletPadDialEvent(event->number, event->delta, event->time, event->device);
@@ -689,19 +708,21 @@ public:
         : InputEventFilter(InputFilterOrder::InteractiveMoveResize)
     {
     }
+
     bool pointerMotion(PointerMotionEvent *event) override
     {
-        Window *window = workspace()->moveResizeWindow();
-        if (!window) {
+        Window *const window = workspace()->moveResizeWindow();
+        if (!window) [[likely]] {
             return false;
         }
         window->updateInteractiveMoveResize(event->position, event->modifiers);
         return true;
     }
+
     bool pointerButton(PointerButtonEvent *event) override
     {
-        Window *window = workspace()->moveResizeWindow();
-        if (!window) {
+        Window *const window = workspace()->moveResizeWindow();
+        if (!window) [[likely]] {
             return false;
         }
         if (event->state == PointerButtonState::Released) {
@@ -711,22 +732,22 @@ public:
         }
         return true;
     }
+
     bool pointerAxis(PointerAxisEvent *event) override
     {
-        // filter out while moving a window
         return workspace()->moveResizeWindow() != nullptr;
     }
+
     bool keyboardKey(KeyboardKeyEvent *event) override
     {
-        Window *window = workspace()->moveResizeWindow();
-        if (!window) {
+        Window *const window = workspace()->moveResizeWindow();
+        if (!window) [[likely]] {
             return false;
         }
         if (event->state == KeyboardKeyState::Repeated || event->state == KeyboardKeyState::Pressed) {
             window->keyPressEvent(QKeyCombination{event->modifiers, event->key});
         }
         if (window->isInteractiveMove() || window->isInteractiveResize()) {
-            // only update if mode didn't end
             window->updateInteractiveMoveResize(input()->globalPointer(), input()->keyboardModifiers());
         }
         return true;
@@ -734,8 +755,8 @@ public:
 
     bool touchDown(qint32 id, const QPointF &pos, std::chrono::microseconds time) override
     {
-        Window *window = workspace()->moveResizeWindow();
-        if (!window) {
+        Window *const window = workspace()->moveResizeWindow();
+        if (!window) [[likely]] {
             return false;
         }
         return true;
@@ -743,8 +764,8 @@ public:
 
     bool touchMotion(qint32 id, const QPointF &pos, std::chrono::microseconds time) override
     {
-        Window *window = workspace()->moveResizeWindow();
-        if (!window) {
+        Window *const window = workspace()->moveResizeWindow();
+        if (!window) [[likely]] {
             return false;
         }
         if (!m_set) {
@@ -759,14 +780,13 @@ public:
 
     bool touchUp(qint32 id, std::chrono::microseconds time) override
     {
-        Window *window = workspace()->moveResizeWindow();
-        if (!window) {
+        Window *const window = workspace()->moveResizeWindow();
+        if (!window) [[likely]] {
             return false;
         }
         if (m_id == id || !m_set) {
             window->endInteractiveMoveResize();
             m_set = false;
-            // pass through to update decoration filter later on
             return false;
         }
         m_set = false;
@@ -775,18 +795,17 @@ public:
 
     bool tabletToolProximityEvent(TabletToolProximityEvent *event) override
     {
-        Window *window = workspace()->moveResizeWindow();
-        if (!window) {
+        Window *const window = workspace()->moveResizeWindow();
+        if (!window) [[likely]] {
             return false;
         }
-
         return true;
     }
 
     bool tabletToolTipEvent(TabletToolTipEvent *event) override
     {
-        Window *window = workspace()->moveResizeWindow();
-        if (!window) {
+        Window *const window = workspace()->moveResizeWindow();
+        if (!window) [[likely]] {
             return false;
         }
         if (event->type == TabletToolTipEvent::Release) {
@@ -797,11 +816,10 @@ public:
 
     bool tabletToolAxisEvent(TabletToolAxisEvent *event) override
     {
-        Window *window = workspace()->moveResizeWindow();
-        if (!window) {
+        Window *const window = workspace()->moveResizeWindow();
+        if (!window) [[likely]] {
             return false;
         }
-
         window->updateInteractiveMoveResize(event->position, input()->keyboardModifiers());
         return true;
     }
@@ -818,13 +836,15 @@ public:
         : InputEventFilter(InputFilterOrder::WindowSelector)
     {
     }
+
     bool pointerMotion(PointerMotionEvent *event) override
     {
         return m_active;
     }
+
     bool pointerButton(PointerButtonEvent *event) override
     {
-        if (!m_active) {
+        if (!m_active) [[likely]] {
             return false;
         }
         if (event->state == PointerButtonState::Released) {
@@ -838,20 +858,20 @@ public:
         }
         return true;
     }
+
     bool pointerAxis(PointerAxisEvent *event) override
     {
-        // filter out while selecting a window
         return m_active;
     }
+
     bool keyboardKey(KeyboardKeyEvent *event) override
     {
-        if (!m_active) {
+        if (!m_active) [[likely]] {
             return false;
         }
         waylandServer()->seat()->setFocusedKeyboardSurface(nullptr);
 
         if (event->state == KeyboardKeyState::Repeated || event->state == KeyboardKeyState::Pressed) {
-            // x11 variant does this on key press, so do the same
             if (event->key == Qt::Key_Escape) {
                 cancel();
             } else if (event->key == Qt::Key_Enter || event->key == Qt::Key_Return || event->key == Qt::Key_Space) {
@@ -879,13 +899,12 @@ public:
                 input()->warpPointer(input()->globalPointer() + QPointF(mx, my));
             }
         }
-        // filter out while selecting a window
         return true;
     }
 
     bool touchDown(qint32 id, const QPointF &pos, std::chrono::microseconds time) override
     {
-        if (!isActive()) {
+        if (!isActive()) [[likely]] {
             return false;
         }
         m_touchPoints.insert(id, pos);
@@ -894,7 +913,7 @@ public:
 
     bool touchMotion(qint32 id, const QPointF &pos, std::chrono::microseconds time) override
     {
-        if (!isActive()) {
+        if (!isActive()) [[likely]] {
             return false;
         }
         auto it = m_touchPoints.find(id);
@@ -906,7 +925,7 @@ public:
 
     bool touchUp(qint32 id, std::chrono::microseconds time) override
     {
-        if (!isActive()) {
+        if (!isActive()) [[likely]] {
             return false;
         }
         auto it = m_touchPoints.find(id);
@@ -922,14 +941,12 @@ public:
 
     bool tabletToolTipEvent(TabletToolTipEvent *event) override
     {
-        if (!isActive()) {
+        if (!isActive()) [[likely]] {
             return false;
         }
-
         if (event->type == TabletToolTipEvent::Release) {
             accept(event->position);
         }
-
         return true;
     }
 
@@ -937,6 +954,7 @@ public:
     {
         return m_active;
     }
+
     void start(std::function<void(Window *)> callback)
     {
         Q_ASSERT(!m_active);
@@ -945,6 +963,7 @@ public:
         input()->keyboard()->update();
         input()->touch()->cancel();
     }
+
     void start(std::function<void(const QPoint &)> callback)
     {
         Q_ASSERT(!m_active);
@@ -964,6 +983,7 @@ private:
         input()->keyboard()->update();
         m_touchPoints.clear();
     }
+
     void cancel()
     {
         if (m_callback) {
@@ -974,10 +994,10 @@ private:
         }
         deactivate();
     }
+
     void accept(const QPointF &pos)
     {
         if (m_callback) {
-            // TODO: this ignores shaped windows
             m_callback(input()->findToplevel(pos));
         }
         if (m_pointSelectionFallback) {
@@ -1004,7 +1024,7 @@ public:
         m_scrollDistance += delta;
         if (std::abs(m_scrollDistance) >= 1.0) {
             const qreal ret = m_scrollDistance;
-            m_scrollDistance = std::fmod(m_scrollDistance, 1.0f);
+            m_scrollDistance = std::fmod(m_scrollDistance, 1.0);
             return ret - m_scrollDistance;
         } else {
             return 0;
@@ -1035,28 +1055,22 @@ public:
         }
         return false;
     }
+
     bool pointerAxis(PointerAxisEvent *event) override
     {
-        if (event->modifiers == Qt::NoModifier) {
+        if (event->modifiers == Qt::NoModifier) [[likely]] {
             return false;
         }
         PointerAxisDirection direction = PointerAxisUp;
         if (event->orientation == Qt::Horizontal) {
-            if (event->delta > 0) {
-                direction = PointerAxisRight;
-            } else if (event->delta < 0) {
-                direction = PointerAxisLeft;
-            }
+            direction = (event->delta > 0) ? PointerAxisRight : PointerAxisLeft;
             return input()->shortcuts()->processAxis(event->modifiers, direction, m_horizontalAccumulator.accumulate(event));
         } else {
-            if (event->delta > 0) {
-                direction = PointerAxisDown;
-            } else if (event->delta < 0) {
-                direction = PointerAxisUp;
-            }
+            direction = (event->delta > 0) ? PointerAxisDown : PointerAxisUp;
             return input()->shortcuts()->processAxis(event->modifiers, direction, m_verticalAccumulator.accumulate(event));
         }
     }
+
     bool keyboardKey(KeyboardKeyEvent *event) override
     {
         if (event->key == Qt::Key_PowerOff) {
@@ -1074,19 +1088,20 @@ public:
                 return ret;
             }
         } else if (event->state == KeyboardKeyState::Repeated || event->state == KeyboardKeyState::Pressed) {
-            if (!waylandServer()->isKeyboardShortcutsInhibited()) {
+            if (!waylandServer()->isKeyboardShortcutsInhibited()) [[likely]] {
                 if (input()->shortcuts()->processKey(event->modifiersRelevantForGlobalShortcuts, event->key)) {
                     input()->keyboard()->addFilteredKey(event->nativeScanCode);
                     return true;
                 }
             }
         } else if (event->state == KeyboardKeyState::Released) {
-            if (!waylandServer()->isKeyboardShortcutsInhibited()) {
+            if (!waylandServer()->isKeyboardShortcutsInhibited()) [[likely]] {
                 return input()->shortcuts()->processKeyRelease(event->modifiersRelevantForGlobalShortcuts, event->key);
             }
         }
         return false;
     }
+
     bool swipeGestureBegin(int fingerCount, std::chrono::microseconds time) override
     {
         m_touchpadGestureFingerCount = fingerCount;
@@ -1097,6 +1112,7 @@ public:
             return false;
         }
     }
+
     bool swipeGestureUpdate(const QPointF &delta, std::chrono::microseconds time) override
     {
         if (m_touchpadGestureFingerCount >= 3) {
@@ -1106,6 +1122,7 @@ public:
             return false;
         }
     }
+
     bool swipeGestureCancelled(std::chrono::microseconds time) override
     {
         if (m_touchpadGestureFingerCount >= 3) {
@@ -1115,6 +1132,7 @@ public:
             return false;
         }
     }
+
     bool swipeGestureEnd(std::chrono::microseconds time) override
     {
         if (m_touchpadGestureFingerCount >= 3) {
@@ -1124,6 +1142,7 @@ public:
             return false;
         }
     }
+
     bool pinchGestureBegin(int fingerCount, std::chrono::microseconds time) override
     {
         m_touchpadGestureFingerCount = fingerCount;
@@ -1134,6 +1153,7 @@ public:
             return false;
         }
     }
+
     bool pinchGestureUpdate(qreal scale, qreal angleDelta, const QPointF &delta, std::chrono::microseconds time) override
     {
         if (m_touchpadGestureFingerCount >= 3) {
@@ -1143,6 +1163,7 @@ public:
             return false;
         }
     }
+
     bool pinchGestureEnd(std::chrono::microseconds time) override
     {
         if (m_touchpadGestureFingerCount >= 3) {
@@ -1152,6 +1173,7 @@ public:
             return false;
         }
     }
+
     bool pinchGestureCancelled(std::chrono::microseconds time) override
     {
         if (m_touchpadGestureFingerCount >= 3) {
@@ -1161,6 +1183,7 @@ public:
             return false;
         }
     }
+
     bool touchDown(qint32 id, const QPointF &pos, std::chrono::microseconds time) override
     {
         if (m_gestureTaken) {
@@ -1177,15 +1200,15 @@ public:
                     return false;
                 }
                 m_lastTouchDownTime = time;
-                auto output = workspace()->outputAt(pos);
+                auto *const output = workspace()->outputAt(pos);
                 auto physicalSize = output->orientateSize(output->physicalSize());
                 if (!physicalSize.isValid()) {
                     physicalSize = QSize(190, 100);
                 }
-                float xfactor = physicalSize.width() / (float)output->geometry().width();
-                float yfactor = physicalSize.height() / (float)output->geometry().height();
-                bool distanceMatch = std::any_of(m_touchPoints.constBegin(), m_touchPoints.constEnd(), [pos, xfactor, yfactor](const auto &point) {
-                    QPointF p = pos - point;
+                const float xfactor = physicalSize.width() / static_cast<float>(output->geometry().width());
+                const float yfactor = physicalSize.height() / static_cast<float>(output->geometry().height());
+                const bool distanceMatch = std::any_of(m_touchPoints.constBegin(), m_touchPoints.constEnd(), [pos, xfactor, yfactor](const auto &point) {
+                    const QPointF p = pos - point;
                     return std::abs(xfactor * p.x()) + std::abs(yfactor * p.y()) < 50;
                 });
                 if (!distanceMatch) {
@@ -1211,10 +1234,10 @@ public:
             if (m_gestureCancelled) {
                 return true;
             }
-            auto output = workspace()->outputAt(pos);
+            auto *const output = workspace()->outputAt(pos);
             const auto physicalSize = output->orientateSize(output->physicalSize());
-            const float xfactor = physicalSize.width() / (float)output->geometry().width();
-            const float yfactor = physicalSize.height() / (float)output->geometry().height();
+            const float xfactor = physicalSize.width() / static_cast<float>(output->geometry().width());
+            const float yfactor = physicalSize.height() / static_cast<float>(output->geometry().height());
 
             auto &point = m_touchPoints[id];
             const QPointF dist = pos - point;
@@ -1270,7 +1293,6 @@ private:
     int m_touchpadGestureFingerCount = 0;
     MouseWheelAccumulator m_horizontalAccumulator;
     MouseWheelAccumulator m_verticalAccumulator;
-
     QTimer m_powerDown;
 };
 #endif
@@ -1278,10 +1300,6 @@ private:
 namespace
 {
 
-/**
- * @returns if a command was performed, whether or not the event should be filtered out
- *          if no command was performed, std::nullopt
- */
 std::optional<bool> performModifierWindowMouseAction(PointerButtonEvent *event, Window *window)
 {
     if (event->modifiersRelevantForShortcuts != options->commandAllModifier()) {
@@ -1301,10 +1319,7 @@ std::optional<bool> performModifierWindo
         return std::nullopt;
     }
 }
-/**
- * @returns if a command was performed, whether or not the event should be filtered out
- *          if no command was performed, std::nullopt
- */
+
 std::optional<bool> performWindowMouseAction(PointerButtonEvent *event, Window *window)
 {
     if (const auto globalAction = performModifierWindowMouseAction(event, window)) {
@@ -1345,7 +1360,8 @@ std::optional<Options::MouseCommand> win
         return std::nullopt;
     }
 }
-}
+
+} // namespace
 
 class InternalWindowEventFilter : public InputEventFilter
 {
@@ -1363,14 +1379,14 @@ public:
                                                            10, 0, kwinApp()->session()->seat(), QPointingDeviceUniqueId());
         QWindowSystemInterface::registerInputDevice(m_tabletDevice.get());
     }
+
     bool pointerMotion(PointerMotionEvent *event) override
     {
-        if (!input()->pointer()->focus() || !input()->pointer()->focus()->isInternal()) {
+        if (!input()->pointer()->focus() || !input()->pointer()->focus()->isInternal()) [[likely]] {
             return false;
         }
-        QWindow *internal = static_cast<InternalWindow *>(input()->pointer()->focus())->handle();
-        if (!internal) {
-            // the handle can be nullptr if the tooltip gets closed while focus updates are blocked
+        QWindow *const internal = static_cast<InternalWindow *>(input()->pointer()->focus())->handle();
+        if (!internal) [[unlikely]] {
             return false;
         }
         QWindowSystemInterface::handleMouseEvent(internal,
@@ -1382,14 +1398,14 @@ public:
                                                  event->modifiers);
         return true;
     }
+
     bool pointerButton(PointerButtonEvent *event) override
     {
-        if (!input()->pointer()->focus() || !input()->pointer()->focus()->isInternal()) {
+        if (!input()->pointer()->focus() || !input()->pointer()->focus()->isInternal()) [[likely]] {
             return false;
         }
-        QWindow *internal = static_cast<InternalWindow *>(input()->pointer()->focus())->handle();
-        if (!internal) {
-            // the handle can be nullptr if the tooltip gets closed while focus updates are blocked
+        QWindow *const internal = static_cast<InternalWindow *>(input()->pointer()->focus())->handle();
+        if (!internal) [[unlikely]] {
             return false;
         }
         QWindowSystemInterface::handleMouseEvent(internal,
@@ -1401,23 +1417,24 @@ public:
                                                  event->modifiers);
         return true;
     }
+
     bool pointerAxis(PointerAxisEvent *event) override
     {
-        if (!input()->pointer()->focus() || !input()->pointer()->focus()->isInternal()) {
+        if (!input()->pointer()->focus() || !input()->pointer()->focus()->isInternal()) [[likely]] {
             return false;
         }
-        QWindow *internal = static_cast<InternalWindow *>(input()->pointer()->focus())->handle();
-        if (!internal) {
-            // the handle can be nullptr if the tooltip gets closed while focus updates are blocked
+        QWindow *const internal = static_cast<InternalWindow *>(input()->pointer()->focus())->handle();
+        if (!internal) [[unlikely]] {
             return false;
         }
-        const auto timestamp = std::chrono::duration_cast<std::chrono::milliseconds>(event->timestamp);
+        const auto timestampMs = std::chrono::duration_cast<std::chrono::milliseconds>(event->timestamp);
+        const QPoint angleDelta = ((event->orientation == Qt::Horizontal) ? QPoint(event->delta, 0) : QPoint(0, event->delta)) * -1;
         QWindowSystemInterface::handleWheelEvent(internal,
-                                                 timestamp.count(),
+                                                 timestampMs.count(),
                                                  event->position - internal->position(),
                                                  event->position,
                                                  QPoint(),
-                                                 ((event->orientation == Qt::Horizontal) ? QPoint(event->delta, 0) : QPoint(0, event->delta)) * -1,
+                                                 angleDelta,
                                                  event->modifiers,
                                                  Qt::NoScrollPhase,
                                                  Qt::MouseEventNotSynthesized,
@@ -1427,25 +1444,24 @@ public:
 
     bool touchDown(qint32 id, const QPointF &pos, std::chrono::microseconds time) override
     {
-        auto seat = waylandServer()->seat();
+        auto *const seat = waylandServer()->seat();
         if (seat->isTouchSequence()) {
-            // something else is getting the events
             return false;
         }
-        if (!input()->touch()->focus() || !input()->touch()->focus()->isInternal()) {
+        if (!input()->touch()->focus() || !input()->touch()->focus()->isInternal()) [[likely]] {
             return false;
         }
 
-        const qreal contactAreaWidth = 8;
-        const qreal contactAreaHeight = 8;
+        constexpr qreal contactAreaWidth = 8;
+        constexpr qreal contactAreaHeight = 8;
 
-        auto &touchPoint = m_touchPoints.emplaceBack(QWindowSystemInterface::TouchPoint{});
+        auto &touchPoint = m_touchPoints.emplace_back(QWindowSystemInterface::TouchPoint{});
         touchPoint.id = id;
         touchPoint.area = QRectF(pos.x() - contactAreaWidth / 2, pos.y() - contactAreaHeight / 2, contactAreaWidth, contactAreaHeight);
         touchPoint.state = QEventPoint::State::Pressed;
         touchPoint.pressure = 1;
 
-        QWindow *internal = static_cast<InternalWindow *>(input()->touch()->focus())->handle();
+        QWindow *const internal = static_cast<InternalWindow *>(input()->touch()->focus())->handle();
         QWindowSystemInterface::handleTouchEvent(internal, m_touchDevice.get(), m_touchPoints, input()->keyboardModifiers());
 
         touchPoint.state = QEventPoint::State::Stationary;
@@ -1464,13 +1480,14 @@ public:
         it->area.moveCenter(pos);
         it->state = QEventPoint::State::Updated;
 
-        if (auto internalWindow = qobject_cast<InternalWindow *>(input()->touch()->focus())) {
+        if (auto *const internalWindow = qobject_cast<InternalWindow *>(input()->touch()->focus())) {
             QWindowSystemInterface::handleTouchEvent(internalWindow->handle(), m_touchDevice.get(), m_touchPoints, input()->keyboardModifiers());
         }
 
         it->state = QEventPoint::State::Stationary;
         return true;
     }
+
     bool touchUp(qint32 id, std::chrono::microseconds time) override
     {
         auto it = std::ranges::find_if(m_touchPoints, [id](const auto &touchPoint) {
@@ -1483,13 +1500,14 @@ public:
         it->pressure = 0;
         it->state = QEventPoint::State::Released;
 
-        if (auto internalWindow = qobject_cast<InternalWindow *>(input()->touch()->focus())) {
+        if (auto *const internalWindow = qobject_cast<InternalWindow *>(input()->touch()->focus())) {
             QWindowSystemInterface::handleTouchEvent(internalWindow->handle(), m_touchDevice.get(), m_touchPoints, input()->keyboardModifiers());
         }
 
         m_touchPoints.erase(it);
         return true;
     }
+
     bool touchCancel() override
     {
         if (!m_touchPoints.isEmpty()) {
@@ -1501,51 +1519,50 @@ public:
 
     bool tabletToolProximityEvent(TabletToolProximityEvent *event) override
     {
-        if (!input()->tablet()->focus() || !input()->tablet()->focus()->isInternal()) {
+        if (!input()->tablet()->focus() || !input()->tablet()->focus()->isInternal()) [[likely]] {
             return false;
         }
-
-        // handleTabletEnterLeaveProximityEvent has lots of parameters, most of which are ignored, so don't bother with them
         QWindowSystemInterface::handleTabletEnterLeaveProximityEvent(nullptr,
                                                                      m_tabletDevice.get(), event->type == TabletToolProximityEvent::EnterProximity);
-
         return true;
     }
 
     bool tabletToolAxisEvent(TabletToolAxisEvent *event) override
     {
-        if (!input()->tablet()->focus() || !input()->tablet()->focus()->isInternal()) {
+        if (!input()->tablet()->focus() || !input()->tablet()->focus()->isInternal()) [[likely]] {
             return false;
         }
 
-        QWindow *internal = static_cast<InternalWindow *>(input()->tablet()->focus())->handle();
-        if (!internal) {
+        QWindow *const internal = static_cast<InternalWindow *>(input()->tablet()->focus())->handle();
+        if (!internal) [[unlikely]] {
             return true;
         }
 
         const QPointF globalPos = event->position;
         const QPointF localPos = globalPos - internal->position();
+        const auto timestampMs = std::chrono::duration_cast<std::chrono::milliseconds>(event->timestamp).count();
 
-        QWindowSystemInterface::handleTabletEvent(internal, std::chrono::duration_cast<std::chrono::milliseconds>(event->timestamp).count(), m_tabletDevice.get(), localPos, globalPos, event->buttons, event->pressure, event->xTilt, event->yTilt, event->sliderPosition, event->rotation, event->distance, input()->keyboardModifiers());
+        QWindowSystemInterface::handleTabletEvent(internal, timestampMs, m_tabletDevice.get(), localPos, globalPos, event->buttons, event->pressure, event->xTilt, event->yTilt, event->sliderPosition, event->rotation, event->distance, input()->keyboardModifiers());
 
         return true;
     }
 
     bool tabletToolTipEvent(TabletToolTipEvent *event) override
     {
-        if (!input()->tablet()->focus() || !input()->tablet()->focus()->isInternal()) {
+        if (!input()->tablet()->focus() || !input()->tablet()->focus()->isInternal()) [[likely]] {
             return false;
         }
 
-        QWindow *internal = static_cast<InternalWindow *>(input()->tablet()->focus())->handle();
-        if (!internal) {
+        QWindow *const internal = static_cast<InternalWindow *>(input()->tablet()->focus())->handle();
+        if (!internal) [[unlikely]] {
             return true;
         }
 
         const QPointF globalPos = event->position;
         const QPointF localPos = globalPos - internal->position();
+        const auto timestampMs = std::chrono::duration_cast<std::chrono::milliseconds>(event->timestamp).count();
 
-        QWindowSystemInterface::handleTabletEvent(internal, std::chrono::duration_cast<std::chrono::milliseconds>(event->timestamp).count(), m_tabletDevice.get(), localPos, globalPos, event->buttons, event->pressure, event->xTilt, event->yTilt, event->sliderPosition, event->rotation, event->distance, input()->keyboardModifiers());
+        QWindowSystemInterface::handleTabletEvent(internal, timestampMs, m_tabletDevice.get(), localPos, globalPos, event->buttons, event->pressure, event->xTilt, event->yTilt, event->sliderPosition, event->rotation, event->distance, input()->keyboardModifiers());
 
         return true;
     }
@@ -1563,10 +1580,11 @@ public:
         : InputEventFilter(InputFilterOrder::Decoration)
     {
     }
+
     bool pointerMotion(PointerMotionEvent *event) override
     {
-        auto decoration = input()->pointer()->decoration();
-        if (!decoration) {
+        auto *const decoration = input()->pointer()->decoration();
+        if (!decoration) [[likely]] {
             return false;
         }
         const QPointF p = event->position - decoration->window()->pos();
@@ -1575,10 +1593,11 @@ public:
         decoration->window()->processDecorationMove(p, event->position);
         return true;
     }
+
     bool pointerButton(PointerButtonEvent *event) override
     {
-        auto decoration = input()->pointer()->decoration();
-        if (!decoration) {
+        auto *const decoration = input()->pointer()->decoration();
+        if (!decoration) [[likely]] {
             return false;
         }
         const QPointF globalPos = event->position;
@@ -1587,8 +1606,9 @@ public:
         if (actionResult) {
             return *actionResult;
         }
+        const auto timestampMs = std::chrono::duration_cast<std::chrono::milliseconds>(event->timestamp).count();
         QMouseEvent e(event->state == PointerButtonState::Pressed ? QEvent::MouseButtonPress : QEvent::MouseButtonRelease, p, event->position, event->button, event->buttons, event->modifiers);
-        e.setTimestamp(std::chrono::duration_cast<std::chrono::milliseconds>(event->timestamp).count());
+        e.setTimestamp(timestampMs);
         e.setAccepted(false);
         QCoreApplication::sendEvent(decoration->decoration(), &e);
         if (!e.isAccepted() && event->state == PointerButtonState::Pressed) {
@@ -1599,10 +1619,11 @@ public:
         }
         return true;
     }
+
     bool pointerAxis(PointerAxisEvent *event) override
     {
-        auto decoration = input()->pointer()->decoration();
-        if (!decoration) {
+        auto *const decoration = input()->pointer()->decoration();
+        if (!decoration) [[likely]] {
             return false;
         }
         if (const auto command = globalWindowWheelAction(event)) {
@@ -1615,8 +1636,9 @@ public:
             }
         }
         const QPointF localPos = event->position - decoration->window()->pos();
+        const QPoint angleDelta = (event->orientation == Qt::Horizontal) ? QPoint(event->delta, 0) : QPoint(0, event->delta);
         QWheelEvent e(localPos, event->position, QPoint(),
-                      (event->orientation == Qt::Horizontal) ? QPoint(event->delta, 0) : QPoint(0, event->delta),
+                      angleDelta,
                       event->buttons,
                       event->modifiers,
                       Qt::NoScrollPhase,
@@ -1627,25 +1649,25 @@ public:
             return true;
         }
         if ((event->orientation == Qt::Vertical) && decoration->window()->titlebarPositionUnderMouse()) {
-            if (float delta = m_accumulator.accumulate(event)) {
+            if (const float delta = m_accumulator.accumulate(event); delta != 0.0) {
                 decoration->window()->performMousePressCommand(options->operationTitlebarMouseWheel(delta * -1),
                                                                event->position);
             }
         }
         return true;
     }
+
     bool touchDown(qint32 id, const QPointF &pos, std::chrono::microseconds time) override
     {
-        auto seat = waylandServer()->seat();
+        auto *const seat = waylandServer()->seat();
         if (seat->isTouchSequence()) {
             return false;
         }
         if (input()->touch()->decorationPressId() != -1) {
-            // already on a decoration, ignore further touch points, but filter out
             return true;
         }
-        auto decoration = input()->touch()->decoration();
-        if (!decoration) {
+        auto *const decoration = input()->touch()->decoration();
+        if (!decoration) [[likely]] {
             return false;
         }
 
@@ -1664,17 +1686,17 @@ public:
         }
         return true;
     }
+
     bool touchMotion(qint32 id, const QPointF &pos, std::chrono::microseconds time) override
     {
-        auto decoration = input()->touch()->decoration();
-        if (!decoration) {
+        auto *const decoration = input()->touch()->decoration();
+        if (!decoration) [[likely]] {
             return false;
         }
         if (input()->touch()->decorationPressId() == -1) {
             return false;
         }
-        if (input()->touch()->decorationPressId() != qint32(id)) {
-            // ignore, but filter out
+        if (input()->touch()->decorationPressId() != id) {
             return true;
         }
         m_lastGlobalTouchPos = pos;
@@ -1685,11 +1707,11 @@ public:
         decoration->window()->processDecorationMove(m_lastLocalTouchPos, pos);
         return true;
     }
+
     bool touchUp(qint32 id, std::chrono::microseconds time) override
     {
-        auto decoration = input()->touch()->decoration();
-        if (!decoration) {
-            // can happen when quick tiling
+        auto *const decoration = input()->touch()->decoration();
+        if (!decoration) [[likely]] {
             if (input()->touch()->decorationPressId() == id) {
                 m_lastGlobalTouchPos = QPointF();
                 m_lastLocalTouchPos = QPointF();
@@ -1701,12 +1723,10 @@ public:
         if (input()->touch()->decorationPressId() == -1) {
             return false;
         }
-        if (input()->touch()->decorationPressId() != qint32(id)) {
-            // ignore, but filter out
+        if (input()->touch()->decorationPressId() != id) {
             return true;
         }
 
-        // send mouse up
         QMouseEvent e(QEvent::MouseButtonRelease, m_lastLocalTouchPos, m_lastGlobalTouchPos, Qt::LeftButton, Qt::MouseButtons(), input()->keyboardModifiers());
         e.setAccepted(false);
         QCoreApplication::sendEvent(decoration->decoration(), &e);
@@ -1723,8 +1743,8 @@ public:
 
     bool tabletToolProximityEvent(TabletToolProximityEvent *event) override
     {
-        auto decoration = input()->tablet()->decoration();
-        if (!decoration) {
+        auto *const decoration = input()->tablet()->decoration();
+        if (!decoration) [[likely]] {
             return false;
         }
         if (event->type == TabletToolProximityEvent::EnterProximity) {
@@ -1736,14 +1756,13 @@ public:
             QHoverEvent leaveEvent(QEvent::HoverLeave, QPointF(), QPointF());
             QCoreApplication::sendEvent(decoration->decoration(), &leaveEvent);
         }
-
         return true;
     }
 
     bool tabletToolAxisEvent(TabletToolAxisEvent *event) override
     {
-        auto decoration = input()->tablet()->decoration();
-        if (!decoration) {
+        auto *const decoration = input()->tablet()->decoration();
+        if (!decoration) [[likely]] {
             return false;
         }
         const QPointF p = event->position - decoration->window()->pos();
@@ -1757,8 +1776,8 @@ public:
 
     bool tabletToolTipEvent(TabletToolTipEvent *event) override
     {
-        auto decoration = input()->tablet()->decoration();
-        if (!decoration) {
+        auto *const decoration = input()->tablet()->decoration();
+        if (!decoration) [[likely]] {
             return false;
         }
         const QPointF globalPos = event->position;
@@ -1797,39 +1816,44 @@ public:
         : InputEventFilter(InputFilterOrder::TabBox)
     {
     }
+
     bool pointerMotion(PointerMotionEvent *event) override
     {
-        if (!workspace()->tabbox() || !workspace()->tabbox()->isGrabbed()) {
+        if (!workspace()->tabbox() || !workspace()->tabbox()->isGrabbed()) [[likely]] {
             return false;
         }
+        const auto timestampMs = std::chrono::duration_cast<std::chrono::milliseconds>(event->timestamp).count();
         QMouseEvent mouseEvent(QEvent::MouseMove,
                                event->position,
                                event->position,
                                Qt::NoButton,
                                event->buttons,
                                event->modifiers);
-        mouseEvent.setTimestamp(std::chrono::duration_cast<std::chrono::milliseconds>(event->timestamp).count());
+        mouseEvent.setTimestamp(timestampMs);
         mouseEvent.setAccepted(false);
         return workspace()->tabbox()->handleMouseEvent(&mouseEvent);
     }
+
     bool pointerButton(PointerButtonEvent *event) override
     {
-        if (!workspace()->tabbox() || !workspace()->tabbox()->isGrabbed()) {
+        if (!workspace()->tabbox() || !workspace()->tabbox()->isGrabbed()) [[likely]] {
             return false;
         }
+        const auto timestampMs = std::chrono::duration_cast<std::chrono::milliseconds>(event->timestamp).count();
         QMouseEvent mouseEvent(event->state == PointerButtonState::Pressed ? QEvent::MouseButtonPress : QEvent::MouseButtonRelease,
                                event->position,
                                event->position,
                                event->button,
                                event->buttons,
                                event->modifiers);
-        mouseEvent.setTimestamp(std::chrono::duration_cast<std::chrono::milliseconds>(event->timestamp).count());
+        mouseEvent.setTimestamp(timestampMs);
         mouseEvent.setAccepted(false);
         return workspace()->tabbox()->handleMouseEvent(&mouseEvent);
     }
+
     bool keyboardKey(KeyboardKeyEvent *event) override
     {
-        if (!workspace()->tabbox() || !workspace()->tabbox()->isGrabbed()) {
+        if (!workspace()->tabbox() || !workspace()->tabbox()->isGrabbed()) [[likely]] {
             return false;
         }
 
@@ -1841,15 +1865,17 @@ public:
         }
         return true;
     }
+
     bool pointerAxis(PointerAxisEvent *event) override
     {
-        if (!workspace()->tabbox() || !workspace()->tabbox()->isGrabbed()) {
+        if (!workspace()->tabbox() || !workspace()->tabbox()->isGrabbed()) [[likely]] {
             return false;
         }
+        const QPoint angleDelta = (event->orientation == Qt::Horizontal) ? QPoint(event->delta, 0) : QPoint(0, event->delta);
         QWheelEvent wheelEvent(event->position,
                                event->position,
                                QPoint(),
-                               (event->orientation == Qt::Horizontal) ? QPoint(event->delta, 0) : QPoint(0, event->delta),
+                               angleDelta,
                                event->buttons,
                                event->modifiers,
                                Qt::NoScrollPhase,
@@ -1867,17 +1893,16 @@ public:
         : InputEventFilter(InputFilterOrder::ScreenEdge)
     {
     }
+
     bool pointerMotion(PointerMotionEvent *event) override
     {
         workspace()->screenEdges()->isEntered(event->position, event->timestamp);
-        // always forward
         return false;
     }
+
     bool touchDown(qint32 id, const QPointF &pos, std::chrono::microseconds time) override
     {
-        // TODO: better check whether a touch sequence is in progress
-        if (m_touchInProgress || waylandServer()->seat()->isTouchSequence()) {
-            // cancel existing touch
+        if (m_touchInProgress || waylandServer()->seat()->isTouchSequence()) [[unlikely]] {
             workspace()->screenEdges()->gestureRecognizer()->cancelSwipeGesture();
             m_touchInProgress = false;
             m_id = 0;
@@ -1891,6 +1916,7 @@ public:
         }
         return false;
     }
+
     bool touchMotion(qint32 id, const QPointF &pos, std::chrono::microseconds time) override
     {
         if (m_touchInProgress && m_id == id) {
@@ -1900,6 +1926,7 @@ public:
         }
         return false;
     }
+
     bool touchUp(qint32 id, std::chrono::microseconds time) override
     {
         if (m_touchInProgress && m_id == id) {
@@ -1916,10 +1943,6 @@ private:
     QPointF m_lastPos;
 };
 
-/**
- * This filter implements window actions. If the event should not be passed to the
- * current window it will filter out the event
- */
 class WindowActionInputFilter : public InputEventFilter
 {
 public:
@@ -1927,19 +1950,18 @@ public:
         : InputEventFilter(InputFilterOrder::WindowAction)
     {
     }
+
     bool pointerButton(PointerButtonEvent *event) override
     {
         if (event->state == PointerButtonState::Pressed) {
-            Window *window = input()->pointer()->focus();
-            if (!window || !window->isClient()) {
+            Window *const window = input()->pointer()->focus();
+            if (!window || !window->isClient()) [[unlikely]] {
                 return false;
             }
             return performWindowMouseAction(event, window).value_or(false);
         } else {
-            // because of implicit pointer grab while a button is pressed, this may need to
-            // target a different window than the one with pointer focus
-            Window *window = input()->pointer()->hover();
-            if (!window || !window->isClient()) {
+            Window *const window = input()->pointer()->hover();
+            if (!window || !window->isClient()) [[unlikely]] {
                 return false;
             }
             if (const auto command = window->getMouseReleaseCommand(event->button)) {
@@ -1948,14 +1970,14 @@ public:
         }
         return false;
     }
+
     bool pointerAxis(PointerAxisEvent *event) override
     {
         if (event->orientation != Qt::Vertical) {
-            // only actions on vertical scroll
             return false;
         }
-        Window *window = input()->pointer()->focus();
-        if (!window || !window->isClient()) {
+        Window *const window = input()->pointer()->focus();
+        if (!window || !window->isClient()) [[unlikely]] {
             return false;
         }
         const auto command = windowWheelCommand(event, window);
@@ -1967,14 +1989,15 @@ public:
         }
         return window->performMousePressCommand(*command, event->position);
     }
+
     bool touchDown(qint32 id, const QPointF &pos, std::chrono::microseconds time) override
     {
-        auto seat = waylandServer()->seat();
+        auto *const seat = waylandServer()->seat();
         if (seat->isTouchSequence()) {
             return false;
         }
-        Window *window = input()->touch()->focus();
-        if (!window || !window->isClient()) {
+        Window *const window = input()->touch()->focus();
+        if (!window || !window->isClient()) [[unlikely]] {
             return false;
         }
         const auto command = window->getMousePressCommand(Qt::LeftButton);
@@ -1983,10 +2006,11 @@ public:
         }
         return false;
     }
+
     bool touchUp(int32_t id, std::chrono::microseconds time) override
     {
-        Window *window = input()->touch()->focus();
-        if (!window || !window->isClient()) {
+        Window *const window = input()->touch()->focus();
+        if (!window || !window->isClient()) [[unlikely]] {
             return false;
         }
         const auto command = window->getMouseReleaseCommand(Qt::LeftButton);
@@ -1995,10 +2019,11 @@ public:
         }
         return false;
     }
+
     bool tabletToolTipEvent(TabletToolTipEvent *event) override
     {
-        Window *window = input()->tablet()->focus();
-        if (!window || !window->isClient()) {
+        Window *const window = input()->tablet()->focus();
+        if (!window || !window->isClient()) [[unlikely]] {
             return false;
         }
 
@@ -2016,10 +2041,11 @@ public:
 
         return false;
     }
+
     bool tabletToolButtonEvent(TabletToolButtonEvent *event) override
     {
-        Window *window = input()->tablet()->focus();
-        if (!window || !window->isClient()) {
+        Window *const window = input()->tablet()->focus();
+        if (!window || !window->isClient()) [[unlikely]] {
             return false;
         }
 
@@ -2052,15 +2078,14 @@ public:
 
     bool pointerButton(PointerButtonEvent *event) override
     {
-        auto inputMethod = kwinApp()->inputMethod();
-        if (!inputMethod) {
+        auto *const inputMethod = kwinApp()->inputMethod();
+        if (!inputMethod) [[unlikely]] {
             return false;
         }
         if (event->state != PointerButtonState::Pressed) {
             return false;
         }
 
-        // clicking on an on screen keyboard shouldn't flush, check we're clicking on our target window
         if (input()->pointer()->focus() != inputMethod->activeWindow()) {
             return false;
         }
@@ -2071,8 +2096,8 @@ public:
 
     bool touchDown(qint32 id, const QPointF &point, std::chrono::microseconds time) override
     {
-        auto inputMethod = kwinApp()->inputMethod();
-        if (!inputMethod) {
+        auto *const inputMethod = kwinApp()->inputMethod();
+        if (!inputMethod) [[unlikely]] {
             return false;
         }
         if (input()->findToplevel(point) != inputMethod->activeWindow()) {
@@ -2089,9 +2114,6 @@ public:
     }
 };
 
-/**
- * The remaining default input filter which forwards events to other windows
- */
 class ForwardInputFilter : public InputEventFilter
 {
 public:
@@ -2099,63 +2121,65 @@ public:
         : InputEventFilter(InputFilterOrder::Forward)
     {
     }
+
     bool pointerMotion(PointerMotionEvent *event) override
     {
-        auto seat = waylandServer()->seat();
+        auto *const seat = waylandServer()->seat();
         seat->setTimestamp(event->timestamp);
         seat->notifyPointerMotion(event->position);
-        // absolute motion events confuse games and Wayland doesn't have a warp event yet
-        // -> send a relative motion event with a zero delta to signal the warp instead
-        if (event->warp) {
+        if (event->warp) [[unlikely]] {
             seat->relativePointerMotion(QPointF(0, 0), QPointF(0, 0), event->timestamp);
-        } else if (!event->delta.isNull()) {
+        } else if (!event->delta.isNull()) [[likely]] {
             seat->relativePointerMotion(event->delta, event->deltaUnaccelerated, event->timestamp);
         }
         return true;
     }
+
     bool pointerButton(PointerButtonEvent *event) override
     {
-        auto seat = waylandServer()->seat();
+        auto *const seat = waylandServer()->seat();
         seat->setTimestamp(event->timestamp);
         seat->notifyPointerButton(event->nativeButton, event->state);
         return true;
     }
+
     bool pointerFrame() override
     {
-        auto seat = waylandServer()->seat();
-        seat->notifyPointerFrame();
+        waylandServer()->seat()->notifyPointerFrame();
         return true;
     }
+
     bool pointerAxis(PointerAxisEvent *event) override
     {
-        auto seat = waylandServer()->seat();
+        auto *const seat = waylandServer()->seat();
         seat->setTimestamp(event->timestamp);
         seat->notifyPointerAxis(event->orientation, event->delta, event->deltaV120, event->source, event->inverted);
         return true;
     }
+
     bool keyboardKey(KeyboardKeyEvent *event) override
     {
-        if (event->state == KeyboardKeyState::Repeated) {
-            // handled by Wayland client
+        if (event->state == KeyboardKeyState::Repeated) [[unlikely]] {
             return false;
         }
         input()->keyboard()->update();
-        auto seat = waylandServer()->seat();
+        auto *const seat = waylandServer()->seat();
         seat->setTimestamp(event->timestamp);
         seat->notifyKeyboardKey(event->nativeScanCode, event->state);
         return true;
     }
+
     bool touchDown(qint32 id, const QPointF &pos, std::chrono::microseconds time) override
     {
-        auto seat = waylandServer()->seat();
-        auto w = input()->findToplevel(pos);
-        if (!w) {
+        auto *const seat = waylandServer()->seat();
+        auto *const w = input()->findToplevel(pos);
+        if (!w) [[unlikely]] {
             qCCritical(KWIN_CORE) << "Could not touch down, there's no window under" << pos;
             return false;
         }
         seat->setTimestamp(time);
-        auto tp = seat->notifyTouchDown(w->surface(), w->bufferGeometry().topLeft(), id, pos);
-        if (!tp) {
+        auto *const tp = seat->notifyTouchDown(w->surface(), w->bufferGeometry().topLeft(), id, pos);
+        if (!tp) [[unlikely]] {
             qCCritical(KWIN_CORE) << "Could not touch down" << pos;
             return false;
         }
@@ -2164,54 +2188,62 @@ public:
         });
         return true;
     }
+
     bool touchMotion(qint32 id, const QPointF &pos, std::chrono::microseconds time) override
     {
-        auto seat = waylandServer()->seat();
+        auto *const seat = waylandServer()->seat();
         seat->setTimestamp(time);
         seat->notifyTouchMotion(id, pos);
         return true;
     }
+
     bool touchUp(qint32 id, std::chrono::microseconds time) override
     {
-        auto seat = waylandServer()->seat();
+        auto *const seat = waylandServer()->seat();
         seat->setTimestamp(time);
         seat->notifyTouchUp(id);
         return true;
     }
+
     bool touchCancel() override
     {
         waylandServer()->seat()->notifyTouchCancel();
         return true;
     }
+
     bool touchFrame() override
     {
         waylandServer()->seat()->notifyTouchFrame();
         return true;
     }
+
     bool pinchGestureBegin(int fingerCount, std::chrono::microseconds time) override
     {
-        auto seat = waylandServer()->seat();
+        auto *const seat = waylandServer()->seat();
         seat->setTimestamp(time);
         seat->startPointerPinchGesture(fingerCount);
         return true;
     }
+
     bool pinchGestureUpdate(qreal scale, qreal angleDelta, const QPointF &delta, std::chrono::microseconds time) override
     {
-        auto seat = waylandServer()->seat();
+        auto *const seat = waylandServer()->seat();
         seat->setTimestamp(time);
         seat->updatePointerPinchGesture(delta, scale, angleDelta);
         return true;
     }
+
     bool pinchGestureEnd(std::chrono::microseconds time) override
     {
-        auto seat = waylandServer()->seat();
+        auto *const seat = waylandServer()->seat();
         seat->setTimestamp(time);
         seat->endPointerPinchGesture();
         return true;
     }
+
     bool pinchGestureCancelled(std::chrono::microseconds time) override
     {
-        auto seat = waylandServer()->seat();
+        auto *const seat = waylandServer()->seat();
         seat->setTimestamp(time);
         seat->cancelPointerPinchGesture();
         return true;
@@ -2219,49 +2251,55 @@ public:
 
     bool swipeGestureBegin(int fingerCount, std::chrono::microseconds time) override
     {
-        auto seat = waylandServer()->seat();
+        auto *const seat = waylandServer()->seat();
         seat->setTimestamp(time);
         seat->startPointerSwipeGesture(fingerCount);
         return true;
     }
+
     bool swipeGestureUpdate(const QPointF &delta, std::chrono::microseconds time) override
     {
-        auto seat = waylandServer()->seat();
+        auto *const seat = waylandServer()->seat();
         seat->setTimestamp(time);
         seat->updatePointerSwipeGesture(delta);
         return true;
     }
+
     bool swipeGestureEnd(std::chrono::microseconds time) override
     {
-        auto seat = waylandServer()->seat();
+        auto *const seat = waylandServer()->seat();
         seat->setTimestamp(time);
         seat->endPointerSwipeGesture();
         return true;
     }
+
     bool swipeGestureCancelled(std::chrono::microseconds time) override
     {
-        auto seat = waylandServer()->seat();
+        auto *const seat = waylandServer()->seat();
         seat->setTimestamp(time);
         seat->cancelPointerSwipeGesture();
         return true;
     }
+
     bool holdGestureBegin(int fingerCount, std::chrono::microseconds time) override
     {
-        auto seat = waylandServer()->seat();
+        auto *const seat = waylandServer()->seat();
         seat->setTimestamp(time);
         seat->startPointerHoldGesture(fingerCount);
         return true;
     }
+
     bool holdGestureEnd(std::chrono::microseconds time) override
     {
-        auto seat = waylandServer()->seat();
+        auto *const seat = waylandServer()->seat();
         seat->setTimestamp(time);
         seat->endPointerHoldGesture();
         return true;
     }
+
     bool holdGestureCancelled(std::chrono::microseconds time) override
     {
-        auto seat = waylandServer()->seat();
+        auto *const seat = waylandServer()->seat();
         seat->setTimestamp(time);
         seat->cancelPointerHoldGesture();
         return true;
@@ -2269,19 +2307,20 @@ public:
 
     bool tabletToolProximityEvent(TabletToolProximityEvent *event) override
     {
-        Window *window = input()->tablet()->focus();
-        if (!window || !window->surface()) {
+        Window *const window = input()->tablet()->focus();
+        if (!window || !window->surface()) [[unlikely]] {
             return false;
         }
 
-        TabletSeatV2Interface *seat = waylandServer()->tabletManagerV2()->seat(waylandServer()->seat());
-        TabletToolV2Interface *tool = seat->tool(event->tool);
-        TabletV2Interface *tablet = seat->tablet(event->device);
+        auto *const ws = waylandServer();
+        TabletSeatV2Interface *const seat = ws->tabletManagerV2()->seat(ws->seat());
+        TabletToolV2Interface *const tool = seat->tool(event->tool);
+        TabletV2Interface *const tablet = seat->tablet(event->device);
 
         const auto [surface, surfaceLocalPos] = window->surface()->mapToInputSurface(window->mapToLocal(event->position));
         tool->setCurrentSurface(surface);
 
-        if (!tool->isClientSupported() || !tablet->isSurfaceSupported(surface)) {
+        if (!tool->isClientSupported() || !tablet->isSurfaceSupported(surface)) [[unlikely]] {
             return emulateTabletEvent(event);
         }
 
@@ -2311,19 +2350,20 @@ public:
 
     bool tabletToolAxisEvent(TabletToolAxisEvent *event) override
     {
-        Window *window = input()->tablet()->focus();
-        if (!window || !window->surface()) {
+        Window *const window = input()->tablet()->focus();
+        if (!window || !window->surface()) [[unlikely]] {
             return false;
         }
 
-        TabletSeatV2Interface *seat = waylandServer()->tabletManagerV2()->seat(waylandServer()->seat());
-        TabletToolV2Interface *tool = seat->tool(event->tool);
-        TabletV2Interface *tablet = seat->tablet(event->device);
+        auto *const ws = waylandServer();
+        TabletSeatV2Interface *const seat = ws->tabletManagerV2()->seat(ws->seat());
+        TabletToolV2Interface *const tool = seat->tool(event->tool);
+        TabletV2Interface *const tablet = seat->tablet(event->device);
 
         const auto [surface, surfaceLocalPos] = window->surface()->mapToInputSurface(window->mapToLocal(event->position));
         tool->setCurrentSurface(surface);
 
-        if (!tool->isClientSupported() || !tablet->isSurfaceSupported(surface)) {
+        if (!tool->isClientSupported() || !tablet->isSurfaceSupported(surface)) [[unlikely]] {
             return emulateTabletEvent(event);
         }
 
@@ -2351,19 +2391,20 @@ public:
 
     bool tabletToolTipEvent(TabletToolTipEvent *event) override
     {
-        Window *window = input()->tablet()->focus();
-        if (!window || !window->surface()) {
+        Window *const window = input()->tablet()->focus();
+        if (!window || !window->surface()) [[unlikely]] {
             return false;
         }
 
-        TabletSeatV2Interface *seat = waylandServer()->tabletManagerV2()->seat(waylandServer()->seat());
-        TabletToolV2Interface *tool = seat->tool(event->tool);
-        TabletV2Interface *tablet = seat->tablet(event->device);
+        auto *const ws = waylandServer();
+        TabletSeatV2Interface *const seat = ws->tabletManagerV2()->seat(ws->seat());
+        TabletToolV2Interface *const tool = seat->tool(event->tool);
+        TabletV2Interface *const tablet = seat->tablet(event->device);
 
         const auto [surface, surfaceLocalPos] = window->surface()->mapToInputSurface(window->mapToLocal(event->position));
         tool->setCurrentSurface(surface);
 
-        if (!tool->isClientSupported() || !tablet->isSurfaceSupported(surface)) {
+        if (!tool->isClientSupported() || !tablet->isSurfaceSupported(surface)) [[unlikely]] {
             return emulateTabletEvent(event);
         }
 
@@ -2404,9 +2445,8 @@ public:
 
     bool emulateTabletEvent(TabletToolProximityEvent *event)
     {
-        // Tablet input emulation is deprecated. It will be removed in the near future.
-        static bool emulateInput = qEnvironmentVariableIntValue("KWIN_WAYLAND_EMULATE_TABLET") == 1;
-        if (!emulateInput) {
+        static const bool emulateInput = qEnvironmentVariableIntValue("KWIN_WAYLAND_EMULATE_TABLET") == 1;
+        if (!emulateInput) [[likely]] {
             return false;
         }
 
@@ -2422,9 +2462,8 @@ public:
 
     bool emulateTabletEvent(TabletToolTipEvent *event)
     {
-        // Tablet input emulation is deprecated. It will be removed in the near future.
-        static bool emulateInput = qEnvironmentVariableIntValue("KWIN_WAYLAND_EMULATE_TABLET") == 1;
-        if (!emulateInput) {
+        static const bool emulateInput = qEnvironmentVariableIntValue("KWIN_WAYLAND_EMULATE_TABLET") == 1;
+        if (!emulateInput) [[likely]] {
             return false;
         }
 
@@ -2443,21 +2482,20 @@ public:
 
     bool emulateTabletEvent(TabletToolAxisEvent *event)
     {
-        // Tablet input emulation is deprecated. It will be removed in the near future.
-        static bool emulateInput = qEnvironmentVariableIntValue("KWIN_WAYLAND_EMULATE_TABLET") == 1;
-        if (!emulateInput) {
+        static const bool emulateInput = qEnvironmentVariableIntValue("KWIN_WAYLAND_EMULATE_TABLET") == 1;
+        if (!emulateInput) [[likely]] {
             return false;
         }
 
         input()->pointer()->processMotionAbsolute(event->position, event->timestamp);
-
         return true;
     }
 
     bool tabletToolButtonEvent(TabletToolButtonEvent *event) override
     {
-        TabletToolV2Interface *tool = waylandServer()->tabletManagerV2()->seat(waylandServer()->seat())->tool(event->tool);
-        if (!tool->isClientSupported()) {
+        auto *const ws = waylandServer();
+        TabletToolV2Interface *const tool = ws->tabletManagerV2()->seat(ws->seat())->tool(event->tool);
+        if (!tool->isClientSupported()) [[unlikely]] {
             return false;
         }
         tool->sendButton(event->button, event->pressed);
@@ -2466,18 +2504,19 @@ public:
 
     TabletPadV2Interface *findAndAdoptPad(InputDevice *device) const
     {
-        Window *window = workspace()->activeWindow();
-        TabletSeatV2Interface *seat = waylandServer()->tabletManagerV2()->seat(waylandServer()->seat());
+        Window *const window = workspace()->activeWindow();
+        auto *const ws = waylandServer();
+        TabletSeatV2Interface *const seat = ws->tabletManagerV2()->seat(ws->seat());
         if (!window || !window->surface() || !seat->isClientSupported(window->surface()->client())) {
             return nullptr;
         }
 
-        TabletPadV2Interface *pad = seat->pad(device);
+        TabletPadV2Interface *const pad = seat->pad(device);
         if (!pad) {
             return nullptr;
         }
 
-        TabletV2Interface *tablet = seat->matchingTablet(pad);
+        TabletV2Interface *const tablet = seat->matchingTablet(pad);
         if (!tablet) {
             return nullptr;
         }
@@ -2488,17 +2527,16 @@ public:
 
     bool tabletPadButtonEvent(TabletPadButtonEvent *event) override
     {
-        auto pad = findAndAdoptPad(event->device);
-        if (!pad) {
+        auto *const pad = findAndAdoptPad(event->device);
+        if (!pad) [[unlikely]] {
             return false;
         }
 
-        auto group = pad->group(event->group);
+        auto *const group = pad->group(event->group);
         if (event->isModeSwitch) {
             group->setCurrentMode(event->mode);
             const auto milliseconds = std::chrono::duration_cast<std::chrono::milliseconds>(event->time).count();
             group->sendModeSwitch(milliseconds);
-            // TODO send button to app?
         }
 
         pad->sendButton(event->time, event->button, event->pressed);
@@ -2507,11 +2545,11 @@ public:
 
     bool tabletPadRingEvent(TabletPadRingEvent *event) override
     {
-        auto pad = findAndAdoptPad(event->device);
-        if (!pad) {
+        auto *const pad = findAndAdoptPad(event->device);
+        if (!pad) [[unlikely]] {
             return false;
         }
-        auto ring = pad->group(event->group)->ring(event->number);
+        auto *const ring = pad->group(event->group)->ring(event->number);
 
         if (event->isFinger && event->position == -1) {
             ring->sendStop();
@@ -2528,11 +2566,11 @@ public:
 
     bool tabletPadStripEvent(TabletPadStripEvent *event) override
     {
-        auto pad = findAndAdoptPad(event->device);
-        if (!pad) {
+        auto *const pad = findAndAdoptPad(event->device);
+        if (!pad) [[unlikely]] {
             return false;
         }
-        auto strip = pad->group(event->group)->strip(event->number);
+        auto *const strip = pad->group(event->group)->strip(event->number);
 
         strip->sendPosition(event->position);
         if (event->isFinger) {
@@ -2544,14 +2582,13 @@ public:
 
     bool tabletPadDialEvent(TabletPadDialEvent *event) override
     {
-        auto pad = findAndAdoptPad(event->device);
-        if (!pad) {
+        auto *const pad = findAndAdoptPad(event->device);
+        if (!pad) [[unlikely]] {
             return false;
         }
-        auto dial = pad->group(event->group)->dial(event->number);
+        auto *const dial = pad->group(event->group)->dial(event->number);
 
         dial->sendDelta(event->delta);
-
         dial->sendFrame(std::chrono::duration_cast<std::chrono::milliseconds>(event->time).count());
         return true;
     }
@@ -2559,12 +2596,12 @@ public:
 
 static AbstractDropHandler *dropHandler(Window *window)
 {
-    auto surface = window->surface();
+    auto *const surface = window->surface();
     if (!surface) {
         return nullptr;
     }
-    auto seat = waylandServer()->seat();
-    auto dropTarget = seat->dropHandlerForSurface(surface);
+    auto *const seat = waylandServer()->seat();
+    auto *const dropTarget = seat->dropHandlerForSurface(surface);
     if (dropTarget) {
         return dropTarget;
     }
@@ -2584,9 +2621,10 @@ public:
     DragAndDropInputFilter()
         : InputEventFilter(InputFilterOrder::DragAndDrop)
     {
-        connect(waylandServer()->seat(), &SeatInterface::dragStarted, this, []() {
-            AbstractDataSource *dragSource = waylandServer()->seat()->dragSource();
-            if (!dragSource) {
+        auto *const ws = waylandServer();
+        connect(ws->seat(), &SeatInterface::dragStarted, this, []() {
+            AbstractDataSource *const dragSource = waylandServer()->seat()->dragSource();
+            if (!dragSource) [[unlikely]] {
                 return;
             }
 
@@ -2600,7 +2638,7 @@ public:
         m_raiseTimer.setInterval(1000);
         connect(&m_raiseTimer, &QTimer::timeout, this, &DragAndDropInputFilter::raiseDragTarget);
 
-        connect(waylandServer()->seat(), &SeatInterface::dragEnded, this, [this] {
+        connect(ws->seat(), &SeatInterface::dragEnded, this, [this] {
             if (!m_currentToplevelDragWindow) {
                 return;
             }
@@ -2612,7 +2650,7 @@ public:
 
     bool pointerMotion(PointerMotionEvent *event) override
     {
-        auto seat = waylandServer()->seat();
+        auto *seat = waylandServer()->seat();
         if (!seat->isDragPointer()) {
             return false;
         }
