--- surface.cpp.orig	2025-10-08 11:53:18.942414901 +0200
+++ surface.cpp	2025-10-08 15:00:55.751094328 +0200
@@ -38,10 +38,72 @@ namespace KWin
 
 static QRegion map_helper(const QMatrix4x4 &matrix, const QRegion &region)
 {
-    QRegion result;
-    for (const QRect &rect : region) {
-        result += matrix.mapRect(QRectF(rect)).toAlignedRect();
+    // Early exit for empty or identity cases (common in compositor)
+    if (region.isEmpty()) {
+        return QRegion();
+    }
+
+    if (matrix.isIdentity()) {
+        return region;
+    }
+
+    // Collect rects and count
+    const auto rectsBegin = region.begin();
+    const auto rectsEnd = region.end();
+    const auto rectCount = std::distance(rectsBegin, rectsEnd);
+
+    if (rectCount == 0) {
+        return QRegion();
     }
+
+    // Pre-allocate output vector to avoid N reallocations
+    QVector<QRect> transformedRects;
+    transformedRects.reserve(static_cast<qsizetype>(rectCount));
+
+    // Fast path: detect simple scale+translate (no rotation/skew)
+    // Common for HiDPI scaling and viewport transforms
+    const bool isSimpleTransform = matrix(0, 1) == 0.0f && matrix(1, 0) == 0.0f &&
+                                    matrix(0, 2) == 0.0f && matrix(1, 2) == 0.0f &&
+                                    matrix(2, 0) == 0.0f && matrix(2, 1) == 0.0f &&
+                                    matrix(3, 0) == 0.0f && matrix(3, 1) == 0.0f &&
+                                    matrix(3, 2) == 0.0f;
+
+    if (isSimpleTransform) {
+        // Extract scale and translate components
+        const float scaleX = matrix(0, 0);
+        const float scaleY = matrix(1, 1);
+        const float transX = matrix(0, 3);
+        const float transY = matrix(1, 3);
+
+        // Process rects with scalar float ops (1-cycle FMA on Raptor Lake)
+        for (auto it = rectsBegin; it != rectsEnd; ++it) {
+            const QRect &rect = *it;
+
+            // Transform corners: [x, x+w] → [x*sx+tx, (x+w)*sx+tx]
+            const float x1 = static_cast<float>(rect.x()) * scaleX + transX;
+            const float y1 = static_cast<float>(rect.y()) * scaleY + transY;
+            const float x2 = static_cast<float>(rect.right() + 1) * scaleX + transX;
+            const float y2 = static_cast<float>(rect.bottom() + 1) * scaleY + transY;
+
+            // Convert to aligned integer rect (conservative rounding)
+            const int left = static_cast<int>(std::floor(x1));
+            const int top = static_cast<int>(std::floor(y1));
+            const int right = static_cast<int>(std::ceil(x2)) - 1;
+            const int bottom = static_cast<int>(std::ceil(y2)) - 1;
+
+            transformedRects.append(QRect(QPoint(left, top), QPoint(right, bottom)));
+        }
+    } else {
+        // General transformation path (handles rotation/skew)
+        for (auto it = rectsBegin; it != rectsEnd; ++it) {
+            const QRect &rect = *it;
+            transformedRects.append(matrix.mapRect(QRectF(rect)).toAlignedRect());
+        }
+    }
+
+    // Construct result region from vector (single allocation vs. N)
+    QRegion result;
+    result.setRects(transformedRects.data(), transformedRects.size());
     return result;
 }
 
@@ -862,13 +924,62 @@ QRegion SurfaceInterfacePrivate::mapToBu
         return QRegion();
     }
 
+    // Guard against invalid state (e.g., buffer released mid-commit)
+    if (!current->buffer) {
+        return QRegion();
+    }
+
+    // Compute transform parameters (hoisted out of loop)
     const QRectF sourceBox = current->bufferTransform.inverted().map(bufferSourceBox, current->buffer->size());
     const qreal xScale = sourceBox.width() / surfaceSize.width();
     const qreal yScale = sourceBox.height() / surfaceSize.height();
 
+    // Collect input rects
+    const auto rectsBegin = region.begin();
+    const auto rectsEnd = region.end();
+    const auto rectCount = std::distance(rectsBegin, rectsEnd);
+
+    if (rectCount == 0) {
+        return QRegion();
+    }
+
+    // Pre-allocate output vector (avoids O(N) reallocations)
+    QVector<QRect> transformedRects;
+    transformedRects.reserve(static_cast<qsizetype>(rectCount));
+
+    // Hoist invariants
+    const QPointF offset = bufferSourceBox.topLeft();
+    const QSizeF boxSize = sourceBox.size();
+    const QRect bufferBounds(QPoint(0, 0), current->buffer->size());
+
+    // Transform each rect: scale → buffer-transform → translate → clip
+    for (auto it = rectsBegin; it != rectsEnd; ++it) {
+        const QRect &rect = *it;  // Reference avoids copy (4×int)
+
+        // Scale to source box coordinates
+        const QRectF scaled(
+            static_cast<qreal>(rect.x()) * xScale,
+            static_cast<qreal>(rect.y()) * yScale,
+            static_cast<qreal>(rect.width()) * xScale,
+            static_cast<qreal>(rect.height()) * yScale
+        );
+
+        // Apply buffer transform (rotation/flip) and translate
+        const QRectF transformed = current->bufferTransform.map(scaled, boxSize).translated(offset);
+
+        // Convert to integer rect and clip to buffer bounds (defensive)
+        const QRect aligned = transformed.toAlignedRect().intersected(bufferBounds);
+
+        // Only append non-empty rects (QRegion handles this, but early-exit is faster)
+        if (!aligned.isEmpty()) {
+            transformedRects.append(aligned);
+        }
+    }
+
+    // Construct result region from vector (single allocation)
     QRegion result;
-    for (QRectF rect : region) {
-        result += current->bufferTransform.map(QRectF(rect.x() * xScale, rect.y() * yScale, rect.width() * xScale, rect.height() * yScale), sourceBox.size()).translated(bufferSourceBox.topLeft()).toAlignedRect();
+    if (!transformedRects.isEmpty()) {
+        result.setRects(transformedRects.data(), transformedRects.size());
     }
     return result;
 }
