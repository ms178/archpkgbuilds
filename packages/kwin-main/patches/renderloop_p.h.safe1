/*
    SPDX-FileCopyrightText: 2020 Vlad Zahorodnii <vlad.zahorodnii@kde.org>

    SPDX-License-Identifier: GPL-2.0-or-later
*/

#pragma once

#include "renderbackend.h"
#include "renderjournal.h"
#include "renderloop.h"

#include <QTimer>
#include <fstream>
#include <optional>

namespace KWin
{

class SurfaceItem;
class OutputFrame;

// Cache-aligned for false sharing prevention and optimal layout
class alignas(64) KWIN_EXPORT RenderLoopPrivate
{
public:
    static RenderLoopPrivate *get(RenderLoop *loop);
    explicit RenderLoopPrivate(RenderLoop *q, Output *output);

    void dispatch();
    void delayScheduleRepaint();
    void scheduleNextRepaint();
    void scheduleRepaint(std::chrono::nanoseconds lastTargetTimestamp);
    void notifyFrameDropped();
    void notifyFrameCompleted(std::chrono::nanoseconds timestamp, std::optional<RenderTimeSpan> renderTime, PresentationMode mode, OutputFrame *frame);
    void notifyVblank(std::chrono::nanoseconds timestamp);

    // === CACHE LINE 0 (0-63 bytes): HOT PATH FIELDS ===
    // Accessed every frame in scheduleRepaint fast path
    RenderLoop *const q;                          // 0-7: Pointer (const, never changes)
    Output *const output;                         // 8-15: Pointer (const, never changes)
    int refreshRate;                              // 16-19: Read every frame
    int pendingFrameCount;                        // 20-23: Read/write every frame
    int inhibitCount;                             // 24-27: Read every frame
    int maxPendingFrameCount;                     // 28-31: Read every frame
    PresentationMode presentationMode;            // 32-35: Read every frame (enum = int)
    bool pendingReschedule;                       // 36: Read/write every frame
    bool wasTripleBuffering;                      // 37: Read/write every frame
    // 38-39: Padding (2 bytes)
    int doubleBufferingCounter;                   // 40-43: Read/write (buffering logic)
    // 44-47: Padding (4 bytes to align next field)
    uint64_t cachedVblankIntervalNs;              // 48-55: Read every frame (NEW FIELD)
    // 56-63: Padding (8 bytes)
    // Total: 56 bytes used, 8 bytes padding â†’ fits in single 64-byte line

    // === CACHE LINE 1 (64-127 bytes): WARM FIELDS ===
    std::chrono::nanoseconds lastPresentationTimestamp; // 64-71: Read every frame
    std::chrono::nanoseconds nextPresentationTimestamp; // 72-79: Read/write every frame
    std::chrono::nanoseconds safetyMargin;              // 80-87: Read every frame
    RenderJournal renderJournal;                        // 88-95: 8-byte nanoseconds field
    // QTimer is large (~32 bytes); starts at 96
    QTimer compositeTimer;                              // 96-127: Accessed every frame

    // === CACHE LINE 2+ (128+ bytes): COLD FIELDS ===
    QTimer delayedVrrTimer;                       // Accessed only in VRR mode
    std::optional<std::fstream> m_debugOutput;    // Accessed only if debug enabled (rare)
};

// Verify cache alignment assumptions
static_assert(alignof(RenderLoopPrivate) == 64, "Must be cache-aligned");
static_assert(sizeof(void*) == 8, "Assumes 64-bit pointers");

} // namespace KWin
