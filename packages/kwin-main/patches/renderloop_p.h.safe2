/*
    SPDX-FileCopyrightText: 2020 Vlad Zahorodnii <vlad.zahorodnii@kde.org>

    SPDX-License-Identifier: GPL-2.0-or-later
*/

#pragma once

#include "renderbackend.h"
#include "renderjournal.h"
#include "renderloop.h"

#include <QTimer>
#include <chrono>
#include <fstream>
#include <optional>

namespace KWin
{

class SurfaceItem;
class OutputFrame;

// Cache-aligned for false sharing prevention and optimal layout of hot fields.
class alignas(64) KWIN_EXPORT RenderLoopPrivate
{
public:
    static RenderLoopPrivate *get(RenderLoop *loop);
    explicit RenderLoopPrivate(RenderLoop *q, Output *output);

    void dispatch();
    void delayScheduleRepaint();
    void scheduleNextRepaint();
    void scheduleRepaint(std::chrono::nanoseconds lastTargetTimestamp);
    void notifyFrameDropped();
    void notifyFrameCompleted(std::chrono::nanoseconds timestamp,
                              std::optional<RenderTimeSpan> renderTime,
                              PresentationMode mode,
                              OutputFrame *frame);
    void notifyVblank(std::chrono::nanoseconds timestamp);

    // === CACHE LINE 0 (0-63 bytes): HOT PATH FIELDS ===
    RenderLoop *const q;               // 0-7: never changes
    Output *const output;              // 8-15: never changes
    int refreshRate;                   // 16-19: millihertz; read every frame
    int pendingFrameCount;             // 20-23: in-flight frames
    int inhibitCount;                  // 24-27: inhibit depth
    int maxPendingFrameCount;          // 28-31: cap in-flight frames
    PresentationMode presentationMode; // 32-35: current presentation mode
    bool pendingReschedule;            // 36: queued reschedule
    bool wasTripleBuffering;           // 37: hysteresis state
    // 38-39: padding
    int doubleBufferingCounter;        // 40-43: hysteresis counter
    // 44-47: padding
    uint64_t cachedVblankIntervalNs;   // 48-55: precomputed vblank interval nanoseconds
    // 56-63: padding

    // === CACHE LINE 1 (64-127 bytes): WARM FIELDS ===
    std::chrono::nanoseconds lastPresentationTimestamp; // 64-71
    std::chrono::nanoseconds nextPresentationTimestamp; // 72-79
    std::chrono::nanoseconds safetyMargin;              // 80-87
    RenderJournal renderJournal;                        // 88-95
    QTimer compositeTimer;                              // 96-127

    // === CACHE LINE 2+ (128+ bytes): COLD FIELDS ===
    QTimer delayedVrrTimer;                       // VRR gating timer
    std::optional<std::fstream> m_debugOutput;    // Debug CSV if enabled
};

static_assert(alignof(RenderLoopPrivate) == 64, "RenderLoopPrivate must be 64-byte aligned");
static_assert(sizeof(void*) == 8, "Assumes 64-bit pointers");

} // namespace KWin
