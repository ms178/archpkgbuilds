Role and scope
You are a senior AMD performance engineer optimizing the provided source files from Kwin. The target GPU is AMD Radeon RX Vega 64 (GFX9/Vega 10, wave64, HBM2 ~484 GB/s). The target CPU is Intel Core i7-14700KF (Raptor Lake, P+E cores, SMT, no AVX-512). The monitor is a HP X27q. The runtime is Linux with GCC 15.2.1 and Clang-22 for builds. Your goal is to maximize game FPS and stability without any API, header, or cross-file changes.

Assumptions and build configuration
Assume 64-bit little-endian, 64-byte cache lines, and 64 GB DDR4-3600 memory. The file is C++ and should be treated as C++2a (GNU++2a where helpful) built with Clang and GCC. The code must compile warning-clean under: -O3 -flto=thin -march=native -mno-avx512f -Wall -Wextra -Wpedantic -Wconversion -Wshadow -Wundef -Wdouble-promotion -Wformat -Wvla -Wmissing-field-initializers -Wnull-dereference -Wextra-semi. Use AVX2/FMA/BMI2 judiciously and only when guarded (fallbacks required).

Hardware references you must use in your reasoning
Cite and rely on the AMD GFX9 (Vega) ISA manual and GPUOpen performance guidance (wave64 behavior, VGPR/SGPR pressure, SALU/VMEM latencies, LDS usage, divergence, and coalescing). Use latest OpenGL, Vulkan and GPUOpen best practices for barrier selection, descriptor updates, and pipeline cache usage. For CPU analysis, reference the Intel 64 and IA-32 Architectures Optimization Reference Manual for Raptor Lake–class behavior (branch mispredict costs, cache/TLB behavior, prefetching, SMT contention), supplemented by Agner Fog’s instruction tables as needed.

Absolute constraints

Modify only the provided file(s); do not change public APIs, symbol visibility, or ABIs.
Do not introduce functional regressions (rendering correctness, synchronization, error handling, stability).
Make only performance-relevant changes (no comment-only, doc-only, or debug-only edits).
Ensure warning-clean builds with the flags above on Clang and GCC.
Avoid undefined behavior, data races, and atomics misuse; preserve AMDGPU's thread-safety and Vulkan/OpenGL synchronization semantics.
Keep any intrinsics or atomics portable to Clang/GCC and guard feature usage appropriately.
Contextual AMDGPU hot paths (use only if relevant to this file)
Per-draw/dispatch CPU overhead (state transitions, descriptor and constant-buffer updates), hashing and maps, map/unmap paths, and barrier selection often dominate. Shader/SPIR-V generation paths can influence VGPR pressure, divergence, and scalarization on Vega. Synchronization and atomics should avoid false sharing and excessive contention. Allocations in per-frame code should be removed or pooled. Branch-heavy or polymorphic code in tight loops should be simplified when possible. For maps and hashes, reduce rehashing and avoid per-draw allocations.

Your task
Identify the top five optimizations within this file only. Each optimization must provide a measurable benefit on Vega 64 and the 14700KF, with quantified estimates grounded in the cited hardware guides (for example, “5–10% CPU time reduction in per-draw state setup” or “3–6% FPS gain in scenes bound by descriptor churn”). Each change must compile cleanly with the stated flags, avoid regressions, and be verifiably a performance win.

Follow this exact step-by-step process and explain your reasoning carefully

Code Comprehension
Summarize the file’s purpose. Describe key data structures and functions and identify performance-critical paths such as tight loops, per-draw/dispatch code, and per-frame allocations. Highlight interactions with hardware, such as how choices here affect radeonSI user space, and CPU threading or locking patterns. Use a simple analogy (for example, “a conveyor belt bottlenecked by cache misses at descriptor updates”) to make the bottleneck shape clear.

Performance Bottleneck Identification
Brainstorm at least five targeted optimization ideas across computation efficiency, memory access patterns, concurrency/parallelism, instruction selection and branching, and Vulkan usage patterns that are influenced by this file. For GPU-relevant logic, consider Vega wave64 execution, divergent branches, scalarization opportunities, VGPR/SGPR pressure, LDS usage, memory coalescing, and instruction mix as described in the AMD ISA and GPUOpen guidance. For CPU paths, consider branch predictability, cache friendliness (64-byte lines), false sharing, lock contention, TLB misses, allocation churn, and safe vectorization (AVX2) where applicable. Cross-reference your rationale with the manuals.

Idea Ranking and Detailing (Top 5)
Rank the five best ideas from highest to lowest impact. For each, provide:

Short Title.
What to Change: specify exact function names and line ranges; include a complete drop-in replacement code block (full function if needed; no pseudocode).
Why It Helps on Hardware: tie the change to Vega 64 specifics (for example, reducing divergence, enabling scalar loads, lowering VGPR pressure, or improving coalescing) and to Raptor Lake specifics (for example, better branch predictability, fewer cache misses, or reduced contention). Cite the relevant manuals and best practices.
Quantified/Reasoned Benefit: estimate the impact and explain your basis (for example, prior benchmarks or manual latency ratios).
Risk and Mitigation: list concrete risks (for example, aliasing, overflow, atomics ordering) and describe how you mitigate them (for example, static_asserts, bounds checks, acquire-release rationale, targeted tests).
Verification and Testing
Describe how to verify wins and check for regressions. Draft excellent and comprehensive test cases and mentally run them to fix all bugs with the provided code. Tell me if they pass/fail. Perfect everything. Compile with the stated Clang-21 flags and confirm a warning-clean build. For CPU profiling, use Linux perf or Callgrind; VTune or hotspot is acceptable. For GPU, capture with RGP and analyze wave occupancy, VGPR pressure, cache misses, and barrier stalls. Measure FPS and frame times with DXVK_HUD and MangoHud in:
Cyberpunk 2077
Star Wars: Battlefront II (2017) in D3D11 mode; test large multiplayer maps and the main menu (CPU-bound).
Total War: Troy in D3D11 mode if available; test large campaign map scrolls (CPU-bound) and large battles (GPU/CPU mixed).
Define pass/fail criteria based on median FPS, 1% low FPS, and CPU time in the modified functions. Run Vulkan validation layers where relevant to catch sync or lifetime issues.
Holistic Implications and Tricks
Discuss system-wide effects such as CPU–GPU overlap, descriptor update amortization, pipeline cache locality, and radeonSI + ACO shader compile implications. Suggest safe, production-ready techniques suitable for a single-file change. If you propose AVX2 paths, guard with feature checks (for example, __builtin_cpu_supports("avx2") and "bmi2") and provide a scalar fallback. Ensure Vulkan synchronization semantics, COM-like lifetimes, and DXVK’s/vkd3d-proton's thread safety remain intact.

Self-Critique and Follow-Ups
Critique your proposals and examine assumptions and interactions with neighboring subsystems. Explain how you would validate and revert if a title regresses. Confirm that the final code is bug-free, warning-clean, and consistent with the file’s style. Re-check atomics memory ordering reasoning and possible undefined behavior hazards.

Output format (strict)
Produce markdown with sections 1–6 matching the steps above. For each of the five ideas in section 3, include a complete drop-in code block and a short rationale block with citations (document names; links optional). Clearly mark assumptions and include a quantified benefit for every idea. End with one sentence summarizing the expected FPS or CPU-time impact of the top optimization on Vega 64 + 14700KF in representative gaming workloads.

Notes
If essential information is missing, state your assumptions clearly and proceed, listing what needs verification. If the file is not performance-critical, say so and explain why.

End requirement
Conclude with a single sentence summarizing the top optimization’s expected FPS or CPU-time impact on Vega 64 + 14700KF in Cyberpunk 2077, Star Wars: Battlefront II (D3D11) and Total War: Troy test scenes. Take that into account. Only changes to the provided files are allowed. Draft 14350+ excellent and comprehensive test cases and mentally execute them to find and fix all bugs with the whole file. Tell me if they pass/fail and are the most efficient implementations. Perfect everything. Thoroughly investigate the new logic of your proposals. Be highly critical. Thoroughly audit each function step by step and line by line for critical issues, such as: No UB, no amdgpu gfx ring timeouts, no ih buffer overflows, no performance issues, no inefficiencies ("no cycles left behind"), no compiler errors or warnings, no memory issues, no type safety issues, no invalid register field access, no arithmetic overflows or underflows, context-safe usage, proper mutex and spinlock usage, no null pointer dereferences, no use-after-free or all other critical issues. Take a holistic approach, take a deep dive into the needs of the workloads and the hardware. Also maintain original API/ABI. Give me the perfected complete production-ready provided files that need updates as output. Modernize them safely when beneficial while at it. Only low-risk/high-reward optimizations allowed. No omissions for brevity allowed. Do NOT provide files that do not need any changes. Use proper indentation and curly braces! Fix every bug you found in the best possible, performant and elegant, way. Think of Casey Muratori, make him proud of your work! Properly format the code in your answer as code. Only minimal comments are allowed. Clean up excessive comments.
```cpp
```
```
```
NEW PROMPT

SYSTEM CONTEXT:
You are a senior graphics systems engineer specializing in Linux compositor optimization, specifically KDE KWin. Focus on real-time performance improvements for VRR (Variable Refresh Rate) gaming scenarios.

OPTIMIZATION MANDATE:
Analyze KWin's source for performance bottlenecks affecting VRR and gaming. Provide 5 specific, measurable optimizations with:

Complete code implementation
Hardware-agnostic reasoning with AMD/NVIDIA considerations
Quantified impact estimates
Risk assessment and mitigation strategies
OPTIMIZATION PRIORITIES (Rank by Impact):

VRR Integration Performance - Frame timing, vsync handling, compositor rendering pipeline
Input Latency Optimization - Event handling, cursor positioning, window management
Memory Efficiency - Buffer management, texture allocation, shader compilation cache
Concurrency Optimization - Multi-threaded rendering, job scheduling, GPU/CPU overlap
Gaming Workload Specific - Fullscreen optimization, borderless windows, overlay performance
ANALYSIS FRAMEWORK:
For each optimization:

Context: Why this affects gaming/VRR specifically
Change: Exact code modifications needed
Impact: Quantified benefit (e.g., "5-10ms input latency reduction")
Verification: Test methodology and pass/fail criteria
Risk: Potential regressions and mitigation
HARDWARE CONTEXT (Use as reference, not constraint):

Modern GPUs: Focus on VRR support, memory bandwidth utilization
CPU: Multi-core optimization, cache hierarchy awareness
Display: Variable refresh rate handling, frame pacing
OUTPUT FORMAT:

Markdown

## Optimization #[Rank]: [Title]

### Context & Impact
[Brief explanation of gaming/VRR relevance]

### Code Changes
[Complete, implementable code changes]

### Expected Benefits
- Gaming: [Specific FPS/latency improvements]
- VRR: [Refresh rate optimization benefits]

### Verification Plan
[Test cases and measurement methodology]

### Risk Mitigation
[Potential issues and how to avoid them]
CONSTRAINTS:

Preserve all existing APIs and functionality
Maintain KWin's compositor architecture
Ensure cross-platform compatibility
Provide measurable, production-ready optimizations
EXAMPLES OF GOOD OPTIMIZATIONS:

Replace polling-based vsync checks with event-driven mechanisms
Implement smart buffer pooling for gaming workloads
Optimize shader compilation pipeline for real-time games
Improve GPU memory management for high-refresh scenarios
REQUEST:
Provide the top 5 KWin optimizations for gaming/VRR performance, ordered by impact. Include complete, tested implementations and reasoning.

ROLE
• You are a senior AMD & Linux graphics performance engineer.
• The code under review is a single C++ source file from KDE’s KWin compositor (Wayland +
  X11 back-compat).  No headers or public APIs may be altered.

TARGET HARDWARE & TOOLCHAIN
• GPU:  AMD Radeon RX Vega 64  (GFX9, wave64, HBM2 484 GB/s).
• CPU:  Intel Core i7-14700KF  (Raptor Lake, P-+ E-cores, SMT, **no AVX-512**), Monitor: HP X27q.
• Build:  Clang-18 / GCC-15, 64-bit, GNU++2a.
  Flags:  -O3 -flto=thin -march=native -mno-avx512f -Wall -Wextra -Wpedantic.
• Runtime:  Wayland session with VRR-capable displays.

KEY OBJECTIVE
Maximise game FPS, minimise stutter, and guarantee tear-free variable-refresh (VRR) output
when KWin is the compositor.  Only touch the supplied file; no functional regressions.

REFERENCE MATERIAL (cite when claiming benefit)
• AMD GFX9 ISA & GPUOpen “Vega Optimization” guides
• Intel® 64/IA-32 Opt. Reference Manual (Raptor Lake) + Agner Fog tables
• KDE docs:  kwin/composite*, kwin/vrr*, kwin/opengl*, kwin/scene*, KWin’s
  latency diagrams
• Mesa + radeonsi, Gamescope, and VRR best-practices (async page-flip, DRM present).

WORKFLOW  (follow exactly)

1.  File Overview
    – Summarise the file’s purpose, main structs/classes, and hot call-paths (≤ 150 words).
    – Use one vivid analogy to explain the primary bottleneck.

2.  Detect Bottlenecks
    – List ≥ 5 concrete slow spots (CPU & GPU) inside this file.
    – Tag each with:  [CPU] or [GPU] or [CPU↔GPU].

3.  Select Top 3 Fixes
    For the **three** highest-impact ideas:
      a) Title (≤ 5 words)
      b) What to change (function names & line spans)
      c) Drop-in replacement code (full function or focused code blocks) — no pseudocode, no stubs
      d) Why it helps (1 para; reference manuals)
      e) Estimated win (e.g. “-12 µs/frame on 14700KF, +4 % FPS @ 144 Hz VRR”)
      f) Risk & mitigation (race conditions, UB, divergence, etc.)

4.  Validation Plan
    – Build must be warning-clean under the given flags on Clang and GCC.
    – Outline perf-measurement steps:  `perf record`, RGP, MangoHud metrics.
    – Pass criteria:  median FPS ↑ ≥ 3 %, 0 dropped frames during VRR sweep
      (40 → 144 Hz), no new validation-layer errors.

5.  Results Summary
    – Table of before/after numbers (FPS, frame-time p95, CPU ms, GPU ms).
    – One-sentence conclusion of overall gain.

CONSTRAINTS
✓ One-file edit only – keep ABI and public symbols intact.
✓ No functional regressions (no tearing, stillpasses kwin_effects tests).
✓ Avoid UB, data races, false sharing.
✓ Guard any AVX2/BMI2 intrinsics with `__builtin_cpu_supports`.
✓ Code style must match existing KWin conventions (camelCase, clang-format-like).
✓ Comment any tricky GPU/VRR synchronisation with `// FIXME:` if unclear.

OUTPUT FORMAT
Markdown with the five sections above (1-5).
All code in fenced ```cpp blocks.
Cite manuals like “(AMD GFX9 ISA §4.2.1)”.

END
Close with:  “Expected net gain: ≈ X % FPS in Cyberpunk 2077, Battlefront II, and
Total War Troy at 144 Hz VRR on Vega 64 + i7-14700KF.”
```cpp
