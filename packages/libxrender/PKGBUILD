# Maintainer: Andreas Radke <andyrtr@archlinux.org>
# Contributor: Jan de Groot <jgc@archlinux.org>
# PGO Optimization: CachyOS

pkgname=libxrender
pkgver=0.9.12
pkgrel=2.1
pkgdesc="X Rendering Extension client library (PGO/CS-PGO optimized)"
arch=('x86_64')
url="https://xorg.freedesktop.org/"
license=('HPND-sell-variant')
depends=('libx11' 'glibc' 'xorgproto')
makedepends=('clang' 'llvm')
source=(${url}/archive/individual/lib/libXrender-${pkgver}.tar.xz{,.sig})
sha512sums=('3d24a6877b500608e3e2a393532a99d4fd54fc343375d8fb51dfbb1b50cedf002c7722f771cf7776f93cb6e0421ca5966ce45435cb402d5f12a398f9ea743474'
            'SKIP')
validpgpkeys=('4A193C06D35E7C670FA4EF0BA2FB9E081F2D130E') # Alan Coopersmith <alan.coopersmith@oracle.com>

prepare() {
  cd "libXrender-${pkgver}"
  autoreconf -vfi

  # Generate comprehensive PGO training workload for XRender
  cat > "${srcdir}/xrender_pgo_workload.c" << 'EOF'
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <math.h>
#include <X11/Xlib.h>
#include <X11/extensions/Xrender.h>

#define WORKLOAD_ITERATIONS 3
#define OPS_PER_ITERATION 2000
#define WINDOW_WIDTH 800
#define WINDOW_HEIGHT 600

/* Query and cache all picture formats */
static void train_format_queries(Display *dpy, int iterations) {
    int i, j;
    XRenderPictFormat *fmt;

    for (i = 0; i < iterations; i++) {
        /* Query standard formats */
        fmt = XRenderFindStandardFormat(dpy, PictStandardARGB32);
        fmt = XRenderFindStandardFormat(dpy, PictStandardRGB24);
        fmt = XRenderFindStandardFormat(dpy, PictStandardA8);
        fmt = XRenderFindStandardFormat(dpy, PictStandardA4);
        fmt = XRenderFindStandardFormat(dpy, PictStandardA1);

        /* Query visual formats */
        for (j = 0; j < ScreenCount(dpy); j++) {
            Visual *vis = DefaultVisual(dpy, j);
            fmt = XRenderFindVisualFormat(dpy, vis);
        }

        /* Query format by depth */
        XRenderPictFormat templ;
        templ.depth = 32;
        templ.type = PictTypeDirect;
        fmt = XRenderFindFormat(dpy, PictFormatDepth | PictFormatType, &templ, 0);

        templ.depth = 24;
        fmt = XRenderFindFormat(dpy, PictFormatDepth | PictFormatType, &templ, 0);

        templ.depth = 8;
        fmt = XRenderFindFormat(dpy, PictFormatDepth | PictFormatType, &templ, 0);
    }
}

/* Exercise picture creation and destruction */
static void train_picture_ops(Display *dpy, Window win, int iterations) {
    int i;
    XRenderPictFormat *fmt;
    XRenderPictureAttributes pa;
    Picture pics[32];
    Pixmap pixmaps[32];
    int screen = DefaultScreen(dpy);

    fmt = XRenderFindStandardFormat(dpy, PictStandardARGB32);
    if (!fmt) return;

    for (i = 0; i < iterations; i++) {
        int j;

        /* Create multiple pictures with different attributes */
        for (j = 0; j < 32; j++) {
            pixmaps[j] = XCreatePixmap(dpy, win, 64 + j * 4, 64 + j * 4, 32);

            memset(&pa, 0, sizeof(pa));
            pa.repeat = (j % 4 == 0) ? RepeatNormal :
                        (j % 4 == 1) ? RepeatPad :
                        (j % 4 == 2) ? RepeatReflect : RepeatNone;

            pics[j] = XRenderCreatePicture(dpy, pixmaps[j], fmt, CPRepeat, &pa);
        }

        XFlush(dpy);

        /* Destroy in reverse order */
        for (j = 31; j >= 0; j--) {
            XRenderFreePicture(dpy, pics[j]);
            XFreePixmap(dpy, pixmaps[j]);
        }

        XFlush(dpy);
    }
}

/* Exercise composite operations */
static void train_composite_ops(Display *dpy, Window win, int iterations) {
    int i;
    XRenderPictFormat *fmt_argb, *fmt_rgb, *fmt_a8;
    XRenderPictureAttributes pa;
    Pixmap src_pix, mask_pix, dst_pix;
    Picture src_pic, mask_pic, dst_pic;
    XRenderColor colors[8];
    int screen = DefaultScreen(dpy);

    fmt_argb = XRenderFindStandardFormat(dpy, PictStandardARGB32);
    fmt_rgb = XRenderFindStandardFormat(dpy, PictStandardRGB24);
    fmt_a8 = XRenderFindStandardFormat(dpy, PictStandardA8);

    if (!fmt_argb || !fmt_a8) return;

    /* Setup colors */
    colors[0] = (XRenderColor){0xFFFF, 0x0000, 0x0000, 0xFFFF}; /* Red */
    colors[1] = (XRenderColor){0x0000, 0xFFFF, 0x0000, 0xFFFF}; /* Green */
    colors[2] = (XRenderColor){0x0000, 0x0000, 0xFFFF, 0xFFFF}; /* Blue */
    colors[3] = (XRenderColor){0xFFFF, 0xFFFF, 0x0000, 0xFFFF}; /* Yellow */
    colors[4] = (XRenderColor){0xFFFF, 0x0000, 0xFFFF, 0x8000}; /* Semi-transparent magenta */
    colors[5] = (XRenderColor){0x0000, 0xFFFF, 0xFFFF, 0x8000}; /* Semi-transparent cyan */
    colors[6] = (XRenderColor){0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF}; /* White */
    colors[7] = (XRenderColor){0x0000, 0x0000, 0x0000, 0x8000}; /* Semi-transparent black */

    /* Create pixmaps and pictures */
    src_pix = XCreatePixmap(dpy, win, 256, 256, 32);
    mask_pix = XCreatePixmap(dpy, win, 256, 256, 8);
    dst_pix = XCreatePixmap(dpy, win, 512, 512, 32);

    memset(&pa, 0, sizeof(pa));
    pa.repeat = RepeatNormal;

    src_pic = XRenderCreatePicture(dpy, src_pix, fmt_argb, CPRepeat, &pa);
    mask_pic = XRenderCreatePicture(dpy, mask_pix, fmt_a8, CPRepeat, &pa);
    dst_pic = XRenderCreatePicture(dpy, dst_pix, fmt_argb, 0, &pa);

    for (i = 0; i < iterations; i++) {
        int op, x, y;

        /* Fill source with solid colors */
        for (y = 0; y < 4; y++) {
            for (x = 0; x < 4; x++) {
                XRenderFillRectangle(dpy, PictOpSrc, src_pic, &colors[(x + y) % 8],
                                     x * 64, y * 64, 64, 64);
            }
        }

        /* Fill mask with gradient-like pattern */
        for (y = 0; y < 8; y++) {
            XRenderColor alpha = {0, 0, 0, (y + 1) * 0x1FFF};
            XRenderFillRectangle(dpy, PictOpSrc, mask_pic, &alpha, 0, y * 32, 256, 32);
        }

        /* Clear destination */
        XRenderColor clear = {0, 0, 0, 0};
        XRenderFillRectangle(dpy, PictOpSrc, dst_pic, &clear, 0, 0, 512, 512);

        /* Test various composite operations */
        int ops[] = {PictOpOver, PictOpIn, PictOpOut, PictOpAtop,
                     PictOpXor, PictOpAdd, PictOpSaturate, PictOpSrc};

        for (op = 0; op < 8; op++) {
            /* Composite without mask */
            XRenderComposite(dpy, ops[op], src_pic, None, dst_pic,
                           0, 0, 0, 0, (op % 4) * 128, (op / 4) * 256, 128, 256);

            /* Composite with mask */
            XRenderComposite(dpy, ops[op], src_pic, mask_pic, dst_pic,
                           0, 0, 0, 0, (op % 4) * 128 + 256, (op / 4) * 256, 128, 256);
        }

        XFlush(dpy);
    }

    XRenderFreePicture(dpy, src_pic);
    XRenderFreePicture(dpy, mask_pic);
    XRenderFreePicture(dpy, dst_pic);
    XFreePixmap(dpy, src_pix);
    XFreePixmap(dpy, mask_pix);
    XFreePixmap(dpy, dst_pix);
}

/* Exercise gradient operations */
static void train_gradient_ops(Display *dpy, Window win, int iterations) {
    int i;
    XRenderPictFormat *fmt;
    Pixmap dst_pix;
    Picture dst_pic, grad_pic;
    XRenderPictureAttributes pa;

    fmt = XRenderFindStandardFormat(dpy, PictStandardARGB32);
    if (!fmt) return;

    dst_pix = XCreatePixmap(dpy, win, 512, 512, 32);
    memset(&pa, 0, sizeof(pa));
    dst_pic = XRenderCreatePicture(dpy, dst_pix, fmt, 0, &pa);

    for (i = 0; i < iterations; i++) {
        XFixed stops[4];
        XRenderColor colors[4];
        XLinearGradient linear;
        XRadialGradient radial;

        /* Setup gradient stops */
        stops[0] = XDoubleToFixed(0.0);
        stops[1] = XDoubleToFixed(0.33);
        stops[2] = XDoubleToFixed(0.66);
        stops[3] = XDoubleToFixed(1.0);

        colors[0] = (XRenderColor){0xFFFF, 0x0000, 0x0000, 0xFFFF};
        colors[1] = (XRenderColor){0xFFFF, 0xFFFF, 0x0000, 0xFFFF};
        colors[2] = (XRenderColor){0x0000, 0xFFFF, 0x0000, 0xFFFF};
        colors[3] = (XRenderColor){0x0000, 0x0000, 0xFFFF, 0xFFFF};

        /* Linear gradient */
        linear.p1.x = XDoubleToFixed(0);
        linear.p1.y = XDoubleToFixed(0);
        linear.p2.x = XDoubleToFixed(256);
        linear.p2.y = XDoubleToFixed(256);

        grad_pic = XRenderCreateLinearGradient(dpy, &linear, stops, colors, 4);
        if (grad_pic) {
            XRenderComposite(dpy, PictOpSrc, grad_pic, None, dst_pic,
                           0, 0, 0, 0, 0, 0, 256, 256);
            XRenderFreePicture(dpy, grad_pic);
        }

        /* Radial gradient */
        radial.inner.x = XDoubleToFixed(128);
        radial.inner.y = XDoubleToFixed(128);
        radial.inner.radius = XDoubleToFixed(0);
        radial.outer.x = XDoubleToFixed(128);
        radial.outer.y = XDoubleToFixed(128);
        radial.outer.radius = XDoubleToFixed(128);

        grad_pic = XRenderCreateRadialGradient(dpy, &radial, stops, colors, 4);
        if (grad_pic) {
            XRenderComposite(dpy, PictOpSrc, grad_pic, None, dst_pic,
                           0, 0, 0, 0, 256, 0, 256, 256);
            XRenderFreePicture(dpy, grad_pic);
        }

        /* Conical gradient */
        XConicalGradient conical;
        conical.center.x = XDoubleToFixed(128);
        conical.center.y = XDoubleToFixed(384);
        conical.angle = XDoubleToFixed(0);

        grad_pic = XRenderCreateConicalGradient(dpy, &conical, stops, colors, 4);
        if (grad_pic) {
            XRenderComposite(dpy, PictOpSrc, grad_pic, None, dst_pic,
                           0, 0, 0, 0, 0, 256, 256, 256);
            XRenderFreePicture(dpy, grad_pic);
        }

        XFlush(dpy);
    }

    XRenderFreePicture(dpy, dst_pic);
    XFreePixmap(dpy, dst_pix);
}

/* Exercise solid fill and rectangle operations */
static void train_fill_ops(Display *dpy, Window win, int iterations) {
    int i, j;
    XRenderPictFormat *fmt;
    Pixmap pix;
    Picture pic;
    XRenderPictureAttributes pa;

    fmt = XRenderFindStandardFormat(dpy, PictStandardARGB32);
    if (!fmt) return;

    pix = XCreatePixmap(dpy, win, 1024, 1024, 32);
    memset(&pa, 0, sizeof(pa));
    pic = XRenderCreatePicture(dpy, pix, fmt, 0, &pa);

    for (i = 0; i < iterations; i++) {
        /* Many small rectangles */
        for (j = 0; j < 256; j++) {
            XRenderColor color = {
                (j * 257) & 0xFFFF,
                ((j * 37) << 8) & 0xFFFF,
                ((j * 73) << 8) & 0xFFFF,
                0xFFFF
            };
            XRenderFillRectangle(dpy, PictOpSrc, pic, &color,
                               (j % 16) * 64, (j / 16) * 64, 64, 64);
        }

        /* Overlapping semi-transparent rectangles */
        for (j = 0; j < 64; j++) {
            XRenderColor color = {0xFFFF, 0x8000, 0x0000, 0x4000};
            XRenderFillRectangle(dpy, PictOpOver, pic, &color,
                               j * 8, j * 8, 256, 256);
        }

        /* Create solid picture */
        XRenderColor solid = {0x8000, 0x8000, 0xFFFF, 0xC000};
        Picture solid_pic = XRenderCreateSolidFill(dpy, &solid);
        if (solid_pic) {
            XRenderComposite(dpy, PictOpOver, solid_pic, None, pic,
                           0, 0, 0, 0, 512, 512, 512, 512);
            XRenderFreePicture(dpy, solid_pic);
        }

        XFlush(dpy);
    }

    XRenderFreePicture(dpy, pic);
    XFreePixmap(dpy, pix);
}

/* Exercise trapezoid operations */
static void train_trapezoid_ops(Display *dpy, Window win, int iterations) {
    int i, j;
    XRenderPictFormat *fmt_argb, *fmt_a8;
    Pixmap src_pix, dst_pix;
    Picture src_pic, dst_pic;
    XRenderPictureAttributes pa;
    XTrapezoid traps[16];

    fmt_argb = XRenderFindStandardFormat(dpy, PictStandardARGB32);
    fmt_a8 = XRenderFindStandardFormat(dpy, PictStandardA8);
    if (!fmt_argb || !fmt_a8) return;

    src_pix = XCreatePixmap(dpy, win, 64, 64, 32);
    dst_pix = XCreatePixmap(dpy, win, 512, 512, 32);

    memset(&pa, 0, sizeof(pa));
    pa.repeat = RepeatNormal;
    src_pic = XRenderCreatePicture(dpy, src_pix, fmt_argb, CPRepeat, &pa);
    dst_pic = XRenderCreatePicture(dpy, dst_pix, fmt_argb, 0, &pa);

    /* Fill source with solid color */
    XRenderColor src_color = {0xFFFF, 0x4000, 0x4000, 0xFFFF};
    XRenderFillRectangle(dpy, PictOpSrc, src_pic, &src_color, 0, 0, 64, 64);

    for (i = 0; i < iterations; i++) {
        /* Clear destination */
        XRenderColor clear = {0x2000, 0x2000, 0x2000, 0xFFFF};
        XRenderFillRectangle(dpy, PictOpSrc, dst_pic, &clear, 0, 0, 512, 512);

        /* Create trapezoids */
        for (j = 0; j < 16; j++) {
            int base_x = (j % 4) * 128;
            int base_y = (j / 4) * 128;

            traps[j].top = XDoubleToFixed(base_y + 10);
            traps[j].bottom = XDoubleToFixed(base_y + 118);
            traps[j].left.p1.x = XDoubleToFixed(base_x + 20 + j);
            traps[j].left.p1.y = XDoubleToFixed(base_y + 10);
            traps[j].left.p2.x = XDoubleToFixed(base_x + 10);
            traps[j].left.p2.y = XDoubleToFixed(base_y + 118);
            traps[j].right.p1.x = XDoubleToFixed(base_x + 108 - j);
            traps[j].right.p1.y = XDoubleToFixed(base_y + 10);
            traps[j].right.p2.x = XDoubleToFixed(base_x + 118);
            traps[j].right.p2.y = XDoubleToFixed(base_y + 118);
        }

        XRenderCompositeTrapezoids(dpy, PictOpOver, src_pic, dst_pic,
                                   fmt_a8, 0, 0, traps, 16);

        XFlush(dpy);
    }

    XRenderFreePicture(dpy, src_pic);
    XRenderFreePicture(dpy, dst_pic);
    XFreePixmap(dpy, src_pix);
    XFreePixmap(dpy, dst_pix);
}

/* Exercise triangle operations */
static void train_triangle_ops(Display *dpy, Window win, int iterations) {
    int i, j;
    XRenderPictFormat *fmt_argb, *fmt_a8;
    Pixmap src_pix, dst_pix;
    Picture src_pic, dst_pic;
    XRenderPictureAttributes pa;
    XTriangle triangles[32];
    XPointFixed points[96];

    fmt_argb = XRenderFindStandardFormat(dpy, PictStandardARGB32);
    fmt_a8 = XRenderFindStandardFormat(dpy, PictStandardA8);
    if (!fmt_argb || !fmt_a8) return;

    src_pix = XCreatePixmap(dpy, win, 64, 64, 32);
    dst_pix = XCreatePixmap(dpy, win, 512, 512, 32);

    memset(&pa, 0, sizeof(pa));
    pa.repeat = RepeatNormal;
    src_pic = XRenderCreatePicture(dpy, src_pix, fmt_argb, CPRepeat, &pa);
    dst_pic = XRenderCreatePicture(dpy, dst_pix, fmt_argb, 0, &pa);

    XRenderColor src_color = {0x4000, 0xFFFF, 0x4000, 0xC000};
    XRenderFillRectangle(dpy, PictOpSrc, src_pic, &src_color, 0, 0, 64, 64);

    for (i = 0; i < iterations; i++) {
        XRenderColor clear = {0x1000, 0x1000, 0x1000, 0xFFFF};
        XRenderFillRectangle(dpy, PictOpSrc, dst_pic, &clear, 0, 0, 512, 512);

        /* Create triangles */
        for (j = 0; j < 32; j++) {
            int cx = (j % 8) * 64 + 32;
            int cy = (j / 8) * 128 + 64;
            int size = 25 + (j % 10);

            triangles[j].p1.x = XDoubleToFixed(cx);
            triangles[j].p1.y = XDoubleToFixed(cy - size);
            triangles[j].p2.x = XDoubleToFixed(cx - size);
            triangles[j].p2.y = XDoubleToFixed(cy + size);
            triangles[j].p3.x = XDoubleToFixed(cx + size);
            triangles[j].p3.y = XDoubleToFixed(cy + size);
        }

        XRenderCompositeTriangles(dpy, PictOpOver, src_pic, dst_pic,
                                  fmt_a8, 0, 0, triangles, 32);

        /* Also test triangle fan and strip */
        for (j = 0; j < 8; j++) {
            points[j].x = XDoubleToFixed(256 + 100 * ((j % 2) ? 1 : -1) * ((j / 2) % 2 ? 0.5 : 1.0));
            points[j].y = XDoubleToFixed(384 + j * 15);
        }
        XRenderCompositeTriFan(dpy, PictOpOver, src_pic, dst_pic,
                              fmt_a8, 0, 0, points, 8);

        for (j = 0; j < 10; j++) {
            points[j].x = XDoubleToFixed(64 + j * 20);
            points[j].y = XDoubleToFixed(450 + ((j % 2) ? 30 : 0));
        }
        XRenderCompositeTriStrip(dpy, PictOpOver, src_pic, dst_pic,
                                fmt_a8, 0, 0, points, 10);

        XFlush(dpy);
    }

    XRenderFreePicture(dpy, src_pic);
    XRenderFreePicture(dpy, dst_pic);
    XFreePixmap(dpy, src_pix);
    XFreePixmap(dpy, dst_pix);
}

/* Exercise transform operations */
static void train_transform_ops(Display *dpy, Window win, int iterations) {
    int i;
    XRenderPictFormat *fmt;
    Pixmap src_pix, dst_pix;
    Picture src_pic, dst_pic;
    XRenderPictureAttributes pa;
    XTransform transform;

    fmt = XRenderFindStandardFormat(dpy, PictStandardARGB32);
    if (!fmt) return;

    src_pix = XCreatePixmap(dpy, win, 256, 256, 32);
    dst_pix = XCreatePixmap(dpy, win, 512, 512, 32);

    memset(&pa, 0, sizeof(pa));
    src_pic = XRenderCreatePicture(dpy, src_pix, fmt, 0, &pa);
    dst_pic = XRenderCreatePicture(dpy, dst_pix, fmt, 0, &pa);

    /* Create a pattern in source */
    for (i = 0; i < 16; i++) {
        XRenderColor color = {
            (i & 1) ? 0xFFFF : 0,
            (i & 2) ? 0xFFFF : 0,
            (i & 4) ? 0xFFFF : 0,
            0xFFFF
        };
        XRenderFillRectangle(dpy, PictOpSrc, src_pic, &color,
                           (i % 4) * 64, (i / 4) * 64, 64, 64);
    }

    for (i = 0; i < iterations; i++) {
        double angle = (i * 0.1);
        double scale = 0.5 + (i % 20) * 0.05;
        double cos_a = cos(angle);
        double sin_a = sin(angle);

        /* Identity */
        memset(&transform, 0, sizeof(transform));
        transform.matrix[0][0] = XDoubleToFixed(1);
        transform.matrix[1][1] = XDoubleToFixed(1);
        transform.matrix[2][2] = XDoubleToFixed(1);
        XRenderSetPictureTransform(dpy, src_pic, &transform);
        XRenderComposite(dpy, PictOpSrc, src_pic, None, dst_pic,
                        0, 0, 0, 0, 0, 0, 256, 256);

        /* Scale */
        transform.matrix[0][0] = XDoubleToFixed(scale);
        transform.matrix[1][1] = XDoubleToFixed(scale);
        XRenderSetPictureTransform(dpy, src_pic, &transform);
        XRenderComposite(dpy, PictOpSrc, src_pic, None, dst_pic,
                        0, 0, 0, 0, 256, 0, 256, 256);

        /* Rotation */
        transform.matrix[0][0] = XDoubleToFixed(cos_a);
        transform.matrix[0][1] = XDoubleToFixed(-sin_a);
        transform.matrix[1][0] = XDoubleToFixed(sin_a);
        transform.matrix[1][1] = XDoubleToFixed(cos_a);
        XRenderSetPictureTransform(dpy, src_pic, &transform);
        XRenderComposite(dpy, PictOpSrc, src_pic, None, dst_pic,
                        0, 0, 0, 0, 0, 256, 256, 256);

        /* Set filter */
        XRenderSetPictureFilter(dpy, src_pic, FilterBilinear, NULL, 0);
        XRenderComposite(dpy, PictOpSrc, src_pic, None, dst_pic,
                        0, 0, 0, 0, 256, 256, 256, 256);

        XRenderSetPictureFilter(dpy, src_pic, FilterNearest, NULL, 0);

        XFlush(dpy);
    }

    XRenderFreePicture(dpy, src_pic);
    XRenderFreePicture(dpy, dst_pic);
    XFreePixmap(dpy, src_pix);
    XFreePixmap(dpy, dst_pix);
}

int main(int argc, char **argv) {
    Display *dpy;
    Window win;
    int screen;
    int event_base, error_base;
    int major, minor;
    int iterations = argc > 1 ? atoi(argv[1]) : WORKLOAD_ITERATIONS;

    fprintf(stderr, "XRender PGO Training starting...\n");

    dpy = XOpenDisplay(NULL);
    if (!dpy) {
        fprintf(stderr, "Cannot open display, skipping XRender training\n");
        return 0;
    }

    if (!XRenderQueryExtension(dpy, &event_base, &error_base)) {
        fprintf(stderr, "XRender extension not available\n");
        XCloseDisplay(dpy);
        return 0;
    }

    if (!XRenderQueryVersion(dpy, &major, &minor)) {
        fprintf(stderr, "Cannot query XRender version\n");
        XCloseDisplay(dpy);
        return 0;
    }

    fprintf(stderr, "XRender version %d.%d\n", major, minor);

    screen = DefaultScreen(dpy);
    win = XCreateSimpleWindow(dpy, RootWindow(dpy, screen),
                              0, 0, WINDOW_WIDTH, WINDOW_HEIGHT, 0,
                              BlackPixel(dpy, screen), BlackPixel(dpy, screen));

    fprintf(stderr, "Training: Format queries (%d iterations)...\n", iterations * 500);
    train_format_queries(dpy, iterations * 500);

    fprintf(stderr, "Training: Picture operations (%d iterations)...\n", iterations * 100);
    train_picture_ops(dpy, win, iterations * 100);

    fprintf(stderr, "Training: Composite operations (%d iterations)...\n", iterations * 200);
    train_composite_ops(dpy, win, iterations * 200);

    fprintf(stderr, "Training: Gradient operations (%d iterations)...\n", iterations * 100);
    train_gradient_ops(dpy, win, iterations * 100);

    fprintf(stderr, "Training: Fill operations (%d iterations)...\n", iterations * 100);
    train_fill_ops(dpy, win, iterations * 100);

    fprintf(stderr, "Training: Trapezoid operations (%d iterations)...\n", iterations * 50);
    train_trapezoid_ops(dpy, win, iterations * 50);

    fprintf(stderr, "Training: Triangle operations (%d iterations)...\n", iterations * 50);
    train_triangle_ops(dpy, win, iterations * 50);

    fprintf(stderr, "Training: Transform operations (%d iterations)...\n", iterations * 100);
    train_transform_ops(dpy, win, iterations * 100);

    XDestroyWindow(dpy, win);
    XCloseDisplay(dpy);

    fprintf(stderr, "XRender PGO Training complete.\n");
    return 0;
}
EOF
}

# Run the workload against the build directory using libtool
_run_xrender_workload() {
  local build_dir="$1"
  local pgo_flags="$2"
  local orig_cflags="$3"
  local orig_ldflags="$4"

  cd "$build_dir" || return 1

  local lib_dir="${build_dir}/src/.libs"
  local include_dir="${build_dir}/include"
  local libtool_la="src/libXrender.la"

  if [[ ! -f "$libtool_la" ]]; then
    echo "Error: Could not find $libtool_la"
    find "$build_dir" -name "*.la" -print 2>/dev/null
    return 1
  fi

  echo "Using libtool archive: $libtool_la"
  echo "Library directory: $lib_dir"
  ls -la "$lib_dir"/libXrender*.so* 2>/dev/null || echo "No libXrender shared libraries found"

  echo "Compiling XRender PGO workload using libtool..."

  CC="${CC:-clang}" \
  CFLAGS="${orig_cflags} ${pgo_flags}" \
  LDFLAGS="${orig_ldflags} ${pgo_flags}" \
  ./libtool --tag=CC --mode=link "${CC:-clang}" \
    "${srcdir}/xrender_pgo_workload.c" \
    -o "${srcdir}/xrender_pgo_runner" \
    -I"$include_dir" \
    -I"${srcdir}/libXrender-${pkgver}/include" \
    "$libtool_la" \
    -lX11 -lm \
    -Wl,-rpath,"$lib_dir" || { echo "Failed to compile workload"; return 1; }

  echo "Running XRender PGO workload..."
  "${srcdir}/xrender_pgo_runner" 5 || echo "Warning: Workload exited with non-zero status (may be missing display)"

  # Additional runs with varying parameters
  "${srcdir}/xrender_pgo_runner" 3 || true
  "${srcdir}/xrender_pgo_runner" 8 || true

  rm -f "${srcdir}/xrender_pgo_runner"
  return 0
}

build() {
  # --- Setup ---
  export CC="clang"
  export CXX="clang++"
  local _original_cflags="${CFLAGS}"
  local _original_cxxflags="${CXXFLAGS}"
  local _original_ldflags="${LDFLAGS}"

  local PGO_DATA_DIR="${srcdir}/pgo_data"
  local CS_PGO_DATA_DIR="${srcdir}/cspgo_data"
  mkdir -p "$PGO_DATA_DIR" "$CS_PGO_DATA_DIR"

  trap 'rm -rf "$PGO_DATA_DIR" "$CS_PGO_DATA_DIR" "${srcdir}/xrender_pgo_workload.c" "${srcdir}/xrender_pgo_runner"' EXIT

  local _configure_opts=(
    --prefix=/usr
    --disable-static
  )

  local pgo_failed=false
  # --- End Setup ---

  cd "${srcdir}/libXrender-${pkgver}"

  # --- Stage 1: PGO Instrumentation Build ---
  msg2 "Stage 1: Building PGO instrumented build..."

  local _pgo_gen_flags="-fprofile-generate=${PGO_DATA_DIR}"

  export CFLAGS="${_original_cflags} ${_pgo_gen_flags}"
  export CXXFLAGS="${_original_cxxflags} ${_pgo_gen_flags}"
  export LDFLAGS="${_original_ldflags} ${_pgo_gen_flags}"

  ./configure "${_configure_opts[@]}" || { echo "Configure failed (Stage 1)"; return 1; }
  make -j1 || { echo "Make failed (Stage 1)"; return 1; }

  # --- Stage 1: PGO Training Run ---
  msg2 "Stage 1: Running PGO training workloads..."
  export LLVM_PROFILE_FILE="${PGO_DATA_DIR}/libxrender-%p-%m.profraw"

  # Run custom workload
  _run_xrender_workload "$PWD" "${_pgo_gen_flags}" "${_original_cflags}" "${_original_ldflags}" || {
    echo "Custom workload failed (Stage 1)"
    pgo_failed=true
  }

  unset LLVM_PROFILE_FILE

  # --- Stage 1: Merge PGO Profiles ---
  msg2 "Stage 1: Merging PGO profiles..."
  sleep 1

  if ! find "$PGO_DATA_DIR" -name "*.profraw" 2>/dev/null | grep -q .; then
    echo "No raw PGO profile data (*.profraw) generated. Aborting PGO."
    pgo_failed=true
  elif ! $pgo_failed; then
    if ! llvm-profdata merge -output="${PGO_DATA_DIR}/default.profdata" "${PGO_DATA_DIR}"/*.profraw; then
      echo "llvm-profdata merge failed (Stage 1). Aborting PGO."
      pgo_failed=true
    elif [[ ! -s "${PGO_DATA_DIR}/default.profdata" ]]; then
      echo "Merged PGO profile data is empty (Stage 1). Aborting PGO."
      pgo_failed=true
    fi
    rm -f "${PGO_DATA_DIR}"/*.profraw
  fi
  # --- End Stage 1 ---

  # --- Stage 2: CS-PGO Instrumentation Build ---
  if ! $pgo_failed; then
    msg2 "Stage 2: Building CS-PGO instrumented build..."
    make distclean || echo "Warning: make distclean failed before Stage 2"

    if [[ ! -f configure ]]; then
      autoreconf -vfi || { echo "autoreconf failed before Stage 2"; pgo_failed=true; }
    fi

    if ! $pgo_failed; then
      local _cspgo_gen_flags="-fprofile-use=${PGO_DATA_DIR}/default.profdata -fcs-profile-generate=${CS_PGO_DATA_DIR}"

      export CFLAGS="${_original_cflags} ${_cspgo_gen_flags}"
      export CXXFLAGS="${_original_cxxflags} ${_cspgo_gen_flags}"
      export LDFLAGS="${_original_ldflags} ${_cspgo_gen_flags}"

      ./configure "${_configure_opts[@]}" || { echo "Configure failed (Stage 2)"; pgo_failed=true; }

      if ! $pgo_failed; then
        make -j"$(nproc)" || { echo "Make failed (Stage 2)"; pgo_failed=true; }
      fi
    fi
  fi
  # --- End Stage 2 ---

  # --- Stage 2: CS-PGO Training Run ---
  if ! $pgo_failed; then
    msg2 "Stage 2: Running CS-PGO training workloads..."
    export LLVM_PROFILE_FILE="${CS_PGO_DATA_DIR}/libxrender-cs-%p-%m.profraw"

    _run_xrender_workload "$PWD" "${_cspgo_gen_flags}" "${_original_cflags}" "${_original_ldflags}" || {
      echo "Custom workload failed (Stage 2)"
      pgo_failed=true
    }

    unset LLVM_PROFILE_FILE

    # --- Stage 2: Merge CS-PGO Profiles ---
    msg2 "Stage 2: Merging CS-PGO profiles..."
    sleep 1

    if ! find "$CS_PGO_DATA_DIR" -name "*.profraw" 2>/dev/null | grep -q .; then
      echo "Warning: No raw CS-PGO profile data generated. Using Stage 1 PGO data."
      cp "${PGO_DATA_DIR}/default.profdata" "${CS_PGO_DATA_DIR}/cs.profdata" || {
        echo "Failed to copy fallback profile data."
        pgo_failed=true
      }
    elif ! $pgo_failed; then
      if ! llvm-profdata merge -output="${CS_PGO_DATA_DIR}/cs.profdata" \
           "${CS_PGO_DATA_DIR}"/*.profraw "${PGO_DATA_DIR}/default.profdata"; then
        echo "llvm-profdata merge failed (Stage 2). Aborting CS-PGO."
        pgo_failed=true
      fi
      rm -f "${CS_PGO_DATA_DIR}"/*.profraw
    fi

    if ! $pgo_failed && [[ ! -s "${CS_PGO_DATA_DIR}/cs.profdata" ]]; then
      echo "Final merged CS-PGO profile is empty (Stage 2). Aborting CS-PGO."
      pgo_failed=true
    fi
  fi
  # --- End Stage 2 ---

  # --- Stage 3: Final Optimized Build ---
  msg2 "Stage 3: Building final optimized build..."
  make distclean || echo "Warning: make distclean failed before Stage 3"

  if [[ ! -f configure ]]; then
    autoreconf -vfi || { echo "autoreconf failed before Stage 3"; return 1; }
  fi

  CFLAGS="${_original_cflags}"
  CXXFLAGS="${_original_cxxflags}"
  LDFLAGS="${_original_ldflags}"

  if ! $pgo_failed; then
    local _final_opt_flags=""
    if [[ -s "${CS_PGO_DATA_DIR}/cs.profdata" ]]; then
      msg2 "Applying CS-PGO profile data for final build."
      _final_opt_flags="-fprofile-use=${CS_PGO_DATA_DIR}/cs.profdata"
    elif [[ -s "${PGO_DATA_DIR}/default.profdata" ]]; then
      msg2 "Applying fallback PGO profile data for final build."
      _final_opt_flags="-fprofile-use=${PGO_DATA_DIR}/default.profdata"
    else
      warning "No usable profile data found. Building without PGO."
    fi
    CFLAGS+=" ${_final_opt_flags}"
    CXXFLAGS+=" ${_final_opt_flags}"
    LDFLAGS+=" ${_final_opt_flags}"
  else
    warning "Building final version without PGO optimization due to previous errors."
  fi

  export CFLAGS CXXFLAGS LDFLAGS

  ./configure "${_configure_opts[@]}" || { echo "Configure failed (Stage 3)"; return 1; }
  make -j"$(nproc)" || { echo "Make failed (Stage 3)"; return 1; }
  # --- End Stage 3 ---

  if $pgo_failed; then
    warning "PGO optimization could not be fully applied. Package built without PGO."
  else
    msg "CS-PGO build process completed successfully."
  fi
}

package() {
  cd "${srcdir}/libXrender-${pkgver}"
  make DESTDIR="${pkgdir}" install

  install -Dm644 COPYING "${pkgdir}/usr/share/licenses/${pkgname}/COPYING"
}
