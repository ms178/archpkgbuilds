pkgname=irqbalance-git
pkgver=1.9.4.r83.g8e8945e
pkgrel=1
pkgdesc="A daemon to help balance the CPU load generated by interrupts across all of a systems CPUs"
arch=('i686' 'x86_64')
url="https://irqbalance.github.io/irqbalance/"
license=('GPL')
options=(!strip)
depends=('glibc' 'numactl' 'systemd-libs')
makedepends=('git' 'glib2' 'libcap-ng' 'ncurses' 'systemd' 'stress-ng' 'fio')
provides=('irqbalance')
conflicts=('irqbalance')
backup=('etc/irqbalance.env')
source=("git+https://github.com/Irqbalance/irqbalance.git" ms178.patch)
sha256sums=('SKIP')

prepare() {
  cd "irqbalance"
  # Apply patches
  for src in "${source[@]}"; do
    src="${src%%::*}"
    src="${src##*/}"
    [[ $src = *.patch ]] || continue
    patch -Np1 -i "../${src}"
  done

  # Create the training workload script
  cat > "$srcdir/training-workload.sh" << 'EOF'
#!/bin/bash
set -e

# Get number of CPUs for proper workload scaling
NUM_CPUS=$(nproc)
DURATION=45 # Reduced duration to be less taxing
WORKDIR=$(pwd)

# Create a cleanup function to ensure we terminate all child processes
cleanup() {
  echo "Stopping workload and cleaning up (trapped signal)..."
  # Use pkill to send TERM signal to all children of this script's process group
  pkill -P $$
  sleep 1
  # Force kill any that remain
  pkill -9 -P $$ 2>/dev/null || true
  # Clean up temporary files
  rm -f "$WORKDIR"/fiotest* "$WORKDIR"/temp_dd_file_* 2>/dev/null || true
  echo "Training workload cleanup completed."
}

# Set trap for various signals to ensure cleanup
trap cleanup EXIT INT TERM

# Function to run the specified program if it exists
run_if_available() {
  if command -v "$1" >/dev/null 2>&1; then
    "$@" &
    echo "Started $1 (PID: $!)"
    return 0
  else
    echo "Warning: $1 not available, skipping."
    return 1
  fi
}

echo "Starting irqbalance in debug/foreground mode..."
# Run irqbalance in the background
./irqbalance --debug --foreground 2>&1 | grep -v "Cannot change IRQ" | grep -v "affinity is now unmanaged" &

echo "Letting irqbalance initialize for 2 seconds..."
sleep 2

echo "Starting safer mixed workload for $DURATION seconds..."

# CPU and a more conservative memory stress
run_if_available stress-ng --cpu $NUM_CPUS --cpu-method all --vm 1 --vm-bytes 128M --timeout ${DURATION}s &

# I/O stress if fio is available, writing to the current directory
if command -v fio >/dev/null 2>&1; then
  fio --name=random-write --ioengine=posixaio --rw=randwrite --bs=4k --size=50m --numjobs=2 \
      --iodepth=8 --runtime=$((DURATION-5)) --time_based --end_fsync=1 \
      --filename="$WORKDIR/fiotest" &
fi

# Network activity (localhost)
run_if_available ping -i 0.1 -c 300 localhost &>/dev/null &

# Generate interrupts with disc I/O, writing to current directory to avoid filling /tmp
for i in $(seq 1 2); do
  dd if=/dev/zero of="$WORKDIR/temp_dd_file_$i" bs=1M count=20 conv=fsync &>/dev/null &
done

# Controlled system call storm to avoid PID exhaustion
if command -v find >/dev/null 2>&1 && command -v xargs >/dev/null 2>&1; then
    find /sys/devices -type f -readable -print0 2>/dev/null | xargs -0 -n 1 -P "$NUM_CPUS" head -c 1 >/dev/null 2>&1 &
fi

# Let everything run for the specified duration
echo "Waiting for $DURATION seconds to complete workload..."
sleep $DURATION

echo "Training workload completed."
EOF

  chmod +x "$srcdir/training-workload.sh"

  # The irq-monitor.sh script is fine, no changes needed there.
  cat > "$srcdir/irq-monitor.sh" << 'EOF'
#!/bin/bash
OUTFILE="$1"
INTERVAL=1
DURATION=45
cleanup() {
  echo "Terminating interrupt monitoring..."
}
trap cleanup EXIT INT TERM
if [ -z "$OUTFILE" ]; then
  OUTFILE="/tmp/irq_stats.txt"
fi
echo "Starting interrupt monitoring, writing to $OUTFILE"
echo "Time,Total IRQs,CPU Distribution" > "$OUTFILE"
start_time=$(date +%s)
end_time=$((start_time + DURATION))
while [ $(date +%s) -lt $end_time ]; do
  current=$(date +%s)
  elapsed=$((current - start_time))
  irq_total=$(grep -s "intr" /proc/stat | awk '{print $2}')
  irq_per_cpu=$(grep -s "intr" /proc/stat | cut -d' ' -f3- | tr ' ' ',')
  echo "$elapsed,$irq_total,$irq_per_cpu" >> "$OUTFILE"
  sleep $INTERVAL
done
echo "Monitoring complete. Statistics saved to $OUTFILE"
EOF

  chmod +x "$srcdir/irq-monitor.sh"
}

pkgver() {
  cd "irqbalance"

  git describe --long --tags | sed 's/^v//;s/\([^-]*-g\)/r\1/;s/-/./g'
}

build() {
  cd "irqbalance"

  # Store original flags
  CFLAGS_ORIG="$CFLAGS"
  CXXFLAGS_ORIG="$CXXFLAGS"
  LDFLAGS_ORIG="$LDFLAGS"

  # Stage 1: Instrumented build for PGO
  export LLVM_PROFILE_FILE="$srcdir/irqbalance-%p.profraw"
  CFLAGS+=" -g3 -fno-omit-frame-pointer -Xclang -mllvm -Xclang -vp-counters-per-site=50 -Xclang -mllvm -Xclang -runtime-counter-relocation -Xclang -mllvm -Xclang -enable-value-profiling -fprofile-generate"
  CXXFLAGS+=" -g3 -fno-omit-frame-pointer -Xclang -mllvm -Xclang -vp-counters-per-site=50 -Xclang -mllvm -Xclang -runtime-counter-relocation -Xclang -mllvm -Xclang -enable-value-profiling -fprofile-generate"
  LDFLAGS+=" -g3 -fno-omit-frame-pointer -Xclang -mllvm -Xclang -vp-counters-per-site=50 -Xclang -mllvm -Xclang -runtime-counter-relocation -Xclang -mllvm -Xclang -enable-value-profiling -fprofile-generate"

  # First build with instrumentation
  autoreconf -vfi || { echo "Error during autoreconf for PGO build"; exit 1; }
  ./configure \
    --prefix="/usr" \
    --sbindir="/usr/bin" \
    --with-systemd \
    --enable-debug || { echo "Error during configure for PGO build"; exit 1; }

  make || { echo "Error during make for PGO build"; exit 1; }

  # Run training workload to generate profile data
  echo "Running training workload for PGO data collection..."
  # Start the monitor in the background
  "$srcdir/irq-monitor.sh" "$srcdir/pgo_irq_stats.txt" &
  MONITOR_PID=$!

  # Run the training workload
  if ! "$srcdir/training-workload.sh"; then
    echo "Warning: Training workload failed, falling back to basic profiling"
    # Fallback to simple oneshot if training script fails
    ./irqbalance --oneshot --debug 2>&1 | grep -v "Cannot change IRQ" | grep -v "affinity is now unmanaged" || { echo "Warning: Error during basic profile data generation"; }
  fi

  # Kill the monitor if it's still running
  kill $MONITOR_PID 2>/dev/null || true
  wait $MONITOR_PID 2>/dev/null || true

  # Merge profile data
  echo "Merging profile data..."
  llvm-profdata merge -output="$srcdir/default.profdata" "$srcdir"/irqbalance-*.profraw || { echo "Error merging profile data"; exit 1; }
  rm -f "$srcdir"/irqbalance-*.profraw

  # Clean build directory
  make clean

  # Stage 2: CS-PGO instrumentation build using first profile data
  echo "Building with context-sensitive PGO instrumentation..."
  export LLVM_PROFILE_FILE="$srcdir/cs-irqbalance-%p.profraw"
  CFLAGS="$CFLAGS_ORIG -fprofile-use=$srcdir/default.profdata -fcs-profile-generate -g3 -fno-omit-frame-pointer -Xclang -mllvm -Xclang -vp-counters-per-site=50 -Xclang -mllvm -Xclang -runtime-counter-relocation -Xclang -mllvm -Xclang -enable-value-profiling"
  CXXFLAGS="$CXXFLAGS_ORIG -fprofile-use=$srcdir/default.profdata -fcs-profile-generate -g3 -fno-omit-frame-pointer -Xclang -mllvm -Xclang -vp-counters-per-site=50 -Xclang -mllvm -Xclang -runtime-counter-relocation -Xclang -mllvm -Xclang -enable-value-profiling"
  LDFLAGS="$LDFLAGS_ORIG -fprofile-use=$srcdir/default.profdata -fcs-profile-generate -g3 -fno-omit-frame-pointer -Xclang -mllvm -Xclang -vp-counters-per-site=50 -Xclang -mllvm -Xclang -runtime-counter-relocation -Xclang -mllvm -Xclang -enable-value-profiling"

  autoreconf -vfi || { echo "Error during autoreconf for CS-PGO build"; exit 1; }
  ./configure \
    --prefix="/usr" \
    --sbindir="/usr/bin" \
    --with-systemd \
    --enable-debug || { echo "Error during configure for CS-PGO build"; exit 1; }

  make || { echo "Error during make for CS-PGO build"; exit 1; }

  # Run the same training workload for CS-PGO
  echo "Running training workload for CS-PGO data collection..."
  "$srcdir/irq-monitor.sh" "$srcdir/cs_pgo_irq_stats.txt" &
  MONITOR_PID=$!

  if ! "$srcdir/training-workload.sh"; then
    echo "Warning: CS-PGO training workload failed, falling back to basic profiling"
    ./irqbalance --oneshot --debug 2>&1 | grep -v "Cannot change IRQ" | grep -v "affinity is now unmanaged" || { echo "Warning: Error during basic CS-PGO data generation"; }
  fi

  kill $MONITOR_PID 2>/dev/null || true
  wait $MONITOR_PID 2>/dev/null || true

  # Merge CS-PGO profile data with previous profile data
  echo "Merging CS-PGO profile data..."
  llvm-profdata merge -output="$srcdir/cs.profdata" "$srcdir"/cs-irqbalance-*.profraw "$srcdir/default.profdata" || { echo "Error merging CS-PGO profile data"; exit 1; }
  rm -f "$srcdir"/cs-irqbalance-*.profraw

  # Clean build directory
  make clean

  # Stage 3: Final build with merged CS-PGO profile data
  echo "Building with merged CS-PGO data..."
  CFLAGS="$CFLAGS_ORIG -fprofile-use=$srcdir/cs.profdata"
  CXXFLAGS="$CXXFLAGS_ORIG -fprofile-use=$srcdir/cs.profdata"
  LDFLAGS="$LDFLAGS_ORIG -fprofile-use=$srcdir/cs.profdata -Wl,--emit-relocs"

  autoreconf -vfi || { echo "Error during autoreconf for final build"; exit 1; }
  ./configure \
    --prefix="/usr" \
    --sbindir="/usr/bin" \
    --with-systemd \
    --disable-debug || { echo "Error during configure for final build"; exit 1; }

  make || { echo "Error during make for final build"; exit 1; }
}

check() {
  cd "$srcdir/irqbalance"

  # Create directory for BOLT data
  mkdir -p "$srcdir/bolt"

  # Step 1: Create an instrumented binary using BOLT instrumentation
  echo "Creating BOLT instrumented binary..."
  if ! llvm-bolt ./irqbalance --instrument \
    --instrumentation-file="$srcdir/bolt/irqbalance.fdata" -o "$srcdir/bolt/irqbalance.inst"; then
    echo "Warning: Failed to create BOLT instrumented binary. Skipping BOLT optimization."
    cp ./irqbalance "$srcdir/bolt_opt_failed"
    return 0
  fi

  # Make the instrumented binary executable
  chmod +x "$srcdir/bolt/irqbalance.inst"

  # Start the monitor in the background
  "$srcdir/irq-monitor.sh" "$srcdir/bolt_irq_stats.txt" &
  MONITOR_PID=$!

  # Step 2: Run the instrumented binary with the training workload
  echo "Running BOLT instrumented binary with training workload..."
  cd "$srcdir/bolt"

  # Create a symlink to make the training script work
  ln -sf irqbalance.inst irqbalance

  cp "$srcdir/training-workload.sh" .

  if ! ./training-workload.sh; then
    echo "Warning: BOLT instrumentation run failed. Trying simple workload..."
    ./irqbalance --oneshot --debug 2>&1 | grep -v "Cannot change IRQ" | grep -v "affinity is now unmanaged"
  fi

  # Kill the monitor if it's still running
  kill $MONITOR_PID 2>/dev/null || true
  wait $MONITOR_PID 2>/dev/null || true

  # Check if we generated the fdata file
  if [ ! -f "$srcdir/bolt/irqbalance.fdata" ]; then
    echo "Warning: No BOLT profile data was generated. Skipping BOLT optimization."
    cd "$srcdir/irqbalance"
    cp ./irqbalance "$srcdir/bolt_opt_failed"
    return 0
  fi

  # Return to the irqbalance directory
  cd "$srcdir/irqbalance"

  # Step 3: Use the collected data to create an optimized binary
  echo "Creating BOLT optimized binary..."
  mkdir -p "$srcdir/bolt_opt"

  if ! llvm-bolt ./irqbalance \
      --data "$srcdir/bolt/irqbalance.fdata" \
      --dyno-stats \
      --lite=false \
      --icf=all \
      --plt=all \
      --hugify \
      --peepholes=all \
      --indirect-call-promotion=all \
      --reorder-blocks=ext-tsp \
      --reorder-functions=cdsort \
      --split-all-cold \
      --split-eh \
      --split-functions \
      --split-strategy=cdsplit \
      --align-functions=32 --align-blocks --block-alignment=16 \
      --x86-strip-redundant-address-size \
      --frame-opt-rm-stores --frame-opt=all --hot-data \
      --jump-tables=aggressive \
      --stoke \
    -o "$srcdir/bolt_opt/irqbalance.bolt"; then
    echo "Warning: Error during BOLT optimization. Using original binary."
    cp ./irqbalance "$srcdir/bolt_opt_failed"
    return 0
  fi

  # Verify BOLT optimization was successful
  if [ -f "$srcdir/bolt_opt/irqbalance.bolt" ]; then
    # Compare file sizes to ensure BOLT didn't create an empty or corrupt file
    ORIG_SIZE=$(stat -c%s ./irqbalance)
    BOLT_SIZE=$(stat -c%s "$srcdir/bolt_opt/irqbalance.bolt")

    if [ "$BOLT_SIZE" -gt 1000 ] && [ "$BOLT_SIZE" -ne "$ORIG_SIZE" ]; then
      echo "BOLT optimization successful. Binary size: $BOLT_SIZE bytes (original: $ORIG_SIZE bytes)"
      cp "$srcdir/bolt_opt/irqbalance.bolt" ./irqbalance
    else
      echo "Warning: BOLT optimization produced suspicious binary. Using original binary."
      cp ./irqbalance "$srcdir/bolt_opt_failed"
    fi
  else
    echo "Warning: BOLT output file not found. Using original binary."
    cp ./irqbalance "$srcdir/bolt_opt_failed"
  fi
}

package() {
  cd "irqbalance"
  make DESTDIR="$pkgdir" install || { echo "Error during installation"; exit 1; }

  # Replace the binary with BOLT-optimized version
  if [ -f "$srcdir/bolt_opt_failed" ]; then
    echo "Warning: Using non-BOLT optimized binary due to earlier errors"
  fi
  install -Dm755 irqbalance "$pkgdir/usr/bin/irqbalance"

  install -Dm644 "misc/irqbalance.env" -t "$pkgdir/etc" || { echo "Error installing env file"; exit 1; }
  install -Dm644 "misc/irqbalance.service" -t "$pkgdir/usr/lib/systemd/system" || { echo "Error installing service file"; exit 1; }

  # Use llvm-strip only on recognized file formats
  find "$pkgdir" -type f \( -name '*.so' -o -name '*.a' -o -executable \) -print0 | while IFS= read -r -d '' file; do
    if file "$file" | grep -q "ELF"; then
      if ! llvm-strip --strip-unneeded "$file" 2>/dev/null && ! llvm-strip --strip-all "$file" 2>/dev/null; then
        echo "Warning: Failed to strip $file" >&2
      else
        echo "Stripped: $file"
      fi
    else
      echo "Skipping: $file (not a valid ELF object file)" >&2
    fi
  done

  # Copy profiling statistics if they exist
  if [ -f "$srcdir/pgo_irq_stats.txt" ] || [ -f "$srcdir/bolt_irq_stats.txt" ]; then
    mkdir -p "$pkgdir/usr/share/irqbalance/"
    [ -f "$srcdir/pgo_irq_stats.txt" ] && cp "$srcdir/pgo_irq_stats.txt" "$pkgdir/usr/share/irqbalance/"
    [ -f "$srcdir/bolt_irq_stats.txt" ] && cp "$srcdir/bolt_irq_stats.txt" "$pkgdir/usr/share/irqbalance/"
  fi
}
