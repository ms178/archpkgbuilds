pkgname=irqbalance-git
pkgver=1.9.4.r83.g8e8945e
pkgrel=1
pkgdesc="A daemon to help balance the CPU load generated by interrupts across all of a systems CPUs (PGO+CS-PGO+BOLT optimized)"
arch=('x86_64')
url="https://irqbalance.github.io/irqbalance/"
license=('GPL')
options=(!strip)
depends=('glibc' 'numactl' 'systemd-libs')
makedepends=('git' 'glib2' 'libcap-ng' 'ncurses' 'systemd' 'stress-ng' 'fio' 'clang' 'llvm' 'lld' 'bolt')
provides=('irqbalance')
conflicts=('irqbalance')
backup=('etc/irqbalance.env')
source=("git+https://github.com/Irqbalance/irqbalance.git"
        "ms178.patch")
sha256sums=('SKIP'
            'SKIP')

prepare() {
  cd "irqbalance"

  # Apply patches
  for src in "${source[@]}"; do
    src="${src%%::*}"
    src="${src##*/}"
    [[ $src = *.patch ]] || continue
    echo "Applying patch: ${src}"
    patch -Np1 -i "../${src}"
  done

  # Create comprehensive training workload for gaming optimization
  cat > "$srcdir/training-workload.sh" << 'EOF'
#!/bin/bash
set -e

NUM_CPUS=$(nproc)
DURATION=180

cleanup() {
  echo "Cleaning up workload processes..."
  pkill -P $$ 2>/dev/null || true
  jobs -p | xargs -r kill 2>/dev/null || true
  pkill -9 -P $$ 2>/dev/null || true

  rm -f /tmp/irq_train_* 2>/dev/null || true
  rm -f /tmp/fio_test_* 2>/dev/null || true

  echo "Cleanup complete"
}

trap cleanup EXIT INT TERM

echo "=== Starting Gaming-Optimized IRQ Training Workload ==="
echo "Duration: ${DURATION}s, CPUs: ${NUM_CPUS}"

# Start irqbalance in foreground
echo "Starting irqbalance daemon..."
if [ -f "./irqbalance" ]; then
  ./irqbalance --foreground --debug 2>&1 | grep -vE "(Cannot change IRQ|affinity is now unmanaged|permission denied)" &
elif [ -f "./irqbalance.inst" ]; then
  ./irqbalance.inst --foreground --debug 2>&1 | grep -vE "(Cannot change IRQ|affinity is now unmanaged|permission denied)" &
else
  echo "ERROR: irqbalance binary not found"
  exit 1
fi
IRQ_PID=$!
echo "IRQ daemon started (PID: $IRQ_PID)"

sleep 3

echo "Starting comprehensive interrupt simulation..."

# 1. CPU-intensive gaming workload
if command -v stress-ng >/dev/null 2>&1; then
  stress-ng --cpu $((NUM_CPUS - 2)) --cpu-method all \
            --vm 2 --vm-bytes 512M \
            --switch $((NUM_CPUS * 4)) \
            --timeout ${DURATION}s &
  echo "Started CPU stress (PID: $!)"
fi

# 2. Realistic disk I/O patterns
if command -v fio >/dev/null 2>&1; then
  TEMP_DIR=$(mktemp -d)

  fio --name=game-read --directory=$TEMP_DIR --ioengine=libaio \
      --rw=randread --bs=64k --size=500m --numjobs=4 --iodepth=32 \
      --runtime=$((DURATION - 10)) --time_based --group_reporting &

  fio --name=game-rw --directory=$TEMP_DIR --ioengine=libaio \
      --rw=randrw --rwmixread=70 --bs=4k-16k --size=200m --numjobs=2 \
      --iodepth=16 --runtime=$((DURATION - 10)) --time_based &

  echo "Started I/O patterns (PID: $!)"
fi

# 3. Network interrupt simulation
if command -v ping >/dev/null 2>&1; then
  for i in $(seq 1 4); do
    ping -f -c 50000 localhost >/dev/null 2>&1 &
  done
  echo "Started network simulation"
fi

# 4. GPU-related interrupts via sync operations
for i in $(seq 1 20); do
  (while true; do sync; sleep 0.01; done) &
done
echo "Started sync operations"

# 5. File system operations
for i in $(seq 1 $NUM_CPUS); do
  (
    while true; do
      find /usr/lib -type f -name "*.so*" -exec head -c 4096 {} \; >/dev/null 2>&1
      sleep 0.1
    done
  ) &
done
echo "Started filesystem operations"

# 6. Memory pressure
for i in $(seq 1 3); do
  dd if=/dev/zero of=/tmp/irq_train_$i bs=1M count=100 oflag=direct 2>/dev/null &
done

# 7. Interrupt bursts
(
  for burst in $(seq 1 10); do
    echo "Interrupt burst $burst/10"
    for i in $(seq 1 100); do
      dd if=/dev/urandom of=/tmp/irq_train_burst bs=4K count=1 oflag=direct 2>/dev/null
    done
    sleep $((DURATION / 10))
  done
) &

# 8. Context switching simulation
for i in $(seq 1 $((NUM_CPUS * 2))); do
  (while true; do sleep 0.001; done) &
done

echo "All workload components started, running for ${DURATION}s..."
echo "Monitoring IRQ distribution..."

# Monitor interrupt distribution
for i in $(seq 1 $((DURATION / 10))); do
  if [ -f /proc/interrupts ]; then
    TOTAL_IRQS=$(awk 'NR>1 {sum+=$2} END {print sum}' /proc/interrupts 2>/dev/null || echo "0")
    echo "[$((i * 10))s] Total interrupts: $TOTAL_IRQS"
  fi
  sleep 10
done

echo "=== Training workload completed successfully ==="
EOF

  chmod +x "$srcdir/training-workload.sh"
}

pkgver() {
  cd "irqbalance"
  git describe --long --tags | sed 's/^v//;s/\([^-]*-g\)/r\1/;s/-/./g'
}

build() {
  cd "irqbalance"

  # Force clang/lld
  export CC=clang
  export CXX=clang++
  export LD=ld.lld
  export AR=llvm-ar
  export NM=llvm-nm
  export RANLIB=llvm-ranlib

  # Store original flags and add LTO
  local -a BASE_CFLAGS=($CFLAGS -flto -fuse-ld=lld)
  local -a BASE_CXXFLAGS=($CXXFLAGS -flto -fuse-ld=lld)
  local -a BASE_LDFLAGS=($LDFLAGS -flto -fuse-ld=lld -Wl,--lto-O3)

  ###########################################################################
  # Stage 1: Standard PGO
  ###########################################################################
  echo "=== Stage 1: PGO Instrumentation ==="

  unset LLVM_PROFILE_FILE
  export LLVM_PROFILE_FILE="$srcdir/pgo-data/irqbalance-%p-%m.profraw"
  mkdir -p "$srcdir/pgo-data"

  local -a PGO_FLAGS=(
    -fprofile-generate="$srcdir/pgo-data"
    -fno-omit-frame-pointer
    -mllvm -vp-counters-per-site=100
    -mllvm -enable-value-profiling
  )

  export CFLAGS="${BASE_CFLAGS[*]} ${PGO_FLAGS[*]}"
  export CXXFLAGS="${BASE_CXXFLAGS[*]} ${PGO_FLAGS[*]}"
  export LDFLAGS="${BASE_LDFLAGS[*]} ${PGO_FLAGS[*]}"

  autoreconf -vfi
  ./configure \
    --prefix="/usr" \
    --sbindir="/usr/bin" \
    --with-systemd \
    --enable-debug

  make -j1

  # PGO Training
  echo "=== Running PGO training workload ==="
  if ! "$srcdir/training-workload.sh"; then
    echo "WARNING: Training failed, using fallback"
    ./irqbalance --oneshot --debug 2>&1 | grep -v "Cannot change IRQ" || true
  fi

  # Verify and merge profiles
  echo "Merging PGO profiles..."
  local PROFILE_COUNT=$(find "$srcdir/pgo-data" -name "*.profraw" -size +1k | wc -l)
  if [ $PROFILE_COUNT -eq 0 ]; then
    echo "ERROR: No valid PGO profiles generated"
    exit 1
  fi
  echo "Found $PROFILE_COUNT profile files"

  llvm-profdata merge -output="$srcdir/pgo-data/default.profdata" "$srcdir/pgo-data"/*.profraw

  local PROFILE_SIZE=$(stat -c%s "$srcdir/pgo-data/default.profdata")
  echo "PGO profile size: $((PROFILE_SIZE / 1024))KB"

  if [ $PROFILE_SIZE -lt 10000 ]; then
    echo "WARNING: PGO profile suspiciously small"
  fi

  rm -f "$srcdir/pgo-data"/*.profraw
  make clean

  ###########################################################################
  # Stage 2: CS-PGO
  ###########################################################################
  echo "=== Stage 2: CS-PGO Instrumentation ==="

  unset LLVM_PROFILE_FILE
  export LLVM_PROFILE_FILE="$srcdir/cspgo-data/irqbalance-%p-%m.profraw"
  mkdir -p "$srcdir/cspgo-data"

  local -a CSPGO_FLAGS=(
    -fprofile-use="$srcdir/pgo-data/default.profdata"
    -fcs-profile-generate="$srcdir/cspgo-data"
    -fno-omit-frame-pointer
    -mllvm -vp-counters-per-site=100
  )

  export CFLAGS="${BASE_CFLAGS[*]} ${CSPGO_FLAGS[*]}"
  export CXXFLAGS="${BASE_CXXFLAGS[*]} ${CSPGO_FLAGS[*]}"
  export LDFLAGS="${BASE_LDFLAGS[*]} ${CSPGO_FLAGS[*]}"

  autoreconf -vfi
  ./configure \
    --prefix="/usr" \
    --sbindir="/usr/bin" \
    --with-systemd \
    --enable-debug

  make -j1

  # CS-PGO Training
  echo "=== Running CS-PGO training workload ==="
  if ! "$srcdir/training-workload.sh"; then
    echo "WARNING: CS-PGO training failed, using fallback"
    ./irqbalance --oneshot --debug 2>&1 | grep -v "Cannot change IRQ" || true
  fi

  # Merge CS-PGO profiles
  echo "Merging CS-PGO profiles..."
  PROFILE_COUNT=$(find "$srcdir/cspgo-data" -name "*.profraw" -size +1k | wc -l)
  echo "Found $PROFILE_COUNT CS-PGO profile files"

  llvm-profdata merge -output="$srcdir/cspgo-data/cs.profdata" \
    "$srcdir/cspgo-data"/*.profraw \
    "$srcdir/pgo-data/default.profdata"

  PROFILE_SIZE=$(stat -c%s "$srcdir/cspgo-data/cs.profdata")
  echo "CS-PGO profile size: $((PROFILE_SIZE / 1024))KB"

  rm -f "$srcdir/cspgo-data"/*.profraw
  make clean

  ###########################################################################
  # Stage 3: Final optimized build
  ###########################################################################
  echo "=== Stage 3: Final PGO-optimized build ==="

  unset LLVM_PROFILE_FILE

  export CFLAGS="${BASE_CFLAGS[*]} -fprofile-use=$srcdir/cspgo-data/cs.profdata"
  export CXXFLAGS="${BASE_CXXFLAGS[*]} -fprofile-use=$srcdir/cspgo-data/cs.profdata"
  export LDFLAGS="${BASE_LDFLAGS[*]} -fprofile-use=$srcdir/cspgo-data/cs.profdata -Wl,--emit-relocs"

  autoreconf -vfi
  ./configure \
    --prefix="/usr" \
    --sbindir="/usr/bin" \
    --with-systemd \
    --disable-debug

  make

  ###########################################################################
  # Stage 4: BOLT Optimization
  ###########################################################################
  echo "=== Stage 4: BOLT Optimization ==="

  mkdir -p "$srcdir/bolt-data"

  # Backup original
  cp irqbalance irqbalance.cspgo

  # Create instrumented binary
  if ! llvm-bolt irqbalance.cspgo \
      --instrument \
      --instrumentation-file-append-pid \
      --instrumentation-file="$srcdir/bolt-data/irqbalance.fdata" \
      -o irqbalance.bolt.inst; then
    echo "WARNING: BOLT instrumentation failed, skipping BOLT"
    return 0
  fi

  chmod +x irqbalance.bolt.inst

  # BOLT training
  echo "=== Running BOLT training workload ==="
  cp irqbalance.bolt.inst irqbalance

  if ! "$srcdir/training-workload.sh"; then
    echo "WARNING: BOLT training failed"
    ./irqbalance --oneshot --debug 2>&1 | grep -v "Cannot change IRQ" || true
  fi

  # Check BOLT profiles
  local BOLT_PROFILE_COUNT=$(find "$srcdir/bolt-data" -name "*.fdata*" -size +1k 2>/dev/null | wc -l)

  if [ $BOLT_PROFILE_COUNT -eq 0 ]; then
    echo "WARNING: No BOLT profiles generated, skipping optimization"
    cp irqbalance.cspgo irqbalance
    return 0
  fi

  echo "Found $BOLT_PROFILE_COUNT BOLT profile files"

  # Merge BOLT profiles
  if command -v merge-fdata >/dev/null 2>&1; then
    merge-fdata "$srcdir/bolt-data"/irqbalance.fdata.* > "$srcdir/bolt-data/merged.fdata" 2>/dev/null || {
      echo "WARNING: BOLT merge failed"
      cp irqbalance.cspgo irqbalance
      return 0
    }
  else
    echo "WARNING: merge-fdata not found"
    cp irqbalance.cspgo irqbalance
    return 0
  fi

  local MERGED_SIZE=$(stat -c%s "$srcdir/bolt-data/merged.fdata" 2>/dev/null || echo 0)
  if [ $MERGED_SIZE -lt 1000 ]; then
    echo "WARNING: BOLT profile too small, skipping"
    cp irqbalance.cspgo irqbalance
    return 0
  fi

  echo "BOLT merged profile size: $((MERGED_SIZE / 1024))KB"

  # Apply BOLT optimization
  if ! llvm-bolt irqbalance.cspgo \
      --data "$srcdir/bolt-data/merged.fdata" \
      --dyno-stats \
      --lite=false \
      --icf=all \
      --plt=all \
      --hugify \
      --peepholes=all \
      --x86-strip-redundant-address-size \
      --indirect-call-promotion=all \
      --reorder-blocks=ext-tsp \
      --reorder-functions=cdsort \
      --split-all-cold \
      --split-eh \
      --split-functions \
      --split-strategy=cdsplit \
      --align-functions=32 \
      --align-blocks \
      --block-alignment=16 \
      -o irqbalance.bolt; then
    echo "WARNING: BOLT optimization failed"
    cp irqbalance.cspgo irqbalance
    return 0
  fi

  # Verify BOLT binary
  local ORIG_SIZE=$(stat -c%s irqbalance.cspgo)
  local BOLT_SIZE=$(stat -c%s irqbalance.bolt)

  if [ $BOLT_SIZE -lt 10000 ]; then
    echo "WARNING: BOLT binary suspiciously small"
    cp irqbalance.cspgo irqbalance
    return 0
  fi

  echo "BOLT optimization successful: ${ORIG_SIZE} -> ${BOLT_SIZE} bytes"
  cp irqbalance.bolt irqbalance
}

package() {
  cd "irqbalance"

  make DESTDIR="$pkgdir" install

  install -Dm644 "misc/irqbalance.env" "$pkgdir/etc/irqbalance.env"
  install -Dm644 "misc/irqbalance.service" "$pkgdir/usr/lib/systemd/system/irqbalance.service"

  # Strip with llvm-strip
  if [ -f irqbalance ] && file irqbalance | grep -q ELF; then
    llvm-strip --strip-unneeded irqbalance 2>/dev/null || llvm-strip --strip-all irqbalance 2>/dev/null || true
  fi

  install -Dm755 irqbalance "$pkgdir/usr/bin/irqbalance"

  # Install optimization stats
  mkdir -p "$pkgdir/usr/share/doc/irqbalance"
  echo "Build optimizations: PGO + CS-PGO + BOLT + LTO" > "$pkgdir/usr/share/doc/irqbalance/OPTIMIZATIONS.txt"

  if [ -f "$srcdir/pgo-data/default.profdata" ]; then
    echo "PGO profile: $(stat -c%s $srcdir/pgo-data/default.profdata) bytes" >> "$pkgdir/usr/share/doc/irqbalance/OPTIMIZATIONS.txt"
  fi
  if [ -f "$srcdir/cspgo-data/cs.profdata" ]; then
    echo "CS-PGO profile: $(stat -c%s $srcdir/cspgo-data/cs.profdata) bytes" >> "$pkgdir/usr/share/doc/irqbalance/OPTIMIZATIONS.txt"
  fi
  if [ -f "$srcdir/bolt-data/merged.fdata" ]; then
    echo "BOLT profile: $(stat -c%s $srcdir/bolt-data/merged.fdata) bytes" >> "$pkgdir/usr/share/doc/irqbalance/OPTIMIZATIONS.txt"
  fi
}
