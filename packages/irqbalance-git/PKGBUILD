pkgname=irqbalance-git
pkgver=1.9.4.r83.g8e8945e
pkgrel=1
pkgdesc="A daemon to help balance the CPU load generated by interrupts across all of a systems CPUs"
arch=('i686' 'x86_64')
url="https://irqbalance.github.io/irqbalance/"
license=('GPL')
options=(!strip)
depends=('glibc' 'numactl' 'systemd-libs')
makedepends=('git' 'glib2' 'libcap-ng' 'ncurses' 'systemd' 'stress-ng' 'fio')
provides=('irqbalance')
conflicts=('irqbalance')
backup=('etc/irqbalance.env')
source=("git+https://github.com/Irqbalance/irqbalance.git" ms178.patch)
sha256sums=('SKIP')

prepare() {
  cd "irqbalance"
  # Apply patches
  for src in "${source[@]}"; do
    src="${src%%::*}"
    src="${src##*/}"
    [[ $src = *.patch ]] || continue
    patch -Np1 -i "../${src}"
  done
  # Create the training workload script
  cat > "$srcdir/training-workload.sh" << 'EOF'
#!/bin/bash
set -e

# Get number of CPUs for proper workload scaling
NUM_CPUS=$(nproc)
DURATION=60

# Create a cleanup function to ensure we terminate all processes
cleanup() {
  echo "Stopping workload and cleaning up (pid: $$)..."

  # Kill all child processes with their process groups
  pkill -P $$ || true

  # Specifically kill processes we know about
  if [ -n "$IRQ_PID" ]; then kill $IRQ_PID 2>/dev/null || true; fi
  if [ -n "$STRESS_PID" ]; then kill $STRESS_PID 2>/dev/null || true; fi
  if [ -n "$FIO_PID" ]; then kill $FIO_PID 2>/dev/null || true; fi
  if [ -n "$PING_PID" ]; then kill $PING_PID 2>/dev/null || true; fi

  # Clean up other process groups
  for pid in $DD_PIDS $FIND_PIDS; do
    if [ -n "$pid" ]; then kill $pid 2>/dev/null || true; fi
  done

  # Force kill any remaining descendants
  pkill -9 -P $$ 2>/dev/null || true

  # Clean up temporary files
  if [ -n "$TEMP_FIO_FILE" ] && [ -f "$TEMP_FIO_FILE" ]; then
    rm -f "$TEMP_FIO_FILE" 2>/dev/null || true
  fi
  for i in $(seq 1 3); do
    rm -f /tmp/temp_dd_file_$i 2>/dev/null || true
  done

  echo "Training workload cleanup completed"
}

# Set trap for various signals to ensure cleanup
trap cleanup EXIT INT TERM

# Function to run the specified program if it exists
run_if_available() {
  if command -v "$1" >/dev/null 2>&1; then
    "$@" &
    local pid=$!
    echo "Started $1 (PID: $pid)"
    return 0
  else
    echo "Warning: $1 not available, skipping"
    return 1
  fi
}

# Start irqbalance in debug mode
# We're going to ignore permission errors, they're expected when running without root
echo "Starting irqbalance in debug/foreground mode..."
./irqbalance --debug --foreground 2>&1 | grep -v "Cannot change IRQ" | grep -v "affinity is now unmanaged" &
IRQ_PID=$!

echo "Letting irqbalance initialize for 2 seconds..."
sleep 2

echo "Starting mixed workload for $DURATION seconds..."

# CPU and memory stress
run_if_available stress-ng --cpu $NUM_CPUS --cpu-method all --vm $(($NUM_CPUS/2)) --vm-bytes 256M --timeout ${DURATION}s &
STRESS_PID=$!

# I/O stress if fio is available
if command -v fio >/dev/null 2>&1; then
  TEMP_FIO_FILE=$(mktemp -d)/fiotest
  fio --name=random-write --ioengine=posixaio --rw=randwrite --bs=4k --size=100m --numjobs=4 --iodepth=16 --runtime=$((DURATION-10)) --time_based --end_fsync=1 --filename=$TEMP_FIO_FILE &
  FIO_PID=$!
  echo "Started fio (PID: $FIO_PID)"
fi

# Network activity (localhost)
if command -v ping >/dev/null 2>&1; then
  ping -c 1000 localhost >/dev/null 2>&1 &
  PING_PID=$!
  echo "Started ping (PID: $PING_PID)"
fi

# Generate interrupts with disc I/O
DD_PIDS=""
for i in $(seq 1 3); do
  dd if=/dev/zero of=/tmp/temp_dd_file_$i bs=1M count=50 conv=fsync &>/dev/null &
  DD_PIDS="$DD_PIDS $!"
done

# Interrupt system calls
for i in $(seq 1 50); do
  sync &
done

# Random system operations that generate interrupts
FIND_PIDS=""
for i in $(seq 1 3); do
  find /proc -type f -maxdepth 3 -readable -exec head -n1 {} \; >/dev/null 2>&1 &
  FIND_PIDS="$FIND_PIDS $!"
done

# Let everything run for the specified duration
echo "Waiting for $DURATION seconds to complete workload..."
sleep $DURATION

# Cleanup is handled by the EXIT trap
echo "Training workload completed"
EOF

  chmod +x "$srcdir/training-workload.sh"

  # Create a separate script for monitoring
  cat > "$srcdir/irq-monitor.sh" << 'EOF'
#!/bin/bash
# Monitor script to collect interrupt statistics during training

OUTFILE="$1"
INTERVAL=1
DURATION=60

# Cleanup function for proper termination
cleanup() {
  echo "Terminating interrupt monitoring..."
  # Nothing specific to clean up here
}

# Set trap for various signals
trap cleanup EXIT INT TERM

if [ -z "$OUTFILE" ]; then
  OUTFILE="/tmp/irq_stats.txt"
fi

echo "Starting interrupt monitoring, writing to $OUTFILE"
echo "Time,Total IRQs,CPU Distribution" > "$OUTFILE"

start_time=$(date +%s)
end_time=$((start_time + DURATION))

while [ $(date +%s) -lt $end_time ]; do
  # Get current time
  current=$(date +%s)
  elapsed=$((current - start_time))

  # Get interrupt counts
  irq_total=$(grep -s "intr" /proc/stat | awk '{print $2}')
  irq_per_cpu=$(grep -s "intr" /proc/stat | cut -d' ' -f3- | tr ' ' ',')

  # Log the data
  echo "$elapsed,$irq_total,$irq_per_cpu" >> "$OUTFILE"

  sleep $INTERVAL
done

echo "Monitoring complete. Statistics saved to $OUTFILE"
EOF

  chmod +x "$srcdir/irq-monitor.sh"
}

pkgver() {
  cd "irqbalance"

  git describe --long --tags | sed 's/^v//;s/\([^-]*-g\)/r\1/;s/-/./g'
}

build() {
  cd "irqbalance"

  # Store original flags
  CFLAGS_ORIG="$CFLAGS"
  CXXFLAGS_ORIG="$CXXFLAGS"
  LDFLAGS_ORIG="$LDFLAGS"

  # Stage 1: Instrumented build for PGO
  export LLVM_PROFILE_FILE="$srcdir/irqbalance-%p.profraw"
  CFLAGS+=" -g3 -fno-omit-frame-pointer -Xclang -mllvm -Xclang -vp-counters-per-site=50 -Xclang -mllvm -Xclang -runtime-counter-relocation -Xclang -mllvm -Xclang -enable-value-profiling -fprofile-generate"
  CXXFLAGS+=" -g3 -fno-omit-frame-pointer -Xclang -mllvm -Xclang -vp-counters-per-site=50 -Xclang -mllvm -Xclang -runtime-counter-relocation -Xclang -mllvm -Xclang -enable-value-profiling -fprofile-generate"
  LDFLAGS+=" -g3 -fno-omit-frame-pointer -Xclang -mllvm -Xclang -vp-counters-per-site=50 -Xclang -mllvm -Xclang -runtime-counter-relocation -Xclang -mllvm -Xclang -enable-value-profiling -fprofile-generate"

  # First build with instrumentation
  autoreconf -vfi || { echo "Error during autoreconf for PGO build"; exit 1; }
  ./configure \
    --prefix="/usr" \
    --sbindir="/usr/bin" \
    --with-systemd \
    --enable-debug || { echo "Error during configure for PGO build"; exit 1; }

  make || { echo "Error during make for PGO build"; exit 1; }

  # Run training workload to generate profile data
  echo "Running training workload for PGO data collection..."
  # Start the monitor in the background
  "$srcdir/irq-monitor.sh" "$srcdir/pgo_irq_stats.txt" &
  MONITOR_PID=$!

  # Run the training workload
  if ! "$srcdir/training-workload.sh"; then
    echo "Warning: Training workload failed, falling back to basic profiling"
    # Fallback to simple oneshot if training script fails
    ./irqbalance --oneshot --debug 2>&1 | grep -v "Cannot change IRQ" | grep -v "affinity is now unmanaged" || { echo "Warning: Error during basic profile data generation"; }
  fi

  # Kill the monitor if it's still running
  kill $MONITOR_PID 2>/dev/null || true
  wait $MONITOR_PID 2>/dev/null || true

  # Merge profile data
  echo "Merging profile data..."
  llvm-profdata merge -output="$srcdir/default.profdata" "$srcdir"/irqbalance-*.profraw || { echo "Error merging profile data"; exit 1; }
  rm -f "$srcdir"/irqbalance-*.profraw

  # Clean build directory
  make clean

  # Stage 2: CS-PGO instrumentation build using first profile data
  echo "Building with context-sensitive PGO instrumentation..."
  export LLVM_PROFILE_FILE="$srcdir/cs-irqbalance-%p.profraw"
  CFLAGS="$CFLAGS_ORIG -fprofile-use=$srcdir/default.profdata -fcs-profile-generate -g3 -fno-omit-frame-pointer -Xclang -mllvm -Xclang -vp-counters-per-site=50 -Xclang -mllvm -Xclang -runtime-counter-relocation -Xclang -mllvm -Xclang -enable-value-profiling"
  CXXFLAGS="$CXXFLAGS_ORIG -fprofile-use=$srcdir/default.profdata -fcs-profile-generate -g3 -fno-omit-frame-pointer -Xclang -mllvm -Xclang -vp-counters-per-site=50 -Xclang -mllvm -Xclang -runtime-counter-relocation -Xclang -mllvm -Xclang -enable-value-profiling"
  LDFLAGS="$LDFLAGS_ORIG -fprofile-use=$srcdir/default.profdata -fcs-profile-generate -g3 -fno-omit-frame-pointer -Xclang -mllvm -Xclang -vp-counters-per-site=50 -Xclang -mllvm -Xclang -runtime-counter-relocation -Xclang -mllvm -Xclang -enable-value-profiling"

  autoreconf -vfi || { echo "Error during autoreconf for CS-PGO build"; exit 1; }
  ./configure \
    --prefix="/usr" \
    --sbindir="/usr/bin" \
    --with-systemd \
    --enable-debug || { echo "Error during configure for CS-PGO build"; exit 1; }

  make || { echo "Error during make for CS-PGO build"; exit 1; }

  # Run the same training workload for CS-PGO
  echo "Running training workload for CS-PGO data collection..."
  "$srcdir/irq-monitor.sh" "$srcdir/cs_pgo_irq_stats.txt" &
  MONITOR_PID=$!

  if ! "$srcdir/training-workload.sh"; then
    echo "Warning: CS-PGO training workload failed, falling back to basic profiling"
    ./irqbalance --oneshot --debug 2>&1 | grep -v "Cannot change IRQ" | grep -v "affinity is now unmanaged" || { echo "Warning: Error during basic CS-PGO data generation"; }
  fi

  kill $MONITOR_PID 2>/dev/null || true
  wait $MONITOR_PID 2>/dev/null || true

  # Merge CS-PGO profile data with previous profile data
  echo "Merging CS-PGO profile data..."
  llvm-profdata merge -output="$srcdir/cs.profdata" "$srcdir"/cs-irqbalance-*.profraw "$srcdir/default.profdata" || { echo "Error merging CS-PGO profile data"; exit 1; }
  rm -f "$srcdir"/cs-irqbalance-*.profraw

  # Clean build directory
  make clean

  # Stage 3: Final build with merged CS-PGO profile data
  echo "Building with merged CS-PGO data..."
  CFLAGS="$CFLAGS_ORIG -fprofile-use=$srcdir/cs.profdata"
  CXXFLAGS="$CXXFLAGS_ORIG -fprofile-use=$srcdir/cs.profdata"
  LDFLAGS="$LDFLAGS_ORIG -fprofile-use=$srcdir/cs.profdata -Wl,--emit-relocs"

  autoreconf -vfi || { echo "Error during autoreconf for final build"; exit 1; }
  ./configure \
    --prefix="/usr" \
    --sbindir="/usr/bin" \
    --with-systemd \
    --disable-debug || { echo "Error during configure for final build"; exit 1; }

  make || { echo "Error during make for final build"; exit 1; }
}

check() {
  cd "$srcdir/irqbalance"

  # Create directory for BOLT data
  mkdir -p "$srcdir/bolt"

  # Step 1: Create an instrumented binary using BOLT instrumentation
  echo "Creating BOLT instrumented binary..."
  if ! llvm-bolt ./irqbalance --instrument \
    --instrumentation-file="$srcdir/bolt/irqbalance.fdata" -o "$srcdir/bolt/irqbalance.inst"; then
    echo "Warning: Failed to create BOLT instrumented binary. Skipping BOLT optimization."
    cp ./irqbalance "$srcdir/bolt_opt_failed"
    return 0
  fi

  # Make the instrumented binary executable
  chmod +x "$srcdir/bolt/irqbalance.inst"

  # Start the monitor in the background
  "$srcdir/irq-monitor.sh" "$srcdir/bolt_irq_stats.txt" &
  MONITOR_PID=$!

  # Step 2: Run the instrumented binary with the training workload
  echo "Running BOLT instrumented binary with training workload..."
  cd "$srcdir/bolt"

  # Create a symlink to make the training script work
  ln -sf irqbalance.inst irqbalance

  cp "$srcdir/training-workload.sh" .

  if ! ./training-workload.sh; then
    echo "Warning: BOLT instrumentation run failed. Trying simple workload..."
    ./irqbalance --oneshot --debug 2>&1 | grep -v "Cannot change IRQ" | grep -v "affinity is now unmanaged"
  fi

  # Kill the monitor if it's still running
  kill $MONITOR_PID 2>/dev/null || true
  wait $MONITOR_PID 2>/dev/null || true

  # Check if we generated the fdata file
  if [ ! -f "$srcdir/bolt/irqbalance.fdata" ]; then
    echo "Warning: No BOLT profile data was generated. Skipping BOLT optimization."
    cd "$srcdir/irqbalance"
    cp ./irqbalance "$srcdir/bolt_opt_failed"
    return 0
  fi

  # Return to the irqbalance directory
  cd "$srcdir/irqbalance"

  # Step 3: Use the collected data to create an optimized binary
  echo "Creating BOLT optimized binary..."
  mkdir -p "$srcdir/bolt_opt"

  if ! llvm-bolt ./irqbalance \
    --data "$srcdir/bolt/irqbalance.fdata" \
    --dyno-stats \
    --lite=false \
    --hugify \
    --frame-opt=all \
    --icf=all \
    --jump-tables=aggressive \
    --min-branch-clusters \
    --stoke \
    --sctc-mode=always \
    --plt=all \
    --hot-data \
    --frame-opt-rm-stores \
    --peepholes=all \
    --infer-stale-profile=1 \
    --x86-strip-redundant-address-size \
    --indirect-call-promotion=all \
    --reorder-blocks=ext-tsp \
    --reorder-functions=cdsort \
    --split-all-cold \
    --split-eh \
    --split-functions \
    -o "$srcdir/bolt_opt/irqbalance.bolt"; then
    echo "Warning: Error during BOLT optimization. Using original binary."
    cp ./irqbalance "$srcdir/bolt_opt_failed"
    return 0
  fi

  # Verify BOLT optimization was successful
  if [ -f "$srcdir/bolt_opt/irqbalance.bolt" ]; then
    # Compare file sizes to ensure BOLT didn't create an empty or corrupt file
    ORIG_SIZE=$(stat -c%s ./irqbalance)
    BOLT_SIZE=$(stat -c%s "$srcdir/bolt_opt/irqbalance.bolt")

    if [ "$BOLT_SIZE" -gt 1000 ] && [ "$BOLT_SIZE" -ne "$ORIG_SIZE" ]; then
      echo "BOLT optimization successful. Binary size: $BOLT_SIZE bytes (original: $ORIG_SIZE bytes)"
      cp "$srcdir/bolt_opt/irqbalance.bolt" ./irqbalance
    else
      echo "Warning: BOLT optimization produced suspicious binary. Using original binary."
      cp ./irqbalance "$srcdir/bolt_opt_failed"
    fi
  else
    echo "Warning: BOLT output file not found. Using original binary."
    cp ./irqbalance "$srcdir/bolt_opt_failed"
  fi
}

package() {
  cd "irqbalance"
  make DESTDIR="$pkgdir" install || { echo "Error during installation"; exit 1; }

  # Replace the binary with BOLT-optimized version
  if [ -f "$srcdir/bolt_opt_failed" ]; then
    echo "Warning: Using non-BOLT optimized binary due to earlier errors"
  fi
  install -Dm755 irqbalance "$pkgdir/usr/bin/irqbalance"

  install -Dm644 "misc/irqbalance.env" -t "$pkgdir/etc" || { echo "Error installing env file"; exit 1; }
  install -Dm644 "misc/irqbalance.service" -t "$pkgdir/usr/lib/systemd/system" || { echo "Error installing service file"; exit 1; }

  # Use llvm-strip only on recognized file formats
  find "$pkgdir" -type f \( -name '*.so' -o -name '*.a' -o -executable \) -print0 | while IFS= read -r -d '' file; do
    if file "$file" | grep -q "ELF"; then
      if ! llvm-strip --strip-unneeded "$file" 2>/dev/null && ! llvm-strip --strip-all "$file" 2>/dev/null; then
        echo "Warning: Failed to strip $file" >&2
      else
        echo "Stripped: $file"
      fi
    else
      echo "Skipping: $file (not a valid ELF object file)" >&2
    fi
  done

  # Copy profiling statistics if they exist
  if [ -f "$srcdir/pgo_irq_stats.txt" ] || [ -f "$srcdir/bolt_irq_stats.txt" ]; then
    mkdir -p "$pkgdir/usr/share/irqbalance/"
    [ -f "$srcdir/pgo_irq_stats.txt" ] && cp "$srcdir/pgo_irq_stats.txt" "$pkgdir/usr/share/irqbalance/"
    [ -f "$srcdir/bolt_irq_stats.txt" ] && cp "$srcdir/bolt_irq_stats.txt" "$pkgdir/usr/share/irqbalance/"
  fi
}
