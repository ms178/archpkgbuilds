--- a/irqbalance.c	2025-07-25 09:57:10.367498037 +0200
+++ b/irqbalance.c	2025-07-25 10:09:59.245051955 +0200
@@ -61,7 +61,7 @@ unsigned long long cycle_count = 0;
 char *pidfile = NULL;
 char *polscript = NULL;
 long HZ;
-int sleep_interval = SLEEP_INTERVAL;
+int sleep_interval = 60;
 int last_interval;
 GMainLoop *main_loop;
 
@@ -272,126 +272,128 @@ gboolean force_rescan(gpointer data __at
 
 gboolean scan(gpointer data __attribute__((unused)))
 {
-	log(TO_CONSOLE, LOG_INFO, "\n\n\n-----------------------------------------------------------------------------\n");
-	clear_work_stats();
-	parse_proc_interrupts();
+    if (log_mask & TO_CONSOLE)
+        log(TO_CONSOLE, LOG_INFO, "\n\n\n-----------------------------------------------------------------------------\n");
+    clear_work_stats();
+    parse_proc_interrupts();
+
+    /* cope with cpu hotplug -- detected during /proc/interrupts parsing */
+    while (keep_going && (need_rescan || need_rebuild)) {
+        int try_times = 0;
+
+        need_rescan = 0;
+        cycle_count = 0;
+        if (log_mask & TO_CONSOLE)
+            log(TO_CONSOLE, LOG_INFO, "Rescanning cpu topology \n");
+        clear_work_stats();
+
+        do {
+            free_object_tree();
+            if (++try_times > 3) {
+                if (log_mask & TO_CONSOLE)
+                    log(TO_CONSOLE, LOG_WARNING, "Rescanning cpu topology: fail\n");
+                goto out;
+            }
+
+            need_rebuild = 0;
+            build_object_tree();
+            if (need_rebuild) {
+                usleep(100000);  /* Optimized delay only on retry to stabilize topology without spinning */
+            }
+        } while (need_rebuild);
+
+        for_each_irq(NULL, force_rebalance_irq, NULL);
+        clear_slots();
+        parse_proc_interrupts();
+        parse_proc_stat();
+        return TRUE;
+    }
 
+    parse_proc_stat();
 
-	/* cope with cpu hotplug -- detected during /proc/interrupts parsing */
-	while (keep_going && (need_rescan || need_rebuild)) {
-		int try_times = 0;
-
-		need_rescan = 0;
-		cycle_count = 0;
-		log(TO_CONSOLE, LOG_INFO, "Rescanning cpu topology \n");
-		clear_work_stats();
-
-		do {
-			free_object_tree();
-			if (++try_times > 3) {
-				log(TO_CONSOLE, LOG_WARNING, "Rescanning cpu topology: fail\n");
-				goto out;
-			}
+    if (cycle_count)
+        update_migration_status();
 
-			need_rebuild = 0;
-			build_object_tree();
-		} while (need_rebuild);
-
-		for_each_irq(NULL, force_rebalance_irq, NULL);
-		clear_slots();
-		parse_proc_interrupts();
-		parse_proc_stat();
-		return TRUE;
-	}
-
-	parse_proc_stat();
-
-	if (cycle_count)	
-		update_migration_status();
-
-	calculate_placement();
-	activate_mappings();
+    calculate_placement();
+    activate_mappings();
 
 out:
-	if (debug_mode)
-		dump_tree();
-	if (one_shot_mode)
-		keep_going = 0;
-	cycle_count++;
-
-	/* sleep_interval may be changed by socket */
-	if (last_interval != sleep_interval) {
-		last_interval = sleep_interval;
-		g_timeout_add_seconds(sleep_interval, scan, NULL);
-		return FALSE;
-	}
+    if (debug_mode)
+        dump_tree();
+    if (one_shot_mode)
+        keep_going = 0;
+    cycle_count++;
+
+    /* sleep_interval may be changed by socket */
+    if (last_interval != sleep_interval) {
+        last_interval = sleep_interval;
+        g_timeout_add_seconds(sleep_interval, scan, NULL);
+        return FALSE;
+    }
+
+    if (keep_going) {
+        return TRUE;
+    }
 
-	if (keep_going) {
-		return TRUE;
-	}
-
-	g_main_loop_quit(main_loop);
-	return FALSE;
+    g_main_loop_quit(main_loop);
+    return FALSE;
 }
 
 void get_irq_data(struct irq_info *irq, void *data)
 {
-	char **irqdata = (char **)data;
-	char *newptr = NULL;
-
-	if (!*irqdata)
-		newptr = calloc(24 + 1 + 11 + 20 + 20 + 11, 1);
-	else
-		newptr = realloc(*irqdata, strlen(*irqdata) + 24 + 1 + 11 + 20 + 20 + 11);
-
-	if (!newptr)
+	GString **str = (GString **)data;
+	if (*str == NULL) {
+		/* OOM fallback: silently skip to avoid crash, maintain stability */
 		return;
-
-	*irqdata = newptr;
-
-	sprintf(*irqdata + strlen(*irqdata),
-			"IRQ %d LOAD %" PRIu64 " DIFF %" PRIu64 " CLASS %d ", irq->irq, irq->load,
-			(irq->irq_count - irq->last_irq_count), irq->class);
+	}
+	g_string_append_printf(*str, "IRQ %d LOAD %" PRIu64 " DIFF %" PRIu64 " CLASS %d ", irq->irq, irq->load,
+						   (irq->irq_count - irq->last_irq_count), irq->class);
 }
 
 void get_object_stat(struct topo_obj *object, void *data)
 {
-	char **stats = (char **)data;	
-	char *irq_data = NULL;
-	char *newptr = NULL;
-	size_t irqdlen;
-
-	if (g_list_length(object->interrupts) > 0) {
-		for_each_irq(object->interrupts, get_irq_data, &irq_data);
+	char **stats = (char **)data;
+	GString *irq_str = g_string_new("");
+	if (irq_str == NULL) {
+		/* OOM: Set empty to continue safely */
+		return;
 	}
 
-	irqdlen = irq_data ? strlen(irq_data) : 0;
-	/*
-	 * Note, the size in both conditional branches below is made up as follows:
-	 * strlen(irq_data) - self explanitory
-	 * 31 - The size of "TYPE  NUMBER  LOAD  SAVE_MODE  "
-	 * 11 - The maximal size of a %d printout
-	 * 20 - The maximal size of a %lu printout
-	 * 1 - The trailing string terminator
-	 * This should be adjusted if the string in the sprintf is changed
-	 */
-	if (!*stats) {
-		newptr = calloc(irqdlen + 31 + 11 + 20 + 11 + 1, 1);
-	} else {
-		newptr = realloc(*stats, strlen(*stats) + irqdlen + 31 + 11 + 20 + 11 + 1);
+	if (g_list_length(object->interrupts) > 0) {
+		for_each_irq(object->interrupts, get_irq_data, &irq_str);
 	}
 
-	if (!newptr) {
-		free(irq_data);
+	GString *obj_str = g_string_new("");
+	if (obj_str == NULL) {
+		g_string_free(irq_str, TRUE);
 		return;
 	}
+	g_string_append_printf(obj_str, "TYPE %d NUMBER %d LOAD %" PRIu64 " SAVE_MODE %d %s",
+						   object->obj_type, object->number, object->load,
+						object->powersave_mode, irq_str->str);
+
+	char *new_stats = NULL;
+	if (*stats && **stats) {
+		new_stats = g_strconcat(*stats, obj_str->str, NULL);
+		if (new_stats == NULL) {
+			/* OOM: Keep original *stats to avoid data loss */
+			g_string_free(irq_str, TRUE);
+			g_string_free(obj_str, TRUE);
+			return;
+		}
+		free(*stats);
+		*stats = new_stats;
+	} else {
+		*stats = g_strdup(obj_str->str);
+		if (*stats == NULL) {
+			/* OOM: Set to empty string */
+			*stats = g_strdup("");
+		}
+	}
 
-	*stats = newptr;
+	g_string_free(irq_str, TRUE);
+	g_string_free(obj_str, TRUE);
 
-	sprintf(*stats + strlen(*stats), "TYPE %d NUMBER %d LOAD %" PRIu64 " SAVE_MODE %d %s",
-			object->obj_type, object->number, object->load,
-			object->powersave_mode, irq_data ? irq_data : "");
-	free(irq_data);
 	if (object->obj_type != OBJ_TYPE_CPU) {
 		for_each_object(object->children, get_object_stat, data);
 	}
@@ -400,149 +402,153 @@ void get_object_stat(struct topo_obj *ob
 #ifdef HAVE_IRQBALANCEUI
 gboolean sock_handle(gint fd, GIOCondition condition, gpointer user_data __attribute__((unused)))
 {
-	char buff[16384];
-	int sock;
-	int recv_size = 0;
-	int valid_user = 0;
-
-	struct iovec iov = { buff, sizeof(buff) };
-	struct msghdr msg = {
-		.msg_iov = &iov,
-		.msg_iovlen = 1,
-		.msg_control = g_malloc(CMSG_SPACE(sizeof(struct ucred))),
-		.msg_controllen = CMSG_SPACE(sizeof(struct ucred)),
-	};
-
-	struct cmsghdr *cmsg;
-
-	if (condition == G_IO_IN) {
-		sock = accept(fd, NULL, NULL);
-		if (sock < 0) {
-			log(TO_ALL, LOG_WARNING, "Connection couldn't be accepted.\n");
-			goto out;
-		}
-		recv_size = recvmsg(sock, &msg, 0);
-		if (recv_size < 0) {
-			log(TO_ALL, LOG_WARNING, "Error while receiving data.\n");
-			goto out_close;
-		}
-		if (recv_size == sizeof(buff)) {
-			log(TO_ALL, LOG_WARNING, "Received command too long.\n");
-			goto out_close;
-		}
-		cmsg = CMSG_FIRSTHDR(&msg);
-		if (!cmsg) {
-			log(TO_ALL, LOG_WARNING, "Connection no memory.\n");
-			goto out_close;
-		}
-		if ((cmsg->cmsg_level == SOL_SOCKET) &&
-				(cmsg->cmsg_type == SCM_CREDENTIALS)) {
-			struct ucred *credentials = (struct ucred *) CMSG_DATA(cmsg);
-			if (!credentials->uid) {
-				valid_user = 1;
-			}
-		}
-		if (!valid_user) {
-			log(TO_ALL, LOG_INFO, "Permission denied for user to connect to socket.\n");
-			goto out_close;
-		}
-
-		if (g_str_has_prefix(buff, "stats")) {
-			char *stats = NULL;
-			for_each_object(numa_nodes, get_object_stat, &stats);
-			send(sock, stats, strlen(stats), 0);
-			free(stats);
-		}
-		if (g_str_has_prefix(buff, "settings ")) {
-			if (g_str_has_prefix(buff + strlen("settings "), "sleep ")) {
-				char *sleep_string = malloc(
-						sizeof(char) * (recv_size - strlen("settings sleep ") + 1));
-
-				if (!sleep_string)
-					goto out_close;
-				strncpy(sleep_string, buff + strlen("settings sleep "),
-						recv_size - strlen("settings sleep "));
-				sleep_string[recv_size - strlen("settings sleep ")] = '\0';
-				int new_iterval = strtoul(sleep_string, NULL, 10);
-				if (new_iterval >= 1) {
-					sleep_interval = new_iterval;
-				}
-				free(sleep_string);
-			} else if (g_str_has_prefix(buff + strlen("settings "), "ban irqs ")) {
-				char *end;
-				char *irq_string = malloc(
-						sizeof(char) * (recv_size - strlen("settings ban irqs ") + 1));
-
-				if (!irq_string)
-					goto out_close;
-				strncpy(irq_string, buff + strlen("settings ban irqs "),
-						recv_size - strlen("settings ban irqs "));
-				irq_string[recv_size - strlen("settings ban irqs ")] = '\0';
-				g_list_free_full(cl_banned_irqs, free);
-				cl_banned_irqs = NULL;
-				need_rescan = 1;
-				if (g_str_has_prefix(irq_string, "NONE")) {
-					free(irq_string);
-					goto out_close;
-				}
-				int irq = strtoul(irq_string, &end, 10);
-				do {
-					add_cl_banned_irq(irq);
-				} while((irq = strtoul(end, &end, 10)));
-				free(irq_string);
-			} else if (g_str_has_prefix(buff + strlen("settings "), "cpus ")) {
-				banned_cpumask_from_ui = NULL;
-				free(cpu_ban_string);
-				cpu_ban_string = NULL;
-
-				cpu_ban_string = malloc(
-						sizeof(char) * (recv_size - strlen("settings cpus ") + 1));
-
-				if (!cpu_ban_string)
-					goto out_close;
-				strncpy(cpu_ban_string, buff + strlen("settings cpus "),
-						recv_size - strlen("settings cpus "));
-				cpu_ban_string[recv_size - strlen("settings cpus ")] = '\0';
-				banned_cpumask_from_ui = strtok(cpu_ban_string, " ");
-				if (banned_cpumask_from_ui && g_str_has_prefix(banned_cpumask_from_ui, "NULL")) {
-					banned_cpumask_from_ui = NULL;
-					free(cpu_ban_string);
-					cpu_ban_string = NULL;
-				}
-				need_rescan = 1;
-			}
-		}
-		if (g_str_has_prefix(buff, "setup")) {
-			char banned[512];
-			char *setup = calloc(strlen("SLEEP  ") + 11 + 1, 1);
-			char *newptr = NULL;
-
-			if (!setup)
-				goto out_close;
-			snprintf(setup, strlen("SLEEP  ") + 11 + 1, "SLEEP %d ", sleep_interval);
-			if(g_list_length(cl_banned_irqs) > 0) {
-				for_each_irq(cl_banned_irqs, get_irq_data, &setup);
-			}
-			cpumask_scnprintf(banned, 512, banned_cpus);
-			newptr = realloc(setup, strlen(setup) + strlen(banned) + 7 + 1);
-			if (!newptr)
-				goto out_free_setup;
-
-			setup = newptr;
-			snprintf(setup + strlen(setup), strlen(banned) + 7 + 1,
-					"BANNED %s", banned);
-			send(sock, setup, strlen(setup), 0);
+    char buff[16384];
+    int sock;
+    int recv_size = 0;
+    int valid_user = 0;
+
+    struct iovec iov = { buff, sizeof(buff) };
+    struct msghdr msg = {
+        .msg_iov = &iov,
+        .msg_iovlen = 1,
+        .msg_control = g_malloc(CMSG_SPACE(sizeof(struct ucred))),
+        .msg_controllen = CMSG_SPACE(sizeof(struct ucred)),
+    };
+
+    struct cmsghdr *cmsg;
+
+    if (condition == G_IO_IN) {
+        sock = accept(fd, NULL, NULL);
+        if (sock < 0) {
+            log(TO_ALL, LOG_WARNING, "Connection couldn't be accepted.\n");
+            goto out;
+        }
+        recv_size = recvmsg(sock, &msg, 0);
+        if (recv_size < 0) {
+            log(TO_ALL, LOG_WARNING, "Error while receiving data.\n");
+            goto out_close;
+        }
+        if (recv_size == sizeof(buff)) {
+            log(TO_ALL, LOG_WARNING, "Received command too long.\n");
+            goto out_close;
+        }
+        buff[recv_size] = '\0';  /* Ensure null-termination */
+        cmsg = CMSG_FIRSTHDR(&msg);
+        if (!cmsg) {
+            log(TO_ALL, LOG_WARNING, "Connection no memory.\n");
+            goto out_close;
+        }
+        if ((cmsg->cmsg_level == SOL_SOCKET) &&
+            (cmsg->cmsg_type == SCM_CREDENTIALS)) {
+            struct ucred *credentials = (struct ucred *) CMSG_DATA(cmsg);
+            if (!credentials->uid) {
+                valid_user = 1;
+            }
+        }
+        if (!valid_user) {
+            log(TO_ALL, LOG_INFO, "Permission denied for user to connect to socket.\n");
+            goto out_close;
+        }
+
+        if (g_str_has_prefix(buff, "stats")) {
+            char *stats = NULL;
+            for_each_object(numa_nodes, get_object_stat, &stats);
+            if (stats) {
+                send(sock, stats, strlen(stats), 0);
+                free(stats);
+            }
+        }
+        if (g_str_has_prefix(buff, "settings ")) {
+            if (g_str_has_prefix(buff + strlen("settings "), "sleep ")) {
+                __auto_type offset = strlen("settings sleep ");
+                if (recv_size - offset >= sizeof("1") && recv_size - offset < 32) {  /* Check length to avoid truncation/invalid parse */
+                    char sleep_buf[32];
+                    strncpy(sleep_buf, buff + offset, sizeof(sleep_buf) - 1);
+                    sleep_buf[sizeof(sleep_buf) - 1] = '\0';
+                    int new_iterval = strtoul(sleep_buf, NULL, 10);
+                    if (new_iterval >= 1) {
+                        sleep_interval = new_iterval;
+                    }
+                } else {
+                    log(TO_ALL, LOG_WARNING, "Invalid sleep command length.\n");
+                }
+            } else if (g_str_has_prefix(buff + strlen("settings "), "ban irqs ")) {
+                __auto_type offset = strlen("settings ban irqs ");
+                if (recv_size - offset >= sizeof("1") && recv_size - offset < 256) {  /* Check length to avoid truncation/invalid parse */
+                    char irq_buf[256];
+                    strncpy(irq_buf, buff + offset, sizeof(irq_buf) - 1);
+                    irq_buf[sizeof(irq_buf) - 1] = '\0';
+                    char *end;
+                    g_list_free_full(cl_banned_irqs, free);
+                    cl_banned_irqs = NULL;
+                    need_rescan = 1;
+                    if (g_str_has_prefix(irq_buf, "NONE")) {
+                        goto out_close;
+                    }
+                    int irq = strtoul(irq_buf, &end, 10);
+                    do {
+                        add_cl_banned_irq(irq);
+                    } while ((irq = strtoul(end, &end, 10)));
+                } else {
+                    log(TO_ALL, LOG_WARNING, "Invalid ban irqs command length.\n");
+                }
+            } else if (g_str_has_prefix(buff + strlen("settings "), "cpus ")) {
+                banned_cpumask_from_ui = NULL;
+                free(cpu_ban_string);
+                cpu_ban_string = NULL;
+
+                __auto_type offset = strlen("settings cpus ");
+                if (recv_size - offset > 0) {
+                    cpu_ban_string = malloc(sizeof(char) * (recv_size - offset + 1));
+                    if (!cpu_ban_string) {
+                        log(TO_ALL, LOG_WARNING, "Malloc failed for cpu_ban_string.\n");
+                        goto out_close;
+                    }
+                    strncpy(cpu_ban_string, buff + offset, recv_size - offset);
+                    cpu_ban_string[recv_size - offset] = '\0';
+                    banned_cpumask_from_ui = strtok(cpu_ban_string, " ");
+                    if (banned_cpumask_from_ui && g_str_has_prefix(banned_cpumask_from_ui, "NULL")) {
+                        banned_cpumask_from_ui = NULL;
+                        free(cpu_ban_string);
+                        cpu_ban_string = NULL;
+                    }
+                    need_rescan = 1;
+                } else {
+                    log(TO_ALL, LOG_WARNING, "Invalid cpus command length.\n");
+                }
+            }
+        }
+        if (g_str_has_prefix(buff, "setup")) {
+            char banned[512];
+            char *setup = calloc(strlen("SLEEP  ") + 11 + 1, 1);
+            char *newptr = NULL;
+
+            if (!setup)
+                goto out_close;
+            snprintf(setup, strlen("SLEEP  ") + 11 + 1, "SLEEP %d ", sleep_interval);
+            if (g_list_length(cl_banned_irqs) > 0) {
+                for_each_irq(cl_banned_irqs, get_irq_data, &setup);
+            }
+            cpumask_scnprintf(banned, 512, banned_cpus);
+            newptr = realloc(setup, strlen(setup) + strlen(banned) + 7 + 1);
+            if (!newptr)
+                goto out_free_setup;
+
+            setup = newptr;
+            snprintf(setup + strlen(setup), strlen(banned) + 7 + 1,
+                     "BANNED %s", banned);
+            send(sock, setup, strlen(setup), 0);
 out_free_setup:
-			free(setup);
-		}
+            free(setup);
+        }
 
 out_close:
-		close(sock);
-	}
+        close(sock);
+    }
 
 out:
-	g_free(msg.msg_control);
-	return TRUE;
+    g_free(msg.msg_control);
+    return TRUE;
 }
 
 int init_socket(void)
@@ -592,11 +598,11 @@ int main(int argc, char** argv)
 	int ret = EXIT_SUCCESS;
 
 	sigemptyset(&sigset);
-	sigaddset(&sigset,SIGINT);
-	sigaddset(&sigset,SIGHUP);
-	sigaddset(&sigset,SIGTERM);
-	sigaddset(&sigset,SIGUSR1);
-	sigaddset(&sigset,SIGUSR2);
+	sigaddset(&sigset, SIGINT);
+	sigaddset(&sigset, SIGHUP);
+	sigaddset(&sigset, SIGTERM);
+	sigaddset(&sigset, SIGUSR1);
+	sigaddset(&sigset, SIGUSR2);
 	sigprocmask(SIG_BLOCK, &sigset, &old_sigset);
 
 	parse_command_line(argc, argv);
@@ -607,27 +613,27 @@ int main(int argc, char** argv)
 	 * INVOCATION_ID.
 	 */
 	if (getenv("INVOCATION_ID")) {
-		journal_logging=1;
-		foreground_mode=1;
+		journal_logging = 1;
+		foreground_mode = 1;
 	}
 
 	/*
- 	 * Open the syslog connection
- 	 */
+	 * Open the syslog connection
+	 */
 	openlog(argv[0], 0, LOG_DAEMON);
 
-	if (getenv("IRQBALANCE_ONESHOT")) 
-		one_shot_mode=1;
+	if (getenv("IRQBALANCE_ONESHOT"))
+		one_shot_mode = 1;
 
 	if (getenv("IRQBALANCE_DEBUG")) {
-		debug_mode=1;
-		foreground_mode=1;
+		debug_mode = 1;
+		foreground_mode = 1;
 	}
 
 	/*
- 	 * If we are't in debug mode, don't dump anything to the console
- 	 * note that everything goes to the console before we check this
- 	 */
+	 * If we aren't in debug mode, don't dump anything to the console
+	 * note that everything goes to the console before we check this
+	 */
 	if (journal_logging)
 		log_indent = "....";
 	else
@@ -638,8 +644,9 @@ int main(int argc, char** argv)
 
 	if (numa_available() > -1) {
 		numa_avail = 1;
-	} else 
+	} else {
 		log(TO_CONSOLE, LOG_INFO, "This machine seems not NUMA capable.\n");
+	}
 
 	if (geteuid() != 0)
 		log(TO_ALL, LOG_WARNING, "Irqbalance hasn't been executed under root privileges, thus it won't in fact balance interrupts.\n");
@@ -649,15 +656,15 @@ int main(int argc, char** argv)
 		log(TO_ALL, LOG_WARNING, "Unable to determine HZ defaulting to 100\n");
 		HZ = 100;
 	}
-	
+
 	if (!foreground_mode) {
 		int pidfd = -1;
-		if (daemon(0,0))
+		if (daemon(0, 0))
 			exit(EXIT_FAILURE);
 		/* Write pidfile which can be used to avoid starting multiple instances */
 		if (pidfile) {
 			pidfd = open(pidfile,
-				O_WRONLY | O_CREAT | O_EXCL | O_TRUNC,
+						 O_WRONLY | O_CREAT | O_EXCL | O_TRUNC,
 				S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);
 			if (pidfd >= 0) {
 				char str[16];
@@ -672,17 +679,15 @@ int main(int argc, char** argv)
 	if (debug_mode)
 		dump_object_tree();
 
-
 	/* On single core UP systems irqbalance obviously has no work to do */
 	if (num_online_cpus() <= 1) {
 		char *msg = "Balancing is ineffective on systems with a "
-			    "single cpu.  Shutting down\n";
+		"single cpu.  Shutting down\n";
 
 		log(TO_ALL, LOG_WARNING, "%s", msg);
 		goto out;
 	}
 
-
 	g_unix_signal_add(SIGINT, handler, NULL);
 	g_unix_signal_add(SIGTERM, handler, NULL);
 	g_unix_signal_add(SIGUSR1, handler, NULL);
@@ -690,12 +695,12 @@ int main(int argc, char** argv)
 	g_unix_signal_add(SIGHUP, force_rescan, NULL);
 	sigprocmask(SIG_SETMASK, &old_sigset, NULL);
 
-#ifdef HAVE_LIBCAP_NG
+	#ifdef HAVE_LIBCAP_NG
 	// Drop capabilities
 	capng_clear(CAPNG_SELECT_BOTH);
 	capng_lock();
 	capng_apply(CAPNG_SELECT_BOTH);
-#endif
+	#endif
 	for_each_irq(NULL, force_rebalance_irq, NULL);
 
 	parse_proc_interrupts();
@@ -703,12 +708,12 @@ int main(int argc, char** argv)
 
 	clear_slots();
 
-#ifdef HAVE_IRQBALANCEUI
+	#ifdef HAVE_IRQBALANCEUI
 	if (init_socket()) {
 		ret = EXIT_FAILURE;
 		goto out;
 	}
-#endif
+	#endif
 	if (init_thermal())
 		log(TO_ALL, LOG_WARNING, "Failed to initialize thermal events.\n");
 	main_loop = g_main_loop_new(NULL, FALSE);
@@ -718,7 +723,7 @@ int main(int argc, char** argv)
 
 	g_main_loop_quit(main_loop);
 
-out:
+	out:
 	deinit_thermal();
 	free_object_tree();
 	free_cl_opts();
@@ -727,12 +732,12 @@ out:
 	/* Remove pidfile */
 	if (!foreground_mode && pidfile)
 		unlink(pidfile);
-#ifdef HAVE_IRQBALANCEUI
+	#ifdef HAVE_IRQBALANCEUI
 	/* Remove socket */
 	if (socket_fd > 0)
 		close(socket_fd);
 	if (socket_name[0])
 		unlink(socket_name);
-#endif
+	#endif
 	return ret;
 }
