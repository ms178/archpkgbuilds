From 346783a5c6dcb215116146c7a4bebc853ed80876 Mon Sep 17 00:00:00 2001
From: Adam Jackson <ajax@redhat.com>
Date: Fri, 11 Feb 2022 10:57:42 -0500
Subject: [PATCH 1/8] ephyr: Hacky putimage stats

---
 hw/kdrive/ephyr/ephyr.c |  1 +
 hw/kdrive/ephyr/hostx.c | 10 ++++++++++
 hw/kdrive/ephyr/hostx.h |  3 +++
 3 files changed, 14 insertions(+)

diff --git a/hw/kdrive/ephyr/ephyr.c b/hw/kdrive/ephyr/ephyr.c
index 9236252b2..71cb7ff6b 100644
--- a/hw/kdrive/ephyr/ephyr.c
+++ b/hw/kdrive/ephyr/ephyr.c
@@ -749,6 +749,7 @@ void
 ephyrCloseScreen(ScreenPtr pScreen)
 {
     ephyrUnsetInternalDamage(pScreen);
+    hostx_fini();
 }
 
 /*
diff --git a/hw/kdrive/ephyr/hostx.c b/hw/kdrive/ephyr/hostx.c
index f9cb6980f..78fd632b4 100644
--- a/hw/kdrive/ephyr/hostx.c
+++ b/hw/kdrive/ephyr/hostx.c
@@ -83,6 +83,8 @@ struct EphyrHostXVars {
 
     long damage_debug_msec;
     Bool size_set_from_configure;
+
+    uint64_t pixels_written;
 };
 
 /* memset ( missing> ) instead of below  */
@@ -750,6 +752,12 @@ hostx_init(void)
     return 1;
 }
 
+void
+hostx_fini(void)
+{
+   ErrorF("Wrote %lu pixels\n", HostX.pixels_written);
+}
+
 int
 hostx_get_depth(void)
 {
@@ -1017,6 +1025,8 @@ hostx_paint_rect(KdScreenInfo *screen,
 
     EPHYR_DBG("painting in screen %d\n", scrpriv->mynum);
 
+    HostX.pixels_written += (width * height);
+
 #ifdef GLAMOR
     if (ephyr_glamor) {
         BoxRec box;
diff --git a/hw/kdrive/ephyr/hostx.h b/hw/kdrive/ephyr/hostx.h
index 4b2678e58..dbffcce47 100644
--- a/hw/kdrive/ephyr/hostx.h
+++ b/hw/kdrive/ephyr/hostx.h
@@ -110,6 +110,9 @@ void
 int
  hostx_init(void);
 
+void
+hostx_fini(void);
+
 void
 hostx_add_screen(KdScreenInfo *screen, unsigned long win_id, int screen_num, Bool use_geometry, const char *output);
 
-- 
GitLab


From a787926759320fc2dfcd14dea1b193a6b4e067ce Mon Sep 17 00:00:00 2001
From: Adam Jackson <ajax@redhat.com>
Date: Tue, 8 Feb 2022 18:02:40 -0500
Subject: [PATCH 2/8] ephyr: Sync less in hostx_paint_rect

Move the xcb_aux_sync into the shm path, where we do still need it to
synchronize access with the host. In the non-shm path the image is
copied to the host anyway so the sync just adds latency and keeps you
from using all your network bandwidth.

Only the non-shm-putimage path benefits from this, but the benefit is
significant even on the local machine (here a 3.2GHz Core i7-8700, using
XEPHYR_NO_SHM=1):

      before                  after   Operation
------------   --------------------   -------------------------
 228000000.0    225000000.0 (0.987)   Dot
  40900000.0     41600000.0 (1.017)   1x1 rectangle
  10400000.0     10700000.0 (1.029)   10x10 rectangle
    477000.0       471000.0 (0.987)   100x100 rectangle
     30900.0        31800.0 (1.029)   500x500 rectangle
    760000.0       981000.0 (1.291)   PutImage 10x10 square
     14700.0        19200.0 (1.306)   PutImage 100x100 square
       320.0          382.0 (1.194)   PutImage 500x500 square
    749000.0       984000.0 (1.314)   ShmPutImage 10x10 square
    268000.0       304000.0 (1.134)   ShmPutImage 100x100 square
     16600.0        18500.0 (1.114)   ShmPutImage 500x500 square
---
 hw/kdrive/ephyr/hostx.c | 3 +--
 1 file changed, 1 insertion(+), 2 deletions(-)

diff --git a/hw/kdrive/ephyr/hostx.c b/hw/kdrive/ephyr/hostx.c
index 78fd632b4..ac0d40762 100644
--- a/hw/kdrive/ephyr/hostx.c
+++ b/hw/kdrive/ephyr/hostx.c
@@ -1110,6 +1110,7 @@ hostx_paint_rect(KdScreenInfo *screen,
                           HostX.gc, scrpriv->ximg,
                           scrpriv->shminfo,
                           sx, sy, dx, dy, width, height, FALSE);
+        xcb_aux_sync(HostX.conn);
     }
     else {
         xcb_image_t *subimg = xcb_image_subimage(scrpriv->ximg, sx, sy,
@@ -1120,8 +1121,6 @@ hostx_paint_rect(KdScreenInfo *screen,
             xcb_image_destroy(img);
         xcb_image_destroy(subimg);
     }
-
-    xcb_aux_sync(HostX.conn);
 }
 
 static void
-- 
GitLab


From 6ca5886910c0d7aa83041b634774fee334554fca Mon Sep 17 00:00:00 2001
From: Adam Jackson <ajax@redhat.com>
Date: Wed, 9 Feb 2022 00:33:10 -0500
Subject: [PATCH 3/8] ephyr: Sync even less in ephyrInternalDamageRedisplay

If we have multiple damage rects we would sync (if we would sync) after
every hostx_paint_rect. For shm images you'd rather push all the
ShmPutImage requests and wait after the last one.

      before                  after   Operation
------------   --------------------   -------------------------
 232000000.0    240000000.0 (1.034)   Dot
  41500000.0     41400000.0 (0.998)   1x1 rectangle
  11400000.0     11400000.0 (1.000)   10x10 rectangle
    553000.0       553000.0 (1.000)   100x100 rectangle
     37300.0        38500.0 (1.032)   500x500 rectangle
    831000.0      1140000.0 (1.372)   PutImage 10x10 square
     65200.0       134000.0 (2.055)   PutImage 100x100 square
      3410.0         3500.0 (1.026)   PutImage 500x500 square
    810000.0      1150000.0 (1.420)   ShmPutImage 10x10 square
    346000.0       364000.0 (1.052)   ShmPutImage 100x100 square
     22400.0        22800.0 (1.018)   ShmPutImage 500x500 square
---
 hw/kdrive/ephyr/ephyr.c | 8 +++++---
 hw/kdrive/ephyr/hostx.c | 6 ++++--
 hw/kdrive/ephyr/hostx.h | 3 ++-
 3 files changed, 11 insertions(+), 6 deletions(-)

diff --git a/hw/kdrive/ephyr/ephyr.c b/hw/kdrive/ephyr/ephyr.c
index 71cb7ff6b..3240b3869 100644
--- a/hw/kdrive/ephyr/ephyr.c
+++ b/hw/kdrive/ephyr/ephyr.c
@@ -298,7 +298,7 @@ ephyrShadowUpdate(ScreenPtr pScreen, shadowBufPtr pBuf)
      * pBuf->pDamage  regions
      */
     shadowUpdateRotatePacked(pScreen, pBuf);
-    hostx_paint_rect(screen, 0, 0, 0, 0, screen->width, screen->height);
+    hostx_paint_rect(screen, 0, 0, 0, 0, screen->width, screen->height, TRUE);
 }
 
 static void
@@ -328,7 +328,8 @@ ephyrInternalDamageRedisplay(ScreenPtr pScreen)
                 hostx_paint_rect(screen,
                                  pbox->x1, pbox->y1,
                                  pbox->x1, pbox->y1,
-                                 pbox->x2 - pbox->x1, pbox->y2 - pbox->y1);
+                                 pbox->x2 - pbox->x1, pbox->y2 - pbox->y1,
+                                 nbox == 0);
                 pbox++;
             }
         }
@@ -890,7 +891,8 @@ ephyrProcessExpose(xcb_generic_event_t *xev)
     if (scrpriv) {
         hostx_paint_rect(scrpriv->screen, 0, 0, 0, 0,
                          scrpriv->win_width,
-                         scrpriv->win_height);
+                         scrpriv->win_height,
+                         TRUE);
     } else {
         EPHYR_LOG_ERROR("failed to get host screen\n");
     }
diff --git a/hw/kdrive/ephyr/hostx.c b/hw/kdrive/ephyr/hostx.c
index ac0d40762..47a7e5647 100644
--- a/hw/kdrive/ephyr/hostx.c
+++ b/hw/kdrive/ephyr/hostx.c
@@ -1019,7 +1019,8 @@ static void hostx_paint_debug_rect(KdScreenInfo *screen,
 
 void
 hostx_paint_rect(KdScreenInfo *screen,
-                 int sx, int sy, int dx, int dy, int width, int height)
+                 int sx, int sy, int dx, int dy, int width, int height,
+                 Bool sync)
 {
     EphyrScrPriv *scrpriv = screen->driver;
 
@@ -1110,7 +1111,8 @@ hostx_paint_rect(KdScreenInfo *screen,
                           HostX.gc, scrpriv->ximg,
                           scrpriv->shminfo,
                           sx, sy, dx, dy, width, height, FALSE);
-        xcb_aux_sync(HostX.conn);
+        if (sync)
+            xcb_aux_sync(HostX.conn);
     }
     else {
         xcb_image_t *subimg = xcb_image_subimage(scrpriv->ximg, sx, sy,
diff --git a/hw/kdrive/ephyr/hostx.h b/hw/kdrive/ephyr/hostx.h
index dbffcce47..c4624c5d2 100644
--- a/hw/kdrive/ephyr/hostx.h
+++ b/hw/kdrive/ephyr/hostx.h
@@ -149,7 +149,8 @@ void *hostx_screen_init(KdScreenInfo *screen,
 
 void
 hostx_paint_rect(KdScreenInfo *screen,
-                 int sx, int sy, int dx, int dy, int width, int height);
+                 int sx, int sy, int dx, int dy, int width, int height,
+                 Bool sync);
 
 Bool
 hostx_load_keymap(KeySymsPtr keySyms, CARD8 *modmap, XkbControlsPtr controls);
-- 
GitLab


From 373d64cedb647a687adb1c23404de01ba73e7060 Mon Sep 17 00:00:00 2001
From: Adam Jackson <ajax@redhat.com>
Date: Thu, 10 Feb 2022 12:19:06 -0500
Subject: [PATCH 4/8] miext/shadow: Add update freeze/thaw API

This is a bit subtle. We have:

    static void
    shadowRedisplay(ScreenPtr pScreen)
    {
        shadowBuf(pScreen);
        RegionPtr pRegion;

        if (!pBuf || !pBuf->pDamage || !pBuf->update)
            return;
        pRegion = DamageRegion(pBuf->pDamage);
        if (RegionNotEmpty(pRegion)) {
            (*pBuf->update) (pScreen, pBuf);
            DamageEmpty(pBuf->pDamage);
        }
    }

If we could disable the update hook, we could let the shadow buffer
accumulate updates until the hook is re-enabled. There's no existing API
to do that (short of recreating the shadow, which destroys any pending
damage), so add some.
---
 miext/shadow/shadow.c | 14 ++++++++++++++
 miext/shadow/shadow.h |  7 ++++++-
 2 files changed, 20 insertions(+), 1 deletion(-)

diff --git a/miext/shadow/shadow.c b/miext/shadow/shadow.c
index e8d0d51b0..f313e406b 100644
--- a/miext/shadow/shadow.c
+++ b/miext/shadow/shadow.c
@@ -193,3 +193,17 @@ shadowRemove(ScreenPtr pScreen, PixmapPtr pPixmap)
         pBuf->pPixmap = 0;
     }
 }
+
+void
+shadowFreeze(ScreenPtr pScreen)
+{
+    shadowBuf(pScreen);
+    pBuf->update = NULL;
+}
+
+void
+shadowThaw(ScreenPtr pScreen, ShadowUpdateProc update)
+{
+    shadowBuf(pScreen);
+    pBuf->update = update;
+}
diff --git a/miext/shadow/shadow.h b/miext/shadow/shadow.h
index c08e1537c..e6581321e 100644
--- a/miext/shadow/shadow.h
+++ b/miext/shadow/shadow.h
@@ -1,5 +1,4 @@
 /*
- *
  * Copyright Â© 2000 Keith Packard
  *
  * Permission to use, copy, modify, distribute, and sell this software and its
@@ -81,6 +80,12 @@ shadowAdd(ScreenPtr pScreen,
 extern _X_EXPORT void
  shadowRemove(ScreenPtr pScreen, PixmapPtr pPixmap);
 
+extern _X_EXPORT void
+shadowFreeze(ScreenPtr pScreen);
+
+extern _X_EXPORT void
+shadowThaw(ScreenPtr pScreen, ShadowUpdateProc update);
+
 extern _X_EXPORT void
  shadowUpdateAfb4(ScreenPtr pScreen, shadowBufPtr pBuf);
 
-- 
GitLab


From c75c06502919a79ca971b7576f515f69214cf15c Mon Sep 17 00:00:00 2001
From: Adam Jackson <ajax@redhat.com>
Date: Thu, 10 Feb 2022 16:02:44 -0500
Subject: [PATCH 5/8] ephyr: Throttle putimage-based updates

10ms is faster than your display's frame time, probably, and happens to
match a similar timeout in miext/rootless. This is a modest win although
mostly for non-shm and mostly because it's avoiding the
getpixel/putpixel path in xcb_image_subimage.
---
 hw/kdrive/ephyr/ephyr.c |  2 +-
 hw/kdrive/ephyr/ephyr.h |  2 ++
 hw/kdrive/ephyr/hostx.c | 12 ++++++++++++
 3 files changed, 15 insertions(+), 1 deletion(-)

diff --git a/hw/kdrive/ephyr/ephyr.c b/hw/kdrive/ephyr/ephyr.c
index 3240b3869..480b911e5 100644
--- a/hw/kdrive/ephyr/ephyr.c
+++ b/hw/kdrive/ephyr/ephyr.c
@@ -309,7 +309,7 @@ ephyrInternalDamageRedisplay(ScreenPtr pScreen)
     EphyrScrPriv *scrpriv = screen->driver;
     RegionPtr pRegion;
 
-    if (!scrpriv || !scrpriv->pDamage)
+    if (!scrpriv || !scrpriv->pDamage || scrpriv->throttled)
         return;
 
     pRegion = DamageRegion(scrpriv->pDamage);
diff --git a/hw/kdrive/ephyr/ephyr.h b/hw/kdrive/ephyr/ephyr.h
index 8833de8a9..55d68f937 100644
--- a/hw/kdrive/ephyr/ephyr.h
+++ b/hw/kdrive/ephyr/ephyr.h
@@ -65,6 +65,8 @@ typedef struct _ephyrScrPriv {
     Rotation randr;
     Bool shadow;
     DamagePtr pDamage;
+    OsTimerPtr throttle_timer;
+    Bool throttled;
     EphyrFakexaPriv *fakexa;
 
     /* Host X window info */
diff --git a/hw/kdrive/ephyr/hostx.c b/hw/kdrive/ephyr/hostx.c
index 47a7e5647..2f3c931fb 100644
--- a/hw/kdrive/ephyr/hostx.c
+++ b/hw/kdrive/ephyr/hostx.c
@@ -1017,6 +1017,14 @@ hostx_screen_init(KdScreenInfo *screen,
 static void hostx_paint_debug_rect(KdScreenInfo *screen,
                                    int x, int y, int width, int height);
 
+static CARD32
+ephyrThrottleCallback(OsTimerPtr timer, CARD32 time, void *arg)
+{
+    EphyrScrPriv *scrpriv = arg;
+    scrpriv->throttled = FALSE;
+    return 0;
+}
+
 void
 hostx_paint_rect(KdScreenInfo *screen,
                  int sx, int sy, int dx, int dy, int width, int height,
@@ -1123,6 +1131,10 @@ hostx_paint_rect(KdScreenInfo *screen,
             xcb_image_destroy(img);
         xcb_image_destroy(subimg);
     }
+
+    scrpriv->throttle_timer = TimerSet(scrpriv->throttle_timer, 0, 10,
+                                       ephyrThrottleCallback, scrpriv);
+    scrpriv->throttled = TRUE;
 }
 
 static void
-- 
GitLab


From 822b4430314da726d808f67e00357d444e5675a0 Mon Sep 17 00:00:00 2001
From: Adam Jackson <ajax@redhat.com>
Date: Fri, 11 Feb 2022 16:51:49 -0500
Subject: [PATCH 6/8] modesetting: Leave some hints about fill detection

---
 hw/xfree86/drivers/modesetting/driver.c | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/hw/xfree86/drivers/modesetting/driver.c b/hw/xfree86/drivers/modesetting/driver.c
index fe3315a9c..53d5ba88d 100644
--- a/hw/xfree86/drivers/modesetting/driver.c
+++ b/hw/xfree86/drivers/modesetting/driver.c
@@ -1370,10 +1370,12 @@ msUpdateIntersect(modesettingPtr ms, shadowBufPtr pBuf, BoxPtr box,
                       *n = new + i * stride;
         if (memcmp(o, n, width) != 0) {
             dirty = 1;
+            /* XXX check for solid fill in new tile */
             memcpy(o, n, width);
         }
     }
 
+    // XXX if solid fill else
     if (dirty) {
         prect->x = box->x1;
         prect->y = box->y1;
-- 
GitLab


From 5033029e27a55c1f6c0bc099907be6ed7925e68b Mon Sep 17 00:00:00 2001
From: Adam Jackson <ajax@redhat.com>
Date: Tue, 22 Feb 2022 15:46:16 -0500
Subject: [PATCH 7/8] damageext: stub PanoramiXDamageAdd

This is actually kind of a cute API trick.
---
 damageext/damageext.c | 16 ++++++++++++++++
 1 file changed, 16 insertions(+)

diff --git a/damageext/damageext.c b/damageext/damageext.c
index c8194da07..733dc3524 100644
--- a/damageext/damageext.c
+++ b/damageext/damageext.c
@@ -688,6 +688,21 @@ PanoramiXDamageCreate(ClientPtr client)
     return rc;
 }
 
+static int
+PanoramiXDamageAdd(ClientPtr client)
+{
+    // XXX this should go ahead and exist. what this lets you do is:
+    //
+    // - automatically redirect your own window
+    // - NameWindowPixmap on it
+    // - draw to the window pixmap
+    // - use DamageAdd to tickle window refresh
+    //
+    // and this works fine, for non-pano, so.
+
+    return BadImplementation;
+}
+
 static int
 PanoramiXDamageDelete(void *res, XID id)
 {
@@ -714,6 +729,7 @@ PanoramiXDamageInit(void)
 
     PanoramiXSaveDamageCreate = ProcDamageVector[X_DamageCreate];
     ProcDamageVector[X_DamageCreate] = PanoramiXDamageCreate;
+    ProcDamageVector[X_DamageAdd] = PanoramiXDamageAdd;
 }
 
 void
-- 
GitLab


From 79b06e5f1c82cef8cbc579ab60b74275250b39d1 Mon Sep 17 00:00:00 2001
From: Adam Jackson <ajax@redhat.com>
Date: Thu, 24 Feb 2022 11:02:55 -0500
Subject: [PATCH 8/8] breadcrumb

---
 hw/kdrive/ephyr/ephyr_glamor.c | 4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

diff --git a/hw/kdrive/ephyr/ephyr_glamor.c b/hw/kdrive/ephyr/ephyr_glamor.c
index 724611d69..57c3a92a0 100644
--- a/hw/kdrive/ephyr/ephyr_glamor.c
+++ b/hw/kdrive/ephyr/ephyr_glamor.c
@@ -155,10 +155,12 @@ ephyr_glamor_setup_texturing_shader(struct ephyr_glamor *glamor)
 static EGLDisplay edpy = EGL_NO_DISPLAY;
 
 xcb_connection_t *
-ephyr_glamor_connect(void)
+ephyr_glamor_connect(void) // XXX bool surfaceless
 {
     int major = 0, minor = 0;
 
+    // surfaceless here
+
     /*
      * Try pure xcb first. If that doesn't work but we can find XOpenDisplay,
      * fall back to xlib. This lets us potentially not load libX11 at all, if
-- 
GitLab

