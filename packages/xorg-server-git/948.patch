From ff8460a92346daa5aa8d662c8eda4a35593df3a5 Mon Sep 17 00:00:00 2001
From: Konstantin <ria.freelander@gmail.com>
Date: Mon, 27 Jun 2022 20:12:44 +0300
Subject: [PATCH 01/10] tests: fix "xephr-glamor" typo

Signed-off-by: Konstantin Pugin <ria.freelander@gmail.com>

Reviewed-by: Adam Jackson <ajax@redhat.com>
Reviewed-by: Emma Anholt <emma@anholt.net>
---
 test/meson.build | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/test/meson.build b/test/meson.build
index e39f31a40..a8d9e8497 100644
--- a/test/meson.build
+++ b/test/meson.build
@@ -74,7 +74,7 @@ if get_option('xvfb')
             find_program('scripts/xephyr-glamor-piglit.sh'),
             env: piglit_env,
             timeout: 1200,
-            suite: 'xephr-glamor',
+            suite: 'xephyr-glamor',
         )
 
         if rendercheck.found()
@@ -92,7 +92,7 @@ if get_option('xvfb')
                             '--',
                             xvfb_args,
                            ],
-                     suite: 'xephr-glamor',
+                     suite: 'xephyr-glamor',
                      timeout: 300,
                     )
             endforeach
-- 
GitLab


From 1094305f49606ea35d24a3f667c8027750e3c020 Mon Sep 17 00:00:00 2001
From: Konstantin <ria.freelander@gmail.com>
Date: Sat, 25 Jun 2022 21:58:08 +0300
Subject: [PATCH 02/10] meson: add glamor gles2 tests

Signed-off-by: Konstantin Pugin <ria.freelander@gmail.com>

Reviewed-by: Adam Jackson <ajax@redhat.com>
Reviewed-by: Emma Anholt <emma@anholt.net>
---
 test/bugs/bug1354.c                        | 149 +++++++++++++++++++++
 test/bugs/meson.build                      |  49 +++++++
 test/meson.build                           |  58 +++++++-
 test/scripts/xephyr-glamor-gles2-piglit.sh |  32 +++++
 4 files changed, 283 insertions(+), 5 deletions(-)
 create mode 100644 test/bugs/bug1354.c
 create mode 100644 test/bugs/meson.build
 create mode 100755 test/scripts/xephyr-glamor-gles2-piglit.sh

diff --git a/test/bugs/bug1354.c b/test/bugs/bug1354.c
new file mode 100644
index 000000000..edc3f228c
--- /dev/null
+++ b/test/bugs/bug1354.c
@@ -0,0 +1,149 @@
+#include <xcb/xcb.h>
+#include <xcb/xcb_aux.h>
+#include <xcb/xcb_image.h>
+#include <stdint.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <getopt.h>
+#include <ctype.h>
+#include <unistd.h>
+
+/*
+ * This is a test which try to test correct glamor colors when rendered.
+ * It should be run with fullscreen Xephyr (with glamor) with present and with 
+ * etalon high-level Xserver (can be any, on CI - Xvfb). For testing this test
+ * creates an image in Xephyr X server, which filled by one of colors defined in
+ * test_pixels. Then it captures central pixel from both Xephyr and Xserver above.
+ * If pixels differ - test failed. Sleep is used to ensure than presentation on both 
+ * Xephyr and Xvfb kicks (xcb_aux_sync was not enough) and test results will be actual
+ */
+
+#define WIDTH 300
+#define HEIGHT 300
+
+int get_display_pixel(xcb_connection_t* c, xcb_drawable_t win);
+void draw_display_pixel(xcb_connection_t* c, xcb_drawable_t win, uint32_t pixel_color);
+
+int get_display_pixel(xcb_connection_t* c, xcb_drawable_t win)
+{
+	xcb_image_t *image;
+	uint32_t    pixel;
+	int format = XCB_IMAGE_FORMAT_XY_PIXMAP;
+
+	image = xcb_image_get (c, win,
+		 0, 0, WIDTH, HEIGHT,
+		 UINT32_MAX,
+		 format);
+	if (!image) {
+	  printf("xcb_image_get failed: exiting\n");
+	  exit(1);
+	}
+
+	pixel = xcb_image_get_pixel(image, WIDTH/2, HEIGHT/2);
+
+	return pixel;
+}
+
+void draw_display_pixel(xcb_connection_t* c, xcb_drawable_t win, uint32_t pixel_color)
+{
+	xcb_gcontext_t       foreground;
+	uint32_t             mask = 0;
+
+	xcb_rectangle_t rectangles[] = {
+	  {0, 0, WIDTH, HEIGHT},
+	};
+
+	foreground = xcb_generate_id (c);
+	mask = XCB_GC_FOREGROUND | XCB_GC_LINE_WIDTH | XCB_GC_SUBWINDOW_MODE;
+
+	uint32_t values[] = {
+		pixel_color,
+		20,
+		XCB_SUBWINDOW_MODE_INCLUDE_INFERIORS
+	};
+
+	xcb_create_gc (c, foreground, win, mask, values);
+
+	xcb_poly_fill_rectangle (c, win, foreground, 1, rectangles);
+	xcb_aux_sync ( c );
+}
+
+
+int main(int argc, char* argv[])
+{
+	xcb_connection_t    *c, *r;
+	xcb_screen_t        *screen1, *screen2;
+	xcb_drawable_t       win1, win2;
+    char *name_test = NULL, *name_relevant = NULL;
+	uint32_t pixel_server1, pixel_server2;
+	int result = 0;
+	uint32_t test_pixels[3] = {0xff0000, 0x00ff00, 0x0000ff};
+	int gv;
+
+	while ((gv = getopt (argc, argv, "t:r:")) != -1)
+	switch (gv)
+	  {
+	  case 't':
+		name_test = optarg;
+		break;
+	  case 'r':
+		name_relevant = optarg;
+		break;
+	  case '?':
+		if (optopt == 't' || optopt == 'r')
+		  fprintf (stderr, "Option -%c requires an argument - test screen name.\n", optopt);
+		else if (isprint (optopt))
+		  fprintf (stderr, "Unknown option `-%c'.\n", optopt);
+		else
+		  fprintf (stderr,
+		           "Unknown option character `\\x%x'.\n",
+		           optopt);
+		return 1;
+	  default:
+		abort ();
+	  }
+
+	printf("test=%s, rel=%s\n", name_test, name_relevant);
+
+	c = xcb_connect (name_test, NULL);
+	r = xcb_connect (name_relevant, NULL);
+
+	/* get the first screen */
+	screen1 = xcb_setup_roots_iterator (xcb_get_setup (c)).data;
+
+    win1 = xcb_generate_id (c);
+    xcb_create_window (c,                    /* Connection          */
+                       XCB_COPY_FROM_PARENT,          /* depth (same as root)*/
+                       win1,                        /* window Id           */
+                       screen1->root,                  /* parent window       */
+                       0, 0,                          /* x, y                */
+                       WIDTH, HEIGHT,                /* width, height       */
+                       20,                            /* border_width        */
+                       XCB_WINDOW_CLASS_INPUT_OUTPUT, /* class               */
+                       screen1->root_visual,           /* visual              */
+                       0, NULL );                     /* masks, not used yet */
+
+
+    /* Map the window on the screen */
+    xcb_map_window (c, win1);
+    xcb_aux_sync(c);
+
+	/* get the first screen */
+	screen2 = xcb_setup_roots_iterator (xcb_get_setup (r)).data;
+
+	/* root window */
+	win2 = screen2->root;
+
+	for(int i = 0; i < 3; i++)
+	{
+		draw_display_pixel(c, win1, test_pixels[i]);
+		xcb_aux_sync(r);
+		pixel_server1 = get_display_pixel(c, win1);
+		sleep(1);
+		pixel_server2 = get_display_pixel(r, win2);
+		xcb_aux_sync(r);
+		printf("p=0x%x, p2=0x%x\n", pixel_server1, pixel_server2);
+		result+= pixel_server1 == pixel_server2;
+	}
+	return result == 3 ? 0 : 1;
+}
diff --git a/test/bugs/meson.build b/test/bugs/meson.build
new file mode 100644
index 000000000..e63cd207d
--- /dev/null
+++ b/test/bugs/meson.build
@@ -0,0 +1,49 @@
+xcb_dep = dependency('xcb', required: false)
+xcb_image_dep = dependency('xcb-image', required: false)
+xcb_util_dep = dependency('xcb-util', required: false)
+
+xvfb_args = [
+    xvfb_server.full_path(),
+    '-screen',
+    'scrn',
+    '1280x1024x24'
+]
+
+if xcb_dep.found() and xcb_image_dep.found() and xcb_util_dep.found() and get_option('xvfb') and get_option('xephyr') and build_glamor
+    bug1354 = executable('bug1354', 'bug1354.c', dependencies: [xcb_dep, xcb_image_dep, xcb_util_dep])
+    test('bug1354-gl',
+            simple_xinit,
+            args: [simple_xinit.full_path(),
+                bug1354.full_path(),
+                '-t',':201','-r',':200',
+                '----',
+                xephyr_server.full_path(),
+                '-glamor',
+                '-schedMax', '2000',
+                ':201',
+                '--',
+                xvfb_args,
+                ':200'
+                ],
+            suite: 'xephyr-glamor',
+            timeout: 300,
+        )
+    test('bug1354-gles',
+            simple_xinit,
+            args: [simple_xinit.full_path(),
+                bug1354.full_path(),
+                '-t',':199','-r',':198',
+                '----',
+                xephyr_server.full_path(),
+                '-glamor_gles2',
+                '-schedMax', '2000',
+                ':199',
+                '--',
+                xvfb_args,
+                ':198'
+                ],
+            suite: 'xephyr-glamor-gles2',
+            timeout: 300,
+            should_fail: true,
+        )
+endif
\ No newline at end of file
diff --git a/test/meson.build b/test/meson.build
index a8d9e8497..662eee4ef 100644
--- a/test/meson.build
+++ b/test/meson.build
@@ -9,13 +9,24 @@ piglit_env.set('XSERVER_DIR', meson.source_root())
 piglit_env.set('XSERVER_BUILDDIR', meson.build_root())
 
 some_ops = ' -o clear,src,dst,over,xor,disjointover'
-rendercheck_tests = [
+gles2_working_formats = ' -f '+ ','.join(['a8',
+                                          'a8r8g8b8',
+                                          'x8r8g8b8',
+                                          'b8g8r8a8',
+                                          'b8g8r8x8',
+                                          'r8g8b8',
+                                          'r5g5b5',
+                                          'b5g5r5',
+                                          'r5g6b5',
+                                          'b5g6r5',
+                                          'b8g8r8',
+                                          'x8b8g8r8',
+                                          'x2r10g10b10',
+                                          'x2b10g10r10'])
+rendercheck_tests_noblend = [
     ['blend/All/a8r8g8b8', '-t blend -f a8r8g8b8'],
     ['blend/All/x8r8g8b8', '-t blend -f a8r8g8b8,x8r8g8b8'],
     ['blend/All/a2r10g10b10', '-t blend -f a8r8g8b8,a2r10g10b10'],
-    ['blend/Clear', '-t blend -o clear'],
-    ['blend/Src', '-t blend -o src'],
-    ['blend/Over', '-t blend -o over'],
     ['composite/Some/a8r8g8b8', '-t composite -f a8r8g8b8' + some_ops],
     ['composite/Some/x8r8g8b8', '-t composite -f a8r8g8b8,x8r8g8b8' + some_ops],
     ['composite/Some/a2r10g10b10', '-t composite -f a8r8g8b8,a2r10g10b10' + some_ops],
@@ -34,7 +45,19 @@ rendercheck_tests = [
     ['LibreOffice xRGB', '-t libreoffice_xrgb'],
     ['GTK ARGB vs xBGR', '-t gtk_argb_xbgr'],
 ]
-
+rendercheck_blend = [
+    ['blend/Clear', '-t blend -o clear'],
+    ['blend/Src', '-t blend -o src'],
+    ['blend/Over', '-t blend -o over'],
+]
+#Exclude 15bpp for now due to GLES limitation (see glamor.c:470)
+rendercheck_blend_gles2 = [
+    ['blend/Clear', '-t blend -o clear' + gles2_working_formats],
+    ['blend/Src', '-t blend -o src' + gles2_working_formats],
+    ['blend/Over', '-t blend -o over' + gles2_working_formats],
+]
+rendercheck_tests = rendercheck_blend + rendercheck_tests_noblend
+rendercheck_tests_gles2 = rendercheck_blend_gles2 + rendercheck_tests_noblend
 rendercheck = find_program('rendercheck', required:false)
 
 if get_option('xvfb')
@@ -76,6 +99,12 @@ if get_option('xvfb')
             timeout: 1200,
             suite: 'xephyr-glamor',
         )
+        test('XTS',
+            find_program('scripts/xephyr-glamor-gles2-piglit.sh'),
+            env: piglit_env,
+            timeout: 1200,
+            suite: 'xephyr-glamor-gles2',
+        )
 
         if rendercheck.found()
             foreach rctest: rendercheck_tests
@@ -96,6 +125,24 @@ if get_option('xvfb')
                      timeout: 300,
                     )
             endforeach
+            foreach rctest: rendercheck_tests_gles2
+                test(rctest[0],
+                     simple_xinit,
+                     args: [simple_xinit.full_path(),
+                            rendercheck.path(),
+                            rctest[1].split(' '),
+                            '----',
+                            xephyr_server.full_path(),
+                            '-glamor_gles2',
+                            '-glamor-skip-present',
+                            '-schedMax', '2000',
+                            '--',
+                            xvfb_args,
+                           ],
+                     suite: 'xephyr-glamor-gles2',
+                     timeout: 300,
+                    )
+            endforeach
         endif
     endif
 endif
@@ -116,6 +163,7 @@ endif
 subdir('bigreq')
 subdir('damage')
 subdir('sync')
+subdir('bugs')
 
 if build_xorg
 # Tests that require at least some DDX functions in order to fully link
diff --git a/test/scripts/xephyr-glamor-gles2-piglit.sh b/test/scripts/xephyr-glamor-gles2-piglit.sh
new file mode 100755
index 000000000..482e7b7b7
--- /dev/null
+++ b/test/scripts/xephyr-glamor-gles2-piglit.sh
@@ -0,0 +1,32 @@
+#!/bin/sh
+
+# this times out on Travis, because the tests take too long.
+if test "x$TRAVIS_BUILD_DIR" != "x"; then
+    exit 77
+fi
+
+# Start a Xephyr server using glamor.  Since the test environment is
+# headless, we start an Xvfb first to host the Xephyr.
+export PIGLIT_RESULTS_DIR=$XSERVER_BUILDDIR/test/piglit-results/xephyr-glamor-gles2
+
+export SERVER_COMMAND="$XSERVER_BUILDDIR/hw/kdrive/ephyr/Xephyr \
+        -glamor_gles2 \
+        -glamor-skip-present \
+        -noreset \
+        -schedMax 2000 \
+        -screen 1280x1024"
+
+# Tests that currently fail on llvmpipe on CI
+PIGLIT_ARGS="$PIGLIT_ARGS -x xcleararea@6"
+PIGLIT_ARGS="$PIGLIT_ARGS -x xcleararea@7"
+PIGLIT_ARGS="$PIGLIT_ARGS -x xclearwindow@4"
+PIGLIT_ARGS="$PIGLIT_ARGS -x xclearwindow@5"
+PIGLIT_ARGS="$PIGLIT_ARGS -x xcopyarea@1"
+
+export PIGLIT_ARGS
+
+$XSERVER_BUILDDIR/test/simple-xinit \
+        $XSERVER_DIR/test/scripts/run-piglit.sh \
+        -- \
+        $XSERVER_BUILDDIR/hw/vfb/Xvfb \
+        -screen scrn 1280x1024x24
-- 
GitLab


From a7e0e1903b949ee4ec4a85b3ed4b8e6d0e611242 Mon Sep 17 00:00:00 2001
From: Konstantin <ria.freelander@gmail.com>
Date: Sun, 26 Jun 2022 00:01:54 +0300
Subject: [PATCH 03/10] glamor: make use of GL_EXT_texture_format_BGRA8888

For 24 and 32 bit depth pictures xserver uses PICT_x8r8g8b8 and PICT_a8r8g8b8 formats,
which must be backed with GL_BGRA format. It is present in OpenGL ES 2.0 only with
GL_EXT_texture_format_BGRA8888 extension. We require such extension in glamor_init,
so, why not to make use of it?
Fixes #1208
Fixes #1354

Signed-off-by: Konstantin Pugin <ria.freelander@gmail.com>

Reviewed-by: Adam Jackson <ajax@redhat.com>
Reviewed-by: Emma Anholt <emma@anholt.net>
---
 glamor/glamor.c         | 8 ++++----
 glamor/glamor_picture.c | 7 ++-----
 test/bugs/meson.build   | 1 -
 3 files changed, 6 insertions(+), 10 deletions(-)

diff --git a/glamor/glamor.c b/glamor/glamor.c
index 9dcef5fac..0a757db35 100644
--- a/glamor/glamor.c
+++ b/glamor/glamor.c
@@ -586,10 +586,10 @@ glamor_setup_formats(ScreenPtr screen)
 
     if (glamor_priv->is_gles) {
         assert(X_BYTE_ORDER == X_LITTLE_ENDIAN);
-        glamor_add_format(screen, 24, PICT_x8b8g8r8,
-                          GL_RGBA8, GL_RGBA, GL_UNSIGNED_BYTE, TRUE);
-        glamor_add_format(screen, 32, PICT_a8b8g8r8,
-                          GL_RGBA8, GL_RGBA, GL_UNSIGNED_BYTE, TRUE);
+        glamor_add_format(screen, 24, PICT_x8r8g8b8,
+                          GL_BGRA, GL_BGRA, GL_UNSIGNED_BYTE, TRUE);
+        glamor_add_format(screen, 32, PICT_a8r8g8b8,
+                          GL_BGRA, GL_BGRA, GL_UNSIGNED_BYTE, TRUE);
     } else {
         glamor_add_format(screen, 24, PICT_x8r8g8b8,
                           GL_RGBA, GL_BGRA, GL_UNSIGNED_INT_8_8_8_8_REV, TRUE);
diff --git a/glamor/glamor_picture.c b/glamor/glamor_picture.c
index 33b3bebd9..2152b85e1 100644
--- a/glamor/glamor_picture.c
+++ b/glamor/glamor_picture.c
@@ -94,7 +94,7 @@ glamor_get_tex_format_type_from_pictformat(ScreenPtr pScreen,
             *tex_format = GL_BGRA;
             *tex_type = GL_UNSIGNED_INT_8_8_8_8;
         } else {
-            *tex_format = GL_RGBA;
+            *tex_format = GL_BGRA;
             *tex_type = GL_UNSIGNED_BYTE;
 
             swizzle[0] = GL_GREEN;
@@ -113,12 +113,9 @@ glamor_get_tex_format_type_from_pictformat(ScreenPtr pScreen,
             *tex_format = GL_BGRA;
             *tex_type = GL_UNSIGNED_INT_8_8_8_8_REV;
         } else {
-            *tex_format = GL_RGBA;
+            *tex_format = GL_BGRA;
             *tex_type = GL_UNSIGNED_BYTE;
 
-            swizzle[0] = GL_BLUE;
-            swizzle[2] = GL_RED;
-
             if (!is_little_endian)
                 byte_swap_swizzle(swizzle);
             break;
diff --git a/test/bugs/meson.build b/test/bugs/meson.build
index e63cd207d..f15658356 100644
--- a/test/bugs/meson.build
+++ b/test/bugs/meson.build
@@ -44,6 +44,5 @@ if xcb_dep.found() and xcb_image_dep.found() and xcb_util_dep.found() and get_op
                 ],
             suite: 'xephyr-glamor-gles2',
             timeout: 300,
-            should_fail: true,
         )
 endif
\ No newline at end of file
-- 
GitLab


From 6c3a16ba3a528248dedb4c4097bc0cc57d93778b Mon Sep 17 00:00:00 2001
From: Konstantin <ria.freelander@gmail.com>
Date: Sat, 25 Jun 2022 17:51:15 +0300
Subject: [PATCH 04/10] glamor: transpose gradients transparently

glUniformMatrix3fv is used with argument transpose set to GL_TRUE.
According to the Khronos OpenGL ES 2.0 pages transpose must be GL_FALSE.
Actually we can just return transformed matrix from
_glamor_gradient_convert_trans_matrix (@anholt suggest),
so @uvas workaround is not required

Signed-off-by: Konstantin Pugin <ria.freelander@gmail.com>

Reviewed-by: Adam Jackson <ajax@redhat.com>
Reviewed-by: Emma Anholt <emma@anholt.net>
---
 glamor/glamor_gradient.c | 32 +++++++++++++++++++++-----------
 1 file changed, 21 insertions(+), 11 deletions(-)

diff --git a/glamor/glamor_gradient.c b/glamor/glamor_gradient.c
index 7e5d5cca9..4c7ae4d77 100644
--- a/glamor/glamor_gradient.c
+++ b/glamor/glamor_gradient.c
@@ -605,27 +605,35 @@ _glamor_gradient_convert_trans_matrix(PictTransform *from, float to[3][3],
      * T_s = | w*t21/h  t22      t23/h|
      *       | w*t31    h*t32    t33  |
      *       --                      --
+     *
+     * Because GLES2 cannot do trasposed mat by spec, we did transposing inside this function
+     * already, and matrix becoming look like this:
+     *       --                      --
+     *       | t11      w*t21/h  t31*w|
+     * T_s = | h*t12/w  t22      t32*h|
+     *       | t13/w    t23/h    t33  |
+     *       --                      --
      */
 
     to[0][0] = (float) pixman_fixed_to_double(from->matrix[0][0]);
-    to[0][1] = (float) pixman_fixed_to_double(from->matrix[0][1])
+    to[1][0] = (float) pixman_fixed_to_double(from->matrix[0][1])
         * (normalize ? (((float) height) / ((float) width)) : 1.0);
-    to[0][2] = (float) pixman_fixed_to_double(from->matrix[0][2])
+    to[2][0] = (float) pixman_fixed_to_double(from->matrix[0][2])
         / (normalize ? ((float) width) : 1.0);
 
-    to[1][0] = (float) pixman_fixed_to_double(from->matrix[1][0])
+    to[0][1] = (float) pixman_fixed_to_double(from->matrix[1][0])
         * (normalize ? (((float) width) / ((float) height)) : 1.0);
     to[1][1] = (float) pixman_fixed_to_double(from->matrix[1][1]);
-    to[1][2] = (float) pixman_fixed_to_double(from->matrix[1][2])
+    to[2][1] = (float) pixman_fixed_to_double(from->matrix[1][2])
         / (normalize ? ((float) height) : 1.0);
 
-    to[2][0] = (float) pixman_fixed_to_double(from->matrix[2][0])
+    to[0][2] = (float) pixman_fixed_to_double(from->matrix[2][0])
         * (normalize ? ((float) width) : 1.0);
-    to[2][1] = (float) pixman_fixed_to_double(from->matrix[2][1])
+    to[1][2] = (float) pixman_fixed_to_double(from->matrix[2][1])
         * (normalize ? ((float) height) : 1.0);
     to[2][2] = (float) pixman_fixed_to_double(from->matrix[2][2]);
 
-    DEBUGF("the transform matrix is:\n%f\t%f\t%f\n%f\t%f\t%f\n%f\t%f\t%f\n",
+    DEBUGF("the transposed transform matrix is:\n%f\t%f\t%f\n%f\t%f\t%f\n%f\t%f\t%f\n",
            to[0][0], to[0][1], to[0][2],
            to[1][0], to[1][1], to[1][2], to[2][0], to[2][1], to[2][2]);
 }
@@ -950,11 +958,12 @@ glamor_generate_radial_gradient_picture(ScreenPtr screen,
         _glamor_gradient_convert_trans_matrix(src_picture->transform,
                                               transform_mat, width, height, 0);
         glUniformMatrix3fv(transform_mat_uniform_location,
-                           1, 1, &transform_mat[0][0]);
+                           1, GL_FALSE, &transform_mat[0][0]);
     }
     else {
+        /* identity matrix dont need to be transposed */
         glUniformMatrix3fv(transform_mat_uniform_location,
-                           1, 1, &identity_mat[0][0]);
+                           1, GL_FALSE, &identity_mat[0][0]);
     }
 
     if (!_glamor_gradient_set_pixmap_destination
@@ -1266,11 +1275,12 @@ glamor_generate_linear_gradient_picture(ScreenPtr screen,
         _glamor_gradient_convert_trans_matrix(src_picture->transform,
                                               transform_mat, width, height, 1);
         glUniformMatrix3fv(transform_mat_uniform_location,
-                           1, 1, &transform_mat[0][0]);
+                           1, GL_FALSE, &transform_mat[0][0]);
     }
     else {
+        /* identity matrix dont need to be transposed */
         glUniformMatrix3fv(transform_mat_uniform_location,
-                           1, 1, &identity_mat[0][0]);
+                           1, GL_FALSE, &identity_mat[0][0]);
     }
 
     if (!_glamor_gradient_set_pixmap_destination
-- 
GitLab


From 2b4bd421867799cb34e79b038ac47877548fb0c0 Mon Sep 17 00:00:00 2001
From: Yuriy <uuvasiliev@yandex.ru>
Date: Thu, 16 Sep 2021 14:47:44 +0300
Subject: [PATCH 05/10] glamor: fix CbCr format handling

In GLES2, we cannot do GL_RED or GL_RG without GL_EXT_texture_rg.
So, add check for GL_EXT_texture_rg to make it working. Also add
a yuv2 pixman format into render.h to make Xv yuv rendering works.

Signed-off-by: Yuriy Vasilev <uuvasiliev@yandex.ru>

Reviewed-by: Adam Jackson <ajax@redhat.com>
Reviewed-by: Emma Anholt <emma@anholt.net>
---
 glamor/glamor.c      | 19 +++++++++++++++----
 glamor/glamor_priv.h |  1 +
 render/picture.h     |  5 ++++-
 3 files changed, 20 insertions(+), 5 deletions(-)

diff --git a/glamor/glamor.c b/glamor/glamor.c
index 0a757db35..c6bb01d8e 100644
--- a/glamor/glamor.c
+++ b/glamor/glamor.c
@@ -223,7 +223,7 @@ glamor_create_pixmap(ScreenPtr screen, int w, int h, int depth,
 
     pixmap_priv = glamor_get_pixmap_private(pixmap);
 
-    pixmap_priv->is_cbcr = (usage == GLAMOR_CREATE_FORMAT_CBCR);
+    pixmap_priv->is_cbcr = (GLAMOR_CREATE_FORMAT_CBCR & usage) == GLAMOR_CREATE_FORMAT_CBCR;
 
     pitch = (((w * pixmap->drawable.bitsPerPixel + 7) / 8) + 3) & ~3;
     screen->ModifyPixmapHeader(pixmap, w, h, 0, 0, pitch, NULL);
@@ -550,9 +550,10 @@ glamor_setup_formats(ScreenPtr screen)
     glamor_screen_private *glamor_priv = glamor_get_screen_private(screen);
 
     /* Prefer r8 textures since they're required by GLES3 and core,
-     * only falling back to a8 if we can't do them.
+     * only falling back to a8 if we can't do them. We cannot do them
+     * on GLES2 due to lack of texture swizzle.
      */
-    if (glamor_priv->is_gles || epoxy_has_gl_extension("GL_ARB_texture_rg")) {
+    if (glamor_priv->has_rg && glamor_priv->has_texture_swizzle) {
         glamor_add_format(screen, 1, PICT_a1,
                           GL_R8, GL_RED, GL_UNSIGNED_BYTE, FALSE);
         glamor_add_format(screen, 8, PICT_a8,
@@ -606,8 +607,13 @@ glamor_setup_formats(ScreenPtr screen)
     }
 
     glamor_priv->cbcr_format.depth = 16;
-    glamor_priv->cbcr_format.internalformat = GL_RG8;
+    if (glamor_priv->is_gles && glamor_priv->has_rg) {
+        glamor_priv->cbcr_format.internalformat = GL_RG;
+    } else {
+        glamor_priv->cbcr_format.internalformat = GL_RG8;
+    }
     glamor_priv->cbcr_format.format = GL_RG;
+    glamor_priv->cbcr_format.render_format = PICT_yuv2;
     glamor_priv->cbcr_format.type = GL_UNSIGNED_BYTE;
     glamor_priv->cbcr_format.rendering_supported = TRUE;
 }
@@ -787,6 +793,11 @@ glamor_init(ScreenPtr screen, unsigned int flags)
     glamor_priv->has_clear_texture =
         epoxy_gl_version() >= 44 ||
         epoxy_has_gl_extension("GL_ARB_clear_texture");
+    /* GL_EXT_texture_rg is part of GLES3 core */
+    glamor_priv->has_rg =
+        (glamor_priv->is_gles && epoxy_gl_version() >= 30) ||
+        epoxy_has_gl_extension("GL_EXT_texture_rg") ||
+        epoxy_has_gl_extension("GL_ARB_texture_rg");
 
     glamor_priv->can_copyplane = (gl_version >= 30);
 
diff --git a/glamor/glamor_priv.h b/glamor/glamor_priv.h
index 028a6d374..da20bc5aa 100644
--- a/glamor/glamor_priv.h
+++ b/glamor/glamor_priv.h
@@ -216,6 +216,7 @@ typedef struct glamor_screen_private {
     Bool has_dual_blend;
     Bool has_clear_texture;
     Bool has_texture_swizzle;
+    Bool has_rg;
     Bool is_core_profile;
     Bool can_copyplane;
     Bool use_gpu_shader4;
diff --git a/render/picture.h b/render/picture.h
index 4499a0021..c3a73d1d8 100644
--- a/render/picture.h
+++ b/render/picture.h
@@ -125,7 +125,10 @@ typedef enum _PictFormatShort {
 /* 1bpp formats */
     PICT_a1 = PIXMAN_a1,
 
-    PICT_g1 = PIXMAN_g1
+    PICT_g1 = PIXMAN_g1,
+
+/* YCbCr formats */
+    PICT_yuv2 = PIXMAN_yuy2
 } PictFormatShort;
 
 /*
-- 
GitLab


From ee10d7827b25a7334320a1ea65f12db69a1b5f81 Mon Sep 17 00:00:00 2001
From: Vasily Khoruzhick <anarsoul@gmail.com>
Date: Fri, 27 May 2022 18:00:56 -0700
Subject: [PATCH 06/10] glamor: use dual source blend on GL 2.1 with
 ARB_ES2_compatibility

ARB_blend_func_extended may be exposed even without GLSL 1.30.
In order to use it we need GLES2 shaders that are available if
ARB_ES2_compatibility is exposed.

Signed-off-by: Vasily Khoruzhick <anarsoul@gmail.com>

Reviewed-by: Adam Jackson <ajax@redhat.com>
Reviewed-by: Emma Anholt <emma@anholt.net>
---
 glamor/glamor.c                  |  6 ++++--
 glamor/glamor_composite_glyphs.c | 20 +++++++++++++++++++-
 glamor/glamor_program.c          | 23 ++++++++++++++++-------
 glamor/glamor_program.h          |  5 +++--
 glamor/glamor_render.c           | 32 ++++++++++++++++++++++++++++----
 5 files changed, 70 insertions(+), 16 deletions(-)

diff --git a/glamor/glamor.c b/glamor/glamor.c
index c6bb01d8e..f15b5a18a 100644
--- a/glamor/glamor.c
+++ b/glamor/glamor.c
@@ -788,8 +788,10 @@ glamor_init(ScreenPtr screen, unsigned int flags)
         epoxy_gl_version() >= 30 ||
         epoxy_has_gl_extension("GL_NV_pack_subimage");
     glamor_priv->has_dual_blend =
-        glamor_glsl_has_ints(glamor_priv) &&
-        epoxy_has_gl_extension("GL_ARB_blend_func_extended");
+        (epoxy_has_gl_extension("GL_ARB_blend_func_extended") &&
+        (glamor_glsl_has_ints(glamor_priv) ||
+        epoxy_has_gl_extension("GL_ARB_ES2_compatibility"))) ||
+        epoxy_has_gl_extension("GL_EXT_blend_func_extended");
     glamor_priv->has_clear_texture =
         epoxy_gl_version() >= 44 ||
         epoxy_has_gl_extension("GL_ARB_clear_texture");
diff --git a/glamor/glamor_composite_glyphs.c b/glamor/glamor_composite_glyphs.c
index 147e3bb31..c69b940d4 100644
--- a/glamor/glamor_composite_glyphs.c
+++ b/glamor/glamor_composite_glyphs.c
@@ -208,6 +208,22 @@ static const glamor_facet glamor_facet_composite_glyphs_120 = {
     .locations = glamor_program_location_atlas,
 };
 
+static const glamor_facet glamor_facet_composite_glyphs_gles2 = {
+    .name = "composite_glyphs",
+    .version = 100,
+    .fs_extensions = ("#extension GL_EXT_blend_func_extended : enable\n"),
+    .vs_vars = ("attribute vec2 primitive;\n"
+                "attribute vec2 source;\n"
+                "varying vec2 glyph_pos;\n"),
+    .vs_exec = ("       vec2 pos = vec2(0,0);\n"
+                GLAMOR_POS(gl_Position, primitive.xy)
+                "       glyph_pos = source.xy * ATLAS_DIM_INV;\n"),
+    .fs_vars = ("varying vec2 glyph_pos;\n"),
+    .fs_exec = ("       vec4 mask = texture2D(atlas, glyph_pos);\n"),
+    .source_name = "source",
+    .locations = glamor_program_location_atlas,
+};
+
 static Bool
 glamor_glyphs_init_facet(ScreenPtr screen)
 {
@@ -442,7 +458,9 @@ glamor_composite_glyphs(CARD8 op,
                         else
                             prog = glamor_setup_program_render(op, src, glyph_pict, dst,
                                                                glyphs_program,
-                                                               &glamor_facet_composite_glyphs_120,
+                                                               glamor_priv->has_dual_blend ?
+                                                                   &glamor_facet_composite_glyphs_gles2 :
+                                                                   &glamor_facet_composite_glyphs_120,
                                                                glamor_priv->glyph_defines);
                         if (!prog)
                             goto bail_one;
diff --git a/glamor/glamor_program.c b/glamor/glamor_program.c
index d8ddb4c77..46a506aaf 100644
--- a/glamor/glamor_program.c
+++ b/glamor/glamor_program.c
@@ -201,6 +201,8 @@ static const char vs_template[] =
 static const char fs_template[] =
     "%s"                                /* version */
     "%s"                                /* exts */
+    "%s"                                /* prim fs_extensions */
+    "%s"                                /* fill fs_extensions */
     GLAMOR_DEFAULT_PRECISION
     "%s"                                /* defines */
     "%s"                                /* prim fs_vars */
@@ -312,6 +314,8 @@ glamor_build_program(ScreenPtr          screen,
     if (asprintf(&fs_prog_string,
                  fs_template,
                  str(version_string),
+                 str(prim->fs_extensions),
+                 str(fill->fs_extensions),
                  gpu_shader4 ? "#extension GL_EXT_gpu_shader4 : require\n#define texelFetch texelFetch2D\n#define uint unsigned int\n" : "",
                  str(defines),
                  str(prim->fs_vars),
@@ -494,7 +498,8 @@ glamor_set_blend(CARD8 op, glamor_program_alpha alpha, PicturePtr dst)
     }
 
     /* Set up the source alpha value for blending in component alpha mode. */
-    if (alpha == glamor_program_alpha_dual_blend) {
+    if (alpha == glamor_program_alpha_dual_blend ||
+        alpha == glamor_program_alpha_dual_blend_gles2) {
         switch (dst_blend) {
         case GL_SRC_ALPHA:
             dst_blend = GL_SRC1_COLOR;
@@ -581,11 +586,13 @@ static const glamor_facet *glamor_facet_source[glamor_program_source_count] = {
 };
 
 static const char *glamor_combine[] = {
-    [glamor_program_alpha_normal]    = "       gl_FragColor = source * mask.a;\n",
-    [glamor_program_alpha_ca_first]  = "       gl_FragColor = source.a * mask;\n",
-    [glamor_program_alpha_ca_second] = "       gl_FragColor = source * mask;\n",
-    [glamor_program_alpha_dual_blend] = "      color0 = source * mask;\n"
-                                        "      color1 = source.a * mask;\n"
+    [glamor_program_alpha_normal]    = "        gl_FragColor = source * mask.a;\n",
+    [glamor_program_alpha_ca_first]  = "        gl_FragColor = source.a * mask;\n",
+    [glamor_program_alpha_ca_second] = "        gl_FragColor = source * mask;\n",
+    [glamor_program_alpha_dual_blend] = "       color0 = source * mask;\n"
+                                        "       color1 = source.a * mask;\n",
+    [glamor_program_alpha_dual_blend_gles2] = " gl_FragColor = source * mask;\n"
+                                              " gl_SecondaryFragColorEXT = source.a * mask;\n"
 };
 
 static Bool
@@ -633,7 +640,9 @@ glamor_setup_program_render(CARD8                 op,
 
     if (glamor_is_component_alpha(mask)) {
         if (glamor_priv->has_dual_blend) {
-            alpha = glamor_program_alpha_dual_blend;
+            alpha = glamor_glsl_has_ints(glamor_priv) ?
+                    glamor_program_alpha_dual_blend :
+                    glamor_program_alpha_dual_blend_gles2;
         } else {
             /* This only works for PictOpOver */
             if (op != PictOpOver)
diff --git a/glamor/glamor_program.h b/glamor/glamor_program.h
index ab6e46f7b..0bd918fff 100644
--- a/glamor/glamor_program.h
+++ b/glamor/glamor_program.h
@@ -44,6 +44,7 @@ typedef enum {
     glamor_program_alpha_ca_first,
     glamor_program_alpha_ca_second,
     glamor_program_alpha_dual_blend,
+    glamor_program_alpha_dual_blend_gles2,
     glamor_program_alpha_count
 } glamor_program_alpha;
 
@@ -56,8 +57,8 @@ typedef Bool (*glamor_use_render) (CARD8 op, PicturePtr src, PicturePtr dst, gla
 typedef struct {
     const char                          *name;
     const int                           version;
-    char                                *vs_defines;
-    char                                *fs_defines;
+    char                                *vs_extensions;
+    const char                          *fs_extensions;
     const char                          *vs_vars;
     const char                          *vs_exec;
     const char                          *fs_vars;
diff --git a/glamor/glamor_render.c b/glamor/glamor_render.c
index 2af65bf93..c9a125ef9 100644
--- a/glamor/glamor_render.c
+++ b/glamor/glamor_render.c
@@ -223,6 +223,15 @@ glamor_create_composite_fs(struct shader_key *key)
         "}\n";
     const char *header_ca_dual_blend =
         "#version 130\n";
+    const char *in_ca_dual_blend_gles2 =
+        "void main()\n"
+        "{\n"
+        "	gl_FragColor = dest_swizzle(get_source() * get_mask());\n"
+        "	gl_SecondaryFragColorEXT = dest_swizzle(get_source().a * get_mask());\n"
+        "}\n";
+    const char *header_ca_dual_blend_gles2 =
+        "#version 100\n"
+        "#extension GL_EXT_blend_func_extended : require\n";
 
     char *source;
     const char *source_fetch;
@@ -294,6 +303,10 @@ glamor_create_composite_fs(struct shader_key *key)
         in = in_ca_dual_blend;
         header = header_ca_dual_blend;
         break;
+    case glamor_program_alpha_dual_blend_gles2:
+        in = in_ca_dual_blend_gles2;
+        header = header_ca_dual_blend_gles2;
+        break;
     default:
         FatalError("Bad composite IN type");
     }
@@ -327,6 +340,8 @@ glamor_create_composite_vs(struct shader_key *key)
     const char *main_closing = "}\n";
     const char *source_coords_setup = "";
     const char *mask_coords_setup = "";
+    const char *version_gles2 = "#version 100\n";
+    const char *version = "";
     char *source;
     GLuint prog;
 
@@ -336,10 +351,15 @@ glamor_create_composite_vs(struct shader_key *key)
     if (key->mask != SHADER_MASK_NONE && key->mask != SHADER_MASK_SOLID)
         mask_coords_setup = mask_coords;
 
+    if (key->in == glamor_program_alpha_dual_blend_gles2)
+        version = version_gles2;
+
     XNFasprintf(&source,
+                "%s"
+                GLAMOR_DEFAULT_PRECISION
                 "%s%s%s%s",
-                main_opening,
-                source_coords_setup, mask_coords_setup, main_closing);
+                version, main_opening, source_coords_setup,
+                mask_coords_setup, main_closing);
 
     prog = glamor_compile_glsl_prog(GL_VERTEX_SHADER, source);
     free(source);
@@ -701,6 +721,7 @@ combine_pict_format(PictFormatShort * des, const PictFormatShort src,
         mask_type = PICT_FORMAT_TYPE(mask);
         break;
     case glamor_program_alpha_dual_blend:
+    case glamor_program_alpha_dual_blend_gles2:
         src_type = PICT_FORMAT_TYPE(src);
         mask_type = PICT_FORMAT_TYPE(mask);
         break;
@@ -886,8 +907,11 @@ glamor_composite_choose_shader(CARD8 op,
         else {
             if (op == PictOpClear)
                 key.mask = SHADER_MASK_NONE;
-            else if (glamor_priv->has_dual_blend)
-                key.in = glamor_program_alpha_dual_blend;
+            else if (glamor_priv->has_dual_blend) {
+                key.in = glamor_glsl_has_ints(glamor_priv) ?
+                    glamor_program_alpha_dual_blend :
+                    glamor_program_alpha_dual_blend_gles2;
+            }
             else if (op == PictOpSrc || op == PictOpAdd
                      || op == PictOpIn || op == PictOpOut
                      || op == PictOpOverReverse)
-- 
GitLab


From fc6eb52efaa2bbecf8c67687172409859ae40fe9 Mon Sep 17 00:00:00 2001
From: Konstantin <ria.freelander@gmail.com>
Date: Tue, 28 Jun 2022 12:28:39 +0300
Subject: [PATCH 07/10] glamor: fix XVideo run with GLES

For now, it sets .version=120, which prevents shader from compiling on ES.
We just force version of shaders to be always 100 on ES, because we use
only 120 shaders on ES anyway, and all shaders works.

Signed-off-by: Konstantin Pugin <ria.freelander@gmail.com>

Reviewed-by: Adam Jackson <ajax@redhat.com>
Reviewed-by: Emma Anholt <emma@anholt.net>
---
 glamor/glamor_program.c | 5 +++++
 1 file changed, 5 insertions(+)

diff --git a/glamor/glamor_program.c b/glamor/glamor_program.c
index 46a506aaf..f361b726e 100644
--- a/glamor/glamor_program.c
+++ b/glamor/glamor_program.c
@@ -283,6 +283,11 @@ glamor_build_program(ScreenPtr          screen,
             gpu_shader4 = TRUE;
         }
     }
+    /* For now, fix shader version to GLES as 100. We will fall with 130 shaders
+     * in previous check due to forcibly set 120 glsl for GLES. But this patch
+     * makes xv shaders to work */
+    if(version && glamor_priv->is_gles)
+        version = 100;
 
     vs_vars = vs_location_vars(locations);
     fs_vars = fs_location_vars(locations);
-- 
GitLab


From e0783fd3d68ce22319f3d5cf31f173f45253fb57 Mon Sep 17 00:00:00 2001
From: Konstantin Pugin <ria.freelander@gmail.com>
Date: Sun, 10 Jul 2022 17:08:44 +0300
Subject: [PATCH 08/10] glamor: introduce fb_caveats flag

If texture can be uploaded to GL using glTexImage2D normally, but
cannot be read back using glReadPixels, we still can accelerate it,
but we cannot create pixmap with FBO using this texture type. So,
add a flag to avoid such creations.

Fixes #1362

Signed-off-by: Konstantin Pugin <ria.freelander@gmail.com>
---
 glamor/glamor.c      | 84 ++++++++++++++++++++++++++++++--------------
 glamor/glamor_priv.h |  7 ++++
 2 files changed, 64 insertions(+), 27 deletions(-)

diff --git a/glamor/glamor.c b/glamor/glamor.c
index f15b5a18a..bfab706ea 100644
--- a/glamor/glamor.c
+++ b/glamor/glamor.c
@@ -216,7 +216,10 @@ glamor_create_pixmap(ScreenPtr screen, int w, int h, int depth,
              w <= glamor_priv->glyph_max_dim &&
              h <= glamor_priv->glyph_max_dim)
          || (w == 0 && h == 0)
-         || !glamor_priv->formats[depth].rendering_supported))
+         || !glamor_priv->formats[depth].rendering_supported
+         || (glamor_priv->formats[depth].fb_caveats &&
+              (usage != GLAMOR_CREATE_FBO_NO_FBO
+               || usage != GLAMOR_CREATE_PIXMAP_NO_TEXTURE))))
         return fbCreatePixmap(screen, w, h, depth, usage);
     else
         pixmap = fbCreatePixmap(screen, 0, 0, depth, usage);
@@ -459,6 +462,47 @@ glamor_format_for_pixmap(PixmapPtr pixmap)
         return &glamor_priv->formats[pixmap->drawable.depth];
 }
 
+/**
+* Check whether image with this depth has framebuffer issues in GL.
+* This check is run on GL ES when rendering is supported and we need
+* to check if format is color-renderable and implementation return
+* requested format/type combo to make format readable
+*/
+static Bool 
+glamor_check_fb_caveats(ScreenPtr screen, unsigned tex, int depth,
+                  GLenum format, GLenum type)
+{
+    unsigned fbo;
+    int read_format, read_type;
+    GLenum status;
+
+    glGenFramebuffers(1, &fbo);
+    glBindFramebuffer(GL_FRAMEBUFFER, fbo);
+    glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,
+                            GL_TEXTURE_2D, tex, 0);
+    status = glCheckFramebufferStatus(GL_FRAMEBUFFER);
+    if (status != GL_FRAMEBUFFER_COMPLETE) {
+        ErrorF("glamor: Test fbo for depth %d incomplete.  "
+                "Texture will not be readable.\n", depth);
+        glDeleteFramebuffers(1, &fbo);
+        return TRUE;
+    }
+
+    glGetIntegerv(GL_IMPLEMENTATION_COLOR_READ_FORMAT, &read_format);
+    glGetIntegerv(GL_IMPLEMENTATION_COLOR_READ_TYPE, &read_type);
+
+    glDeleteFramebuffers(1, &fbo);
+
+    if (format != read_format || type != read_type) {
+        ErrorF("glamor: Implementation returned 0x%x/0x%x read format/type "
+                "for depth %d, expected 0x%x/0x%x.  "
+                "Texture will not be readable.\n",
+                read_format, read_type, depth, format, type);
+        return TRUE;
+    }
+    return FALSE;
+}
+
 static void
 glamor_add_format(ScreenPtr screen, int depth, CARD32 render_format,
                   GLenum internalformat, GLenum format, GLenum type,
@@ -466,6 +510,7 @@ glamor_add_format(ScreenPtr screen, int depth, CARD32 render_format,
 {
     glamor_screen_private *glamor_priv = glamor_get_screen_private(screen);
     struct glamor_format *f = &glamor_priv->formats[depth];
+    Bool fb_caveats = FALSE;
 
     /* If we're trying to run on GLES, make sure that we get the read
      * formats that we're expecting, since glamor_transfer relies on
@@ -478,43 +523,26 @@ glamor_add_format(ScreenPtr screen, int depth, CARD32 render_format,
      * screeninit.
      */
     if (rendering_supported && glamor_priv->is_gles) {
-        unsigned fbo, tex;
-        int read_format, read_type;
-        GLenum status;
+        unsigned tex;
 
+        /* Dummy glGetError() make sure second check will not fail from prev
+         * errors */
+        tex = glGetError();
         glGenTextures(1, &tex);
         glBindTexture(GL_TEXTURE_2D, tex);
         glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
         glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
         glTexImage2D(GL_TEXTURE_2D, 0, internalformat, 1, 1, 0,
                      format, type, NULL);
-
-        glGenFramebuffers(1, &fbo);
-        glBindFramebuffer(GL_FRAMEBUFFER, fbo);
-        glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,
-                               GL_TEXTURE_2D, tex, 0);
-        status = glCheckFramebufferStatus(GL_FRAMEBUFFER);
-        if (status != GL_FRAMEBUFFER_COMPLETE) {
-            ErrorF("glamor: Test fbo for depth %d incomplete.  "
-                   "Falling back to software.\n", depth);
+        if(glGetError() != GL_NO_ERROR)
+        {
+            ErrorF("glamor: Cannot upload texture for depth %d.  "
+                "Falling back to software.\n", depth);
             glDeleteTextures(1, &tex);
-            glDeleteFramebuffers(1, &fbo);
             return;
         }
-
-        glGetIntegerv(GL_IMPLEMENTATION_COLOR_READ_FORMAT, &read_format);
-        glGetIntegerv(GL_IMPLEMENTATION_COLOR_READ_TYPE, &read_type);
-
+        fb_caveats = glamor_check_fb_caveats(screen, tex, depth, format, type);
         glDeleteTextures(1, &tex);
-        glDeleteFramebuffers(1, &fbo);
-
-        if (format != read_format || type != read_type) {
-            ErrorF("glamor: Implementation returned 0x%x/0x%x read format/type "
-                   "for depth %d, expected 0x%x/0x%x.  "
-                   "Falling back to software.\n",
-                   read_format, read_type, depth, format, type);
-            return;
-        }
     }
 
     f->depth = depth;
@@ -523,6 +551,7 @@ glamor_add_format(ScreenPtr screen, int depth, CARD32 render_format,
     f->format = format;
     f->type = type;
     f->rendering_supported = rendering_supported;
+    f->fb_caveats = fb_caveats;
 }
 
 /* Set up the GL format/types that glamor will use for the various depths
@@ -616,6 +645,7 @@ glamor_setup_formats(ScreenPtr screen)
     glamor_priv->cbcr_format.render_format = PICT_yuv2;
     glamor_priv->cbcr_format.type = GL_UNSIGNED_BYTE;
     glamor_priv->cbcr_format.rendering_supported = TRUE;
+    glamor_priv->cbcr_format.fb_caveats = FALSE;
 }
 
 /** Set up glamor for an already-configured GL context. */
diff --git a/glamor/glamor_priv.h b/glamor/glamor_priv.h
index da20bc5aa..b47063f11 100644
--- a/glamor/glamor_priv.h
+++ b/glamor/glamor_priv.h
@@ -175,6 +175,13 @@ struct glamor_format {
      * just before upload)
      */
     Bool rendering_supported;
+    /**
+     * Whether image with this depth is framebuffer-complete in GL.
+     * This flag is set on GL ES when rendering is supported without
+     * conversion, but reading from framebuffer can bring some caveats
+     * like different format combination or incomplete framebuffer.
+     */
+    Bool fb_caveats;
 };
 
 struct glamor_saved_procs {
-- 
GitLab


From 49ce69e1674842f6f7c332f4223a61a3186b9892 Mon Sep 17 00:00:00 2001
From: Konstantin <ria.freelander@gmail.com>
Date: Tue, 19 Jul 2022 11:22:30 +0300
Subject: [PATCH 09/10] glamor: add gl_PointSize for ES shaders

According to ESSL 1.0, if gl_PointSize is not defined explicitly,
then it will be undefined behaviour in shaders which use points.
So, define gl_PointSize explicitly for ES as 1.0, which is
desktop OpenGL default, so, shaders for ES and GL glamor will
behave the same.

As @anholt requested, define this only for minimal amount of shaders
(point and glyphbit ones), to make sure than performance will not
affected

Signed-off-by: Konstantin <ria.freelander@gmail.com>
---
 glamor/glamor_glyphblt.c | 1 +
 glamor/glamor_points.c   | 3 ++-
 glamor/glamor_priv.h     | 5 +++++
 3 files changed, 8 insertions(+), 1 deletion(-)

diff --git a/glamor/glamor_glyphblt.c b/glamor/glamor_glyphblt.c
index 78315ea9b..412877224 100644
--- a/glamor/glamor_glyphblt.c
+++ b/glamor/glamor_glyphblt.c
@@ -34,6 +34,7 @@ static const glamor_facet glamor_facet_poly_glyph_blt = {
     .name = "poly_glyph_blt",
     .vs_vars = "attribute vec2 primitive;\n",
     .vs_exec = ("       vec2 pos = vec2(0,0);\n"
+                GLAMOR_DEFAULT_POINT_SIZE
                 GLAMOR_POS(gl_Position, primitive)),
 };
 
diff --git a/glamor/glamor_points.c b/glamor/glamor_points.c
index faf6f433b..d31da6789 100644
--- a/glamor/glamor_points.c
+++ b/glamor/glamor_points.c
@@ -32,7 +32,8 @@
 static const glamor_facet glamor_facet_point = {
     .name = "poly_point",
     .vs_vars = "attribute vec2 primitive;\n",
-    .vs_exec = GLAMOR_POS(gl_Position, primitive),
+    .vs_exec = (GLAMOR_DEFAULT_POINT_SIZE 
+                GLAMOR_POS(gl_Position, primitive)),
 };
 
 static Bool
diff --git a/glamor/glamor_priv.h b/glamor/glamor_priv.h
index b47063f11..956dd6a0b 100644
--- a/glamor/glamor_priv.h
+++ b/glamor/glamor_priv.h
@@ -49,6 +49,11 @@
     "precision mediump float;\n"  \
     "#endif\n"
 
+#define GLAMOR_DEFAULT_POINT_SIZE  \
+    "#ifdef GL_ES\n"              \
+    "       gl_PointSize = 1.0;\n"  \
+    "#endif\n"
+
 #include "glyphstr.h"
 
 #include "glamor_debug.h"
-- 
GitLab


From 904b0e0165e324e96b08f87f64264f18001d707c Mon Sep 17 00:00:00 2001
From: Konstantin Pugin <ria.freelander@gmail.com>
Date: Sun, 24 Jul 2022 16:03:51 +0300
Subject: [PATCH 10/10] glamor: support GLES3 shaders

Some hardware (preferably mobile) working on GLES3 way faster than
on desktop GL and supports more features. This commit will allow using
GLES3 if glamor is running over GL ES, and version 3 is supported.

Changes are the following:
1. Add compatibility layer for 120/GLES2 shaders with defines in and out
2. Switch attribute and varying to in and out in almost all shaders
   (aside gradient)
3. Add newGL-only frag_color variable, which defines as gl_FragColor on
   old pipelines
4. Switch all shaders to use frag_color.

Signed-off-by: Konstantin Pugin <ria.freelander@gmail.com>
---
 glamor/glamor.c                  | 12 +------
 glamor/glamor_composite_glyphs.c | 10 +++---
 glamor/glamor_copy.c             | 12 +++----
 glamor/glamor_dash.c             | 14 ++++----
 glamor/glamor_glyphblt.c         |  2 +-
 glamor/glamor_lines.c            |  2 +-
 glamor/glamor_points.c           |  2 +-
 glamor/glamor_priv.h             | 12 +++++++
 glamor/glamor_program.c          | 47 ++++++++++++++-----------
 glamor/glamor_rects.c            |  4 +--
 glamor/glamor_render.c           | 60 +++++++++++++++++---------------
 glamor/glamor_segs.c             |  2 +-
 glamor/glamor_spans.c            |  2 +-
 glamor/glamor_text.c             | 14 ++++----
 glamor/glamor_xv.c               | 20 +++++------
 15 files changed, 114 insertions(+), 101 deletions(-)

diff --git a/glamor/glamor.c b/glamor/glamor.c
index bfab706ea..13d0219a7 100644
--- a/glamor/glamor.c
+++ b/glamor/glamor.c
@@ -718,17 +718,6 @@ glamor_init(ScreenPtr screen, unsigned int flags)
 
     glamor_priv->glsl_version = epoxy_glsl_version();
 
-    if (glamor_priv->is_gles) {
-        /* Force us back to the base version of our programs on an ES
-         * context, anyway.  Basically glamor only uses desktop 1.20
-         * or 1.30 currently.  1.30's new features are also present in
-         * ES 3.0, but our glamor_program.c constructions use a lot of
-         * compatibility features (to reduce the diff between 1.20 and
-         * 1.30 programs).
-         */
-        glamor_priv->glsl_version = 120;
-    }
-
     /* We'd like to require GL_ARB_map_buffer_range or
      * GL_OES_map_buffer_range, since it offers more information to
      * the driver than plain old glMapBuffer() or glBufferSubData().
@@ -762,6 +751,7 @@ glamor_init(ScreenPtr screen, unsigned int flags)
          * etnaviv offers GLSL 140 with OpenGL 2.1.
          */
         if (glamor_glsl_has_ints(glamor_priv) &&
+            !glamor_priv->is_gles &&
             !epoxy_has_gl_extension("GL_ARB_instanced_arrays"))
                 glamor_priv->glsl_version = 120;
     } else {
diff --git a/glamor/glamor_composite_glyphs.c b/glamor/glamor_composite_glyphs.c
index c69b940d4..102ed4640 100644
--- a/glamor/glamor_composite_glyphs.c
+++ b/glamor/glamor_composite_glyphs.c
@@ -180,16 +180,16 @@ glamor_glyph_add(struct glamor_glyph_atlas *atlas, DrawablePtr glyph_draw)
 static const glamor_facet glamor_facet_composite_glyphs_130 = {
     .name = "composite_glyphs",
     .version = 130,
-    .vs_vars = ("attribute vec4 primitive;\n"
-                "attribute vec2 source;\n"
-                "varying vec2 glyph_pos;\n"),
+    .vs_vars = ("in vec4 primitive;\n"
+                "in vec2 source;\n"
+                "out vec2 glyph_pos;\n"),
     .vs_exec = ("       vec2 pos = primitive.zw * vec2(gl_VertexID&1, (gl_VertexID&2)>>1);\n"
                 GLAMOR_POS(gl_Position, (primitive.xy + pos))
                 "       glyph_pos = (source + pos) * ATLAS_DIM_INV;\n"),
-    .fs_vars = ("varying vec2 glyph_pos;\n"
+    .fs_vars = ("in vec2 glyph_pos;\n"
                 "out vec4 color0;\n"
                 "out vec4 color1;\n"),
-    .fs_exec = ("       vec4 mask = texture2D(atlas, glyph_pos);\n"),
+    .fs_exec = ("       vec4 mask = texture(atlas, glyph_pos);\n"),
     .source_name = "source",
     .locations = glamor_program_location_atlas,
 };
diff --git a/glamor/glamor_copy.c b/glamor/glamor_copy.c
index 1ab2be6c0..eae70e95f 100644
--- a/glamor/glamor_copy.c
+++ b/glamor/glamor_copy.c
@@ -49,10 +49,10 @@ use_copyarea(PixmapPtr dst, GCPtr gc, glamor_program *prog, void *arg)
 
 static const glamor_facet glamor_facet_copyarea = {
     "copy_area",
-    .vs_vars = "attribute vec2 primitive;\n",
+    .vs_vars = "in vec2 primitive;\n",
     .vs_exec = (GLAMOR_POS(gl_Position, primitive.xy)
                 "       fill_pos = (fill_offset + primitive.xy) * fill_size_inv;\n"),
-    .fs_exec = "       gl_FragColor = texture2D(sampler, fill_pos);\n",
+    .fs_exec = "       frag_color = texture(sampler, fill_pos);\n",
     .locations = glamor_program_location_fillsamp | glamor_program_location_fillpos,
     .use = use_copyarea,
 };
@@ -141,14 +141,14 @@ use_copyplane(PixmapPtr dst, GCPtr gc, glamor_program *prog, void *arg)
 static const glamor_facet glamor_facet_copyplane = {
     "copy_plane",
     .version = 130,
-    .vs_vars = "attribute vec2 primitive;\n",
+    .vs_vars = "in vec2 primitive;\n",
     .vs_exec = (GLAMOR_POS(gl_Position, (primitive.xy))
                 "       fill_pos = (fill_offset + primitive.xy) * fill_size_inv;\n"),
-    .fs_exec = ("       uvec4 bits = uvec4(round(texture2D(sampler, fill_pos) * bitmul));\n"
+    .fs_exec = ("       uvec4 bits = uvec4(round(texture(sampler, fill_pos) * bitmul));\n"
                 "       if ((bits & bitplane) != uvec4(0,0,0,0))\n"
-                "               gl_FragColor = fg;\n"
+                "               frag_color = fg;\n"
                 "       else\n"
-                "               gl_FragColor = bg;\n"),
+                "               frag_color = bg;\n"),
     .locations = glamor_program_location_fillsamp|glamor_program_location_fillpos|glamor_program_location_fg|glamor_program_location_bg|glamor_program_location_bitplane,
     .use = use_copyplane,
 };
diff --git a/glamor/glamor_dash.c b/glamor/glamor_dash.c
index b53ce5c50..c27367070 100644
--- a/glamor/glamor_dash.c
+++ b/glamor/glamor_dash.c
@@ -27,8 +27,8 @@
 #include "glamor_prepare.h"
 
 static const char dash_vs_vars[] =
-    "attribute vec3 primitive;\n"
-    "varying float dash_offset;\n";
+    "in vec3 primitive;\n"
+    "out float dash_offset;\n";
 
 static const char dash_vs_exec[] =
     "       dash_offset = primitive.z / dash_length;\n"
@@ -36,20 +36,20 @@ static const char dash_vs_exec[] =
     GLAMOR_POS(gl_Position, primitive.xy);
 
 static const char dash_fs_vars[] =
-    "varying float dash_offset;\n";
+    "in float dash_offset;\n";
 
 static const char on_off_fs_exec[] =
-    "       float pattern = texture2D(dash, vec2(dash_offset, 0.5)).w;\n"
+    "       float pattern = texture(dash, vec2(dash_offset, 0.5)).w;\n"
     "       if (pattern == 0.0)\n"
     "               discard;\n";
 
 /* XXX deal with stippled double dashed lines once we have stippling support */
 static const char double_fs_exec[] =
-    "       float pattern = texture2D(dash, vec2(dash_offset, 0.5)).w;\n"
+    "       float pattern = texture(dash, vec2(dash_offset, 0.5)).w;\n"
     "       if (pattern == 0.0)\n"
-    "               gl_FragColor = bg;\n"
+    "               frag_color = bg;\n"
     "       else\n"
-    "               gl_FragColor = fg;\n";
+    "               frag_color = fg;\n";
 
 
 static const glamor_facet glamor_facet_on_off_dash_lines = {
diff --git a/glamor/glamor_glyphblt.c b/glamor/glamor_glyphblt.c
index 412877224..6ae92f2d5 100644
--- a/glamor/glamor_glyphblt.c
+++ b/glamor/glamor_glyphblt.c
@@ -32,7 +32,7 @@
 
 static const glamor_facet glamor_facet_poly_glyph_blt = {
     .name = "poly_glyph_blt",
-    .vs_vars = "attribute vec2 primitive;\n",
+    .vs_vars = "in vec2 primitive;\n",
     .vs_exec = ("       vec2 pos = vec2(0,0);\n"
                 GLAMOR_DEFAULT_POINT_SIZE
                 GLAMOR_POS(gl_Position, primitive)),
diff --git a/glamor/glamor_lines.c b/glamor/glamor_lines.c
index 5d95333fe..5f0758896 100644
--- a/glamor/glamor_lines.c
+++ b/glamor/glamor_lines.c
@@ -27,7 +27,7 @@
 
 static const glamor_facet glamor_facet_poly_lines = {
     .name = "poly_lines",
-    .vs_vars = "attribute vec2 primitive;\n",
+    .vs_vars = "in vec2 primitive;\n",
     .vs_exec = ("       vec2 pos = vec2(0.0,0.0);\n"
                 GLAMOR_POS(gl_Position, primitive.xy)),
 };
diff --git a/glamor/glamor_points.c b/glamor/glamor_points.c
index d31da6789..5b38ee76e 100644
--- a/glamor/glamor_points.c
+++ b/glamor/glamor_points.c
@@ -31,7 +31,7 @@
 
 static const glamor_facet glamor_facet_point = {
     .name = "poly_point",
-    .vs_vars = "attribute vec2 primitive;\n",
+    .vs_vars = "in vec2 primitive;\n",
     .vs_exec = (GLAMOR_DEFAULT_POINT_SIZE 
                 GLAMOR_POS(gl_Position, primitive)),
 };
diff --git a/glamor/glamor_priv.h b/glamor/glamor_priv.h
index 956dd6a0b..49fe18ffd 100644
--- a/glamor/glamor_priv.h
+++ b/glamor/glamor_priv.h
@@ -54,6 +54,18 @@
     "       gl_PointSize = 1.0;\n"  \
     "#endif\n"
 
+#define GLAMOR_COMPAT_DEFINES_VS  \
+    "#define in attribute\n" \
+    "#define out varying\n"  \
+
+#define GLAMOR_COMPAT_DEFINES_FS  \
+    "#define in varying\n"  \
+    "#define frag_color gl_FragColor\n" \
+    "#define texture texture2D\n"
+
+#define GLAMOR_CORE_VARIABLES \
+    "out vec4 frag_color;\n"
+
 #include "glyphstr.h"
 
 #include "glamor_debug.h"
diff --git a/glamor/glamor_program.c b/glamor/glamor_program.c
index f361b726e..18cdb63bc 100644
--- a/glamor/glamor_program.c
+++ b/glamor/glamor_program.c
@@ -32,7 +32,7 @@ use_solid(PixmapPtr pixmap, GCPtr gc, glamor_program *prog, void *arg)
 
 const glamor_facet glamor_fill_solid = {
     .name = "solid",
-    .fs_exec = "       gl_FragColor = fg;\n",
+    .fs_exec = "       frag_color = fg;\n",
     .locations = glamor_program_location_fg,
     .use = use_solid,
 };
@@ -46,7 +46,7 @@ use_tile(PixmapPtr pixmap, GCPtr gc, glamor_program *prog, void *arg)
 static const glamor_facet glamor_fill_tile = {
     .name = "tile",
     .vs_exec =  "       fill_pos = (fill_offset + primitive.xy + pos) * fill_size_inv;\n",
-    .fs_exec =  "       gl_FragColor = texture2D(sampler, fill_pos);\n",
+    .fs_exec =  "       frag_color = texture(sampler, fill_pos);\n",
     .locations = glamor_program_location_fillsamp | glamor_program_location_fillpos,
     .use = use_tile,
 };
@@ -62,10 +62,10 @@ use_stipple(PixmapPtr pixmap, GCPtr gc, glamor_program *prog, void *arg)
 static const glamor_facet glamor_fill_stipple = {
     .name = "stipple",
     .vs_exec =  "       fill_pos = (fill_offset + primitive.xy + pos) * fill_size_inv;\n",
-    .fs_exec = ("       float a = texture2D(sampler, fill_pos).w;\n"
+    .fs_exec = ("       float a = texture(sampler, fill_pos).w;\n"
                 "       if (a == 0.0)\n"
                 "               discard;\n"
-                "       gl_FragColor = fg;\n"),
+                "       frag_color = fg;\n"),
     .locations = glamor_program_location_fg | glamor_program_location_fillsamp | glamor_program_location_fillpos,
     .use = use_stipple,
 };
@@ -82,11 +82,11 @@ use_opaque_stipple(PixmapPtr pixmap, GCPtr gc, glamor_program *prog, void *arg)
 static const glamor_facet glamor_fill_opaque_stipple = {
     .name = "opaque_stipple",
     .vs_exec =  "       fill_pos = (fill_offset + primitive.xy + pos) * fill_size_inv;\n",
-    .fs_exec = ("       float a = texture2D(sampler, fill_pos).w;\n"
+    .fs_exec = ("       float a = texture(sampler, fill_pos).w;\n"
                 "       if (a == 0.0)\n"
-                "               gl_FragColor = bg;\n"
+                "               frag_color = bg;\n"
                 "       else\n"
-                "               gl_FragColor = fg;\n"),
+                "               frag_color = fg;\n"),
     .locations = glamor_program_location_fg | glamor_program_location_bg | glamor_program_location_fillsamp | glamor_program_location_fillpos,
     .use = use_opaque_stipple
 };
@@ -121,12 +121,12 @@ static glamor_location_var location_vars[] = {
         .location = glamor_program_location_fillpos,
         .vs_vars = ("uniform vec2 fill_offset;\n"
                     "uniform vec2 fill_size_inv;\n"
-                    "varying vec2 fill_pos;\n"),
-        .fs_vars = ("varying vec2 fill_pos;\n")
+                    "out vec2 fill_pos;\n"),
+        .fs_vars = ("in vec2 fill_pos;\n")
     },
     {
         .location = glamor_program_location_font,
-        .fs_vars = "uniform usampler2D font;\n",
+        .fs_vars = "#ifdef GL_ES\nprecision mediump usampler2D;\n#endif\nuniform usampler2D font;\n",
     },
     {
         .location = glamor_program_location_bitplane,
@@ -188,6 +188,7 @@ fs_location_vars(glamor_program_location locations)
 static const char vs_template[] =
     "%s"                                /* version */
     "%s"                                /* exts */
+    "%s"                                /* in/out defines */
     "%s"                                /* defines */
     "%s"                                /* prim vs_vars */
     "%s"                                /* fill vs_vars */
@@ -204,6 +205,7 @@ static const char fs_template[] =
     "%s"                                /* prim fs_extensions */
     "%s"                                /* fill fs_extensions */
     GLAMOR_DEFAULT_PRECISION
+    "%s"                                /* in/out defines */
     "%s"                                /* defines */
     "%s"                                /* prim fs_vars */
     "%s"                                /* fill fs_vars */
@@ -283,11 +285,13 @@ glamor_build_program(ScreenPtr          screen,
             gpu_shader4 = TRUE;
         }
     }
-    /* For now, fix shader version to GLES as 100. We will fall with 130 shaders
-     * in previous check due to forcibly set 120 glsl for GLES. But this patch
-     * makes xv shaders to work */
-    if(version && glamor_priv->is_gles)
+
+    if(version == 130 && glamor_priv->is_gles && glamor_priv->glsl_version > 110)
+        version = 300;
+    else if (glamor_priv->is_gles)
         version = 100;
+    else if (!version)
+        version = 120;
 
     vs_vars = vs_location_vars(locations);
     fs_vars = fs_location_vars(locations);
@@ -298,7 +302,8 @@ glamor_build_program(ScreenPtr          screen,
         goto fail;
 
     if (version) {
-        if (asprintf(&version_string, "#version %d\n", version) < 0)
+        if (asprintf(&version_string, "#version %d %s\n", version,
+                     glamor_priv->is_gles && version > 100 ? "es" : "") < 0)
             version_string = NULL;
         if (!version_string)
             goto fail;
@@ -308,6 +313,7 @@ glamor_build_program(ScreenPtr          screen,
                  vs_template,
                  str(version_string),
                  gpu_shader4 ? "#extension GL_EXT_gpu_shader4 : require\n" : "",
+                 version < 130 ? GLAMOR_COMPAT_DEFINES_VS : "",
                  str(defines),
                  str(prim->vs_vars),
                  str(fill->vs_vars),
@@ -322,6 +328,7 @@ glamor_build_program(ScreenPtr          screen,
                  str(prim->fs_extensions),
                  str(fill->fs_extensions),
                  gpu_shader4 ? "#extension GL_EXT_gpu_shader4 : require\n#define texelFetch texelFetch2D\n#define uint unsigned int\n" : "",
+                 version < 130 ? GLAMOR_COMPAT_DEFINES_FS : GLAMOR_CORE_VARIABLES,
                  str(defines),
                  str(prim->fs_vars),
                  str(fill->fs_vars),
@@ -563,7 +570,7 @@ use_source_picture(CARD8 op, PicturePtr src, PicturePtr dst, glamor_program *pro
 static const glamor_facet glamor_source_picture = {
     .name = "render_picture",
     .vs_exec =  "       fill_pos = (fill_offset + primitive.xy + pos) * fill_size_inv;\n",
-    .fs_exec =  "       vec4 source = texture2D(sampler, fill_pos);\n",
+    .fs_exec =  "       vec4 source = texture(sampler, fill_pos);\n",
     .locations = glamor_program_location_fillsamp | glamor_program_location_fillpos,
     .use_render = use_source_picture,
 };
@@ -579,7 +586,7 @@ use_source_1x1_picture(CARD8 op, PicturePtr src, PicturePtr dst, glamor_program
 
 static const glamor_facet glamor_source_1x1_picture = {
     .name = "render_picture",
-    .fs_exec =  "       vec4 source = texture2D(sampler, vec2(0.5));\n",
+    .fs_exec =  "       vec4 source = texture(sampler, vec2(0.5));\n",
     .locations = glamor_program_location_fillsamp,
     .use_render = use_source_1x1_picture,
 };
@@ -591,9 +598,9 @@ static const glamor_facet *glamor_facet_source[glamor_program_source_count] = {
 };
 
 static const char *glamor_combine[] = {
-    [glamor_program_alpha_normal]    = "        gl_FragColor = source * mask.a;\n",
-    [glamor_program_alpha_ca_first]  = "        gl_FragColor = source.a * mask;\n",
-    [glamor_program_alpha_ca_second] = "        gl_FragColor = source * mask;\n",
+    [glamor_program_alpha_normal]    = "        frag_color = source * mask.a;\n",
+    [glamor_program_alpha_ca_first]  = "        frag_color = source.a * mask;\n",
+    [glamor_program_alpha_ca_second] = "        frag_color = source * mask;\n",
     [glamor_program_alpha_dual_blend] = "       color0 = source * mask;\n"
                                         "       color1 = source.a * mask;\n",
     [glamor_program_alpha_dual_blend_gles2] = " gl_FragColor = source * mask;\n"
diff --git a/glamor/glamor_rects.c b/glamor/glamor_rects.c
index 8cdad64e4..02a1d5953 100644
--- a/glamor/glamor_rects.c
+++ b/glamor/glamor_rects.c
@@ -28,8 +28,8 @@ static const glamor_facet glamor_facet_polyfillrect_130 = {
     .name = "poly_fill_rect",
     .version = 130,
     .source_name = "size",
-    .vs_vars = "attribute vec2 primitive;\n"
-               "attribute vec2 size;\n",
+    .vs_vars = "in vec2 primitive;\n"
+               "in vec2 size;\n",
     .vs_exec = ("       vec2 pos = size * vec2(gl_VertexID&1, (gl_VertexID&2)>>1);\n"
                 GLAMOR_POS(gl_Position, (primitive.xy + pos))),
 };
diff --git a/glamor/glamor_render.c b/glamor/glamor_render.c
index c9a125ef9..07bea8080 100644
--- a/glamor/glamor_render.c
+++ b/glamor/glamor_render.c
@@ -61,7 +61,7 @@ static struct blendinfo composite_op_info[] = {
 
 #define RepeatFix			10
 static GLuint
-glamor_create_composite_fs(struct shader_key *key)
+glamor_create_composite_fs(glamor_screen_private* priv, struct shader_key *key)
 {
     const char *repeat_define =
         "#define RepeatNone               	      0\n"
@@ -116,7 +116,7 @@ glamor_create_composite_fs(struct shader_key *key)
         "			tex = (fract(tex) / wh.xy);\n"
         "		}\n"
         "	}\n"
-        "	return texture2D(tex_image, tex);\n"
+        "	return texture(tex_image, tex);\n"
         "}\n"
         " vec4 rel_sampler_rgbx(sampler2D tex_image, vec2 tex, vec4 wh, int repeat)\n"
         "{\n"
@@ -129,7 +129,7 @@ glamor_create_composite_fs(struct shader_key *key)
         "			tex = (fract(tex) / wh.xy);\n"
         "		}\n"
         "	}\n"
-        "	return vec4(texture2D(tex_image, tex).rgb, 1.0);\n"
+        "	return vec4(texture(tex_image, tex).rgb, 1.0);\n"
         "}\n";
 
     const char *source_solid_fetch =
@@ -139,7 +139,7 @@ glamor_create_composite_fs(struct shader_key *key)
         "	return source;\n"
         "}\n";
     const char *source_alpha_pixmap_fetch =
-        "varying vec2 source_texture;\n"
+        "in vec2 source_texture;\n"
         "uniform sampler2D source_sampler;\n"
         "uniform vec4 source_wh;"
         "vec4 get_source()\n"
@@ -148,7 +148,7 @@ glamor_create_composite_fs(struct shader_key *key)
         "			        source_wh, source_repeat_mode);\n"
         "}\n";
     const char *source_pixmap_fetch =
-        "varying vec2 source_texture;\n"
+        "in vec2 source_texture;\n"
         "uniform sampler2D source_sampler;\n"
         "uniform vec4 source_wh;\n"
         "vec4 get_source()\n"
@@ -168,7 +168,7 @@ glamor_create_composite_fs(struct shader_key *key)
         "	return mask;\n"
         "}\n";
     const char *mask_alpha_pixmap_fetch =
-        "varying vec2 mask_texture;\n"
+        "in vec2 mask_texture;\n"
         "uniform sampler2D mask_sampler;\n"
         "uniform vec4 mask_wh;\n"
         "vec4 get_mask()\n"
@@ -177,7 +177,7 @@ glamor_create_composite_fs(struct shader_key *key)
         "			        mask_wh, mask_repeat_mode);\n"
         "}\n";
     const char *mask_pixmap_fetch =
-        "varying vec2 mask_texture;\n"
+        "in vec2 mask_texture;\n"
         "uniform sampler2D mask_sampler;\n"
         "uniform vec4 mask_wh;\n"
         "vec4 get_mask()\n"
@@ -201,17 +201,17 @@ glamor_create_composite_fs(struct shader_key *key)
     const char *in_normal =
         "void main()\n"
         "{\n"
-        "	gl_FragColor = dest_swizzle(get_source() * get_mask().a);\n"
+        "	frag_color = dest_swizzle(get_source() * get_mask().a);\n"
         "}\n";
     const char *in_ca_source =
         "void main()\n"
         "{\n"
-        "	gl_FragColor = dest_swizzle(get_source() * get_mask());\n"
+        "	frag_color = dest_swizzle(get_source() * get_mask());\n"
         "}\n";
     const char *in_ca_alpha =
         "void main()\n"
         "{\n"
-        "	gl_FragColor = dest_swizzle(get_source().a * get_mask());\n"
+        "	frag_color = dest_swizzle(get_source().a * get_mask());\n"
         "}\n";
     const char *in_ca_dual_blend =
         "out vec4 color0;\n"
@@ -221,8 +221,6 @@ glamor_create_composite_fs(struct shader_key *key)
         "	color0 = dest_swizzle(get_source() * get_mask());\n"
         "	color1 = dest_swizzle(get_source().a * get_mask());\n"
         "}\n";
-    const char *header_ca_dual_blend =
-        "#version 130\n";
     const char *in_ca_dual_blend_gles2 =
         "void main()\n"
         "{\n"
@@ -238,7 +236,8 @@ glamor_create_composite_fs(struct shader_key *key)
     const char *mask_fetch = "";
     const char *in;
     const char *header;
-    const char *header_norm = "";
+    const char *header_norm = priv->glsl_version > 120 ? "#version 130\n" : "#version 120\n" GLAMOR_COMPAT_DEFINES_FS;
+    const char *header_es = priv->glsl_version > 100 ? "#version 300 es\n" : "#version 100\n" GLAMOR_COMPAT_DEFINES_FS;
     const char *dest_swizzle;
     GLuint prog;
 
@@ -288,7 +287,7 @@ glamor_create_composite_fs(struct shader_key *key)
         FatalError("Bad composite shader dest swizzle");
     }
 
-    header = header_norm;
+    header = priv->is_gles ? header_es : header_norm;
     switch (key->in) {
     case glamor_program_alpha_normal:
         in = in_normal;
@@ -301,7 +300,6 @@ glamor_create_composite_fs(struct shader_key *key)
         break;
     case glamor_program_alpha_dual_blend:
         in = in_ca_dual_blend;
-        header = header_ca_dual_blend;
         break;
     case glamor_program_alpha_dual_blend_gles2:
         in = in_ca_dual_blend_gles2;
@@ -314,7 +312,8 @@ glamor_create_composite_fs(struct shader_key *key)
     XNFasprintf(&source,
                 "%s"
                 GLAMOR_DEFAULT_PRECISION
-                "%s%s%s%s%s%s%s", header, repeat_define, relocate_texture,
+                "%s%s%s%s%s%s%s%s", header, priv->glsl_version > 120 ? GLAMOR_CORE_VARIABLES: "",
+                repeat_define, relocate_texture,
                 rel_sampler, source_fetch, mask_fetch, dest_swizzle, in);
 
     prog = glamor_compile_glsl_prog(GL_FRAGMENT_SHADER, source);
@@ -324,14 +323,14 @@ glamor_create_composite_fs(struct shader_key *key)
 }
 
 static GLuint
-glamor_create_composite_vs(struct shader_key *key)
+glamor_create_composite_vs(glamor_screen_private* priv, struct shader_key *key)
 {
     const char *main_opening =
-        "attribute vec4 v_position;\n"
-        "attribute vec4 v_texcoord0;\n"
-        "attribute vec4 v_texcoord1;\n"
-        "varying vec2 source_texture;\n"
-        "varying vec2 mask_texture;\n"
+        "in vec4 v_position;\n"
+        "in vec4 v_texcoord0;\n"
+        "in vec4 v_texcoord1;\n"
+        "out vec2 source_texture;\n"
+        "out vec2 mask_texture;\n"
         "void main()\n"
         "{\n"
         "	gl_Position = v_position;\n";
@@ -341,7 +340,9 @@ glamor_create_composite_vs(struct shader_key *key)
     const char *source_coords_setup = "";
     const char *mask_coords_setup = "";
     const char *version_gles2 = "#version 100\n";
-    const char *version = "";
+    const char *version_gles3 = "#version 300 es\n";
+    const char *version = priv->glsl_version > 120 ? "#version 130\n" : "#version 120\n";
+    const char *defines = priv->glsl_version > 120 ? "": GLAMOR_COMPAT_DEFINES_VS;
     char *source;
     GLuint prog;
 
@@ -351,14 +352,17 @@ glamor_create_composite_vs(struct shader_key *key)
     if (key->mask != SHADER_MASK_NONE && key->mask != SHADER_MASK_SOLID)
         mask_coords_setup = mask_coords;
 
-    if (key->in == glamor_program_alpha_dual_blend_gles2)
+    if (key->in == glamor_program_alpha_dual_blend_gles2 || priv->is_gles)
         version = version_gles2;
 
+    if (priv->is_gles && priv->glsl_version > 120)
+        version = version_gles3;
+
     XNFasprintf(&source,
                 "%s"
                 GLAMOR_DEFAULT_PRECISION
-                "%s%s%s%s",
-                version, main_opening, source_coords_setup,
+                "%s%s%s%s%s",
+                version, defines, main_opening, source_coords_setup,
                 mask_coords_setup, main_closing);
 
     prog = glamor_compile_glsl_prog(GL_VERTEX_SHADER, source);
@@ -376,10 +380,10 @@ glamor_create_composite_shader(ScreenPtr screen, struct shader_key *key,
     glamor_screen_private *glamor_priv = glamor_get_screen_private(screen);
 
     glamor_make_current(glamor_priv);
-    vs = glamor_create_composite_vs(key);
+    vs = glamor_create_composite_vs(glamor_priv, key);
     if (vs == 0)
         return;
-    fs = glamor_create_composite_fs(key);
+    fs = glamor_create_composite_fs(glamor_priv, key);
     if (fs == 0)
         return;
 
diff --git a/glamor/glamor_segs.c b/glamor/glamor_segs.c
index 4dfa6553b..1fe6aabdd 100644
--- a/glamor/glamor_segs.c
+++ b/glamor/glamor_segs.c
@@ -27,7 +27,7 @@
 
 static const glamor_facet glamor_facet_poly_segment = {
     .name = "poly_segment",
-    .vs_vars = "attribute vec2 primitive;\n",
+    .vs_vars = "in vec2 primitive;\n",
     .vs_exec = ("       vec2 pos = vec2(0.0,0.0);\n"
                 GLAMOR_POS(gl_Position, primitive.xy)),
 };
diff --git a/glamor/glamor_spans.c b/glamor/glamor_spans.c
index 00a019c7b..e3d92e50e 100644
--- a/glamor/glamor_spans.c
+++ b/glamor/glamor_spans.c
@@ -29,7 +29,7 @@ glamor_program  fill_spans_progs[4];
 static const glamor_facet glamor_facet_fillspans_130 = {
     .name = "fill_spans",
     .version = 130,
-    .vs_vars =  "attribute vec3 primitive;\n",
+    .vs_vars =  "in vec3 primitive;\n",
     .vs_exec = ("       vec2 pos = vec2(primitive.z,1) * vec2(gl_VertexID&1, (gl_VertexID&2)>>1);\n"
                 GLAMOR_POS(gl_Position, (primitive.xy + pos))),
 };
diff --git a/glamor/glamor_text.c b/glamor/glamor_text.c
index cf165cad8..0c89058e8 100644
--- a/glamor/glamor_text.c
+++ b/glamor/glamor_text.c
@@ -221,9 +221,9 @@ glamor_text(DrawablePtr drawable, GCPtr gc,
 }
 
 static const char vs_vars_text[] =
-    "attribute vec4 primitive;\n"
-    "attribute vec2 source;\n"
-    "varying vec2 glyph_pos;\n";
+    "in vec4 primitive;\n"
+    "in vec2 source;\n"
+    "out vec2 glyph_pos;\n";
 
 static const char vs_exec_text[] =
     "       vec2 pos = primitive.zw * vec2(gl_VertexID&1, (gl_VertexID&2)>>1);\n"
@@ -231,7 +231,7 @@ static const char vs_exec_text[] =
     "       glyph_pos = source + pos;\n";
 
 static const char fs_vars_text[] =
-    "varying vec2 glyph_pos;\n";
+    "in vec2 glyph_pos;\n";
 
 static const char fs_exec_text[] =
     "       ivec2 itile_texture = ivec2(glyph_pos);\n"
@@ -249,9 +249,9 @@ static const char fs_exec_te[] =
     "       uint texel = texelFetch(font, itile_texture, 0).x;\n"
     "       uint bit = (texel >> x) & uint(1);\n"
     "       if (bit == uint(0))\n"
-    "               gl_FragColor = bg;\n"
+    "               frag_color = bg;\n"
     "       else\n"
-    "               gl_FragColor = fg;\n";
+    "               frag_color = fg;\n";
 
 static const glamor_facet glamor_facet_poly_text = {
     .name = "poly_text",
@@ -353,7 +353,7 @@ use_image_solid(PixmapPtr pixmap, GCPtr gc, glamor_program *prog, void *arg)
 
 static const glamor_facet glamor_facet_image_fill = {
     .name = "solid",
-    .fs_exec = "       gl_FragColor = fg;\n",
+    .fs_exec = "       frag_color = fg;\n",
     .locations = glamor_program_location_fg,
     .use = use_image_solid,
 };
diff --git a/glamor/glamor_xv.c b/glamor/glamor_xv.c
index dbb490599..809cd358f 100644
--- a/glamor/glamor_xv.c
+++ b/glamor/glamor_xv.c
@@ -65,9 +65,9 @@ static const glamor_facet glamor_facet_xv_planar_2 = {
     .version = 120,
 
     .source_name = "v_texcoord0",
-    .vs_vars = ("attribute vec2 position;\n"
-                "attribute vec2 v_texcoord0;\n"
-                "varying vec2 tcs;\n"),
+    .vs_vars = ("in vec2 position;\n"
+                "in vec2 v_texcoord0;\n"
+                "out vec2 tcs;\n"),
     .vs_exec = (GLAMOR_POS(gl_Position, position)
                 "        tcs = v_texcoord0;\n"),
 
@@ -76,7 +76,7 @@ static const glamor_facet glamor_facet_xv_planar_2 = {
                 "uniform vec4 offsetyco;\n"
                 "uniform vec4 ucogamma;\n"
                 "uniform vec4 vco;\n"
-                "varying vec2 tcs;\n"),
+                "in vec2 tcs;\n"),
     .fs_exec = (
                 "        float sample;\n"
                 "        vec2 sample_uv;\n"
@@ -87,7 +87,7 @@ static const glamor_facet glamor_facet_xv_planar_2 = {
                 "        temp1.xyz = ucogamma.xyz * vec3(sample_uv.x) + temp1.xyz;\n"
                 "        temp1.xyz = clamp(vco.xyz * vec3(sample_uv.y) + temp1.xyz, 0.0, 1.0);\n"
                 "        temp1.w = 1.0;\n"
-                "        gl_FragColor = temp1;\n"
+                "        frag_color = temp1;\n"
                 ),
 };
 
@@ -97,9 +97,9 @@ static const glamor_facet glamor_facet_xv_planar_3 = {
     .version = 120,
 
     .source_name = "v_texcoord0",
-    .vs_vars = ("attribute vec2 position;\n"
-                "attribute vec2 v_texcoord0;\n"
-                "varying vec2 tcs;\n"),
+    .vs_vars = ("in vec2 position;\n"
+                "in vec2 v_texcoord0;\n"
+                "out vec2 tcs;\n"),
     .vs_exec = (GLAMOR_POS(gl_Position, position)
                 "        tcs = v_texcoord0;\n"),
 
@@ -109,7 +109,7 @@ static const glamor_facet glamor_facet_xv_planar_3 = {
                 "uniform vec4 offsetyco;\n"
                 "uniform vec4 ucogamma;\n"
                 "uniform vec4 vco;\n"
-                "varying vec2 tcs;\n"),
+                "in vec2 tcs;\n"),
     .fs_exec = (
                 "        float sample;\n"
                 "        vec4 temp1;\n"
@@ -120,7 +120,7 @@ static const glamor_facet glamor_facet_xv_planar_3 = {
                 "        sample = texture2D(v_sampler, tcs).w;\n"
                 "        temp1.xyz = clamp(vco.xyz * vec3(sample) + temp1.xyz, 0.0, 1.0);\n"
                 "        temp1.w = 1.0;\n"
-                "        gl_FragColor = temp1;\n"
+                "        frag_color = temp1;\n"
                 ),
 };
 
-- 
GitLab

