From 83dfb7ae15534543027e281944f3a07c4aa7e8fd Mon Sep 17 00:00:00 2001
From: Erik Kurzinger <ekurzinger@nvidia.com>
Date: Tue, 16 Aug 2022 11:57:40 -0700
Subject: [PATCH 1/4] DRI3: add DRI3ImportSyncobj and DRI3FreeSyncobj

Adds the required infrastructure in the core DRI3 code to support
importing DRM synchronization objects from clients. This includes
support for the two new protocol requests from DRI3 version 1.4, an
internal representation of these objects in the form of the dri3_syncobj
structure, and an import_syncobj screen info callback.

The following operations are defined for dri3_syncobj objects
* free - release any server-side resources associated with the object
* check - poll a timeline point and return whether it is signaled
* export_fence - return a sync fd corresponding to a timeline point
* import_fence - submit a sync fd as the fence for a timeline point
* signal - immediately signal a timeline point
* eventfd - register an eventfd to be signaled when the given timeline
  point is either submitted or signaled, depending on wait_avail

Implementations will be responsible for populating these function
pointers when importing a syncobj.

Signed-off-by: Erik Kurzinger <ekurzinger@nvidia.com>
---
 dri3/dri3.c                 | 15 ++++++++
 dri3/dri3.h                 | 34 +++++++++++++++++
 dri3/dri3_priv.h            |  3 ++
 dri3/dri3_request.c         | 74 +++++++++++++++++++++++++++++++++++++
 dri3/dri3_screen.c          | 20 ++++++++++
 include/protocol-versions.h |  2 +-
 6 files changed, 147 insertions(+), 1 deletion(-)

diff --git a/dri3/dri3.c b/dri3/dri3.c
index 1912529695..f9c5172774 100644
--- a/dri3/dri3.c
+++ b/dri3/dri3.c
@@ -63,6 +63,16 @@ dri3_screen_init(ScreenPtr screen, const dri3_screen_info_rec *info)
     return TRUE;
 }
 
+RESTYPE dri3_syncobj_type;
+
+static int dri3_syncobj_free(void *data, XID id)
+{
+    struct dri3_syncobj *syncobj = data;
+    if (--syncobj->refcount == 0)
+        syncobj->free(syncobj);
+    return 0;
+}
+
 void
 dri3_extension_init(void)
 {
@@ -92,6 +102,11 @@ dri3_extension_init(void)
         if (!dri3_screen_init(screenInfo.screens[i], NULL))
             goto bail;
     }
+
+    dri3_syncobj_type = CreateNewResourceType(dri3_syncobj_free, "DRI3Syncobj");
+    if (!dri3_syncobj_type)
+        goto bail;
+
     return;
 
 bail:
diff --git a/dri3/dri3.h b/dri3/dri3.h
index 02d3b03eec..456e7a38d9 100644
--- a/dri3/dri3.h
+++ b/dri3/dri3.h
@@ -30,6 +30,32 @@
 
 #define DRI3_SCREEN_INFO_VERSION        2
 
+extern RESTYPE dri3_syncobj_type;
+
+struct dri3_syncobj
+{
+    XID id;
+    ScreenPtr screen;
+    uint32_t refcount;
+
+    void (*free)(struct dri3_syncobj *syncobj);
+    Bool (*check)(struct dri3_syncobj *syncobj, uint64_t point);
+    int (*export_fence)(struct dri3_syncobj *syncobj, uint64_t point);
+    void (*import_fence)(struct dri3_syncobj *syncobj, uint64_t point, int fd);
+    void (*signal)(struct dri3_syncobj *syncobj, uint64_t point);
+    void (*eventfd)(struct dri3_syncobj *syncobj, uint64_t point, int efd, Bool wait_avail);
+};
+
+#define VERIFY_DRI3_SYNCOBJ(id, ptr, a)\
+    do {\
+        int rc = dixLookupResourceByType((void **)&(ptr), id,\
+                                         dri3_syncobj_type, client, a);\
+        if (rc != Success) {\
+            client->errorValue = id;\
+            return rc;\
+        }\
+    } while (0);
+
 typedef int (*dri3_open_proc)(ScreenPtr screen,
                               RRProviderPtr provider,
                               int *fd);
@@ -84,6 +110,11 @@ typedef int (*dri3_get_drawable_modifiers_proc) (DrawablePtr draw,
                                                  uint32_t *num_modifiers,
                                                  uint64_t **modifiers);
 
+typedef struct dri3_syncobj *(*dri3_import_syncobj_proc) (ClientPtr client,
+                                                          ScreenPtr screen,
+                                                          XID id,
+                                                          int fd);
+
 typedef struct dri3_screen_info {
     uint32_t                    version;
 
@@ -101,6 +132,9 @@ typedef struct dri3_screen_info {
     dri3_get_modifiers_proc     get_modifiers;
     dri3_get_drawable_modifiers_proc get_drawable_modifiers;
 
+    /* Version 4 */
+    dri3_import_syncobj_proc    import_syncobj;
+
 } dri3_screen_info_rec, *dri3_screen_info_ptr;
 
 extern _X_EXPORT Bool
diff --git a/dri3/dri3_priv.h b/dri3/dri3_priv.h
index f319d17702..71d2da9571 100644
--- a/dri3/dri3_priv.h
+++ b/dri3/dri3_priv.h
@@ -102,4 +102,7 @@ dri3_get_supported_modifiers(ScreenPtr screen, DrawablePtr drawable,
                              CARD32 *num_screen_modifiers,
                              CARD64 **screen_modifiers);
 
+int
+dri3_import_syncobj(ClientPtr client, ScreenPtr screen, XID id, int fd);
+
 #endif /* _DRI3PRIV_H_ */
diff --git a/dri3/dri3_request.c b/dri3/dri3_request.c
index 6871689308..e7218b8b9c 100644
--- a/dri3/dri3_request.c
+++ b/dri3/dri3_request.c
@@ -554,6 +554,51 @@ proc_dri3_buffers_from_pixmap(ClientPtr client)
     return Success;
 }
 
+static int
+proc_dri3_import_syncobj(ClientPtr client)
+{
+    REQUEST(xDRI3ImportSyncobjReq);
+    DrawablePtr drawable;
+    ScreenPtr screen;
+    int fd;
+    int status;
+
+    SetReqFds(client, 1);
+    REQUEST_SIZE_MATCH(xDRI3ImportSyncobjReq);
+    LEGAL_NEW_RESOURCE(stuff->syncobj, client);
+
+    status = dixLookupDrawable(&drawable, stuff->drawable, client,
+                               M_ANY, DixGetAttrAccess);
+    if (status != Success)
+        return status;
+
+    screen = drawable->pScreen;
+
+    fd = ReadFdFromClient(client);
+    if (fd < 0)
+        return BadValue;
+
+    return dri3_import_syncobj(client, screen, stuff->syncobj, fd);
+}
+
+static int
+proc_dri3_free_syncobj(ClientPtr client)
+{
+    REQUEST(xDRI3FreeSyncobjReq);
+    struct dri3_syncobj *syncobj;
+    int status;
+
+    REQUEST_SIZE_MATCH(xDRI3FreeSyncobjReq);
+
+    status = dixLookupResourceByType((void **) &syncobj, stuff->syncobj,
+                                     dri3_syncobj_type, client, DixWriteAccess);
+    if (status != Success)
+        return status;
+
+    FreeResource(stuff->syncobj, dri3_syncobj_type);
+    return Success;
+}
+
 int (*proc_dri3_vector[DRI3NumberRequests]) (ClientPtr) = {
     proc_dri3_query_version,            /* 0 */
     proc_dri3_open,                     /* 1 */
@@ -564,6 +609,9 @@ int (*proc_dri3_vector[DRI3NumberRequests]) (ClientPtr) = {
     proc_dri3_get_supported_modifiers,  /* 6 */
     proc_dri3_pixmap_from_buffers,      /* 7 */
     proc_dri3_buffers_from_pixmap,      /* 8 */
+    NULL,                               /* 9 */
+    proc_dri3_import_syncobj,           /* 10 */
+    proc_dri3_free_syncobj,             /* 11 */
 };
 
 int
@@ -697,6 +745,29 @@ sproc_dri3_buffers_from_pixmap(ClientPtr client)
     return (*proc_dri3_vector[stuff->dri3ReqType]) (client);
 }
 
+static int _X_COLD
+sproc_dri3_import_syncobj(ClientPtr client)
+{
+    REQUEST(xDRI3ImportSyncobjReq);
+    REQUEST_SIZE_MATCH(xDRI3ImportSyncobjReq);
+
+    swaps(&stuff->length);
+    swapl(&stuff->syncobj);
+    swapl(&stuff->drawable);
+    return (*proc_dri3_vector[stuff->dri3ReqType]) (client);
+}
+
+static int _X_COLD
+sproc_dri3_free_syncobj(ClientPtr client)
+{
+    REQUEST(xDRI3FreeSyncobjReq);
+    REQUEST_SIZE_MATCH(xDRI3FreeSyncobjReq);
+
+    swaps(&stuff->length);
+    swapl(&stuff->syncobj);
+    return (*proc_dri3_vector[stuff->dri3ReqType]) (client);
+}
+
 int (*sproc_dri3_vector[DRI3NumberRequests]) (ClientPtr) = {
     sproc_dri3_query_version,           /* 0 */
     sproc_dri3_open,                    /* 1 */
@@ -707,6 +778,9 @@ int (*sproc_dri3_vector[DRI3NumberRequests]) (ClientPtr) = {
     sproc_dri3_get_supported_modifiers, /* 6 */
     sproc_dri3_pixmap_from_buffers,     /* 7 */
     sproc_dri3_buffers_from_pixmap,     /* 8 */
+    NULL,                               /* 9 */
+    sproc_dri3_import_syncobj,          /* 10 */
+    sproc_dri3_free_syncobj,            /* 11 */
 };
 
 int _X_COLD
diff --git a/dri3/dri3_screen.c b/dri3/dri3_screen.c
index bc96e5339c..866525991a 100644
--- a/dri3/dri3_screen.c
+++ b/dri3/dri3_screen.c
@@ -272,3 +272,23 @@ dri3_get_supported_modifiers(ScreenPtr screen, DrawablePtr drawable,
 
     return Success;
 }
+
+int dri3_import_syncobj(ClientPtr client, ScreenPtr screen, XID id, int fd)
+{
+    const dri3_screen_info_rec *info = dri3_screen_priv(screen)->info;
+    struct dri3_syncobj *syncobj = NULL;
+
+    if (!info->import_syncobj)
+        return BadImplementation;
+
+    syncobj = info->import_syncobj(client, screen, id, fd);
+    close(fd);
+
+    if (!syncobj)
+        return BadAlloc;
+
+    if (!AddResource(id, dri3_syncobj_type, syncobj))
+        return BadAlloc;
+
+    return Success;
+}
diff --git a/include/protocol-versions.h b/include/protocol-versions.h
index d7bfc6dca2..ffd7d0e239 100644
--- a/include/protocol-versions.h
+++ b/include/protocol-versions.h
@@ -48,7 +48,7 @@
 
 /* DRI3 */
 #define SERVER_DRI3_MAJOR_VERSION               1
-#define SERVER_DRI3_MINOR_VERSION               2
+#define SERVER_DRI3_MINOR_VERSION               4
 
 /* DMX */
 #define SERVER_DMX_MAJOR_VERSION		2
-- 
GitLab


From 02425ea237dc3e99ee7b84f37d25d28759c83e78 Mon Sep 17 00:00:00 2001
From: Erik Kurzinger <ekurzinger@nvidia.com>
Date: Tue, 16 Aug 2022 11:59:14 -0700
Subject: [PATCH 2/4] xwayland: implement support for DRI3 syncobjs

Adds an implementation of the import_syncobj DRI3 screen info callback
for Xwayland along with the various operations defined for dri3_syncobj
objects.

Signed-off-by: Erik Kurzinger <ekurzinger@nvidia.com>
---
 hw/xwayland/xwayland-glamor-gbm.c | 141 ++++++++++++++++++++++++++++++
 1 file changed, 141 insertions(+)

diff --git a/hw/xwayland/xwayland-glamor-gbm.c b/hw/xwayland/xwayland-glamor-gbm.c
index b177b77e08..66e448b759 100644
--- a/hw/xwayland/xwayland-glamor-gbm.c
+++ b/hw/xwayland/xwayland-glamor-gbm.c
@@ -811,6 +811,146 @@ glamor_egl_fd_from_pixmap(ScreenPtr screen, PixmapPtr pixmap,
     return -1;
 }
 
+struct xwl_dri3_syncobj
+{
+    struct dri3_syncobj base;
+    uint32_t handle;
+};
+
+static Bool xwl_dri3_check_syncobj(struct dri3_syncobj *syncobj,
+                                   uint64_t point)
+{
+    struct xwl_dri3_syncobj *xwl_syncobj = (struct xwl_dri3_syncobj *)syncobj;
+    struct xwl_screen *xwl_screen = xwl_screen_get(syncobj->screen);
+    struct xwl_gbm_private *xwl_gbm = xwl_gbm_get(xwl_screen);
+
+    return !drmSyncobjTimelineWait(xwl_gbm->drm_fd,
+                                   &xwl_syncobj->handle, &point, 1,
+                                   0 /* timeout */,
+                                   DRM_SYNCOBJ_WAIT_FLAGS_WAIT_FOR_SUBMIT,
+                                   NULL /* first_signaled */);
+}
+
+static int xwl_dri3_syncobj_export_fence(struct dri3_syncobj *syncobj,
+                                         uint64_t point)
+{
+    struct xwl_dri3_syncobj *xwl_syncobj = (struct xwl_dri3_syncobj *)syncobj;
+    struct xwl_screen *xwl_screen = xwl_screen_get(syncobj->screen);
+    struct xwl_gbm_private *xwl_gbm = xwl_gbm_get(xwl_screen);
+    int fd = -1;
+
+    drmSyncobjExportSyncFileTimeline(xwl_gbm->drm_fd,
+                                     xwl_syncobj->handle,
+                                     point, &fd);
+    return fd;
+}
+
+static void xwl_dri3_syncobj_import_fence(struct dri3_syncobj *syncobj,
+                                          uint64_t point, int fd)
+{
+    struct xwl_dri3_syncobj *xwl_syncobj = (struct xwl_dri3_syncobj *)syncobj;
+    struct xwl_screen *xwl_screen = xwl_screen_get(syncobj->screen);
+    struct xwl_gbm_private *xwl_gbm = xwl_gbm_get(xwl_screen);
+
+    drmSyncobjImportSyncFileTimeline(xwl_gbm->drm_fd,
+                                     xwl_syncobj->handle,
+                                     point, fd);
+    close(fd);
+}
+
+static void xwl_dri3_signal_syncobj(struct dri3_syncobj *syncobj,
+                                    uint64_t point)
+{
+    struct xwl_dri3_syncobj *xwl_syncobj = (struct xwl_dri3_syncobj *)syncobj;
+    struct xwl_screen *xwl_screen = xwl_screen_get(syncobj->screen);
+    struct xwl_gbm_private *xwl_gbm = xwl_gbm_get(xwl_screen);
+
+    drmSyncobjTimelineSignal(xwl_gbm->drm_fd, &xwl_syncobj->handle, &point, 1);
+}
+
+static void xwl_dri3_free_syncobj(struct dri3_syncobj *syncobj)
+{
+    struct xwl_dri3_syncobj *xwl_syncobj = (struct xwl_dri3_syncobj *)syncobj;
+    struct xwl_screen *xwl_screen = xwl_screen_get(syncobj->screen);
+    struct xwl_gbm_private *xwl_gbm = xwl_gbm_get(xwl_screen);
+
+    if (xwl_syncobj->handle)
+        drmSyncobjDestroy(xwl_gbm->drm_fd, xwl_syncobj->handle);
+
+    free(xwl_syncobj);
+}
+
+static void xwl_dri3_syncobj_eventfd(struct dri3_syncobj *syncobj, uint64_t point,
+                                     int efd, Bool wait_avail)
+{
+    struct xwl_dri3_syncobj *xwl_syncobj = (struct xwl_dri3_syncobj *)syncobj;
+    struct xwl_screen *xwl_screen = xwl_screen_get(syncobj->screen);
+    struct xwl_gbm_private *xwl_gbm = xwl_gbm_get(xwl_screen);
+
+    drmSyncobjEventfd(xwl_gbm->drm_fd, xwl_syncobj->handle, point, efd,
+                      wait_avail ? DRM_SYNCOBJ_WAIT_FLAGS_WAIT_AVAILABLE : 0);
+}
+
+static struct dri3_syncobj *xwl_dri3_create_syncobj(struct xwl_screen *xwl_screen,
+                                                    uint32_t handle)
+{
+    struct xwl_dri3_syncobj *syncobj = calloc(1, sizeof (*syncobj));
+    struct xwl_gbm_private *xwl_gbm = xwl_gbm_get(xwl_screen);
+    int syncobj_fd = -1;
+
+    if (!syncobj)
+        return NULL;
+
+    if (drmSyncobjHandleToFD(xwl_gbm->drm_fd, handle, &syncobj_fd))
+        goto fail;
+
+    syncobj->timeline =
+        wp_linux_explicit_sync_v2_import_timeline(xwl_screen->explicit_sync,
+                                                  syncobj_fd);
+    close(syncobj_fd);
+    if (!syncobj->timeline)
+        goto fail;
+
+    syncobj->handle = handle;
+    syncobj->base.screen = xwl_screen->screen;
+    syncobj->base.refcount = 1;
+
+    syncobj->base.free = xwl_dri3_free_syncobj;
+    syncobj->base.check = xwl_dri3_check_syncobj;
+    syncobj->base.export_fence = xwl_dri3_syncobj_export_fence;
+    syncobj->base.import_fence = xwl_dri3_syncobj_import_fence;
+    syncobj->base.signal = xwl_dri3_signal_syncobj;
+    syncobj->base.eventfd = xwl_dri3_syncobj_eventfd;
+    return &syncobj->base;
+
+fail:
+    free(syncobj);
+    return NULL;
+}
+
+static struct dri3_syncobj *xwl_dri3_import_syncobj(ClientPtr client,
+                                                    ScreenPtr screen,
+                                                    XID id, int fd)
+{
+    struct xwl_screen *xwl_screen = xwl_screen_get(screen);
+    struct xwl_gbm_private *xwl_gbm = xwl_gbm_get(xwl_screen);
+    struct xwl_dri3_syncobj *syncobj = NULL;
+    uint32_t handle;
+
+    if (drmSyncobjFDToHandle(xwl_gbm->drm_fd, fd, &handle))
+        return NULL;
+
+    syncobj = (struct xwl_dri3_syncobj *)xwl_dri3_create_syncobj(xwl_screen, handle);
+    if (!syncobj) {
+        drmSyncobjDestroy(xwl_gbm->drm_fd, handle);
+        return NULL;
+    }
+
+    syncobj->base.id = id;
+
+    return &syncobj->base;
+}
+
 static const dri3_screen_info_rec xwl_dri3_info = {
     .version = 2,
     .open = NULL,
@@ -820,6 +960,7 @@ static const dri3_screen_info_rec xwl_dri3_info = {
     .get_formats = xwl_glamor_get_formats,
     .get_modifiers = xwl_glamor_get_modifiers,
     .get_drawable_modifiers = xwl_glamor_get_drawable_modifiers,
+    .import_syncobj = xwl_dri3_import_syncobj,
 };
 
 static const char *
-- 
GitLab


From 7117fd5d47701665f2e77f13afdc3964a4eab4cf Mon Sep 17 00:00:00 2001
From: Erik Kurzinger <ekurzinger@nvidia.com>
Date: Tue, 16 Aug 2022 12:03:59 -0700
Subject: [PATCH 3/4] Present: implement PresentPixmapSynced

Adds support for an augmented version of PresentPixmap supporting
explicit synchronization with the GPU by way of a DRM synchronization
object. The new request will accept a previously imported timeline
syncobj along with acquire and release points on that timeline.

If the backend reports support for PresentCapabilitySyncobj, the
syncobj, acquire, and release points will be attached to the vblank
structure for the present request, taking an extra reference to the
syncobj to ensure it is not freed before the request has completed.

Initially, only the Xwayland backend will advertise
PresentCapabilitySyncobj, provided that the EGL driver supports the
ANDROID_native_fence_sync extension.

Before executing a present request, if the given vblank has an attached
syncobj, we will first poll the acquire point. If it has not yet been
signaled, we will export the fence as a sync fd and add that to the
server's event loop. When the fence eventually is signaled, the request
will be re-executed.

After executing a request, the release point must be signaled after any
GPU operations on the pixmap have completed. For flips, this can be done
as soon as the buffer has been released by the Wayland compositor (in
the case of Xwayland). For copies, we must insert a fence release into
the GPU command stream after the copy and transfer it to the syncobj.
This requires a new flush_fenced callback, which must be implemented by
any backends advertising PresentCapabilitySyncobj. This will perform the
same function as the current flush callback, but also return a sync fd
corresponding to the aforementioned fence.

Signed-off-by: Erik Kurzinger <ekurzinger@nvidia.com>
---
 hw/xwayland/xwayland-glamor.c  |  24 +++++++
 hw/xwayland/xwayland-glamor.h  |   1 +
 hw/xwayland/xwayland-present.c |  38 +++++++++-
 hw/xwayland/xwayland-screen.h  |   2 +
 include/protocol-versions.h    |   2 +-
 present/present.c              |   7 ++
 present/present_execute.c      |  32 ++++++++-
 present/present_priv.h         |  20 ++++++
 present/present_request.c      | 123 ++++++++++++++++++++++++++++++++-
 present/present_scmd.c         |   6 ++
 present/present_screen.c       |   1 +
 present/present_vblank.c       |  23 ++++++
 12 files changed, 274 insertions(+), 5 deletions(-)

diff --git a/hw/xwayland/xwayland-glamor.c b/hw/xwayland/xwayland-glamor.c
index c6aa8eb172..f9a4ef0b49 100644
--- a/hw/xwayland/xwayland-glamor.c
+++ b/hw/xwayland/xwayland-glamor.c
@@ -1074,6 +1074,30 @@ xwl_glamor_create_pixmap_for_window(struct xwl_window *xwl_window)
         return NullPixmap;
 }
 
+int
+xwl_glamor_get_fence(struct xwl_screen *xwl_screen)
+{
+    EGLint attribs[3];
+    EGLSyncKHR sync;
+    int fence_fd = -1;
+
+    if (!xwl_screen->glamor)
+        return -1;
+
+    xwl_glamor_egl_make_current(xwl_screen);
+
+    attribs[0] = EGL_SYNC_NATIVE_FENCE_FD_ANDROID;
+    attribs[1] = EGL_NO_NATIVE_FENCE_FD_ANDROID;
+    attribs[2] = EGL_NONE;
+    sync = eglCreateSyncKHR(xwl_screen->egl_display, EGL_SYNC_NATIVE_FENCE_ANDROID, attribs);
+    if (sync != EGL_NO_SYNC_KHR) {
+        fence_fd = eglDupNativeFenceFDANDROID(xwl_screen->egl_display, sync);
+        eglDestroySyncKHR(xwl_screen->egl_display, sync);
+    }
+
+    return fence_fd;
+}
+
 void
 xwl_glamor_init_backends(struct xwl_screen *xwl_screen, Bool use_eglstream)
 {
diff --git a/hw/xwayland/xwayland-glamor.h b/hw/xwayland/xwayland-glamor.h
index 183fe755ae..6f46043642 100644
--- a/hw/xwayland/xwayland-glamor.h
+++ b/hw/xwayland/xwayland-glamor.h
@@ -151,6 +151,7 @@ Bool xwl_glamor_get_drawable_modifiers(DrawablePtr drawable, uint32_t format,
                                        uint32_t *num_modifiers, uint64_t **modifiers);
 Bool xwl_glamor_check_flip(WindowPtr present_window, PixmapPtr pixmap);
 PixmapPtr xwl_glamor_create_pixmap_for_window (struct xwl_window *xwl_window);
+int xwl_glamor_get_fence(struct xwl_screen *screen);
 
 #ifdef XV
 /* glamor Xv Adaptor */
diff --git a/hw/xwayland/xwayland-present.c b/hw/xwayland/xwayland-present.c
index 5ede33e4cf..6143491804 100644
--- a/hw/xwayland/xwayland-present.c
+++ b/hw/xwayland/xwayland-present.c
@@ -27,6 +27,7 @@
 
 #include <windowstr.h>
 #include <present.h>
+#include <sys/eventfd.h>
 
 #include "xwayland-present.h"
 #include "xwayland-screen.h"
@@ -214,7 +215,8 @@ xwl_present_execute(present_vblank_ptr vblank, uint64_t ust, uint64_t crtc_msc);
 static uint32_t
 xwl_present_query_capabilities(present_screen_priv_ptr screen_priv)
 {
-    return XWL_PRESENT_CAPS;
+    struct xwl_screen *xwl_screen = xwl_screen_get(screen_priv->pScreen);
+    return xwl_screen->present_capabilities;
 }
 
 static int
@@ -281,6 +283,9 @@ xwl_present_free_event(struct xwl_present_event *event)
 static void
 xwl_present_free_idle_vblank(present_vblank_ptr vblank)
 {
+    if (vblank->syncobj)
+        vblank->syncobj->signal(vblank->syncobj, vblank->release_point);
+
     present_pixmap_idle(vblank->pixmap, vblank->window, vblank->serial, vblank->idle_fence);
     xwl_present_free_event(xwl_present_event_from_vblank(vblank));
 }
@@ -440,6 +445,10 @@ xwl_present_buffer_release(void *data)
         return;
 
     vblank = &event->vblank;
+
+    if (vblank->syncobj)
+        vblank->syncobj->signal(vblank->syncobj, vblank->release_point);
+
     present_pixmap_idle(vblank->pixmap, vblank->window, vblank->serial, vblank->idle_fence);
 
     xwl_present_window = xwl_present_window_priv(vblank->window);
@@ -630,6 +639,15 @@ xwl_present_maybe_set_reason(struct xwl_window *xwl_window, PresentFlipReason *r
     }
 }
 
+static int
+xwl_present_flush_fenced(WindowPtr window)
+{
+    struct xwl_window *xwl_window = xwl_window_from_window(window);
+    int fence = xwl_glamor_get_fence(xwl_window->xwl_screen);
+    xwl_present_flush(window);
+    return fence;
+}
+
 static Bool
 xwl_present_check_flip(RRCrtcPtr crtc,
                        WindowPtr present_window,
@@ -934,6 +952,9 @@ xwl_present_pixmap(WindowPtr window,
                    RRCrtcPtr target_crtc,
                    SyncFence *wait_fence,
                    SyncFence *idle_fence,
+                   struct dri3_syncobj *syncobj,
+                   uint64_t acquire_point,
+                   uint64_t release_point,
                    uint32_t options,
                    uint64_t target_window_msc,
                    uint64_t divisor,
@@ -950,6 +971,7 @@ xwl_present_pixmap(WindowPtr window,
     ScreenPtr                   screen = window->drawable.pScreen;
     present_window_priv_ptr     window_priv = present_get_window_priv(window, TRUE);
     present_screen_priv_ptr     screen_priv = present_screen_priv(screen);
+    struct xwl_screen          *xwl_screen = xwl_screen_get(screen_priv->pScreen);
     struct xwl_present_event *event;
 
     if (!window_priv)
@@ -989,6 +1011,9 @@ xwl_present_pixmap(WindowPtr window,
             if (vblank->target_msc != target_msc)
                 continue;
 
+            if (vblank->syncobj)
+                vblank->syncobj->signal(vblank->syncobj, vblank->release_point);
+
             present_vblank_scrap(vblank);
             if (vblank->flip_ready)
                 xwl_present_re_execute(vblank);
@@ -1001,7 +1026,9 @@ xwl_present_pixmap(WindowPtr window,
 
     vblank = &event->vblank;
     if (!present_vblank_init(vblank, window, pixmap, serial, valid, update, x_off, y_off,
-                             target_crtc, wait_fence, idle_fence, options, XWL_PRESENT_CAPS,
+                             target_crtc, wait_fence, idle_fence,
+                             syncobj, acquire_point, release_point,
+                             options, xwl_screen->present_capabilities,
                              notifies, num_notifies, target_msc, crtc_msc)) {
         present_vblank_destroy(vblank);
         return BadAlloc;
@@ -1065,6 +1092,12 @@ xwl_present_init(ScreenPtr screen)
     if (!dixRegisterPrivateKey(&xwl_present_window_private_key, PRIVATE_WINDOW, 0))
         return FALSE;
 
+    xwl_screen->present_capabilities = XWL_PRESENT_CAPS;
+    if (epoxy_has_egl_extension(xwl_screen->egl_display,
+                                "ANDROID_native_fence_sync"))
+        xwl_screen->present_capabilities |=
+            PresentCapabilitySyncobj;
+
     screen_priv->query_capabilities = xwl_present_query_capabilities;
     screen_priv->get_crtc = xwl_present_get_crtc;
 
@@ -1075,6 +1108,7 @@ xwl_present_init(ScreenPtr screen)
     screen_priv->present_pixmap = xwl_present_pixmap;
     screen_priv->queue_vblank = xwl_present_queue_vblank;
     screen_priv->flush = xwl_present_flush;
+    screen_priv->flush_fenced = xwl_present_flush_fenced;
     screen_priv->re_execute = xwl_present_re_execute;
 
     screen_priv->abort_vblank = xwl_present_abort_vblank;
diff --git a/hw/xwayland/xwayland-screen.h b/hw/xwayland/xwayland-screen.h
index 94033aabf9..97af13baeb 100644
--- a/hw/xwayland/xwayland-screen.h
+++ b/hw/xwayland/xwayland-screen.h
@@ -144,6 +144,8 @@ struct xwl_screen {
     int libdecor_fd;
     struct libdecor *libdecor_context;
 #endif
+
+    uint32_t present_capabilities;
 };
 
 /* Apps which use randr/vidmode to change the mode when going fullscreen,
diff --git a/include/protocol-versions.h b/include/protocol-versions.h
index ffd7d0e239..e28e2384d8 100644
--- a/include/protocol-versions.h
+++ b/include/protocol-versions.h
@@ -69,7 +69,7 @@
 
 /* Present */
 #define SERVER_PRESENT_MAJOR_VERSION            1
-#define SERVER_PRESENT_MINOR_VERSION            2
+#define SERVER_PRESENT_MINOR_VERSION            4
 
 /* RandR */
 #define SERVER_RANDR_MAJOR_VERSION		1
diff --git a/present/present.c b/present/present.c
index 211868341d..63415e479d 100644
--- a/present/present.c
+++ b/present/present.c
@@ -230,6 +230,9 @@ present_pixmap(WindowPtr window,
                RRCrtcPtr target_crtc,
                SyncFence *wait_fence,
                SyncFence *idle_fence,
+               struct dri3_syncobj *syncobj,
+               uint64_t acquire_point,
+               uint64_t release_point,
                uint32_t options,
                uint64_t window_msc,
                uint64_t divisor,
@@ -250,6 +253,9 @@ present_pixmap(WindowPtr window,
                                        target_crtc,
                                        wait_fence,
                                        idle_fence,
+                                       syncobj,
+                                       acquire_point,
+                                       release_point,
                                        options,
                                        window_msc,
                                        divisor,
@@ -272,6 +278,7 @@ present_notify_msc(WindowPtr window,
                           0, 0,
                           NULL,
                           NULL, NULL,
+                          NULL, 0, 0,
                           divisor == 0 ? PresentOptionAsync : 0,
                           target_msc, divisor, remainder, NULL, 0);
 }
diff --git a/present/present_execute.c b/present/present_execute.c
index 68a5878be9..2b4e253e2b 100644
--- a/present/present_execute.c
+++ b/present/present_execute.c
@@ -21,6 +21,7 @@
  */
 
 #include "present_priv.h"
+#include <sys/eventfd.h>
 
 /*
  * Called when the wait fence is triggered; just gets the current msc/ust and
@@ -37,6 +38,21 @@ present_wait_fence_triggered(void *param)
     screen_priv->re_execute(vblank);
 }
 
+static void present_syncobj_triggered(int fd, int xevents, void *data)
+{
+    present_vblank_ptr vblank = data;
+    ScreenPtr screen = vblank->screen;
+    present_screen_priv_ptr screen_priv = present_screen_priv(screen);
+    uint64_t efd_value;
+
+    read(fd, &efd_value, sizeof (efd_value));
+    SetNotifyFd(fd, NULL, 0, NULL);
+    close(fd);
+    vblank->efd = -1;
+
+    screen_priv->re_execute(vblank);
+}
+
 Bool
 present_execute_wait(present_vblank_ptr vblank, uint64_t crtc_msc)
 {
@@ -58,6 +74,15 @@ present_execute_wait(present_vblank_ptr vblank, uint64_t crtc_msc)
             return TRUE;
         }
     }
+
+    if (vblank->syncobj && !vblank->syncobj->check(vblank->syncobj, vblank->acquire_point)) {
+        vblank->efd = eventfd(0, EFD_CLOEXEC);
+        SetNotifyFd(vblank->efd, present_syncobj_triggered, X_NOTIFY_READ, vblank);
+        vblank->syncobj->eventfd(vblank->syncobj, vblank->acquire_point,
+                                 vblank->efd, FALSE /* wait_avail */);
+        return TRUE;
+    }
+
     return FALSE;
 }
 
@@ -85,7 +110,12 @@ present_execute_copy(present_vblank_ptr vblank, uint64_t crtc_msc)
      * which is then freed, freeing the region
      */
     vblank->update = NULL;
-    screen_priv->flush(window);
+    if (vblank->syncobj) {
+        int fence_fd = screen_priv->flush_fenced(window);
+        vblank->syncobj->import_fence(vblank->syncobj, vblank->release_point, fence_fd);
+    } else {
+        screen_priv->flush(window);
+    }
 
     present_pixmap_idle(vblank->pixmap, vblank->window, vblank->serial, vblank->idle_fence);
 }
diff --git a/present/present_priv.h b/present/present_priv.h
index 4ad7298647..ac9ada8a39 100644
--- a/present/present_priv.h
+++ b/present/present_priv.h
@@ -36,6 +36,7 @@
 #include <xfixes.h>
 #include <randrstr.h>
 #include <inttypes.h>
+#include "dri3.h"
 
 #if 0
 #define DebugPresent(x) ErrorF x
@@ -90,6 +91,10 @@ struct present_vblank {
     Bool                abort_flip;     /* aborting this flip */
     PresentFlipReason   reason;         /* reason for which flip is not possible */
     Bool                has_suboptimal; /* whether client can support SuboptimalCopy mode */
+    struct dri3_syncobj *syncobj;
+    uint64_t            acquire_point;
+    uint64_t            release_point;
+    int                 efd;
 };
 
 typedef struct present_screen_priv present_screen_priv_rec, *present_screen_priv_ptr;
@@ -124,6 +129,9 @@ typedef int (*present_priv_pixmap_ptr)(WindowPtr window,
                                        RRCrtcPtr target_crtc,
                                        SyncFence *wait_fence,
                                        SyncFence *idle_fence,
+                                       struct dri3_syncobj *syncobj,
+                                       uint64_t acquire_point,
+                                       uint64_t release_point,
                                        uint32_t options,
                                        uint64_t window_msc,
                                        uint64_t divisor,
@@ -137,6 +145,7 @@ typedef int (*present_priv_queue_vblank_ptr)(ScreenPtr screen,
                                              uint64_t event_id,
                                              uint64_t msc);
 typedef void (*present_priv_flush_ptr)(WindowPtr window);
+typedef int (*present_priv_flush_fenced_ptr)(WindowPtr window);
 typedef void (*present_priv_re_execute_ptr)(present_vblank_ptr vblank);
 
 typedef void (*present_priv_abort_vblank_ptr)(ScreenPtr screen,
@@ -147,6 +156,7 @@ typedef void (*present_priv_abort_vblank_ptr)(ScreenPtr screen,
 typedef void (*present_priv_flip_destroy_ptr)(ScreenPtr screen);
 
 struct present_screen_priv {
+    ScreenPtr                   pScreen;
     CloseScreenProcPtr          CloseScreen;
     ConfigNotifyProcPtr         ConfigNotify;
     DestroyWindowProcPtr        DestroyWindow;
@@ -180,6 +190,7 @@ struct present_screen_priv {
 
     present_priv_queue_vblank_ptr       queue_vblank;
     present_priv_flush_ptr              flush;
+    present_priv_flush_fenced_ptr       flush_fenced;
     present_priv_re_execute_ptr         re_execute;
 
     present_priv_abort_vblank_ptr       abort_vblank;
@@ -290,6 +301,9 @@ present_pixmap(WindowPtr window,
                RRCrtcPtr target_crtc,
                SyncFence *wait_fence,
                SyncFence *idle_fence,
+               struct dri3_syncobj *syncobj,
+               uint64_t acquire_point,
+               uint64_t release_point,
                uint32_t options,
                uint64_t target_msc,
                uint64_t divisor,
@@ -464,6 +478,9 @@ present_vblank_init(present_vblank_ptr vblank,
                     RRCrtcPtr target_crtc,
                     SyncFence *wait_fence,
                     SyncFence *idle_fence,
+                    struct dri3_syncobj *syncobj,
+                    uint64_t acquire_point,
+                    uint64_t release_point,
                     uint32_t options,
                     const uint32_t capabilities,
                     present_notify_ptr notifies,
@@ -482,6 +499,9 @@ present_vblank_create(WindowPtr window,
                       RRCrtcPtr target_crtc,
                       SyncFence *wait_fence,
                       SyncFence *idle_fence,
+                      struct dri3_syncobj *syncobj,
+                      uint64_t acquire_point,
+                      uint64_t release_point,
                       uint32_t options,
                       const uint32_t capabilities,
                       present_notify_ptr notifies,
diff --git a/present/present_request.c b/present/present_request.c
index f3e5679b5d..1d2c0ee5da 100644
--- a/present/present_request.c
+++ b/present/present_request.c
@@ -145,7 +145,7 @@ proc_present_pixmap(ClientPtr client)
 
     ret = present_pixmap(window, pixmap, stuff->serial, valid, update,
                          stuff->x_off, stuff->y_off, target_crtc,
-                         wait_fence, idle_fence, stuff->options,
+                         wait_fence, idle_fence, NULL, 0, 0, stuff->options,
                          stuff->target_msc, stuff->divisor, stuff->remainder, notifies, nnotifies);
     if (ret != Success)
         present_destroy_notifies(notifies, nnotifies);
@@ -240,12 +240,99 @@ proc_present_query_capabilities (ClientPtr client)
     return Success;
 }
 
+#define VERIFY_SYNCOBJ_OR_NONE(syncobj_ptr, syncobj_id, client, access)\
+    do {\
+        if ((syncobj_id) == None)\
+            (syncobj_ptr) = NULL;\
+        else \
+            VERIFY_DRI3_SYNCOBJ(syncobj_id, syncobj_ptr, access);\
+    } while (0);
+
+static int
+proc_present_pixmap_synced (ClientPtr client)
+{
+    REQUEST(xPresentPixmapSyncedReq);
+    WindowPtr           window;
+    PixmapPtr           pixmap;
+    RegionPtr           valid = NULL;
+    RegionPtr           update = NULL;
+    struct dri3_syncobj *syncobj;
+    RRCrtcPtr           target_crtc;
+    int                 ret;
+    int                 nnotifies;
+    present_notify_ptr  notifies = NULL;
+
+    REQUEST_AT_LEAST_SIZE(xPresentPixmapSyncedReq);
+    ret = dixLookupWindow(&window, stuff->window, client, DixWriteAccess);
+    if (ret != Success)
+        return ret;
+    ret = dixLookupResourceByType((void **) &pixmap, stuff->pixmap, RT_PIXMAP, client, DixReadAccess);
+    if (ret != Success)
+        return ret;
+
+    if (window->drawable.depth != pixmap->drawable.depth)
+        return BadMatch;
+
+    VERIFY_REGION_OR_NONE(valid, stuff->valid, client, DixReadAccess);
+    VERIFY_REGION_OR_NONE(update, stuff->update, client, DixReadAccess);
+
+    VERIFY_CRTC_OR_NONE(target_crtc, stuff->target_crtc, client, DixReadAccess);
+
+    VERIFY_SYNCOBJ_OR_NONE(syncobj, stuff->syncobj, client, DixWriteAccess);
+
+    if (stuff->options & ~(PresentAllOptions)) {
+        client->errorValue = stuff->options;
+        return BadValue;
+    }
+
+    if (stuff->divisor == 0) {
+        if (stuff->remainder != 0) {
+            client->errorValue = (CARD32) stuff->remainder;
+            return BadValue;
+        }
+    } else {
+        if (stuff->remainder >= stuff->divisor) {
+            client->errorValue = (CARD32) stuff->remainder;
+            return BadValue;
+        }
+    }
+
+    if (stuff->syncobj &&
+        (stuff->acquire_point == 0 ||
+         stuff->release_point == 0 ||
+         stuff->acquire_point >= stuff->release_point)) 
+        return BadValue;
+
+    nnotifies = (client->req_len << 2) - sizeof (xPresentPixmapSyncedReq);
+    if (nnotifies % sizeof (xPresentNotify))
+        return BadLength;
+
+    nnotifies /= sizeof (xPresentNotify);
+    if (nnotifies) {
+        ret = present_create_notifies(client, nnotifies, (xPresentNotify *) (stuff + 1), &notifies);
+        if (ret != Success)
+            return ret;
+    }
+
+
+    ret = present_pixmap(window, pixmap, stuff->serial, valid, update,
+                         stuff->x_off, stuff->y_off, target_crtc,
+                         None /* wait_fence */, None /* idle_fence */,
+                         syncobj, stuff->acquire_point, stuff->release_point,
+                         stuff->options, stuff->target_msc, stuff->divisor, stuff->remainder,
+                         notifies, nnotifies);
+    if (ret != Success)
+        present_destroy_notifies(notifies, nnotifies);
+    return ret;
+}
+
 static int (*proc_present_vector[PresentNumberRequests]) (ClientPtr) = {
     proc_present_query_version,            /* 0 */
     proc_present_pixmap,                   /* 1 */
     proc_present_notify_msc,               /* 2 */
     proc_present_select_input,             /* 3 */
     proc_present_query_capabilities,       /* 4 */
+    proc_present_pixmap_synced,            /* 5 */
 };
 
 int
@@ -325,12 +412,46 @@ sproc_present_query_capabilities (ClientPtr client)
     return (*proc_present_vector[stuff->presentReqType]) (client);
 }
 
+
+static int _X_COLD
+sproc_present_pixmap_synced(ClientPtr client)
+{
+    REQUEST(xPresentPixmapSyncedReq);
+    REQUEST_AT_LEAST_SIZE(xPresentPixmapSyncedReq);
+
+    swaps(&stuff->length);
+
+    swapl(&stuff->window);
+
+    swapl(&stuff->pixmap);
+    swapl(&stuff->serial);
+
+    swapl(&stuff->valid);
+    swapl(&stuff->update);
+
+    swaps(&stuff->x_off);
+    swaps(&stuff->y_off);
+    swapl(&stuff->target_crtc);
+
+    swapll(&stuff->acquire_point);
+    swapll(&stuff->release_point);
+    swapl(&stuff->syncobj);
+
+    swapl(&stuff->options);
+
+    swapll(&stuff->target_msc);
+    swapll(&stuff->divisor);
+    swapll(&stuff->remainder);
+    return (*proc_present_vector[stuff->presentReqType]) (client);
+}
+
 static int (*sproc_present_vector[PresentNumberRequests]) (ClientPtr) = {
     sproc_present_query_version,           /* 0 */
     sproc_present_pixmap,                  /* 1 */
     sproc_present_notify_msc,              /* 2 */
     sproc_present_select_input,            /* 3 */
     sproc_present_query_capabilities,      /* 4 */
+    sproc_present_pixmap_synced,           /* 5 */
 };
 
 int _X_COLD
diff --git a/present/present_scmd.c b/present/present_scmd.c
index d378f00167..9a99c80280 100644
--- a/present/present_scmd.c
+++ b/present/present_scmd.c
@@ -738,6 +738,9 @@ present_scmd_pixmap(WindowPtr window,
                     RRCrtcPtr target_crtc,
                     SyncFence *wait_fence,
                     SyncFence *idle_fence,
+                    struct dri3_syncobj *syncobj,
+                    uint64_t acquire_point,
+                    uint64_t release_point,
                     uint32_t options,
                     uint64_t target_window_msc,
                     uint64_t divisor,
@@ -824,6 +827,9 @@ present_scmd_pixmap(WindowPtr window,
                                    target_crtc,
                                    wait_fence,
                                    idle_fence,
+                                   syncobj,
+                                   acquire_point,
+                                   release_point,
                                    options,
                                    screen_priv->info ? screen_priv->info->capabilities : 0,
                                    notifies,
diff --git a/present/present_screen.c b/present/present_screen.c
index 2c29aafd23..df6a6a215e 100644
--- a/present/present_screen.c
+++ b/present/present_screen.c
@@ -187,6 +187,7 @@ present_screen_priv_init(ScreenPtr screen)
     wrap(screen_priv, screen, ClipNotify, present_clip_notify);
 
     dixSetPrivate(&screen->devPrivates, &present_screen_private_key, screen_priv);
+    screen_priv->pScreen = screen;
 
     return screen_priv;
 }
diff --git a/present/present_vblank.c b/present/present_vblank.c
index 4f94f16e44..0d690473d9 100644
--- a/present/present_vblank.c
+++ b/present/present_vblank.c
@@ -55,6 +55,9 @@ present_vblank_init(present_vblank_ptr vblank,
                     RRCrtcPtr target_crtc,
                     SyncFence *wait_fence,
                     SyncFence *idle_fence,
+                    struct dri3_syncobj *syncobj,
+                    uint64_t acquire_point,
+                    uint64_t release_point,
                     uint32_t options,
                     const uint32_t capabilities,
                     present_notify_ptr notifies,
@@ -106,6 +109,7 @@ present_vblank_init(present_vblank_ptr vblank,
     vblank->notifies = notifies;
     vblank->num_notifies = num_notifies;
     vblank->has_suboptimal = (options & PresentOptionSuboptimal);
+    vblank->efd = -1;
 
     if (pixmap != NULL &&
         !(options & PresentOptionCopy) &&
@@ -135,6 +139,13 @@ present_vblank_init(present_vblank_ptr vblank,
             goto no_mem;
     }
 
+    if (syncobj && (capabilities & PresentCapabilitySyncobj)) {
+        vblank->syncobj = syncobj;
+        ++syncobj->refcount;
+        vblank->acquire_point = acquire_point;
+        vblank->release_point = release_point;
+    }
+
     if (pixmap)
         DebugPresent(("q %" PRIu64 " %p %" PRIu64 ": %08" PRIx32 " -> %08" PRIx32 " (crtc %p) flip %d vsync %d serial %d\n",
                       vblank->event_id, vblank, target_msc,
@@ -158,6 +169,9 @@ present_vblank_create(WindowPtr window,
                       RRCrtcPtr target_crtc,
                       SyncFence *wait_fence,
                       SyncFence *idle_fence,
+                      struct dri3_syncobj *syncobj,
+                      uint64_t acquire_point,
+                      uint64_t release_point,
                       uint32_t options,
                       const uint32_t capabilities,
                       present_notify_ptr notifies,
@@ -172,6 +186,7 @@ present_vblank_create(WindowPtr window,
 
     if (present_vblank_init(vblank, window, pixmap, serial, valid, update,
                             x_off, y_off, target_crtc, wait_fence, idle_fence,
+                            syncobj, acquire_point, release_point,
                             options, capabilities, notifies, num_notifies,
                             target_msc, crtc_msc))
         return vblank;
@@ -229,5 +244,13 @@ present_vblank_destroy(present_vblank_ptr vblank)
     if (vblank->notifies)
         present_destroy_notifies(vblank->notifies, vblank->num_notifies);
 
+    if (vblank->efd >= 0) {
+        SetNotifyFd(vblank->efd, NULL, 0, NULL);
+        close(vblank->efd);
+    }
+
+    if (vblank->syncobj && --vblank->syncobj->refcount == 0)
+        vblank->syncobj->free(vblank->syncobj);
+
     free(vblank);
 }
-- 
GitLab


From c6521760a605b95403397b0c6fdf9bac4090bfb8 Mon Sep 17 00:00:00 2001
From: Erik Kurzinger <ekurzinger@nvidia.com>
Date: Tue, 15 Aug 2023 15:32:47 -0700
Subject: [PATCH 4/4] xwayland: add support for wp_linux_explicit_sync_v2

This protocol allows for explicit synchronization of GPU operations by
Wayland clients and the compositor. Xwayland can make use of this to
ensure any rendering it initiates has completed before the target image
is accessed by the compositor, without having to rely on kernel-level
implicit synchronization.

Furthermore, for X11 clients that also support explicit synchronization
using the mechanisms exposed in the DRI3 and Present extensions, this
Wayland protocol allows us to simply forward the timeline, acquire, and
release points directly to the compositor, ideally avoiding any
premature stalls in the presentation pipeline.

Signed-off-by: Erik Kurzinger <ekurzinger@nvidia.com>
---
 dri3/dri3.h                           |   2 +
 hw/xwayland/meson.build               |   3 +
 hw/xwayland/xwayland-glamor-gbm.c     | 141 ++++++++++++++++++++++++++
 hw/xwayland/xwayland-glamor.c         |  22 ++++
 hw/xwayland/xwayland-glamor.h         |   8 ++
 hw/xwayland/xwayland-present.c        |  61 +++++++++--
 hw/xwayland/xwayland-present.h        |   1 +
 hw/xwayland/xwayland-screen.c         |   1 +
 hw/xwayland/xwayland-screen.h         |   4 +
 hw/xwayland/xwayland-window-buffers.c |  44 +++++++-
 hw/xwayland/xwayland-window.c         |  10 ++
 hw/xwayland/xwayland-window.h         |   1 +
 present/present_execute.c             |   5 +-
 13 files changed, 293 insertions(+), 10 deletions(-)

diff --git a/dri3/dri3.h b/dri3/dri3.h
index 456e7a38d9..ef2f75308c 100644
--- a/dri3/dri3.h
+++ b/dri3/dri3.h
@@ -44,6 +44,8 @@ struct dri3_syncobj
     void (*import_fence)(struct dri3_syncobj *syncobj, uint64_t point, int fd);
     void (*signal)(struct dri3_syncobj *syncobj, uint64_t point);
     void (*eventfd)(struct dri3_syncobj *syncobj, uint64_t point, int efd, Bool wait_avail);
+    void (*window_attach)(struct dri3_syncobj *syncobj, WindowPtr window,
+                          uint64_t acquire_point, uint64_t release_point);
 };
 
 #define VERIFY_DRI3_SYNCOBJ(id, ptr, a)\
diff --git a/hw/xwayland/meson.build b/hw/xwayland/meson.build
index f2038ab7c3..91fe3f3d12 100644
--- a/hw/xwayland/meson.build
+++ b/hw/xwayland/meson.build
@@ -49,6 +49,7 @@ drm_lease_xml = join_paths(protodir, 'staging', 'drm-lease', 'drm-lease-v1.xml')
 shortcuts_inhibit_xml = join_paths(protodir, 'unstable', 'keyboard-shortcuts-inhibit', 'keyboard-shortcuts-inhibit-unstable-v1.xml')
 xwayland_shell_xml = join_paths(protodir, 'staging', 'xwayland-shell', 'xwayland-shell-v1.xml')
 tearing_xml = join_paths(protodir, 'staging', 'tearing-control', 'tearing-control-v1.xml')
+explicit_sync_xml = join_paths(protodir, 'staging', 'linux-explicit-synchronization', 'linux-explicit-synchronization-v2.xml')
 
 client_header = generator(scanner,
     output : '@BASENAME@-client-protocol.h',
@@ -78,6 +79,7 @@ srcs += client_header.process(drm_lease_xml)
 srcs += client_header.process(shortcuts_inhibit_xml)
 srcs += client_header.process(xwayland_shell_xml)
 srcs += client_header.process(tearing_xml)
+srcs += client_header.process(explicit_sync_xml)
 srcs += code.process(relative_xml)
 srcs += code.process(pointer_xml)
 srcs += code.process(gestures_xml)
@@ -91,6 +93,7 @@ srcs += code.process(drm_lease_xml)
 srcs += code.process(shortcuts_inhibit_xml)
 srcs += code.process(xwayland_shell_xml)
 srcs += code.process(tearing_xml)
+srcs += code.process(explicit_sync_xml)
 
 if build_ei
     xwayland_dep += libei_dep
diff --git a/hw/xwayland/xwayland-glamor-gbm.c b/hw/xwayland/xwayland-glamor-gbm.c
index 66e448b759..ce0d2fcbf2 100644
--- a/hw/xwayland/xwayland-glamor-gbm.c
+++ b/hw/xwayland/xwayland-glamor-gbm.c
@@ -35,6 +35,9 @@
 #include <sys/stat.h>
 #include <xf86drm.h>
 #include <drm_fourcc.h>
+#include <linux/dma-buf.h>
+#include <linux/sync_file.h>
+#include <sys/ioctl.h>
 
 #define MESA_EGL_NO_X11_HEADERS
 #define EGL_NO_X11
@@ -51,6 +54,7 @@
 #include "xwayland-screen.h"
 
 #include "linux-dmabuf-unstable-v1-client-protocol.h"
+#include "linux-explicit-synchronization-v2-client-protocol.h"
 
 struct xwl_gbm_private {
     drmDevice *device;
@@ -553,6 +557,22 @@ xwl_glamor_gbm_get_wl_buffer_for_pixmap(PixmapPtr pixmap)
     return xwl_pixmap->buffer;
 }
 
+static void
+xwl_screen_destroy_explicit_sync(struct xwl_screen *xwl_screen)
+{
+    if (xwl_screen->syncobj) {
+        xwl_screen->syncobj->free(xwl_screen->syncobj);
+        xwl_screen->syncobj = NULL;
+    }
+
+    if (xwl_screen->explicit_sync) {
+        wp_linux_explicit_sync_v2_destroy(xwl_screen->explicit_sync);
+        xwl_screen->explicit_sync = NULL;
+    }
+
+    xwl_screen->timeline_point = 0;
+}
+
 static void
 xwl_glamor_gbm_cleanup(struct xwl_screen *xwl_screen)
 {
@@ -567,6 +587,7 @@ xwl_glamor_gbm_cleanup(struct xwl_screen *xwl_screen)
         wl_drm_destroy(xwl_gbm->drm);
     if (xwl_gbm->gbm)
         gbm_device_destroy(xwl_gbm->gbm);
+    xwl_screen_destroy_explicit_sync(xwl_screen);
 
     free(xwl_gbm);
 }
@@ -811,12 +832,79 @@ glamor_egl_fd_from_pixmap(ScreenPtr screen, PixmapPtr pixmap,
     return -1;
 }
 
+static int xwl_glamor_gbm_dmabuf_export_sync_file(PixmapPtr pixmap)
+{
+    struct xwl_pixmap *xwl_pixmap = xwl_pixmap_get(pixmap);
+    int num_planes = gbm_bo_get_plane_count(xwl_pixmap->bo);
+    int sync_file = -1;
+    int p;
+
+    for (p = 0; p < num_planes; ++p) {
+        int plane_fd = gbm_bo_get_fd_for_plane(xwl_pixmap->bo, p);
+        struct dma_buf_export_sync_file export_args = { 0 };
+        export_args.fd = -1;
+        export_args.flags = DMA_BUF_SYNC_READ;
+        drmIoctl(plane_fd, DMA_BUF_IOCTL_EXPORT_SYNC_FILE, &export_args);
+        close(plane_fd);
+        if (sync_file == -1) {
+            sync_file = export_args.fd;
+        } else {
+            struct sync_merge_data merge_args = { 0 };
+            merge_args.fd2 = export_args.fd;
+            ioctl(sync_file, SYNC_IOC_MERGE, &merge_args);
+            close(export_args.fd);
+            close(sync_file);
+            sync_file = merge_args.fence;
+        }
+    }
+
+    return sync_file;
+}
+
+static void xwl_glamor_gbm_dmabuf_import_sync_file(PixmapPtr pixmap, int sync_file)
+{
+    struct xwl_pixmap *xwl_pixmap = xwl_pixmap_get(pixmap);
+    int num_planes = gbm_bo_get_plane_count(xwl_pixmap->bo);
+    int p;
+
+    for (p = 0; p < num_planes; ++p) {
+        int plane_fd = gbm_bo_get_fd_for_plane(xwl_pixmap->bo, p);
+        struct dma_buf_import_sync_file import_args = { 0 };
+        import_args.fd = sync_file;
+        import_args.flags = DMA_BUF_SYNC_READ;
+        drmIoctl(plane_fd, DMA_BUF_IOCTL_IMPORT_SYNC_FILE, &import_args);
+        close(plane_fd);
+    }
+    close(sync_file);
+}
+
 struct xwl_dri3_syncobj
 {
     struct dri3_syncobj base;
     uint32_t handle;
+    struct wp_linux_sync_timeline_v2 *timeline;
 };
 
+static void xwl_dri3_syncobj_window_attach(struct dri3_syncobj *syncobj,
+                                           WindowPtr window,
+                                           uint64_t acquire_point,
+                                           uint64_t release_point)
+{
+    struct xwl_window *xwl_window = xwl_window_get(window);
+    struct xwl_dri3_syncobj *xwl_syncobj = (struct xwl_dri3_syncobj *)syncobj;
+    uint32_t acquire_hi = acquire_point >> 32;
+    uint32_t acquire_lo = acquire_point & 0xffffffff;
+    uint32_t release_hi = release_point >> 32;
+    uint32_t release_lo = release_point & 0xffffffff;
+
+    wp_linux_surface_sync_v2_set_acquire_point(xwl_window->surface_sync,
+                                               xwl_syncobj->timeline,
+                                               acquire_hi, acquire_lo);
+    wp_linux_surface_sync_v2_set_release_point(xwl_window->surface_sync,
+                                               xwl_syncobj->timeline,
+                                               release_hi, release_lo);
+}
+
 static Bool xwl_dri3_check_syncobj(struct dri3_syncobj *syncobj,
                                    uint64_t point)
 {
@@ -874,6 +962,9 @@ static void xwl_dri3_free_syncobj(struct dri3_syncobj *syncobj)
     struct xwl_screen *xwl_screen = xwl_screen_get(syncobj->screen);
     struct xwl_gbm_private *xwl_gbm = xwl_gbm_get(xwl_screen);
 
+    if (xwl_syncobj->timeline)
+        wp_linux_sync_timeline_v2_destroy(xwl_syncobj->timeline);
+
     if (xwl_syncobj->handle)
         drmSyncobjDestroy(xwl_gbm->drm_fd, xwl_syncobj->handle);
 
@@ -921,6 +1012,7 @@ static struct dri3_syncobj *xwl_dri3_create_syncobj(struct xwl_screen *xwl_scree
     syncobj->base.import_fence = xwl_dri3_syncobj_import_fence;
     syncobj->base.signal = xwl_dri3_signal_syncobj;
     syncobj->base.eventfd = xwl_dri3_syncobj_eventfd;
+    syncobj->base.window_attach = xwl_dri3_syncobj_window_attach;
     return &syncobj->base;
 
 fail:
@@ -951,6 +1043,41 @@ static struct dri3_syncobj *xwl_dri3_import_syncobj(ClientPtr client,
     return &syncobj->base;
 }
 
+static Bool
+xwl_screen_init_explicit_sync(struct xwl_screen *xwl_screen)
+{
+    struct xwl_gbm_private *xwl_gbm = xwl_gbm_get(xwl_screen);
+    uint64_t syncobj_cap;
+    uint32_t syncobj_handle;
+    int sync_file = -1;
+
+    if (!xwl_screen->explicit_sync)
+        return FALSE;
+
+    if (drmGetCap(xwl_gbm->drm_fd, DRM_CAP_SYNCOBJ_TIMELINE,
+                  &syncobj_cap) || !syncobj_cap)
+        return FALSE;
+
+    /* Check if timeline syncobj sync_file import / export is supported. */
+    drmSyncobjExportSyncFileTimeline(xwl_gbm->drm_fd, 0, 0, &sync_file);
+    if (errno != ENOENT)
+        return FALSE;
+
+    if (drmSyncobjCreate(xwl_gbm->drm_fd, 0, &syncobj_handle))
+        goto fail;
+
+    xwl_screen->syncobj = xwl_dri3_create_syncobj(xwl_screen, syncobj_handle);
+    if (!xwl_screen->syncobj)
+        goto fail;
+
+    xwl_screen->timeline_point = 1;
+    return TRUE;
+
+fail:
+    xwl_screen_destroy_explicit_sync(xwl_screen);
+    return FALSE;
+}
+
 static const dri3_screen_info_rec xwl_dri3_info = {
     .version = 2,
     .open = NULL,
@@ -1122,6 +1249,11 @@ xwl_glamor_gbm_init_wl_registry(struct xwl_screen *xwl_screen,
     } else if (strcmp(name, "zwp_linux_dmabuf_v1") == 0) {
         xwl_screen_set_dmabuf_interface(xwl_screen, id, version);
         return TRUE;
+    } else if (strcmp(name, "wp_linux_explicit_sync_v2") == 0) {
+        xwl_screen->explicit_sync =
+            wl_registry_bind(xwl_screen->registry, id,
+                             &wp_linux_explicit_sync_v2_interface,
+                             version);
     }
 
     /* no match */
@@ -1306,6 +1438,13 @@ xwl_glamor_gbm_init_egl(struct xwl_screen *xwl_screen)
     if (gbm_backend_name && strcmp(gbm_backend_name, "drm") != 0)
         xwl_screen->glvnd_vendor = gbm_backend_name;
 
+    if (epoxy_has_egl_extension(xwl_screen->egl_display,
+                                "ANDROID_native_fence_sync"))
+        xwl_screen_init_explicit_sync(xwl_screen);
+    else
+        /* release our reference to the global */
+        xwl_screen_destroy_explicit_sync(xwl_screen);
+
     return TRUE;
 error:
     if (xwl_screen->egl_display != EGL_NO_DISPLAY) {
@@ -1393,4 +1532,6 @@ xwl_glamor_init_gbm(struct xwl_screen *xwl_screen)
     xwl_screen->gbm_backend.backend_flags = XWL_EGL_BACKEND_NEEDS_BUFFER_FLUSH |
                                             XWL_EGL_BACKEND_NEEDS_N_BUFFERING;
     xwl_screen->gbm_backend.create_pixmap_for_window = xwl_glamor_gbm_create_pixmap_for_window;
+    xwl_screen->gbm_backend.dmabuf_export_sync_file = xwl_glamor_gbm_dmabuf_export_sync_file;
+    xwl_screen->gbm_backend.dmabuf_import_sync_file = xwl_glamor_gbm_dmabuf_import_sync_file;
 }
diff --git a/hw/xwayland/xwayland-glamor.c b/hw/xwayland/xwayland-glamor.c
index f9a4ef0b49..185c5a76c0 100644
--- a/hw/xwayland/xwayland-glamor.c
+++ b/hw/xwayland/xwayland-glamor.c
@@ -1098,6 +1098,28 @@ xwl_glamor_get_fence(struct xwl_screen *xwl_screen)
     return fence_fd;
 }
 
+int xwl_glamor_dmabuf_export_sync_file(PixmapPtr pixmap)
+{
+    ScreenPtr screen = pixmap->drawable.pScreen;
+    struct xwl_screen *xwl_screen = xwl_screen_get(screen);
+
+    if (xwl_screen->glamor && xwl_screen->egl_backend &&
+        xwl_screen->egl_backend->dmabuf_export_sync_file)
+        return xwl_screen->egl_backend->dmabuf_export_sync_file(pixmap);
+
+    return -1;
+}
+
+void xwl_glamor_dmabuf_import_sync_file(PixmapPtr pixmap, int sync_file)
+{
+    ScreenPtr screen = pixmap->drawable.pScreen;
+    struct xwl_screen *xwl_screen = xwl_screen_get(screen);
+
+    if (xwl_screen->glamor && xwl_screen->egl_backend &&
+        xwl_screen->egl_backend->dmabuf_import_sync_file)
+        xwl_screen->egl_backend->dmabuf_import_sync_file(pixmap, sync_file);
+}
+
 void
 xwl_glamor_init_backends(struct xwl_screen *xwl_screen, Bool use_eglstream)
 {
diff --git a/hw/xwayland/xwayland-glamor.h b/hw/xwayland/xwayland-glamor.h
index 6f46043642..0437daa1b6 100644
--- a/hw/xwayland/xwayland-glamor.h
+++ b/hw/xwayland/xwayland-glamor.h
@@ -107,6 +107,12 @@ struct xwl_egl_backend {
 
     /* Direct hook to create the backing pixmap for a window */
     PixmapPtr (*create_pixmap_for_window)(struct xwl_window *xwl_window);
+
+    /* Merge the implicit read fences of each plane into a sync file */
+    int (*dmabuf_export_sync_file)(PixmapPtr pixmap);
+
+    /* Sets the implicit read fence of each plane to the given sync file */
+    void (*dmabuf_import_sync_file)(PixmapPtr pixmap, int sync_file);
 };
 
 #ifdef XWL_HAS_GLAMOR
@@ -152,6 +158,8 @@ Bool xwl_glamor_get_drawable_modifiers(DrawablePtr drawable, uint32_t format,
 Bool xwl_glamor_check_flip(WindowPtr present_window, PixmapPtr pixmap);
 PixmapPtr xwl_glamor_create_pixmap_for_window (struct xwl_window *xwl_window);
 int xwl_glamor_get_fence(struct xwl_screen *screen);
+int xwl_glamor_dmabuf_export_sync_file(PixmapPtr pixmap);
+void xwl_glamor_dmabuf_import_sync_file(PixmapPtr pixmap, int sync_file);
 
 #ifdef XV
 /* glamor Xv Adaptor */
diff --git a/hw/xwayland/xwayland-present.c b/hw/xwayland/xwayland-present.c
index 6143491804..f7ce8665b1 100644
--- a/hw/xwayland/xwayland-present.c
+++ b/hw/xwayland/xwayland-present.c
@@ -446,8 +446,11 @@ xwl_present_buffer_release(void *data)
 
     vblank = &event->vblank;
 
-    if (vblank->syncobj)
-        vblank->syncobj->signal(vblank->syncobj, vblank->release_point);
+    if (vblank->efd >= 0) {
+        // wait until release fence is available
+        event->released = TRUE;
+        return;
+    }
 
     present_pixmap_idle(vblank->pixmap, vblank->window, vblank->serial, vblank->idle_fence);
 
@@ -459,6 +462,25 @@ xwl_present_buffer_release(void *data)
         xwl_present_free_event(event);
 }
 
+static void
+xwl_present_syncobj_release_fence_avail(int fd, int xevents, void *data)
+{
+    struct xwl_present_event *event = data;
+    present_vblank_ptr vblank = &event->vblank;
+    uint64_t efd_value;
+
+    read(fd, &efd_value, sizeof (efd_value));
+    SetNotifyFd(fd, NULL, 0, NULL);
+    close(fd);
+    vblank->efd = -1;
+
+    int fence_fd = vblank->syncobj->export_fence(vblank->syncobj, vblank->release_point);
+    xwl_glamor_dmabuf_import_sync_file(vblank->pixmap, fence_fd);
+
+    if (event->released)
+        xwl_present_buffer_release(data);
+}
+
 static void
 xwl_present_msc_bump(struct xwl_present_window *xwl_present_window)
 {
@@ -794,6 +816,35 @@ xwl_present_flip(present_vblank_ptr vblank, RegionPtr damage)
 
     event->pixmap = pixmap;
 
+    if (xwl_window->xwl_screen->explicit_sync) {
+        /* If the client is not using explicit sync, extract the dma-buf
+         * implicit fence and use that as the acquire point. Then when the
+         * compositor submits the release fence, set that as the new implicit
+         * fence */
+        if (!vblank->syncobj) {
+            struct xwl_screen *xwl_screen = xwl_window->xwl_screen;
+            vblank->syncobj = xwl_screen->syncobj;
+            ++xwl_screen->syncobj->refcount;
+
+            vblank->acquire_point = xwl_screen->timeline_point;
+            vblank->release_point = vblank->acquire_point + 1;
+            xwl_screen->timeline_point += 2;
+
+            int fence_fd = xwl_glamor_dmabuf_export_sync_file(pixmap);
+            vblank->syncobj->import_fence(vblank->syncobj, vblank->acquire_point, fence_fd);
+
+            vblank->efd = eventfd(0, EFD_CLOEXEC);
+            SetNotifyFd(vblank->efd, xwl_present_syncobj_release_fence_avail,
+                        X_NOTIFY_READ, event);
+            vblank->syncobj->eventfd(vblank->syncobj, vblank->release_point,
+                                     vblank->efd, TRUE /* wait_avail */);
+
+        }
+
+        vblank->syncobj->window_attach(vblank->syncobj, present_window,
+                                       vblank->acquire_point, vblank->release_point);
+    }
+
     xwl_pixmap_set_buffer_release_cb(pixmap, xwl_present_buffer_release, event);
 
     /* We can flip directly to the main surface (full screen window without clips) */
@@ -1093,10 +1144,8 @@ xwl_present_init(ScreenPtr screen)
         return FALSE;
 
     xwl_screen->present_capabilities = XWL_PRESENT_CAPS;
-    if (epoxy_has_egl_extension(xwl_screen->egl_display,
-                                "ANDROID_native_fence_sync"))
-        xwl_screen->present_capabilities |=
-            PresentCapabilitySyncobj;
+    if (xwl_screen->explicit_sync)
+        xwl_screen->present_capabilities |= PresentCapabilitySyncobj;
 
     screen_priv->query_capabilities = xwl_present_query_capabilities;
     screen_priv->get_crtc = xwl_present_get_crtc;
diff --git a/hw/xwayland/xwayland-present.h b/hw/xwayland/xwayland-present.h
index 4fd1e579ff..22ee0d28e2 100644
--- a/hw/xwayland/xwayland-present.h
+++ b/hw/xwayland/xwayland-present.h
@@ -60,6 +60,7 @@ struct xwl_present_event {
 
     PixmapPtr pixmap;
     Bool async_may_tear;
+    Bool released;
 };
 
 Bool xwl_present_entered_for_each_frame_callback(void);
diff --git a/hw/xwayland/xwayland-screen.c b/hw/xwayland/xwayland-screen.c
index 6b57fbe9d7..e49cb503b7 100644
--- a/hw/xwayland/xwayland-screen.c
+++ b/hw/xwayland/xwayland-screen.c
@@ -64,6 +64,7 @@
 #include "xdg-shell-client-protocol.h"
 #include "xwayland-shell-v1-client-protocol.h"
 #include "tearing-control-v1-client-protocol.h"
+#include "linux-explicit-synchronization-v2-client-protocol.h"
 
 static DevPrivateKeyRec xwl_screen_private_key;
 static DevPrivateKeyRec xwl_client_private_key;
diff --git a/hw/xwayland/xwayland-screen.h b/hw/xwayland/xwayland-screen.h
index 97af13baeb..f4e0a1d0db 100644
--- a/hw/xwayland/xwayland-screen.h
+++ b/hw/xwayland/xwayland-screen.h
@@ -110,6 +110,7 @@ struct xwl_screen {
     struct wp_viewporter *viewporter;
     struct xwayland_shell_v1 *xwayland_shell;
     struct wp_tearing_control_manager_v1 *tearing_control_manager;
+    struct wp_linux_explicit_sync_v2 *explicit_sync;
     struct xorg_list drm_lease_devices;
     struct xorg_list queued_drm_lease_devices;
     struct xorg_list drm_leases;
@@ -146,6 +147,9 @@ struct xwl_screen {
 #endif
 
     uint32_t present_capabilities;
+
+    struct dri3_syncobj *syncobj;
+    uint64_t timeline_point;
 };
 
 /* Apps which use randr/vidmode to change the mode when going fullscreen,
diff --git a/hw/xwayland/xwayland-window-buffers.c b/hw/xwayland/xwayland-window-buffers.c
index f7bb571bbf..54f2ff790c 100644
--- a/hw/xwayland/xwayland-window-buffers.c
+++ b/hw/xwayland/xwayland-window-buffers.c
@@ -32,6 +32,10 @@
 #include "xwayland-pixmap.h"
 #include "xwayland-screen.h"
 #include "xwayland-window-buffers.h"
+#include "dri3.h"
+
+#include <poll.h>
+#include <sys/eventfd.h>
 
 #define BUFFER_TIMEOUT 1 * 1000 /* ms */
 
@@ -40,6 +44,7 @@ struct xwl_window_buffer {
     PixmapPtr pixmap;
     RegionPtr damage_region;
     Bool recycle_on_release;
+    int efd;
     int refcnt;
     uint32_t time;
     struct xorg_list link_buffer;
@@ -80,6 +85,7 @@ xwl_window_buffer_new(struct xwl_window *xwl_window)
     xwl_window_buffer->xwl_window = xwl_window;
     xwl_window_buffer->damage_region = RegionCreate(NullBox, 1);
     xwl_window_buffer->pixmap = NullPixmap;
+    xwl_window_buffer->efd = -1;
     xwl_window_buffer->refcnt = 1;
 
     xorg_list_append(&xwl_window_buffer->link_buffer,
@@ -230,6 +236,20 @@ xwl_window_buffer_release_callback(void *data)
                  xwl_window);
 }
 
+static void
+xwl_window_buffer_syncobj_release_callback(int fd, int xevents, void *data)
+{
+    struct xwl_window_buffer *xwl_window_buffer = data;
+    uint64_t efd_value;
+
+    read(fd, &efd_value, sizeof (efd_value));
+    SetNotifyFd(fd, NULL, 0, NULL);
+    close(fd);
+    xwl_window_buffer->efd = -1;
+
+    xwl_window_buffer_release_callback(data);
+}
+
 void
 xwl_window_buffers_init(struct xwl_window *xwl_window)
 {
@@ -359,9 +379,27 @@ xwl_window_buffers_get_pixmap(struct xwl_window *xwl_window,
 
     /* Hold a reference on the buffer until it's released by the compositor */
     xwl_window_buffer->refcnt++;
-    xwl_pixmap_set_buffer_release_cb(xwl_window_buffer->pixmap,
-                                     xwl_window_buffer_release_callback,
-                                     xwl_window_buffer);
+    if (xwl_screen->explicit_sync) {
+        uint64_t acquire_point = xwl_screen->timeline_point;
+        uint64_t release_point = acquire_point + 1;
+        xwl_screen->timeline_point += 2;
+
+        int fence_fd = xwl_glamor_get_fence(xwl_screen);
+        xwl_screen->syncobj->import_fence(xwl_screen->syncobj, acquire_point, fence_fd);
+
+        xwl_screen->syncobj->window_attach(xwl_screen->syncobj, xwl_window->window,
+                                           acquire_point, release_point);
+
+        xwl_window_buffer->efd = eventfd(0, EFD_CLOEXEC);
+        SetNotifyFd(xwl_window_buffer->efd, xwl_window_buffer_syncobj_release_callback,
+                    X_NOTIFY_READ, xwl_window_buffer);
+        xwl_screen->syncobj->eventfd(xwl_screen->syncobj, release_point,
+                                     xwl_window_buffer->efd, FALSE /* wait_avail */);
+    } else {
+        xwl_pixmap_set_buffer_release_cb(xwl_window_buffer->pixmap,
+                                         xwl_window_buffer_release_callback,
+                                         xwl_window_buffer);
+    }
 
     xorg_list_del(&xwl_window_buffer->link_buffer);
     xorg_list_append(&xwl_window_buffer->link_buffer,
diff --git a/hw/xwayland/xwayland-window.c b/hw/xwayland/xwayland-window.c
index f1d6580e67..7cc6d30b67 100644
--- a/hw/xwayland/xwayland-window.c
+++ b/hw/xwayland/xwayland-window.c
@@ -50,6 +50,7 @@
 #include "viewporter-client-protocol.h"
 #include "xdg-shell-client-protocol.h"
 #include "xwayland-shell-v1-client-protocol.h"
+#include "linux-explicit-synchronization-v2-client-protocol.h"
 
 #define DELAYED_WL_SURFACE_DESTROY 1000 /* ms */
 
@@ -936,6 +937,12 @@ ensure_surface_for_window(WindowPtr window)
             xwl_screen->tearing_control_manager, xwl_window->surface);
     }
 
+    if (xwl_screen->explicit_sync) {
+        xwl_window->surface_sync =
+            wp_linux_explicit_sync_v2_get_surface(xwl_screen->explicit_sync,
+                                                  xwl_window->surface);
+    }
+
     return TRUE;
 
 err:
@@ -1149,6 +1156,9 @@ xwl_unrealize_window(WindowPtr window)
     if (xwl_window->tearing_control)
         wp_tearing_control_v1_destroy(xwl_window->tearing_control);
 
+    if (xwl_window->surface_sync)
+        wp_linux_surface_sync_v2_destroy(xwl_window->surface_sync);
+
     release_wl_surface_for_window(xwl_window);
     xorg_list_del(&xwl_window->link_damage);
     xorg_list_del(&xwl_window->link_window);
diff --git a/hw/xwayland/xwayland-window.h b/hw/xwayland/xwayland-window.h
index 45ae16da0f..e4007429f4 100644
--- a/hw/xwayland/xwayland-window.h
+++ b/hw/xwayland/xwayland-window.h
@@ -122,6 +122,7 @@ struct xwl_window {
     /* If TRUE, the window buffer format supports scanout with implicit modifier */
     Bool has_implicit_scanout_support;
     struct wp_tearing_control_v1 *tearing_control;
+    struct wp_linux_surface_sync_v2 *surface_sync;
 };
 
 struct xwl_window *xwl_window_get(WindowPtr window);
diff --git a/present/present_execute.c b/present/present_execute.c
index 2b4e253e2b..714e39b17d 100644
--- a/present/present_execute.c
+++ b/present/present_execute.c
@@ -75,7 +75,10 @@ present_execute_wait(present_vblank_ptr vblank, uint64_t crtc_msc)
         }
     }
 
-    if (vblank->syncobj && !vblank->syncobj->check(vblank->syncobj, vblank->acquire_point)) {
+    /* Defer execution of explicitly synchronized copies.
+     * Flip synchronization is managed by the driver. */
+    if (!vblank->flip && vblank->syncobj &&
+        !vblank->syncobj->check(vblank->syncobj, vblank->acquire_point)) {
         vblank->efd = eventfd(0, EFD_CLOEXEC);
         SetNotifyFd(vblank->efd, present_syncobj_triggered, X_NOTIFY_READ, vblank);
         vblank->syncobj->eventfd(vblank->syncobj, vblank->acquire_point,
-- 
GitLab

