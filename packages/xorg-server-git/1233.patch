From 4eb8b419f5611fef782ce601611cf0c561619190 Mon Sep 17 00:00:00 2001
From: Peter Hutterer <peter.hutterer@who-t.net>
Date: Thu, 4 Jan 2024 10:31:51 +1000
Subject: [PATCH 1/5] dix: don't allow for devices with 0 axes

This just makes the existing behavior explicit, previously we relied on
a malloc(numAxes * ...) to return NULL to error out.
---
 dix/devices.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/dix/devices.c b/dix/devices.c
index 3f3224d626..bdbe2dc735 100644
--- a/dix/devices.c
+++ b/dix/devices.c
@@ -1335,6 +1335,7 @@ InitValuatorClassDeviceStruct(DeviceIntPtr dev, int numAxes, Atom *labels,
     ValuatorClassPtr valc;
 
     BUG_RETURN_VAL(dev == NULL, FALSE);
+    BUG_RETURN_VAL(numAxes == 0, FALSE);
 
     if (numAxes > MAX_VALUATORS) {
         LogMessage(X_WARNING,
-- 
GitLab


From 97cb6e5dbd63ee82a3c18c77606d069bc3384e62 Mon Sep 17 00:00:00 2001
From: Peter Hutterer <peter.hutterer@who-t.net>
Date: Thu, 4 Jan 2024 11:12:28 +1000
Subject: [PATCH 2/5] dix: use valuator_mask_free() to free the last touches
 vmask

No functional effect since that one is just a free() call anyway.
---
 dix/devices.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/dix/devices.c b/dix/devices.c
index bdbe2dc735..d58f96b473 100644
--- a/dix/devices.c
+++ b/dix/devices.c
@@ -1021,7 +1021,7 @@ CloseDevice(DeviceIntPtr dev)
     free(dev->config_info);     /* Allocated in xf86ActivateDevice. */
     free(dev->last.scroll);
     for (j = 0; j < dev->last.num_touches; j++)
-        free(dev->last.touches[j].valuators);
+        valuator_mask_free(&dev->last.touches[j].valuators);
     free(dev->last.touches);
     dev->config_info = NULL;
     dixFreePrivates(dev->devPrivates, PRIVATE_DEVICE);
-- 
GitLab


From 201a67604a5e4f20a7c4203a3c3cd7a7b6598f88 Mon Sep 17 00:00:00 2001
From: Peter Hutterer <peter.hutterer@who-t.net>
Date: Thu, 4 Jan 2024 10:15:26 +1000
Subject: [PATCH 3/5] test: fix various leaks in the tests

---
 dix/devices.c         |  2 +-
 include/input.h       |  2 ++
 test/input.c          | 17 +++++++++++++++++
 test/list.c           |  4 ++++
 test/signal-logging.c |  5 ++++-
 test/test_xkb.c       |  8 ++++++++
 test/xfree86.c        |  7 +++++++
 7 files changed, 43 insertions(+), 2 deletions(-)

diff --git a/dix/devices.c b/dix/devices.c
index d58f96b473..56b811fa25 100644
--- a/dix/devices.c
+++ b/dix/devices.c
@@ -778,7 +778,7 @@ InitAndStartDevices(void)
 /**
  * Free the given device class and reset the pointer to NULL.
  */
-static void
+void
 FreeDeviceClass(int type, void **class)
 {
     if (!(*class))
diff --git a/include/input.h b/include/input.h
index 75c7c2df68..fd5b7c4df3 100644
--- a/include/input.h
+++ b/include/input.h
@@ -331,6 +331,8 @@ extern _X_EXPORT Bool InitButtonClassDeviceStruct(DeviceIntPtr /*device */ ,
 
 extern _X_INTERNAL ValuatorClassPtr AllocValuatorClass(ValuatorClassPtr src,
                                                        int numAxes);
+extern _X_INTERNAL void FreeDeviceClass(int type, void **class);
+
 
 extern _X_EXPORT Bool InitValuatorClassDeviceStruct(DeviceIntPtr /*device */ ,
                                                     int /*numAxes */ ,
diff --git a/test/input.c b/test/input.c
index e27374db32..34a75fd7fa 100644
--- a/test/input.c
+++ b/test/input.c
@@ -154,6 +154,9 @@ dix_init_valuators(void)
     assert(axis->scroll.type == SCROLL_TYPE_VERTICAL);
     assert(axis->scroll.increment == 3.0);
     assert(axis->scroll.flags == SCROLL_FLAG_NONE);
+
+    FreeDeviceClass(ValuatorClass, (void**)&val);
+    free(dev.last.scroll); /* sigh, allocated but not freed by the valuator functions */
 }
 
 /* just check the known success cases, and that error cases set the client's
@@ -282,6 +285,7 @@ dix_event_to_core(int type)
     ev.detail.key = 0;
     rc = EventToCore((InternalEvent *) &ev, &core, &count);
     test_event();
+    free(core);
 
     x = 1;
     y = 2;
@@ -289,6 +293,7 @@ dix_event_to_core(int type)
     ev.root_y = y;
     rc = EventToCore((InternalEvent *) &ev, &core, &count);
     test_event();
+    free(core);
 
     x = 0x7FFF;
     y = 0x7FFF;
@@ -296,6 +301,7 @@ dix_event_to_core(int type)
     ev.root_y = y;
     rc = EventToCore((InternalEvent *) &ev, &core, &count);
     test_event();
+    free(core);
 
     x = 0x8000;                 /* too high */
     y = 0x8000;                 /* too high */
@@ -307,6 +313,7 @@ dix_event_to_core(int type)
     assert(count == 1);
     assert(core->u.keyButtonPointer.rootX != x);
     assert(core->u.keyButtonPointer.rootY != y);
+    free(core);
 
     x = 0x7FFF;
     y = 0x7FFF;
@@ -316,16 +323,19 @@ dix_event_to_core(int type)
     ev.time = time;
     rc = EventToCore((InternalEvent *) &ev, &core, &count);
     test_event();
+    free(core);
 
     detail = 1;
     ev.detail.key = detail;
     rc = EventToCore((InternalEvent *) &ev, &core, &count);
     test_event();
+    free(core);
 
     detail = 0xFF;              /* highest value */
     ev.detail.key = detail;
     rc = EventToCore((InternalEvent *) &ev, &core, &count);
     test_event();
+    free(core);
 
     detail = 0xFFF;             /* too big */
     ev.detail.key = detail;
@@ -338,6 +348,7 @@ dix_event_to_core(int type)
     ev.corestate = state;
     rc = EventToCore((InternalEvent *) &ev, &core, &count);
     test_event();
+    free(core);
 
     state = 0x10000;            /* too big */
     ev.corestate = state;
@@ -347,6 +358,7 @@ dix_event_to_core(int type)
     assert(count == 1);
     assert(core->u.keyButtonPointer.state != state);
     assert(core->u.keyButtonPointer.state == (state & 0xFFFF));
+    free(core);
 
 #undef test_event
 }
@@ -1197,6 +1209,7 @@ dix_input_attributes(void)
 
     new = DuplicateInputAttributes(orig);
     assert(memcmp(orig, new, sizeof(InputAttributes)) == 0);
+    FreeInputAttributes(new);
 
     orig->product = xnfstrdup("product name");
     new = DuplicateInputAttributes(orig);
@@ -1330,6 +1343,7 @@ dix_input_valuator_masks(void)
     }
 
     valuator_mask_free(&mask);
+    valuator_mask_free(&copy);
     assert(mask == NULL);
 }
 
@@ -1361,6 +1375,9 @@ dix_valuator_mode(void)
     valuator_set_mode(&dev, VALUATOR_MODE_ALL_AXES, Relative);
     for (i = 0; i < num_axes; i++)
         assert(valuator_get_mode(&dev, i) == Relative);
+
+    FreeDeviceClass(ValuatorClass, (void**)&dev.valuator);
+    free(dev.last.scroll); /* sigh, allocated but not freed by the valuator functions */
 }
 
 static void
diff --git a/test/list.c b/test/list.c
index d51817c214..fee41a5388 100644
--- a/test/list.c
+++ b/test/list.c
@@ -266,6 +266,8 @@ test_nt_list_append(void)
         i++;
     }
     assert(i == 11);
+
+    free(foo);
 }
 
 static void
@@ -300,6 +302,8 @@ test_nt_list_insert(void)
         i++;
     }
     assert(i == 11);
+
+    free(foo);
 }
 
 static void
diff --git a/test/signal-logging.c b/test/signal-logging.c
index 4ba8485fc1..97477dcee9 100644
--- a/test/signal-logging.c
+++ b/test/signal-logging.c
@@ -176,13 +176,16 @@ static void logging_format(void)
     char read_buf[2048];
     char *logmsg;
     uintptr_t ptr;
+    char *fname = NULL;
 
     /* set up buf to contain ".....end" */
     memset(buf, '.', sizeof(buf));
     strcpy(&buf[sizeof(buf) - 4], "end");
 
-    LogInit(log_file_path, NULL);
+    fname = (char*)LogInit(log_file_path, NULL);
+    assert(fname != NULL);
     assert((f = fopen(log_file_path, "r")));
+    free(fname);
 
 #define read_log_msg(msg) do {                                  \
         msg = fgets(read_buf, sizeof(read_buf), f);             \
diff --git a/test/test_xkb.c b/test/test_xkb.c
index a131073901..18e37e408e 100644
--- a/test/test_xkb.c
+++ b/test/test_xkb.c
@@ -75,6 +75,8 @@ xkb_get_rules_test(void)
     assert(strcmp(rmlvo.layout, XKB_DFLT_LAYOUT) == 0);
     assert(strcmp(rmlvo.variant, XKB_DFLT_VARIANT) == 0);
     assert(strcmp(rmlvo.options, XKB_DFLT_OPTIONS) == 0);
+
+    XkbFreeRMLVOSet(&rmlvo, FALSE);
 }
 
 /**
@@ -114,6 +116,7 @@ xkb_set_rules_test(void)
     assert(strcmp(rmlvo.options, rmlvo_new.options) == 0);
 
     XkbFreeRMLVOSet(&rmlvo, FALSE);
+    XkbFreeRMLVOSet(&rmlvo_new, FALSE);
 }
 
 /**
@@ -139,6 +142,7 @@ xkb_set_get_rules_test(void)
 
     /* pass 1 */
     XkbSetRulesDflts(&rmlvo);
+    XkbFreeRMLVOSet(&rmlvo, FALSE);
     XkbGetRulesDflts(&rmlvo);
 
     /* Make a backup copy */
@@ -159,12 +163,16 @@ xkb_set_get_rules_test(void)
     assert(strcmp(rmlvo.variant, rmlvo_backup.variant) == 0);
     assert(strcmp(rmlvo.options, rmlvo_backup.options) == 0);
 
+    XkbFreeRMLVOSet(&rmlvo, FALSE);
     XkbGetRulesDflts(&rmlvo);
     assert(strcmp(rmlvo.rules, rmlvo_backup.rules) == 0);
     assert(strcmp(rmlvo.model, rmlvo_backup.model) == 0);
     assert(strcmp(rmlvo.layout, rmlvo_backup.layout) == 0);
     assert(strcmp(rmlvo.variant, rmlvo_backup.variant) == 0);
     assert(strcmp(rmlvo.options, rmlvo_backup.options) == 0);
+
+    XkbFreeRMLVOSet(&rmlvo, FALSE);
+    XkbFreeRMLVOSet(&rmlvo_backup, FALSE);
 }
 
 int
diff --git a/test/xfree86.c b/test/xfree86.c
index 59e3716339..76837d57e2 100644
--- a/test/xfree86.c
+++ b/test/xfree86.c
@@ -63,17 +63,24 @@ xfree86_option_list_duplicate(void)
 
     assert(strcmp(val1, v1) == 0);
     assert(strcmp(val1, val2) == 0);
+    free(val1);
+    free(val2);
 
     val1 = xf86CheckStrOption(options, o2, "1");
     val2 = xf86CheckStrOption(duplicate, o2, "2");
 
     assert(strcmp(val1, v2) == 0);
     assert(strcmp(val1, val2) == 0);
+    free(val1);
+    free(val2);
 
     a = xf86FindOption(options, o_null);
     b = xf86FindOption(duplicate, o_null);
     assert(a);
     assert(b);
+
+    xf86OptionListFree(duplicate);
+    xf86OptionListFree(options);
 }
 
 static void
-- 
GitLab


From be26a86120b0680fa8d219b373653ea79de2f3e9 Mon Sep 17 00:00:00 2001
From: Peter Hutterer <peter.hutterer@who-t.net>
Date: Thu, 4 Jan 2024 12:30:20 +1000
Subject: [PATCH 4/5] test: fix the xtest device to show the dependency

These two tests were dependent on each other, the second test relied on
the xtest devices created in the first test. Let's move the bits that
are shared out into the main function instead to illustrate this better.

This lets us add a call to CloseDownDevices() that will remove the leaks
in this set of tests.
---
 test/xtest.c | 58 +++++++++++++++++++++++++++-------------------------
 1 file changed, 30 insertions(+), 28 deletions(-)

diff --git a/test/xtest.c b/test/xtest.c
index 12433afc45..171f285f60 100644
--- a/test/xtest.c
+++ b/test/xtest.c
@@ -62,34 +62,6 @@ device_cursor_cleanup(DeviceIntPtr dev, ScreenPtr screen)
 static void
 xtest_init_devices(void)
 {
-    ScreenRec screen = {0};
-    ClientRec server_client = {0};
-    WindowRec root = {{0}};
-    WindowOptRec optional = {0};
-
-    /* random stuff that needs initialization */
-    root.drawable.id = 0xab;
-    root.optional = &optional;
-    screen.root = &root;
-    screenInfo.numScreens = 1;
-    screenInfo.screens[0] = &screen;
-    screen.myNum = 0;
-    screen.id = 100;
-    screen.width = 640;
-    screen.height = 480;
-    screen.DeviceCursorInitialize = device_cursor_init;
-    screen.DeviceCursorCleanup = device_cursor_cleanup;
-    dixResetPrivates();
-    serverClient = &server_client;
-    InitClient(serverClient, 0, (void *) NULL);
-    if (!InitClientResources(serverClient)) /* for root resources */
-        FatalError("couldn't init server resources");
-    InitAtoms();
-    SyncExtensionInit();
-
-    /* this also inits the xtest devices */
-    InitCoreDevices();
-
     assert(xtestpointer);
     assert(xtestkeyboard);
     assert(IsXTestDevice(xtestpointer, NULL));
@@ -135,8 +107,38 @@ xtest_properties(void)
 int
 xtest_test(void)
 {
+    ScreenRec screen = {0};
+    ClientRec server_client = {0};
+    WindowRec root = {{0}};
+    WindowOptRec optional = {0};
+
+    /* random stuff that needs initialization */
+    root.drawable.id = 0xab;
+    root.optional = &optional;
+    screen.root = &root;
+    screenInfo.numScreens = 1;
+    screenInfo.screens[0] = &screen;
+    screen.myNum = 0;
+    screen.id = 100;
+    screen.width = 640;
+    screen.height = 480;
+    screen.DeviceCursorInitialize = device_cursor_init;
+    screen.DeviceCursorCleanup = device_cursor_cleanup;
+    dixResetPrivates();
+    serverClient = &server_client;
+    InitClient(serverClient, 0, (void *) NULL);
+    if (!InitClientResources(serverClient)) /* for root resources */
+        FatalError("couldn't init server resources");
+    InitAtoms();
+    SyncExtensionInit();
+
+    /* this also inits the xtest devices */
+    InitCoreDevices();
+
     xtest_init_devices();
     xtest_properties();
 
+    CloseDownDevices();
+
     return 0;
 }
-- 
GitLab


From 8b85f37ac0b84487a086eb020ef9e3b0d9da0795 Mon Sep 17 00:00:00 2001
From: Peter Hutterer <peter.hutterer@who-t.net>
Date: Thu, 4 Jan 2024 12:23:35 +1000
Subject: [PATCH 5/5] test: fix the touch tests to no longer leak

Instead of hardcoded TouchRec/ValuatorRec init the devices with the
matching functions and go from there. This allows us to clean them
up later, removing the various leaks that stop asan from being happy.
---
 test/touch.c | 110 +++++++++++++++++++++++++++++++--------------------
 1 file changed, 67 insertions(+), 43 deletions(-)

diff --git a/test/touch.c b/test/touch.c
index 7b22ceddb2..1f183a72ab 100644
--- a/test/touch.c
+++ b/test/touch.c
@@ -35,27 +35,46 @@
 
 #include "tests-common.h"
 
+static void
+free_device(DeviceIntPtr dev)
+{
+    free(dev->name);
+    free(dev->last.scroll); /* sigh, allocated but not freed by the valuator functions */
+    for (int i = 0; i < dev->last.num_touches; i++)
+         valuator_mask_free(&dev->last.touches[i].valuators);
+
+    free(dev->last.touches); /* sigh, allocated but not freed by the valuator functions */
+    FreeDeviceClass(XIValuatorClass, (void**)&dev->valuator);
+    FreeDeviceClass(XITouchClass, (void**)&dev->touch);
+}
+
 static void
 touch_grow_queue(void)
 {
     DeviceIntRec dev;
-    ValuatorClassRec val;
-    TouchClassRec touch;
+    SpriteInfoRec sprite;
     size_t size, new_size;
     int i;
+    ScreenRec screen;
+    Atom labels[2] = { 0 };
+
+    screenInfo.screens[0] = &screen;
 
     memset(&dev, 0, sizeof(dev));
+    dev.type = MASTER_POINTER;  /* claim it's a master to stop ptracccel */
     dev.name = xnfstrdup("test device");
     dev.id = 2;
-    dev.valuator = &val;
-    val.numAxes = 5;
-    dev.touch = &touch;
+
+    InitValuatorClassDeviceStruct(&dev, 2, labels, 10, Absolute);
+    InitTouchClassDeviceStruct(&dev, 5, XIDirectTouch, 2);
+
+    memset(&sprite, 0, sizeof(sprite));
+    dev.spriteInfo = &sprite;
+
     inputInfo.devices = &dev;
 
     size = 5;
 
-    dev.last.num_touches = size;
-    dev.last.touches = calloc(dev.last.num_touches, sizeof(*dev.last.touches));
     assert(dev.last.touches);
     for (i = 0; i < size; i++) {
         dev.last.touches[i].active = TRUE;
@@ -91,27 +110,33 @@ touch_grow_queue(void)
         assert(t->ddx_id == 0);
     }
 
-    free(dev.name);
+    free_device(&dev);
 }
 
 static void
 touch_find_ddxid(void)
 {
     DeviceIntRec dev;
+    SpriteInfoRec sprite;
     DDXTouchPointInfoPtr ti, ti2;
-    ValuatorClassRec val;
-    TouchClassRec touch;
     int size = 5;
     int i;
+    Atom labels[2] = { 0 };
+    ScreenRec screen;
+
+    screenInfo.screens[0] = &screen;
 
     memset(&dev, 0, sizeof(dev));
+    dev.type = MASTER_POINTER;  /* claim it's a master to stop ptracccel */
     dev.name = xnfstrdup("test device");
     dev.id = 2;
-    dev.valuator = &val;
-    val.numAxes = 5;
-    dev.touch = &touch;
-    dev.last.num_touches = size;
-    dev.last.touches = calloc(dev.last.num_touches, sizeof(*dev.last.touches));
+
+    InitValuatorClassDeviceStruct(&dev, 2, labels, 10, Absolute);
+    InitTouchClassDeviceStruct(&dev, 5, XIDirectTouch, 2);
+
+    memset(&sprite, 0, sizeof(sprite));
+    dev.spriteInfo = &sprite;
+
     inputInfo.devices = &dev;
     assert(dev.last.touches);
 
@@ -159,32 +184,35 @@ touch_find_ddxid(void)
     ti = TouchFindByDDXID(&dev, 40, TRUE);
     assert(ti == &dev.last.touches[size+1]);
 
-    free(dev.name);
+    free_device(&dev);
 }
 
 static void
 touch_begin_ddxtouch(void)
 {
     DeviceIntRec dev;
+    SpriteInfoRec sprite;
     DDXTouchPointInfoPtr ti;
-    ValuatorClassRec val;
-    TouchClassRec touch;
     int ddx_id = 123;
     unsigned int last_client_id = 0;
-    int size = 5;
+    Atom labels[2] = { 0 };
+    ScreenRec screen;
+
+    screenInfo.screens[0] = &screen;
 
     memset(&dev, 0, sizeof(dev));
+    dev.type = MASTER_POINTER;  /* claim it's a master to stop ptracccel */
     dev.name = xnfstrdup("test device");
     dev.id = 2;
-    dev.valuator = &val;
-    val.numAxes = 5;
-    touch.mode = XIDirectTouch;
-    dev.touch = &touch;
-    dev.last.num_touches = size;
-    dev.last.touches = calloc(dev.last.num_touches, sizeof(*dev.last.touches));
     inputInfo.devices = &dev;
-    assert(dev.last.touches);
 
+    InitValuatorClassDeviceStruct(&dev, 2, labels, 10, Absolute);
+    InitTouchClassDeviceStruct(&dev, 5, XIDirectTouch, 2);
+
+    memset(&sprite, 0, sizeof(sprite));
+    dev.spriteInfo = &sprite;
+
+    assert(dev.last.touches);
     ti = TouchBeginDDXTouch(&dev, ddx_id);
     assert(ti);
     assert(ti->ddx_id == ddx_id);
@@ -206,41 +234,36 @@ touch_begin_ddxtouch(void)
     assert(!ti->emulate_pointer);
     last_client_id = ti->client_id;
 
-    free(dev.name);
+    free_device(&dev);
 }
 
 static void
 touch_begin_touch(void)
 {
     DeviceIntRec dev;
-    TouchClassRec touch;
-    ValuatorClassRec val;
     TouchPointInfoPtr ti;
     int touchid = 12434;
     int sourceid = 23;
     SpriteInfoRec sprite;
     ScreenRec screen;
+    Atom labels[2] = { 0 };
 
     screenInfo.screens[0] = &screen;
 
     memset(&dev, 0, sizeof(dev));
+    dev.type = MASTER_POINTER;  /* claim it's a master to stop ptracccel */
     dev.name = xnfstrdup("test device");
     dev.id = 2;
 
-    memset(&sprite, 0, sizeof(sprite));
-    dev.spriteInfo = &sprite;
-
-    memset(&touch, 0, sizeof(touch));
-    touch.num_touches = 0;
-
-    memset(&val, 0, sizeof(val));
-    dev.valuator = &val;
-    val.numAxes = 2;
-
     ti = TouchBeginTouch(&dev, sourceid, touchid, TRUE);
     assert(!ti);
 
-    dev.touch = &touch;
+    InitValuatorClassDeviceStruct(&dev, 2, labels, 10, Absolute);
+    InitTouchClassDeviceStruct(&dev, 5, XIDirectTouch, 2);
+
+    memset(&sprite, 0, sizeof(sprite));
+    dev.spriteInfo = &sprite;
+
     ti = TouchBeginTouch(&dev, sourceid, touchid, TRUE);
     assert(ti);
     assert(ti->client_id == touchid);
@@ -248,9 +271,9 @@ touch_begin_touch(void)
     assert(ti->sourceid == sourceid);
     assert(ti->emulate_pointer);
 
-    assert(touch.num_touches == 1);
+    assert(dev.touch->num_touches == 5);
 
-    free(dev.name);
+    free_device(&dev);
 }
 
 static void
@@ -265,6 +288,7 @@ touch_init(void)
     screenInfo.screens[0] = &screen;
 
     memset(&dev, 0, sizeof(dev));
+    dev.type = MASTER_POINTER;  /* claim it's a master to stop ptracccel */
     dev.name = xnfstrdup("test device");
 
     memset(&sprite, 0, sizeof(sprite));
@@ -279,7 +303,7 @@ touch_init(void)
     assert(rc == TRUE);
     assert(dev.touch);
 
-    free(dev.name);
+    free_device(&dev);
 }
 
 int
-- 
GitLab

