From a5dad3d87e3ba2be22ff11938ab2d0627ffc3214 Mon Sep 17 00:00:00 2001
From: Konstantin <ria.freelander@gmail.com>
Date: Mon, 27 Jun 2022 20:12:44 +0300
Subject: [PATCH 1/8] tests: fix "xephr-glamor" typo

Signed-off-by: Konstantin Pugin <ria.freelander@gmail.com>

Reviewed-by: Adam Jackson <ajax@redhat.com>
---
 test/meson.build | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/test/meson.build b/test/meson.build
index e39f31a40..a8d9e8497 100644
--- a/test/meson.build
+++ b/test/meson.build
@@ -74,7 +74,7 @@ if get_option('xvfb')
             find_program('scripts/xephyr-glamor-piglit.sh'),
             env: piglit_env,
             timeout: 1200,
-            suite: 'xephr-glamor',
+            suite: 'xephyr-glamor',
         )
 
         if rendercheck.found()
@@ -92,7 +92,7 @@ if get_option('xvfb')
                             '--',
                             xvfb_args,
                            ],
-                     suite: 'xephr-glamor',
+                     suite: 'xephyr-glamor',
                      timeout: 300,
                     )
             endforeach
-- 
GitLab


From 28cebf3cf202f052adde5d564022f715bbc060f0 Mon Sep 17 00:00:00 2001
From: Konstantin <ria.freelander@gmail.com>
Date: Sat, 25 Jun 2022 21:58:08 +0300
Subject: [PATCH 2/8] meson: add glamor gles2 tests

Signed-off-by: Konstantin Pugin <ria.freelander@gmail.com>

Reviewed-by: Adam Jackson <ajax@redhat.com>
---
 test/bugs/bug1354.c                        | 139 +++++++++++++++++++++
 test/bugs/meson.build                      |  49 ++++++++
 test/meson.build                           |  58 ++++++++-
 test/scripts/xephyr-glamor-gles2-piglit.sh |  32 +++++
 4 files changed, 273 insertions(+), 5 deletions(-)
 create mode 100644 test/bugs/bug1354.c
 create mode 100644 test/bugs/meson.build
 create mode 100755 test/scripts/xephyr-glamor-gles2-piglit.sh

diff --git a/test/bugs/bug1354.c b/test/bugs/bug1354.c
new file mode 100644
index 000000000..f12d9a84a
--- /dev/null
+++ b/test/bugs/bug1354.c
@@ -0,0 +1,139 @@
+#include <xcb/xcb.h>
+#include <xcb/xcb_aux.h>
+#include <xcb/xcb_image.h>
+#include <stdint.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <getopt.h>
+#include <ctype.h>
+#include <unistd.h>
+
+#define WIDTH 300
+#define HEIGHT 300
+
+int get_display_pixel(xcb_connection_t* c, xcb_drawable_t win);
+void draw_display_pixel(xcb_connection_t* c, xcb_drawable_t win, uint32_t pixel_color);
+
+int get_display_pixel(xcb_connection_t* c, xcb_drawable_t win)
+{
+	xcb_image_t *image;
+	uint32_t    pixel;
+	int format = XCB_IMAGE_FORMAT_XY_PIXMAP;
+
+	image = xcb_image_get (c, win,
+		 0, 0, WIDTH, HEIGHT,
+		 UINT32_MAX,
+		 format);
+	if (!image) {
+	  printf("xcb_image_get failed: exiting\n");
+	  exit(1);
+	}
+
+	pixel = xcb_image_get_pixel(image, WIDTH/2, HEIGHT/2);
+
+	return pixel;
+}
+
+void draw_display_pixel(xcb_connection_t* c, xcb_drawable_t win, uint32_t pixel_color)
+{
+	xcb_gcontext_t       foreground;
+	uint32_t             mask = 0;
+
+	xcb_rectangle_t rectangles[] = {
+	  {0, 0, WIDTH, HEIGHT},
+	};
+
+	foreground = xcb_generate_id (c);
+	mask = XCB_GC_FOREGROUND | XCB_GC_LINE_WIDTH | XCB_GC_SUBWINDOW_MODE;
+
+	uint32_t values[] = {
+		pixel_color,
+		20,
+		XCB_SUBWINDOW_MODE_INCLUDE_INFERIORS
+	};
+
+	xcb_create_gc (c, foreground, win, mask, values);
+
+	xcb_poly_fill_rectangle (c, win, foreground, 1, rectangles);
+	xcb_aux_sync ( c );
+}
+
+
+int main(int argc, char* argv[])
+{
+	xcb_connection_t    *c, *r;
+	xcb_screen_t        *screen1, *screen2;
+	xcb_drawable_t       win1, win2;
+    char *name_test = NULL, *name_relevant = NULL;
+	uint32_t pixel_server1, pixel_server2;
+	int result = 0;
+	uint32_t test_pixels[3] = {0xff0000, 0x00ff00, 0x0000ff};
+	int gv;
+
+	while ((gv = getopt (argc, argv, "t:r:")) != -1)
+	switch (gv)
+	  {
+	  case 't':
+		name_test = optarg;
+		break;
+	  case 'r':
+		name_relevant = optarg;
+		break;
+	  case '?':
+		if (optopt == 't' || optopt == 'r')
+		  fprintf (stderr, "Option -%c requires an argument - test screen name.\n", optopt);
+		else if (isprint (optopt))
+		  fprintf (stderr, "Unknown option `-%c'.\n", optopt);
+		else
+		  fprintf (stderr,
+		           "Unknown option character `\\x%x'.\n",
+		           optopt);
+		return 1;
+	  default:
+		abort ();
+	  }
+
+	printf("test=%s, rel=%s\n", name_test, name_relevant);
+
+	c = xcb_connect (name_test, NULL);
+	r = xcb_connect (name_relevant, NULL);
+
+	/* get the first screen */
+	screen1 = xcb_setup_roots_iterator (xcb_get_setup (c)).data;
+
+    win1 = xcb_generate_id (c);
+    xcb_create_window (c,                    /* Connection          */
+                       XCB_COPY_FROM_PARENT,          /* depth (same as root)*/
+                       win1,                        /* window Id           */
+                       screen1->root,                  /* parent window       */
+                       0, 0,                          /* x, y                */
+                       WIDTH, HEIGHT,                /* width, height       */
+                       20,                            /* border_width        */
+                       XCB_WINDOW_CLASS_INPUT_OUTPUT, /* class               */
+                       screen1->root_visual,           /* visual              */
+                       0, NULL );                     /* masks, not used yet */
+
+
+    /* Map the window on the screen */
+    xcb_map_window (c, win1);
+    xcb_aux_sync(c);
+
+	/* get the first screen */
+	screen2 = xcb_setup_roots_iterator (xcb_get_setup (r)).data;
+
+	/* root window */
+	win2 = screen2->root;
+
+	for(int i = 0; i < 3; i++)
+	{
+		draw_display_pixel(c, win1, test_pixels[i]);
+		xcb_aux_sync(r);
+		pixel_server1 = get_display_pixel(c, win1);
+		sleep(1);
+		pixel_server2 = get_display_pixel(r, win2);
+		xcb_aux_sync(r);
+		printf("p=0x%x, p2=0x%x\n", pixel_server1, pixel_server2);
+		result+= pixel_server1 == pixel_server2;
+	}
+	return result == 3 ? 0 : 1;
+}
diff --git a/test/bugs/meson.build b/test/bugs/meson.build
new file mode 100644
index 000000000..e63cd207d
--- /dev/null
+++ b/test/bugs/meson.build
@@ -0,0 +1,49 @@
+xcb_dep = dependency('xcb', required: false)
+xcb_image_dep = dependency('xcb-image', required: false)
+xcb_util_dep = dependency('xcb-util', required: false)
+
+xvfb_args = [
+    xvfb_server.full_path(),
+    '-screen',
+    'scrn',
+    '1280x1024x24'
+]
+
+if xcb_dep.found() and xcb_image_dep.found() and xcb_util_dep.found() and get_option('xvfb') and get_option('xephyr') and build_glamor
+    bug1354 = executable('bug1354', 'bug1354.c', dependencies: [xcb_dep, xcb_image_dep, xcb_util_dep])
+    test('bug1354-gl',
+            simple_xinit,
+            args: [simple_xinit.full_path(),
+                bug1354.full_path(),
+                '-t',':201','-r',':200',
+                '----',
+                xephyr_server.full_path(),
+                '-glamor',
+                '-schedMax', '2000',
+                ':201',
+                '--',
+                xvfb_args,
+                ':200'
+                ],
+            suite: 'xephyr-glamor',
+            timeout: 300,
+        )
+    test('bug1354-gles',
+            simple_xinit,
+            args: [simple_xinit.full_path(),
+                bug1354.full_path(),
+                '-t',':199','-r',':198',
+                '----',
+                xephyr_server.full_path(),
+                '-glamor_gles2',
+                '-schedMax', '2000',
+                ':199',
+                '--',
+                xvfb_args,
+                ':198'
+                ],
+            suite: 'xephyr-glamor-gles2',
+            timeout: 300,
+            should_fail: true,
+        )
+endif
\ No newline at end of file
diff --git a/test/meson.build b/test/meson.build
index a8d9e8497..662eee4ef 100644
--- a/test/meson.build
+++ b/test/meson.build
@@ -9,13 +9,24 @@ piglit_env.set('XSERVER_DIR', meson.source_root())
 piglit_env.set('XSERVER_BUILDDIR', meson.build_root())
 
 some_ops = ' -o clear,src,dst,over,xor,disjointover'
-rendercheck_tests = [
+gles2_working_formats = ' -f '+ ','.join(['a8',
+                                          'a8r8g8b8',
+                                          'x8r8g8b8',
+                                          'b8g8r8a8',
+                                          'b8g8r8x8',
+                                          'r8g8b8',
+                                          'r5g5b5',
+                                          'b5g5r5',
+                                          'r5g6b5',
+                                          'b5g6r5',
+                                          'b8g8r8',
+                                          'x8b8g8r8',
+                                          'x2r10g10b10',
+                                          'x2b10g10r10'])
+rendercheck_tests_noblend = [
     ['blend/All/a8r8g8b8', '-t blend -f a8r8g8b8'],
     ['blend/All/x8r8g8b8', '-t blend -f a8r8g8b8,x8r8g8b8'],
     ['blend/All/a2r10g10b10', '-t blend -f a8r8g8b8,a2r10g10b10'],
-    ['blend/Clear', '-t blend -o clear'],
-    ['blend/Src', '-t blend -o src'],
-    ['blend/Over', '-t blend -o over'],
     ['composite/Some/a8r8g8b8', '-t composite -f a8r8g8b8' + some_ops],
     ['composite/Some/x8r8g8b8', '-t composite -f a8r8g8b8,x8r8g8b8' + some_ops],
     ['composite/Some/a2r10g10b10', '-t composite -f a8r8g8b8,a2r10g10b10' + some_ops],
@@ -34,7 +45,19 @@ rendercheck_tests = [
     ['LibreOffice xRGB', '-t libreoffice_xrgb'],
     ['GTK ARGB vs xBGR', '-t gtk_argb_xbgr'],
 ]
-
+rendercheck_blend = [
+    ['blend/Clear', '-t blend -o clear'],
+    ['blend/Src', '-t blend -o src'],
+    ['blend/Over', '-t blend -o over'],
+]
+#Exclude 15bpp for now due to GLES limitation (see glamor.c:470)
+rendercheck_blend_gles2 = [
+    ['blend/Clear', '-t blend -o clear' + gles2_working_formats],
+    ['blend/Src', '-t blend -o src' + gles2_working_formats],
+    ['blend/Over', '-t blend -o over' + gles2_working_formats],
+]
+rendercheck_tests = rendercheck_blend + rendercheck_tests_noblend
+rendercheck_tests_gles2 = rendercheck_blend_gles2 + rendercheck_tests_noblend
 rendercheck = find_program('rendercheck', required:false)
 
 if get_option('xvfb')
@@ -76,6 +99,12 @@ if get_option('xvfb')
             timeout: 1200,
             suite: 'xephyr-glamor',
         )
+        test('XTS',
+            find_program('scripts/xephyr-glamor-gles2-piglit.sh'),
+            env: piglit_env,
+            timeout: 1200,
+            suite: 'xephyr-glamor-gles2',
+        )
 
         if rendercheck.found()
             foreach rctest: rendercheck_tests
@@ -96,6 +125,24 @@ if get_option('xvfb')
                      timeout: 300,
                     )
             endforeach
+            foreach rctest: rendercheck_tests_gles2
+                test(rctest[0],
+                     simple_xinit,
+                     args: [simple_xinit.full_path(),
+                            rendercheck.path(),
+                            rctest[1].split(' '),
+                            '----',
+                            xephyr_server.full_path(),
+                            '-glamor_gles2',
+                            '-glamor-skip-present',
+                            '-schedMax', '2000',
+                            '--',
+                            xvfb_args,
+                           ],
+                     suite: 'xephyr-glamor-gles2',
+                     timeout: 300,
+                    )
+            endforeach
         endif
     endif
 endif
@@ -116,6 +163,7 @@ endif
 subdir('bigreq')
 subdir('damage')
 subdir('sync')
+subdir('bugs')
 
 if build_xorg
 # Tests that require at least some DDX functions in order to fully link
diff --git a/test/scripts/xephyr-glamor-gles2-piglit.sh b/test/scripts/xephyr-glamor-gles2-piglit.sh
new file mode 100755
index 000000000..482e7b7b7
--- /dev/null
+++ b/test/scripts/xephyr-glamor-gles2-piglit.sh
@@ -0,0 +1,32 @@
+#!/bin/sh
+
+# this times out on Travis, because the tests take too long.
+if test "x$TRAVIS_BUILD_DIR" != "x"; then
+    exit 77
+fi
+
+# Start a Xephyr server using glamor.  Since the test environment is
+# headless, we start an Xvfb first to host the Xephyr.
+export PIGLIT_RESULTS_DIR=$XSERVER_BUILDDIR/test/piglit-results/xephyr-glamor-gles2
+
+export SERVER_COMMAND="$XSERVER_BUILDDIR/hw/kdrive/ephyr/Xephyr \
+        -glamor_gles2 \
+        -glamor-skip-present \
+        -noreset \
+        -schedMax 2000 \
+        -screen 1280x1024"
+
+# Tests that currently fail on llvmpipe on CI
+PIGLIT_ARGS="$PIGLIT_ARGS -x xcleararea@6"
+PIGLIT_ARGS="$PIGLIT_ARGS -x xcleararea@7"
+PIGLIT_ARGS="$PIGLIT_ARGS -x xclearwindow@4"
+PIGLIT_ARGS="$PIGLIT_ARGS -x xclearwindow@5"
+PIGLIT_ARGS="$PIGLIT_ARGS -x xcopyarea@1"
+
+export PIGLIT_ARGS
+
+$XSERVER_BUILDDIR/test/simple-xinit \
+        $XSERVER_DIR/test/scripts/run-piglit.sh \
+        -- \
+        $XSERVER_BUILDDIR/hw/vfb/Xvfb \
+        -screen scrn 1280x1024x24
-- 
GitLab


From 2f3ceca6613d671787b8a1471e78d0f8df513f7b Mon Sep 17 00:00:00 2001
From: Konstantin <ria.freelander@gmail.com>
Date: Sun, 26 Jun 2022 00:01:54 +0300
Subject: [PATCH 3/8] glamor: make use of GL_EXT_texture_format_BGRA8888

For 24 and 32 bit depth pictures xserver uses PICT_x8r8g8b8 and PICT_a8r8g8b8 formats,
which must be backed with GL_BGRA format. It is present in OpenGL ES 2.0 only with
GL_EXT_texture_format_BGRA8888 extension. We require such extension in glamor_init,
so, why not to make use of it?
Fixes #1208
Fixes #1354

Signed-off-by: Konstantin Pugin <ria.freelander@gmail.com>

Reviewed-by: Adam Jackson <ajax@redhat.com>
---
 glamor/glamor.c         | 8 ++++----
 glamor/glamor_picture.c | 7 ++-----
 test/bugs/meson.build   | 1 -
 3 files changed, 6 insertions(+), 10 deletions(-)

diff --git a/glamor/glamor.c b/glamor/glamor.c
index 9dcef5fac..0a757db35 100644
--- a/glamor/glamor.c
+++ b/glamor/glamor.c
@@ -586,10 +586,10 @@ glamor_setup_formats(ScreenPtr screen)
 
     if (glamor_priv->is_gles) {
         assert(X_BYTE_ORDER == X_LITTLE_ENDIAN);
-        glamor_add_format(screen, 24, PICT_x8b8g8r8,
-                          GL_RGBA8, GL_RGBA, GL_UNSIGNED_BYTE, TRUE);
-        glamor_add_format(screen, 32, PICT_a8b8g8r8,
-                          GL_RGBA8, GL_RGBA, GL_UNSIGNED_BYTE, TRUE);
+        glamor_add_format(screen, 24, PICT_x8r8g8b8,
+                          GL_BGRA, GL_BGRA, GL_UNSIGNED_BYTE, TRUE);
+        glamor_add_format(screen, 32, PICT_a8r8g8b8,
+                          GL_BGRA, GL_BGRA, GL_UNSIGNED_BYTE, TRUE);
     } else {
         glamor_add_format(screen, 24, PICT_x8r8g8b8,
                           GL_RGBA, GL_BGRA, GL_UNSIGNED_INT_8_8_8_8_REV, TRUE);
diff --git a/glamor/glamor_picture.c b/glamor/glamor_picture.c
index 33b3bebd9..2152b85e1 100644
--- a/glamor/glamor_picture.c
+++ b/glamor/glamor_picture.c
@@ -94,7 +94,7 @@ glamor_get_tex_format_type_from_pictformat(ScreenPtr pScreen,
             *tex_format = GL_BGRA;
             *tex_type = GL_UNSIGNED_INT_8_8_8_8;
         } else {
-            *tex_format = GL_RGBA;
+            *tex_format = GL_BGRA;
             *tex_type = GL_UNSIGNED_BYTE;
 
             swizzle[0] = GL_GREEN;
@@ -113,12 +113,9 @@ glamor_get_tex_format_type_from_pictformat(ScreenPtr pScreen,
             *tex_format = GL_BGRA;
             *tex_type = GL_UNSIGNED_INT_8_8_8_8_REV;
         } else {
-            *tex_format = GL_RGBA;
+            *tex_format = GL_BGRA;
             *tex_type = GL_UNSIGNED_BYTE;
 
-            swizzle[0] = GL_BLUE;
-            swizzle[2] = GL_RED;
-
             if (!is_little_endian)
                 byte_swap_swizzle(swizzle);
             break;
diff --git a/test/bugs/meson.build b/test/bugs/meson.build
index e63cd207d..f15658356 100644
--- a/test/bugs/meson.build
+++ b/test/bugs/meson.build
@@ -44,6 +44,5 @@ if xcb_dep.found() and xcb_image_dep.found() and xcb_util_dep.found() and get_op
                 ],
             suite: 'xephyr-glamor-gles2',
             timeout: 300,
-            should_fail: true,
         )
 endif
\ No newline at end of file
-- 
GitLab


From 941f3550cf27a7a611d81012fa5a0cf194e49c4c Mon Sep 17 00:00:00 2001
From: Konstantin <ria.freelander@gmail.com>
Date: Sat, 25 Jun 2022 17:51:15 +0300
Subject: [PATCH 4/8] glamor: transpose gradients transparently

glUniformMatrix3fv is used with argument transpose set to GL_TRUE.
According to the Khronos OpenGL ES 2.0 pages transpose must be GL_FALSE.
Actually we can just return transformed matrix from
_glamor_gradient_convert_trans_matrix (@anholt suggest),
so @uvas workaround is not required

Signed-off-by: Konstantin Pugin <ria.freelander@gmail.com>

Reviewed-by: Adam Jackson <ajax@redhat.com>
---
 glamor/glamor_gradient.c | 32 +++++++++++++++++++++-----------
 1 file changed, 21 insertions(+), 11 deletions(-)

diff --git a/glamor/glamor_gradient.c b/glamor/glamor_gradient.c
index 7e5d5cca9..0d4245cfa 100644
--- a/glamor/glamor_gradient.c
+++ b/glamor/glamor_gradient.c
@@ -605,27 +605,35 @@ _glamor_gradient_convert_trans_matrix(PictTransform *from, float to[3][3],
      * T_s = | w*t21/h  t22      t23/h|
      *       | w*t31    h*t32    t33  |
      *       --                      --
+     *
+     * Because GLES2 cannot do trasposed mat by spec, we did transposing inside this function
+     * already, and matrix becoming look like this:
+     *       --                      --
+     *       | t11      h*t21/w  t31/w|
+     * T_s = | w*t12/h  t22      t32/h|
+     *       | w*t13    h*t23    t33  |
+     *       --                      --
      */
 
     to[0][0] = (float) pixman_fixed_to_double(from->matrix[0][0]);
-    to[0][1] = (float) pixman_fixed_to_double(from->matrix[0][1])
+    to[1][0] = (float) pixman_fixed_to_double(from->matrix[0][1])
         * (normalize ? (((float) height) / ((float) width)) : 1.0);
-    to[0][2] = (float) pixman_fixed_to_double(from->matrix[0][2])
+    to[2][0] = (float) pixman_fixed_to_double(from->matrix[0][2])
         / (normalize ? ((float) width) : 1.0);
 
-    to[1][0] = (float) pixman_fixed_to_double(from->matrix[1][0])
+    to[0][1] = (float) pixman_fixed_to_double(from->matrix[1][0])
         * (normalize ? (((float) width) / ((float) height)) : 1.0);
     to[1][1] = (float) pixman_fixed_to_double(from->matrix[1][1]);
-    to[1][2] = (float) pixman_fixed_to_double(from->matrix[1][2])
+    to[2][1] = (float) pixman_fixed_to_double(from->matrix[1][2])
         / (normalize ? ((float) height) : 1.0);
 
-    to[2][0] = (float) pixman_fixed_to_double(from->matrix[2][0])
+    to[0][2] = (float) pixman_fixed_to_double(from->matrix[2][0])
         * (normalize ? ((float) width) : 1.0);
-    to[2][1] = (float) pixman_fixed_to_double(from->matrix[2][1])
+    to[1][2] = (float) pixman_fixed_to_double(from->matrix[2][1])
         * (normalize ? ((float) height) : 1.0);
     to[2][2] = (float) pixman_fixed_to_double(from->matrix[2][2]);
 
-    DEBUGF("the transform matrix is:\n%f\t%f\t%f\n%f\t%f\t%f\n%f\t%f\t%f\n",
+    DEBUGF("the transposed transform matrix is:\n%f\t%f\t%f\n%f\t%f\t%f\n%f\t%f\t%f\n",
            to[0][0], to[0][1], to[0][2],
            to[1][0], to[1][1], to[1][2], to[2][0], to[2][1], to[2][2]);
 }
@@ -950,11 +958,12 @@ glamor_generate_radial_gradient_picture(ScreenPtr screen,
         _glamor_gradient_convert_trans_matrix(src_picture->transform,
                                               transform_mat, width, height, 0);
         glUniformMatrix3fv(transform_mat_uniform_location,
-                           1, 1, &transform_mat[0][0]);
+                           1, GL_FALSE, &transform_mat[0][0]);
     }
     else {
+        /* identity matrix dont need to be transposed */
         glUniformMatrix3fv(transform_mat_uniform_location,
-                           1, 1, &identity_mat[0][0]);
+                           1, GL_FALSE, &identity_mat[0][0]);
     }
 
     if (!_glamor_gradient_set_pixmap_destination
@@ -1266,11 +1275,12 @@ glamor_generate_linear_gradient_picture(ScreenPtr screen,
         _glamor_gradient_convert_trans_matrix(src_picture->transform,
                                               transform_mat, width, height, 1);
         glUniformMatrix3fv(transform_mat_uniform_location,
-                           1, 1, &transform_mat[0][0]);
+                           1, GL_FALSE, &transform_mat[0][0]);
     }
     else {
+        /* identity matrix dont need to be transposed */
         glUniformMatrix3fv(transform_mat_uniform_location,
-                           1, 1, &identity_mat[0][0]);
+                           1, GL_FALSE, &identity_mat[0][0]);
     }
 
     if (!_glamor_gradient_set_pixmap_destination
-- 
GitLab


From c00bd4da501e116b3320d2b7fad85510688f79ca Mon Sep 17 00:00:00 2001
From: Yuriy <uuvasiliev@yandex.ru>
Date: Thu, 16 Sep 2021 14:47:44 +0300
Subject: [PATCH 5/8] glamor: fix CbCr format handling

In GLES2, we cannot do GL_RED or GL_RG without GL_EXT_texture_rg.
So, add check for GL_EXT_texture_rg to make it working. Also add
a yuv2 pixman format into render.h to make Xv yuv rendering works.

Signed-off-by: Yuriy Vasilev <uuvasiliev@yandex.ru>

Reviewed-by: Adam Jackson <ajax@redhat.com>
---
 glamor/glamor.c      | 19 +++++++++++++++----
 glamor/glamor_priv.h |  1 +
 render/picture.h     |  5 ++++-
 3 files changed, 20 insertions(+), 5 deletions(-)

diff --git a/glamor/glamor.c b/glamor/glamor.c
index 0a757db35..1d1727508 100644
--- a/glamor/glamor.c
+++ b/glamor/glamor.c
@@ -223,7 +223,7 @@ glamor_create_pixmap(ScreenPtr screen, int w, int h, int depth,
 
     pixmap_priv = glamor_get_pixmap_private(pixmap);
 
-    pixmap_priv->is_cbcr = (usage == GLAMOR_CREATE_FORMAT_CBCR);
+    pixmap_priv->is_cbcr = (GLAMOR_CREATE_FORMAT_CBCR & usage) == GLAMOR_CREATE_FORMAT_CBCR;
 
     pitch = (((w * pixmap->drawable.bitsPerPixel + 7) / 8) + 3) & ~3;
     screen->ModifyPixmapHeader(pixmap, w, h, 0, 0, pitch, NULL);
@@ -550,9 +550,10 @@ glamor_setup_formats(ScreenPtr screen)
     glamor_screen_private *glamor_priv = glamor_get_screen_private(screen);
 
     /* Prefer r8 textures since they're required by GLES3 and core,
-     * only falling back to a8 if we can't do them.
+     * only falling back to a8 if we can't do them. We cannot do them
+     * on GLES2 due to lack of texture swizzle.
      */
-    if (glamor_priv->is_gles || epoxy_has_gl_extension("GL_ARB_texture_rg")) {
+    if (glamor_priv->has_rg && glamor_priv->has_texture_swizzle) {
         glamor_add_format(screen, 1, PICT_a1,
                           GL_R8, GL_RED, GL_UNSIGNED_BYTE, FALSE);
         glamor_add_format(screen, 8, PICT_a8,
@@ -606,8 +607,13 @@ glamor_setup_formats(ScreenPtr screen)
     }
 
     glamor_priv->cbcr_format.depth = 16;
-    glamor_priv->cbcr_format.internalformat = GL_RG8;
+    if (glamor_priv->is_gles && glamor_priv->has_rg) {
+        glamor_priv->cbcr_format.internalformat = GL_RG;
+    } else {
+        glamor_priv->cbcr_format.internalformat = GL_RG8;
+    }
     glamor_priv->cbcr_format.format = GL_RG;
+    glamor_priv->cbcr_format.render_format = PICT_yuv2;
     glamor_priv->cbcr_format.type = GL_UNSIGNED_BYTE;
     glamor_priv->cbcr_format.rendering_supported = TRUE;
 }
diff --git a/glamor/glamor_priv.h b/glamor/glamor_priv.h
index 028a6d374..da20bc5aa 100644
--- a/glamor/glamor_priv.h
+++ b/glamor/glamor_priv.h
@@ -216,6 +216,7 @@ typedef struct glamor_screen_private {
     Bool has_dual_blend;
     Bool has_clear_texture;
     Bool has_texture_swizzle;
+    Bool has_rg;
     Bool is_core_profile;
     Bool can_copyplane;
     Bool use_gpu_shader4;
diff --git a/render/picture.h b/render/picture.h
index 4499a0021..c3a73d1d8 100644
--- a/render/picture.h
+++ b/render/picture.h
@@ -125,7 +125,10 @@ typedef enum _PictFormatShort {
 /* 1bpp formats */
     PICT_a1 = PIXMAN_a1,
 
-    PICT_g1 = PIXMAN_g1
+    PICT_g1 = PIXMAN_g1,
+
+/* YCbCr formats */
+    PICT_yuv2 = PIXMAN_yuy2
 } PictFormatShort;
 
 /*
-- 
GitLab


From 057f69cdfeffdbd09734664979f75c9c7cccc46c Mon Sep 17 00:00:00 2001
From: Vasily Khoruzhick <anarsoul@gmail.com>
Date: Fri, 27 May 2022 18:00:56 -0700
Subject: [PATCH 6/8] glamor: use dual source blend on GL 2.1 with
 ARB_ES2_compatibility

ARB_blend_func_extended may be exposed even without GLSL 1.30.
In order to use it we need GLES2 shaders that are available if
ARB_ES2_compatibility is exposed.

Signed-off-by: Vasily Khoruzhick <anarsoul@gmail.com>

Reviewed-by: Adam Jackson <ajax@redhat.com>
---
 glamor/glamor.c                  |  6 ++++--
 glamor/glamor_composite_glyphs.c | 20 +++++++++++++++++++-
 glamor/glamor_program.c          | 23 ++++++++++++++++-------
 glamor/glamor_program.h          |  5 +++--
 glamor/glamor_render.c           | 32 ++++++++++++++++++++++++++++----
 5 files changed, 70 insertions(+), 16 deletions(-)

diff --git a/glamor/glamor.c b/glamor/glamor.c
index 1d1727508..42b3461f5 100644
--- a/glamor/glamor.c
+++ b/glamor/glamor.c
@@ -788,8 +788,10 @@ glamor_init(ScreenPtr screen, unsigned int flags)
         epoxy_gl_version() >= 30 ||
         epoxy_has_gl_extension("GL_NV_pack_subimage");
     glamor_priv->has_dual_blend =
-        glamor_glsl_has_ints(glamor_priv) &&
-        epoxy_has_gl_extension("GL_ARB_blend_func_extended");
+        (epoxy_has_gl_extension("GL_ARB_blend_func_extended") &&
+        (glamor_glsl_has_ints(glamor_priv) ||
+        epoxy_has_gl_extension("GL_ARB_ES2_compatibility"))) ||
+        epoxy_has_gl_extension("GL_EXT_blend_func_extended");
     glamor_priv->has_clear_texture =
         epoxy_gl_version() >= 44 ||
         epoxy_has_gl_extension("GL_ARB_clear_texture");
diff --git a/glamor/glamor_composite_glyphs.c b/glamor/glamor_composite_glyphs.c
index 147e3bb31..c69b940d4 100644
--- a/glamor/glamor_composite_glyphs.c
+++ b/glamor/glamor_composite_glyphs.c
@@ -208,6 +208,22 @@ static const glamor_facet glamor_facet_composite_glyphs_120 = {
     .locations = glamor_program_location_atlas,
 };
 
+static const glamor_facet glamor_facet_composite_glyphs_gles2 = {
+    .name = "composite_glyphs",
+    .version = 100,
+    .fs_extensions = ("#extension GL_EXT_blend_func_extended : enable\n"),
+    .vs_vars = ("attribute vec2 primitive;\n"
+                "attribute vec2 source;\n"
+                "varying vec2 glyph_pos;\n"),
+    .vs_exec = ("       vec2 pos = vec2(0,0);\n"
+                GLAMOR_POS(gl_Position, primitive.xy)
+                "       glyph_pos = source.xy * ATLAS_DIM_INV;\n"),
+    .fs_vars = ("varying vec2 glyph_pos;\n"),
+    .fs_exec = ("       vec4 mask = texture2D(atlas, glyph_pos);\n"),
+    .source_name = "source",
+    .locations = glamor_program_location_atlas,
+};
+
 static Bool
 glamor_glyphs_init_facet(ScreenPtr screen)
 {
@@ -442,7 +458,9 @@ glamor_composite_glyphs(CARD8 op,
                         else
                             prog = glamor_setup_program_render(op, src, glyph_pict, dst,
                                                                glyphs_program,
-                                                               &glamor_facet_composite_glyphs_120,
+                                                               glamor_priv->has_dual_blend ?
+                                                                   &glamor_facet_composite_glyphs_gles2 :
+                                                                   &glamor_facet_composite_glyphs_120,
                                                                glamor_priv->glyph_defines);
                         if (!prog)
                             goto bail_one;
diff --git a/glamor/glamor_program.c b/glamor/glamor_program.c
index d8ddb4c77..46a506aaf 100644
--- a/glamor/glamor_program.c
+++ b/glamor/glamor_program.c
@@ -201,6 +201,8 @@ static const char vs_template[] =
 static const char fs_template[] =
     "%s"                                /* version */
     "%s"                                /* exts */
+    "%s"                                /* prim fs_extensions */
+    "%s"                                /* fill fs_extensions */
     GLAMOR_DEFAULT_PRECISION
     "%s"                                /* defines */
     "%s"                                /* prim fs_vars */
@@ -312,6 +314,8 @@ glamor_build_program(ScreenPtr          screen,
     if (asprintf(&fs_prog_string,
                  fs_template,
                  str(version_string),
+                 str(prim->fs_extensions),
+                 str(fill->fs_extensions),
                  gpu_shader4 ? "#extension GL_EXT_gpu_shader4 : require\n#define texelFetch texelFetch2D\n#define uint unsigned int\n" : "",
                  str(defines),
                  str(prim->fs_vars),
@@ -494,7 +498,8 @@ glamor_set_blend(CARD8 op, glamor_program_alpha alpha, PicturePtr dst)
     }
 
     /* Set up the source alpha value for blending in component alpha mode. */
-    if (alpha == glamor_program_alpha_dual_blend) {
+    if (alpha == glamor_program_alpha_dual_blend ||
+        alpha == glamor_program_alpha_dual_blend_gles2) {
         switch (dst_blend) {
         case GL_SRC_ALPHA:
             dst_blend = GL_SRC1_COLOR;
@@ -581,11 +586,13 @@ static const glamor_facet *glamor_facet_source[glamor_program_source_count] = {
 };
 
 static const char *glamor_combine[] = {
-    [glamor_program_alpha_normal]    = "       gl_FragColor = source * mask.a;\n",
-    [glamor_program_alpha_ca_first]  = "       gl_FragColor = source.a * mask;\n",
-    [glamor_program_alpha_ca_second] = "       gl_FragColor = source * mask;\n",
-    [glamor_program_alpha_dual_blend] = "      color0 = source * mask;\n"
-                                        "      color1 = source.a * mask;\n"
+    [glamor_program_alpha_normal]    = "        gl_FragColor = source * mask.a;\n",
+    [glamor_program_alpha_ca_first]  = "        gl_FragColor = source.a * mask;\n",
+    [glamor_program_alpha_ca_second] = "        gl_FragColor = source * mask;\n",
+    [glamor_program_alpha_dual_blend] = "       color0 = source * mask;\n"
+                                        "       color1 = source.a * mask;\n",
+    [glamor_program_alpha_dual_blend_gles2] = " gl_FragColor = source * mask;\n"
+                                              " gl_SecondaryFragColorEXT = source.a * mask;\n"
 };
 
 static Bool
@@ -633,7 +640,9 @@ glamor_setup_program_render(CARD8                 op,
 
     if (glamor_is_component_alpha(mask)) {
         if (glamor_priv->has_dual_blend) {
-            alpha = glamor_program_alpha_dual_blend;
+            alpha = glamor_glsl_has_ints(glamor_priv) ?
+                    glamor_program_alpha_dual_blend :
+                    glamor_program_alpha_dual_blend_gles2;
         } else {
             /* This only works for PictOpOver */
             if (op != PictOpOver)
diff --git a/glamor/glamor_program.h b/glamor/glamor_program.h
index ab6e46f7b..0bd918fff 100644
--- a/glamor/glamor_program.h
+++ b/glamor/glamor_program.h
@@ -44,6 +44,7 @@ typedef enum {
     glamor_program_alpha_ca_first,
     glamor_program_alpha_ca_second,
     glamor_program_alpha_dual_blend,
+    glamor_program_alpha_dual_blend_gles2,
     glamor_program_alpha_count
 } glamor_program_alpha;
 
@@ -56,8 +57,8 @@ typedef Bool (*glamor_use_render) (CARD8 op, PicturePtr src, PicturePtr dst, gla
 typedef struct {
     const char                          *name;
     const int                           version;
-    char                                *vs_defines;
-    char                                *fs_defines;
+    char                                *vs_extensions;
+    const char                          *fs_extensions;
     const char                          *vs_vars;
     const char                          *vs_exec;
     const char                          *fs_vars;
diff --git a/glamor/glamor_render.c b/glamor/glamor_render.c
index 2af65bf93..c9a125ef9 100644
--- a/glamor/glamor_render.c
+++ b/glamor/glamor_render.c
@@ -223,6 +223,15 @@ glamor_create_composite_fs(struct shader_key *key)
         "}\n";
     const char *header_ca_dual_blend =
         "#version 130\n";
+    const char *in_ca_dual_blend_gles2 =
+        "void main()\n"
+        "{\n"
+        "	gl_FragColor = dest_swizzle(get_source() * get_mask());\n"
+        "	gl_SecondaryFragColorEXT = dest_swizzle(get_source().a * get_mask());\n"
+        "}\n";
+    const char *header_ca_dual_blend_gles2 =
+        "#version 100\n"
+        "#extension GL_EXT_blend_func_extended : require\n";
 
     char *source;
     const char *source_fetch;
@@ -294,6 +303,10 @@ glamor_create_composite_fs(struct shader_key *key)
         in = in_ca_dual_blend;
         header = header_ca_dual_blend;
         break;
+    case glamor_program_alpha_dual_blend_gles2:
+        in = in_ca_dual_blend_gles2;
+        header = header_ca_dual_blend_gles2;
+        break;
     default:
         FatalError("Bad composite IN type");
     }
@@ -327,6 +340,8 @@ glamor_create_composite_vs(struct shader_key *key)
     const char *main_closing = "}\n";
     const char *source_coords_setup = "";
     const char *mask_coords_setup = "";
+    const char *version_gles2 = "#version 100\n";
+    const char *version = "";
     char *source;
     GLuint prog;
 
@@ -336,10 +351,15 @@ glamor_create_composite_vs(struct shader_key *key)
     if (key->mask != SHADER_MASK_NONE && key->mask != SHADER_MASK_SOLID)
         mask_coords_setup = mask_coords;
 
+    if (key->in == glamor_program_alpha_dual_blend_gles2)
+        version = version_gles2;
+
     XNFasprintf(&source,
+                "%s"
+                GLAMOR_DEFAULT_PRECISION
                 "%s%s%s%s",
-                main_opening,
-                source_coords_setup, mask_coords_setup, main_closing);
+                version, main_opening, source_coords_setup,
+                mask_coords_setup, main_closing);
 
     prog = glamor_compile_glsl_prog(GL_VERTEX_SHADER, source);
     free(source);
@@ -701,6 +721,7 @@ combine_pict_format(PictFormatShort * des, const PictFormatShort src,
         mask_type = PICT_FORMAT_TYPE(mask);
         break;
     case glamor_program_alpha_dual_blend:
+    case glamor_program_alpha_dual_blend_gles2:
         src_type = PICT_FORMAT_TYPE(src);
         mask_type = PICT_FORMAT_TYPE(mask);
         break;
@@ -886,8 +907,11 @@ glamor_composite_choose_shader(CARD8 op,
         else {
             if (op == PictOpClear)
                 key.mask = SHADER_MASK_NONE;
-            else if (glamor_priv->has_dual_blend)
-                key.in = glamor_program_alpha_dual_blend;
+            else if (glamor_priv->has_dual_blend) {
+                key.in = glamor_glsl_has_ints(glamor_priv) ?
+                    glamor_program_alpha_dual_blend :
+                    glamor_program_alpha_dual_blend_gles2;
+            }
             else if (op == PictOpSrc || op == PictOpAdd
                      || op == PictOpIn || op == PictOpOut
                      || op == PictOpOverReverse)
-- 
GitLab


From 530b165c3361ea34b89eebf7efb8b7a89e7776ba Mon Sep 17 00:00:00 2001
From: Konstantin <ria.freelander@gmail.com>
Date: Tue, 28 Jun 2022 12:28:39 +0300
Subject: [PATCH 7/8] glamor: fix XVideo run with GLES

For now, it sets .version=120, which prevents shader from compiling on ES.
We just force version of shaders to be always 100 on ES, because we use
only 120 shaders on ES anyway, and all shaders works.

Signed-off-by: Konstantin Pugin <ria.freelander@gmail.com>

Reviewed-by: Adam Jackson <ajax@redhat.com>
---
 glamor/glamor_program.c | 5 +++++
 1 file changed, 5 insertions(+)

diff --git a/glamor/glamor_program.c b/glamor/glamor_program.c
index 46a506aaf..f361b726e 100644
--- a/glamor/glamor_program.c
+++ b/glamor/glamor_program.c
@@ -283,6 +283,11 @@ glamor_build_program(ScreenPtr          screen,
             gpu_shader4 = TRUE;
         }
     }
+    /* For now, fix shader version to GLES as 100. We will fall with 130 shaders
+     * in previous check due to forcibly set 120 glsl for GLES. But this patch
+     * makes xv shaders to work */
+    if(version && glamor_priv->is_gles)
+        version = 100;
 
     vs_vars = vs_location_vars(locations);
     fs_vars = fs_location_vars(locations);
-- 
GitLab


From af5d2133b6a1a50eddc5fb28d60d3d5f08d1e7f1 Mon Sep 17 00:00:00 2001
From: Konstantin Pugin <ria.freelander@gmail.com>
Date: Sun, 10 Jul 2022 17:08:44 +0300
Subject: [PATCH 8/8] glamor: do not check framebuffer for GL_ALPHA

GLES2 and only GLES2 does not have any color renderable formats for
depth < 8, but we can use non-renderable GL_ALPHA for glTexImage2D family.
(https://www.khronos.org/registry/OpenGL-Refpages/es2.0/xhtml/glTexImage2D.xml)
For GLES3+ we actually use GL_RED and can check renderability normally.

Fixes #1362

Signed-off-by: Konstantin Pugin <ria.freelander@gmail.com>
---
 glamor/glamor.c | 6 +++++-
 1 file changed, 5 insertions(+), 1 deletion(-)

diff --git a/glamor/glamor.c b/glamor/glamor.c
index 42b3461f5..f3cfd93f4 100644
--- a/glamor/glamor.c
+++ b/glamor/glamor.c
@@ -476,8 +476,12 @@ glamor_add_format(ScreenPtr screen, int depth, CARD32 render_format,
      *
      * Note that we can't just create a pixmap because we're in
      * screeninit.
+     *
+     * GLES2 and only GLES2 does not have any color renderable formats for
+     * depth < 8, but we can use non-renderable GL_ALPHA for glTexImage2D family.
+     * For GLES3+ we actually use GL_RED and can check renderability normally.
      */
-    if (rendering_supported && glamor_priv->is_gles) {
+    if (rendering_supported && glamor_priv->is_gles && format != GL_ALPHA) {
         unsigned fbo, tex;
         int read_format, read_type;
         GLenum status;
-- 
GitLab

