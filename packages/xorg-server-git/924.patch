From d1c177cf214723c646020a75ffb1d578205393d0 Mon Sep 17 00:00:00 2001
From: Konstantin <ria.freelander@gmail.com>
Date: Sat, 25 Jun 2022 21:58:08 +0300
Subject: [PATCH 1/8] meson: add glamor gles2 tests

Signed-off-by: Konstantin Pugin <ria.freelander@gmail.com>

Reviewed-by: Adam Jackson <ajax@redhat.com>
Reviewed-by: Emma Anholt <emma@anholt.net>
---
 test/bugs/bug1354.c                        | 149 +++++++++++++++++++++
 test/bugs/meson.build                      |  51 +++++++
 test/meson.build                           |  58 +++++++-
 test/scripts/xephyr-glamor-gles2-piglit.sh |  34 +++++
 4 files changed, 287 insertions(+), 5 deletions(-)
 create mode 100644 test/bugs/bug1354.c
 create mode 100644 test/bugs/meson.build
 create mode 100755 test/scripts/xephyr-glamor-gles2-piglit.sh

diff --git a/test/bugs/bug1354.c b/test/bugs/bug1354.c
new file mode 100644
index 000000000..edc3f228c
--- /dev/null
+++ b/test/bugs/bug1354.c
@@ -0,0 +1,149 @@
+#include <xcb/xcb.h>
+#include <xcb/xcb_aux.h>
+#include <xcb/xcb_image.h>
+#include <stdint.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <getopt.h>
+#include <ctype.h>
+#include <unistd.h>
+
+/*
+ * This is a test which try to test correct glamor colors when rendered.
+ * It should be run with fullscreen Xephyr (with glamor) with present and with 
+ * etalon high-level Xserver (can be any, on CI - Xvfb). For testing this test
+ * creates an image in Xephyr X server, which filled by one of colors defined in
+ * test_pixels. Then it captures central pixel from both Xephyr and Xserver above.
+ * If pixels differ - test failed. Sleep is used to ensure than presentation on both 
+ * Xephyr and Xvfb kicks (xcb_aux_sync was not enough) and test results will be actual
+ */
+
+#define WIDTH 300
+#define HEIGHT 300
+
+int get_display_pixel(xcb_connection_t* c, xcb_drawable_t win);
+void draw_display_pixel(xcb_connection_t* c, xcb_drawable_t win, uint32_t pixel_color);
+
+int get_display_pixel(xcb_connection_t* c, xcb_drawable_t win)
+{
+	xcb_image_t *image;
+	uint32_t    pixel;
+	int format = XCB_IMAGE_FORMAT_XY_PIXMAP;
+
+	image = xcb_image_get (c, win,
+		 0, 0, WIDTH, HEIGHT,
+		 UINT32_MAX,
+		 format);
+	if (!image) {
+	  printf("xcb_image_get failed: exiting\n");
+	  exit(1);
+	}
+
+	pixel = xcb_image_get_pixel(image, WIDTH/2, HEIGHT/2);
+
+	return pixel;
+}
+
+void draw_display_pixel(xcb_connection_t* c, xcb_drawable_t win, uint32_t pixel_color)
+{
+	xcb_gcontext_t       foreground;
+	uint32_t             mask = 0;
+
+	xcb_rectangle_t rectangles[] = {
+	  {0, 0, WIDTH, HEIGHT},
+	};
+
+	foreground = xcb_generate_id (c);
+	mask = XCB_GC_FOREGROUND | XCB_GC_LINE_WIDTH | XCB_GC_SUBWINDOW_MODE;
+
+	uint32_t values[] = {
+		pixel_color,
+		20,
+		XCB_SUBWINDOW_MODE_INCLUDE_INFERIORS
+	};
+
+	xcb_create_gc (c, foreground, win, mask, values);
+
+	xcb_poly_fill_rectangle (c, win, foreground, 1, rectangles);
+	xcb_aux_sync ( c );
+}
+
+
+int main(int argc, char* argv[])
+{
+	xcb_connection_t    *c, *r;
+	xcb_screen_t        *screen1, *screen2;
+	xcb_drawable_t       win1, win2;
+    char *name_test = NULL, *name_relevant = NULL;
+	uint32_t pixel_server1, pixel_server2;
+	int result = 0;
+	uint32_t test_pixels[3] = {0xff0000, 0x00ff00, 0x0000ff};
+	int gv;
+
+	while ((gv = getopt (argc, argv, "t:r:")) != -1)
+	switch (gv)
+	  {
+	  case 't':
+		name_test = optarg;
+		break;
+	  case 'r':
+		name_relevant = optarg;
+		break;
+	  case '?':
+		if (optopt == 't' || optopt == 'r')
+		  fprintf (stderr, "Option -%c requires an argument - test screen name.\n", optopt);
+		else if (isprint (optopt))
+		  fprintf (stderr, "Unknown option `-%c'.\n", optopt);
+		else
+		  fprintf (stderr,
+		           "Unknown option character `\\x%x'.\n",
+		           optopt);
+		return 1;
+	  default:
+		abort ();
+	  }
+
+	printf("test=%s, rel=%s\n", name_test, name_relevant);
+
+	c = xcb_connect (name_test, NULL);
+	r = xcb_connect (name_relevant, NULL);
+
+	/* get the first screen */
+	screen1 = xcb_setup_roots_iterator (xcb_get_setup (c)).data;
+
+    win1 = xcb_generate_id (c);
+    xcb_create_window (c,                    /* Connection          */
+                       XCB_COPY_FROM_PARENT,          /* depth (same as root)*/
+                       win1,                        /* window Id           */
+                       screen1->root,                  /* parent window       */
+                       0, 0,                          /* x, y                */
+                       WIDTH, HEIGHT,                /* width, height       */
+                       20,                            /* border_width        */
+                       XCB_WINDOW_CLASS_INPUT_OUTPUT, /* class               */
+                       screen1->root_visual,           /* visual              */
+                       0, NULL );                     /* masks, not used yet */
+
+
+    /* Map the window on the screen */
+    xcb_map_window (c, win1);
+    xcb_aux_sync(c);
+
+	/* get the first screen */
+	screen2 = xcb_setup_roots_iterator (xcb_get_setup (r)).data;
+
+	/* root window */
+	win2 = screen2->root;
+
+	for(int i = 0; i < 3; i++)
+	{
+		draw_display_pixel(c, win1, test_pixels[i]);
+		xcb_aux_sync(r);
+		pixel_server1 = get_display_pixel(c, win1);
+		sleep(1);
+		pixel_server2 = get_display_pixel(r, win2);
+		xcb_aux_sync(r);
+		printf("p=0x%x, p2=0x%x\n", pixel_server1, pixel_server2);
+		result+= pixel_server1 == pixel_server2;
+	}
+	return result == 3 ? 0 : 1;
+}
diff --git a/test/bugs/meson.build b/test/bugs/meson.build
new file mode 100644
index 000000000..1f5305f56
--- /dev/null
+++ b/test/bugs/meson.build
@@ -0,0 +1,51 @@
+xcb_dep = dependency('xcb', required: false)
+xcb_image_dep = dependency('xcb-image', required: false)
+xcb_util_dep = dependency('xcb-util', required: false)
+
+if get_option('xvfb')
+    xvfb_args = [
+        xvfb_server.full_path(),
+        '-screen',
+        'scrn',
+        '1280x1024x24'
+    ]
+
+    if xcb_dep.found() and xcb_image_dep.found() and xcb_util_dep.found() and get_option('xvfb') and get_option('xephyr') and build_glamor
+        bug1354 = executable('bug1354', 'bug1354.c', dependencies: [xcb_dep, xcb_image_dep, xcb_util_dep])
+        test('bug1354-gl',
+                simple_xinit,
+                args: [simple_xinit.full_path(),
+                    bug1354.full_path(),
+                    '-t',':201','-r',':200',
+                    '----',
+                    xephyr_server.full_path(),
+                    '-glamor',
+                    '-schedMax', '2000',
+                    ':201',
+                    '--',
+                    xvfb_args,
+                    ':200'
+                    ],
+                suite: 'xephyr-glamor',
+                timeout: 300,
+            )
+        test('bug1354-gles',
+                simple_xinit,
+                args: [simple_xinit.full_path(),
+                    bug1354.full_path(),
+                    '-t',':199','-r',':198',
+                    '----',
+                    xephyr_server.full_path(),
+                    '-glamor_gles2',
+                    '-schedMax', '2000',
+                    ':199',
+                    '--',
+                    xvfb_args,
+                    ':198'
+                    ],
+                suite: 'xephyr-glamor-gles2',
+                timeout: 300,
+                should_fail: true,
+            )
+    endif
+endif
\ No newline at end of file
diff --git a/test/meson.build b/test/meson.build
index a8d9e8497..662eee4ef 100644
--- a/test/meson.build
+++ b/test/meson.build
@@ -9,13 +9,24 @@ piglit_env.set('XSERVER_DIR', meson.source_root())
 piglit_env.set('XSERVER_BUILDDIR', meson.build_root())
 
 some_ops = ' -o clear,src,dst,over,xor,disjointover'
-rendercheck_tests = [
+gles2_working_formats = ' -f '+ ','.join(['a8',
+                                          'a8r8g8b8',
+                                          'x8r8g8b8',
+                                          'b8g8r8a8',
+                                          'b8g8r8x8',
+                                          'r8g8b8',
+                                          'r5g5b5',
+                                          'b5g5r5',
+                                          'r5g6b5',
+                                          'b5g6r5',
+                                          'b8g8r8',
+                                          'x8b8g8r8',
+                                          'x2r10g10b10',
+                                          'x2b10g10r10'])
+rendercheck_tests_noblend = [
     ['blend/All/a8r8g8b8', '-t blend -f a8r8g8b8'],
     ['blend/All/x8r8g8b8', '-t blend -f a8r8g8b8,x8r8g8b8'],
     ['blend/All/a2r10g10b10', '-t blend -f a8r8g8b8,a2r10g10b10'],
-    ['blend/Clear', '-t blend -o clear'],
-    ['blend/Src', '-t blend -o src'],
-    ['blend/Over', '-t blend -o over'],
     ['composite/Some/a8r8g8b8', '-t composite -f a8r8g8b8' + some_ops],
     ['composite/Some/x8r8g8b8', '-t composite -f a8r8g8b8,x8r8g8b8' + some_ops],
     ['composite/Some/a2r10g10b10', '-t composite -f a8r8g8b8,a2r10g10b10' + some_ops],
@@ -34,7 +45,19 @@ rendercheck_tests = [
     ['LibreOffice xRGB', '-t libreoffice_xrgb'],
     ['GTK ARGB vs xBGR', '-t gtk_argb_xbgr'],
 ]
-
+rendercheck_blend = [
+    ['blend/Clear', '-t blend -o clear'],
+    ['blend/Src', '-t blend -o src'],
+    ['blend/Over', '-t blend -o over'],
+]
+#Exclude 15bpp for now due to GLES limitation (see glamor.c:470)
+rendercheck_blend_gles2 = [
+    ['blend/Clear', '-t blend -o clear' + gles2_working_formats],
+    ['blend/Src', '-t blend -o src' + gles2_working_formats],
+    ['blend/Over', '-t blend -o over' + gles2_working_formats],
+]
+rendercheck_tests = rendercheck_blend + rendercheck_tests_noblend
+rendercheck_tests_gles2 = rendercheck_blend_gles2 + rendercheck_tests_noblend
 rendercheck = find_program('rendercheck', required:false)
 
 if get_option('xvfb')
@@ -76,6 +99,12 @@ if get_option('xvfb')
             timeout: 1200,
             suite: 'xephyr-glamor',
         )
+        test('XTS',
+            find_program('scripts/xephyr-glamor-gles2-piglit.sh'),
+            env: piglit_env,
+            timeout: 1200,
+            suite: 'xephyr-glamor-gles2',
+        )
 
         if rendercheck.found()
             foreach rctest: rendercheck_tests
@@ -96,6 +125,24 @@ if get_option('xvfb')
                      timeout: 300,
                     )
             endforeach
+            foreach rctest: rendercheck_tests_gles2
+                test(rctest[0],
+                     simple_xinit,
+                     args: [simple_xinit.full_path(),
+                            rendercheck.path(),
+                            rctest[1].split(' '),
+                            '----',
+                            xephyr_server.full_path(),
+                            '-glamor_gles2',
+                            '-glamor-skip-present',
+                            '-schedMax', '2000',
+                            '--',
+                            xvfb_args,
+                           ],
+                     suite: 'xephyr-glamor-gles2',
+                     timeout: 300,
+                    )
+            endforeach
         endif
     endif
 endif
@@ -116,6 +163,7 @@ endif
 subdir('bigreq')
 subdir('damage')
 subdir('sync')
+subdir('bugs')
 
 if build_xorg
 # Tests that require at least some DDX functions in order to fully link
diff --git a/test/scripts/xephyr-glamor-gles2-piglit.sh b/test/scripts/xephyr-glamor-gles2-piglit.sh
new file mode 100755
index 000000000..59ca12d26
--- /dev/null
+++ b/test/scripts/xephyr-glamor-gles2-piglit.sh
@@ -0,0 +1,34 @@
+#!/bin/sh
+
+# this times out on Travis, because the tests take too long.
+if test "x$TRAVIS_BUILD_DIR" != "x"; then
+    exit 77
+fi
+
+# Start a Xephyr server using glamor.  Since the test environment is
+# headless, we start an Xvfb first to host the Xephyr.
+export PIGLIT_RESULTS_DIR=$XSERVER_BUILDDIR/test/piglit-results/xephyr-glamor-gles2
+
+export SERVER_COMMAND="$XSERVER_BUILDDIR/hw/kdrive/ephyr/Xephyr \
+        -glamor_gles2 \
+        -glamor-skip-present \
+        -noreset \
+        -schedMax 2000 \
+        -screen 1280x1024"
+
+# Tests that currently fail on llvmpipe on CI
+PIGLIT_ARGS="$PIGLIT_ARGS -x xcleararea@6"
+PIGLIT_ARGS="$PIGLIT_ARGS -x xcleararea@7"
+PIGLIT_ARGS="$PIGLIT_ARGS -x xclearwindow@4"
+PIGLIT_ARGS="$PIGLIT_ARGS -x xclearwindow@5"
+PIGLIT_ARGS="$PIGLIT_ARGS -x xcopyarea@1"
+PIGLIT_ARGS="$PIGLIT_ARGS -x xsetfontpath@1"
+PIGLIT_ARGS="$PIGLIT_ARGS -x xsetfontpath@2"
+
+export PIGLIT_ARGS
+
+$XSERVER_BUILDDIR/test/simple-xinit \
+        $XSERVER_DIR/test/scripts/run-piglit.sh \
+        -- \
+        $XSERVER_BUILDDIR/hw/vfb/Xvfb \
+        -screen scrn 1280x1024x24
-- 
GitLab


From 953b76f1a2db4d9637cd74082c953f26b1705f84 Mon Sep 17 00:00:00 2001
From: Konstantin <ria.freelander@gmail.com>
Date: Sun, 26 Jun 2022 00:01:54 +0300
Subject: [PATCH 2/8] glamor: make use of GL_EXT_texture_format_BGRA8888

For 24 and 32 bit depth pictures xserver uses PICT_x8r8g8b8 and PICT_a8r8g8b8 formats,
which must be backed with GL_BGRA format. It is present in OpenGL ES 2.0 only with
GL_EXT_texture_format_BGRA8888 extension. We require such extension in glamor_init,
so, why not to make use of it?
Fixes #1208
Fixes #1354

Signed-off-by: Konstantin Pugin <ria.freelander@gmail.com>

Reviewed-by: Adam Jackson <ajax@redhat.com>
Reviewed-by: Emma Anholt <emma@anholt.net>
---
 glamor/glamor.c         | 8 ++++----
 glamor/glamor_picture.c | 7 ++-----
 test/bugs/meson.build   | 1 -
 3 files changed, 6 insertions(+), 10 deletions(-)

diff --git a/glamor/glamor.c b/glamor/glamor.c
index 9dcef5fac..0a757db35 100644
--- a/glamor/glamor.c
+++ b/glamor/glamor.c
@@ -586,10 +586,10 @@ glamor_setup_formats(ScreenPtr screen)
 
     if (glamor_priv->is_gles) {
         assert(X_BYTE_ORDER == X_LITTLE_ENDIAN);
-        glamor_add_format(screen, 24, PICT_x8b8g8r8,
-                          GL_RGBA8, GL_RGBA, GL_UNSIGNED_BYTE, TRUE);
-        glamor_add_format(screen, 32, PICT_a8b8g8r8,
-                          GL_RGBA8, GL_RGBA, GL_UNSIGNED_BYTE, TRUE);
+        glamor_add_format(screen, 24, PICT_x8r8g8b8,
+                          GL_BGRA, GL_BGRA, GL_UNSIGNED_BYTE, TRUE);
+        glamor_add_format(screen, 32, PICT_a8r8g8b8,
+                          GL_BGRA, GL_BGRA, GL_UNSIGNED_BYTE, TRUE);
     } else {
         glamor_add_format(screen, 24, PICT_x8r8g8b8,
                           GL_RGBA, GL_BGRA, GL_UNSIGNED_INT_8_8_8_8_REV, TRUE);
diff --git a/glamor/glamor_picture.c b/glamor/glamor_picture.c
index 33b3bebd9..2152b85e1 100644
--- a/glamor/glamor_picture.c
+++ b/glamor/glamor_picture.c
@@ -94,7 +94,7 @@ glamor_get_tex_format_type_from_pictformat(ScreenPtr pScreen,
             *tex_format = GL_BGRA;
             *tex_type = GL_UNSIGNED_INT_8_8_8_8;
         } else {
-            *tex_format = GL_RGBA;
+            *tex_format = GL_BGRA;
             *tex_type = GL_UNSIGNED_BYTE;
 
             swizzle[0] = GL_GREEN;
@@ -113,12 +113,9 @@ glamor_get_tex_format_type_from_pictformat(ScreenPtr pScreen,
             *tex_format = GL_BGRA;
             *tex_type = GL_UNSIGNED_INT_8_8_8_8_REV;
         } else {
-            *tex_format = GL_RGBA;
+            *tex_format = GL_BGRA;
             *tex_type = GL_UNSIGNED_BYTE;
 
-            swizzle[0] = GL_BLUE;
-            swizzle[2] = GL_RED;
-
             if (!is_little_endian)
                 byte_swap_swizzle(swizzle);
             break;
diff --git a/test/bugs/meson.build b/test/bugs/meson.build
index 1f5305f56..470706d56 100644
--- a/test/bugs/meson.build
+++ b/test/bugs/meson.build
@@ -45,7 +45,6 @@ if get_option('xvfb')
                     ],
                 suite: 'xephyr-glamor-gles2',
                 timeout: 300,
-                should_fail: true,
             )
     endif
 endif
\ No newline at end of file
-- 
GitLab


From 511eed5a72d5bc12dbef758d833e657d44a618b3 Mon Sep 17 00:00:00 2001
From: Konstantin <ria.freelander@gmail.com>
Date: Sat, 25 Jun 2022 17:51:15 +0300
Subject: [PATCH 3/8] glamor: transpose gradients transparently

glUniformMatrix3fv is used with argument transpose set to GL_TRUE.
According to the Khronos OpenGL ES 2.0 pages transpose must be GL_FALSE.
Actually we can just return transformed matrix from
_glamor_gradient_convert_trans_matrix (@anholt suggest),
so @uvas workaround is not required

Signed-off-by: Konstantin Pugin <ria.freelander@gmail.com>

Reviewed-by: Adam Jackson <ajax@redhat.com>
Reviewed-by: Emma Anholt <emma@anholt.net>
---
 glamor/glamor_gradient.c | 32 +++++++++++++++++++++-----------
 1 file changed, 21 insertions(+), 11 deletions(-)

diff --git a/glamor/glamor_gradient.c b/glamor/glamor_gradient.c
index 7e5d5cca9..4c7ae4d77 100644
--- a/glamor/glamor_gradient.c
+++ b/glamor/glamor_gradient.c
@@ -605,27 +605,35 @@ _glamor_gradient_convert_trans_matrix(PictTransform *from, float to[3][3],
      * T_s = | w*t21/h  t22      t23/h|
      *       | w*t31    h*t32    t33  |
      *       --                      --
+     *
+     * Because GLES2 cannot do trasposed mat by spec, we did transposing inside this function
+     * already, and matrix becoming look like this:
+     *       --                      --
+     *       | t11      w*t21/h  t31*w|
+     * T_s = | h*t12/w  t22      t32*h|
+     *       | t13/w    t23/h    t33  |
+     *       --                      --
      */
 
     to[0][0] = (float) pixman_fixed_to_double(from->matrix[0][0]);
-    to[0][1] = (float) pixman_fixed_to_double(from->matrix[0][1])
+    to[1][0] = (float) pixman_fixed_to_double(from->matrix[0][1])
         * (normalize ? (((float) height) / ((float) width)) : 1.0);
-    to[0][2] = (float) pixman_fixed_to_double(from->matrix[0][2])
+    to[2][0] = (float) pixman_fixed_to_double(from->matrix[0][2])
         / (normalize ? ((float) width) : 1.0);
 
-    to[1][0] = (float) pixman_fixed_to_double(from->matrix[1][0])
+    to[0][1] = (float) pixman_fixed_to_double(from->matrix[1][0])
         * (normalize ? (((float) width) / ((float) height)) : 1.0);
     to[1][1] = (float) pixman_fixed_to_double(from->matrix[1][1]);
-    to[1][2] = (float) pixman_fixed_to_double(from->matrix[1][2])
+    to[2][1] = (float) pixman_fixed_to_double(from->matrix[1][2])
         / (normalize ? ((float) height) : 1.0);
 
-    to[2][0] = (float) pixman_fixed_to_double(from->matrix[2][0])
+    to[0][2] = (float) pixman_fixed_to_double(from->matrix[2][0])
         * (normalize ? ((float) width) : 1.0);
-    to[2][1] = (float) pixman_fixed_to_double(from->matrix[2][1])
+    to[1][2] = (float) pixman_fixed_to_double(from->matrix[2][1])
         * (normalize ? ((float) height) : 1.0);
     to[2][2] = (float) pixman_fixed_to_double(from->matrix[2][2]);
 
-    DEBUGF("the transform matrix is:\n%f\t%f\t%f\n%f\t%f\t%f\n%f\t%f\t%f\n",
+    DEBUGF("the transposed transform matrix is:\n%f\t%f\t%f\n%f\t%f\t%f\n%f\t%f\t%f\n",
            to[0][0], to[0][1], to[0][2],
            to[1][0], to[1][1], to[1][2], to[2][0], to[2][1], to[2][2]);
 }
@@ -950,11 +958,12 @@ glamor_generate_radial_gradient_picture(ScreenPtr screen,
         _glamor_gradient_convert_trans_matrix(src_picture->transform,
                                               transform_mat, width, height, 0);
         glUniformMatrix3fv(transform_mat_uniform_location,
-                           1, 1, &transform_mat[0][0]);
+                           1, GL_FALSE, &transform_mat[0][0]);
     }
     else {
+        /* identity matrix dont need to be transposed */
         glUniformMatrix3fv(transform_mat_uniform_location,
-                           1, 1, &identity_mat[0][0]);
+                           1, GL_FALSE, &identity_mat[0][0]);
     }
 
     if (!_glamor_gradient_set_pixmap_destination
@@ -1266,11 +1275,12 @@ glamor_generate_linear_gradient_picture(ScreenPtr screen,
         _glamor_gradient_convert_trans_matrix(src_picture->transform,
                                               transform_mat, width, height, 1);
         glUniformMatrix3fv(transform_mat_uniform_location,
-                           1, 1, &transform_mat[0][0]);
+                           1, GL_FALSE, &transform_mat[0][0]);
     }
     else {
+        /* identity matrix dont need to be transposed */
         glUniformMatrix3fv(transform_mat_uniform_location,
-                           1, 1, &identity_mat[0][0]);
+                           1, GL_FALSE, &identity_mat[0][0]);
     }
 
     if (!_glamor_gradient_set_pixmap_destination
-- 
GitLab


From b1ea8f3023140f657a228e129fad977a0da0f8f4 Mon Sep 17 00:00:00 2001
From: Yuriy <uuvasiliev@yandex.ru>
Date: Thu, 16 Sep 2021 14:47:44 +0300
Subject: [PATCH 4/8] glamor: fix CbCr format handling

In GLES2, we cannot do GL_RED or GL_RG without GL_EXT_texture_rg.
So, add check for GL_EXT_texture_rg to make it working. Also add
a yuv2 pixman format into render.h to make Xv yuv rendering works.

Signed-off-by: Yuriy Vasilev <uuvasiliev@yandex.ru>

Reviewed-by: Adam Jackson <ajax@redhat.com>
Reviewed-by: Emma Anholt <emma@anholt.net>
---
 glamor/glamor.c      | 19 +++++++++++++++----
 glamor/glamor_priv.h |  1 +
 render/picture.h     |  5 ++++-
 3 files changed, 20 insertions(+), 5 deletions(-)

diff --git a/glamor/glamor.c b/glamor/glamor.c
index 0a757db35..c6bb01d8e 100644
--- a/glamor/glamor.c
+++ b/glamor/glamor.c
@@ -223,7 +223,7 @@ glamor_create_pixmap(ScreenPtr screen, int w, int h, int depth,
 
     pixmap_priv = glamor_get_pixmap_private(pixmap);
 
-    pixmap_priv->is_cbcr = (usage == GLAMOR_CREATE_FORMAT_CBCR);
+    pixmap_priv->is_cbcr = (GLAMOR_CREATE_FORMAT_CBCR & usage) == GLAMOR_CREATE_FORMAT_CBCR;
 
     pitch = (((w * pixmap->drawable.bitsPerPixel + 7) / 8) + 3) & ~3;
     screen->ModifyPixmapHeader(pixmap, w, h, 0, 0, pitch, NULL);
@@ -550,9 +550,10 @@ glamor_setup_formats(ScreenPtr screen)
     glamor_screen_private *glamor_priv = glamor_get_screen_private(screen);
 
     /* Prefer r8 textures since they're required by GLES3 and core,
-     * only falling back to a8 if we can't do them.
+     * only falling back to a8 if we can't do them. We cannot do them
+     * on GLES2 due to lack of texture swizzle.
      */
-    if (glamor_priv->is_gles || epoxy_has_gl_extension("GL_ARB_texture_rg")) {
+    if (glamor_priv->has_rg && glamor_priv->has_texture_swizzle) {
         glamor_add_format(screen, 1, PICT_a1,
                           GL_R8, GL_RED, GL_UNSIGNED_BYTE, FALSE);
         glamor_add_format(screen, 8, PICT_a8,
@@ -606,8 +607,13 @@ glamor_setup_formats(ScreenPtr screen)
     }
 
     glamor_priv->cbcr_format.depth = 16;
-    glamor_priv->cbcr_format.internalformat = GL_RG8;
+    if (glamor_priv->is_gles && glamor_priv->has_rg) {
+        glamor_priv->cbcr_format.internalformat = GL_RG;
+    } else {
+        glamor_priv->cbcr_format.internalformat = GL_RG8;
+    }
     glamor_priv->cbcr_format.format = GL_RG;
+    glamor_priv->cbcr_format.render_format = PICT_yuv2;
     glamor_priv->cbcr_format.type = GL_UNSIGNED_BYTE;
     glamor_priv->cbcr_format.rendering_supported = TRUE;
 }
@@ -787,6 +793,11 @@ glamor_init(ScreenPtr screen, unsigned int flags)
     glamor_priv->has_clear_texture =
         epoxy_gl_version() >= 44 ||
         epoxy_has_gl_extension("GL_ARB_clear_texture");
+    /* GL_EXT_texture_rg is part of GLES3 core */
+    glamor_priv->has_rg =
+        (glamor_priv->is_gles && epoxy_gl_version() >= 30) ||
+        epoxy_has_gl_extension("GL_EXT_texture_rg") ||
+        epoxy_has_gl_extension("GL_ARB_texture_rg");
 
     glamor_priv->can_copyplane = (gl_version >= 30);
 
diff --git a/glamor/glamor_priv.h b/glamor/glamor_priv.h
index 028a6d374..da20bc5aa 100644
--- a/glamor/glamor_priv.h
+++ b/glamor/glamor_priv.h
@@ -216,6 +216,7 @@ typedef struct glamor_screen_private {
     Bool has_dual_blend;
     Bool has_clear_texture;
     Bool has_texture_swizzle;
+    Bool has_rg;
     Bool is_core_profile;
     Bool can_copyplane;
     Bool use_gpu_shader4;
diff --git a/render/picture.h b/render/picture.h
index 4499a0021..c3a73d1d8 100644
--- a/render/picture.h
+++ b/render/picture.h
@@ -125,7 +125,10 @@ typedef enum _PictFormatShort {
 /* 1bpp formats */
     PICT_a1 = PIXMAN_a1,
 
-    PICT_g1 = PIXMAN_g1
+    PICT_g1 = PIXMAN_g1,
+
+/* YCbCr formats */
+    PICT_yuv2 = PIXMAN_yuy2
 } PictFormatShort;
 
 /*
-- 
GitLab


From 526d8ce8de0d4c45b53c467ec2ccb6483df10d75 Mon Sep 17 00:00:00 2001
From: Vasily Khoruzhick <anarsoul@gmail.com>
Date: Fri, 27 May 2022 18:00:56 -0700
Subject: [PATCH 5/8] glamor: use dual source blend on GL 2.1 with
 ARB_ES2_compatibility

ARB_blend_func_extended may be exposed even without GLSL 1.30.
In order to use it we need GLES2 shaders that are available if
ARB_ES2_compatibility is exposed.

Signed-off-by: Vasily Khoruzhick <anarsoul@gmail.com>

Reviewed-by: Adam Jackson <ajax@redhat.com>
Reviewed-by: Emma Anholt <emma@anholt.net>
---
 glamor/glamor.c                  |  6 ++++--
 glamor/glamor_composite_glyphs.c | 20 +++++++++++++++++++-
 glamor/glamor_program.c          | 23 ++++++++++++++++-------
 glamor/glamor_program.h          |  5 +++--
 glamor/glamor_render.c           | 32 ++++++++++++++++++++++++++++----
 5 files changed, 70 insertions(+), 16 deletions(-)

diff --git a/glamor/glamor.c b/glamor/glamor.c
index c6bb01d8e..f15b5a18a 100644
--- a/glamor/glamor.c
+++ b/glamor/glamor.c
@@ -788,8 +788,10 @@ glamor_init(ScreenPtr screen, unsigned int flags)
         epoxy_gl_version() >= 30 ||
         epoxy_has_gl_extension("GL_NV_pack_subimage");
     glamor_priv->has_dual_blend =
-        glamor_glsl_has_ints(glamor_priv) &&
-        epoxy_has_gl_extension("GL_ARB_blend_func_extended");
+        (epoxy_has_gl_extension("GL_ARB_blend_func_extended") &&
+        (glamor_glsl_has_ints(glamor_priv) ||
+        epoxy_has_gl_extension("GL_ARB_ES2_compatibility"))) ||
+        epoxy_has_gl_extension("GL_EXT_blend_func_extended");
     glamor_priv->has_clear_texture =
         epoxy_gl_version() >= 44 ||
         epoxy_has_gl_extension("GL_ARB_clear_texture");
diff --git a/glamor/glamor_composite_glyphs.c b/glamor/glamor_composite_glyphs.c
index 147e3bb31..c69b940d4 100644
--- a/glamor/glamor_composite_glyphs.c
+++ b/glamor/glamor_composite_glyphs.c
@@ -208,6 +208,22 @@ static const glamor_facet glamor_facet_composite_glyphs_120 = {
     .locations = glamor_program_location_atlas,
 };
 
+static const glamor_facet glamor_facet_composite_glyphs_gles2 = {
+    .name = "composite_glyphs",
+    .version = 100,
+    .fs_extensions = ("#extension GL_EXT_blend_func_extended : enable\n"),
+    .vs_vars = ("attribute vec2 primitive;\n"
+                "attribute vec2 source;\n"
+                "varying vec2 glyph_pos;\n"),
+    .vs_exec = ("       vec2 pos = vec2(0,0);\n"
+                GLAMOR_POS(gl_Position, primitive.xy)
+                "       glyph_pos = source.xy * ATLAS_DIM_INV;\n"),
+    .fs_vars = ("varying vec2 glyph_pos;\n"),
+    .fs_exec = ("       vec4 mask = texture2D(atlas, glyph_pos);\n"),
+    .source_name = "source",
+    .locations = glamor_program_location_atlas,
+};
+
 static Bool
 glamor_glyphs_init_facet(ScreenPtr screen)
 {
@@ -442,7 +458,9 @@ glamor_composite_glyphs(CARD8 op,
                         else
                             prog = glamor_setup_program_render(op, src, glyph_pict, dst,
                                                                glyphs_program,
-                                                               &glamor_facet_composite_glyphs_120,
+                                                               glamor_priv->has_dual_blend ?
+                                                                   &glamor_facet_composite_glyphs_gles2 :
+                                                                   &glamor_facet_composite_glyphs_120,
                                                                glamor_priv->glyph_defines);
                         if (!prog)
                             goto bail_one;
diff --git a/glamor/glamor_program.c b/glamor/glamor_program.c
index d8ddb4c77..46a506aaf 100644
--- a/glamor/glamor_program.c
+++ b/glamor/glamor_program.c
@@ -201,6 +201,8 @@ static const char vs_template[] =
 static const char fs_template[] =
     "%s"                                /* version */
     "%s"                                /* exts */
+    "%s"                                /* prim fs_extensions */
+    "%s"                                /* fill fs_extensions */
     GLAMOR_DEFAULT_PRECISION
     "%s"                                /* defines */
     "%s"                                /* prim fs_vars */
@@ -312,6 +314,8 @@ glamor_build_program(ScreenPtr          screen,
     if (asprintf(&fs_prog_string,
                  fs_template,
                  str(version_string),
+                 str(prim->fs_extensions),
+                 str(fill->fs_extensions),
                  gpu_shader4 ? "#extension GL_EXT_gpu_shader4 : require\n#define texelFetch texelFetch2D\n#define uint unsigned int\n" : "",
                  str(defines),
                  str(prim->fs_vars),
@@ -494,7 +498,8 @@ glamor_set_blend(CARD8 op, glamor_program_alpha alpha, PicturePtr dst)
     }
 
     /* Set up the source alpha value for blending in component alpha mode. */
-    if (alpha == glamor_program_alpha_dual_blend) {
+    if (alpha == glamor_program_alpha_dual_blend ||
+        alpha == glamor_program_alpha_dual_blend_gles2) {
         switch (dst_blend) {
         case GL_SRC_ALPHA:
             dst_blend = GL_SRC1_COLOR;
@@ -581,11 +586,13 @@ static const glamor_facet *glamor_facet_source[glamor_program_source_count] = {
 };
 
 static const char *glamor_combine[] = {
-    [glamor_program_alpha_normal]    = "       gl_FragColor = source * mask.a;\n",
-    [glamor_program_alpha_ca_first]  = "       gl_FragColor = source.a * mask;\n",
-    [glamor_program_alpha_ca_second] = "       gl_FragColor = source * mask;\n",
-    [glamor_program_alpha_dual_blend] = "      color0 = source * mask;\n"
-                                        "      color1 = source.a * mask;\n"
+    [glamor_program_alpha_normal]    = "        gl_FragColor = source * mask.a;\n",
+    [glamor_program_alpha_ca_first]  = "        gl_FragColor = source.a * mask;\n",
+    [glamor_program_alpha_ca_second] = "        gl_FragColor = source * mask;\n",
+    [glamor_program_alpha_dual_blend] = "       color0 = source * mask;\n"
+                                        "       color1 = source.a * mask;\n",
+    [glamor_program_alpha_dual_blend_gles2] = " gl_FragColor = source * mask;\n"
+                                              " gl_SecondaryFragColorEXT = source.a * mask;\n"
 };
 
 static Bool
@@ -633,7 +640,9 @@ glamor_setup_program_render(CARD8                 op,
 
     if (glamor_is_component_alpha(mask)) {
         if (glamor_priv->has_dual_blend) {
-            alpha = glamor_program_alpha_dual_blend;
+            alpha = glamor_glsl_has_ints(glamor_priv) ?
+                    glamor_program_alpha_dual_blend :
+                    glamor_program_alpha_dual_blend_gles2;
         } else {
             /* This only works for PictOpOver */
             if (op != PictOpOver)
diff --git a/glamor/glamor_program.h b/glamor/glamor_program.h
index ab6e46f7b..0bd918fff 100644
--- a/glamor/glamor_program.h
+++ b/glamor/glamor_program.h
@@ -44,6 +44,7 @@ typedef enum {
     glamor_program_alpha_ca_first,
     glamor_program_alpha_ca_second,
     glamor_program_alpha_dual_blend,
+    glamor_program_alpha_dual_blend_gles2,
     glamor_program_alpha_count
 } glamor_program_alpha;
 
@@ -56,8 +57,8 @@ typedef Bool (*glamor_use_render) (CARD8 op, PicturePtr src, PicturePtr dst, gla
 typedef struct {
     const char                          *name;
     const int                           version;
-    char                                *vs_defines;
-    char                                *fs_defines;
+    char                                *vs_extensions;
+    const char                          *fs_extensions;
     const char                          *vs_vars;
     const char                          *vs_exec;
     const char                          *fs_vars;
diff --git a/glamor/glamor_render.c b/glamor/glamor_render.c
index 2af65bf93..c9a125ef9 100644
--- a/glamor/glamor_render.c
+++ b/glamor/glamor_render.c
@@ -223,6 +223,15 @@ glamor_create_composite_fs(struct shader_key *key)
         "}\n";
     const char *header_ca_dual_blend =
         "#version 130\n";
+    const char *in_ca_dual_blend_gles2 =
+        "void main()\n"
+        "{\n"
+        "	gl_FragColor = dest_swizzle(get_source() * get_mask());\n"
+        "	gl_SecondaryFragColorEXT = dest_swizzle(get_source().a * get_mask());\n"
+        "}\n";
+    const char *header_ca_dual_blend_gles2 =
+        "#version 100\n"
+        "#extension GL_EXT_blend_func_extended : require\n";
 
     char *source;
     const char *source_fetch;
@@ -294,6 +303,10 @@ glamor_create_composite_fs(struct shader_key *key)
         in = in_ca_dual_blend;
         header = header_ca_dual_blend;
         break;
+    case glamor_program_alpha_dual_blend_gles2:
+        in = in_ca_dual_blend_gles2;
+        header = header_ca_dual_blend_gles2;
+        break;
     default:
         FatalError("Bad composite IN type");
     }
@@ -327,6 +340,8 @@ glamor_create_composite_vs(struct shader_key *key)
     const char *main_closing = "}\n";
     const char *source_coords_setup = "";
     const char *mask_coords_setup = "";
+    const char *version_gles2 = "#version 100\n";
+    const char *version = "";
     char *source;
     GLuint prog;
 
@@ -336,10 +351,15 @@ glamor_create_composite_vs(struct shader_key *key)
     if (key->mask != SHADER_MASK_NONE && key->mask != SHADER_MASK_SOLID)
         mask_coords_setup = mask_coords;
 
+    if (key->in == glamor_program_alpha_dual_blend_gles2)
+        version = version_gles2;
+
     XNFasprintf(&source,
+                "%s"
+                GLAMOR_DEFAULT_PRECISION
                 "%s%s%s%s",
-                main_opening,
-                source_coords_setup, mask_coords_setup, main_closing);
+                version, main_opening, source_coords_setup,
+                mask_coords_setup, main_closing);
 
     prog = glamor_compile_glsl_prog(GL_VERTEX_SHADER, source);
     free(source);
@@ -701,6 +721,7 @@ combine_pict_format(PictFormatShort * des, const PictFormatShort src,
         mask_type = PICT_FORMAT_TYPE(mask);
         break;
     case glamor_program_alpha_dual_blend:
+    case glamor_program_alpha_dual_blend_gles2:
         src_type = PICT_FORMAT_TYPE(src);
         mask_type = PICT_FORMAT_TYPE(mask);
         break;
@@ -886,8 +907,11 @@ glamor_composite_choose_shader(CARD8 op,
         else {
             if (op == PictOpClear)
                 key.mask = SHADER_MASK_NONE;
-            else if (glamor_priv->has_dual_blend)
-                key.in = glamor_program_alpha_dual_blend;
+            else if (glamor_priv->has_dual_blend) {
+                key.in = glamor_glsl_has_ints(glamor_priv) ?
+                    glamor_program_alpha_dual_blend :
+                    glamor_program_alpha_dual_blend_gles2;
+            }
             else if (op == PictOpSrc || op == PictOpAdd
                      || op == PictOpIn || op == PictOpOut
                      || op == PictOpOverReverse)
-- 
GitLab


From 6a738c83f3c06d1576fcbe97a26a241e8fba063d Mon Sep 17 00:00:00 2001
From: Konstantin <ria.freelander@gmail.com>
Date: Tue, 28 Jun 2022 12:28:39 +0300
Subject: [PATCH 6/8] glamor: fix XVideo run with GLES

For now, it sets .version=120, which prevents shader from compiling on ES.
We just force version of shaders to be always 100 on ES, because we use
only 120 shaders on ES anyway, and all shaders works.

Signed-off-by: Konstantin Pugin <ria.freelander@gmail.com>

Reviewed-by: Adam Jackson <ajax@redhat.com>
Reviewed-by: Emma Anholt <emma@anholt.net>
---
 glamor/glamor_program.c | 5 +++++
 1 file changed, 5 insertions(+)

diff --git a/glamor/glamor_program.c b/glamor/glamor_program.c
index 46a506aaf..f361b726e 100644
--- a/glamor/glamor_program.c
+++ b/glamor/glamor_program.c
@@ -283,6 +283,11 @@ glamor_build_program(ScreenPtr          screen,
             gpu_shader4 = TRUE;
         }
     }
+    /* For now, fix shader version to GLES as 100. We will fall with 130 shaders
+     * in previous check due to forcibly set 120 glsl for GLES. But this patch
+     * makes xv shaders to work */
+    if(version && glamor_priv->is_gles)
+        version = 100;
 
     vs_vars = vs_location_vars(locations);
     fs_vars = fs_location_vars(locations);
-- 
GitLab


From 7428e1f1c24f6dfb747159b69571edb9e3828e6d Mon Sep 17 00:00:00 2001
From: Konstantin Pugin <ria.freelander@gmail.com>
Date: Sun, 10 Jul 2022 17:08:44 +0300
Subject: [PATCH 7/8] glamor: introduce fb_caveats flag

If texture can be uploaded to GL using glTexImage2D normally, but
cannot be read back using glReadPixels, we still can accelerate it,
but we cannot create pixmap with FBO using this texture type. So,
add a flag to avoid such creations.

Fixes #1362

Signed-off-by: Konstantin Pugin <ria.freelander@gmail.com>
---
 glamor/glamor.c      | 84 ++++++++++++++++++++++++++++++--------------
 glamor/glamor_priv.h |  7 ++++
 2 files changed, 64 insertions(+), 27 deletions(-)

diff --git a/glamor/glamor.c b/glamor/glamor.c
index f15b5a18a..9a7f7d5a1 100644
--- a/glamor/glamor.c
+++ b/glamor/glamor.c
@@ -216,7 +216,10 @@ glamor_create_pixmap(ScreenPtr screen, int w, int h, int depth,
              w <= glamor_priv->glyph_max_dim &&
              h <= glamor_priv->glyph_max_dim)
          || (w == 0 && h == 0)
-         || !glamor_priv->formats[depth].rendering_supported))
+         || !glamor_priv->formats[depth].rendering_supported
+         || (glamor_priv->formats[depth].fb_caveats &&
+              (usage != GLAMOR_CREATE_FBO_NO_FBO
+               && usage != GLAMOR_CREATE_PIXMAP_NO_TEXTURE))))
         return fbCreatePixmap(screen, w, h, depth, usage);
     else
         pixmap = fbCreatePixmap(screen, 0, 0, depth, usage);
@@ -459,6 +462,47 @@ glamor_format_for_pixmap(PixmapPtr pixmap)
         return &glamor_priv->formats[pixmap->drawable.depth];
 }
 
+/**
+* Check whether image with this depth has framebuffer issues in GL.
+* This check is run on GL ES when rendering is supported and we need
+* to check if format is color-renderable and implementation return
+* requested format/type combo to make format readable
+*/
+static Bool
+glamor_check_fb_caveats(ScreenPtr screen, unsigned tex, int depth,
+                  GLenum format, GLenum type)
+{
+    unsigned fbo;
+    int read_format, read_type;
+    GLenum status;
+
+    glGenFramebuffers(1, &fbo);
+    glBindFramebuffer(GL_FRAMEBUFFER, fbo);
+    glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,
+                            GL_TEXTURE_2D, tex, 0);
+    status = glCheckFramebufferStatus(GL_FRAMEBUFFER);
+    if (status != GL_FRAMEBUFFER_COMPLETE) {
+        ErrorF("glamor: Test fbo for depth %d incomplete.  "
+                "Texture will not be readable.\n", depth);
+        glDeleteFramebuffers(1, &fbo);
+        return TRUE;
+    }
+
+    glGetIntegerv(GL_IMPLEMENTATION_COLOR_READ_FORMAT, &read_format);
+    glGetIntegerv(GL_IMPLEMENTATION_COLOR_READ_TYPE, &read_type);
+
+    glDeleteFramebuffers(1, &fbo);
+
+    if (format != read_format || type != read_type) {
+        ErrorF("glamor: Implementation returned 0x%x/0x%x read format/type "
+                "for depth %d, expected 0x%x/0x%x.  "
+                "Texture will not be readable.\n",
+                read_format, read_type, depth, format, type);
+        return TRUE;
+    }
+    return FALSE;
+}
+
 static void
 glamor_add_format(ScreenPtr screen, int depth, CARD32 render_format,
                   GLenum internalformat, GLenum format, GLenum type,
@@ -466,6 +510,7 @@ glamor_add_format(ScreenPtr screen, int depth, CARD32 render_format,
 {
     glamor_screen_private *glamor_priv = glamor_get_screen_private(screen);
     struct glamor_format *f = &glamor_priv->formats[depth];
+    Bool fb_caveats = FALSE;
 
     /* If we're trying to run on GLES, make sure that we get the read
      * formats that we're expecting, since glamor_transfer relies on
@@ -478,43 +523,26 @@ glamor_add_format(ScreenPtr screen, int depth, CARD32 render_format,
      * screeninit.
      */
     if (rendering_supported && glamor_priv->is_gles) {
-        unsigned fbo, tex;
-        int read_format, read_type;
-        GLenum status;
+        unsigned tex;
 
+        /* Dummy glGetError() make sure second check will not fail from prev
+         * errors */
+        tex = glGetError();
         glGenTextures(1, &tex);
         glBindTexture(GL_TEXTURE_2D, tex);
         glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
         glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
         glTexImage2D(GL_TEXTURE_2D, 0, internalformat, 1, 1, 0,
                      format, type, NULL);
-
-        glGenFramebuffers(1, &fbo);
-        glBindFramebuffer(GL_FRAMEBUFFER, fbo);
-        glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,
-                               GL_TEXTURE_2D, tex, 0);
-        status = glCheckFramebufferStatus(GL_FRAMEBUFFER);
-        if (status != GL_FRAMEBUFFER_COMPLETE) {
-            ErrorF("glamor: Test fbo for depth %d incomplete.  "
-                   "Falling back to software.\n", depth);
+        if(glGetError() != GL_NO_ERROR)
+        {
+            ErrorF("glamor: Cannot upload texture for depth %d.  "
+                "Falling back to software.\n", depth);
             glDeleteTextures(1, &tex);
-            glDeleteFramebuffers(1, &fbo);
             return;
         }
-
-        glGetIntegerv(GL_IMPLEMENTATION_COLOR_READ_FORMAT, &read_format);
-        glGetIntegerv(GL_IMPLEMENTATION_COLOR_READ_TYPE, &read_type);
-
+        fb_caveats = glamor_check_fb_caveats(screen, tex, depth, format, type);
         glDeleteTextures(1, &tex);
-        glDeleteFramebuffers(1, &fbo);
-
-        if (format != read_format || type != read_type) {
-            ErrorF("glamor: Implementation returned 0x%x/0x%x read format/type "
-                   "for depth %d, expected 0x%x/0x%x.  "
-                   "Falling back to software.\n",
-                   read_format, read_type, depth, format, type);
-            return;
-        }
     }
 
     f->depth = depth;
@@ -523,6 +551,7 @@ glamor_add_format(ScreenPtr screen, int depth, CARD32 render_format,
     f->format = format;
     f->type = type;
     f->rendering_supported = rendering_supported;
+    f->fb_caveats = fb_caveats;
 }
 
 /* Set up the GL format/types that glamor will use for the various depths
@@ -616,6 +645,7 @@ glamor_setup_formats(ScreenPtr screen)
     glamor_priv->cbcr_format.render_format = PICT_yuv2;
     glamor_priv->cbcr_format.type = GL_UNSIGNED_BYTE;
     glamor_priv->cbcr_format.rendering_supported = TRUE;
+    glamor_priv->cbcr_format.fb_caveats = FALSE;
 }
 
 /** Set up glamor for an already-configured GL context. */
diff --git a/glamor/glamor_priv.h b/glamor/glamor_priv.h
index da20bc5aa..b47063f11 100644
--- a/glamor/glamor_priv.h
+++ b/glamor/glamor_priv.h
@@ -175,6 +175,13 @@ struct glamor_format {
      * just before upload)
      */
     Bool rendering_supported;
+    /**
+     * Whether image with this depth is framebuffer-complete in GL.
+     * This flag is set on GL ES when rendering is supported without
+     * conversion, but reading from framebuffer can bring some caveats
+     * like different format combination or incomplete framebuffer.
+     */
+    Bool fb_caveats;
 };
 
 struct glamor_saved_procs {
-- 
GitLab


From e64679077ccceb9a2061d0e74cebcd6bd0256502 Mon Sep 17 00:00:00 2001
From: Konstantin <ria.freelander@gmail.com>
Date: Tue, 19 Jul 2022 11:22:30 +0300
Subject: [PATCH 8/8] glamor: add gl_PointSize for ES shaders

According to ESSL 1.0, if gl_PointSize is not defined explicitly,
then it will be undefined behaviour in shaders which use points.
So, define gl_PointSize explicitly for ES as 1.0, which is
desktop OpenGL default, so, shaders for ES and GL glamor will
behave the same.

As @anholt requested, define this only for minimal amount of shaders
(point and glyphbit ones), to make sure than performance will not
affected

Signed-off-by: Konstantin <ria.freelander@gmail.com>
---
 glamor/glamor_glyphblt.c | 1 +
 glamor/glamor_points.c   | 3 ++-
 glamor/glamor_priv.h     | 5 +++++
 3 files changed, 8 insertions(+), 1 deletion(-)

diff --git a/glamor/glamor_glyphblt.c b/glamor/glamor_glyphblt.c
index 78315ea9b..412877224 100644
--- a/glamor/glamor_glyphblt.c
+++ b/glamor/glamor_glyphblt.c
@@ -34,6 +34,7 @@ static const glamor_facet glamor_facet_poly_glyph_blt = {
     .name = "poly_glyph_blt",
     .vs_vars = "attribute vec2 primitive;\n",
     .vs_exec = ("       vec2 pos = vec2(0,0);\n"
+                GLAMOR_DEFAULT_POINT_SIZE
                 GLAMOR_POS(gl_Position, primitive)),
 };
 
diff --git a/glamor/glamor_points.c b/glamor/glamor_points.c
index faf6f433b..d31da6789 100644
--- a/glamor/glamor_points.c
+++ b/glamor/glamor_points.c
@@ -32,7 +32,8 @@
 static const glamor_facet glamor_facet_point = {
     .name = "poly_point",
     .vs_vars = "attribute vec2 primitive;\n",
-    .vs_exec = GLAMOR_POS(gl_Position, primitive),
+    .vs_exec = (GLAMOR_DEFAULT_POINT_SIZE 
+                GLAMOR_POS(gl_Position, primitive)),
 };
 
 static Bool
diff --git a/glamor/glamor_priv.h b/glamor/glamor_priv.h
index b47063f11..956dd6a0b 100644
--- a/glamor/glamor_priv.h
+++ b/glamor/glamor_priv.h
@@ -49,6 +49,11 @@
     "precision mediump float;\n"  \
     "#endif\n"
 
+#define GLAMOR_DEFAULT_POINT_SIZE  \
+    "#ifdef GL_ES\n"              \
+    "       gl_PointSize = 1.0;\n"  \
+    "#endif\n"
+
 #include "glyphstr.h"
 
 #include "glamor_debug.h"
-- 
GitLab

