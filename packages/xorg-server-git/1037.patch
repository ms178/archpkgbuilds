From 8c410cbb3d9bab1e9abd696b5abde3dca27b8007 Mon Sep 17 00:00:00 2001
From: Joshua Ashton <joshua@froggi.es>
Date: Tue, 17 Jan 2023 00:03:50 +0000
Subject: [PATCH] glamor: Don't glFlush/ctx switch unless any work has been
 performed

`glamor_make_current` is always called before any calls to GL.

Apply some dirty-tracking to whenever we call `glamor_make_current` so
that we can avoid a decent amount of redundant GL work on each
Dispatch cycle.

Gamescope previously was waking up an empty Xwayland server with an
XQueryPointer and I noticed a significant amount of churn doing
redundant GL work.

This has been addressed on the Gamescope side as well, but avoiding any
useless GL context switches and flushes when glamor is doing nothing
is still beneficial for CPU and power usage on portable devices.

Signed-off-by: Joshua Ashton <joshua@froggi.es>
---
 glamor/glamor.c       | 15 ++++++++++-----
 glamor/glamor_priv.h  |  1 +
 glamor/glamor_sync.c  |  7 +++++--
 glamor/glamor_utils.h |  1 +
 4 files changed, 17 insertions(+), 7 deletions(-)

diff --git a/glamor/glamor.c b/glamor/glamor.c
index f15b5a18a..961874b0b 100644
--- a/glamor/glamor.c
+++ b/glamor/glamor.c
@@ -271,9 +271,11 @@ void
 glamor_block_handler(ScreenPtr screen)
 {
     glamor_screen_private *glamor_priv = glamor_get_screen_private(screen);
-
-    glamor_make_current(glamor_priv);
-    glFlush();
+    if (glamor_priv->dirty) {
+        glamor_make_current(glamor_priv);
+        glFlush();
+        glamor_priv->dirty = FALSE;
+    }
 }
 
 static void
@@ -281,8 +283,11 @@ _glamor_block_handler(ScreenPtr screen, void *timeout)
 {
     glamor_screen_private *glamor_priv = glamor_get_screen_private(screen);
 
-    glamor_make_current(glamor_priv);
-    glFlush();
+    if (glamor_priv->dirty) {
+        glamor_make_current(glamor_priv);
+        glFlush();
+        glamor_priv->dirty = FALSE;
+    }
 
     screen->BlockHandler = glamor_priv->saved_procs.block_handler;
     screen->BlockHandler(screen, timeout);
diff --git a/glamor/glamor_priv.h b/glamor/glamor_priv.h
index da20bc5aa..1032b880b 100644
--- a/glamor/glamor_priv.h
+++ b/glamor/glamor_priv.h
@@ -314,6 +314,7 @@ typedef struct glamor_screen_private {
     Bool suppress_gl_out_of_memory_logging;
     Bool logged_any_fbo_allocation_failure;
     Bool logged_any_pbo_allocation_failure;
+    Bool dirty;
 
     /* xv */
     glamor_program xv_prog;
diff --git a/glamor/glamor_sync.c b/glamor/glamor_sync.c
index 907e0c613..884555d76 100644
--- a/glamor/glamor_sync.c
+++ b/glamor/glamor_sync.c
@@ -52,8 +52,11 @@ glamor_sync_fence_set_triggered (SyncFence *fence)
 	struct glamor_sync_fence *glamor_fence = glamor_get_sync_fence(fence);
 
 	/* Flush pending rendering operations */
-        glamor_make_current(glamor);
-        glFlush();
+	if (glamor->dirty) {
+		glamor_make_current(glamor);
+		glFlush();
+		glamor->dirty = FALSE;
+	}
 
 	fence->funcs.SetTriggered = glamor_fence->set_triggered;
 	fence->funcs.SetTriggered(fence);
diff --git a/glamor/glamor_utils.h b/glamor/glamor_utils.h
index 93a933eed..e3a1b073b 100644
--- a/glamor/glamor_utils.h
+++ b/glamor/glamor_utils.h
@@ -672,6 +672,7 @@ glamor_make_current(glamor_screen_private *glamor_priv)
         lastGLContext = glamor_priv->ctx.ctx;
         glamor_priv->ctx.make_current(&glamor_priv->ctx);
     }
+    glamor_priv->dirty = TRUE;
 }
 
 static inline BoxRec
-- 
GitLab

