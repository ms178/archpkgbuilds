From ac763831bd95d6a31365b5e17b2744953f7d986b Mon Sep 17 00:00:00 2001
From: Konstantin <ria.freelander@gmail.com>
Date: Tue, 31 Oct 2023 19:52:07 +0300
Subject: [PATCH 1/8] glamor_egl: add helper functions for contexts

This is just a split big glamor_egl_init to 3 smaller functions.
No functional change.

Signed-off-by: Konstantin <ria.freelander@gmail.com>
---
 glamor/glamor_egl.c | 150 +++++++++++++++++++++++++-------------------
 1 file changed, 87 insertions(+), 63 deletions(-)

diff --git a/glamor/glamor_egl.c b/glamor/glamor_egl.c
index c35b10d832..65cf1ecf53 100644
--- a/glamor/glamor_egl.c
+++ b/glamor/glamor_egl.c
@@ -955,6 +955,86 @@ glamor_egl_free_screen(ScrnInfoPtr scrn)
     }
 }
 
+static Bool
+glamor_egl_try_big_gl_api(ScrnInfoPtr scrn)
+{
+    struct glamor_egl_screen_private *glamor_egl =
+        glamor_egl_get_screen_private(scrn);
+
+    if (eglBindAPI(EGL_OPENGL_API)) {
+        static const EGLint config_attribs_core[] = {
+            EGL_CONTEXT_OPENGL_PROFILE_MASK_KHR,
+            EGL_CONTEXT_OPENGL_CORE_PROFILE_BIT_KHR,
+            EGL_CONTEXT_MAJOR_VERSION_KHR,
+            GLAMOR_GL_CORE_VER_MAJOR,
+            EGL_CONTEXT_MINOR_VERSION_KHR,
+            GLAMOR_GL_CORE_VER_MINOR,
+            EGL_NONE
+        };
+        static const EGLint config_attribs[] = {
+            EGL_NONE
+        };
+
+        glamor_egl->context = eglCreateContext(glamor_egl->display,
+                                               EGL_NO_CONFIG_KHR, EGL_NO_CONTEXT,
+                                               config_attribs_core);
+
+        if (glamor_egl->context == EGL_NO_CONTEXT)
+            glamor_egl->context = eglCreateContext(glamor_egl->display,
+                                                   EGL_NO_CONFIG_KHR,
+                                                   EGL_NO_CONTEXT,
+                                                   config_attribs);
+    }
+
+    if (glamor_egl->context != EGL_NO_CONTEXT) {
+        if (!eglMakeCurrent(glamor_egl->display,
+                            EGL_NO_SURFACE, EGL_NO_SURFACE, glamor_egl->context)) {
+            xf86DrvMsg(scrn->scrnIndex, X_ERROR,
+                       "Failed to make GL context current\n");
+            return FALSE;
+        }
+
+        if (epoxy_gl_version() < 21) {
+            xf86DrvMsg(scrn->scrnIndex, X_INFO,
+                       "glamor: Ignoring GL < 2.1, falling back to GLES.\n");
+            eglDestroyContext(glamor_egl->display, glamor_egl->context);
+            glamor_egl->context = EGL_NO_CONTEXT;
+        }
+    }
+    return TRUE;
+}
+
+static Bool
+glamor_egl_try_gles_api(ScrnInfoPtr scrn)
+{
+    struct glamor_egl_screen_private *glamor_egl =
+        glamor_egl_get_screen_private(scrn);
+        
+    static const EGLint config_attribs[] = {
+        EGL_CONTEXT_CLIENT_VERSION, 2,
+        EGL_NONE
+    };
+    if (!eglBindAPI(EGL_OPENGL_ES_API)) {
+        xf86DrvMsg(scrn->scrnIndex, X_ERROR,
+                    "glamor: Failed to bind GLES API.\n");
+        return FALSE;
+    }
+
+    glamor_egl->context = eglCreateContext(glamor_egl->display,
+                                            EGL_NO_CONFIG_KHR, EGL_NO_CONTEXT,
+                                            config_attribs);
+
+    if (glamor_egl->context != EGL_NO_CONTEXT) {
+        if (!eglMakeCurrent(glamor_egl->display,
+                            EGL_NO_SURFACE, EGL_NO_SURFACE, glamor_egl->context)) {
+            xf86DrvMsg(scrn->scrnIndex, X_ERROR,
+                       "Failed to make GLES context current\n");
+            return FALSE;
+        }
+    }
+    return TRUE;
+}
+
 Bool
 glamor_egl_init(ScrnInfoPtr scrn, int fd)
 {
@@ -1004,74 +1084,18 @@ glamor_egl_init(ScrnInfoPtr scrn, int fd)
     GLAMOR_CHECK_EGL_EXTENSION(KHR_surfaceless_context);
     GLAMOR_CHECK_EGL_EXTENSION(KHR_no_config_context);
 
-    if (eglBindAPI(EGL_OPENGL_API)) {
-        static const EGLint config_attribs_core[] = {
-            EGL_CONTEXT_OPENGL_PROFILE_MASK_KHR,
-            EGL_CONTEXT_OPENGL_CORE_PROFILE_BIT_KHR,
-            EGL_CONTEXT_MAJOR_VERSION_KHR,
-            GLAMOR_GL_CORE_VER_MAJOR,
-            EGL_CONTEXT_MINOR_VERSION_KHR,
-            GLAMOR_GL_CORE_VER_MINOR,
-            EGL_NONE
-        };
-        static const EGLint config_attribs[] = {
-            EGL_NONE
-        };
-
-        glamor_egl->context = eglCreateContext(glamor_egl->display,
-                                               EGL_NO_CONFIG_KHR, EGL_NO_CONTEXT,
-                                               config_attribs_core);
-
-        if (glamor_egl->context == EGL_NO_CONTEXT)
-            glamor_egl->context = eglCreateContext(glamor_egl->display,
-                                                   EGL_NO_CONFIG_KHR,
-                                                   EGL_NO_CONTEXT,
-                                                   config_attribs);
-    }
+    if(!glamor_egl_try_big_gl_api(scrn))
+        goto error;
 
-    if (glamor_egl->context != EGL_NO_CONTEXT) {
-        if (!eglMakeCurrent(glamor_egl->display,
-                            EGL_NO_SURFACE, EGL_NO_SURFACE, glamor_egl->context)) {
-            xf86DrvMsg(scrn->scrnIndex, X_ERROR,
-                       "Failed to make GL context current\n");
+    if (glamor_egl->context == EGL_NO_CONTEXT) {
+        if(!glamor_egl_try_gles_api(scrn))
             goto error;
-        }
-
-        if (epoxy_gl_version() < 21) {
-            xf86DrvMsg(scrn->scrnIndex, X_INFO,
-                       "glamor: Ignoring GL < 2.1, falling back to GLES.\n");
-            eglDestroyContext(glamor_egl->display, glamor_egl->context);
-            glamor_egl->context = EGL_NO_CONTEXT;
-        }
     }
 
     if (glamor_egl->context == EGL_NO_CONTEXT) {
-        static const EGLint config_attribs[] = {
-            EGL_CONTEXT_CLIENT_VERSION, 2,
-            EGL_NONE
-        };
-        if (!eglBindAPI(EGL_OPENGL_ES_API)) {
-            xf86DrvMsg(scrn->scrnIndex, X_ERROR,
-                       "glamor: Failed to bind either GL or GLES APIs.\n");
-            goto error;
-        }
-
-        glamor_egl->context = eglCreateContext(glamor_egl->display,
-                                               EGL_NO_CONFIG_KHR, EGL_NO_CONTEXT,
-                                               config_attribs);
-
-        if (glamor_egl->context == EGL_NO_CONTEXT) {
-            xf86DrvMsg(scrn->scrnIndex, X_ERROR,
-                       "glamor: Failed to create GL or GLES2 contexts\n");
-            goto error;
-        }
-
-        if (!eglMakeCurrent(glamor_egl->display,
-                            EGL_NO_SURFACE, EGL_NO_SURFACE, glamor_egl->context)) {
-            xf86DrvMsg(scrn->scrnIndex, X_ERROR,
-                       "Failed to make GLES2 context current\n");
-            goto error;
-        }
+        xf86DrvMsg(scrn->scrnIndex, X_ERROR,
+                    "glamor: Failed to create GL or GLES2 contexts\n");
+        goto error;
     }
 
     renderer = glGetString(GL_RENDERER);
-- 
GitLab


From dcce28b8f1d4a21362bbd740a91f8fce63ab6bed Mon Sep 17 00:00:00 2001
From: Konstantin <ria.freelander@gmail.com>
Date: Thu, 21 Sep 2023 18:06:14 +0300
Subject: [PATCH 2/8] glamor_egl: add RenderingAPI option

This allows to choose between Glamor on OpenGL and Glamor on OpenGL ES
via an option.

Reviewed-by: Adam Jackson <ajax@redhat.com>
Signed-off-by: Konstantin <ria.freelander@gmail.com>
---
 glamor/glamor_egl.c | 31 ++++++++++++++++++++++++++++---
 1 file changed, 28 insertions(+), 3 deletions(-)

diff --git a/glamor/glamor_egl.c b/glamor/glamor_egl.c
index 65cf1ecf53..e70711e67b 100644
--- a/glamor/glamor_egl.c
+++ b/glamor/glamor_egl.c
@@ -1035,11 +1035,24 @@ glamor_egl_try_gles_api(ScrnInfoPtr scrn)
     return TRUE;
 }
 
+enum {
+    GLAMOREGLOPT_RENDERING_API,
+};
+
+static const OptionInfoRec GlamorEGLOptions[] = {
+    { GLAMOREGLOPT_RENDERING_API, "RenderingAPI", OPTV_STRING, {0}, FALSE },
+    { -1, NULL, OPTV_NONE, {0}, FALSE },
+};
+
 Bool
 glamor_egl_init(ScrnInfoPtr scrn, int fd)
 {
     struct glamor_egl_screen_private *glamor_egl;
     const GLubyte *renderer;
+    OptionInfoPtr options;
+    const char *api = NULL;
+    Bool es_allowed = TRUE;
+    Bool force_es = FALSE;
 
     glamor_egl = calloc(sizeof(*glamor_egl), 1);
     if (glamor_egl == NULL)
@@ -1047,6 +1060,16 @@ glamor_egl_init(ScrnInfoPtr scrn, int fd)
     if (xf86GlamorEGLPrivateIndex == -1)
         xf86GlamorEGLPrivateIndex = xf86AllocateScrnInfoPrivateIndex();
 
+    options = xnfalloc(sizeof(GlamorEGLOptions));
+    memcpy(options, GlamorEGLOptions, sizeof(GlamorEGLOptions));
+    xf86ProcessOptions(scrn->scrnIndex, scrn->options, options);
+    api = xf86GetOptValString(options, GLAMOREGLOPT_RENDERING_API);
+    if (api && !strncasecmp(api, "es", 2))
+        force_es = TRUE;
+    else if (api && !strncasecmp(api, "gl", 2))
+        es_allowed = FALSE;
+    free(options);
+
     scrn->privates[xf86GlamorEGLPrivateIndex].ptr = glamor_egl;
     glamor_egl->fd = fd;
     glamor_egl->gbm = gbm_create_device(glamor_egl->fd);
@@ -1084,10 +1107,12 @@ glamor_egl_init(ScrnInfoPtr scrn, int fd)
     GLAMOR_CHECK_EGL_EXTENSION(KHR_surfaceless_context);
     GLAMOR_CHECK_EGL_EXTENSION(KHR_no_config_context);
 
-    if(!glamor_egl_try_big_gl_api(scrn))
-        goto error;
+    if (!force_es) {
+        if(!glamor_egl_try_big_gl_api(scrn))
+            goto error;
+    }
 
-    if (glamor_egl->context == EGL_NO_CONTEXT) {
+    if (glamor_egl->context == EGL_NO_CONTEXT && es_allowed) {
         if(!glamor_egl_try_gles_api(scrn))
             goto error;
     }
-- 
GitLab


From e2cfe3421152037577b83f27cdcb54ddbb58d7a3 Mon Sep 17 00:00:00 2001
From: Konstantin <ria.freelander@gmail.com>
Date: Thu, 21 Sep 2023 17:07:43 +0300
Subject: [PATCH 3/8] glamor_egl: add info message about context API

It is useful to know on what context we are running, and
we need to show it into xorg.log

Reviewed-by: Adam Jackson <ajax@redhat.com>
Signed-off-by: Konstantin <ria.freelander@gmail.com>
---
 glamor/glamor_egl.c | 8 ++++++++
 1 file changed, 8 insertions(+)

diff --git a/glamor/glamor_egl.c b/glamor/glamor_egl.c
index e70711e67b..9bdff24c53 100644
--- a/glamor/glamor_egl.c
+++ b/glamor/glamor_egl.c
@@ -1000,6 +1000,10 @@ glamor_egl_try_big_gl_api(ScrnInfoPtr scrn)
             eglDestroyContext(glamor_egl->display, glamor_egl->context);
             glamor_egl->context = EGL_NO_CONTEXT;
         }
+        xf86DrvMsg(scrn->scrnIndex, X_INFO,
+            "glamor: Using OpenGL %d.%d context.\n",
+            epoxy_gl_version() / 10,
+            epoxy_gl_version() % 10);
     }
     return TRUE;
 }
@@ -1031,6 +1035,10 @@ glamor_egl_try_gles_api(ScrnInfoPtr scrn)
                        "Failed to make GLES context current\n");
             return FALSE;
         }
+        xf86DrvMsg(scrn->scrnIndex, X_INFO,
+                "glamor: Using OpenGL ES %d.%d context.\n",
+                epoxy_gl_version() / 10,
+                epoxy_gl_version() % 10);
     }
     return TRUE;
 }
-- 
GitLab


From c25195b5ac7e98190fcb4e1f375a48e58e210d3d Mon Sep 17 00:00:00 2001
From: Konstantin <ria.freelander@gmail.com>
Date: Fri, 22 Sep 2023 12:29:52 +0300
Subject: [PATCH 4/8] xorg.conf.man: document new RenderingAPI option

Reviewed-by: Adam Jackson <ajax@redhat.com>
Signed-off-by: Konstantin <ria.freelander@gmail.com>
---
 hw/xfree86/man/xorg.conf.man | 8 ++++++++
 1 file changed, 8 insertions(+)

diff --git a/hw/xfree86/man/xorg.conf.man b/hw/xfree86/man/xorg.conf.man
index d057f26ecd..3669e6d1f8 100644
--- a/hw/xfree86/man/xorg.conf.man
+++ b/hw/xfree86/man/xorg.conf.man
@@ -2096,6 +2096,14 @@ use for the screen. This may be used to select an alternate implementation
 for development, debugging, or alternate feature sets.
 Default: mesa.
 .TP 7
+.BI "Option \*RenderingAPI\*q \*q" string \*q
+This option specifies an rendering API for use in conjunction with Glamor
+accel method. You can specify OpenGL with a value "gl" and OpenGL ES with a 
+value "es", and the default is both, when Glamor fallbacks to GLES if GL 2.1 is
+not available. This may be useful for embedded and old cards, where GL ES
+feature set works faster than GL feature set.
+Default: gl.
+.TP 7
 .BI "Option \*qInitPrimary\*q \*q" boolean \*q
 Use the Int10 module to initialize the primary graphics card.
 Normally, only secondary cards are soft-booted using the Int10 module, as the
-- 
GitLab


From 55ecb87b3d363b3805ac07ec14672d856eb2239f Mon Sep 17 00:00:00 2001
From: Konstantin <ria.freelander@gmail.com>
Date: Mon, 30 Oct 2023 14:23:43 +0300
Subject: [PATCH 5/8] hw/Xwayland: add xwl_glamor_mode_flags enum

This replaces int glamor parameter with a new enum to be more clean
and prepare for more glamor options.
No functional change.

Signed-off-by: Konstantin <ria.freelander@gmail.com>
---
 hw/xwayland/xwayland-glamor-eglstream.c | 5 +++++
 hw/xwayland/xwayland-glamor-gbm.c       | 6 ++++++
 hw/xwayland/xwayland-glamor.h           | 5 +++++
 hw/xwayland/xwayland-screen.c           | 9 ++++++---
 hw/xwayland/xwayland-screen.h           | 2 +-
 5 files changed, 23 insertions(+), 4 deletions(-)

diff --git a/hw/xwayland/xwayland-glamor-eglstream.c b/hw/xwayland/xwayland-glamor-eglstream.c
index c911ed987f..e5131b09cc 100644
--- a/hw/xwayland/xwayland-glamor-eglstream.c
+++ b/hw/xwayland/xwayland-glamor-eglstream.c
@@ -962,6 +962,11 @@ xwl_glamor_eglstream_init_egl(struct xwl_screen *xwl_screen)
     };
     int n;
 
+    if (!(xwl_screen->glamor & XWL_GLAMOR_GL)) {
+        ErrorF("glamor: eglstream backend requires desktop OpenGL\n");
+        goto error;
+    }
+
     xwl_screen->egl_display = glamor_egl_get_display(
         EGL_PLATFORM_DEVICE_EXT, xwl_eglstream->egl_device);
     if (!xwl_screen->egl_display)
diff --git a/hw/xwayland/xwayland-glamor-gbm.c b/hw/xwayland/xwayland-glamor-gbm.c
index fca476b862..5707b5e63c 100644
--- a/hw/xwayland/xwayland-glamor-gbm.c
+++ b/hw/xwayland/xwayland-glamor-gbm.c
@@ -1072,6 +1072,9 @@ xwl_glamor_try_big_gl_api(struct xwl_screen *xwl_screen)
     };
     int gl_version;
 
+    if (!(xwl_screen->glamor & XWL_GLAMOR_GL))
+        return FALSE;
+
     eglBindAPI(EGL_OPENGL_API);
 
     xwl_screen->egl_context =
@@ -1112,6 +1115,9 @@ xwl_glamor_try_gles_api(struct xwl_screen *xwl_screen)
         EGL_NONE,
     };
 
+    if (!(xwl_screen->glamor & XWL_GLAMOR_GL))
+        return FALSE;
+
     eglBindAPI(EGL_OPENGL_ES_API);
 
     xwl_screen->egl_context = eglCreateContext(xwl_screen->egl_display,
diff --git a/hw/xwayland/xwayland-glamor.h b/hw/xwayland/xwayland-glamor.h
index 183fe755ae..f4069553cd 100644
--- a/hw/xwayland/xwayland-glamor.h
+++ b/hw/xwayland/xwayland-glamor.h
@@ -41,6 +41,11 @@ typedef enum _xwl_egl_backend_flags {
     XWL_EGL_BACKEND_NEEDS_N_BUFFERING = (1 << 1),
 } xwl_egl_backend_flags;
 
+typedef enum _xwl_glamor_mode_flags{
+    XWL_GLAMOR_NONE = 0,
+    XWL_GLAMOR_GL = (1 << 0),
+} xwl_glamor_mode_flags;
+
 struct xwl_egl_backend {
     /* Set by the backend if available */
     Bool is_available;
diff --git a/hw/xwayland/xwayland-screen.c b/hw/xwayland/xwayland-screen.c
index cc14e0771e..7cc7775d03 100644
--- a/hw/xwayland/xwayland-screen.c
+++ b/hw/xwayland/xwayland-screen.c
@@ -54,6 +54,9 @@
 #ifdef XWL_HAS_EI
 #include "xwayland-xtest.h"
 #endif
+#ifdef XWL_HAS_GLAMOR
+#include "xwayland-glamor.h"
+#endif
 
 #ifdef MITSHM
 #include "shmint.h"
@@ -757,7 +760,7 @@ xwl_screen_init(ScreenPtr pScreen, int argc, char **argv)
 #endif
 
 #ifdef XWL_HAS_GLAMOR
-    xwl_screen->glamor = 1;
+    xwl_screen->glamor = XWL_GLAMOR_GL;
 #endif
 
     for (i = 1; i < argc; i++) {
@@ -778,7 +781,7 @@ xwl_screen_init(ScreenPtr pScreen, int argc, char **argv)
             defaultScreenSaverInterval = 0;
         }
         else if (strcmp(argv[i], "-shm") == 0) {
-            xwl_screen->glamor = 0;
+            xwl_screen->glamor = XWL_GLAMOR_NONE;
         }
         else if (strcmp(argv[i], "-eglstream") == 0) {
 #ifdef XWL_HAS_EGLSTREAM
@@ -961,7 +964,7 @@ xwl_screen_init(ScreenPtr pScreen, int argc, char **argv)
 
         if (xwl_screen->egl_backend == NULL || !xwl_glamor_init(xwl_screen)) {
            ErrorF("Failed to initialize glamor, falling back to sw\n");
-           xwl_screen->glamor = 0;
+           xwl_screen->glamor = XWL_GLAMOR_NONE;
         }
     }
 #ifdef GLAMOR_HAS_GBM
diff --git a/hw/xwayland/xwayland-screen.h b/hw/xwayland/xwayland-screen.h
index bd66dd6818..9eaac16dba 100644
--- a/hw/xwayland/xwayland-screen.h
+++ b/hw/xwayland/xwayland-screen.h
@@ -60,7 +60,7 @@ struct xwl_screen {
     enum RootClipMode root_clip_mode;
 
     int rootless;
-    int glamor;
+    xwl_glamor_mode_flags glamor;
     int present;
     int force_xrandr_emulation;
     int fullscreen;
-- 
GitLab


From c85cc2ad0f92f0600db05f3b3b3467a81b4ccea0 Mon Sep 17 00:00:00 2001
From: Konstantin <ria.freelander@gmail.com>
Date: Mon, 30 Oct 2023 14:25:43 +0300
Subject: [PATCH 6/8] Xwayland: add "glamor" command line option

This will force Glamor run on GL or GL ES independently from GL version set.

Signed-off-by: Konstantin <ria.freelander@gmail.com>
---
 hw/xwayland/xwayland-glamor-gbm.c |  2 +-
 hw/xwayland/xwayland-glamor.h     |  2 ++
 hw/xwayland/xwayland-screen.c     | 14 +++++++++++++-
 hw/xwayland/xwayland.c            | 10 ++++++++++
 4 files changed, 26 insertions(+), 2 deletions(-)

diff --git a/hw/xwayland/xwayland-glamor-gbm.c b/hw/xwayland/xwayland-glamor-gbm.c
index 5707b5e63c..40a02f2dbd 100644
--- a/hw/xwayland/xwayland-glamor-gbm.c
+++ b/hw/xwayland/xwayland-glamor-gbm.c
@@ -1115,7 +1115,7 @@ xwl_glamor_try_gles_api(struct xwl_screen *xwl_screen)
         EGL_NONE,
     };
 
-    if (!(xwl_screen->glamor & XWL_GLAMOR_GL))
+    if (!(xwl_screen->glamor & XWL_GLAMOR_GLES))
         return FALSE;
 
     eglBindAPI(EGL_OPENGL_ES_API);
diff --git a/hw/xwayland/xwayland-glamor.h b/hw/xwayland/xwayland-glamor.h
index f4069553cd..97e8fb6642 100644
--- a/hw/xwayland/xwayland-glamor.h
+++ b/hw/xwayland/xwayland-glamor.h
@@ -44,6 +44,8 @@ typedef enum _xwl_egl_backend_flags {
 typedef enum _xwl_glamor_mode_flags{
     XWL_GLAMOR_NONE = 0,
     XWL_GLAMOR_GL = (1 << 0),
+    XWL_GLAMOR_GLES = (1 << 1),
+    XWL_GLAMOR_DEFAULT = XWL_GLAMOR_GL | XWL_GLAMOR_GLES,
 } xwl_glamor_mode_flags;
 
 struct xwl_egl_backend {
diff --git a/hw/xwayland/xwayland-screen.c b/hw/xwayland/xwayland-screen.c
index 7cc7775d03..17c8a255fe 100644
--- a/hw/xwayland/xwayland-screen.c
+++ b/hw/xwayland/xwayland-screen.c
@@ -760,7 +760,7 @@ xwl_screen_init(ScreenPtr pScreen, int argc, char **argv)
 #endif
 
 #ifdef XWL_HAS_GLAMOR
-    xwl_screen->glamor = XWL_GLAMOR_GL;
+    xwl_screen->glamor = XWL_GLAMOR_DEFAULT;
 #endif
 
     for (i = 1; i < argc; i++) {
@@ -790,6 +790,18 @@ xwl_screen_init(ScreenPtr pScreen, int argc, char **argv)
             ErrorF("Xwayland glamor: this build does not have EGLStream support\n");
 #endif
         }
+#ifdef XWL_HAS_GLAMOR
+        else if (strcmp(argv[i], "-glamor") == 0) {
+            if (strncmp(argv[i + 1], "es", 2) == 0)
+                xwl_screen->glamor = XWL_GLAMOR_GLES;
+            else if (strncmp(argv[i + 1], "gl", 2) == 0)
+                xwl_screen->glamor = XWL_GLAMOR_GL;
+            else if (strncmp(argv[i + 1], "off", 3) == 0)
+                xwl_screen->glamor = XWL_GLAMOR_NONE;
+            else
+                ErrorF("Xwayland glamor: unknown rendering API selected\n");
+        }
+#endif
         else if (strcmp(argv[i], "-force-xrandr-emulation") == 0) {
             xwl_screen->force_xrandr_emulation = 1;
         }
diff --git a/hw/xwayland/xwayland.c b/hw/xwayland/xwayland.c
index 3f9c5c2699..6ec5736747 100644
--- a/hw/xwayland/xwayland.c
+++ b/hw/xwayland/xwayland.c
@@ -102,6 +102,9 @@ ddxUseMsg(void)
     ErrorF("-eglstream             use eglstream backend for nvidia GPUs\n");
 #endif
     ErrorF("-shm                   use shared memory for passing buffers\n");
+#ifdef XWL_HAS_GLAMOR
+    ErrorF("-glamor [gl|es|off]    use given API for Glamor acceleration. Incompatible with -shm option\n");
+#endif
     ErrorF("-verbose [n]           verbose startup messages\n");
     ErrorF("-version               show the server version and exit\n");
     ErrorF("-noTouchPointerEmulation  disable touch pointer emulation\n");
@@ -207,6 +210,13 @@ ddxProcessArgument(int argc, char *argv[], int i)
     else if (strcmp(argv[i], "-shm") == 0) {
         return 1;
     }
+#ifdef XWL_HAS_GLAMOR
+    else if (strcmp(argv[i], "-glamor") == 0) {
+        CHECK_FOR_REQUIRED_ARGUMENTS(1);
+        /* Only check here, actual work inside xwayland-screen.c */
+        return 2;
+    }
+#endif
     else if (strcmp(argv[i], "-verbose") == 0) {
         if (++i < argc && argv[i]) {
             char *end;
-- 
GitLab


From 427209cc58306626844850d70325b6950a28e3dc Mon Sep 17 00:00:00 2001
From: Konstantin <ria.freelander@gmail.com>
Date: Fri, 22 Sep 2023 12:33:38 +0300
Subject: [PATCH 7/8] Xwayland: document new "glamor" option

Signed-off-by: Konstantin <ria.freelander@gmail.com>
---
 hw/xwayland/man/Xwayland.man | 11 +++++++++++
 1 file changed, 11 insertions(+)

diff --git a/hw/xwayland/man/Xwayland.man b/hw/xwayland/man/Xwayland.man
index 9ecb650010..26b554be84 100644
--- a/hw/xwayland/man/Xwayland.man
+++ b/hw/xwayland/man/Xwayland.man
@@ -80,6 +80,15 @@ Sets the geometry of the \fIXwayland\fP window to \fIWxH\fP when running rootful
 
 This option is not compatible with rootless mode (\fI-rootless\fP).
 .TP 8
+.B \-glamor " [\fIgl|es|off\fP]"
+Use given rendering API for Glamor acceleration. Possible options are \fIgl\fP and \fIes\fP.
+If \fIXwayland\fP was compiled with Glamor support, this option will instruct \fIXwayland\fP
+to use only requested API for Glamor. If this set to \fIoff\fP, effect is equal to \fI-shm\fP option.
+Without this option and without \fI-shm\fP option, \fIXwayland\fP tries the OpenGL rendering API first,
+and fallback to GL ES if GL version is less than 2.1.
+
+This option is not compatible with \fI-shm\fP option.
+.TP 8
 .B \-host-grab
 Disable host keyboard shorcuts and confine the pointer when running rootful.
 
@@ -123,6 +132,8 @@ to be an X window manager as well.
 .BI \-shm
 Force the shared memory backend instead of glamor (if available) for passing
 buffers to the Wayland server.
+
+This option is not compatible with \fI-glamor\fP option.
 .TP 8
 .BR \-verbose " [\fIn\fP]"
 Sets the verbosity level for information printed on stderr.  If the
-- 
GitLab


From 990c1373ff1ab3a17a14ca82da63ad0d614d2e8f Mon Sep 17 00:00:00 2001
From: Konstantin <ria.freelander@gmail.com>
Date: Wed, 11 Oct 2023 17:10:07 +0300
Subject: [PATCH 8/8] Xwayland: add new "have_glamor_api" pkgconfig

For compositors which want to check if Xwayland is capable to select Glamor
rendering API.

Signed-off-by: Konstantin <ria.freelander@gmail.com>
---
 hw/xwayland/meson.build | 1 +
 1 file changed, 1 insertion(+)

diff --git a/hw/xwayland/meson.build b/hw/xwayland/meson.build
index 54529b64e9..8bda50eabb 100644
--- a/hw/xwayland/meson.build
+++ b/hw/xwayland/meson.build
@@ -175,6 +175,7 @@ xwayland_server = executable(
 
 xwayland_vars = [
     'have_glamor=' + build_glamor.to_string(),
+    'have_glamor_api=' + build_glamor.to_string(),
     'have_eglstream=' + build_eglstream.to_string(),
     'have_initfd=true',
     'have_listenfd=true',
-- 
GitLab

