From 501985f959e0e24f7929fb9af6be292135e9051b Mon Sep 17 00:00:00 2001
From: Konstantin Pugin <ria.freelander@gmail.com>
Date: Thu, 21 Jul 2022 00:46:07 +0300
Subject: [PATCH 1/5] glamor: add glvnd_vendor private

This commit adds an ability to store a glvnd vendor in Glamor
structures, which can be used for initialize some vendor-based values
without hooking into DDX internals. Also this adds setting this value
into Xorg and Xwayland

Signed-off-by: Konstantin Pugin <ria.freelander@gmail.com>
Reviewed-by: Adam Jackson <ajax@redhat.com>
Acked-by: Emma Anholt <emma@anholt.net>
---
 glamor/glamor.c               | 16 ++++++++++++++++
 glamor/glamor.h               |  6 ++++++
 glamor/glamor_egl.c           |  5 +++++
 glamor/glamor_priv.h          |  2 ++
 hw/xwayland/xwayland-glamor.c |  1 +
 5 files changed, 30 insertions(+)

diff --git a/glamor/glamor.c b/glamor/glamor.c
index 9dcef5fac..6c16d48a4 100644
--- a/glamor/glamor.c
+++ b/glamor/glamor.c
@@ -947,6 +947,22 @@ glamor_fini(ScreenPtr screen)
     /* Do nothing currently. */
 }
 
+void
+glamor_set_glvnd_vendor(ScreenPtr screen, const char* vendor_name)
+{
+    glamor_screen_private *glamor_priv = glamor_get_screen_private(screen);
+
+    glamor_priv->glvnd_vendor = vendor_name;
+}
+
+const char*
+glamor_get_glvnd_vendor(ScreenPtr screen)
+{
+    glamor_screen_private *glamor_priv = glamor_get_screen_private(screen);
+
+    return glamor_priv->glvnd_vendor;
+}
+
 void
 glamor_enable_dri3(ScreenPtr screen)
 {
diff --git a/glamor/glamor.h b/glamor/glamor.h
index 31157471d..a0b3783d9 100644
--- a/glamor/glamor.h
+++ b/glamor/glamor.h
@@ -120,6 +120,12 @@ extern _X_EXPORT void glamor_clear_pixmap(PixmapPtr pixmap);
 
 extern _X_EXPORT void glamor_block_handler(ScreenPtr screen);
 
+/* This function should be called after glamor_init,
+ * but before adding a glamor GLX provider */
+extern _X_EXPORT void glamor_set_glvnd_vendor(ScreenPtr screen,
+                                              const char* vendor);
+extern _X_EXPORT const char* glamor_get_glvnd_vendor(ScreenPtr screen);
+
 extern _X_EXPORT PixmapPtr glamor_create_pixmap(ScreenPtr screen, int w, int h,
                                                 int depth, unsigned int usage);
 extern _X_EXPORT Bool glamor_destroy_pixmap(PixmapPtr pixmap);
diff --git a/glamor/glamor_egl.c b/glamor/glamor_egl.c
index aa82a5608..498f50519 100644
--- a/glamor/glamor_egl.c
+++ b/glamor/glamor_egl.c
@@ -887,6 +887,7 @@ glamor_egl_screen_init(ScreenPtr screen, struct glamor_context *glamor_ctx)
 #ifdef DRI3
     glamor_screen_private *glamor_priv = glamor_get_screen_private(screen);
 #endif
+    const char* gbm_backend_name;
 
     glamor_egl->saved_close_screen = screen->CloseScreen;
     screen->CloseScreen = glamor_egl_close_screen;
@@ -899,6 +900,10 @@ glamor_egl_screen_init(ScreenPtr screen, struct glamor_context *glamor_ctx)
 
     glamor_ctx->make_current = glamor_egl_make_current;
 
+    gbm_backend_name = gbm_device_get_backend_name(glamor_egl->gbm);
+    /* Mesa uses "drm" as backend name, in that case, just do nothing */
+    if (gbm_backend_name && strcmp(gbm_backend_name, "drm") != 0)
+        glamor_set_glvnd_vendor(screen, gbm_backend_name);
 #ifdef DRI3
     /* Tell the core that we have the interfaces for import/export
      * of pixmaps.
diff --git a/glamor/glamor_priv.h b/glamor/glamor_priv.h
index 028a6d374..5875b280b 100644
--- a/glamor/glamor_priv.h
+++ b/glamor/glamor_priv.h
@@ -309,6 +309,8 @@ typedef struct glamor_screen_private {
     int flags;
     ScreenPtr screen;
     int dri3_enabled;
+    /* glvnd vendor */
+    const char* glvnd_vendor;
 
     Bool suppress_gl_out_of_memory_logging;
     Bool logged_any_fbo_allocation_failure;
diff --git a/hw/xwayland/xwayland-glamor.c b/hw/xwayland/xwayland-glamor.c
index 24620605d..fa2a7ea61 100644
--- a/hw/xwayland/xwayland-glamor.c
+++ b/hw/xwayland/xwayland-glamor.c
@@ -72,6 +72,7 @@ glamor_egl_screen_init(ScreenPtr screen, struct glamor_context *glamor_ctx)
 {
     struct xwl_screen *xwl_screen = xwl_screen_get(screen);
 
+    glamor_set_glvnd_vendor(screen, xwl_screen->glvnd_vendor);
     glamor_enable_dri3(screen);
     glamor_ctx->ctx = xwl_screen->egl_context;
     glamor_ctx->display = xwl_screen->egl_display;
-- 
GitLab


From 992613a69715e333a79337367407af454e9ed9a8 Mon Sep 17 00:00:00 2001
From: Adam Jackson <ajax@redhat.com>
Date: Wed, 26 Aug 2020 18:22:22 -0400
Subject: [PATCH 2/5] glamor: Lift the GLX EGL backend from Xwayland

This code is almost entirely ddx-agnostic already, and I'd like to use
it from the other EGL glamor consumers. Which, right now that's just
Xorg, but soon it'll be Xephyr too.
---
 .../glamor_glx_provider.c                     | 19 ++++++++++---------
 .../glamor_glx_provider.h                     |  4 ++--
 glamor/meson.build                            |  5 ++++-
 hw/xwayland/meson.build                       |  4 ----
 hw/xwayland/xwayland-glamor.c                 |  2 +-
 5 files changed, 17 insertions(+), 17 deletions(-)
 rename hw/xwayland/xwayland-glx.c => glamor/glamor_glx_provider.c (97%)
 rename hw/xwayland/xwayland-glx.h => glamor/glamor_glx_provider.h (94%)

diff --git a/hw/xwayland/xwayland-glx.c b/glamor/glamor_glx_provider.c
similarity index 97%
rename from hw/xwayland/xwayland-glx.c
rename to glamor/glamor_glx_provider.c
index a3e85fc2f..ffc641b1b 100644
--- a/hw/xwayland/xwayland-glx.c
+++ b/glamor/glamor_glx_provider.c
@@ -30,21 +30,18 @@
  * can do, which often does not include things like multisample visuals.
  */
 
-#include <xwayland-config.h>
+#include <dix-config.h>
 
 #define MESA_EGL_NO_X11_HEADERS
 #define EGL_NO_X11
-// #include <EGL/egl.h>
 #include <epoxy/egl.h>
 #include "glxserver.h"
 #include "glxutil.h"
 #include "compint.h"
 #include <X11/extensions/composite.h>
-#include "glamor_context.h"
+#include "glamor_priv.h"
 #include "glamor.h"
 
-#include "xwayland-screen.h"
-
 /* Can't get these from <GL/glx.h> since it pulls in client headers */
 #define GLX_RGBA_BIT		0x00000001
 #define GLX_WINDOW_BIT		0x00000001
@@ -364,12 +361,16 @@ static __GLXscreen *
 egl_screen_probe(ScreenPtr pScreen)
 {
     struct egl_screen *screen;
-    struct xwl_screen *xwl_screen = xwl_screen_get(pScreen);
+    glamor_screen_private *glamor_screen;
     __GLXscreen *base;
 
     if (enableIndirectGLX)
         return NULL; /* not implemented */
 
+    glamor_screen = glamor_get_screen_private(pScreen);
+    if (!glamor_screen)
+        return NULL;
+
     if (!(screen = calloc(1, sizeof *screen)))
         return NULL;
 
@@ -378,7 +379,7 @@ egl_screen_probe(ScreenPtr pScreen)
     base->createDrawable = egl_create_glx_drawable;
     /* base.swapInterval = NULL; */
 
-    screen->display = xwl_screen->glamor_ctx->display;
+    screen->display = glamor_screen->ctx.display;
 
     __glXInitExtensionEnableBits(screen->base.glx_enable_bits);
     __glXEnableExtension(base->glx_enable_bits, "GLX_ARB_context_flush_control");
@@ -402,8 +403,8 @@ egl_screen_probe(ScreenPtr pScreen)
         return NULL;
     }
 
-    if (!screen->base.glvnd && xwl_screen->glvnd_vendor)
-        screen->base.glvnd = strdup(xwl_screen->glvnd_vendor);
+    if (!screen->base.glvnd && glamor_screen->glvnd_vendor)
+        screen->base.glvnd = strdup(glamor_screen->glvnd_vendor);
 
     if (!screen->base.glvnd)
         screen->base.glvnd = strdup("mesa");
diff --git a/hw/xwayland/xwayland-glx.h b/glamor/glamor_glx_provider.h
similarity index 94%
rename from hw/xwayland/xwayland-glx.h
rename to glamor/glamor_glx_provider.h
index 62c9fb7ce..b0db90e47 100644
--- a/hw/xwayland/xwayland-glx.h
+++ b/glamor/glamor_glx_provider.h
@@ -27,11 +27,11 @@
 #ifndef XWAYLAND_GLX_H
 #define XWAYLAND_GLX_H
 
-#include <xwayland-config.h>
+#include <dix-config.h>
 
 #ifdef GLXEXT
 #include "glx_extinit.h"
-extern __GLXprovider glamor_provider;
+extern _X_EXPORT __GLXprovider glamor_provider;
 #endif
 
 #endif /* XWAYLAND_GLX_H */
diff --git a/glamor/meson.build b/glamor/meson.build
index 4a3f6241a..d4cb1859a 100644
--- a/glamor/meson.build
+++ b/glamor/meson.build
@@ -33,6 +33,9 @@ srcs_glamor = [
     'glamor_sync.c',
 ]
 
+if build_glx
+    srcs_glamor += 'glamor_glx_provider.c'
+endif
 if build_xv
     srcs_glamor += 'glamor_xv.c'
 endif
@@ -41,7 +44,7 @@ epoxy_dep = dependency('epoxy')
 
 glamor = static_library('glamor',
     srcs_glamor,
-    include_directories: inc,
+    include_directories: [inc, glx_inc],
     dependencies: [
         common_dep,
         epoxy_dep,
diff --git a/hw/xwayland/meson.build b/hw/xwayland/meson.build
index 692b0442a..e258007c4 100644
--- a/hw/xwayland/meson.build
+++ b/hw/xwayland/meson.build
@@ -7,7 +7,6 @@ srcs = [
     'xwayland-drm-lease.h',
     'xwayland-drm-lease.c',
     'xwayland-glamor.h',
-    'xwayland-glx.h',
     'xwayland-pixmap.c',
     'xwayland-pixmap.h',
     'xwayland-present.h',
@@ -90,9 +89,6 @@ xwayland_glamor = []
 eglstream_srcs = []
 if build_glamor
     srcs += 'xwayland-glamor.c'
-    if build_glx
-        srcs += 'xwayland-glx.c'
-    endif
     if gbm_dep.found()
         srcs += 'xwayland-glamor-gbm.c'
     endif
diff --git a/hw/xwayland/xwayland-glamor.c b/hw/xwayland/xwayland-glamor.c
index fa2a7ea61..238145ae5 100644
--- a/hw/xwayland/xwayland-glamor.c
+++ b/hw/xwayland/xwayland-glamor.c
@@ -31,6 +31,7 @@
 
 #include <glamor.h>
 #include <glamor_context.h>
+#include <glamor_glx_provider.h>
 #ifdef GLXEXT
 #include "glx_extinit.h"
 #endif
@@ -40,7 +41,6 @@
 #include <drm_fourcc.h>
 
 #include "xwayland-glamor.h"
-#include "xwayland-glx.h"
 #include "xwayland-screen.h"
 #include "xwayland-window.h"
 
-- 
GitLab


From 75a90bf24646797ab54186ade16f931171638675 Mon Sep 17 00:00:00 2001
From: Adam Jackson <ajax@redhat.com>
Date: Fri, 25 Feb 2022 13:41:41 -0500
Subject: [PATCH 3/5] glamor/glxprov: Stop exposing non-db(-capable) configs

---
 glamor/glamor_glx_provider.c | 35 +++++++++++++++--------------------
 1 file changed, 15 insertions(+), 20 deletions(-)

diff --git a/glamor/glamor_glx_provider.c b/glamor/glamor_glx_provider.c
index ffc641b1b..62530a29e 100644
--- a/glamor/glamor_glx_provider.c
+++ b/glamor/glamor_glx_provider.c
@@ -142,8 +142,7 @@ egl_create_glx_drawable(ClientPtr client, __GLXscreen *screen,
 static struct egl_config *
 translate_eglconfig(struct egl_screen *screen, EGLConfig hc,
                     struct egl_config *chain, Bool direct_color,
-                    Bool double_buffer, Bool duplicate_for_composite,
-                    Bool srgb_only)
+                    Bool duplicate_for_composite, Bool srgb_only)
 {
     EGLint value;
     struct egl_config *c = calloc(1, sizeof *c);
@@ -191,10 +190,8 @@ translate_eglconfig(struct egl_screen *screen, EGLConfig hc,
     else
         c->base.visualType = GLX_TRUE_COLOR;
 
-    if (double_buffer)
-        c->base.doubleBufferMode = GL_TRUE;
-    else
-        c->base.doubleBufferMode = GL_FALSE;
+    /* We choose not to implement front-buffer-only configs */
+    c->base.doubleBufferMode = GL_TRUE;
 
     /* direct-mapped state */
 #define GET(attr, slot) \
@@ -320,7 +317,7 @@ translate_eglconfig(struct egl_screen *screen, EGLConfig hc,
 static __GLXconfig *
 egl_mirror_configs(ScreenPtr pScreen, struct egl_screen *screen)
 {
-    int i, j, k, nconfigs;
+    int i, j, nconfigs;
     struct egl_config *c = NULL;
     EGLConfig *host_configs = NULL;
     bool can_srgb = epoxy_has_gl_extension("GL_ARB_framebuffer_sRGB") ||
@@ -336,22 +333,20 @@ egl_mirror_configs(ScreenPtr pScreen, struct egl_screen *screen)
     /* We walk the EGL configs backwards to make building the
      * ->next chain easier.
      */
-    for (i = nconfigs - 1; i > 0; i--)
-        for (j = 0; j < 3; j++) /* direct_color */
-            for (k = 0; k < 2; k++) /* double_buffer */ {
-                if (can_srgb)
-                    c = translate_eglconfig(screen, host_configs[i], c,
-                                            /* direct_color */ j == 1,
-                                            /* double_buffer */ k > 0,
-                                            /* duplicate_for_composite */ j == 0,
-                                            /* srgb_only */ true);
-
+    for (i = nconfigs - 1; i > 0; i--) {
+        for (j = 0; j < 3; j++) { /* direct_color */
+            if (can_srgb)
                 c = translate_eglconfig(screen, host_configs[i], c,
                                         /* direct_color */ j == 1,
-                                        /* double_buffer */ k > 0,
                                         /* duplicate_for_composite */ j == 0,
-                                        /* srgb_only */ false);
-            }
+                                        /* srgb_only */ true);
+
+            c = translate_eglconfig(screen, host_configs[i], c,
+                                    /* direct_color */ j == 1,
+                                    /* duplicate_for_composite */ j == 0,
+                                    /* srgb_only */ false);
+        }
+    }
 
     screen->configs = host_configs;
     return c ? &c->base : NULL;
-- 
GitLab


From c19db1aa69437da82d52b50d18148a3f83571075 Mon Sep 17 00:00:00 2001
From: Konstantin Pugin <ria.freelander@gmail.com>
Date: Thu, 21 Jul 2022 00:49:13 +0300
Subject: [PATCH 4/5] xorg: initialize glamor provider

This allows Xorg to use Glamor GLX when Glamor is requested,
and eliminates usage of DRI2 in case of Glamor.

Signed-off-by: Konstantin Pugin <ria.freelander@gmail.com>
Reviewed-by: Adam Jackson <ajax@redhat.com>
Acked-by: Emma Anholt <emma@anholt.net>
---
 glamor/glamor_egl.c               | 11 +++++++++++
 hw/xfree86/glamor_egl/meson.build |  2 +-
 2 files changed, 12 insertions(+), 1 deletion(-)

diff --git a/glamor/glamor_egl.c b/glamor/glamor_egl.c
index 498f50519..69e0da123 100644
--- a/glamor/glamor_egl.c
+++ b/glamor/glamor_egl.c
@@ -46,6 +46,7 @@
 
 #include "glamor.h"
 #include "glamor_priv.h"
+#include "glamor_glx_provider.h"
 #include "dri3.h"
 
 struct glamor_egl_screen_private {
@@ -886,6 +887,9 @@ glamor_egl_screen_init(ScreenPtr screen, struct glamor_context *glamor_ctx)
         glamor_egl_get_screen_private(scrn);
 #ifdef DRI3
     glamor_screen_private *glamor_priv = glamor_get_screen_private(screen);
+#endif
+#ifdef GLXEXT
+    static Bool vendor_initialized = FALSE;
 #endif
     const char* gbm_backend_name;
 
@@ -927,6 +931,13 @@ glamor_egl_screen_init(ScreenPtr screen, struct glamor_context *glamor_ctx)
         }
     }
 #endif
+#ifdef GLXEXT
+    if(!vendor_initialized) {
+        GlxPushProvider(&glamor_provider);
+        xorgGlxCreateVendor();
+        vendor_initialized = TRUE;
+    }
+#endif
 }
 
 static void glamor_egl_cleanup(struct glamor_egl_screen_private *glamor_egl)
diff --git a/hw/xfree86/glamor_egl/meson.build b/hw/xfree86/glamor_egl/meson.build
index 7eae05812..dd1cafcd9 100644
--- a/hw/xfree86/glamor_egl/meson.build
+++ b/hw/xfree86/glamor_egl/meson.build
@@ -15,7 +15,7 @@ shared_module(
         dependency('libdrm', version: '>= 2.4.46'),
         gbm_dep,
     ],
-    link_with: glamor,
+    link_with: [glamor, libxserver_glx],
 
     install: true,
     install_dir: module_dir,
-- 
GitLab


From ef35452ea7a662e9c1c5290c74a9c36c116b99a6 Mon Sep 17 00:00:00 2001
From: Konstantin Pugin <ria.freelander@gmail.com>
Date: Mon, 1 Aug 2022 15:24:10 +0300
Subject: [PATCH 5/5] Xephyr: use glamor glx provider

Xephyr now gained an ability to use glamor glx provider.
Unfortunately, without DRI3, we end up with same llvmpipe as before

Signed-off-by: Konstantin Pugin <ria.freelander@gmail.com>
---
 glamor/glamor_egl_stubs.c      | 60 --------------------------------
 glamor/meson.build             |  6 ----
 hw/kdrive/ephyr/ephyr_glamor.c | 62 ++++++++++++++++++++++++++++++++++
 hw/kdrive/ephyr/hostx.c        | 51 ++++++++++++++++++++++++++++
 hw/kdrive/ephyr/meson.build    |  2 +-
 5 files changed, 114 insertions(+), 67 deletions(-)
 delete mode 100644 glamor/glamor_egl_stubs.c

diff --git a/glamor/glamor_egl_stubs.c b/glamor/glamor_egl_stubs.c
deleted file mode 100644
index 91ab9a7ae..000000000
--- a/glamor/glamor_egl_stubs.c
+++ /dev/null
@@ -1,60 +0,0 @@
-/*
- * Copyright © 2013 Intel Corporation
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice (including the next
- * paragraph) shall be included in all copies or substantial portions of the
- * Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
- * IN THE SOFTWARE.
- */
-
-/** @file glamor_egl_stubs.c
- *
- * Stubbed out glamor_egl.c functions for servers other than Xorg.
- */
-
-#include "dix-config.h"
-
-#include "glamor.h"
-
-void
-glamor_egl_screen_init(ScreenPtr screen, struct glamor_context *glamor_ctx)
-{
-}
-
-int
-glamor_egl_fd_name_from_pixmap(ScreenPtr screen,
-                               PixmapPtr pixmap,
-                               CARD16 *stride, CARD32 *size)
-{
-    return -1;
-}
-
-
-int
-glamor_egl_fds_from_pixmap(ScreenPtr screen, PixmapPtr pixmap, int *fds,
-                           uint32_t *offsets, uint32_t *strides,
-                           uint64_t *modifier)
-{
-    return 0;
-}
-
-int
-glamor_egl_fd_from_pixmap(ScreenPtr screen, PixmapPtr pixmap,
-                          CARD16 *stride, CARD32 *size)
-{
-    return -1;
-}
diff --git a/glamor/meson.build b/glamor/meson.build
index d4cb1859a..2ae522aec 100644
--- a/glamor/meson.build
+++ b/glamor/meson.build
@@ -51,12 +51,6 @@ glamor = static_library('glamor',
     ],
 )
 
-glamor_egl_stubs = static_library('glamor_egl_stubs',
-    'glamor_egl_stubs.c',
-    include_directories: inc,
-    dependencies: common_dep,
-)
-
 if build_xorg
     install_data('glamor.h', install_dir: xorgsdkdir)
 endif
diff --git a/hw/kdrive/ephyr/ephyr_glamor.c b/hw/kdrive/ephyr/ephyr_glamor.c
index 724611d69..772b73052 100644
--- a/hw/kdrive/ephyr/ephyr_glamor.c
+++ b/hw/kdrive/ephyr/ephyr_glamor.c
@@ -25,14 +25,18 @@
  *
  * Glamor support and EGL setup.
  */
+#define MESA_EGL_NO_X11_HEADERS
+#define EGL_NO_X11
 
 #include <stdlib.h>
 #include <stdint.h>
 #include <xcb/xcb.h>
 #include <xcb/xcb_aux.h>
 #include <pixman.h>
+#include "glamor_context.h"
 #include "glamor_egl.h"
 #include "glamor_priv.h"
+#include "ephyr.h"
 #include "ephyr_glamor.h"
 #include "os.h"
 
@@ -69,6 +73,64 @@ struct ephyr_glamor {
     GLuint vao, vbo;
 };
 
+static void
+glamor_egl_make_current(struct glamor_context *glamor_ctx)
+{
+    /* There's only a single global dispatch table in Mesa.  EGL, GLX,
+     * and AIGLX's direct dispatch table manipulation don't talk to
+     * each other.  We need to set the context to NULL first to avoid
+     * EGL's no-op context change fast path when switching back to
+     * EGL.
+     */
+    eglMakeCurrent(glamor_ctx->display, EGL_NO_SURFACE,
+                   EGL_NO_SURFACE, EGL_NO_CONTEXT);
+
+    if (!eglMakeCurrent(glamor_ctx->display,
+                        glamor_ctx->surface, glamor_ctx->surface,
+                        glamor_ctx->ctx)) {
+        FatalError("Failed to make EGL context current\n");
+    }
+}
+
+void
+glamor_egl_screen_init(ScreenPtr screen, struct glamor_context *glamor_ctx)
+{
+    KdScreenPriv(screen);
+    KdScreenInfo *kd_screen = pScreenPriv->screen;
+    EphyrScrPriv *scrpriv = kd_screen->driver;
+    struct ephyr_glamor *ephyr_glamor = scrpriv->glamor;
+
+    glamor_enable_dri3(screen);
+    glamor_ctx->display = ephyr_glamor->dpy;
+    glamor_ctx->ctx = ephyr_glamor->ctx;
+    glamor_ctx->surface = ephyr_glamor->egl_win;
+    glamor_ctx->make_current = glamor_egl_make_current;
+}
+
+int
+glamor_egl_fd_name_from_pixmap(ScreenPtr screen,
+                               PixmapPtr pixmap,
+                               CARD16 *stride, CARD32 *size)
+{
+    return -1;
+}
+
+
+int
+glamor_egl_fds_from_pixmap(ScreenPtr screen, PixmapPtr pixmap, int *fds,
+                           uint32_t *offsets, uint32_t *strides,
+                           uint64_t *modifier)
+{
+    return 0;
+}
+
+int
+glamor_egl_fd_from_pixmap(ScreenPtr screen, PixmapPtr pixmap,
+                          CARD16 *stride, CARD32 *size)
+{
+    return -1;
+}
+
 static GLuint
 ephyr_glamor_build_glsl_prog(GLuint vs, GLuint fs)
 {
diff --git a/hw/kdrive/ephyr/hostx.c b/hw/kdrive/ephyr/hostx.c
index 1dc14be38..70e9d65ab 100644
--- a/hw/kdrive/ephyr/hostx.c
+++ b/hw/kdrive/ephyr/hostx.c
@@ -55,8 +55,11 @@
 #include <xcb/randr.h>
 #include <xcb/xkb.h>
 #ifdef GLAMOR
+#include <xcb/glx.h>
+#include <epoxy/common.h>
 #include <epoxy/gl.h>
 #include "glamor.h"
+#include "glamor_glx_provider.h"
 #include "ephyr_glamor.h"
 #endif
 #include "ephyrlog.h"
@@ -83,6 +86,7 @@ struct EphyrHostXVars {
 
     long damage_debug_msec;
     Bool size_set_from_configure;
+    char* glvnd_vendor;
 };
 
 /* memset ( missing> ) instead of below  */
@@ -1551,12 +1555,47 @@ out:
 }
 
 #ifdef GLAMOR
+
+#ifndef GLX_EXTENSIONS
+#define GLX_EXTENSIONS          3
+#endif
+
+#ifndef GLX_VENDOR_NAMES_EXT
+#define GLX_VENDOR_NAMES_EXT 0x20F6
+#endif
+
+/**
+ * Exchange a protocol request for glXQueryServerString.
+ */
+static char *
+__glXQueryServerString(CARD32 name)
+{
+   xcb_glx_query_server_string_reply_t *reply =
+      xcb_glx_query_server_string_reply(HostX.conn,
+                                        xcb_glx_query_server_string(HostX.conn,
+                                                                    HostX.screen,
+                                                                    name),
+                                        NULL);
+
+   /* The spec doesn't mention this, but the Xorg server replies with
+    * a string already terminated with '\0'. */
+   uint32_t len = xcb_glx_query_server_string_string_length(reply);
+   char *buf = malloc(len);
+   memcpy(buf, xcb_glx_query_server_string_string(reply), len);
+   free(reply);
+
+   return buf;
+}
+
 Bool
 ephyr_glamor_init(ScreenPtr screen)
 {
     KdScreenPriv(screen);
     KdScreenInfo *kd_screen = pScreenPriv->screen;
     EphyrScrPriv *scrpriv = kd_screen->driver;
+    char* hostx_glx_exts = NULL;
+    char* glvnd_vendors = NULL;
+    char* saveptr = NULL;
 
     scrpriv->glamor = ephyr_glamor_screen_init(scrpriv->win, scrpriv->vid);
     ephyr_glamor_set_window_size(scrpriv->glamor,
@@ -1566,6 +1605,18 @@ ephyr_glamor_init(ScreenPtr screen)
         FatalError("Failed to initialize glamor\n");
         return FALSE;
     }
+    hostx_glx_exts = __glXQueryServerString(GLX_EXTENSIONS);
+    if(epoxy_extension_in_string(hostx_glx_exts,"GLX_EXT_libglvnd"))
+        glvnd_vendors = __glXQueryServerString(GLX_VENDOR_NAMES_EXT);
+
+    if(glvnd_vendors) {
+        HostX.glvnd_vendor = strtok_r(glvnd_vendors, " ", &saveptr);
+        glamor_set_glvnd_vendor(screen, HostX.glvnd_vendor);
+        free(glvnd_vendors);
+    }
+    free(hostx_glx_exts);
+    
+    GlxPushProvider(&glamor_provider);
 
     return TRUE;
 }
diff --git a/hw/kdrive/ephyr/meson.build b/hw/kdrive/ephyr/meson.build
index dff1dfb68..148b82cef 100644
--- a/hw/kdrive/ephyr/meson.build
+++ b/hw/kdrive/ephyr/meson.build
@@ -28,8 +28,8 @@ if build_glamor
         srcs += 'ephyr_glamor_xv.c'
     endif
     xephyr_glamor += glamor
-    xephyr_glamor += glamor_egl_stubs
     xephyr_dep += epoxy_dep
+    xephyr_dep += dependency('xcb-glx')
 endif
 
 if build_xv
-- 
GitLab

