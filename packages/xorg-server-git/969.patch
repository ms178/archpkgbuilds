From 5a337fe68eeccc9fe40d463f28bcda5948675278 Mon Sep 17 00:00:00 2001
From: Austin Shafer <ashafer@nvidia.com>
Date: Fri, 2 Sep 2022 11:54:05 -0400
Subject: [PATCH 1/4] Add libdrm 2.4.109 requirement

---
 .gitlab-ci.yml               | 2 +-
 .gitlab-ci/debian-install.sh | 8 ++++++++
 meson.build                  | 2 +-
 3 files changed, 10 insertions(+), 2 deletions(-)

diff --git a/.gitlab-ci.yml b/.gitlab-ci.yml
index 22769a047..b1e725331 100644
--- a/.gitlab-ci.yml
+++ b/.gitlab-ci.yml
@@ -19,7 +19,7 @@ variables:
     FDO_UPSTREAM_REPO: xorg/xserver
     FDO_DISTRIBUTION_VERSION: bullseye-slim
     FDO_DISTRIBUTION_EXEC: 'env FDO_CI_CONCURRENT=${FDO_CI_CONCURRENT} bash .gitlab-ci/debian-install.sh'
-    FDO_DISTRIBUTION_TAG: "2022-11-24-new-wayland-protocols"
+    FDO_DISTRIBUTION_TAG: "2023-01-25-libdrm-update"
 
 include:
   - project: 'freedesktop/ci-templates'
diff --git a/.gitlab-ci/debian-install.sh b/.gitlab-ci/debian-install.sh
index 5fca4c625..62c292be5 100644
--- a/.gitlab-ci/debian-install.sh
+++ b/.gitlab-ci/debian-install.sh
@@ -113,6 +113,14 @@ apt-get install -y \
 
 cd /root
 
+# Xwayland requires drm 2.4.109 for drmGetDeviceFromDevId
+git clone https://gitlab.freedesktop.org/mesa/drm --depth 1 --branch=libdrm-2.4.109
+cd drm
+meson _build
+ninja -C _build -j${FDO_CI_CONCURRENT:-4} install
+cd ..
+rm -rf drm
+
 # xserver requires libxcvt
 git clone https://gitlab.freedesktop.org/xorg/lib/libxcvt.git --depth 1 --branch=libxcvt-0.1.0
 cd libxcvt
diff --git a/meson.build b/meson.build
index 01e22b6a9..c681f157d 100644
--- a/meson.build
+++ b/meson.build
@@ -60,7 +60,7 @@ endforeach
 
 add_project_arguments(common_wflags, language : ['c', 'objc'])
 
-libdrm_req = '>= 2.4.89'
+libdrm_req = '>= 2.4.109'
 libselinux_req = '>= 2.0.86'
 xext_req = '>= 1.0.99.4'
 wayland_req = '>= 1.18.0'
-- 
GitLab


From 45fcf92d3cea5e1460f497f0bcbbefb145f9cd28 Mon Sep 17 00:00:00 2001
From: Austin Shafer <ashafer@nvidia.com>
Date: Wed, 15 Dec 2021 13:11:30 -0500
Subject: [PATCH 2/4] xwl: Use linux_dmabuf to get the DRM device name

This avoids using wl_drm now that linux_dmabuf is powerful enough
---
 hw/xwayland/xwayland-glamor-gbm.c | 132 +++++++++++++++++++++---------
 1 file changed, 92 insertions(+), 40 deletions(-)

diff --git a/hw/xwayland/xwayland-glamor-gbm.c b/hw/xwayland/xwayland-glamor-gbm.c
index 205d2feb3..2be2d56c8 100644
--- a/hw/xwayland/xwayland-glamor-gbm.c
+++ b/hw/xwayland/xwayland-glamor-gbm.c
@@ -53,14 +53,16 @@
 #include "linux-dmabuf-unstable-v1-client-protocol.h"
 
 struct xwl_gbm_private {
-    dev_t device;
-    char *device_name;
     struct gbm_device *gbm;
-    struct wl_drm *drm;
-    int drm_fd;
-    int fd_render_node;
-    Bool drm_authenticated;
-    uint32_t capabilities;
+    struct {
+        dev_t device;
+        char *device_name;
+        struct wl_drm *drm;
+        int drm_fd;
+        int fd_render_node;
+        Bool drm_authenticated;
+        uint32_t capabilities;
+    } drm_priv;
     int dmabuf_capable;
 };
 
@@ -436,7 +438,7 @@ xwl_glamor_gbm_get_wl_buffer_for_pixmap(PixmapPtr pixmap)
         zwp_linux_buffer_params_v1_destroy(params);
     } else if (num_planes == 1) {
         xwl_pixmap->buffer =
-            wl_drm_create_prime_buffer(xwl_gbm->drm, prime_fds[0], width, height,
+            wl_drm_create_prime_buffer(xwl_gbm->drm_priv.drm, prime_fds[0], width, height,
                                        format,
                                        0, gbm_bo_get_stride(xwl_pixmap->bo),
                                        0, 0,
@@ -458,12 +460,12 @@ xwl_glamor_gbm_cleanup(struct xwl_screen *xwl_screen)
 {
     struct xwl_gbm_private *xwl_gbm = xwl_gbm_get(xwl_screen);
 
-    if (xwl_gbm->device_name)
-        free(xwl_gbm->device_name);
-    if (xwl_gbm->drm_fd)
-        close(xwl_gbm->drm_fd);
-    if (xwl_gbm->drm)
-        wl_drm_destroy(xwl_gbm->drm);
+    if (xwl_gbm->drm_priv.device_name)
+        free(xwl_gbm->drm_priv.device_name);
+    if (xwl_gbm->drm_priv.drm_fd)
+        close(xwl_gbm->drm_priv.drm_fd);
+    if (xwl_gbm->drm_priv.drm)
+        wl_drm_destroy(xwl_gbm->drm_priv.drm);
     if (xwl_gbm->gbm)
         gbm_device_destroy(xwl_gbm->gbm);
 
@@ -523,6 +525,23 @@ static const struct wl_callback_listener sync_listener = {
    sync_callback
 };
 
+
+static char *
+xwl_find_drm_node_by_devid(dev_t devid)
+{
+    drmDevicePtr drm_dev;
+    char *name = NULL;
+
+    if (drmGetDeviceFromDevId(devid, 0, &drm_dev))
+        return NULL;
+
+    if (!(drm_dev->available_nodes & (1 << DRM_NODE_RENDER)))
+        name = strdup(drm_dev->nodes[DRM_NODE_RENDER]);
+
+    drmFreeDevice(&drm_dev);
+    return name;
+}
+
 static int
 xwl_dri3_open_client(ClientPtr client,
                      ScreenPtr screen,
@@ -534,11 +553,30 @@ xwl_dri3_open_client(ClientPtr client,
     struct xwl_auth_state *state;
     drm_magic_t magic;
     int fd;
+    char *drm_dev_name;
 
-    fd = open(xwl_gbm->device_name, O_RDWR | O_CLOEXEC);
+    /*
+     * Try to use the latest linux_dmabuf protocol's default main device.
+     * If it is not available or if something went wrong, fall back to using
+     * the device provided by wl_drm
+     */
+    if (xwl_screen->dmabuf_protocol_version >= 4) {
+        drm_dev_name = xwl_find_drm_node_by_devid(xwl_screen->default_feedback.main_dev);
+        if (drm_dev_name) {
+            fd = open(drm_dev_name, O_RDWR | O_CLOEXEC);
+            free(drm_dev_name);
+            if (fd < 0)
+                return BadAlloc;
+
+            *pfd = fd;
+            return Success;
+        }
+    }
+
+    fd = open(xwl_gbm->drm_priv.device_name, O_RDWR | O_CLOEXEC);
     if (fd < 0)
         return BadAlloc;
-    if (xwl_gbm->fd_render_node) {
+    if (xwl_gbm->drm_priv.fd_render_node) {
         *pfd = fd;
         return Success;
     }
@@ -558,7 +596,7 @@ xwl_dri3_open_client(ClientPtr client,
         return BadMatch;
     }
 
-    wl_drm_authenticate(xwl_gbm->drm, magic);
+    wl_drm_authenticate(xwl_gbm->drm_priv.drm, magic);
     state->callback = wl_display_sync(xwl_screen->display);
     wl_callback_add_listener(state->callback, &sync_listener, state);
     dixSetPrivate(&client->devPrivates, &xwl_auth_state_private_key, state);
@@ -790,36 +828,36 @@ xwl_drm_handle_device(void *data, struct wl_drm *drm, const char *device)
        render_node_path = get_render_node_path(device);
 
    if (render_node_path)
-       xwl_gbm->device_name = render_node_path;
+       xwl_gbm->drm_priv.device_name = render_node_path;
    else
-       xwl_gbm->device_name = strdup(device);
+       xwl_gbm->drm_priv.device_name = strdup(device);
 
-   if (!xwl_gbm->device_name) {
+   if (!xwl_gbm->drm_priv.device_name) {
        xwl_glamor_gbm_cleanup(xwl_screen);
        return;
    }
 
-   xwl_gbm->drm_fd = open(xwl_gbm->device_name, O_RDWR | O_CLOEXEC);
-   if (xwl_gbm->drm_fd == -1) {
+   xwl_gbm->drm_priv.drm_fd = open(xwl_gbm->drm_priv.device_name, O_RDWR | O_CLOEXEC);
+   if (xwl_gbm->drm_priv.drm_fd == -1) {
        ErrorF("wayland-egl: could not open %s (%s)\n",
-              xwl_gbm->device_name, strerror(errno));
+              xwl_gbm->drm_priv.device_name, strerror(errno));
        xwl_glamor_gbm_cleanup(xwl_screen);
        return;
    }
 
-   if (fstat(xwl_gbm->drm_fd, &stat)) {
+   if (fstat(xwl_gbm->drm_priv.drm_fd, &stat)) {
        ErrorF("wayland-egl: Could not stat file %s (%s)\n",
-              xwl_gbm->device_name, strerror(errno));
+              xwl_gbm->drm_priv.device_name, strerror(errno));
        return;
    }
-   xwl_gbm->device = stat.st_rdev;
+   xwl_gbm->drm_priv.device = stat.st_rdev;
 
-   if (drmGetNodeTypeFromFd(xwl_gbm->drm_fd) == DRM_NODE_RENDER) {
-       xwl_gbm->fd_render_node = 1;
+   if (drmGetNodeTypeFromFd(xwl_gbm->drm_priv.drm_fd) == DRM_NODE_RENDER) {
+       xwl_gbm->drm_priv.fd_render_node = 1;
        xwl_screen->expecting_event--;
    } else {
-       drmGetMagic(xwl_gbm->drm_fd, &magic);
-       wl_drm_authenticate(xwl_gbm->drm, magic);
+       drmGetMagic(xwl_gbm->drm_priv.drm_fd, &magic);
+       wl_drm_authenticate(xwl_gbm->drm_priv.drm, magic);
    }
 }
 
@@ -834,14 +872,14 @@ xwl_drm_handle_authenticated(void *data, struct wl_drm *drm)
     struct xwl_screen *xwl_screen = data;
     struct xwl_gbm_private *xwl_gbm = xwl_gbm_get(xwl_screen);
 
-    xwl_gbm->drm_authenticated = TRUE;
+    xwl_gbm->drm_priv.drm_authenticated = TRUE;
     xwl_screen->expecting_event--;
 }
 
 static void
 xwl_drm_handle_capabilities(void *data, struct wl_drm *drm, uint32_t value)
 {
-    xwl_gbm_get(data)->capabilities = value;
+    xwl_gbm_get(data)->drm_priv.capabilities = value;
 }
 
 static const struct wl_drm_listener xwl_drm_listener = {
@@ -860,9 +898,9 @@ xwl_screen_set_drm_interface(struct xwl_screen *xwl_screen,
     if (version < 2)
         return FALSE;
 
-    xwl_gbm->drm =
+    xwl_gbm->drm_priv.drm =
         wl_registry_bind(xwl_screen->registry, id, &wl_drm_interface, 2);
-    wl_drm_add_listener(xwl_gbm->drm, &xwl_drm_listener, xwl_screen);
+    wl_drm_add_listener(xwl_gbm->drm_priv.drm, &xwl_drm_listener, xwl_screen);
     xwl_screen->expecting_event++;
 
     return TRUE;
@@ -898,7 +936,7 @@ xwl_glamor_gbm_has_wl_interfaces(struct xwl_screen *xwl_screen)
 {
     struct xwl_gbm_private *xwl_gbm = xwl_gbm_get(xwl_screen);
 
-    if (xwl_gbm->drm == NULL) {
+    if (xwl_gbm->drm_priv.drm == NULL) {
         LogMessageVerb(X_INFO, 3, "glamor: 'wl_drm' not supported\n");
         return FALSE;
     }
@@ -1004,13 +1042,27 @@ xwl_glamor_gbm_init_egl(struct xwl_screen *xwl_screen)
     EGLint major, minor;
     const GLubyte *renderer;
     const char *gbm_backend_name;
+    char *drm_dev_name;
+    int fd;
 
-    if (!xwl_gbm->fd_render_node && !xwl_gbm->drm_authenticated) {
+    if (xwl_screen->dmabuf_protocol_version < 4
+        && !xwl_gbm->drm_priv.fd_render_node && !xwl_gbm->drm_priv.drm_authenticated) {
         ErrorF("Failed to get wl_drm, disabling Glamor and DRI3\n");
-	return FALSE;
+        return FALSE;
+    }
+
+    fd = xwl_gbm->drm_priv.drm_fd;
+    if (xwl_screen->dmabuf_protocol_version >= 4) {
+        drm_dev_name = xwl_find_drm_node_by_devid(xwl_screen->default_feedback.main_dev);
+        if (drm_dev_name) {
+            fd = open(drm_dev_name, O_RDWR | O_CLOEXEC);
+            free(drm_dev_name);
+            if (fd < 0)
+                return BadAlloc;
+        }
     }
 
-    xwl_gbm->gbm = gbm_create_device(xwl_gbm->drm_fd);
+    xwl_gbm->gbm = gbm_create_device(fd);
     if (!xwl_gbm->gbm) {
         ErrorF("couldn't create gbm device\n");
         goto error;
@@ -1086,7 +1138,7 @@ xwl_glamor_gbm_init_screen(struct xwl_screen *xwl_screen)
         goto error;
     }
 
-    if (xwl_gbm->fd_render_node)
+    if (xwl_gbm->drm_priv.fd_render_node || xwl_screen->dmabuf_protocol_version >= 4)
         goto skip_drm_auth;
 
     if (!dixRegisterPrivateKey(&xwl_auth_state_private_key, PRIVATE_CLIENT,
@@ -1115,7 +1167,7 @@ static dev_t xwl_gbm_get_main_device(struct xwl_screen *xwl_screen)
 {
     struct xwl_gbm_private *xwl_gbm = xwl_gbm_get(xwl_screen);
 
-    return xwl_gbm->device;
+    return xwl_gbm->drm_priv.device;
 }
 
 void
-- 
GitLab


From fdebe563472bd1e60408776c4c3ac7c6b2100ee8 Mon Sep 17 00:00:00 2001
From: Austin Shafer <ashafer@nvidia.com>
Date: Thu, 16 Dec 2021 13:19:00 -0500
Subject: [PATCH 3/4] Add Gitlab CI support for dri3 1.3

---
 .gitlab-ci.yml                    |  2 +-
 .gitlab-ci/cross-prereqs-build.sh |  4 ++--
 .gitlab-ci/debian-install.sh      | 14 ++++++++++++++
 3 files changed, 17 insertions(+), 3 deletions(-)

diff --git a/.gitlab-ci.yml b/.gitlab-ci.yml
index b1e725331..9b41ef112 100644
--- a/.gitlab-ci.yml
+++ b/.gitlab-ci.yml
@@ -19,7 +19,7 @@ variables:
     FDO_UPSTREAM_REPO: xorg/xserver
     FDO_DISTRIBUTION_VERSION: bullseye-slim
     FDO_DISTRIBUTION_EXEC: 'env FDO_CI_CONCURRENT=${FDO_CI_CONCURRENT} bash .gitlab-ci/debian-install.sh'
-    FDO_DISTRIBUTION_TAG: "2023-01-25-libdrm-update"
+    FDO_DISTRIBUTION_TAG: "2023-01-25-DRI3-updates"
 
 include:
   - project: 'freedesktop/ci-templates'
diff --git a/.gitlab-ci/cross-prereqs-build.sh b/.gitlab-ci/cross-prereqs-build.sh
index c3502e932..d1b19bb82 100755
--- a/.gitlab-ci/cross-prereqs-build.sh
+++ b/.gitlab-ci/cross-prereqs-build.sh
@@ -49,9 +49,9 @@ build 'https://gitlab.freedesktop.org/pixman/pixman.git' 'pixman-0.38.4'
 build 'https://gitlab.freedesktop.org/xorg/lib/pthread-stubs.git' '0.4'
 # we can't use the xorgproto pkgconfig files from /usr/share/pkgconfig, because
 # these would add -I/usr/include to CFLAGS, which breaks cross-compilation
-build 'https://gitlab.freedesktop.org/xorg/proto/xorgproto.git' 'xorgproto-2021.4.99.2' '--datadir=/lib'
+build 'https://gitlab.freedesktop.org/xorg/proto/xorgproto.git' 'xorgproto-2022.2' '--datadir=/lib'
 build 'https://gitlab.freedesktop.org/xorg/lib/libXau.git' 'libXau-1.0.9'
-build 'https://gitlab.freedesktop.org/xorg/proto/xcbproto.git' 'xcb-proto-1.14.1'
+build 'https://gitlab.freedesktop.org/xorg/proto/xcbproto.git' 'xcb-proto-1.15.1'
 build 'https://gitlab.freedesktop.org/xorg/lib/libxcb.git' 'libxcb-1.14'
 build 'https://gitlab.freedesktop.org/xorg/lib/libxtrans.git' 'xtrans-1.4.0'
 # the default value of keysymdefdir is taken from the includedir variable for
diff --git a/.gitlab-ci/debian-install.sh b/.gitlab-ci/debian-install.sh
index 62c292be5..16198e3e0 100644
--- a/.gitlab-ci/debian-install.sh
+++ b/.gitlab-ci/debian-install.sh
@@ -166,6 +166,20 @@ cd piglit
 git checkout 265896c86f90cb72e8f218ba6a3617fca8b9a1e3
 cd ..
 
+git clone https://gitlab.freedesktop.org/xorg/proto/xcbproto --depth=1 --branch=xcb-proto-1.15.1
+pushd xcbproto
+./autogen.sh
+make -j${FDO_CI_CONCURRENT:-4} install
+popd
+rm -rf xcbproto
+
+git clone https://gitlab.freedesktop.org/xorg/lib/libxcb --depth=1
+pushd libxcb
+./autogen.sh
+make -j${FDO_CI_CONCURRENT:-4} install
+popd
+rm -rf libxcb
+
 git clone https://gitlab.freedesktop.org/xorg/test/xts
 cd xts
 git checkout dbbfa96c036e596346147081cbceda136e7c86c1
-- 
GitLab


From 12ec3c4d4900bfff0247bc21e456141ba35a3ffc Mon Sep 17 00:00:00 2001
From: Austin Shafer <ashafer@nvidia.com>
Date: Wed, 1 Dec 2021 10:30:18 -0500
Subject: [PATCH 4/4] DRI3: Add support for DRI3 v1.3

This add the DRI3SetDRMDeviceInUse request, and implements it. This
request is only used in Xwayland, and is a hint to notify us
what device to return modifiers for.
---
 dri3/dri3.h                             |  5 +++
 dri3/dri3_priv.h                        |  5 +++
 dri3/dri3_request.c                     | 18 +++++++++++
 dri3/dri3_screen.c                      | 16 ++++++++++
 glamor/glamor_egl.c                     |  2 ++
 hw/xwayland/xwayland-glamor-eglstream.c |  1 +
 hw/xwayland/xwayland-glamor-gbm.c       |  1 +
 hw/xwayland/xwayland-glamor.c           | 41 +++++++++++++++++++++++--
 hw/xwayland/xwayland-glamor.h           |  1 +
 hw/xwayland/xwayland-window.h           |  7 +++++
 meson.build                             |  2 +-
 11 files changed, 95 insertions(+), 4 deletions(-)

diff --git a/dri3/dri3.h b/dri3/dri3.h
index 02d3b03ee..d1fd6a7f2 100644
--- a/dri3/dri3.h
+++ b/dri3/dri3.h
@@ -84,6 +84,10 @@ typedef int (*dri3_get_drawable_modifiers_proc) (DrawablePtr draw,
                                                  uint32_t *num_modifiers,
                                                  uint64_t **modifiers);
 
+typedef int (*dri3_set_drm_device_in_use_proc) (WindowPtr window,
+                                                uint32_t drmMajor,
+                                                uint32_t drmMinor);
+
 typedef struct dri3_screen_info {
     uint32_t                    version;
 
@@ -100,6 +104,7 @@ typedef struct dri3_screen_info {
     dri3_get_formats_proc       get_formats;
     dri3_get_modifiers_proc     get_modifiers;
     dri3_get_drawable_modifiers_proc get_drawable_modifiers;
+    dri3_set_drm_device_in_use_proc set_drm_device_in_use;
 
 } dri3_screen_info_rec, *dri3_screen_info_ptr;
 
diff --git a/dri3/dri3_priv.h b/dri3/dri3_priv.h
index f319d1770..7e1d919af 100644
--- a/dri3/dri3_priv.h
+++ b/dri3/dri3_priv.h
@@ -102,4 +102,9 @@ dri3_get_supported_modifiers(ScreenPtr screen, DrawablePtr drawable,
                              CARD32 *num_screen_modifiers,
                              CARD64 **screen_modifiers);
 
+int
+dri3_set_drm_device_in_use(WindowPtr window,
+                           CARD32 drmMajor,
+                           CARD32 drmMinor);
+
 #endif /* _DRI3PRIV_H_ */
diff --git a/dri3/dri3_request.c b/dri3/dri3_request.c
index 687168930..f71282ad7 100644
--- a/dri3/dri3_request.c
+++ b/dri3/dri3_request.c
@@ -554,6 +554,23 @@ proc_dri3_buffers_from_pixmap(ClientPtr client)
     return Success;
 }
 
+static int
+proc_dri3_set_drm_device_in_use(ClientPtr client)
+{
+    REQUEST(xDRI3SetDRMDeviceInUseReq);
+    WindowPtr window;
+    int status;
+
+    REQUEST_SIZE_MATCH(xDRI3SetDRMDeviceInUseReq);
+
+    status = dixLookupWindow(&window, stuff->window, client,
+                               DixGetAttrAccess);
+    if (status != Success)
+        return status;
+
+    return dri3_set_drm_device_in_use(window, stuff->drmMajor, stuff->drmMinor);
+}
+
 int (*proc_dri3_vector[DRI3NumberRequests]) (ClientPtr) = {
     proc_dri3_query_version,            /* 0 */
     proc_dri3_open,                     /* 1 */
@@ -564,6 +581,7 @@ int (*proc_dri3_vector[DRI3NumberRequests]) (ClientPtr) = {
     proc_dri3_get_supported_modifiers,  /* 6 */
     proc_dri3_pixmap_from_buffers,      /* 7 */
     proc_dri3_buffers_from_pixmap,      /* 8 */
+    proc_dri3_set_drm_device_in_use,    /* 9 */
 };
 
 int
diff --git a/dri3/dri3_screen.c b/dri3/dri3_screen.c
index bc96e5339..37b938565 100644
--- a/dri3/dri3_screen.c
+++ b/dri3/dri3_screen.c
@@ -272,3 +272,19 @@ dri3_get_supported_modifiers(ScreenPtr screen, DrawablePtr drawable,
 
     return Success;
 }
+
+int
+dri3_set_drm_device_in_use(WindowPtr window,
+                           CARD32 drmMajor,
+                           CARD32 drmMinor)
+{
+    dri3_screen_priv_ptr        ds = dri3_screen_priv(window->drawable.pScreen);
+    const dri3_screen_info_rec *info = ds->info;
+
+    if (info->set_drm_device_in_use &&
+        !info->set_drm_device_in_use(window, drmMajor, drmMinor)) {
+        return BadWindow;
+    }
+
+    return Success;
+}
diff --git a/glamor/glamor_egl.c b/glamor/glamor_egl.c
index c35b10d83..b7c1002bd 100644
--- a/glamor/glamor_egl.c
+++ b/glamor/glamor_egl.c
@@ -875,6 +875,8 @@ static const dri3_screen_info_rec glamor_dri3_info = {
     .get_formats = glamor_get_formats,
     .get_modifiers = glamor_get_modifiers,
     .get_drawable_modifiers = glamor_get_drawable_modifiers,
+    /* this is only needed in xwayland */
+    .set_drm_device_in_use = NULL,
 };
 #endif /* DRI3 */
 
diff --git a/hw/xwayland/xwayland-glamor-eglstream.c b/hw/xwayland/xwayland-glamor-eglstream.c
index c911ed987..dd8eeadf4 100644
--- a/hw/xwayland/xwayland-glamor-eglstream.c
+++ b/hw/xwayland/xwayland-glamor-eglstream.c
@@ -933,6 +933,7 @@ static const dri3_screen_info_rec xwl_dri3_info = {
     .get_formats = xwl_glamor_get_formats,
     .get_modifiers = xwl_glamor_get_modifiers,
     .get_drawable_modifiers = xwl_glamor_get_drawable_modifiers,
+    .set_drm_device_in_use = xwl_set_drm_device_in_use,
 };
 
 static Bool
diff --git a/hw/xwayland/xwayland-glamor-gbm.c b/hw/xwayland/xwayland-glamor-gbm.c
index 2be2d56c8..6fa1fec8c 100644
--- a/hw/xwayland/xwayland-glamor-gbm.c
+++ b/hw/xwayland/xwayland-glamor-gbm.c
@@ -755,6 +755,7 @@ static const dri3_screen_info_rec xwl_dri3_info = {
     .get_formats = xwl_glamor_get_formats,
     .get_modifiers = xwl_glamor_get_modifiers,
     .get_drawable_modifiers = xwl_glamor_get_drawable_modifiers,
+    .set_drm_device_in_use = xwl_set_drm_device_in_use,
 };
 
 static const char *
diff --git a/hw/xwayland/xwayland-glamor.c b/hw/xwayland/xwayland-glamor.c
index 6c7784efb..2edf3e5c6 100644
--- a/hw/xwayland/xwayland-glamor.c
+++ b/hw/xwayland/xwayland-glamor.c
@@ -46,6 +46,13 @@
 
 #include <sys/mman.h>
 
+#include <xf86drm.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#if defined(__linux__)
+#include <sys/sysmacros.h>
+#endif
+
 static void
 glamor_egl_make_current(struct glamor_context *glamor_ctx)
 {
@@ -386,11 +393,39 @@ xwl_glamor_get_drawable_modifiers(DrawablePtr drawable, uint32_t format,
     if (!xwl_window)
         return FALSE;
 
-    main_dev = xwl_screen_get_main_dev(xwl_screen);
+    /*
+     * If we have a drm device specified by the client, query the mods for
+     * that device. Otherwise get the modifiers for the default device for
+     * this window.
+     */
+    if (xwl_window->drm_dev_in_use_set) {
+        return xwl_get_modifiers_for_device(&xwl_window->feedback, xwl_window->drm_dev_in_use,
+                                            format, num_modifiers, modifiers);
+    } else {
+        main_dev = xwl_screen_get_main_dev(xwl_screen);
+
+        return xwl_get_modifiers_for_device(&xwl_window->feedback, main_dev,
+                                            format, num_modifiers, modifiers);
+    }
+}
+
+Bool
+xwl_set_drm_device_in_use(WindowPtr window, uint32_t drmMajor, uint32_t drmMinor)
+{
+    struct xwl_window *xwl_window = xwl_window_from_window(window);
+
+    /*
+     * It's possible this function will be called without a
+     * xwl_window ever being created for this WindowPtr. In this
+     * case this isn't an error, we just ignore it.
+     */
+    if (!xwl_window)
+        return TRUE;
 
-    return xwl_get_modifiers_for_device(&xwl_window->feedback, main_dev,
-                                        format, num_modifiers, modifiers);
+    xwl_window->drm_dev_in_use = makedev(drmMajor, drmMinor);
+    xwl_window->drm_dev_in_use_set = 1;
 
+    return TRUE;
 }
 
 static void
diff --git a/hw/xwayland/xwayland-glamor.h b/hw/xwayland/xwayland-glamor.h
index ed9ec40de..1e13fd12c 100644
--- a/hw/xwayland/xwayland-glamor.h
+++ b/hw/xwayland/xwayland-glamor.h
@@ -136,6 +136,7 @@ Bool xwl_glamor_get_formats(ScreenPtr screen,
                             CARD32 *num_formats, CARD32 **formats);
 Bool xwl_glamor_get_modifiers(ScreenPtr screen, uint32_t format,
                               uint32_t *num_modifiers, uint64_t **modifiers);
+Bool xwl_set_drm_device_in_use(WindowPtr window, uint32_t drmMajor, uint32_t drmMinor);
 Bool xwl_glamor_get_drawable_modifiers(DrawablePtr drawable, uint32_t format,
                                        uint32_t *num_modifiers, uint64_t **modifiers);
 Bool xwl_glamor_check_flip(PixmapPtr pixmap);
diff --git a/hw/xwayland/xwayland-window.h b/hw/xwayland/xwayland-window.h
index 2e8313f56..7ee39d9b6 100644
--- a/hw/xwayland/xwayland-window.h
+++ b/hw/xwayland/xwayland-window.h
@@ -115,6 +115,13 @@ struct xwl_window {
 #endif
     struct xwayland_surface_v1 *xwayland_surface;
     struct xwl_dmabuf_feedback feedback;
+    /*
+     * The path to the DRM node in use. May
+     * be NULL if the client did not call
+     * DRI3SetDRMDeviceInUse.
+     */
+    dev_t drm_dev_in_use;
+    int drm_dev_in_use_set;
 };
 
 struct xwl_window *xwl_window_get(WindowPtr window);
diff --git a/meson.build b/meson.build
index c681f157d..04fcffc81 100644
--- a/meson.build
+++ b/meson.build
@@ -88,7 +88,7 @@ scrnsaverproto_dep = dependency('scrnsaverproto', version: '>= 1.1', fallback: [
 resourceproto_dep = dependency('resourceproto', version: '>= 1.2.0', fallback: ['xorgproto', 'ext_xorgproto'])
 xf86driproto_dep = dependency('xf86driproto', version: '>= 2.1.0', fallback: ['xorgproto', 'ext_xorgproto'], required: get_option('dri1') == 'true')
 dri2proto_dep = dependency('dri2proto', version: '>= 2.8', fallback: ['xorgproto', 'ext_xorgproto'], required: get_option('dri2') == 'true')
-dri3proto_dep = dependency('dri3proto', version: '>= 1.2', fallback: ['xorgproto', 'ext_xorgproto'], required: get_option('dri3') == 'true')
+dri3proto_dep = dependency('dri3proto', version: '>= 1.3', fallback: ['xorgproto', 'ext_xorgproto'], required: get_option('dri3') == 'true')
 xineramaproto_dep = dependency('xineramaproto', fallback: ['xorgproto', 'ext_xorgproto'])
 xf86bigfontproto_dep = dependency('xf86bigfontproto', version: '>= 1.2.0', fallback: ['xorgproto', 'ext_xorgproto'], required: get_option('xf86bigfont'))
 xf86vidmodeproto_dep = dependency('xf86vidmodeproto', version: '>= 2.2.99.1', fallback: ['xorgproto', 'ext_xorgproto'])
-- 
GitLab

