From a594ee1ba8c80338d761dd5377471391b3d25f21 Mon Sep 17 00:00:00 2001
From: Konstantin <ria.freelander@gmail.com>
Date: Thu, 21 Sep 2023 15:56:10 +0300
Subject: [PATCH 1/5] glamor: xv: port optimization

Allow xv to build a shader once per video and reuse,
and do not rebuild a shader each frame.

Reviewed-by: Adam Jackson <ajax@redhat.com>
Signed-off-by: Konstantin <ria.freelander@gmail.com>
---
 glamor/glamor_priv.h |   3 ++
 glamor/glamor_xv.c   | 113 ++++++++++++++++++++++++++++---------------
 2 files changed, 78 insertions(+), 38 deletions(-)

diff --git a/glamor/glamor_priv.h b/glamor/glamor_priv.h
index d8da1a0c12..1e8fb652fc 100644
--- a/glamor/glamor_priv.h
+++ b/glamor/glamor_priv.h
@@ -937,6 +937,9 @@ typedef struct {
     RegionRec clip;
     PixmapPtr src_pix[3];       /* y, u, v for planar */
     int src_pix_w, src_pix_h;
+    /* Port optimization */
+    int prev_fmt;
+    glamor_program xv_prog;
 } glamor_port_private;
 
 extern XvAttributeRec glamor_xv_attributes[];
diff --git a/glamor/glamor_xv.c b/glamor/glamor_xv.c
index 1548f8079e..1732200ffa 100644
--- a/glamor/glamor_xv.c
+++ b/glamor/glamor_xv.c
@@ -42,6 +42,12 @@
 
 #include <X11/extensions/Xv.h>
 #include <fourcc.h>
+
+static int is_previous(glamor_port_private *port_priv,
+                       int id,
+                       short w,
+                       short h);
+
 /* Reference color space transform data */
 typedef struct tagREF_TRANSFORM {
     float RefLuma;
@@ -147,9 +153,8 @@ XvImageRec glamor_xv_images[] = {
 int glamor_xv_num_images = ARRAY_SIZE(glamor_xv_images);
 
 static void
-glamor_init_xv_shader(ScreenPtr screen, int id)
+glamor_init_xv_shader(ScreenPtr screen, glamor_port_private *port_priv, int id)
 {
-    glamor_screen_private *glamor_priv = glamor_get_screen_private(screen);
     GLint sampler_loc;
     const glamor_facet *glamor_facet_xv_planar = NULL;
 
@@ -166,22 +171,27 @@ glamor_init_xv_shader(ScreenPtr screen, int id)
     }
 
     glamor_build_program(screen,
-                         &glamor_priv->xv_prog,
+                         &port_priv->xv_prog,
                          glamor_facet_xv_planar, NULL, NULL, NULL);
 
-    glUseProgram(glamor_priv->xv_prog.prog);
-    sampler_loc = glGetUniformLocation(glamor_priv->xv_prog.prog, "y_sampler");
-    glUniform1i(sampler_loc, 0);
-    sampler_loc = glGetUniformLocation(glamor_priv->xv_prog.prog, "u_sampler");
-    glUniform1i(sampler_loc, 1);
+    glUseProgram(port_priv->xv_prog.prog);
 
     switch (id) {
     case FOURCC_YV12:
     case FOURCC_I420:
-        sampler_loc = glGetUniformLocation(glamor_priv->xv_prog.prog, "v_sampler");
+        sampler_loc = glGetUniformLocation(port_priv->xv_prog.prog, "y_sampler");
+        glUniform1i(sampler_loc, 0);
+        sampler_loc = glGetUniformLocation(port_priv->xv_prog.prog, "u_sampler");
+        glUniform1i(sampler_loc, 1);
+        sampler_loc = glGetUniformLocation(port_priv->xv_prog.prog, "v_sampler");
         glUniform1i(sampler_loc, 2);
         break;
     case FOURCC_NV12:
+        glUseProgram(port_priv->xv_prog.prog);
+        sampler_loc = glGetUniformLocation(port_priv->xv_prog.prog, "y_sampler");
+        glUniform1i(sampler_loc, 0);
+        sampler_loc = glGetUniformLocation(port_priv->xv_prog.prog, "u_sampler");
+        glUniform1i(sampler_loc, 1);
         break;
     default:
         break;
@@ -334,8 +344,8 @@ glamor_xv_render(glamor_port_private *port_priv, int id)
     char *vbo_offset;
     int dst_box_index;
 
-    if (!glamor_priv->xv_prog.prog)
-        glamor_init_xv_shader(screen, id);
+    if (!port_priv->xv_prog.prog)
+        glamor_init_xv_shader(screen, port_priv, id);
 
     cont = RTFContrast(port_priv->contrast);
     bright = RTFBrightness(port_priv->brightness);
@@ -369,13 +379,13 @@ glamor_xv_render(glamor_port_private *port_priv, int id)
         }
     }
     glamor_make_current(glamor_priv);
-    glUseProgram(glamor_priv->xv_prog.prog);
+    glUseProgram(port_priv->xv_prog.prog);
 
-    uloc = glGetUniformLocation(glamor_priv->xv_prog.prog, "offsetyco");
+    uloc = glGetUniformLocation(port_priv->xv_prog.prog, "offsetyco");
     glUniform4f(uloc, off[0], off[1], off[2], yco);
-    uloc = glGetUniformLocation(glamor_priv->xv_prog.prog, "ucogamma");
+    uloc = glGetUniformLocation(port_priv->xv_prog.prog, "ucogamma");
     glUniform4f(uloc, uco[0], uco[1], uco[2], gamma);
-    uloc = glGetUniformLocation(glamor_priv->xv_prog.prog, "vco");
+    uloc = glGetUniformLocation(port_priv->xv_prog.prog, "vco");
     glUniform4f(uloc, vco[0], vco[1], vco[2], 0);
 
     glActiveTexture(GL_TEXTURE0);
@@ -385,16 +395,16 @@ glamor_xv_render(glamor_port_private *port_priv, int id)
     glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
     glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
 
-    glActiveTexture(GL_TEXTURE1);
-    glBindTexture(GL_TEXTURE_2D, src_pixmap_priv[1]->fbo->tex);
-    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
-    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
-    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
-    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
-
     switch (id) {
     case FOURCC_YV12:
     case FOURCC_I420:
+        glActiveTexture(GL_TEXTURE1);
+        glBindTexture(GL_TEXTURE_2D, src_pixmap_priv[1]->fbo->tex);
+        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
+        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
+
         glActiveTexture(GL_TEXTURE2);
         glBindTexture(GL_TEXTURE_2D, src_pixmap_priv[2]->fbo->tex);
         glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
@@ -403,6 +413,12 @@ glamor_xv_render(glamor_port_private *port_priv, int id)
         glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
         break;
     case FOURCC_NV12:
+        glActiveTexture(GL_TEXTURE1);
+        glBindTexture(GL_TEXTURE_2D, src_pixmap_priv[1]->fbo->tex);
+        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
+        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
         break;
     default:
         break;
@@ -459,7 +475,7 @@ glamor_xv_render(glamor_port_private *port_priv, int id)
         glamor_set_destination_drawable(port_priv->pDraw,
                                         dst_box_index,
                                         FALSE, FALSE,
-                                        glamor_priv->xv_prog.matrix_uniform,
+                                        port_priv->xv_prog.matrix_uniform,
                                         &dst_off_x, &dst_off_y);
 
         for (i = 0; i < nBox; i++) {
@@ -480,8 +496,25 @@ glamor_xv_render(glamor_port_private *port_priv, int id)
     glDisableVertexAttribArray(GLAMOR_VERTEX_SOURCE);
 
     DamageDamageRegion(port_priv->pDraw, &port_priv->clip);
+}
+
+static int
+is_previous(glamor_port_private *port_priv, int id, short w, short h)
+{
+    int ret = 1;
+
+    if(port_priv->prev_fmt != id)
+        ret = 0;
+
+    if(w != port_priv->src_pix_w || h != port_priv->src_pix_h)
+        ret = 0;
 
-    glamor_xv_free_port_data(port_priv);
+    if(!port_priv->src_pix[0])
+        ret = 0;
+
+    port_priv->prev_fmt = id;
+
+    return ret;
 }
 
 int
@@ -499,7 +532,6 @@ glamor_xv_put_image(glamor_port_private *port_priv,
                     RegionPtr clipBoxes)
 {
     ScreenPtr pScreen = pDrawable->pScreen;
-    glamor_screen_private *glamor_priv = glamor_get_screen_private(pScreen);
     int srcPitch, srcPitch2;
     int top, nlines;
     int s2offset, s3offset, tmp;
@@ -507,43 +539,48 @@ glamor_xv_put_image(glamor_port_private *port_priv,
 
     s2offset = s3offset = srcPitch2 = 0;
 
-    if (!port_priv->src_pix[0] ||
-        (width != port_priv->src_pix_w || height != port_priv->src_pix_h) ||
-        (port_priv->src_pix[2] && id == FOURCC_NV12) ||
-        (!port_priv->src_pix[2] && id != FOURCC_NV12)) {
+    if (!is_previous(port_priv, id, width, height)) {
         int i;
 
-        if (glamor_priv->xv_prog.prog) {
-            glDeleteProgram(glamor_priv->xv_prog.prog);
-            glamor_priv->xv_prog.prog = 0;
+        glamor_xv_free_port_data(port_priv);
+
+        if (port_priv->xv_prog.prog) {
+            glDeleteProgram(port_priv->xv_prog.prog);
+            port_priv->xv_prog.prog = 0;
         }
 
         for (i = 0; i < 3; i++)
             if (port_priv->src_pix[i])
                 glamor_destroy_pixmap(port_priv->src_pix[i]);
 
-        port_priv->src_pix[0] =
-            glamor_create_pixmap(pScreen, width, height, 8,
-                                 GLAMOR_CREATE_FBO_NO_FBO);
-
         switch (id) {
         case FOURCC_YV12:
         case FOURCC_I420:
+            port_priv->src_pix[0] =
+            glamor_create_pixmap(pScreen, width, height, 8,
+                                 GLAMOR_CREATE_FBO_NO_FBO);
+
             port_priv->src_pix[1] =
                 glamor_create_pixmap(pScreen, width >> 1, height >> 1, 8,
                                      GLAMOR_CREATE_FBO_NO_FBO);
             port_priv->src_pix[2] =
                 glamor_create_pixmap(pScreen, width >> 1, height >> 1, 8,
                                      GLAMOR_CREATE_FBO_NO_FBO);
-            if (!port_priv->src_pix[2])
+            if (!port_priv->src_pix[1] || !port_priv->src_pix[2])
                 return BadAlloc;
             break;
         case FOURCC_NV12:
+            port_priv->src_pix[0] =
+                glamor_create_pixmap(pScreen, width, height, 8,
+                                     GLAMOR_CREATE_FBO_NO_FBO);
             port_priv->src_pix[1] =
                 glamor_create_pixmap(pScreen, width >> 1, height >> 1, 16,
                                      GLAMOR_CREATE_FBO_NO_FBO |
                                      GLAMOR_CREATE_FORMAT_CBCR);
             port_priv->src_pix[2] = NULL;
+
+            if (!port_priv->src_pix[1])
+                return BadAlloc;
             break;
         default:
             return BadMatch;
@@ -552,7 +589,7 @@ glamor_xv_put_image(glamor_port_private *port_priv,
         port_priv->src_pix_w = width;
         port_priv->src_pix_h = height;
 
-        if (!port_priv->src_pix[0] || !port_priv->src_pix[1])
+        if (!port_priv->src_pix[0])
             return BadAlloc;
     }
 
-- 
GitLab


From 757174ea3cba3d71d578e5348b3155cae18023de Mon Sep 17 00:00:00 2001
From: Konstantin <ria.freelander@gmail.com>
Date: Tue, 19 Oct 2021 15:03:35 +0300
Subject: [PATCH 2/5] glamor: xv: enable UYVY acceleration

This commit adds UYVY format in XVideo for Glamor
along with shader support.

Reviewed-by: Adam Jackson <ajax@redhat.com>
Signed-off-by: Konstantin <ria.freelander@gmail.com>
---
 glamor/glamor_xv.c | 110 +++++++++++++++++++++++++++++++++++++++++----
 1 file changed, 102 insertions(+), 8 deletions(-)

diff --git a/glamor/glamor_xv.c b/glamor/glamor_xv.c
index 1732200ffa..10501624cf 100644
--- a/glamor/glamor_xv.c
+++ b/glamor/glamor_xv.c
@@ -130,6 +130,47 @@ static const glamor_facet glamor_facet_xv_planar_3 = {
                 ),
 };
 
+static const glamor_facet glamor_facet_xv_uyvy = {
+    .name = "xv_uyvy",
+
+    .source_name = "v_texcoord0",
+    .vs_vars = ("in vec2 position;\n"
+                "in vec2 v_texcoord0;\n"
+                "out vec2 tcs;\n"),
+    .vs_exec = (GLAMOR_POS(gl_Position, position)
+                "        tcs = v_texcoord0;\n"),
+
+    .fs_vars = ("#ifdef GL_ES\n"
+                "precision highp float;\n"
+                "#endif\n"
+                "uniform sampler2D sampler;\n"
+                "uniform vec2 texelSize;\n"
+                "uniform vec4 offsetyco;\n"
+                "uniform vec4 ucogamma;\n"
+                "uniform vec4 vco;\n"
+                "in vec2 tcs;\n"
+                ),
+    .fs_exec = (
+        "    vec3 uyv;\n"
+        "    vec4 frameOut = texture2D(sampler, tcs.st);\n"
+        "\n"
+        "    vec4 prevPixel = texture2D(sampler, vec2(tcs.s - texelSize.x, tcs.t));\n"
+        "    vec4 nextPixel = texture2D(sampler, vec2(tcs.s + texelSize.x, tcs.t));\n"
+        "\n"
+        "    float delta = 0.50;\n"
+        "\n"
+        "    int even = int(mod(tcs.x / texelSize.x, 2.0));\n"
+        "\n"
+        "    uyv.rgb = float(even)*vec3(frameOut.rg, nextPixel.r) + (1.0-float(even))*vec3(prevPixel.r, frameOut.gr);\n"
+        "\n"
+        "    frameOut.r = uyv.g + 1.403*(uyv.r - delta);\n"
+        "    frameOut.g = uyv.g - 0.714*(uyv.r - delta) - 0.344*(uyv.b - delta);\n"
+        "    frameOut.b = uyv.g + 1.773*(uyv.b - delta);\n"
+        "    frameOut.a = 1.0;\n"
+        "    frag_color = frameOut;\n"
+        ),
+};
+
 #define MAKE_ATOM(a) MakeAtom(a, sizeof(a) - 1, TRUE)
 
 XvAttributeRec glamor_xv_attributes[] = {
@@ -148,7 +189,8 @@ Atom glamorBrightness, glamorContrast, glamorSaturation, glamorHue,
 XvImageRec glamor_xv_images[] = {
     XVIMAGE_YV12,
     XVIMAGE_I420,
-    XVIMAGE_NV12
+    XVIMAGE_NV12,
+    XVIMAGE_UYVY,
 };
 int glamor_xv_num_images = ARRAY_SIZE(glamor_xv_images);
 
@@ -166,6 +208,9 @@ glamor_init_xv_shader(ScreenPtr screen, glamor_port_private *port_priv, int id)
     case FOURCC_NV12:
         glamor_facet_xv_planar = &glamor_facet_xv_planar_2;
         break;
+    case FOURCC_UYVY:
+        glamor_facet_xv_planar = &glamor_facet_xv_uyvy;
+        break;
     default:
         break;
     }
@@ -193,6 +238,10 @@ glamor_init_xv_shader(ScreenPtr screen, glamor_port_private *port_priv, int id)
         sampler_loc = glGetUniformLocation(port_priv->xv_prog.prog, "u_sampler");
         glUniform1i(sampler_loc, 1);
         break;
+    case FOURCC_UYVY:
+        sampler_loc = glGetUniformLocation(port_priv->xv_prog.prog, "sampler");
+        glUniform1i(sampler_loc, 0);
+        break;
     default:
         break;
     }
@@ -308,6 +357,15 @@ glamor_xv_query_image_attributes(int id,
         tmp *= (*h >> 1);
         size += tmp;
         break;
+    case FOURCC_UYVY:
+        //UYVU is single-plane really, all tranformation is processed inside a shader
+        size = *w * 2;
+        if (pitches)
+            pitches[0] = size;
+        if (offsets)
+            offsets[0] = 0;
+        size = size * *h;
+        break;
     }
     return size;
 }
@@ -388,16 +446,16 @@ glamor_xv_render(glamor_port_private *port_priv, int id)
     uloc = glGetUniformLocation(port_priv->xv_prog.prog, "vco");
     glUniform4f(uloc, vco[0], vco[1], vco[2], 0);
 
-    glActiveTexture(GL_TEXTURE0);
-    glBindTexture(GL_TEXTURE_2D, src_pixmap_priv[0]->fbo->tex);
-    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
-    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
-    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
-    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
-
     switch (id) {
     case FOURCC_YV12:
     case FOURCC_I420:
+        glActiveTexture(GL_TEXTURE0);
+        glBindTexture(GL_TEXTURE_2D, src_pixmap_priv[0]->fbo->tex);
+        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
+        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
+
         glActiveTexture(GL_TEXTURE1);
         glBindTexture(GL_TEXTURE_2D, src_pixmap_priv[1]->fbo->tex);
         glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
@@ -413,6 +471,13 @@ glamor_xv_render(glamor_port_private *port_priv, int id)
         glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
         break;
     case FOURCC_NV12:
+        glActiveTexture(GL_TEXTURE0);
+        glBindTexture(GL_TEXTURE_2D, src_pixmap_priv[0]->fbo->tex);
+        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
+        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
+
         glActiveTexture(GL_TEXTURE1);
         glBindTexture(GL_TEXTURE_2D, src_pixmap_priv[1]->fbo->tex);
         glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
@@ -420,6 +485,17 @@ glamor_xv_render(glamor_port_private *port_priv, int id)
         glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
         glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
         break;
+    case FOURCC_UYVY:
+        uloc = glGetUniformLocation(port_priv->xv_prog.prog, "texelSize");
+        glUniform2f(uloc, 1.0 / port_priv->w, 1.0 / port_priv->h);
+
+        glActiveTexture(GL_TEXTURE0);
+        glBindTexture(GL_TEXTURE_2D, src_pixmap_priv[0]->fbo->tex);
+        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
+        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
+        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
+        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
+        break;
     default:
         break;
     }
@@ -582,6 +658,14 @@ glamor_xv_put_image(glamor_port_private *port_priv,
             if (!port_priv->src_pix[1])
                 return BadAlloc;
             break;
+        case FOURCC_UYVY:
+            port_priv->src_pix[0] =
+                glamor_create_pixmap(pScreen, width, height, 32,
+                                     GLAMOR_CREATE_FBO_NO_FBO |
+                                     GLAMOR_CREATE_FORMAT_CBCR);
+            port_priv->src_pix[1] = NULL;
+            port_priv->src_pix[2] = NULL;
+            break;
         default:
             return BadMatch;
         }
@@ -656,6 +740,16 @@ glamor_xv_put_image(glamor_port_private *port_priv,
                             0, 0, 0, 0,
                             buf + s2offset, srcPitch);
         break;
+    case FOURCC_UYVY:
+        srcPitch = width * 2;
+        full_box.x1 = 0;
+        full_box.y1 = 0;
+        full_box.x2 = width;
+        full_box.y2 = height;
+        glamor_upload_boxes(&port_priv->src_pix[0]->drawable, &full_box, 1,
+                            0, 0, 0, 0,
+                            buf, srcPitch);
+        break;
     default:
         return BadMatch;
     }
-- 
GitLab


From af18428e9739ae04d18b961c74c51a2479b83165 Mon Sep 17 00:00:00 2001
From: Yuriy Vasilev <uuvasiliev@yandex.ru>
Date: Thu, 9 Sep 2021 18:14:02 +0300
Subject: [PATCH 3/5] glamor: xv: add rgba32 format

This commit adds RGBA32 format to XVideo along with shader for handling it.

Reviewed-by: Adam Jackson <ajax@redhat.com>
Signed-off-by: Yuriy Vasilev <uuvasiliev@yandex.ru>
---
 glamor/glamor_xv.c | 55 ++++++++++++++++++++++++++++++++++++++++++++++
 include/fourcc.h   | 19 ++++++++++++++++
 2 files changed, 74 insertions(+)

diff --git a/glamor/glamor_xv.c b/glamor/glamor_xv.c
index 10501624cf..41c9b5ade5 100644
--- a/glamor/glamor_xv.c
+++ b/glamor/glamor_xv.c
@@ -171,6 +171,23 @@ static const glamor_facet glamor_facet_xv_uyvy = {
         ),
 };
 
+static const glamor_facet glamor_facet_xv_rgb_raw = {
+    .name = "xv_rgb",
+
+    .source_name = "v_texcoord0",
+    .vs_vars = ("in vec2 position;\n"
+                "in vec2 v_texcoord0;\n"
+                "out vec2 tcs;\n"),
+    .vs_exec = (GLAMOR_POS(gl_Position, position)
+                "        tcs = v_texcoord0;\n"),
+
+    .fs_vars = ("uniform sampler2D sampler;\n"
+                "in vec2 tcs;\n"),
+    .fs_exec = (
+                "        frag_color = texture2D(sampler, tcs);\n"
+                ),
+};
+
 #define MAKE_ATOM(a) MakeAtom(a, sizeof(a) - 1, TRUE)
 
 XvAttributeRec glamor_xv_attributes[] = {
@@ -191,6 +208,7 @@ XvImageRec glamor_xv_images[] = {
     XVIMAGE_I420,
     XVIMAGE_NV12,
     XVIMAGE_UYVY,
+    XVIMAGE_RGB32,
 };
 int glamor_xv_num_images = ARRAY_SIZE(glamor_xv_images);
 
@@ -211,6 +229,9 @@ glamor_init_xv_shader(ScreenPtr screen, glamor_port_private *port_priv, int id)
     case FOURCC_UYVY:
         glamor_facet_xv_planar = &glamor_facet_xv_uyvy;
         break;
+    case FOURCC_RGBA32:
+        glamor_facet_xv_planar = &glamor_facet_xv_rgb_raw;
+        break;
     default:
         break;
     }
@@ -239,6 +260,7 @@ glamor_init_xv_shader(ScreenPtr screen, glamor_port_private *port_priv, int id)
         glUniform1i(sampler_loc, 1);
         break;
     case FOURCC_UYVY:
+    case FOURCC_RGBA32:
         sampler_loc = glGetUniformLocation(port_priv->xv_prog.prog, "sampler");
         glUniform1i(sampler_loc, 0);
         break;
@@ -357,6 +379,14 @@ glamor_xv_query_image_attributes(int id,
         tmp *= (*h >> 1);
         size += tmp;
         break;
+    case FOURCC_RGBA32:
+        size = *w * 4;
+        if(pitches)
+            pitches[0] = size;
+        if(offsets)
+            offsets[0] = 0;
+        size *= *h;
+        break;
     case FOURCC_UYVY:
         //UYVU is single-plane really, all tranformation is processed inside a shader
         size = *w * 2;
@@ -496,6 +526,14 @@ glamor_xv_render(glamor_port_private *port_priv, int id)
         glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
         glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
         break;
+    case FOURCC_RGBA32:
+        glActiveTexture(GL_TEXTURE0);
+        glBindTexture(GL_TEXTURE_2D, src_pixmap_priv[0]->fbo->tex);
+        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
+        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
+        break;
     default:
         break;
     }
@@ -658,6 +696,13 @@ glamor_xv_put_image(glamor_port_private *port_priv,
             if (!port_priv->src_pix[1])
                 return BadAlloc;
             break;
+        case FOURCC_RGBA32:
+            port_priv->src_pix[0] =
+            glamor_create_pixmap(pScreen, width, height, 32,
+                                     GLAMOR_CREATE_FBO_NO_FBO);
+            port_priv->src_pix[1] = NULL;
+            port_priv->src_pix[2] = NULL;
+            break;
         case FOURCC_UYVY:
             port_priv->src_pix[0] =
                 glamor_create_pixmap(pScreen, width, height, 32,
@@ -750,6 +795,16 @@ glamor_xv_put_image(glamor_port_private *port_priv,
                             0, 0, 0, 0,
                             buf, srcPitch);
         break;
+    case FOURCC_RGBA32:
+        srcPitch = width * 4;
+        full_box.x1 = 0;
+        full_box.y1 = 0;
+        full_box.x2 = width;
+        full_box.y2 = height;
+        glamor_upload_boxes(&port_priv->src_pix[0]->drawable, &full_box, 1,
+                            0, 0, 0, 0,
+                            buf, srcPitch);
+        break;
     default:
         return BadMatch;
     }
diff --git a/include/fourcc.h b/include/fourcc.h
index a19e6869ec..582a95afe6 100644
--- a/include/fourcc.h
+++ b/include/fourcc.h
@@ -176,4 +176,23 @@
         XvTopToBottom \
    }
 
+#define FOURCC_RGBA32 0x34325241
+#define XVIMAGE_RGB32 \
+   { \
+        FOURCC_RGBA32, \
+        XvRGB, \
+		LSBFirst, \
+		{'R','A','2','4', \
+		 0x00, 0x00, 0x00,0x10,0x80,0x00,0x00,0xAA,0x00,0x38,0x9B,0x71}, \
+		32, \
+		XvPacked, \
+		1, \
+		32, 0xff0000, 0xff00, 0xff, \
+		0, 0, 0, \
+		0, 0, 0, \
+		0, 0, 0, \
+		{0,0,0,0, \
+		 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}, \
+		0 \
+   }
 #endif                          /* _XF86_FOURCC_H_ */
-- 
GitLab


From af7efbff1d38e372b6a9f66e8010d4d2152ef278 Mon Sep 17 00:00:00 2001
From: Yuriy Vasilev <uuvasiliev@yandex.ru>
Date: Fri, 10 Sep 2021 16:20:06 +0300
Subject: [PATCH 4/5] glamor: xv: add rgb565

This commit adds RGB565 format to XVideo with reuse of RGBA32 shader

Reviewed-by: Adam Jackson <ajax@redhat.com>
Signed-off-by: Yuriy Vasilev <uuvasiliev@yandex.ru>
---
 glamor/glamor_xv.c | 20 ++++++++++++++++++++
 include/fourcc.h   | 20 ++++++++++++++++++++
 2 files changed, 40 insertions(+)

diff --git a/glamor/glamor_xv.c b/glamor/glamor_xv.c
index 41c9b5ade5..57d23d7692 100644
--- a/glamor/glamor_xv.c
+++ b/glamor/glamor_xv.c
@@ -209,6 +209,7 @@ XvImageRec glamor_xv_images[] = {
     XVIMAGE_NV12,
     XVIMAGE_UYVY,
     XVIMAGE_RGB32,
+    XVIMAGE_RGB565,
 };
 int glamor_xv_num_images = ARRAY_SIZE(glamor_xv_images);
 
@@ -230,6 +231,7 @@ glamor_init_xv_shader(ScreenPtr screen, glamor_port_private *port_priv, int id)
         glamor_facet_xv_planar = &glamor_facet_xv_uyvy;
         break;
     case FOURCC_RGBA32:
+    case FOURCC_RGB565:
         glamor_facet_xv_planar = &glamor_facet_xv_rgb_raw;
         break;
     default:
@@ -261,6 +263,7 @@ glamor_init_xv_shader(ScreenPtr screen, glamor_port_private *port_priv, int id)
         break;
     case FOURCC_UYVY:
     case FOURCC_RGBA32:
+    case FOURCC_RGB565:
         sampler_loc = glGetUniformLocation(port_priv->xv_prog.prog, "sampler");
         glUniform1i(sampler_loc, 0);
         break;
@@ -387,6 +390,14 @@ glamor_xv_query_image_attributes(int id,
             offsets[0] = 0;
         size *= *h;
         break;
+    case FOURCC_RGB565:
+        size = *w * 2;
+        if(pitches)
+            pitches[0] = size;
+        if(offsets)
+            offsets[0] = 0;
+        size *= *h;
+        break;
     case FOURCC_UYVY:
         //UYVU is single-plane really, all tranformation is processed inside a shader
         size = *w * 2;
@@ -527,6 +538,7 @@ glamor_xv_render(glamor_port_private *port_priv, int id)
         glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
         break;
     case FOURCC_RGBA32:
+    case FOURCC_RGB565:
         glActiveTexture(GL_TEXTURE0);
         glBindTexture(GL_TEXTURE_2D, src_pixmap_priv[0]->fbo->tex);
         glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
@@ -703,6 +715,13 @@ glamor_xv_put_image(glamor_port_private *port_priv,
             port_priv->src_pix[1] = NULL;
             port_priv->src_pix[2] = NULL;
             break;
+        case FOURCC_RGB565:
+            port_priv->src_pix[0] =
+            glamor_create_pixmap(pScreen, width, height, 16,
+                                     GLAMOR_CREATE_FBO_NO_FBO);
+            port_priv->src_pix[1] = NULL;
+            port_priv->src_pix[2] = NULL;
+            break;
         case FOURCC_UYVY:
             port_priv->src_pix[0] =
                 glamor_create_pixmap(pScreen, width, height, 32,
@@ -786,6 +805,7 @@ glamor_xv_put_image(glamor_port_private *port_priv,
                             buf + s2offset, srcPitch);
         break;
     case FOURCC_UYVY:
+    case FOURCC_RGB565:
         srcPitch = width * 2;
         full_box.x1 = 0;
         full_box.y1 = 0;
diff --git a/include/fourcc.h b/include/fourcc.h
index 582a95afe6..83e51a888e 100644
--- a/include/fourcc.h
+++ b/include/fourcc.h
@@ -195,4 +195,24 @@
 		 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}, \
 		0 \
    }
+
+#define FOURCC_RGB565 0x36314752
+#define XVIMAGE_RGB565 \
+   { \
+        FOURCC_RGB565, \
+        XvRGB, \
+		LSBFirst, \
+		{'R','G','1','6', \
+		 0x00, 0x00, 0x00,0x10,0x80,0x00,0x00,0xAA,0x00,0x38,0x9B,0x71}, \
+		16, \
+		XvPacked, \
+		1, \
+		16, 0xf800, 0x7e0, 0x1f, \
+		0, 0, 0, \
+		0, 0, 0, \
+		0, 0, 0, \
+		{0,0,0,0, \
+		 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}, \
+		0 \
+   }
 #endif                          /* _XF86_FOURCC_H_ */
-- 
GitLab


From b1c4caa6e86827e2c8635d08634b10e0e793f3b7 Mon Sep 17 00:00:00 2001
From: Konstantin <ria.freelander@gmail.com>
Date: Tue, 10 Oct 2023 13:07:41 +0300
Subject: [PATCH 5/5] glamor: xv: do not force a version on XV shaders

There is a no need to force a low version for XV shaders, it will
work on higher version too.

Reviewed-by: Adam Jackson <ajax@redhat.com>
Signed-off-by: Konstantin <ria.freelander@gmail.com>
---
 glamor/glamor_xv.c | 4 ----
 1 file changed, 4 deletions(-)

diff --git a/glamor/glamor_xv.c b/glamor/glamor_xv.c
index 57d23d7692..d9d6e94183 100644
--- a/glamor/glamor_xv.c
+++ b/glamor/glamor_xv.c
@@ -68,8 +68,6 @@ typedef struct tagREF_TRANSFORM {
 static const glamor_facet glamor_facet_xv_planar_2 = {
     .name = "xv_planar_2",
 
-    .version = 120,
-
     .source_name = "v_texcoord0",
     .vs_vars = ("in vec2 position;\n"
                 "in vec2 v_texcoord0;\n"
@@ -100,8 +98,6 @@ static const glamor_facet glamor_facet_xv_planar_2 = {
 static const glamor_facet glamor_facet_xv_planar_3 = {
     .name = "xv_planar_3",
 
-    .version = 120,
-
     .source_name = "v_texcoord0",
     .vs_vars = ("in vec2 position;\n"
                 "in vec2 v_texcoord0;\n"
-- 
GitLab

