From 4cb95f65ef74145cdc0d2d45e273ac5719003faa Mon Sep 17 00:00:00 2001
From: Austin Shafer <ashafer@nvidia.com>
Date: Fri, 2 Sep 2022 11:54:05 -0400
Subject: [PATCH 1/2] Add libdrm 2.4.109 requirement

Reviewed-by: Olivier Fourdan <ofourdan@redhat.com>
---
 .gitlab-ci.yml               | 2 +-
 .gitlab-ci/debian-install.sh | 8 ++++++++
 meson.build                  | 2 +-
 3 files changed, 10 insertions(+), 2 deletions(-)

diff --git a/.gitlab-ci.yml b/.gitlab-ci.yml
index 22769a047..b1e725331 100644
--- a/.gitlab-ci.yml
+++ b/.gitlab-ci.yml
@@ -19,7 +19,7 @@ variables:
     FDO_UPSTREAM_REPO: xorg/xserver
     FDO_DISTRIBUTION_VERSION: bullseye-slim
     FDO_DISTRIBUTION_EXEC: 'env FDO_CI_CONCURRENT=${FDO_CI_CONCURRENT} bash .gitlab-ci/debian-install.sh'
-    FDO_DISTRIBUTION_TAG: "2022-11-24-new-wayland-protocols"
+    FDO_DISTRIBUTION_TAG: "2023-01-25-libdrm-update"
 
 include:
   - project: 'freedesktop/ci-templates'
diff --git a/.gitlab-ci/debian-install.sh b/.gitlab-ci/debian-install.sh
index 5fca4c625..62c292be5 100644
--- a/.gitlab-ci/debian-install.sh
+++ b/.gitlab-ci/debian-install.sh
@@ -113,6 +113,14 @@ apt-get install -y \
 
 cd /root
 
+# Xwayland requires drm 2.4.109 for drmGetDeviceFromDevId
+git clone https://gitlab.freedesktop.org/mesa/drm --depth 1 --branch=libdrm-2.4.109
+cd drm
+meson _build
+ninja -C _build -j${FDO_CI_CONCURRENT:-4} install
+cd ..
+rm -rf drm
+
 # xserver requires libxcvt
 git clone https://gitlab.freedesktop.org/xorg/lib/libxcvt.git --depth 1 --branch=libxcvt-0.1.0
 cd libxcvt
diff --git a/meson.build b/meson.build
index 01e22b6a9..c681f157d 100644
--- a/meson.build
+++ b/meson.build
@@ -60,7 +60,7 @@ endforeach
 
 add_project_arguments(common_wflags, language : ['c', 'objc'])
 
-libdrm_req = '>= 2.4.89'
+libdrm_req = '>= 2.4.109'
 libselinux_req = '>= 2.0.86'
 xext_req = '>= 1.0.99.4'
 wayland_req = '>= 1.18.0'
-- 
GitLab


From f7649697ac3a2179b90cdfe48edb98df24f7c2c6 Mon Sep 17 00:00:00 2001
From: Austin Shafer <ashafer@nvidia.com>
Date: Wed, 1 Feb 2023 17:29:32 -0500
Subject: [PATCH 2/2] xwl: Use linux_dmabuf to get the DRM device name

This avoids using wl_drm now that linux_dmabuf is powerful enough
---
 hw/xwayland/xwayland-glamor-gbm.c | 33 +++++++++++++++++++++++++++++++
 hw/xwayland/xwayland-glamor.c     | 23 +++++++++++++++++----
 hw/xwayland/xwayland-glamor.h     |  1 +
 hw/xwayland/xwayland-screen.h     |  4 ++++
 4 files changed, 57 insertions(+), 4 deletions(-)

diff --git a/hw/xwayland/xwayland-glamor-gbm.c b/hw/xwayland/xwayland-glamor-gbm.c
index 205d2feb3..43e9814a4 100644
--- a/hw/xwayland/xwayland-glamor-gbm.c
+++ b/hw/xwayland/xwayland-glamor-gbm.c
@@ -53,6 +53,7 @@
 #include "linux-dmabuf-unstable-v1-client-protocol.h"
 
 struct xwl_gbm_private {
+    /* These fields are set by the wl_drm protocol */
     dev_t device;
     char *device_name;
     struct gbm_device *gbm;
@@ -523,6 +524,27 @@ static const struct wl_callback_listener sync_listener = {
    sync_callback
 };
 
+static int
+xwl_find_drm_node_by_devid(dev_t devid)
+{
+    drmDevicePtr drm_dev;
+    int fd = -1;
+
+    if (drmGetDeviceFromDevId(devid, 0, &drm_dev))
+        return -1;
+
+    if (drm_dev->available_nodes & (1 << DRM_NODE_RENDER)) {
+        fd = open(drm_dev->nodes[DRM_NODE_RENDER], O_RDWR | O_CLOEXEC);
+        if (fd < 0) {
+            ErrorF("Failed to open %s, disabling Glamor and DRI3: %s\n",
+                   drm_dev->nodes[DRM_NODE_RENDER], strerror(errno));
+        }
+    }
+
+    drmFreeDevice(&drm_dev);
+    return fd;
+}
+
 static int
 xwl_dri3_open_client(ClientPtr client,
                      ScreenPtr screen,
@@ -535,6 +557,17 @@ xwl_dri3_open_client(ClientPtr client,
     drm_magic_t magic;
     int fd;
 
+    /* For v4 use the cached main device in our screen */
+    if (xwl_screen->dmabuf_protocol_version >= 4) {
+        dev_t main_dev = xwl_screen_get_main_dev(xwl_screen);
+        fd = xwl_find_drm_node_by_devid(main_dev);
+        if (fd < 0)
+            return BadAlloc;
+
+        *pfd = fd;
+        return Success;
+    }
+
     fd = open(xwl_gbm->device_name, O_RDWR | O_CLOEXEC);
     if (fd < 0)
         return BadAlloc;
diff --git a/hw/xwayland/xwayland-glamor.c b/hw/xwayland/xwayland-glamor.c
index 6c7784efb..f9140c641 100644
--- a/hw/xwayland/xwayland-glamor.c
+++ b/hw/xwayland/xwayland-glamor.c
@@ -187,14 +187,29 @@ wl_drm_format_for_depth(int depth)
     }
 }
 
-static dev_t
+dev_t
 xwl_screen_get_main_dev(struct xwl_screen *xwl_screen)
 {
     /*
-     * If we have gbm then get our main device from it. Otherwise use what
-     * the compositor told us.
+     * There's a couple different scenarios we have to handle to get the
+     * correct device that was used as the "main" device for this client:
+     *
+     * 1. For dmabuf v4, we stash the default_feedback.main_dev in the screen,
+     *    so grab it from there and return it. This is the device being treated
+     *    as the main device for Xwayland's lifetime
+     * 2. For dmabuf v3 and if we are using GBM, get the device GBM used (the device
+     *    handed to us from the wl_drm protocol)
+     * 3. For all other cases (eglstream backend) just return the main device
+     *    the compositor gave us.
      */
-    if (xwl_screen->gbm_backend.is_available)
+    if (xwl_screen->dmabuf_protocol_version >= 4) {
+        if (!xwl_screen->main_dev_is_set) {
+            xwl_screen->main_dev_is_set = true;
+            xwl_screen->main_dev = xwl_screen->default_feedback.main_dev;
+        }
+
+        return xwl_screen->main_dev;
+    } else if (xwl_screen->gbm_backend.is_available)
         return xwl_screen->gbm_backend.get_main_device(xwl_screen);
     else
         return xwl_screen->default_feedback.main_dev;
diff --git a/hw/xwayland/xwayland-glamor.h b/hw/xwayland/xwayland-glamor.h
index ed9ec40de..f901a3aca 100644
--- a/hw/xwayland/xwayland-glamor.h
+++ b/hw/xwayland/xwayland-glamor.h
@@ -116,6 +116,7 @@ Bool xwl_screen_set_drm_interface(struct xwl_screen *xwl_screen,
 Bool xwl_dmabuf_setup_feedback_for_window(struct xwl_window *xwl_window);
 Bool xwl_screen_set_dmabuf_interface(struct xwl_screen *xwl_screen,
                                      uint32_t id, uint32_t version);
+dev_t xwl_screen_get_main_dev(struct xwl_screen *xwl_screen);
 struct wl_buffer *xwl_glamor_pixmap_get_wl_buffer(PixmapPtr pixmap);
 void xwl_glamor_init_wl_registry(struct xwl_screen *xwl_screen,
                                  struct wl_registry *registry,
diff --git a/hw/xwayland/xwayland-screen.h b/hw/xwayland/xwayland-screen.h
index fadd0526e..f77d3201b 100644
--- a/hw/xwayland/xwayland-screen.h
+++ b/hw/xwayland/xwayland-screen.h
@@ -32,6 +32,7 @@
 #include <unistd.h>
 #include <X11/X.h>
 #include <dix.h>
+#include <stdbool.h>
 
 #include "xwayland-types.h"
 #include "xwayland-window.h"
@@ -104,6 +105,9 @@ struct xwl_screen {
     struct zwp_linux_dmabuf_v1 *dmabuf;
     int dmabuf_protocol_version;
     struct xwl_dmabuf_feedback default_feedback;
+    /* The cached device that we will consider the primary device */
+    dev_t main_dev;
+    bool main_dev_is_set;
     struct zxdg_output_manager_v1 *xdg_output_manager;
     struct wp_viewporter *viewporter;
     struct xwayland_shell_v1 *xwayland_shell;
-- 
GitLab

