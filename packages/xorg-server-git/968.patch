From 2434719499a9ae0033b363d9a967a488d2876b6b Mon Sep 17 00:00:00 2001
From: Austin Shafer <ashafer@nvidia.com>
Date: Wed, 31 Aug 2022 09:55:43 -0400
Subject: [PATCH 01/11] xwayland: Require wayland-protocols 1.24

Needed for linux_dmabuf v4 protocol support.

Update the CI image according
---
 .gitlab-ci.yml               | 2 +-
 .gitlab-ci/debian-install.sh | 8 ++++----
 meson.build                  | 2 +-
 3 files changed, 6 insertions(+), 6 deletions(-)

diff --git a/.gitlab-ci.yml b/.gitlab-ci.yml
index d1b584a57..69740ab93 100644
--- a/.gitlab-ci.yml
+++ b/.gitlab-ci.yml
@@ -19,7 +19,7 @@ variables:
     FDO_UPSTREAM_REPO: xorg/xserver
     FDO_DISTRIBUTION_VERSION: bullseye-slim
     FDO_DISTRIBUTION_EXEC: 'env FDO_CI_CONCURRENT=${FDO_CI_CONCURRENT} bash .gitlab-ci/debian-install.sh'
-    FDO_DISTRIBUTION_TAG: "2022-09-02-fixed-commits"
+    FDO_DISTRIBUTION_TAG: "2022-09-20"
 
 include:
   - project: 'freedesktop/ci-templates'
diff --git a/.gitlab-ci/debian-install.sh b/.gitlab-ci/debian-install.sh
index 079b7056f..164a0c411 100644
--- a/.gitlab-ci/debian-install.sh
+++ b/.gitlab-ci/debian-install.sh
@@ -129,11 +129,11 @@ make -j${FDO_CI_CONCURRENT:-4} install
 popd
 rm -rf xorgproto
 
-# Xwayland requires wayland-protocols >= 1.22, but Debian bullseye has 1.20 only
-git clone https://gitlab.freedesktop.org/wayland/wayland-protocols.git --depth 1 --branch=1.22
+# Xwayland requires wayland-protocols >= 1.24, but Debian bullseye has 1.20 only
+git clone https://gitlab.freedesktop.org/wayland/wayland-protocols.git --depth 1 --branch=1.24
 cd wayland-protocols
-./autogen.sh
-make -j${FDO_CI_CONCURRENT:-4} install
+meson _build
+ninja -C _build -j${FDO_CI_CONCURRENT:-4} install
 cd ..
 rm -rf wayland-protocols
 
diff --git a/meson.build b/meson.build
index 2498025a2..a8bc07f19 100644
--- a/meson.build
+++ b/meson.build
@@ -64,7 +64,7 @@ libdrm_req = '>= 2.4.89'
 libselinux_req = '>= 2.0.86'
 xext_req = '>= 1.0.99.4'
 wayland_req = '>= 1.5.0'
-wayland_protocols_req = '>= 1.22'
+wayland_protocols_req = '>= 1.24'
 gbm_req = '>= 10.2'
 xf86dgaproto_req = '>= 2.0.99.1'
 
-- 
GitLab


From edab5fa26c57b0667cdb28f269d232f6f99fb4c8 Mon Sep 17 00:00:00 2001
From: Austin Shafer <ashafer@nvidia.com>
Date: Mon, 29 Nov 2021 11:05:13 -0500
Subject: [PATCH 02/11] xwayland: Move xwl_format array management to its own
 function
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

This creates xwl_add_format_and_mod_to_list, which is a helper
that adds a format/mod combo to a xwl_format* list. This will
be used by both the modifier event handling and the tranche
format handling.

Reviewed-by: Michel Dänzer <mdaenzer@redhat.com>
---
 hw/xwayland/xwayland-glamor.c | 50 ++++++++++++++++++++++-------------
 1 file changed, 31 insertions(+), 19 deletions(-)

diff --git a/hw/xwayland/xwayland-glamor.c b/hw/xwayland/xwayland-glamor.c
index 24620605d..326708f9a 100644
--- a/hw/xwayland/xwayland-glamor.c
+++ b/hw/xwayland/xwayland-glamor.c
@@ -213,40 +213,52 @@ xwl_dmabuf_handle_format(void *data, struct zwp_linux_dmabuf_v1 *dmabuf,
 }
 
 static void
-xwl_dmabuf_handle_modifier(void *data, struct zwp_linux_dmabuf_v1 *dmabuf,
-                           uint32_t format, uint32_t modifier_hi,
-                           uint32_t modifier_lo)
+xwl_add_format_and_mod_to_list(struct xwl_format **formats,
+                               uint32_t *num_formats,
+                               uint32_t format,
+                               uint64_t modifier)
 {
-    struct xwl_screen *xwl_screen = data;
     struct xwl_format *xwl_format = NULL;
     int i;
 
-    for (i = 0; i < xwl_screen->num_formats; i++) {
-        if (xwl_screen->formats[i].format == format) {
-            xwl_format = &xwl_screen->formats[i];
+    for (i = 0; i < *num_formats; i++) {
+        if ((*formats)[i].format == format) {
+            xwl_format = &(*formats)[i];
             break;
         }
     }
 
     if (xwl_format == NULL) {
-        xwl_screen->num_formats++;
-        xwl_screen->formats = realloc(xwl_screen->formats,
-                                      xwl_screen->num_formats * sizeof(*xwl_format));
-        if (!xwl_screen->formats)
-            return;
-        xwl_format = &xwl_screen->formats[xwl_screen->num_formats - 1];
+        (*num_formats)++;
+        *formats = xnfrealloc(*formats, *num_formats * sizeof(*xwl_format));
+        xwl_format = &(*formats)[*num_formats - 1];
         xwl_format->format = format;
         xwl_format->num_modifiers = 0;
         xwl_format->modifiers = NULL;
     }
 
+    for (i = 0; i < xwl_format->num_modifiers; i++) {
+        /* don't add it if the modifier already exists */
+        if (xwl_format->modifiers[i] == modifier)
+            return;
+    }
+
     xwl_format->num_modifiers++;
-    xwl_format->modifiers = realloc(xwl_format->modifiers,
-                                    xwl_format->num_modifiers * sizeof(uint64_t));
-    if (!xwl_format->modifiers)
-        return;
-    xwl_format->modifiers[xwl_format->num_modifiers - 1]  = (uint64_t) modifier_lo;
-    xwl_format->modifiers[xwl_format->num_modifiers - 1] |= (uint64_t) modifier_hi << 32;
+    xwl_format->modifiers = xnfrealloc(xwl_format->modifiers,
+                                       xwl_format->num_modifiers * sizeof(uint64_t));
+    xwl_format->modifiers[xwl_format->num_modifiers - 1]  = modifier;
+}
+
+static void
+xwl_dmabuf_handle_modifier(void *data, struct zwp_linux_dmabuf_v1 *dmabuf,
+                           uint32_t format, uint32_t modifier_hi,
+                           uint32_t modifier_lo)
+{
+    struct xwl_screen *xwl_screen = data;
+
+    xwl_add_format_and_mod_to_list(&xwl_screen->formats, &xwl_screen->num_formats,
+                                   format,
+                                   ((uint64_t)modifier_hi << 32 | (uint64_t)modifier_lo));
 }
 
 static const struct zwp_linux_dmabuf_v1_listener xwl_dmabuf_listener = {
-- 
GitLab


From 795f4930a8fe1e82748761babd443f30e69ab2cb Mon Sep 17 00:00:00 2001
From: Austin Shafer <ashafer@nvidia.com>
Date: Tue, 23 Nov 2021 15:36:03 -0500
Subject: [PATCH 03/11] xwayland: Implement linux_dmabuf_feedback event
 handlers

---
 hw/xwayland/xwayland-glamor.c | 213 +++++++++++++++++++++++++++++++++-
 hw/xwayland/xwayland-glamor.h |   1 +
 hw/xwayland/xwayland-screen.c |   2 +
 hw/xwayland/xwayland-screen.h |   3 +
 hw/xwayland/xwayland-window.c |  47 ++++++++
 hw/xwayland/xwayland-window.h |  43 +++++++
 6 files changed, 308 insertions(+), 1 deletion(-)

diff --git a/hw/xwayland/xwayland-glamor.c b/hw/xwayland/xwayland-glamor.c
index 326708f9a..bf74163c1 100644
--- a/hw/xwayland/xwayland-glamor.c
+++ b/hw/xwayland/xwayland-glamor.c
@@ -44,6 +44,8 @@
 #include "xwayland-screen.h"
 #include "xwayland-window.h"
 
+#include <sys/mman.h>
+
 static void
 glamor_egl_make_current(struct glamor_context *glamor_ctx)
 {
@@ -266,15 +268,224 @@ static const struct zwp_linux_dmabuf_v1_listener xwl_dmabuf_listener = {
     .modifier = xwl_dmabuf_handle_modifier
 };
 
+/*
+ * We need to check if the compositor is resending all of the tranche
+ * information. Each tranche event will call this method to see
+ * if the existing format info should be cleared before refilling.
+ */
+static void
+xwl_check_reset_tranche_info(struct xwl_dmabuf_feedback *xwl_feedback)
+{
+    if (!xwl_feedback->feedback_done)
+        return;
+
+    xwl_feedback->feedback_done = false;
+
+    xwl_dmabuf_feedback_clear_dev_formats(xwl_feedback);
+}
+
+static void
+xwl_dmabuf_feedback_main_device(void *data,
+                                struct zwp_linux_dmabuf_feedback_v1 *dmabuf_feedback,
+                                struct wl_array *dev)
+{
+    struct xwl_dmabuf_feedback *xwl_feedback = data;
+    dev_t devid;
+
+    xwl_check_reset_tranche_info(xwl_feedback);
+
+    assert(dev->size == sizeof(dev_t));
+    memcpy(&devid, dev->data, sizeof(dev_t));
+
+    xwl_feedback->main_dev = devid;
+}
+
+static void
+xwl_dmabuf_feedback_tranche_target_device(void *data,
+                                          struct zwp_linux_dmabuf_feedback_v1 *dmabuf_feedback,
+                                          struct wl_array *dev)
+{
+    struct xwl_dmabuf_feedback *xwl_feedback = data;
+
+    xwl_check_reset_tranche_info(xwl_feedback);
+
+    assert(dev->size == sizeof(dev_t));
+    memcpy(&xwl_feedback->tmp_tranche.drm_dev, dev->data, sizeof(dev_t));
+}
+
+static void
+xwl_dmabuf_feedback_tranche_flags(void *data,
+                                  struct zwp_linux_dmabuf_feedback_v1 *dmabuf_feedback,
+                                  uint32_t flags)
+{
+    struct xwl_dmabuf_feedback *xwl_feedback = data;
+
+    xwl_check_reset_tranche_info(xwl_feedback);
+
+    if (flags & ZWP_LINUX_DMABUF_FEEDBACK_V1_TRANCHE_FLAGS_SCANOUT)
+        xwl_feedback->tmp_tranche.supports_scanout = true;
+}
+
+static void
+xwl_dmabuf_feedback_tranche_formats(void *data,
+                                    struct zwp_linux_dmabuf_feedback_v1 *dmabuf_feedback,
+                                    struct wl_array *indices)
+{
+    struct xwl_dmabuf_feedback *xwl_feedback = data;
+    struct xwl_device_formats *tranche = &xwl_feedback->tmp_tranche;
+    uint16_t *index;
+
+    xwl_check_reset_tranche_info(xwl_feedback);
+
+    wl_array_for_each(index, indices) {
+        if (*index >= xwl_feedback->format_table.len) {
+            ErrorF("linux_dmabuf_feedback.tranche_formats: Index given to us by the compositor"
+                   " is too large to fit in the format table\n");
+            continue;
+        }
+
+        /* Look up this format/mod in the format table */
+        struct xwl_format_table_entry *entry = &xwl_feedback->format_table.entry[*index];
+
+        /* Add it to the in-progress tranche */
+        xwl_add_format_and_mod_to_list(&tranche->formats, &tranche->num_formats,
+                                       entry->format,
+                                       entry->modifier);
+    }
+}
+
+static void
+xwl_append_to_tranche(struct xwl_device_formats *dst, struct xwl_device_formats *src)
+{
+    struct xwl_format *format;
+
+    for (int i = 0; i < src->num_formats; i++) {
+        format = &src->formats[i];
+
+        for (int j = 0; j < format->num_modifiers; j++)
+            xwl_add_format_and_mod_to_list(&dst->formats, &dst->num_formats,
+                                           format->format,
+                                           format->modifiers[j]);
+    }
+}
+
+static void
+xwl_dmabuf_feedback_tranche_done(void *data,
+                                 struct zwp_linux_dmabuf_feedback_v1 *dmabuf_feedback)
+{
+    struct xwl_dmabuf_feedback *xwl_feedback = data;
+    struct xwl_device_formats *tranche;
+    int appended = false;
+
+    /*
+     * No need to call xwl_check_reset_tranche_info, the other events should have been
+     * triggered first
+     */
+
+    /*
+     * First check if there is an existing tranche for this device+flags combo. We
+     * will combine it with this tranche, since we can only send one modifier list
+     * in DRI3 but the compositor may report multiple tranches per device (KDE
+     * does this)
+     */
+    for (int i = 0; i < xwl_feedback->dev_formats_len; i++) {
+        tranche = &xwl_feedback->dev_formats[i];
+        if (tranche->drm_dev == xwl_feedback->tmp_tranche.drm_dev &&
+            tranche->supports_scanout == xwl_feedback->tmp_tranche.supports_scanout) {
+            appended = true;
+
+            /* Add all format/mods to this tranche */
+            xwl_append_to_tranche(tranche, &xwl_feedback->tmp_tranche);
+
+            /* Now free our temp tranche's allocations */
+            xwl_device_formats_destroy(&xwl_feedback->tmp_tranche);
+        }
+    }
+
+    if (!appended) {
+        xwl_feedback->dev_formats_len++;
+        xwl_feedback->dev_formats = xnfrealloc(xwl_feedback->dev_formats,
+                                               sizeof(struct xwl_device_formats) *
+                                               xwl_feedback->dev_formats_len);
+
+        /* copy the temporary tranche into the official array */
+        memcpy(&xwl_feedback->dev_formats[xwl_feedback->dev_formats_len - 1],
+               &xwl_feedback->tmp_tranche,
+               sizeof(struct xwl_device_formats));
+    }
+
+    /* reset the tranche */
+    memset(&xwl_feedback->tmp_tranche, 0, sizeof(struct xwl_device_formats));
+}
+
+static void
+xwl_dmabuf_feedback_done(void *data, struct zwp_linux_dmabuf_feedback_v1 *dmabuf_feedback)
+{
+    struct xwl_dmabuf_feedback *xwl_feedback = data;
+
+    xwl_feedback->feedback_done = true;
+}
+
+static void
+xwl_dmabuf_feedback_format_table(void *data,
+                                 struct zwp_linux_dmabuf_feedback_v1 *zwp_linux_dmabuf_feedback_v1,
+                                 int32_t fd, uint32_t size)
+{
+    struct xwl_dmabuf_feedback *xwl_feedback = data;
+
+    assert(size % sizeof(struct xwl_format_table_entry) == 0);
+    xwl_feedback->format_table.len = size / sizeof(struct xwl_format_table_entry);
+    xwl_feedback->format_table.entry = mmap(NULL, size, PROT_READ, MAP_PRIVATE, fd, 0);
+    close(fd);
+
+    if (xwl_feedback->format_table.entry == MAP_FAILED) {
+        ErrorF("linux_dmabuf_feedback.format_table: Could not map the format"
+               " table: Compositor bug or out of resources\n");
+        xwl_feedback->format_table.len = 0;
+    }
+}
+
+static const struct zwp_linux_dmabuf_feedback_v1_listener xwl_dmabuf_feedback_listener = {
+    .done = xwl_dmabuf_feedback_done,
+    .format_table = xwl_dmabuf_feedback_format_table,
+    .main_device = xwl_dmabuf_feedback_main_device,
+    .tranche_done = xwl_dmabuf_feedback_tranche_done,
+    .tranche_target_device = xwl_dmabuf_feedback_tranche_target_device,
+    .tranche_formats = xwl_dmabuf_feedback_tranche_formats,
+    .tranche_flags = xwl_dmabuf_feedback_tranche_flags,
+};
+
+Bool
+xwl_dmabuf_setup_feedback_for_window(struct xwl_window *xwl_window)
+{
+    struct xwl_screen *xwl_screen = xwl_window->xwl_screen;
+
+    xwl_window->feedback.dmabuf_feedback =
+        zwp_linux_dmabuf_v1_get_surface_feedback(xwl_screen->dmabuf, xwl_window->surface);
+
+    if (!xwl_window->feedback.dmabuf_feedback)
+        return FALSE;
+
+    zwp_linux_dmabuf_feedback_v1_add_listener(xwl_window->feedback.dmabuf_feedback,
+            &xwl_dmabuf_feedback_listener,
+            &xwl_window->feedback);
+
+    return TRUE;
+}
+
 Bool
 xwl_screen_set_dmabuf_interface(struct xwl_screen *xwl_screen,
                                 uint32_t id, uint32_t version)
 {
+    /* We either support versions 3 or 4. 4 is needed for dmabuf feedback */
+    int supported_version = version >= 4 ? 4 : 3;
+
     if (version < 3)
         return FALSE;
 
     xwl_screen->dmabuf =
-        wl_registry_bind(xwl_screen->registry, id, &zwp_linux_dmabuf_v1_interface, 3);
+        wl_registry_bind(xwl_screen->registry, id, &zwp_linux_dmabuf_v1_interface, supported_version);
+    xwl_screen->dmabuf_protocol_version = supported_version;
     zwp_linux_dmabuf_v1_add_listener(xwl_screen->dmabuf, &xwl_dmabuf_listener, xwl_screen);
 
     return TRUE;
diff --git a/hw/xwayland/xwayland-glamor.h b/hw/xwayland/xwayland-glamor.h
index cf3c4fba3..5c3661de3 100644
--- a/hw/xwayland/xwayland-glamor.h
+++ b/hw/xwayland/xwayland-glamor.h
@@ -108,6 +108,7 @@ Bool xwl_glamor_init(struct xwl_screen *xwl_screen);
 
 Bool xwl_screen_set_drm_interface(struct xwl_screen *xwl_screen,
                                   uint32_t id, uint32_t version);
+Bool xwl_dmabuf_setup_feedback_for_window(struct xwl_window *xwl_window);
 Bool xwl_screen_set_dmabuf_interface(struct xwl_screen *xwl_screen,
                                      uint32_t id, uint32_t version);
 struct wl_buffer *xwl_glamor_pixmap_get_wl_buffer(PixmapPtr pixmap);
diff --git a/hw/xwayland/xwayland-screen.c b/hw/xwayland/xwayland-screen.c
index 1e2a345c2..8ac52dbd2 100644
--- a/hw/xwayland/xwayland-screen.c
+++ b/hw/xwayland/xwayland-screen.c
@@ -183,6 +183,8 @@ xwl_close_screen(ScreenPtr screen)
     struct xwl_output *xwl_output, *next_xwl_output;
     struct xwl_seat *xwl_seat, *next_xwl_seat;
 
+    xwl_dmabuf_feedback_destroy(&xwl_screen->default_feedback);
+
     DeleteCallback(&PropertyStateCallback, xwl_property_callback, screen);
 
     xorg_list_for_each_entry_safe(xwl_output, next_xwl_output,
diff --git a/hw/xwayland/xwayland-screen.h b/hw/xwayland/xwayland-screen.h
index 43414f77d..9ce145e6b 100644
--- a/hw/xwayland/xwayland-screen.h
+++ b/hw/xwayland/xwayland-screen.h
@@ -34,6 +34,7 @@
 #include <dix.h>
 
 #include "xwayland-types.h"
+#include "xwayland-window.h"
 #include "xwayland-output.h"
 #include "xwayland-glamor.h"
 #include "xwayland-drm-lease.h"
@@ -101,6 +102,8 @@ struct xwl_screen {
     struct zwp_keyboard_shortcuts_inhibit_manager_v1 *shortcuts_inhibit_manager;
     struct zwp_keyboard_shortcuts_inhibitor_v1 *shortcuts_inhibit;
     struct zwp_linux_dmabuf_v1 *dmabuf;
+    int dmabuf_protocol_version;
+    struct xwl_dmabuf_feedback default_feedback;
     struct zxdg_output_manager_v1 *xdg_output_manager;
     struct wp_viewporter *viewporter;
     struct xorg_list drm_lease_devices;
diff --git a/hw/xwayland/xwayland-window.c b/hw/xwayland/xwayland-window.c
index 0f6cacd3f..03bff8066 100644
--- a/hw/xwayland/xwayland-window.c
+++ b/hw/xwayland/xwayland-window.c
@@ -27,6 +27,8 @@
 #include <dix-config.h>
 #endif
 
+#include <sys/mman.h>
+
 #include <X11/X.h>
 #include <X11/Xatom.h>
 
@@ -45,6 +47,7 @@
 
 #include "viewporter-client-protocol.h"
 #include "xdg-shell-client-protocol.h"
+#include "linux-dmabuf-unstable-v1-client-protocol.h"
 
 static DevPrivateKeyRec xwl_window_private_key;
 static DevPrivateKeyRec xwl_damage_private_key;
@@ -767,6 +770,11 @@ ensure_surface_for_window(WindowPtr window)
     if (!xwl_screen->rootless && !xwl_create_root_surface(xwl_window))
         goto err;
 
+#ifdef XWL_HAS_GLAMOR
+    if (xwl_screen->dmabuf_protocol_version >= 4)
+        xwl_dmabuf_setup_feedback_for_window(xwl_window);
+#endif
+
     wl_display_flush(xwl_screen->display);
 
     send_surface_id_event(xwl_window);
@@ -852,6 +860,43 @@ xwl_realize_window(WindowPtr window)
     return ensure_surface_for_window(window);
 }
 
+void
+xwl_device_formats_destroy(struct xwl_device_formats *dev_formats)
+{
+	for (int j = 0; j < dev_formats->num_formats; j++) {
+		free(dev_formats->formats[j].modifiers);
+	}
+	free(dev_formats->formats);
+}
+
+void
+xwl_dmabuf_feedback_clear_dev_formats(struct xwl_dmabuf_feedback *xwl_feedback)
+{
+    if (xwl_feedback->dev_formats_len == 0)
+        return;
+
+    for (int i = 0; i < xwl_feedback->dev_formats_len; i++) {
+        struct xwl_device_formats *dev_format = &xwl_feedback->dev_formats[i];
+		xwl_device_formats_destroy(dev_format);
+    }
+    free(xwl_feedback->dev_formats);
+    xwl_feedback->dev_formats = NULL;
+    xwl_feedback->dev_formats_len = 0;
+}
+
+void
+xwl_dmabuf_feedback_destroy(struct xwl_dmabuf_feedback *xwl_feedback)
+{
+    munmap(xwl_feedback->format_table.entry,
+           xwl_feedback->format_table.len * sizeof(struct xwl_format_table_entry));
+    xwl_dmabuf_feedback_clear_dev_formats(xwl_feedback);
+
+    if (xwl_feedback->dmabuf_feedback)
+        zwp_linux_dmabuf_feedback_v1_destroy(xwl_feedback->dmabuf_feedback);
+
+    xwl_feedback->dmabuf_feedback = NULL;
+}
+
 Bool
 xwl_unrealize_window(WindowPtr window)
 {
@@ -894,6 +939,8 @@ xwl_unrealize_window(WindowPtr window)
     if (xwl_window_has_viewport_enabled(xwl_window))
         xwl_window_disable_viewport(xwl_window);
 
+    xwl_dmabuf_feedback_destroy(&xwl_window->feedback);
+
 #ifdef GLAMOR_HAS_GBM
     if (xwl_screen->present) {
         struct xwl_present_window *xwl_present_window, *tmp;
diff --git a/hw/xwayland/xwayland-window.h b/hw/xwayland/xwayland-window.h
index 3dbfd2dc2..c4cceef94 100644
--- a/hw/xwayland/xwayland-window.h
+++ b/hw/xwayland/xwayland-window.h
@@ -37,6 +37,44 @@
 
 #include "xwayland-types.h"
 
+struct xwl_format_table_entry {
+    uint32_t format;
+    uint32_t pad;
+    uint64_t modifier;
+};
+
+struct xwl_device_formats {
+    dev_t drm_dev;
+    int supports_scanout;
+    uint32_t num_formats;
+    struct xwl_format *formats;
+};
+
+struct xwl_format_table {
+    /* This is mmapped from the fd given to us by the compositor */
+    int len;
+    struct xwl_format_table_entry *entry;
+};
+
+/*
+ * Helper struct for sharing dmabuf feedback logic between
+ * a screen and a window. The screen will get the default
+ * feedback, and a window will get a per-surface feedback.
+ */
+struct xwl_dmabuf_feedback {
+    struct zwp_linux_dmabuf_feedback_v1 *dmabuf_feedback;
+    struct xwl_format_table format_table;
+    dev_t main_dev;
+    /*
+     * This will be filled in during wl events and copied to
+     * dev_formats on dmabuf_feedback.tranche_done
+     */
+    struct xwl_device_formats tmp_tranche;
+    int feedback_done;
+    int dev_formats_len;
+    struct xwl_device_formats *dev_formats;
+};
+
 struct xwl_window {
     struct xwl_screen *xwl_screen;
     struct wl_surface *surface;
@@ -61,6 +99,7 @@ struct xwl_window {
 #ifdef XWL_HAS_LIBDECOR
     struct libdecor_frame *libdecor_frame;
 #endif
+    struct xwl_dmabuf_feedback feedback;
 };
 
 struct xwl_window *xwl_window_get(WindowPtr window);
@@ -93,4 +132,8 @@ void xwl_window_post_damage(struct xwl_window *xwl_window);
 void xwl_window_create_frame_callback(struct xwl_window *xwl_window);
 Bool xwl_window_init(void);
 
+void xwl_dmabuf_feedback_destroy(struct xwl_dmabuf_feedback *xwl_feedback);
+void xwl_dmabuf_feedback_clear_dev_formats(struct xwl_dmabuf_feedback *xwl_feedback);
+void xwl_device_formats_destroy(struct xwl_device_formats *dev_formats);
+
 #endif /* XWAYLAND_WINDOW_H */
-- 
GitLab


From c0fc9aabb35862e98c9531a56aa4e3ff1fcad615 Mon Sep 17 00:00:00 2001
From: Austin Shafer <ashafer@nvidia.com>
Date: Tue, 23 Nov 2021 16:53:43 -0500
Subject: [PATCH 04/11] xwayland: Add get_drawable_modifiers implementation

This reads from the format list, which is not yet filled in.
---
 hw/xwayland/xwayland-glamor-eglstream.c |  2 +-
 hw/xwayland/xwayland-glamor-gbm.c       |  2 +-
 hw/xwayland/xwayland-glamor.c           | 86 +++++++++++++++++++++----
 hw/xwayland/xwayland-glamor.h           |  2 +
 hw/xwayland/xwayland-window.h           |  1 +
 5 files changed, 79 insertions(+), 14 deletions(-)

diff --git a/hw/xwayland/xwayland-glamor-eglstream.c b/hw/xwayland/xwayland-glamor-eglstream.c
index 9f95e6c14..b2fe28e0f 100644
--- a/hw/xwayland/xwayland-glamor-eglstream.c
+++ b/hw/xwayland/xwayland-glamor-eglstream.c
@@ -932,7 +932,7 @@ static const dri3_screen_info_rec xwl_dri3_info = {
     .open_client = xwl_dri3_open_client,
     .get_formats = xwl_glamor_get_formats,
     .get_modifiers = xwl_glamor_get_modifiers,
-    .get_drawable_modifiers = glamor_get_drawable_modifiers,
+    .get_drawable_modifiers = xwl_glamor_get_drawable_modifiers,
 };
 
 static Bool
diff --git a/hw/xwayland/xwayland-glamor-gbm.c b/hw/xwayland/xwayland-glamor-gbm.c
index 60c63ba99..f278edcba 100644
--- a/hw/xwayland/xwayland-glamor-gbm.c
+++ b/hw/xwayland/xwayland-glamor-gbm.c
@@ -660,7 +660,7 @@ static const dri3_screen_info_rec xwl_dri3_info = {
     .open_client = xwl_dri3_open_client,
     .get_formats = xwl_glamor_get_formats,
     .get_modifiers = xwl_glamor_get_modifiers,
-    .get_drawable_modifiers = glamor_get_drawable_modifiers,
+    .get_drawable_modifiers = xwl_glamor_get_drawable_modifiers,
 };

 static const char *
diff --git a/hw/xwayland/xwayland-glamor.c b/hw/xwayland/xwayland-glamor.c
index bf74163c1..cf7a1f9ac 100644
--- a/hw/xwayland/xwayland-glamor.c
+++ b/hw/xwayland/xwayland-glamor.c
@@ -168,26 +168,22 @@ xwl_glamor_get_formats(ScreenPtr screen,
     return TRUE;
 }
 
-Bool
-xwl_glamor_get_modifiers(ScreenPtr screen, uint32_t format,
-                         uint32_t *num_modifiers, uint64_t **modifiers)
+static Bool
+xwl_get_modifiers_for_format(struct xwl_format *format_array, int num_formats,
+                             uint32_t format, uint32_t *num_modifiers, uint64_t **modifiers)
 {
-    struct xwl_screen *xwl_screen = xwl_screen_get(screen);
     struct xwl_format *xwl_format = NULL;
     int i;
 
-    /* Explicitly zero the count as the caller may ignore the return value */
     *num_modifiers = 0;
+    *modifiers = NULL;
 
-    if (!xwl_screen->dmabuf)
-        return FALSE;
-
-    if (xwl_screen->num_formats == 0)
+    if (num_formats == 0)
        return TRUE;
 
-    for (i = 0; i < xwl_screen->num_formats; i++) {
-       if (xwl_screen->formats[i].format == format) {
-          xwl_format = &xwl_screen->formats[i];
+    for (i = 0; i < num_formats; i++) {
+       if (format_array[i].format == format) {
+          xwl_format = &format_array[i];
           break;
        }
     }
@@ -208,6 +204,72 @@ xwl_glamor_get_modifiers(ScreenPtr screen, uint32_t format,
     return TRUE;
 }
 
+static Bool
+xwl_get_modifiers_for_device(struct xwl_dmabuf_feedback *feedback, dev_t device,
+                             uint32_t format, uint32_t *num_modifiers,
+                             uint64_t **modifiers)
+{
+    struct xwl_device_formats *dev_formats = NULL;
+
+    /* Now try to find a matching set of tranches for the window's device */
+    for (int i = 0; i < feedback->dev_formats_len; i++) {
+        if (feedback->dev_formats[i].drm_dev == device)
+            dev_formats = &feedback->dev_formats[i];
+    }
+
+    if (!dev_formats)
+        return FALSE;
+
+    return xwl_get_modifiers_for_format(dev_formats->formats, dev_formats->num_formats,
+                                        format, num_modifiers, modifiers);
+}
+
+Bool
+xwl_glamor_get_modifiers(ScreenPtr screen, uint32_t format,
+                         uint32_t *num_modifiers, uint64_t **modifiers)
+{
+    struct xwl_screen *xwl_screen = xwl_screen_get(screen);
+
+    /* Explicitly zero the count as the caller may ignore the return value */
+    *num_modifiers = 0;
+    *modifiers = NULL;
+
+    if (!xwl_screen->dmabuf)
+        return FALSE;
+
+    return xwl_get_modifiers_for_format(xwl_screen->formats, xwl_screen->num_formats,
+                                        format, num_modifiers, modifiers);
+}
+
+Bool
+xwl_glamor_get_drawable_modifiers(DrawablePtr drawable, uint32_t format,
+                                  uint32_t *num_modifiers, uint64_t **modifiers)
+{
+    struct xwl_screen *xwl_screen = xwl_screen_get(drawable->pScreen);
+    struct xwl_window *xwl_window;
+
+    *num_modifiers = 0;
+    *modifiers = NULL;
+
+    /* We can only return per-drawable modifiers if the compositor supports feedback */
+    if (xwl_screen->dmabuf_protocol_version < 4)
+        return TRUE;
+
+    if (drawable->type != DRAWABLE_WINDOW || !xwl_screen->dmabuf)
+        return FALSE;
+
+    xwl_window = xwl_window_from_window((WindowPtr)drawable);
+
+    /* couldn't find drawable for window */
+    if (!xwl_window)
+        return FALSE;
+
+    return xwl_get_modifiers_for_device(&xwl_window->feedback,
+                                        xwl_screen->default_feedback.main_dev,
+                                        format, num_modifiers, modifiers);
+
+}
+
 static void
 xwl_dmabuf_handle_format(void *data, struct zwp_linux_dmabuf_v1 *dmabuf,
                          uint32_t format)
diff --git a/hw/xwayland/xwayland-glamor.h b/hw/xwayland/xwayland-glamor.h
index 5c3661de3..4e0c1e32f 100644
--- a/hw/xwayland/xwayland-glamor.h
+++ b/hw/xwayland/xwayland-glamor.h
@@ -131,6 +131,8 @@ Bool xwl_glamor_get_formats(ScreenPtr screen,
                             CARD32 *num_formats, CARD32 **formats);
 Bool xwl_glamor_get_modifiers(ScreenPtr screen, uint32_t format,
                               uint32_t *num_modifiers, uint64_t **modifiers);
+Bool xwl_glamor_get_drawable_modifiers(DrawablePtr drawable, uint32_t format,
+                                       uint32_t *num_modifiers, uint64_t **modifiers);
 Bool xwl_glamor_check_flip(PixmapPtr pixmap);
 
 #ifdef XV
diff --git a/hw/xwayland/xwayland-window.h b/hw/xwayland/xwayland-window.h
index c4cceef94..883d7c118 100644
--- a/hw/xwayland/xwayland-window.h
+++ b/hw/xwayland/xwayland-window.h
@@ -34,6 +34,7 @@
 #include <dix.h>
 #include <propertyst.h>
 #include <validate.h>
+#include <wayland-util.h>
 
 #include "xwayland-types.h"
 
-- 
GitLab


From ecffa843cf8dc6b7dc2515a553ebcd18a3003e8f Mon Sep 17 00:00:00 2001
From: Austin Shafer <ashafer@nvidia.com>
Date: Thu, 2 Dec 2021 12:39:59 -0500
Subject: [PATCH 05/11] xwayland: Make helper for returning a list of formats

This adds xwl_get_formats
---
 hw/xwayland/xwayland-glamor.c | 36 ++++++++++++++++++++++-------------
 1 file changed, 23 insertions(+), 13 deletions(-)

diff --git a/hw/xwayland/xwayland-glamor.c b/hw/xwayland/xwayland-glamor.c
index cf7a1f9ac..a5c937728 100644
--- a/hw/xwayland/xwayland-glamor.c
+++ b/hw/xwayland/xwayland-glamor.c
@@ -141,12 +141,32 @@ wl_drm_format_for_depth(int depth)
     }
 }
 
+static Bool
+xwl_get_formats(struct xwl_format *format_array, int format_array_len,
+               uint32_t *num_formats, uint32_t **formats)
+{
+    *num_formats = 0;
+    *formats = NULL;
+
+    if (format_array_len == 0)
+       return TRUE;
+
+    *formats = calloc(format_array_len, sizeof(CARD32));
+    if (*formats == NULL)
+        return FALSE;
+
+    for (int i = 0; i < format_array_len; i++)
+       (*formats)[i] = format_array[i].format;
+    *num_formats = format_array_len;
+
+    return TRUE;
+}
+
 Bool
 xwl_glamor_get_formats(ScreenPtr screen,
                        CARD32 *num_formats, CARD32 **formats)
 {
     struct xwl_screen *xwl_screen = xwl_screen_get(screen);
-    int i;
 
     /* Explicitly zero the count as the caller may ignore the return value */
     *num_formats = 0;
@@ -154,18 +174,8 @@ xwl_glamor_get_formats(ScreenPtr screen,
     if (!xwl_screen->dmabuf)
         return FALSE;
 
-    if (xwl_screen->num_formats == 0)
-       return TRUE;
-
-    *formats = calloc(xwl_screen->num_formats, sizeof(CARD32));
-    if (*formats == NULL)
-        return FALSE;
-
-    for (i = 0; i < xwl_screen->num_formats; i++)
-       (*formats)[i] = xwl_screen->formats[i].format;
-    *num_formats = xwl_screen->num_formats;
-
-    return TRUE;
+    return xwl_get_formats(xwl_screen->formats, xwl_screen->num_formats,
+                           num_formats, formats);
 }
 
 static Bool
-- 
GitLab


From aae20b0e2d5b0ad12001169edd90b758cee30aea Mon Sep 17 00:00:00 2001
From: Austin Shafer <ashafer@nvidia.com>
Date: Thu, 2 Dec 2021 12:54:23 -0500
Subject: [PATCH 06/11] xwayland: Return default feedback in xwl_screen

If protocol version 4 of linux_dmabuf is in use, then the compositor
may not return anything with the modifiers event. We instead
will return the formats/mods reported for the main device.
---
 hw/xwayland/xwayland-glamor.c | 73 ++++++++++++++++++++++++++++-------
 1 file changed, 60 insertions(+), 13 deletions(-)

diff --git a/hw/xwayland/xwayland-glamor.c b/hw/xwayland/xwayland-glamor.c
index a5c937728..df05501bc 100644
--- a/hw/xwayland/xwayland-glamor.c
+++ b/hw/xwayland/xwayland-glamor.c
@@ -162,6 +162,32 @@ xwl_get_formats(struct xwl_format *format_array, int format_array_len,
     return TRUE;
 }
 
+static Bool
+xwl_get_formats_for_device(struct xwl_dmabuf_feedback *xwl_feedback, dev_t device,
+                           uint32_t *num_formats, uint32_t **formats)
+{
+    uint32_t *ret = NULL;
+    uint32_t count = 0;
+
+    /* go through all matching sets of tranches for the window's device */
+    for (int i = 0; i < xwl_feedback->dev_formats_len; i++) {
+        if (xwl_feedback->dev_formats[i].drm_dev == device) {
+            struct xwl_device_formats *dev_formats = &xwl_feedback->dev_formats[i];
+
+            /* Append the formats from this tranche to the list */
+            ret = xnfreallocarray(ret, count + dev_formats->num_formats, sizeof(CARD32));
+
+            for (int j = 0; j < dev_formats->num_formats; j++)
+                ret[count++] = dev_formats->formats[j].format;
+        }
+    }
+
+    *num_formats = count;
+    *formats = ret;
+
+    return TRUE;
+}
+
 Bool
 xwl_glamor_get_formats(ScreenPtr screen,
                        CARD32 *num_formats, CARD32 **formats)
@@ -174,8 +200,13 @@ xwl_glamor_get_formats(ScreenPtr screen,
     if (!xwl_screen->dmabuf)
         return FALSE;
 
-    return xwl_get_formats(xwl_screen->formats, xwl_screen->num_formats,
-                           num_formats, formats);
+    if (xwl_screen->dmabuf_protocol_version >= 4)
+        return xwl_get_formats_for_device(&xwl_screen->default_feedback,
+                                          xwl_screen->default_feedback.main_dev,
+                                          num_formats, formats);
+    else
+        return xwl_get_formats(xwl_screen->formats, xwl_screen->num_formats,
+                               num_formats, formats);
 }
 
 static Bool
@@ -219,19 +250,18 @@ xwl_get_modifiers_for_device(struct xwl_dmabuf_feedback *feedback, dev_t device,
                              uint32_t format, uint32_t *num_modifiers,
                              uint64_t **modifiers)
 {
-    struct xwl_device_formats *dev_formats = NULL;
-
     /* Now try to find a matching set of tranches for the window's device */
     for (int i = 0; i < feedback->dev_formats_len; i++) {
-        if (feedback->dev_formats[i].drm_dev == device)
-            dev_formats = &feedback->dev_formats[i];
-    }
+        struct xwl_device_formats *dev_formats = &feedback->dev_formats[i];
 
-    if (!dev_formats)
-        return FALSE;
+        if (dev_formats->drm_dev == device &&
+            xwl_get_modifiers_for_format(dev_formats->formats, dev_formats->num_formats,
+                                         format, num_modifiers, modifiers)) {
+            return TRUE;
+        }
+    }
 
-    return xwl_get_modifiers_for_format(dev_formats->formats, dev_formats->num_formats,
-                                        format, num_modifiers, modifiers);
+    return FALSE;
 }
 
 Bool
@@ -247,8 +277,13 @@ xwl_glamor_get_modifiers(ScreenPtr screen, uint32_t format,
     if (!xwl_screen->dmabuf)
         return FALSE;
 
-    return xwl_get_modifiers_for_format(xwl_screen->formats, xwl_screen->num_formats,
-                                        format, num_modifiers, modifiers);
+    if (xwl_screen->dmabuf_protocol_version >= 4)
+        return xwl_get_modifiers_for_device(&xwl_screen->default_feedback,
+                                            xwl_screen->default_feedback.main_dev,
+                                            format, num_modifiers, modifiers);
+    else
+        return xwl_get_modifiers_for_format(xwl_screen->formats, xwl_screen->num_formats,
+                                            format, num_modifiers, modifiers);
 }
 
 Bool
@@ -560,6 +595,18 @@ xwl_screen_set_dmabuf_interface(struct xwl_screen *xwl_screen,
     xwl_screen->dmabuf_protocol_version = supported_version;
     zwp_linux_dmabuf_v1_add_listener(xwl_screen->dmabuf, &xwl_dmabuf_listener, xwl_screen);
 
+    /* If the compositor supports it, request the default feedback hints */
+    if (version >= 4) {
+        xwl_screen->default_feedback.dmabuf_feedback =
+            zwp_linux_dmabuf_v1_get_default_feedback(xwl_screen->dmabuf);
+        if (!xwl_screen->default_feedback.dmabuf_feedback)
+            return FALSE;
+
+        zwp_linux_dmabuf_feedback_v1_add_listener(xwl_screen->default_feedback.dmabuf_feedback,
+                &xwl_dmabuf_feedback_listener,
+                &xwl_screen->default_feedback);
+    }
+
     return TRUE;
 }
 
-- 
GitLab


From b867c0ac822c4e1b827f7904592b8e2d32225bef Mon Sep 17 00:00:00 2001
From: Austin Shafer <ashafer@nvidia.com>
Date: Fri, 3 Dec 2021 11:08:47 -0500
Subject: [PATCH 07/11] xwayland: Add proper support for telling if a
 format/mod is supported

This adds to xwl_glamor_is_modifier_supported, where if feedback
is in use we will check that the format/mod is allowed in any
device advertised by the compositor.
---
 hw/xwayland/xwayland-glamor.c | 58 +++++++++++++++++++++++++++++++----
 1 file changed, 52 insertions(+), 6 deletions(-)

diff --git a/hw/xwayland/xwayland-glamor.c b/hw/xwayland/xwayland-glamor.c
index df05501bc..f708c943f 100644
--- a/hw/xwayland/xwayland-glamor.c
+++ b/hw/xwayland/xwayland-glamor.c
@@ -97,16 +97,16 @@ xwl_glamor_check_flip(PixmapPtr pixmap)
     return TRUE;
 }
 
-Bool
-xwl_glamor_is_modifier_supported(struct xwl_screen *xwl_screen,
-                                 uint32_t format, uint64_t modifier)
+static Bool
+xwl_glamor_is_modifier_supported_in_formats(struct xwl_format *formats, int num_formats,
+                                            uint32_t format, uint64_t modifier)
 {
     struct xwl_format *xwl_format = NULL;
     int i;
 
-    for (i = 0; i < xwl_screen->num_formats; i++) {
-        if (xwl_screen->formats[i].format == format) {
-            xwl_format = &xwl_screen->formats[i];
+    for (i = 0; i < num_formats; i++) {
+        if (formats[i].format == format) {
+            xwl_format = &formats[i];
             break;
         }
     }
@@ -122,6 +122,52 @@ xwl_glamor_is_modifier_supported(struct xwl_screen *xwl_screen,
     return FALSE;
 }
 
+static Bool
+xwl_feedback_is_modifier_supported(struct xwl_dmabuf_feedback *xwl_feedback,
+                                   uint32_t format, uint64_t modifier)
+{
+    struct xwl_device_formats *dev_formats = NULL;
+
+    for (int i = 0; i < xwl_feedback->dev_formats_len; i++) {
+        dev_formats = &xwl_feedback->dev_formats[i];
+
+        if (xwl_glamor_is_modifier_supported_in_formats(dev_formats->formats,
+                                                        dev_formats->num_formats,
+                                                        format, modifier))
+            return TRUE;
+    }
+    return FALSE;
+}
+
+
+Bool
+xwl_glamor_is_modifier_supported(struct xwl_screen *xwl_screen,
+                                 uint32_t format, uint64_t modifier)
+{
+    struct xwl_window *xwl_window;
+
+    /*
+     * If we are using dmabuf v4, then we need to check in the main
+     * device and per-window format lists. For older protocol
+     * versions we can just check the list returned by the dmabuf.modifier
+     * events in xwl_screen
+     */
+    if (xwl_screen->dmabuf_protocol_version < 4)
+        return xwl_glamor_is_modifier_supported_in_formats(xwl_screen->formats,
+                                                           xwl_screen->num_formats,
+                                                           format, modifier);
+
+    if (xwl_feedback_is_modifier_supported(&xwl_screen->default_feedback, format, modifier))
+        return TRUE;
+
+    xorg_list_for_each_entry(xwl_window, &xwl_screen->window_list, link_window) {
+        if (xwl_feedback_is_modifier_supported(&xwl_window->feedback, format, modifier))
+            return TRUE;
+    }
+
+    return FALSE;
+}
+
 uint32_t
 wl_drm_format_for_depth(int depth)
 {
-- 
GitLab


From 63585d70aa432abfadba3805d34e0d6deb6cd1db Mon Sep 17 00:00:00 2001
From: Austin Shafer <ashafer@nvidia.com>
Date: Fri, 10 Dec 2021 10:38:15 -0500
Subject: [PATCH 08/11] dri3: Don't compute intersection with drawable
 modifiers

In dri3_get_supported_modifiers we were previously intersecting
the drawable mods and the screen mods. This meant all screen mods
were returned, but the ones compatible with the drawable were
returned in the drawable mods list and the rest are returned in
the screen mods list.

This is a problem with linux_dmabuf v4 since the drawable mods may
contain different mods not found in the screen mods (such as scanout
entries). This change removes the intersection, and just returns
the drawable/screen mod lists directly.
---
 dri3/dri3_screen.c | 56 ++++++++++------------------------------------
 1 file changed, 12 insertions(+), 44 deletions(-)

diff --git a/dri3/dri3_screen.c b/dri3/dri3_screen.c
index 3c7e5bf60..bc96e5339 100644
--- a/dri3/dri3_screen.c
+++ b/dri3/dri3_screen.c
@@ -211,18 +211,17 @@ cache_formats_and_modifiers(ScreenPtr screen)
 int
 dri3_get_supported_modifiers(ScreenPtr screen, DrawablePtr drawable,
                              CARD8 depth, CARD8 bpp,
-                             CARD32 *num_intersect_modifiers,
-                             CARD64 **intersect_modifiers,
+                             CARD32 *num_drawable_modifiers,
+                             CARD64 **drawable_modifiers,
                              CARD32 *num_screen_modifiers,
                              CARD64 **screen_modifiers)
 {
     dri3_screen_priv_ptr        ds = dri3_screen_priv(screen);
     const dri3_screen_info_rec *info = ds->info;
-    int                         i, j;
+    int                         i;
     int                         ret;
     uint32_t                    num_drawable_mods;
     uint64_t                   *drawable_mods;
-    CARD64                     *intersect_mods = NULL;
     CARD64                     *screen_mods = NULL;
     CARD32                      format;
     dri3_dmabuf_format_ptr      screen_format = NULL;
@@ -248,10 +247,15 @@ dri3_get_supported_modifiers(ScreenPtr screen, DrawablePtr drawable,
 
     if (screen_format->num_modifiers == 0) {
         *num_screen_modifiers = 0;
-        *num_intersect_modifiers = 0;
+        *num_drawable_modifiers = 0;
         return Success;
     }
 
+    /* copy the screen mods so we can return an owned allocation */
+    screen_mods = xnfalloc(screen_format->num_modifiers * sizeof(CARD64));
+    memcpy(screen_mods, screen_format->modifiers,
+           screen_format->num_modifiers * sizeof(CARD64));
+
     if (!info->get_drawable_modifiers ||
         !info->get_drawable_modifiers(drawable, format,
                                       &num_drawable_mods,
@@ -260,47 +264,11 @@ dri3_get_supported_modifiers(ScreenPtr screen, DrawablePtr drawable,
         drawable_mods = NULL;
     }
 
-    /* We're allocating slightly more memory than necessary but it reduces
-     * the complexity of finding the intersection set.
-     */
-    screen_mods = malloc(screen_format->num_modifiers * sizeof(CARD64));
-    if (!screen_mods)
-        return BadAlloc;
-    if (num_drawable_mods > 0) {
-        intersect_mods = malloc(screen_format->num_modifiers * sizeof(CARD64));
-        if (!intersect_mods) {
-            free(screen_mods);
-            return BadAlloc;
-        }
-    }
-
-    *num_screen_modifiers = 0;
-    *num_intersect_modifiers = 0;
-    for (i = 0; i < screen_format->num_modifiers; i++) {
-        CARD64 modifier = screen_format->modifiers[i];
-        Bool intersect = FALSE;
-
-        for (j = 0; j < num_drawable_mods; j++) {
-            if (drawable_mods[j] == modifier) {
-                intersect = TRUE;
-                break;
-            }
-        }
-
-        if (intersect) {
-            intersect_mods[*num_intersect_modifiers] = modifier;
-            *num_intersect_modifiers += 1;
-        } else {
-            screen_mods[*num_screen_modifiers] = modifier;
-            *num_screen_modifiers += 1;
-        }
-    }
-
-    assert(*num_intersect_modifiers + *num_screen_modifiers == screen_format->num_modifiers);
+    *num_drawable_modifiers = num_drawable_mods;
+    *drawable_modifiers = drawable_mods;
 
-    *intersect_modifiers = intersect_mods;
+    *num_screen_modifiers = screen_format->num_modifiers;
     *screen_modifiers = screen_mods;
-    free(drawable_mods);
 
     return Success;
 }
-- 
GitLab


From f8f8358da5367099ccefe1b789cc2026cc95183a Mon Sep 17 00:00:00 2001
From: Austin Shafer <ashafer@nvidia.com>
Date: Tue, 7 Dec 2021 15:03:23 -0500
Subject: [PATCH 09/11] xwayland: Send PresentCompleteModeSuboptimalCopy if
 dmabuf feedback was resent
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

If the dmabuf protocol's feedback object gave us a new list of
modifiers, send PresentCompleteModeSuboptimalCopy to the client
to inform them that they need to call GetSupportedModifiers.

Reviewed-by: Michel Dänzer <mdaenzer@redhat.com>
---
 hw/xwayland/xwayland-glamor.c  |  1 +
 hw/xwayland/xwayland-present.c | 29 ++++++++++++++++++++++++++++-
 hw/xwayland/xwayland-window.h  |  7 +++++++
 3 files changed, 36 insertions(+), 1 deletion(-)

diff --git a/hw/xwayland/xwayland-glamor.c b/hw/xwayland/xwayland-glamor.c
index f708c943f..f4f57ce83 100644
--- a/hw/xwayland/xwayland-glamor.c
+++ b/hw/xwayland/xwayland-glamor.c
@@ -577,6 +577,7 @@ xwl_dmabuf_feedback_done(void *data, struct zwp_linux_dmabuf_feedback_v1 *dmabuf
     struct xwl_dmabuf_feedback *xwl_feedback = data;
 
     xwl_feedback->feedback_done = true;
+    xwl_feedback->unprocessed_feedback_pending = true;
 }
 
 static void
diff --git a/hw/xwayland/xwayland-present.c b/hw/xwayland/xwayland-present.c
index 99e476b2f..2c0e1a05c 100644
--- a/hw/xwayland/xwayland-present.c
+++ b/hw/xwayland/xwayland-present.c
@@ -296,6 +296,7 @@ xwl_present_flip_notify_vblank(present_vblank_ptr vblank, uint64_t ust, uint64_t
 {
     WindowPtr                   window = vblank->window;
     struct xwl_present_window *xwl_present_window = xwl_present_window_priv(window);
+    uint8_t mode = PresentCompleteModeFlip;
 
     DebugPresent(("\tn %" PRIu64 " %p %" PRIu64 " %" PRIu64 ": %08" PRIx32 " -> %08" PRIx32 "\n",
                   vblank->event_id, vblank, vblank->exec_msc, vblank->target_msc,
@@ -321,7 +322,10 @@ xwl_present_flip_notify_vblank(present_vblank_ptr vblank, uint64_t ust, uint64_t
 
     xwl_present_window->flip_active = vblank;
 
-    present_vblank_notify(vblank, PresentCompleteKindPixmap, PresentCompleteModeFlip, ust, crtc_msc);
+    if (vblank->reason == PRESENT_FLIP_REASON_BUFFER_FORMAT)
+        mode = PresentCompleteModeSuboptimalCopy;
+
+    present_vblank_notify(vblank, PresentCompleteKindPixmap, mode, ust, crtc_msc);
 
     if (vblank->abort_flip)
         xwl_present_flips_stop(window);
@@ -559,6 +563,27 @@ xwl_present_flush(WindowPtr window)
     glamor_block_handler(window->drawable.pScreen);
 }
 
+static void
+xwl_present_maybe_set_reason(struct xwl_window *xwl_window, PresentFlipReason *reason)
+{
+    struct xwl_screen *xwl_screen = xwl_window->xwl_screen;
+
+    if (!reason || xwl_screen->dmabuf_protocol_version < 4)
+        return;
+
+    if (xwl_window->feedback.unprocessed_feedback_pending) {
+        xwl_window->feedback.unprocessed_feedback_pending = 0;
+
+        *reason = PRESENT_FLIP_REASON_BUFFER_FORMAT;
+    }
+
+    if (xwl_screen->default_feedback.unprocessed_feedback_pending) {
+        xwl_screen->default_feedback.unprocessed_feedback_pending = 0;
+
+        *reason = PRESENT_FLIP_REASON_BUFFER_FORMAT;
+    }
+}
+
 static Bool
 xwl_present_check_flip(RRCrtcPtr crtc,
                        WindowPtr present_window,
@@ -579,6 +604,8 @@ xwl_present_check_flip(RRCrtcPtr crtc,
     if (!xwl_window)
         return FALSE;
 
+    xwl_present_maybe_set_reason(xwl_window, reason);
+
     if (!crtc)
         return FALSE;
 
diff --git a/hw/xwayland/xwayland-window.h b/hw/xwayland/xwayland-window.h
index 883d7c118..6565b454a 100644
--- a/hw/xwayland/xwayland-window.h
+++ b/hw/xwayland/xwayland-window.h
@@ -74,6 +74,13 @@ struct xwl_dmabuf_feedback {
     int feedback_done;
     int dev_formats_len;
     struct xwl_device_formats *dev_formats;
+    /*
+     * This flag is used to identify if the feedback
+     * has been resent. If this is true, then the xwayland
+     * clients need to be sent PresentCompleteModeSuboptimalCopy
+     * to tell them to re-request modifiers.
+     */
+    int unprocessed_feedback_pending;
 };
 
 struct xwl_window {
-- 
GitLab


From c7a665754f9766a4393c6dec29306180caa47d35 Mon Sep 17 00:00:00 2001
From: Austin Shafer <ashafer@nvidia.com>
Date: Fri, 2 Sep 2022 11:54:05 -0400
Subject: [PATCH 10/11] Add libdrm 2.4.109 requirement

---
 .gitlab-ci/debian-install.sh | 8 ++++++++
 meson.build                  | 2 +-
 2 files changed, 9 insertions(+), 1 deletion(-)

diff --git a/.gitlab-ci/debian-install.sh b/.gitlab-ci/debian-install.sh
index 164a0c411..5baa76799 100644
--- a/.gitlab-ci/debian-install.sh
+++ b/.gitlab-ci/debian-install.sh
@@ -113,6 +113,14 @@ apt-get install -y \
 
 cd /root
 
+# Xwayland requires drm 2.4.109 for drmGetDeviceFromDevId
+git clone https://gitlab.freedesktop.org/mesa/drm --depth 1 --branch=libdrm-2.4.109
+cd drm
+meson _build
+ninja -C _build -j${FDO_CI_CONCURRENT:-4} install
+cd ..
+rm -rf drm
+
 # xserver requires libxcvt
 git clone https://gitlab.freedesktop.org/xorg/lib/libxcvt.git --depth 1 --branch=libxcvt-0.1.0
 cd libxcvt
diff --git a/meson.build b/meson.build
index a8bc07f19..9e784e403 100644
--- a/meson.build
+++ b/meson.build
@@ -60,7 +60,7 @@ endforeach
 
 add_project_arguments(common_wflags, language : ['c', 'objc'])
 
-libdrm_req = '>= 2.4.89'
+libdrm_req = '>= 2.4.109'
 libselinux_req = '>= 2.0.86'
 xext_req = '>= 1.0.99.4'
 wayland_req = '>= 1.5.0'
-- 
GitLab
