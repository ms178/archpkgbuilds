pkgbase=flac
pkgname=('flac')
pkgver=1.5.0
pkgrel=3.2
pkgdesc='Free Lossless Audio Codec (CS-PGO and BOLT optimized)'
url='https://xiph.org/flac/'
arch=('x86_64')
license=('BSD-3-Clause' 'GPL-2.0-or-later')
depends=('gcc-libs' 'libogg')
makedepends=('nasm' 'doxygen' 'cmake' 'ninja')
source=(https://downloads.xiph.org/releases/flac/flac-${pkgver}.tar.xz)
sha512sums=('4a626e8a1bd126e234c0e5061e3b46f3a27c2065fdfa228fd8cf00d3c7fa2c05fafb5cec36acce7bfce4914bfd7db0b2a27ee15decf2d8c4caad630f62d44ec9')

# ══════════════════════════════════════════════════════════════════════════════
# Custom LLVM Toolchain Configuration
# ══════════════════════════════════════════════════════════════════════════════
: "${_LLVM_DIR:=/home/marcus/toolchain/llvm/stage1/bin}"

prepare() {
  cd flac-${pkgver}

  # Clean stale build directories with cached compiler paths
  rm -rf "$srcdir"/build-* "$srcdir"/*-profiles
}

build() {
  # ════════════════════════════════════════════════════════════════════════════
  # Setup LLVM Toolchain - ALL tools from same installation
  # ════════════════════════════════════════════════════════════════════════════
  local _llvm_bin="${_LLVM_DIR}"

  local _clang="${_llvm_bin}/clang"
  local _clangxx="${_llvm_bin}/clang++"
  local _llvm_profdata="${_llvm_bin}/llvm-profdata"
  local _llvm_bolt="${_llvm_bin}/llvm-bolt"
  local _merge_fdata="${_llvm_bin}/merge-fdata"

  # Verify all tools exist
  local _tool _tool_name
  for _tool in "$_clang" "$_clangxx" "$_llvm_profdata" "$_llvm_bolt" "$_merge_fdata"; do
    if [[ ! -x "$_tool" ]]; then
      error "Required tool not found: $_tool"
      return 1
    fi
  done

  # Log versions to verify consistency
  msg2 "LLVM Toolchain from: ${_llvm_bin}"
  msg2 "  clang:          $("$_clang" --version | head -1)"
  msg2 "  llvm-profdata:  $("$_llvm_profdata" --version | head -1)"
  msg2 "  llvm-bolt:      $("$_llvm_bolt" --version | head -1)"

  # ════════════════════════════════════════════════════════════════════════════
  # Setup directories
  # ════════════════════════════════════════════════════════════════════════════
  local _pgo_dir="$srcdir/pgo-profiles"
  local _cspgo_dir="$srcdir/cspgo-profiles"
  local _bolt_dir="$srcdir/bolt-profiles"
  mkdir -p "$_pgo_dir" "$_cspgo_dir" "$_bolt_dir"

  # Common CMake options
  local _cmake_common_opts=(
    -G Ninja
    -DCMAKE_BUILD_TYPE=Release
    -DCMAKE_C_COMPILER="$_clang"
    -DCMAKE_CXX_COMPILER="$_clangxx"
    -DCMAKE_LINKER_TYPE=LLD
    -DCMAKE_C_STANDARD=23
    -DCMAKE_CXX_STANDARD=23
    -DCMAKE_INSTALL_PREFIX=/usr
    -DCMAKE_INSTALL_MANDIR=/usr/share/man/man1
    -DBUILD_SHARED_LIBS=ON
    -DBUILD_DOCS=OFF
    -DBUILD_EXAMPLES=OFF
    -DINSTALL_MANPAGES=OFF
    -DWITH_STACK_PROTECTOR=OFF
    -DNDEBUG=ON
  )

  # LLD flags: -q emits relocations needed for BOLT
  local _lld_flags="-fuse-ld=lld -Wl,-q"

  # ════════════════════════════════════════════════════════════════════════════
  # STAGE 1: Standard PGO Instrumentation
  # ════════════════════════════════════════════════════════════════════════════
  msg2 "Stage 1/5: Building PGO-instrumented binaries..."

  local _pgo_gen="-fprofile-generate=${_pgo_dir}"

  cmake -S flac-${pkgver} -B build-pgo-gen \
    "${_cmake_common_opts[@]}" \
    -DCMAKE_C_FLAGS="${CFLAGS} ${_pgo_gen}" \
    -DCMAKE_CXX_FLAGS="${CXXFLAGS} ${_pgo_gen}" \
    -DCMAKE_EXE_LINKER_FLAGS="${LDFLAGS} ${_pgo_gen} ${_lld_flags}" \
    -DCMAKE_SHARED_LINKER_FLAGS="${LDFLAGS} ${_pgo_gen} ${_lld_flags}" \
    -DCMAKE_MODULE_LINKER_FLAGS="${LDFLAGS} ${_pgo_gen} ${_lld_flags}"

  cmake --build build-pgo-gen

  msg2 "Running workload for PGO profile generation..."
  ctest --test-dir build-pgo-gen --output-on-failure -j$(nproc)

  local _pgo_profdata="$_pgo_dir/pgo.profdata"
  find "$_pgo_dir" -maxdepth 1 -type f -name '*.profraw' \
    | "$_llvm_profdata" merge -output="$_pgo_profdata" -input-files=-

  [[ -s "$_pgo_profdata" ]] || { error "PGO profile generation failed"; return 1; }
  msg2 "PGO profile: $(du -h "$_pgo_profdata" | cut -f1)"

  # ════════════════════════════════════════════════════════════════════════════
  # STAGE 2: Context-Sensitive PGO (CS-PGO) Instrumentation
  # ════════════════════════════════════════════════════════════════════════════
  msg2 "Stage 2/5: Building CS-PGO instrumented binaries..."

  local _cspgo_gen="-fprofile-use=${_pgo_profdata} -fcs-profile-generate=${_cspgo_dir}"

  cmake -S flac-${pkgver} -B build-cspgo-gen \
    "${_cmake_common_opts[@]}" \
    -DCMAKE_C_FLAGS="${CFLAGS} ${_cspgo_gen}" \
    -DCMAKE_CXX_FLAGS="${CXXFLAGS} ${_cspgo_gen}" \
    -DCMAKE_EXE_LINKER_FLAGS="${LDFLAGS} ${_cspgo_gen} ${_lld_flags}" \
    -DCMAKE_SHARED_LINKER_FLAGS="${LDFLAGS} ${_cspgo_gen} ${_lld_flags}" \
    -DCMAKE_MODULE_LINKER_FLAGS="${LDFLAGS} ${_cspgo_gen} ${_lld_flags}"

  cmake --build build-cspgo-gen

  msg2 "Running workload for CS-PGO profile generation..."
  ctest --test-dir build-cspgo-gen --output-on-failure -j$(nproc)

  # Merge CS-PGO profiles with base PGO profile
  local _cspgo_profdata="$_cspgo_dir/cspgo.profdata"
  find "$_cspgo_dir" -maxdepth 1 -type f -name '*.profraw' \
    | "$_llvm_profdata" merge -output="$_cspgo_profdata" "$_pgo_profdata" -input-files=-

  [[ -s "$_cspgo_profdata" ]] || { error "CS-PGO profile generation failed"; return 1; }
  msg2 "CS-PGO profile: $(du -h "$_cspgo_profdata" | cut -f1)"

  # ════════════════════════════════════════════════════════════════════════════
  # STAGE 3: Build with CS-PGO optimization
  # ════════════════════════════════════════════════════════════════════════════
  msg2 "Stage 3/5: Building CS-PGO optimized binaries..."

  local _pgo_use="-fprofile-use=${_cspgo_profdata}"

  cmake -S flac-${pkgver} -B build-optimized \
    "${_cmake_common_opts[@]}" \
    -DCMAKE_C_FLAGS="${CFLAGS} ${_pgo_use}" \
    -DCMAKE_CXX_FLAGS="${CXXFLAGS} ${_pgo_use}" \
    -DCMAKE_EXE_LINKER_FLAGS="${LDFLAGS} ${_pgo_use} ${_lld_flags}" \
    -DCMAKE_SHARED_LINKER_FLAGS="${LDFLAGS} ${_pgo_use} ${_lld_flags}" \
    -DCMAKE_MODULE_LINKER_FLAGS="${LDFLAGS} ${_pgo_use} ${_lld_flags}"

  cmake --build build-optimized

  # ════════════════════════════════════════════════════════════════════════════
  # STAGE 4: BOLT Instrumentation & Profile Collection
  # ════════════════════════════════════════════════════════════════════════════
  msg2 "Stage 4/5: BOLT instrumentation and profiling..."

  # Binaries to optimize
  local _bolt_binaries=(
    "build-optimized/src/flac/flac"
    "build-optimized/src/metaflac/metaflac"
  )

  # Find shared libraries (real files, not symlinks)
  local _bolt_libs=()
  local _lib
  while IFS= read -r -d '' _lib; do
    _bolt_libs+=("$_lib")
  done < <(find build-optimized/src -name 'lib*.so.*' -type f ! -name '*.orig' -print0 2>/dev/null)

  # Instrument binaries
  local _bin
  for _bin in "${_bolt_binaries[@]}" "${_bolt_libs[@]}"; do
    [[ -f "$_bin" ]] || continue
    msg2 "  Instrumenting $(basename "$_bin")..."
    cp -a "$_bin" "${_bin}.orig"
    "$_llvm_bolt" "${_bin}.orig" \
      --instrument \
      --instrumentation-file-append-pid \
      --instrumentation-file="${_bolt_dir}/$(basename "$_bin").fdata" \
      -o "$_bin" 2>&1 | grep -v "^BOLT-" || {
        warning "BOLT instrumentation failed for $_bin, keeping original"
        cp -a "${_bin}.orig" "$_bin"
      }
  done

  msg2 "Running workload for BOLT profile generation..."
  ctest --test-dir build-optimized --output-on-failure -j$(nproc) || true

  # Merge BOLT profiles
  local _bolt_fdata="$_bolt_dir/merged.fdata"
  local _fdata_files=()
  while IFS= read -r -d '' _f; do
    _fdata_files+=("$_f")
  done < <(find "$_bolt_dir" -maxdepth 1 -name '*.fdata*' -type f -size +0 -print0 2>/dev/null)

  if (( ${#_fdata_files[@]} > 0 )); then
    "$_merge_fdata" "${_fdata_files[@]}" -o "$_bolt_fdata" || true
  fi

  [[ -s "$_bolt_fdata" ]] || warning "BOLT profile empty or missing"

  # ════════════════════════════════════════════════════════════════════════════
  # STAGE 5: Apply BOLT Optimizations
  # ════════════════════════════════════════════════════════════════════════════
  msg2 "Stage 5/5: Applying BOLT optimizations..."

  local _bolt_opts=(
    --dyno-stats
    --lite=false
    --icf=all
    --plt=all
    --hugify
    --peepholes=all
    --x86-strip-redundant-address-size
    --indirect-call-promotion=all
    --reorder-blocks=ext-tsp
    --reorder-functions=cdsort
    --split-all-cold
    --split-eh
    --split-functions
    --split-strategy=cdsplit
  )

  for _bin in "${_bolt_binaries[@]}" "${_bolt_libs[@]}"; do
    [[ -f "${_bin}.orig" ]] || continue

    if [[ -s "$_bolt_fdata" ]]; then
      msg2 "  Optimizing $(basename "$_bin") with BOLT..."
      "$_llvm_bolt" "${_bin}.orig" \
        --data="$_bolt_fdata" \
        "${_bolt_opts[@]}" \
        -o "$_bin" 2>&1 | grep -v "^BOLT-" || {
          warning "BOLT optimization failed for $_bin, using CS-PGO only"
          cp -a "${_bin}.orig" "$_bin"
        }
    else
      warning "No BOLT profile for $_bin, using CS-PGO optimized binary"
      cp -a "${_bin}.orig" "$_bin"
    fi
    rm -f "${_bin}.orig"
  done

  msg "Build complete: CS-PGO + BOLT optimized"
}

check() {
  ctest --test-dir build-optimized --output-on-failure -j$(nproc)
}

package_flac() {
  provides=('libFLAC.so' 'libFLAC.so=8-64' 'libFLAC++.so')

  DESTDIR="${pkgdir}" cmake --install build-optimized

  install -Dm 644 flac-${pkgver}/src/*/*.m4 -t "${pkgdir}/usr/share/aclocal"
  install -Dm 644 flac-${pkgver}/COPYING.Xiph -t "${pkgdir}/usr/share/licenses/${pkgname}"
}
