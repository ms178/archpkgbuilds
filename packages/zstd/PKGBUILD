pkgname=zstd
pkgver=1.5.6
pkgrel=12.1
pkgdesc='Zstandard - Fast real-time compression algorithm'
url='https://facebook.github.io/zstd/'
arch=(x86_64)
license=(BSD GPL2)
depends=(glibc gcc-libs zlib xz lz4 cmake)
makedepends=(gtest)
provides=("libzstd.so" "zstd=${pkgver}" "libzstd.so=1-64")
options=(!debug lto !strip)
source=(https://github.com/facebook/zstd/releases/download/v${pkgver}/zstd-${pkgver}.tar.zst{,.sig}
        fopen-use-m.patch
        multi-thread-default.patch
        notrace.patch
)
sha256sums=('SKIP')

prepare() {
  cd ${pkgname}-${pkgver}

  local src
  for src in "${source[@]}"; do
    src="${src%%::*}"
    src="${src##*/}"
    [[ $src = *.patch ]] || continue
    echo "Applying patch $src..."
    patch -Np1 < "../$src"
  done
  # avoid error on tests without static libs, we use LD_LIBRARY_PATH
  sed '/build static library to build tests/d' -i build/cmake/CMakeLists.txt
  sed 's/libzstd_static/libzstd_shared/g' -i build/cmake/tests/CMakeLists.txt
}

build() {
  cd ${pkgname}-${pkgver}
  # Build zstd (no instrumentation needed for perf)
  cmake -S build/cmake -B build -G Ninja \
    -DCMAKE_BUILD_TYPE=Release \
    -DCMAKE_C_STANDARD=23 \
    -DCMAKE_CXX_STANDARD=23 \
    -DCMAKE_INSTALL_PREFIX=/usr \
    -DCMAKE_INSTALL_LIBDIR=lib \
    -DZSTD_ZLIB_SUPPORT=ON \
    -DZSTD_LZMA_SUPPORT=ON \
    -DZSTD_LZ4_SUPPORT=ON \
    -DZSTD_BUILD_CONTRIB=ON \
    -DZSTD_BUILD_STATIC=OFF \
    -DZSTD_BUILD_TESTS=ON \
    -DZSTD_PROGRAMS_LINK_SHARED=ON \
    -DZSTD_MULTITHREAD_SUPPORT=ON
  cmake --build build

  echo "== Profiling zstd with enhanced workload" # Changed msg2 to echo

  # Create profiling directory
  PROFILE_DIR="/tmp/zstd-profile"
  mkdir -p "$PROFILE_DIR"

  echo "Generating test files..." # Changed msg2 to echo
  # Generate more text content for better dictionary training
  for i in {1..50}; do
    # Mix of different patterns for better dictionary training
    {
      seq 1 2000  # Increased sequence length
      yes "pattern$i" | head -n 2000 # Increased repetitions
      dd if=/dev/urandom bs=1K count=20 2>/dev/null | base64 # Increased random data
      printf "%0.sA" $(seq 1 20000) # Increased "A" sequence
      printf "%0.sB" $(seq 1 20000) # Increased "B" sequence
      # Add more diverse patterns here if needed
      echo "Common header $i"
      echo "Common footer $i"
    } > "$PROFILE_DIR/training_$i.txt"
  done

  # Regular test files for compression
  dd if=/dev/urandom bs=1M count=100 2>/dev/null | base64 > "$PROFILE_DIR/text1.txt"
  seq 1 1000000 > "$PROFILE_DIR/numbers.txt"
  yes "repeated data" | head -n 1000000 > "$PROFILE_DIR/repeated.txt"
  dd if=/dev/urandom of="$PROFILE_DIR/random.bin" bs=1M count=100 2>/dev/null

  # Files with different compression ratios
  for i in {1..5}; do
    dd if=/dev/urandom bs=1K count=$((i * 1000)) 2>/dev/null > "$PROFILE_DIR/binary_$i.bin"
  done

  # Highly compressible files
  for i in {1..3}; do
    printf "%0.sA" $(seq 1 $((i * 1000000))) > "$PROFILE_DIR/compressible_$i.txt"
  done

  # Mixed-content files
  if [ -d "/usr/share/doc" ]; then
    find /usr/share/doc -type f -name "*.txt" 2>/dev/null | head -n 20 | while read -r file; do
      cat "$file" 2>/dev/null
    done > "$PROFILE_DIR/docs.txt"
  else
    # Fallback content
    for i in {1..1000}; do
      echo "Sample documentation line $i with some common technical terms: buffer, memory, cache, process, thread, socket"
    done > "$PROFILE_DIR/docs.txt"
  fi

  # Create a sample source code file for testing
  {
    echo "#include <stdio.h>"
    echo "int main() {"
    echo "  printf(\"Hello, world!\\n\");"
    echo "  return 0;"
    echo "}"
  } > "$PROFILE_DIR/source_code.txt"

  echo "Running profiling workload..." # Changed msg2 to echo
  ZSTD="$PWD/build/programs/zstd"

  # Run perf record with all workloads
  perf record -o /tmp/perf.data -b --max-size=6G -F 5000 -e cycles:u,cache-misses:u,branch-misses:u -- bash -c "
    # First create and test dictionary
    echo 'Training dictionary...' # Changed msg2 to echo
    $ZSTD --train $PROFILE_DIR/training_*.txt -o $PROFILE_DIR/dictionary --maxdict=16384

    # Test dictionary compression
    for file in $PROFILE_DIR/training_*.txt; do
      $ZSTD -f -D $PROFILE_DIR/dictionary \"\$file\" -o /dev/null
    done

    # Single-threaded compression at different levels
    for level in 1 3 5 9 15 19; do
      for file in $PROFILE_DIR/*; do
        [[ \"\$file\" != *\"training_\"* ]] && $ZSTD -f -\$level \"\$file\" -o /dev/null
      done
    done

    # Multi-threaded compression
    for thread in 2 4 8; do
      for file in $PROFILE_DIR/*; do
        [[ \"\$file\" != *\"training_\"* ]] && $ZSTD -f -T\$thread -3 \"\$file\" -o /dev/null
      done
    done

    # Long range mode for larger files
    for file in $PROFILE_DIR/*.bin $PROFILE_DIR/text1.txt; do
      $ZSTD -f --long \"\$file\" -o /dev/null
    done

    # Streaming compression
    for file in $PROFILE_DIR/*; do
      [[ \"\$file\" != *\"training_\"* ]] && cat \"\$file\" | $ZSTD -f > /dev/null
    done

    # Decompression workload (stderr redirected)
    for file in $PROFILE_DIR/*; do
      if [[ \"\$file\" != *\"training_\"* ]] && [[ \"\$file\" != *\".zst\" ]]; then
        $ZSTD -f -3 \"\$file\" -o \"\$file.zst\"
        $ZSTD -f -d \"\$file.zst\" -o /dev/null 2>/dev/null
      fi
    done

    # --- Dictionary Training (include more data types) ---
    echo 'Training dictionary...' # Changed msg2 to echo
    cat "$PROFILE_DIR/training_*.txt" "$PROFILE_DIR/docs.txt" "$PROFILE_DIR/source_code.txt" | "$ZSTD" -f --train - -o "$PROFILE_DIR/dictionary" --maxdict=32768

    # Test dictionary compression
    for file in "$PROFILE_DIR/training_*.txt" "$PROFILE_DIR/docs.txt" "$PROFILE_DIR/source_code.txt"; do
      "$ZSTD" -f -D "$PROFILE_DIR/dictionary" "\$file" -o /dev/null
    done

    # --- Single-threaded compression at different levels ---
    for level in 1 3 5 9 15 19; do
      for file in "$PROFILE_DIR/"*; do
        [[ "\$file" != *"/training_"* ]] && "$ZSTD" -f -\$level "\$file" -o /dev/null
      done
    done

    # --- Multi-threaded compression ---
    for thread in 2 4 8; do
      for file in "$PROFILE_DIR/"*; do
        [[ "\$file" != *"/training_"* ]] && "$ZSTD" -f -T\$thread -3 "\$file" -o /dev/null
      done
    done

    # --- Long range mode for larger files ---
    for file in "$PROFILE_DIR/"*.bin "$PROFILE_DIR/text1.txt"; do
      "$ZSTD" -f --long "\$file" -o /dev/null
    done

    # --- Streaming compression ---
    for file in "$PROFILE_DIR/"*; do
      [[ "\$file" != *"/training_"* ]] && cat "\$file" | "$ZSTD" -f > /dev/null
    done

    # --- Decompression workload (stderr redirected) ---
    for file in "$PROFILE_DIR/"*; do
      if [[ "\$file" != *"/training_"* ]] && [[ "\$file" != *".zst" ]]; then
        "$ZSTD" -f -3 "\$file" -o "\$file.zst"
        "$ZSTD" -f -d "\$file.zst" -o /dev/null 2>/dev/null
      fi
    done
  "

  # Convert perf data to BOLT format
  echo "== Converting perf data to BOLT format" # Changed msg2 to echo
  perf2bolt build/programs/zstd -p /tmp/perf.data -o build/programs/zstd.fdata

  # Optimize zstd with BOLT
  echo "== Optimizing zstd with BOLT" # Changed msg2 to echo
  llvm-bolt build/programs/zstd -o build/programs/zstd.bolt \
    --data build/programs/zstd.fdata \
    --dyno-stats --lite=false --cu-processing-batch-size=64 --eliminate-unreachable --frame-opt=all \
    --icf=all --jump-tables=aggressive --min-branch-clusters --stoke --sctc-mode=always \
    --plt=all --hot-data --hot-text --frame-opt-rm-stores --peepholes=all \
    --infer-stale-profile=1 --x86-strip-redundant-address-size --indirect-call-promotion=all \
    --reg-reassign --use-aggr-reg-reassign --reorder-blocks=ext-tsp --reorder-functions=cdsort \
    --split-all-cold --split-eh --split-functions --split-strategy=cdsplit

  # Replace original zstd with optimized version
  mv build/programs/zstd.bolt build/programs/zstd

  # Cleanup
  rm -rf "$PROFILE_DIR" /tmp/perf.data
}

#check() {
#  cd ${pkgname}-${pkgver}
#  export LD_LIBRARY_PATH="$(pwd)/build/lib"
#  ctest -VV --test-dir build
#}

package() {
  cd ${pkgname}-${pkgver}
  DESTDIR="${pkgdir}" cmake --install build

  # Use llvm-strip only on recognized file formats
  find "$pkgdir" -type f \( -name '*.so*' -o -name '*.a' -o -executable \) -print0 | while IFS= read -r -d '' file; do
    if llvm-strip --strip-unneeded "$file" 2>/dev/null || llvm-strip --strip-all "$file" 2>/dev/null; then
      echo "Stripped: $file"
    else
      echo "Skipping: $file (not a valid object file)" >&2
    fi
  done

  ln -sf /usr/bin/zstd "${pkgdir}/usr/bin/zstdmt"
  install -Dm 644 LICENSE -t "${pkgdir}/usr/share/licenses/${pkgname}"
}
