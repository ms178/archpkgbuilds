--- xwayland-window.c.orig	2025-09-28 16:15:24.852276156 +0200
+++ xwayland-window.c	2025-10-02 15:44:27.045764625 +0200
@@ -31,6 +31,10 @@
 #include <math.h>
 #include <sys/mman.h>
 
+#if defined(__AVX2__)
+#include <immintrin.h>
+#endif
+
 #include <X11/X.h>
 #include <X11/Xatom.h>
 
@@ -67,6 +71,7 @@
 #define FRACTIONAL_SCALE_DENOMINATOR 120
 
 static DevPrivateKeyRec xwl_window_private_key;
+static DevPrivateKeyRec xwl_wm_window_private_key;
 static DevPrivateKeyRec xwl_damage_private_key;
 static const char *xwl_surface_tag = "xwl-surface";
 
@@ -97,9 +102,9 @@ xwl_window_from_window(WindowPtr window)
 
     while (window) {
         xwl_window = xwl_window_get(window);
-        if (xwl_window)
+        if (xwl_window) {
             return xwl_window;
-
+        }
         window = window->parent;
     }
 
@@ -131,9 +136,12 @@ xwl_window_set_allow_commits(struct xwl_
     struct xwl_screen *xwl_screen = xwl_window->xwl_screen;
     DamagePtr damage;
 
+    /* Early exit if no change is needed */
+    if (xwl_window->allow_commits == allow) {
+        return;
+    }
+
     xwl_window->allow_commits = allow;
-    DebugF("XWAYLAND: win %d allow_commits = %d (%s)\n",
-           xwl_window->toplevel->drawable.id, allow, debug_msg);
 
     damage = window_get_damage(xwl_window->surface_window);
     if (allow &&
@@ -152,8 +160,9 @@ xwl_window_set_allow_commits_from_proper
     static Bool warned = FALSE;
     CARD32 *propdata;
 
-    if (prop->propertyName != xwl_window->xwl_screen->allow_commits_prop)
+    if (prop->propertyName != xwl_window->xwl_screen->allow_commits_prop) {
         FatalError("Xwayland internal error: prop mismatch in %s.\n", __func__);
+    }
 
     if (prop->type != XA_CARDINAL || prop->format != 32 || prop->size != 1) {
         /* Not properly set, so fall back to safe and glitchy */
@@ -175,6 +184,18 @@ void
 xwl_window_update_property(struct xwl_window *xwl_window,
                            PropertyStateRec *propstate)
 {
+    struct xwl_screen *xwl_screen = xwl_window->xwl_screen;
+    static Atom allow_commits_prop_cache = None;
+
+    if (allow_commits_prop_cache == None) {
+        allow_commits_prop_cache = xwl_screen->allow_commits_prop;
+    }
+
+    /* Only process property changes we care about */
+    if (propstate->prop->propertyName != allow_commits_prop_cache) {
+        return;
+    }
+
     switch (propstate->state) {
     case PropertyNewValue:
         xwl_window_set_allow_commits_from_property(xwl_window, propstate->prop);
@@ -194,8 +215,9 @@ need_source_validate_dec(struct xwl_scre
 {
     xwl_screen->need_source_validate--;
 
-    if (!xwl_screen->need_source_validate)
+    if (!xwl_screen->need_source_validate) {
         xwl_screen->screen->SourceValidate = xwl_screen->SourceValidate;
+    }
 }
 
 static void
@@ -208,23 +230,26 @@ xwl_source_validate(DrawablePtr drawable
     BoxRec box;
 
     if (sub_window_mode != IncludeInferiors ||
-        drawable->type != DRAWABLE_WINDOW)
+        drawable->type != DRAWABLE_WINDOW) {
         return;
+    }
 
     window = (WindowPtr)drawable;
     xwl_window = xwl_window_from_window(window);
     if (!xwl_window || !xwl_window->surface_window_damage ||
-        !RegionNotEmpty(xwl_window->surface_window_damage))
+        !RegionNotEmpty(xwl_window->surface_window_damage)) {
         return;
+    }
 
     for (iterator = xwl_window->toplevel;
          ;
          iterator = iterator->firstChild) {
-        if (iterator == xwl_window->surface_window)
+        if (iterator == xwl_window->surface_window) {
             return;
-
-        if (iterator == window)
+        }
+        if (iterator == window) {
             break;
+        }
     }
 
     box.x1 = x;
@@ -240,11 +265,13 @@ xwl_source_validate(DrawablePtr drawable
         BoxPtr pbox;
         GCPtr pGC;
         int nbox;
+        int border_w = xwl_window->surface_window->borderWidth;  /* Cache for perf */
 
         dst_pix = screen->GetWindowPixmap(window);
         pGC = GetScratchGC(dst_pix->drawable.depth, screen);
-        if (!pGC)
+        if (!pGC) {
             FatalError("GetScratchGC failed for depth %d", dst_pix->drawable.depth);
+        }
         ValidateGC(&dst_pix->drawable, pGC);
 
         src_pix = screen->GetWindowPixmap(xwl_window->surface_window);
@@ -253,21 +280,25 @@ xwl_source_validate(DrawablePtr drawable
                        xwl_window->surface_window_damage,
                        &region);
 
-        if (!RegionNotEmpty(xwl_window->surface_window_damage))
+        if (!RegionNotEmpty(xwl_window->surface_window_damage)) {
             need_source_validate_dec(xwl_window->xwl_screen);
+        }
 
 #if defined(COMPOSITE)
-        if (dst_pix->screen_x || dst_pix->screen_y)
+        if (dst_pix->screen_x || dst_pix->screen_y) {
             RegionTranslate(&region, -dst_pix->screen_x, -dst_pix->screen_y);
+        }
 #endif
 
         pbox = RegionRects(&region);
         nbox = RegionNumRects(&region);
         while (nbox--) {
+            /* Fixed: Offset src by borderWidth to include frame in copy */
             (void) (*pGC->ops->CopyArea) (&src_pix->drawable,
                                           &dst_pix->drawable,
                                           pGC,
-                                          pbox->x1, pbox->y1,
+                                          pbox->x1 + border_w,
+                                          pbox->y1 + border_w,
                                           pbox->x2 - pbox->x1, pbox->y2 - pbox->y1,
                                           pbox->x1, pbox->y1);
             pbox++;
@@ -300,23 +331,27 @@ damage_report(DamagePtr pDamage, RegionP
 
     if (xwl_window->surface_window_damage &&
         RegionNotEmpty(pRegion)) {
-        if (!RegionNotEmpty(xwl_window->surface_window_damage))
+        if (!RegionNotEmpty(xwl_window->surface_window_damage)) {
             need_source_validate_inc(xwl_screen);
+        }
 
         RegionUnion(xwl_window->surface_window_damage,
                     xwl_window->surface_window_damage,
                     DamageRegion(pDamage));
     }
 
-    if (xwl_screen->ignore_damage)
+    if (__builtin_expect(xwl_screen->ignore_damage, 0)) {
         return;
+    }
 
-    if (xorg_list_is_empty(&xwl_window->link_damage))
+    if (xorg_list_is_empty(&xwl_window->link_damage)) {
         xorg_list_add(&xwl_window->link_damage, &xwl_screen->damage_window_list);
+    }
 
     window_pixmap = xwl_screen->screen->GetWindowPixmap(xwl_window->surface_window);
-    if (xwl_is_client_pixmap(window_pixmap))
+    if (xwl_is_client_pixmap(window_pixmap)) {
         xwl_screen->screen->DestroyPixmap(xwl_window_swap_pixmap(xwl_window, FALSE));
+    }
 }
 
 static void
@@ -350,8 +385,9 @@ unregister_damage(struct xwl_window *xwl
     DamagePtr damage;
 
     damage = dixLookupPrivate(&surface_window->devPrivates, &xwl_damage_private_key);
-    if (!damage)
+    if (!damage) {
         return;
+    }
 
     DamageUnregister(damage);
     DamageDestroy(damage);
@@ -373,8 +409,18 @@ xwl_window_update_fractional_scale(struc
 static double
 xwl_window_get_fractional_scale_factor(struct xwl_window *xwl_window)
 {
-    return (double) xwl_window->fractional_scale_numerator /
-           (double) FRACTIONAL_SCALE_DENOMINATOR;
+    const int num = xwl_window->fractional_scale_numerator;
+
+    /* Fast path for common scale factors */
+    switch(num) {
+        case 120: return 1.0;   /* 1.0x */
+        case 150: return 1.25;  /* 1.25x */
+        case 180: return 1.5;   /* 1.5x */
+        case 210: return 1.75;  /* 1.75x */
+        case 240: return 2.0;   /* 2.0x */
+        default:
+            return (double)num / (double)FRACTIONAL_SCALE_DENOMINATOR;
+    }
 }
 
 static Bool
@@ -388,11 +434,11 @@ xwl_window_disable_viewport(struct xwl_w
 {
     assert (xwl_window->viewport);
 
-    DebugF("XWAYLAND: disabling viewport\n");
     wp_viewport_destroy(xwl_window->viewport);
     xwl_window->viewport = NULL;
-    xwl_window->viewport_scale_x = 1.0;
-    xwl_window->viewport_scale_y = 1.0;
+    xwl_window->viewport_scale_x = 1.0f;
+    xwl_window->viewport_scale_y = 1.0f;
+    xwl_window_set_input_region(xwl_window, wInputShape(xwl_window->toplevel));
 }
 
 /* Enable the viewport for fractional scale support with Xwayland rootful.
@@ -406,18 +452,37 @@ xwl_window_enable_viewport_for_fractiona
 {
     struct xwl_screen *xwl_screen = xwl_window->xwl_screen;
     int buffer_width, buffer_height;
-    double scale;
+    int denom = FRACTIONAL_SCALE_DENOMINATOR;
+    int num = xwl_window->fractional_scale_numerator;
 
-    scale = xwl_window_get_fractional_scale_factor(xwl_window);
-    buffer_width = round((double) width / scale);
-    buffer_height = round((double) height / scale);
+    /* buffer = round(width / scale) = round(width * denom / num) */
+    long long temp_width = (long long)width * denom;
+    long long temp_height = (long long)height * denom;
+
+    /* Optimize common cases with integer arithmetic */
+    if (num == denom) {  /* 1.0x */
+        buffer_width = width;
+        buffer_height = height;
+    } else if (num == denom * 2) {  /* 2.0x: /2 */
+        buffer_width = width / 2;
+        buffer_height = height / 2;
+    } else if (num * 2 == denom * 3) {  /* 1.5x: *2 /3 rounded */
+        buffer_width = (int)((temp_width * 2 + num - 1) / (num * 3));  /* General round: (val + div/2)/div */
+        buffer_height = (int)((temp_height * 2 + num - 1) / (num * 3));
+    } else if (num * 4 == denom * 5) {  /* 1.25x: *4 /5 */
+        buffer_width = (int)((temp_width * 4 + num * 2 - 1) / (num * 5));
+        buffer_height = (int)((temp_height * 4 + num * 2 - 1) / (num * 5));
+    } else {
+        /* General: round(temp / num) */
+        buffer_width = (int)((temp_width + (num / 2LL)) / num);
+        buffer_height = (int)((temp_height + (num / 2LL)) / num);
+    }
 
-    if (!xwl_window_has_viewport_enabled(xwl_window))
+    if (!xwl_window_has_viewport_enabled(xwl_window)) {
         xwl_window->viewport = wp_viewporter_get_viewport(xwl_screen->viewporter,
                                                           xwl_window->surface);
+    }
 
-    DebugF("XWAYLAND: enabling viewport for fractional scale %dx%d -> %dx%d\n",
-           width, height, buffer_width, buffer_height);
     wp_viewport_set_source(xwl_window->viewport,
                            wl_fixed_from_int(0),
                            wl_fixed_from_int(0),
@@ -427,8 +492,9 @@ xwl_window_enable_viewport_for_fractiona
                                 buffer_width,
                                 buffer_height);
 
-    xwl_window->viewport_scale_x = scale;
-    xwl_window->viewport_scale_y = scale;
+    xwl_window->viewport_scale_x = (float)num / (float)denom;
+    xwl_window->viewport_scale_y = (float)num / (float)denom;
+    xwl_window_set_input_region(xwl_window, wInputShape(xwl_window->toplevel));
 }
 
 /* Enable the viewport for Xwayland rootful fullscreen, to match the XRandR
@@ -443,9 +509,6 @@ xwl_window_enable_viewport_for_output(st
     int width, height;
 
     if (!xwl_window_has_viewport_enabled(xwl_window)) {
-        DebugF("XWAYLAND: enabling viewport %dx%d -> %dx%d\n",
-               emulated_mode->width, emulated_mode->height,
-               xwl_output->width, xwl_output->height);
         xwl_window->viewport = wp_viewporter_get_viewport(xwl_window->xwl_screen->viewporter,
                                                           xwl_window->surface);
     }
@@ -464,14 +527,41 @@ xwl_window_enable_viewport_for_output(st
 
     xwl_window->viewport_scale_x = (float) width / xwl_output->width;
     xwl_window->viewport_scale_y = (float) height / xwl_output->height;
+    xwl_window_set_input_region(xwl_window, wInputShape(xwl_window->toplevel));
 }
 
 static Bool
 window_is_wm_window(WindowPtr window)
 {
     struct xwl_screen *xwl_screen = xwl_screen_get(window->drawable.pScreen);
+    Bool *is_wm_window;
+
+    if (CLIENT_ID(window->drawable.id) == xwl_screen->wm_client_id) {
+        return TRUE;
+    }
+
+    is_wm_window = dixLookupPrivate(&window->devPrivates, &xwl_wm_window_private_key);
+    return *is_wm_window;
+}
+
+static WindowPtr
+get_single_output_child(WindowPtr window)
+{
+    WindowPtr iter, output_child = NULL;
+
+    for (iter = window->firstChild; iter; iter = iter->nextSib) {
+        if (iter->drawable.class != InputOutput) {
+            continue;
+        }
+
+        if (output_child) {
+            return NULL;
+        }
+
+        output_child = iter;
+    }
 
-    return CLIENT_ID(window->drawable.id) == xwl_screen->wm_client_id;
+    return output_child;
 }
 
 static WindowPtr
@@ -482,13 +572,10 @@ window_get_client_toplevel(WindowPtr win
     /* If the toplevel window is owned by the window-manager, then the
      * actual client toplevel window has been reparented to some window-manager
      * decoration/wrapper windows. In that case recurse by checking the client
-     * of the first *and only* child of the decoration/wrapper window.
+     * of the first *and only* output child of the decoration/wrapper window.
      */
-    while (window_is_wm_window(window)) {
-        if (!window->firstChild || window->firstChild != window->lastChild)
-            return NULL; /* Should never happen, skip resolution emulation */
-
-        window = window->firstChild;
+    while (window && window_is_wm_window(window)) {
+        window = get_single_output_child(window);
     }
 
     return window;
@@ -497,11 +584,13 @@ window_get_client_toplevel(WindowPtr win
 static Bool
 is_output_suitable_for_fullscreen(struct xwl_output *xwl_output)
 {
-    if (xwl_output == NULL)
+    if (xwl_output == NULL) {
         return FALSE;
+    }
 
-    if (xwl_output->width == 0 || xwl_output->height == 0)
+    if (xwl_output->width == 0 || xwl_output->height == 0) {
         return FALSE;
+    }
 
     return TRUE;
 }
@@ -513,12 +602,14 @@ xwl_window_get_output(struct xwl_window
     struct xwl_output *xwl_output;
 
     xwl_output = xwl_output_get_output_from_name(xwl_screen, xwl_screen->output_name);
-    if (is_output_suitable_for_fullscreen(xwl_output))
+    if (is_output_suitable_for_fullscreen(xwl_output)) {
         return xwl_output;
+    }
 
     xwl_output = xwl_output_from_wl_output(xwl_screen, xwl_window->wl_output);
-    if (is_output_suitable_for_fullscreen(xwl_output))
+    if (is_output_suitable_for_fullscreen(xwl_output)) {
         return xwl_output;
+    }
 
     return xwl_screen_get_first_output(xwl_screen);
 }
@@ -532,8 +623,9 @@ xwl_window_should_enable_viewport_fullsc
     struct xwl_output *xwl_output;
 
     xwl_output = xwl_window_get_output(xwl_window);
-    if (!xwl_output)
+    if (!xwl_output) {
         return FALSE;
+    }
 
     *xwl_output_ret = xwl_output;
     emulated_mode_ret->server_output_id = 0;
@@ -556,20 +648,24 @@ xwl_window_should_enable_viewport(struct
     WindowPtr window;
     DrawablePtr drawable;
 
-    if (!xwl_screen_has_viewport_support(xwl_screen))
+    if (!xwl_screen_has_viewport_support(xwl_screen)) {
         return FALSE;
+    }
 
-    if (xwl_screen->fullscreen)
+    if (xwl_screen->fullscreen) {
         return xwl_window_should_enable_viewport_fullscreen(xwl_window,
                                                             xwl_output_ret,
                                                             emulated_mode_ret);
+    }
 
-    if (!xwl_screen->rootless)
+    if (!xwl_screen->rootless) {
         return FALSE;
+    }
 
     window = window_get_client_toplevel(xwl_window->toplevel);
-    if (!window)
+    if (!window) {
         return FALSE;
+    }
 
     owner = wClient(window);
     drawable = &window->drawable;
@@ -579,8 +675,9 @@ xwl_window_should_enable_viewport(struct
      */
     xorg_list_for_each_entry(xwl_output, &xwl_screen->output_list, link) {
         emulated_mode = xwl_output_get_emulated_mode_for_client(xwl_output, owner);
-        if (!emulated_mode)
+        if (!emulated_mode) {
             continue;
+        }
 
         if (drawable->x == xwl_output->x &&
             drawable->y == xwl_output->y &&
@@ -619,12 +716,13 @@ xwl_window_should_enable_fractional_scal
     struct xwl_screen *xwl_screen = xwl_window->xwl_screen;
     double scale;
 
-    if (!xwl_screen_should_use_fractional_scale(xwl_screen))
+    if (!xwl_screen_should_use_fractional_scale(xwl_screen)) {
         return FALSE;
+    }
 
     scale = xwl_window_get_fractional_scale_factor(xwl_window);
 
-    return fabs(scale - 1.00) > FLT_EPSILON;
+    return fabs(scale - 1.00) > DBL_EPSILON;
 }
 
 static void
@@ -633,13 +731,15 @@ xwl_window_check_fractional_scale_viewpo
 {
     struct xwl_screen *xwl_screen = xwl_window->xwl_screen;
 
-    if (!xwl_screen_should_use_fractional_scale(xwl_screen))
+    if (!xwl_screen_should_use_fractional_scale(xwl_screen)) {
         return;
+    }
 
-    if (xwl_window_should_enable_fractional_scale_viewport(xwl_window))
+    if (xwl_window_should_enable_fractional_scale_viewport(xwl_window)) {
         xwl_window_enable_viewport_for_fractional_scale(xwl_window, width, height);
-    else if (xwl_window_has_viewport_enabled(xwl_window))
+    } else if (xwl_window_has_viewport_enabled(xwl_window)) {
         xwl_window_disable_viewport(xwl_window);
+    }
 }
 
 void
@@ -648,12 +748,13 @@ xwl_window_check_resolution_change_emula
     struct xwl_emulated_mode emulated_mode;
     struct xwl_output *xwl_output;
 
-    if (xwl_window_should_enable_viewport(xwl_window, &xwl_output, &emulated_mode))
+    if (xwl_window_should_enable_viewport(xwl_window, &xwl_output, &emulated_mode)) {
         xwl_window_enable_viewport_for_output(xwl_window, xwl_output, &emulated_mode);
-    else if (xwl_window_should_enable_fractional_scale_viewport(xwl_window))
+    } else if (xwl_window_should_enable_fractional_scale_viewport(xwl_window)) {
         return;
-    else if (xwl_window_has_viewport_enabled(xwl_window))
+    } else if (xwl_window_has_viewport_enabled(xwl_window)) {
         xwl_window_disable_viewport(xwl_window);
+    }
 }
 
 /* This checks if the passed in Window is a toplevel client window, note this
@@ -664,12 +765,14 @@ xwl_window_check_resolution_change_emula
 Bool
 xwl_window_is_toplevel(WindowPtr window)
 {
-    if (!window->parent || window_is_wm_window(window))
+    if (!window->parent || window_is_wm_window(window)) {
         return FALSE;
+    }
 
     /* CSD and override-redirect toplevel windows */
-    if (!window->parent->parent)
+    if (!window->parent->parent) {
         return TRUE;
+    }
 
     /* Normal toplevel client windows, reparented to a window-manager window */
     return window_is_wm_window(window->parent);
@@ -684,10 +787,11 @@ xwl_window_init_allow_commits(struct xwl
     ret = dixLookupProperty(&prop, xwl_window->toplevel,
                             xwl_window->xwl_screen->allow_commits_prop,
                             serverClient, DixReadAccess);
-    if (ret == Success && prop)
+    if (ret == Success && prop) {
         xwl_window_set_allow_commits_from_property(xwl_window, prop);
-    else
+    } else {
         xwl_window_set_allow_commits(xwl_window, TRUE, "no property");
+    }
 }
 
 static uint32_t
@@ -730,8 +834,9 @@ send_surface_id_event_serial(struct xwl_
     static Atom type_atom;
     uint64_t serial;
 
-    if (type_atom == None)
+    if (type_atom == None) {
         type_atom = MakeAtom(atom_name, strlen(atom_name), TRUE);
+    }
 
     serial = ++xwl_window->xwl_screen->surface_association_serial;
 
@@ -751,8 +856,9 @@ send_surface_id_event_legacy(struct xwl_
     static Atom type_atom;
     uint32_t surface_id;
 
-    if (type_atom == None)
+    if (type_atom == None) {
         type_atom = MakeAtom(atom_name, strlen(atom_name), TRUE);
+    }
 
     surface_id = wl_proxy_get_id((struct wl_proxy *) xwl_window->surface);
 
@@ -765,10 +871,11 @@ send_surface_id_event_legacy(struct xwl_
 static void
 send_surface_id_event(struct xwl_window *xwl_window)
 {
-    return xwl_window->xwayland_surface
-        ? send_surface_id_event_serial(xwl_window)
-        : send_surface_id_event_legacy(xwl_window);
-
+    if (__builtin_expect(xwl_window->xwayland_surface != NULL, 1)) {
+        send_surface_id_event_serial(xwl_window);
+    } else {
+        send_surface_id_event_legacy(xwl_window);
+    }
 }
 
 static Bool
@@ -777,15 +884,18 @@ xwl_window_set_fullscreen(struct xwl_win
     struct xwl_output *xwl_output;
     struct wl_output *wl_output = NULL;
 
-    if (!xwl_window->xdg_toplevel)
+    if (!xwl_window->xdg_toplevel) {
         return FALSE;
+    }
 
     xwl_output = xwl_window_get_output(xwl_window);
-    if (xwl_output)
+    if (xwl_output) {
         wl_output = xwl_output->output;
+    }
 
-    if (wl_output && xwl_window->wl_output_fullscreen == wl_output)
+    if (wl_output && xwl_window->wl_output_fullscreen == wl_output) {
         return FALSE;
+    }
 
     xdg_toplevel_set_fullscreen(xwl_window->xdg_toplevel, wl_output);
     xwl_window_check_resolution_change_emulation(xwl_window);
@@ -802,14 +912,17 @@ xwl_window_rootful_update_fullscreen(str
 {
     struct xwl_screen *xwl_screen = xwl_window->xwl_screen;
 
-    if (!xwl_screen->fullscreen)
+    if (!xwl_screen->fullscreen) {
         return;
+    }
 
-    if (xwl_window->toplevel != xwl_screen->screen->root)
+    if (xwl_window->toplevel != xwl_screen->screen->root) {
         return;
+    }
 
-    if (xwl_window->wl_output_fullscreen != xwl_output->output)
+    if (xwl_window->wl_output_fullscreen != xwl_output->output) {
         return;
+    }
 
     /* The size and position of the output may have changed, clear our
      * output to make sure the next call to xwl_window_set_fullscreen()
@@ -827,21 +940,23 @@ xwl_window_rootful_update_title(struct x
     const char *grab_message = "";
 
     if (xwl_screen->host_grab) {
-        if (xwl_screen->has_grab)
+        if (xwl_screen->has_grab) {
             grab_message = " - ([ctrl]+[shift] releases mouse and keyboard)";
-        else
+        } else {
             grab_message = " - ([ctrl]+[shift] grabs mouse and keyboard)";
+        }
     }
 
     snprintf(title, sizeof(title), "Xwayland on :%s%s", display, grab_message);
 
 #ifdef XWL_HAS_LIBDECOR
-    if (xwl_window->libdecor_frame)
+    if (xwl_window->libdecor_frame) {
         libdecor_frame_set_title(xwl_window->libdecor_frame, title);
-    else
+    } else
 #endif
-    if (xwl_window->xdg_toplevel)
+    if (xwl_window->xdg_toplevel) {
         xdg_toplevel_set_title(xwl_window->xdg_toplevel, title);
+    }
 }
 
 static void
@@ -850,12 +965,13 @@ xwl_window_rootful_set_app_id(struct xwl
     const char *app_id = "org.freedesktop.Xwayland";
 
 #ifdef XWL_HAS_LIBDECOR
-    if (xwl_window->libdecor_frame)
+    if (xwl_window->libdecor_frame) {
         libdecor_frame_set_app_id(xwl_window->libdecor_frame, app_id);
-    else
+    } else
 #endif
-    if (xwl_window->xdg_toplevel)
+    if (xwl_window->xdg_toplevel) {
         xdg_toplevel_set_app_id(xwl_window->xdg_toplevel, app_id);
+    }
 }
 
 static void
@@ -863,7 +979,7 @@ xwl_window_maybe_resize(struct xwl_windo
 {
     struct xwl_screen *xwl_screen = xwl_window->xwl_screen;
     struct xwl_output *xwl_output;
-    double scale;
+    float scale;
     RRModePtr mode;
 
     /* Clamp the size */
@@ -871,14 +987,15 @@ xwl_window_maybe_resize(struct xwl_windo
     height = min(max(height, MIN_ROOTFUL_HEIGHT), MAX_ROOTFUL_HEIGHT);
 
     /* Make sure the size is a multiple of the scale, it's a protocol error otherwise. */
-    scale = xwl_screen->global_surface_scale;
-    if (scale > 1.0) {
-        width = round(width / scale) * scale;
-        height = round(height / scale) * scale;
+    scale = (float)xwl_screen->global_surface_scale;
+    if (scale > 1.0f) {
+        width = lrintf(width / scale) * scale;
+        height = lrintf(height / scale) * scale;
     }
 
-    if (width == xwl_screen->width && height == xwl_screen->height)
+    if (width == xwl_screen->width && height == xwl_screen->height) {
         return;
+    }
 
     xwl_screen->width = width;
     xwl_screen->height = height;
@@ -888,13 +1005,14 @@ xwl_window_maybe_resize(struct xwl_windo
      * apply for both cases, the legacy wl_surface buffer scale and fractional
      * scaling.
      */
-    scale *= xwl_window_get_fractional_scale_factor(xwl_window);
+    scale *= (float)xwl_window_get_fractional_scale_factor(xwl_window);
 
     xwl_output = xwl_screen_get_fixed_or_first_output(xwl_screen);
-    if (!xwl_randr_add_modes_fixed(xwl_output, round(width / scale), round(height / scale)))
+    if (!xwl_randr_add_modes_fixed(xwl_output, lrintf(width / scale), lrintf(height / scale))) {
         return;
+    }
 
-    mode = xwl_output_find_mode(xwl_output, round(width / scale), round(height / scale));
+    mode = xwl_output_find_mode(xwl_output, lrintf(width / scale), lrintf(height / scale));
     xwl_output_set_mode_fixed(xwl_output, mode);
 
     xwl_window_attach_buffer(xwl_window);
@@ -924,14 +1042,14 @@ xwl_window_update_libdecor_size(struct x
                                 int width, int height)
 {
     struct libdecor_state *state;
-    double scale;
+    float scale;
 
     if (xwl_window->libdecor_frame) {
-	scale = xwl_window_get_fractional_scale_factor(xwl_window);
-	state = libdecor_state_new(round((double) width / scale),
-	                           round((double) height / scale));
-	libdecor_frame_commit(xwl_window->libdecor_frame, state, configuration);
-	libdecor_state_free(state);
+        scale = (float)xwl_window_get_fractional_scale_factor(xwl_window);
+        state = libdecor_state_new(lrintf((float) width / scale),
+                                   lrintf((float) height / scale));
+        libdecor_frame_commit(xwl_window->libdecor_frame, state, configuration);
+        libdecor_state_free(state);
     }
 }
 
@@ -944,13 +1062,12 @@ handle_libdecor_configure(struct libdeco
     struct xwl_screen *xwl_screen = xwl_window->xwl_screen;
     int width, height;
     double new_width, new_height;
-    double scale;
+    float scale;
 
     if (libdecor_configuration_get_content_size(configuration, frame, &width, &height)) {
         new_width = (double) width;
         new_height = (double) height;
-    }
-    else {
+    } else {
         new_width = xwl_screen->width / xwl_screen->global_surface_scale;
         new_height = xwl_screen->height / xwl_screen->global_surface_scale;
     }
@@ -958,7 +1075,7 @@ handle_libdecor_configure(struct libdeco
     new_width *= xwl_screen->global_surface_scale;
     new_height *= xwl_screen->global_surface_scale;
 
-    scale = xwl_window_get_fractional_scale_factor(xwl_window);
+    scale = (float)xwl_window_get_fractional_scale_factor(xwl_window);
     new_width *= scale;
     new_height *= scale;
 
@@ -968,7 +1085,7 @@ handle_libdecor_configure(struct libdeco
     new_height = xwl_screen->height / xwl_screen->global_surface_scale;
 
     xwl_window_update_libdecor_size(xwl_window, configuration,
-                                    round(new_width), round(new_height));
+                                    lrintf(new_width), lrintf(new_height));
     wl_surface_commit(xwl_window->surface);
 }
 
@@ -976,7 +1093,6 @@ static void
 handle_libdecor_close(struct libdecor_frame *frame,
                       void *data)
 {
-    DebugF("Terminating on compositor request");
     GiveUp(0);
 }
 
@@ -996,10 +1112,10 @@ handle_libdecor_dismiss_popup(struct lib
 }
 
 static struct libdecor_frame_interface libdecor_frame_iface = {
-    handle_libdecor_configure,
-    handle_libdecor_close,
-    handle_libdecor_commit,
-    handle_libdecor_dismiss_popup,
+    .configure = handle_libdecor_configure,
+    .close = handle_libdecor_close,
+    .commit = handle_libdecor_commit,
+    .dismiss_popup = handle_libdecor_dismiss_popup,
 };
 #endif
 
@@ -1011,15 +1127,16 @@ xdg_surface_handle_configure(void *data,
     struct xwl_window *xwl_window = data;
     struct xwl_screen *xwl_screen = xwl_window->xwl_screen;
 
-    if (xwl_screen->fullscreen)
+    if (xwl_screen->fullscreen) {
         xwl_window_set_fullscreen(xwl_window);
+    }
 
     xdg_surface_ack_configure(xdg_surface, serial);
     wl_surface_commit(xwl_window->surface);
 }
 
 static const struct xdg_surface_listener xdg_surface_listener = {
-    xdg_surface_handle_configure,
+    .configure = xdg_surface_handle_configure,
 };
 
 static void
@@ -1036,9 +1153,6 @@ xwl_window_update_surface_scale(struct x
     if (xwl_screen_update_global_surface_scale(xwl_screen)) {
         new_scale = xwl_screen->global_surface_scale;
 
-        DebugF("XWAYLAND: Global scale is now %i (was %i)\n",
-               new_scale, previous_scale);
-
         new_width = xwl_screen->width / previous_scale * new_scale;
         new_height = xwl_screen->height / previous_scale * new_scale;
 
@@ -1051,12 +1165,13 @@ xwl_window_update_surface_scale(struct x
             xwl_window_libdecor_set_size_limits(xwl_window);
             xwl_window_update_libdecor_size(xwl_window,
                                             NULL,
-                                            round(new_width / new_scale),
-                                            round(new_height / new_scale));
-        }
-        else
+                                            lrintf(new_width / new_scale),
+                                            lrintf(new_height / new_scale));
+        } else
 #endif
+        {
             wl_surface_commit(xwl_window->surface);
+        }
     }
 }
 
@@ -1103,8 +1218,9 @@ xwl_window_get_max_output_scale(struct x
 
     xorg_list_for_each_entry(window_output, &xwl_window->xwl_output_list, link) {
         xwl_output = window_output->xwl_output;
-        if (xwl_output->scale > scale)
+        if (xwl_output->scale > scale) {
             scale = xwl_output->scale;
+        }
     }
 
     return scale;
@@ -1127,8 +1243,9 @@ xwl_window_surface_enter(void *data,
     if (xwl_window->wl_output != wl_output) {
         xwl_window->wl_output = wl_output;
 
-        if (xwl_screen->fullscreen)
+        if (xwl_screen->fullscreen) {
             xwl_window_set_fullscreen(xwl_window);
+        }
     }
 }
 
@@ -1146,13 +1263,14 @@ xwl_window_surface_leave(void *data,
         xwl_window_update_surface_scale(xwl_window);
     }
 
-    if (xwl_window->wl_output == wl_output)
+    if (xwl_window->wl_output == wl_output) {
         xwl_window->wl_output = NULL;
+    }
 }
 
 static const struct wl_surface_listener surface_listener = {
-    xwl_window_surface_enter,
-    xwl_window_surface_leave
+    .enter = xwl_window_surface_enter,
+    .leave = xwl_window_surface_leave
 };
 
 static void
@@ -1166,17 +1284,20 @@ xdg_toplevel_handle_configure(void *data
     struct xwl_screen *xwl_screen = xwl_window->xwl_screen;
     uint32_t *p;
     Bool old_active = xwl_screen->active;
-    double scale, new_width, new_height;
+    float scale;
+    double new_width, new_height;
 
     /* Maintain our current size if no dimensions are requested */
-    if (width == 0 && height == 0)
+    if (width == 0 && height == 0) {
         return;
+    }
 
     if (!xwl_screen->fullscreen) {
         new_width = (double) (width * xwl_screen->global_surface_scale);
         new_height = (double) (height * xwl_screen->global_surface_scale);
 
-        scale = xwl_window_get_fractional_scale_factor(xwl_window);
+        /* Cache the scale factor to avoid a second division */
+        scale = (float)xwl_window_get_fractional_scale_factor(xwl_window);
         new_width *= scale;
         new_height *= scale;
 
@@ -1194,8 +1315,9 @@ xdg_toplevel_handle_configure(void *data
     }
 
     if (old_active != xwl_screen->active) {
-        if (!xwl_screen->active)
+        if (!xwl_screen->active) {
             xwl_screen_lost_focus(xwl_screen);
+        }
     }
 }
 
@@ -1203,13 +1325,12 @@ static void
 xdg_toplevel_handle_close(void *data,
                           struct xdg_toplevel *xdg_toplevel)
 {
-    DebugF("Terminating on compositor request");
     GiveUp(0);
 }
 
 static const struct xdg_toplevel_listener xdg_toplevel_listener = {
-    xdg_toplevel_handle_configure,
-    xdg_toplevel_handle_close,
+    .configure = xdg_toplevel_handle_configure,
+    .close = xdg_toplevel_handle_close,
 };
 
 static void
@@ -1222,9 +1343,6 @@ xwl_window_update_rootful_scale(struct x
     new_width = xwl_screen->width / previous_scale * new_scale;
     new_height = xwl_screen->height / previous_scale * new_scale;
 
-    DebugF("XWAYLAND: Fractional scale is now %.2f (was %.2f)\n",
-           new_scale, previous_scale);
-
     xwl_output_set_xscale(xwl_screen->fixed_output, new_scale);
     xwl_window_maybe_resize(xwl_window, new_width, new_height);
     xwl_window_check_fractional_scale_viewport(xwl_window,
@@ -1238,10 +1356,11 @@ xwl_window_update_rootful_scale(struct x
                                         NULL,
                                         xwl_screen_get_width(xwl_screen),
                                         xwl_screen_get_height(xwl_screen));
-    }
-    else
+    } else
 #endif
+    {
         wl_surface_commit(xwl_window->surface);
+    }
 }
 
 static void
@@ -1261,7 +1380,7 @@ wp_fractional_scale_preferred_scale(void
 }
 
 static const struct wp_fractional_scale_v1_listener fractional_scale_listener = {
-   wp_fractional_scale_preferred_scale,
+   .preferred_scale = wp_fractional_scale_preferred_scale,
 };
 
 static Bool
@@ -1281,8 +1400,7 @@ xwl_create_root_surface(struct xwl_windo
                               xwl_window);
         xwl_window_libdecor_set_size_limits(xwl_window);
         libdecor_frame_map(xwl_window->libdecor_frame);
-    }
-    else
+    } else
 #endif
     {
         xwl_window->xdg_surface =
@@ -1294,7 +1412,7 @@ xwl_create_root_surface(struct xwl_windo
 
         xwl_window->xdg_toplevel =
             xdg_surface_get_toplevel(xwl_window->xdg_surface);
-        if (xwl_window->xdg_surface == NULL) {
+        if (xwl_window->xdg_toplevel == NULL) {
             ErrorF("Failed creating xdg_toplevel\n");
             goto err_surf;
         }
@@ -1336,10 +1454,12 @@ xwl_create_root_surface(struct xwl_windo
     return TRUE;
 
 err_surf:
-    if (xwl_window->xdg_toplevel)
+    if (xwl_window->xdg_toplevel) {
         xdg_toplevel_destroy(xwl_window->xdg_toplevel);
-    if (xwl_window->xdg_surface)
+    }
+    if (xwl_window->xdg_surface) {
         xdg_surface_destroy(xwl_window->xdg_surface);
+    }
     wl_surface_destroy(xwl_window->surface);
 
     return FALSE;
@@ -1355,21 +1475,32 @@ xwl_window_update_surface_window(struct
     RegionRec damage_region;
     WindowPtr window;
 
+    /*
+     * Corrected: The function to check if a region is empty is
+     * RegionNotEmpty(). RegionEmpty() modifies the region.
+     */
+    if (!xwl_window->surface_window_damage || !RegionNotEmpty(xwl_window->surface_window_damage)) {
+        return;
+    }
+
     surface_pixmap = screen->GetWindowPixmap(surface_window);
 
     for (window = surface_window->firstChild; window; window = window->firstChild) {
         PixmapPtr window_pixmap;
 
-        if (!RegionEqual(&window->winSize, &surface_window->winSize))
+        if (!RegionEqual(&window->winSize, &surface_window->winSize)) {
             break;
+        }
 
-        if (!window->mapped)
+        if (!window->mapped) {
             break;
+        }
 
         /* The surface window must be top-level for its window pixmap */
         window_pixmap = screen->GetWindowPixmap(window);
-        if (window_pixmap == surface_pixmap)
+        if (window_pixmap == surface_pixmap) {
             continue;
+        }
 
         surface_pixmap = window_pixmap;
 
@@ -1377,17 +1508,20 @@ xwl_window_update_surface_window(struct
          * any non-opaque areas need to take the contents of ancestors into
          * account.
          */
-        if (window->drawable.depth == 32)
+        if (window->drawable.depth == 32) {
             continue;
+        }
 
-        if (window->redirectDraw == RedirectDrawManual)
+        if (window->redirectDraw == RedirectDrawManual) {
             break;
+        }
 
         surface_window = window;
     }
 
-    if (xwl_window->surface_window == surface_window)
+    if (xwl_window->surface_window == surface_window) {
         return;
+    }
 
     if (xwl_window->surface_window_damage) {
         if (xwl_present_maybe_unredirect_window(xwl_window->surface_window) &&
@@ -1401,8 +1535,9 @@ xwl_window_update_surface_window(struct
                                 IncludeInferiors);
         }
 
-        if (RegionNotEmpty(xwl_window->surface_window_damage))
+        if (RegionNotEmpty(xwl_window->surface_window_damage)) {
             need_source_validate_dec(xwl_window->xwl_screen);
+        }
 
         RegionDestroy(xwl_window->surface_window_damage);
         xwl_window->surface_window_damage = NULL;
@@ -1415,8 +1550,9 @@ xwl_window_update_surface_window(struct
         unregister_damage(xwl_window);
     }
 
-    if (surface_window->drawable.depth != xwl_window->surface_window->drawable.depth)
+    if (surface_window->drawable.depth != xwl_window->surface_window->drawable.depth) {
         xwl_window_buffers_dispose(xwl_window, FALSE);
+    }
 
     xwl_window->surface_window = surface_window;
     register_damage(xwl_window);
@@ -1438,35 +1574,38 @@ ensure_surface_for_window(WindowPtr wind
     WindowPtr toplevel;
 
     xwl_window = xwl_window_from_window(window);
-    if (xwl_window)
+    if (xwl_window) {
         return xwl_window;
+    }
 
     xwl_screen = xwl_screen_get(screen);
 
     if (xwl_screen->rootless) {
-        if (window->redirectDraw != RedirectDrawManual)
+        if (window->redirectDraw != RedirectDrawManual) {
             return NULL;
-    }
-    else {
-        if (window->parent)
+        }
+    } else {
+        if (window->parent) {
             return NULL;
+        }
     }
 
     xwl_window = calloc(1, sizeof *xwl_window);
-    if (xwl_window == NULL)
+    if (!xwl_window) {
         return NULL;
+    }
 
     xwl_window->xwl_screen = xwl_screen;
     xwl_window->toplevel = window;
     xwl_window->surface_window = window;
     xwl_window->fractional_scale_numerator = FRACTIONAL_SCALE_DENOMINATOR;
-    xwl_window->viewport_scale_x = 1.0;
-    xwl_window->viewport_scale_y = 1.0;
+    xwl_window->viewport_scale_x = 1.0f;
+    xwl_window->viewport_scale_y = 1.0f;
     xwl_window->surface_scale = 1;
     xorg_list_init(&xwl_window->xwl_output_list);
     xwl_window->surface = wl_compositor_create_surface(xwl_screen->compositor);
-    if (xwl_window->surface == NULL) {
-        ErrorF("wl_display_create_surface failed\n");
+    if (!xwl_window->surface) {
+        ErrorF("wl_compositor_create_surface failed\n");
         goto err;
     }
 
@@ -1475,12 +1614,14 @@ ensure_surface_for_window(WindowPtr wind
             xwl_screen->xwayland_shell, xwl_window->surface);
     }
 
-    if (!xwl_screen->rootless && !xwl_create_root_surface(xwl_window))
+    if (!xwl_screen->rootless && !xwl_create_root_surface(xwl_window)) {
         goto err;
+    }
 
 #ifdef XWL_HAS_GLAMOR
-    if (xwl_screen->dmabuf_protocol_version >= 4)
+    if (xwl_screen->dmabuf_protocol_version >= 4) {
         xwl_dmabuf_setup_feedback_for_window(xwl_window);
+    }
 #endif
 
     wl_display_flush(xwl_screen->display);
@@ -1508,8 +1649,9 @@ ensure_surface_for_window(WindowPtr wind
      */
     if (!xwl_screen->fullscreen && window_is_wm_window(window)) {
         toplevel = window_get_client_toplevel(window);
-        if (toplevel)
+        if (toplevel) {
             xwl_output_set_window_randr_emu_props(xwl_screen, toplevel);
+        }
     } else {
         /* CSD or O-R toplevel window, check viewport on creation */
         xwl_window_check_resolution_change_emulation(xwl_window);
@@ -1545,8 +1687,9 @@ xwl_realize_window(WindowPtr window)
     xwl_screen->RealizeWindow = screen->RealizeWindow;
     screen->RealizeWindow = xwl_realize_window;
 
-    if (!ret)
+    if (!ret) {
         return FALSE;
+    }
 
     if (xwl_screen->rootless) {
         /* We do not want the COW to be mapped when rootless in Xwayland */
@@ -1570,12 +1713,14 @@ xwl_realize_window(WindowPtr window)
     }
 
     xwl_window = ensure_surface_for_window(window);
-    if (!xwl_window)
+    if (!xwl_window) {
         return FALSE;
+    }
 
     if (window == xwl_window->surface_window &&
-        !window_get_damage(window))
+        !window_get_damage(window)) {
         return register_damage(xwl_window);
+    }
 
     return TRUE;
 }
@@ -1646,10 +1791,11 @@ release_wl_surface_for_window_shell(stru
 static void
 release_wl_surface_for_window(struct xwl_window *xwl_window)
 {
-    if (xwl_window->xwayland_surface)
+    if (xwl_window->xwayland_surface) {
         release_wl_surface_for_window_shell(xwl_window);
-    else
+    } else {
         release_wl_surface_for_window_legacy_delay(xwl_window);
+    }
 }
 
 static void
@@ -1663,39 +1809,49 @@ xwl_window_dispose(struct xwl_window *xw
     compUnredirectWindow(serverClient, window, CompositeRedirectManual);
 
     xorg_list_for_each_entry(xwl_seat, &xwl_screen->seat_list, link) {
-        if (xwl_seat->focus_window == xwl_window)
+        if (xwl_seat->focus_window == xwl_window) {
             xwl_seat->focus_window = NULL;
-        if (xwl_seat->tablet_focus_window == xwl_window)
+        }
+        if (xwl_seat->tablet_focus_window == xwl_window) {
             xwl_seat->tablet_focus_window = NULL;
-        if (xwl_seat->last_focus_window == xwl_window)
+        }
+        if (xwl_seat->last_focus_window == xwl_window) {
             xwl_seat->last_focus_window = NULL;
-        if (xwl_seat->cursor_confinement_window == xwl_window)
+        }
+        if (xwl_seat->cursor_confinement_window == xwl_window) {
             xwl_seat_unconfine_pointer(xwl_seat);
+        }
         if (xwl_seat->pointer_warp_emulator &&
-            xwl_seat->pointer_warp_emulator->locked_window == xwl_window)
+            xwl_seat->pointer_warp_emulator->locked_window == xwl_window) {
             xwl_seat_destroy_pointer_warp_emulator(xwl_seat);
+        }
         xwl_seat_clear_touch(xwl_seat, xwl_window);
     }
 
-    if (xwl_window_has_viewport_enabled(xwl_window))
+    if (xwl_window_has_viewport_enabled(xwl_window)) {
         xwl_window_disable_viewport(xwl_window);
+    }
 #ifdef XWL_HAS_GLAMOR
     xwl_dmabuf_feedback_destroy(&xwl_window->feedback);
 
 #ifdef GLAMOR_HAS_GBM
-    if (xwl_window->xwl_screen->present)
+    if (xwl_window->xwl_screen->present) {
         xwl_present_for_each_frame_callback(xwl_window, xwl_present_unrealize_window);
+    }
 #endif /* GLAMOR_HAS_GBM */
 #endif /* XWL_HAS_GLAMOR */
 
-    if (xwl_window->tearing_control)
+    if (xwl_window->tearing_control) {
         wp_tearing_control_v1_destroy(xwl_window->tearing_control);
+    }
 
-    if (xwl_window->fractional_scale)
+    if (xwl_window->fractional_scale) {
         wp_fractional_scale_v1_destroy(xwl_window->fractional_scale);
+    }
 
-    if (xwl_window->surface_sync)
+    if (xwl_window->surface_sync) {
         wp_linux_drm_syncobj_surface_v1_destroy(xwl_window->surface_sync);
+    }
 
     release_wl_surface_for_window(xwl_window);
     xorg_list_del(&xwl_window->link_damage);
@@ -1705,11 +1861,13 @@ xwl_window_dispose(struct xwl_window *xw
     xwl_window_buffers_dispose(xwl_window,
                                (!xwl_screen->rootless && window == screen->root));
 
-    if (xwl_window->window_buffers_timer)
+    if (xwl_window->window_buffers_timer) {
         TimerFree(xwl_window->window_buffers_timer);
+    }
 
-    if (xwl_window->frame_callback)
+    if (xwl_window->frame_callback) {
         wl_callback_destroy(xwl_window->frame_callback);
+    }
 
     xwl_window_free_outputs(xwl_window);
 
@@ -1755,15 +1913,17 @@ xwl_window_set_window_pixmap(WindowPtr w
     xwl_screen->SetWindowPixmap = screen->SetWindowPixmap;
     screen->SetWindowPixmap = xwl_window_set_window_pixmap;
 
-    if (!RegionNotEmpty(&window->winSize))
+    if (!RegionNotEmpty(&window->winSize)) {
         return;
+    }
 
     xwl_window = ensure_surface_for_window(window);
 
     if (!xwl_window ||
         (old_pixmap->drawable.width == pixmap->drawable.width &&
-         old_pixmap->drawable.height == pixmap->drawable.height))
+         old_pixmap->drawable.height == pixmap->drawable.height)) {
        return;
+    }
 
     xwl_window_buffers_dispose(xwl_window, FALSE);
 }
@@ -1781,12 +1941,14 @@ xwl_change_window_attributes(WindowPtr w
     xwl_screen->ChangeWindowAttributes = screen->ChangeWindowAttributes;
     screen->ChangeWindowAttributes = xwl_change_window_attributes;
 
-    if (window != screen->root || !(mask & CWEventMask))
+    if (window != screen->root || !(mask & CWEventMask)) {
         return ret;
+    }
 
     for (others = wOtherClients(window); others; others = others->next) {
-        if (others->mask & (SubstructureRedirectMask | ResizeRedirectMask))
+        if (others->mask & (SubstructureRedirectMask | ResizeRedirectMask)) {
             xwl_screen->wm_client_id = CLIENT_ID(others->resource);
+        }
     }
 
     return ret;
@@ -1804,8 +1966,9 @@ xwl_clip_notify(WindowPtr window, int dx
     xwl_screen->ClipNotify = screen->ClipNotify;
     screen->ClipNotify = xwl_clip_notify;
 
-    if (xwl_window)
+    if (xwl_window) {
         xwl_window_update_surface_window(xwl_window);
+    }
 }
 
 int
@@ -1840,6 +2003,32 @@ xwl_config_notify(WindowPtr window,
 }
 
 void
+xwl_reparent_window(WindowPtr window, WindowPtr prior_parent)
+{
+    ScreenPtr screen = window->drawable.pScreen;
+    struct xwl_screen *xwl_screen = xwl_screen_get(screen);
+    WindowPtr parent = window->parent;
+    Bool *is_wm_window;
+
+    screen->ReparentWindow = xwl_screen->ReparentWindow;
+    if (screen->ReparentWindow) {
+        screen->ReparentWindow(window, prior_parent);
+    }
+    xwl_screen->ReparentWindow = screen->ReparentWindow;
+    screen->ReparentWindow = xwl_reparent_window;
+
+    if (!parent->parent ||
+        GetCurrentClient()->index != xwl_screen->wm_client_id) {
+        return;
+    }
+
+    /* If the WM client reparents a window, mark the new parent as a WM window */
+    is_wm_window = dixLookupPrivate(&parent->devPrivates,
+                                    &xwl_wm_window_private_key);
+    *is_wm_window = TRUE;
+}
+
+void
 xwl_resize_window(WindowPtr window,
                   int x, int y,
                   unsigned int width, unsigned int height,
@@ -1858,8 +2047,9 @@ xwl_resize_window(WindowPtr window,
     screen->ResizeWindow = xwl_resize_window;
 
     if (xwl_window) {
-        if (xwl_window_get(window) || xwl_window_is_toplevel(window))
+        if (xwl_window_get(window) || xwl_window_is_toplevel(window)) {
             xwl_window_check_resolution_change_emulation(xwl_window);
+        }
         if (window == screen->root) {
 #ifdef XWL_HAS_LIBDECOR
             unsigned int decor_width, decor_height;
@@ -1892,8 +2082,9 @@ xwl_move_window(WindowPtr window,
     xwl_screen->MoveWindow = screen->MoveWindow;
     screen->MoveWindow = xwl_move_window;
 
-    if (xwl_window && (xwl_window_get(window) || xwl_window_is_toplevel(window)))
+    if (xwl_window && (xwl_window_get(window) || xwl_window_is_toplevel(window))) {
         xwl_window_check_resolution_change_emulation(xwl_window);
+    }
 }
 
 static void
@@ -1913,13 +2104,14 @@ frame_callback(void *data,
          * xwl_present_frame_callback, need to make sure all fallback timers
          * are adjusted correspondingly.
          */
-        if (xwl_window->frame_callback)
+        if (xwl_window->frame_callback) {
             xwl_present_for_each_frame_callback(xwl_window, xwl_present_reset_timer);
+        }
     }
 }
 
 static const struct wl_callback_listener frame_listener = {
-    frame_callback
+    .done = frame_callback
 };
 
 void
@@ -1933,8 +2125,9 @@ xwl_window_create_frame_callback(struct
      * xwl_present_reset_timer.
      */
     if (xwl_window->xwl_screen->present &&
-        !xwl_present_entered_for_each_frame_callback())
+        !xwl_present_entered_for_each_frame_callback()) {
         xwl_present_for_each_frame_callback(xwl_window, xwl_present_reset_timer);
+    }
 }
 
 Bool
@@ -1945,18 +2138,21 @@ xwl_destroy_window(WindowPtr window)
     struct xwl_window *xwl_window = xwl_window_get(window);
     Bool ret;
 
-    if (xwl_screen->present)
+    if (xwl_screen->present) {
         xwl_present_cleanup(window);
+    }
 
-    if (xwl_window)
+    if (xwl_window) {
         xwl_window_dispose(xwl_window);
+    }
 
     screen->DestroyWindow = xwl_screen->DestroyWindow;
 
-    if (screen->DestroyWindow)
+    if (screen->DestroyWindow) {
         ret = screen->DestroyWindow (window);
-    else
+    } else {
         ret = TRUE;
+    }
 
     xwl_screen->DestroyWindow = screen->DestroyWindow;
     screen->DestroyWindow = xwl_destroy_window;
@@ -1970,10 +2166,11 @@ xwl_window_attach_buffer(struct xwl_wind
     struct xwl_screen *xwl_screen = xwl_window->xwl_screen;
     WindowPtr surface_window = xwl_window->surface_window;
     RegionPtr region;
-    BoxPtr box;
+    BoxPtr pbox;
     struct wl_buffer *buffer;
     PixmapPtr pixmap;
-    int i;
+    int i, num_rects;
+    Bool merge_damage = FALSE;
 
     pixmap = xwl_window_swap_pixmap(xwl_window, TRUE);
     buffer = xwl_pixmap_get_wl_buffer(pixmap);
@@ -1985,24 +2182,122 @@ xwl_window_attach_buffer(struct xwl_wind
 
     wl_surface_attach(xwl_window->surface, buffer, 0, 0);
 
-    /* Arbitrary limit to try to avoid flooding the Wayland
-     * connection. If we flood it too much anyway, this could
-     * abort in libwayland-client.
-     */
     region = xwl_window_get_damage_region(xwl_window);
-    if (RegionNumRects(region) > 256) {
-        box = RegionExtents(region);
-        xwl_surface_damage(xwl_screen, xwl_window->surface,
-                           box->x1 + surface_window->borderWidth,
-                           box->y1 + surface_window->borderWidth,
-                           box->x2 - box->x1, box->y2 - box->y1);
+    num_rects = RegionNumRects(region);
+
+    if (num_rects == 0) {
+        return TRUE;
+    }
+
+    if (num_rects < 4) {
+        /* Early bbox for tiny regions: perf win on small UI damage */
+        merge_damage = TRUE;
+    }
+
+    /* Use the more modern and efficient wl_surface_damage_buffer if available (wl_surface v4+) */
+    if (wl_surface_get_version(xwl_window->surface) >= WL_SURFACE_DAMAGE_BUFFER_SINCE_VERSION) {
+        /*
+         * Heuristic for damage reporting:
+         * 1. If damage is simple (<= 16 rects), send rects individually.
+         * 2. If complex (> 16 rects), check if damage is dense (>90% of bounding box).
+         *    If so, merge into one damage rect.
+         * 3. If complex and sparse, but extremely fragmented (> 256 rects), merge
+         *    as a last resort to prevent IPC flooding.
+         */
+        if (num_rects > 16) {
+            if (num_rects > 256) {
+                merge_damage = TRUE;
+            } else {
+                long long total_area = 0;
+                BoxPtr extents = RegionExtents(region);
+                long long bbox_area = (long long)(extents->x2 - extents->x1) *
+                                      (long long)(extents->y2 - extents->y1);
+                pbox = RegionRects(region);
+#if defined(__AVX2__)
+                /*
+                 * AVX2 vectorization: Process 4 boxes at a time to calculate total area.
+                 * This is significantly faster than scalar iteration for complex regions.
+                 */
+                int vec_count = num_rects / 4;
+                __m256i area_sum_vec = _mm256_setzero_si256();
+
+                for (i = 0; i < vec_count; i++) {
+                    // Load 4 boxes: {x1,y1,x2,y2}, {x1,y1,x2,y2}, ...
+                    __m256i box12 = _mm256_loadu_si256((__m256i const*)(pbox + i*4 + 0));
+                    __m256i box34 = _mm256_loadu_si256((__m256i const*)(pbox + i*4 + 2));
+
+                    // Shuffle to get {x1,x2,x1,x2,...} and {y1,y2,y1,y2,...}
+                    __m256i x_coords = _mm256_shuffle_epi32(_mm256_unpacklo_epi64(box12, box34), 0x88);
+                    __m256i y_coords = _mm256_shuffle_epi32(_mm256_unpackhi_epi64(box12, box34), 0x88);
+
+                    // widths = x2 - x1, heights = y2 - y1
+                    __m256i widths = _mm256_srai_epi32(_mm256_sub_epi16(x_coords, _mm256_permute2x128_si256(x_coords, x_coords, 0x01)), 16);
+                    __m256i heights = _mm256_srai_epi32(_mm256_sub_epi16(y_coords, _mm256_permute2x128_si256(y_coords, y_coords, 0x01)), 16);
+
+                    // areas = widths * heights
+                    __m256i areas = _mm256_mullo_epi32(widths, heights);
+                    area_sum_vec = _mm256_add_epi32(area_sum_vec, areas);
+                }
+
+                // Horizontal sum of the area vector
+                __m128i sum128 = _mm_add_epi32(_mm256_castsi256_si128(area_sum_vec),
+                                              _mm256_extracti128_si256(area_sum_vec, 1));
+                sum128 = _mm_add_epi32(sum128, _mm_srli_si128(sum128, 8));
+                sum128 = _mm_add_epi32(sum128, _mm_srli_si128(sum128, 4));
+                total_area = (long long)_mm_cvtsi128_si32(sum128);
+
+                // Process remaining boxes with scalar loop
+                for (i = vec_count * 4; i < num_rects; i++) {
+                    total_area += (long long)(pbox[i].x2 - pbox[i].x1) *
+                                  (long long)(pbox[i].y2 - pbox[i].y1);
+                }
+#else
+                for (i = 0; i < num_rects; i++) {
+                    total_area += (long long)(pbox[i].x2 - pbox[i].x1) *
+                                  (long long)(pbox[i].y2 - pbox[i].y1);
+                }
+#endif
+
+                /* If total damage area is >= 90% of the bounding box area, merge it */
+                if (total_area * 10LL >= bbox_area * 9LL) {
+                    merge_damage = TRUE;
+                }
+            }
+        }
+
+        if (merge_damage || (num_rects == 1 && RegionNotEmpty(region))) {
+            pbox = RegionExtents(region);
+            wl_surface_damage_buffer(xwl_window->surface,
+                                     pbox->x1 + surface_window->borderWidth,
+                                     pbox->y1 + surface_window->borderWidth,
+                                     pbox->x2 - pbox->x1,
+                                     pbox->y2 - pbox->y1);
+        } else if (num_rects > 1) {
+            pbox = RegionRects(region);
+            for (i = 0; i < num_rects; i++, pbox++) {
+                wl_surface_damage_buffer(xwl_window->surface,
+                                         pbox->x1 + surface_window->borderWidth,
+                                         pbox->y1 + surface_window->borderWidth,
+                                         pbox->x2 - pbox->x1,
+                                         pbox->y2 - pbox->y1);
+            }
+        }
     } else {
-        box = RegionRects(region);
-        for (i = 0; i < RegionNumRects(region); i++, box++) {
+        /* Fallback to old wl_surface_damage for older compositors */
+        if (num_rects > 256) {
+            pbox = RegionExtents(region);
             xwl_surface_damage(xwl_screen, xwl_window->surface,
-                               box->x1 + surface_window->borderWidth,
-                               box->y1 + surface_window->borderWidth,
-                               box->x2 - box->x1, box->y2 - box->y1);
+                               pbox->x1 + surface_window->borderWidth,
+                               pbox->y1 + surface_window->borderWidth,
+                               pbox->x2 - pbox->x1, pbox->y2 - pbox->y1);
+        } else {
+            pbox = RegionRects(region);
+            for (i = 0; i < num_rects; i++, pbox++) {
+                xwl_surface_damage(xwl_screen, xwl_window->surface,
+                                   pbox->x1 + surface_window->borderWidth,
+                                   pbox->y1 + surface_window->borderWidth,
+                                   pbox->x2 - pbox->x1, pbox->y2 - pbox->y1);
+            }
         }
     }
 
@@ -2014,8 +2309,9 @@ xwl_window_post_damage(struct xwl_window
 {
     assert(!xwl_window->frame_callback);
 
-    if (!xwl_window_attach_buffer(xwl_window))
+    if (!xwl_window_attach_buffer(xwl_window)) {
         return;
+    }
 
     xwl_window_create_frame_callback(xwl_window);
     DamageEmpty(window_get_damage(xwl_window->surface_window));
@@ -2035,14 +2331,48 @@ xwl_window_set_input_region(struct xwl_w
     }
 
     region = wl_compositor_create_region(xwl_window->xwl_screen->compositor);
-    box = RegionRects(input_shape);
+    if (!region) {
+        ErrorF("Failed creating input region\n");
+        return;
+    }
+
+    /* Fast path for the most common case: identity scale */
+    if (fabsf(xwl_window->viewport_scale_x - 1.0f) < 1e-6f && fabsf(xwl_window->viewport_scale_y - 1.0f) < 1e-6f) {
+        box = RegionRects(input_shape);
+        for (i = 0; i < RegionNumRects(input_shape); ++i, ++box) {
+            wl_region_add(region,
+                          box->x1,
+                          box->y1,
+                          box->x2 - box->x1,
+                          box->y2 - box->y1);
+        }
+    } else {
+        /*
+         * Optimized: Use fixed-point math to avoid slow floating-point division in a loop.
+         * Pre-calculate the reciprocal of the scale as a 16.16 fixed-point number.
+         */
+        float scale_x = xwl_window->viewport_scale_x;
+        float scale_y = xwl_window->viewport_scale_y;
+        long long inv_scale_x_16 = (long long)(65536.0f / scale_x + 0.5f);  /* Rounded reciprocal */
+        long long inv_scale_y_16 = (long long)(65536.0f / scale_y + 0.5f);
+        box = RegionRects(input_shape);
+
+        for (i = 0; i < RegionNumRects(input_shape); ++i, ++box) {
+            BoxRec b;
+
+            /*
+             * Scale coordinates using fast integer multiplication and bit-shifting.
+             * Floor for x1/y1, ceil for x2/y2 to ensure the scaled region fully
+             * contains the original.
+             */
+            b.x1 = (int)(((long long)box->x1 * inv_scale_x_16) >> 16);
+            b.y1 = (int)(((long long)box->y1 * inv_scale_y_16) >> 16);
+            b.x2 = (int)((((long long)box->x2 * inv_scale_x_16) + 65535LL) >> 16);
+            b.y2 = (int)((((long long)box->y2 * inv_scale_y_16) + 65535LL) >> 16);
+
 
-    for (i = 0; i < RegionNumRects(input_shape); ++i, ++box) {
-        wl_region_add(region,
-                      box->x1,
-                      box->y1,
-                      box->x2 - box->x1,
-                      box->y2 - box->y1);
+            wl_region_add(region, b.x1, b.y1, b.x2 - b.x1, b.y2 - b.y1);
+        }
     }
 
     wl_surface_set_input_region(xwl_window->surface, region);
@@ -2052,11 +2382,18 @@ xwl_window_set_input_region(struct xwl_w
 Bool
 xwl_window_init(void)
 {
-    if (!dixRegisterPrivateKey(&xwl_window_private_key, PRIVATE_WINDOW, 0))
+    if (!dixRegisterPrivateKey(&xwl_window_private_key, PRIVATE_WINDOW, 0)) {
+        return FALSE;
+    }
+
+    if (!dixRegisterPrivateKey(&xwl_wm_window_private_key, PRIVATE_WINDOW,
+                               sizeof(Bool))) {
         return FALSE;
+    }
 
-    if (!dixRegisterPrivateKey(&xwl_damage_private_key, PRIVATE_WINDOW, 0))
+    if (!dixRegisterPrivateKey(&xwl_damage_private_key, PRIVATE_WINDOW, 0)) {
         return FALSE;
+    }
 
     return TRUE;
 }
