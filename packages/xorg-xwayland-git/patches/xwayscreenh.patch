--- xwayland-screen.h.orig	2025-10-02 15:48:59.058099148 +0200
+++ xwayland-screen.h	2025-10-02 16:30:41.060726142 +0200
@@ -44,64 +44,123 @@
 #include <libdecor.h>
 #endif
 
+/* Forward declarations to reduce header coupling */
+struct xwl_format;
+struct xwl_emulated_mode;
+
 struct xwl_screen {
+    /*
+     * ═════════════════════════════════════════════════════════════════════
+     *  Core Screen Properties
+     * ═════════════════════════════════════════════════════════════════════
+     */
+    ScreenPtr screen;
     double width;
     double height;
     int depth;
     int global_surface_scale;
-    int output_name_serial;
-    ScreenPtr screen;
-    int wm_client_id;
-    int expecting_event;
     enum RootClipMode root_clip_mode;
 
-    Bool active;
-    int rootless;
+    /*
+     * ═════════════════════════════════════════════════════════════════════
+     *  Configuration Flags
+     * ═════════════════════════════════════════════════════════════════════
+     */
+    Bool rootless;
+    Bool fullscreen;
+    Bool host_grab;
+    Bool has_grab;
+    Bool decorate;
+    Bool enable_ei_portal;
+    Bool nokeymap;
+    Bool hidpi;
     xwl_glamor_mode_flags glamor;
-    int present;
-    int force_xrandr_emulation;
-    int fullscreen;
-    int host_grab;
-    int has_grab;
-    int decorate;
-    int enable_ei_portal;
-    int nokeymap;
-    int hidpi;
+    Bool present;
+    Bool force_xrandr_emulation;
+    Bool active;
+    Bool use_damage_buffer;
 
-    ClipNotifyProcPtr ClipNotify;
+    /*
+     * ═════════════════════════════════════════════════════════════════════
+     *  Wrapped X Server Function Pointers (for hooking screen operations)
+     * ═════════════════════════════════════════════════════════════════════
+     */
     CreateScreenResourcesProcPtr CreateScreenResources;
     CloseScreenProcPtr CloseScreen;
-    ConfigNotifyProcPtr ConfigNotify;
     RealizeWindowProcPtr RealizeWindow;
     UnrealizeWindowProcPtr UnrealizeWindow;
     DestroyWindowProcPtr DestroyWindow;
-    XYToWindowProcPtr XYToWindow;
-    SetWindowPixmapProcPtr SetWindowPixmap;
+    ConfigNotifyProcPtr ConfigNotify;
     ChangeWindowAttributesProcPtr ChangeWindowAttributes;
+    ReparentWindowProcPtr ReparentWindow;
     ResizeWindowProcPtr ResizeWindow;
     MoveWindowProcPtr MoveWindow;
+    SetWindowPixmapProcPtr SetWindowPixmap;
+    XYToWindowProcPtr XYToWindow;
     SourceValidateProcPtr SourceValidate;
     SetShapeProcPtr SetShape;
-
+    ClipNotifyProcPtr ClipNotify;
+    StoreColorsProcPtr StoreColors;
+    InstallColormapProcPtr InstallColormap;
+    UninstallColormapProcPtr UninstallColormap;
+    QueryBestSizeProcPtr QueryBestSize;
     int (*GrabServer) (ClientPtr client);
     int (*UngrabServer) (ClientPtr client);
 
+    /*
+     * ═════════════════════════════════════════════════════════════════════
+     *  Object Lists & State Management
+     * ═════════════════════════════════════════════════════════════════════
+     */
     struct xorg_list output_list;
     struct xorg_list seat_list;
     struct xorg_list damage_window_list;
     struct xorg_list window_list;
-    Bool ignore_damage;
+    struct xorg_list drm_lease_devices;
+    struct xorg_list queued_drm_lease_devices;
+    struct xorg_list drm_leases;
+    struct xorg_list pending_wl_surface_destroy;
 
+    int wm_client_id;
+    int expecting_event;
     int need_source_validate;
+    Bool ignore_damage;
+    uint32_t serial;
+    uint64_t surface_association_serial;
+
+    /*
+     * ═════════════════════════════════════════════════════════════════════
+     *  Wayland Event Loop State
+     *
+     *  These flags manage the core event loop synchronization with the
+     *  Wayland display server. This is a performance-critical section.
+     *
+     *  - wait_flush: If true, indicates that a previous wl_display_flush()
+     *    failed (likely due to a full buffer), and we must successfully
+     *    flush before waiting for new events.
+     *
+     *  - prepare_read: A flag to indicate that we are ready to block in
+     *    poll(). It is used to break out of a potential busy-wait loop in
+     *    xwl_sync_events() if wl_display_prepare_read() fails because other
+     *    code is concurrently flushing to the display.
+     * ═════════════════════════════════════════════════════════════════════
+     */
+    int prepare_read;
+    int wait_flush;
 
+    /*
+     * ═════════════════════════════════════════════════════════════════════
+     *  Wayland Protocol Objects (must be destroyed in xwl_close_screen)
+     * ═════════════════════════════════════════════════════════════════════
+     */
     int wayland_fd;
     struct wl_display *display;
     struct wl_registry *registry;
     struct wl_registry *input_registry;
     struct wl_compositor *compositor;
-    struct zwp_tablet_manager_v2 *tablet_manager;
     struct wl_shm *shm;
     struct xdg_wm_base *xdg_wm_base;
+    struct zwp_tablet_manager_v2 *tablet_manager;
     struct zwp_relative_pointer_manager_v1 *relative_pointer_manager;
     struct zwp_pointer_constraints_v1 *pointer_constraints;
     struct zwp_pointer_gestures_v1 *pointer_gestures;
@@ -109,46 +168,44 @@ struct xwl_screen {
     struct zwp_keyboard_shortcuts_inhibit_manager_v1 *shortcuts_inhibit_manager;
     struct zwp_keyboard_shortcuts_inhibitor_v1 *shortcuts_inhibit;
     struct zwp_linux_dmabuf_v1 *dmabuf;
-    int dmabuf_protocol_version;
-    struct xwl_dmabuf_feedback default_feedback;
     struct zxdg_output_manager_v1 *xdg_output_manager;
     struct wp_viewporter *viewporter;
     struct xwayland_shell_v1 *xwayland_shell;
     struct wp_tearing_control_manager_v1 *tearing_control_manager;
     struct wp_fractional_scale_manager_v1 *fractional_scale_manager;
     struct wp_linux_drm_syncobj_manager_v1 *explicit_sync;
-    struct xorg_list drm_lease_devices;
-    struct xorg_list queued_drm_lease_devices;
-    struct xorg_list drm_leases;
-    struct xwl_output *fixed_output;
-    struct xorg_list pending_wl_surface_destroy;
-    uint64_t surface_association_serial;
-    uint32_t serial;
 
-#define XWL_FORMAT_ARGB8888 (1 << 0)
-#define XWL_FORMAT_XRGB8888 (1 << 1)
-#define XWL_FORMAT_RGB565   (1 << 2)
+    /*
+     * ═════════════════════════════════════════════════════════════════════
+     *  EGL & Glamor Integration
+     * ═════════════════════════════════════════════════════════════════════
+     */
+    void *egl_display;
+    void *egl_context;
+    struct glamor_context *glamor_ctx;
+    const char *glvnd_vendor;
+    uint32_t present_capabilities;
 
-    int prepare_read;
-    int wait_flush;
+    int dmabuf_protocol_version;
+    struct xwl_dmabuf_feedback default_feedback;
 
     uint32_t num_formats;
     struct xwl_format *formats;
-    void *egl_display, *egl_context;
-
-    struct glamor_context *glamor_ctx;
-
-    Atom allow_commits_prop;
 
-    /* The preferred GLVND vendor. If NULL, "mesa" is assumed. */
-    const char *glvnd_vendor;
+    /*
+     * ═════════════════════════════════════════════════════════════════════
+     *  Rootful / Rootless Specifics
+     * ═════════════════════════════════════════════════════════════════════
+     */
+    struct xwl_output *fixed_output;
+    const char *output_name;
+    int output_name_serial;
 #ifdef XWL_HAS_LIBDECOR
     int libdecor_fd;
     struct libdecor *libdecor_context;
 #endif
-    const char *output_name;
 
-    uint32_t present_capabilities;
+    Atom allow_commits_prop;
 };
 
 /* Apps which use randr/vidmode to change the mode when going fullscreen,
@@ -172,8 +229,8 @@ int xwl_screen_get_height(struct xwl_scr
 
 Bool xwl_close_screen(ScreenPtr screen);
 Bool xwl_screen_init(ScreenPtr pScreen, int argc, char **argv);
-void xwl_sync_events (struct xwl_screen *xwl_screen);
-void xwl_screen_roundtrip (struct xwl_screen *xwl_screen);
+void xwl_sync_events(struct xwl_screen *xwl_screen);
+void xwl_screen_roundtrip(struct xwl_screen *xwl_screen);
 void xwl_surface_damage(struct xwl_screen *xwl_screen,
                         struct wl_surface *surface,
                         int32_t x, int32_t y, int32_t width, int32_t height);
