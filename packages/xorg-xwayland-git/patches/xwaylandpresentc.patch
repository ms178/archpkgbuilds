--- xwayland-present.c.orig	2025-08-17 00:21:07.659495734 +0200
+++ xwayland-present.c	2025-08-17 00:25:41.413780502 +0200
@@ -100,9 +100,15 @@ xwl_present_event_from_id(WindowPtr pres
     present_window_priv_ptr window_priv = present_get_window_priv(present_window, TRUE);
     struct xwl_present_event *event;
 
+    if (!window_priv)
+        return NULL;
+
     xorg_list_for_each_entry(event, &window_priv->vblank, vblank.window_list) {
         if (event->vblank.event_id == event_id)
             return event;
+        /* Early termination optimization: assuming mostly sequential event IDs */
+        if (event->vblank.event_id > event_id + 50000)  /* Conservative threshold */
+            break;
     }
     return NULL;
 }
@@ -183,6 +189,9 @@ xwl_present_has_pending_events(struct xw
 void
 xwl_present_reset_timer(struct xwl_present_window *xwl_present_window)
 {
+    if (!xwl_present_window)
+        return;
+
     if (xwl_present_has_pending_events(xwl_present_window)) {
         struct xwl_window *xwl_window = xwl_window_from_window(xwl_present_window->window);
         CARD32 now = GetTimeInMillis();
@@ -205,10 +214,17 @@ xwl_present_reset_timer(struct xwl_prese
                                            xwl_present_window);
                 return;
             }
+
+            /* Optimization: Avoid unnecessary timer updates */
+            if (xwl_present_window->frame_timer &&
+                xwl_present_window->timer_timeout == timeout) {
+                return;  /* Timer already set with correct timeout */
+            }
         } else {
             xwl_present_window->timer_armed = now;
         }
 
+        xwl_present_window->timer_timeout = timeout;  /* Track current timeout */
         xwl_present_window->frame_timer = TimerSet(xwl_present_window->frame_timer,
                                                    0, timeout,
                                                    &xwl_present_timer_callback,
@@ -218,7 +234,6 @@ xwl_present_reset_timer(struct xwl_prese
     }
 }
 
-
 static void
 xwl_present_execute(present_vblank_ptr vblank, uint64_t ust, uint64_t crtc_msc);
 
@@ -741,6 +756,7 @@ xwl_present_check_flip(RRCrtcPtr crtc,
     WindowPtr toplvl_window = xwl_present_toplvl_pixmap_window(present_window);
     struct xwl_window *xwl_window = xwl_window_from_window(present_window);
     ScreenPtr screen = pixmap->drawable.pScreen;
+    PixmapPtr window_pixmap = screen->GetWindowPixmap(present_window);
 
     if (reason)
         *reason = PRESENT_FLIP_REASON_UNKNOWN;
@@ -761,9 +777,11 @@ xwl_present_check_flip(RRCrtcPtr crtc,
     if (valid)
         return FALSE;
 
-    /* Flip pixmap must have same dimensions as window */
+    /* Flip pixmap must have same dimensions as the window and its pixmap */
     if (present_window->drawable.width != pixmap->drawable.width ||
-            present_window->drawable.height != pixmap->drawable.height)
+        present_window->drawable.height != pixmap->drawable.height ||
+        pixmap->drawable.width != window_pixmap->drawable.width ||
+        pixmap->drawable.height != window_pixmap->drawable.height)
         return FALSE;
 
     if (!xwl_pixmap_get_wl_buffer(pixmap))
@@ -781,7 +799,7 @@ xwl_present_check_flip(RRCrtcPtr crtc,
      * window's, e.g. because a client redirected this window or one of its
      * parents.
      */
-    if (screen->GetWindowPixmap(xwl_window->surface_window) != screen->GetWindowPixmap(present_window))
+    if (screen->GetWindowPixmap(xwl_window->surface_window) != window_pixmap)
         return FALSE;
 
     /*
@@ -1030,16 +1048,32 @@ xwl_present_flush_blocked(struct xwl_pre
 static void
 xwl_present_execute(present_vblank_ptr vblank, uint64_t ust, uint64_t crtc_msc)
 {
-    WindowPtr               window = vblank->window;
-    struct xwl_present_window *xwl_present_window = xwl_present_window_get_priv(window);
-    present_vblank_ptr flip_pending = xwl_present_get_pending_flip(xwl_present_window);
-    struct xwl_present_event *event = xwl_present_event_from_vblank(vblank);
-    struct xwl_screen *xwl_screen = xwl_screen_get(window->drawable.pScreen);
-    Bool notify_only = !vblank->window || !vblank->pixmap;
+    WindowPtr               window;
+    struct xwl_present_window *xwl_present_window;
+    present_vblank_ptr flip_pending;
+    struct xwl_present_event *event;
+    struct xwl_screen *xwl_screen;
+    Bool notify_only;
+
+    if (!vblank)
+        return;
+
+    window = vblank->window;
+    if (!window)
+        return;
+
+    xwl_present_window = xwl_present_window_get_priv(window);
+    if (!xwl_present_window)
+        return;
+
+    flip_pending = xwl_present_get_pending_flip(xwl_present_window);
+    event = xwl_present_event_from_vblank(vblank);
+    xwl_screen = xwl_screen_get(window->drawable.pScreen);
+    notify_only = !vblank->window || !vblank->pixmap;
 
     xorg_list_del(&vblank->event_queue);
 
-    if (!notify_only && !event->copy_executed &&
+    if (!notify_only && event && !event->copy_executed &&
         xwl_present_window->blocking_event &&
         xwl_present_window->blocking_event != event->vblank.event_id) {
         /* an earlier request is blocking execution */
@@ -1050,42 +1084,41 @@ xwl_present_execute(present_vblank_ptr v
 retry:
     if (present_execute_wait(vblank, crtc_msc) ||
         xwl_present_wait_acquire_fence_avail(xwl_screen, vblank)) {
-        if (!notify_only)
+        if (!notify_only && event)
             /* block execution of subsequent requests until this request is ready */
             xwl_present_window->blocking_event = event->vblank.event_id;
         return;
     }
 
     if (flip_pending && vblank->flip && !notify_only) {
-        present_vblank_ptr flip_queued_last;
-
-        flip_queued_last = xorg_list_last_entry(&xwl_present_window->flip_queue,
-                                                present_vblank_rec, event_queue);
-
-        /* Do mailbox handling for queued flips, to prevent the flip queue from
-         * growing unbounded.
-         */
-        if (flip_queued_last != flip_pending &&
-            (flip_queued_last->sync_flip
-#ifdef DRI3
-             || vblank->acquire_syncobj
-#endif
-             )) {
-            xorg_list_del(&flip_queued_last->event_queue);
-            present_vblank_scrap(flip_queued_last);
-            xwl_present_re_execute(flip_queued_last);
-        }
-
         DebugPresent(("\tr %" PRIu64 " %p (pending %p)\n",
                       vblank->event_id, vblank, flip_pending));
         xorg_list_append(&vblank->event_queue, &xwl_present_window->flip_queue);
-        vblank->flip_ready = TRUE;
+
+        /* Prevent flip queue from growing unbounded */
+        int queue_length = 0;
+        present_vblank_ptr temp_vblank;
+        xorg_list_for_each_entry(temp_vblank, &xwl_present_window->flip_queue, event_queue) {
+            queue_length++;
+            /* Early termination for performance */
+            if (queue_length > 32) break;
+        }
+
+        if (queue_length > 16) {  /* Reasonable limit */
+            present_vblank_ptr oldest_vblank = xorg_list_first_entry(
+                &xwl_present_window->flip_queue, present_vblank_rec, event_queue);
+            if (oldest_vblank && oldest_vblank != flip_pending && oldest_vblank != vblank) {
+                xorg_list_del(&oldest_vblank->event_queue);
+                present_vblank_scrap(oldest_vblank);
+                xwl_present_re_execute(oldest_vblank);
+            }
+        }
         return;
     }
 
     vblank->queued = FALSE;
 
-    if (!notify_only && !event->copy_executed) {
+    if (!notify_only && event && !event->copy_executed) {
         ScreenPtr screen = window->drawable.pScreen;
         int ret;
 
@@ -1094,49 +1127,62 @@ retry:
 
             DebugPresent(("\tf %" PRIu64 " %p %" PRIu64 ": %08" PRIx32 " -> %08" PRIx32 "\n",
                           vblank->event_id, vblank, crtc_msc,
-                          vblank->pixmap->drawable.id, vblank->window->drawable.id));
+                          vblank->pixmap ? vblank->pixmap->drawable.id : 0,
+                          vblank->window ? vblank->window->drawable.id : 0));
 
             /* Set update region as damaged */
             if (vblank->update) {
                 damage = RegionDuplicate(vblank->update);
-                /* Translate update region to screen space */
-                assert(vblank->x_off == 0 && vblank->y_off == 0);
-                RegionTranslate(damage, window->drawable.x, window->drawable.y);
-                RegionIntersect(damage, damage, &window->clipList);
-            } else
+                if (damage) {
+                    /* Translate update region to screen space */
+                    assert(vblank->x_off == 0 && vblank->y_off == 0);
+                    RegionTranslate(damage, window->drawable.x, window->drawable.y);
+                    RegionIntersect(damage, damage, &window->clipList);
+                }
+            } else {
                 damage = RegionDuplicate(&window->clipList);
+            }
 
-            if (xwl_present_flip(vblank, damage)) {
+            if (damage && xwl_present_flip(vblank, damage)) {
                 WindowPtr toplvl_window = xwl_present_toplvl_pixmap_window(vblank->window);
                 struct xwl_window *xwl_window = xwl_window_from_window(window);
                 PixmapPtr old_pixmap = screen->GetWindowPixmap(window);
 
                 /* Replace window pixmap with flip pixmap */
 #ifdef COMPOSITE
-                vblank->pixmap->screen_x = old_pixmap->screen_x;
-                vblank->pixmap->screen_y = old_pixmap->screen_y;
+                if (old_pixmap && vblank->pixmap) {
+                    vblank->pixmap->screen_x = old_pixmap->screen_x;
+                    vblank->pixmap->screen_y = old_pixmap->screen_y;
+                }
 #endif
-                present_set_tree_pixmap(toplvl_window, old_pixmap, vblank->pixmap);
+                if (toplvl_window)
+                    present_set_tree_pixmap(toplvl_window, old_pixmap, vblank->pixmap);
 
                 if (toplvl_window == screen->root &&
                     screen->GetScreenPixmap(screen) == old_pixmap)
                     screen->SetScreenPixmap(vblank->pixmap);
 
-                vblank->pixmap->refcnt++;
-                dixDestroyPixmap(old_pixmap, old_pixmap->drawable.id);
+                if (vblank->pixmap)
+                    vblank->pixmap->refcnt++;
+                if (old_pixmap)
+                    dixDestroyPixmap(old_pixmap, old_pixmap->drawable.id);
 
                 /* Report damage, let damage_report ignore it though */
-                xwl_screen->ignore_damage = TRUE;
-                DamageDamageRegion(&vblank->window->drawable, damage);
-                xwl_screen->ignore_damage = FALSE;
+                if (xwl_screen) {
+                    xwl_screen->ignore_damage = TRUE;
+                    DamageDamageRegion(&vblank->window->drawable, damage);
+                    xwl_screen->ignore_damage = FALSE;
+                }
                 RegionDestroy(damage);
 
                 /* Clear damage region, to ensure damage_report is called before
                  * any drawing to the window
                  */
-                xwl_window_buffer_add_damage_region(xwl_window);
-                RegionEmpty(xwl_window_get_damage_region(xwl_window));
-                xorg_list_del(&xwl_window->link_damage);
+                if (xwl_window) {
+                    xwl_window_buffer_add_damage_region(xwl_window);
+                    RegionEmpty(xwl_window_get_damage_region(xwl_window));
+                    xorg_list_del(&xwl_window->link_damage);
+                }
 
                 /* Put pending flip at the flip queue head */
                 xorg_list_add(&vblank->event_queue, &xwl_present_window->flip_queue);
@@ -1148,12 +1194,18 @@ retry:
                 return;
             }
 
+            if (damage)
+                RegionDestroy(damage);
+
             vblank->flip = FALSE;
             /* re-execute, falling through to copy */
             goto retry;
         }
+
         DebugPresent(("\tc %p %" PRIu64 ": %08" PRIx32 " -> %08" PRIx32 "\n",
-                      vblank, crtc_msc, vblank->pixmap->drawable.id, vblank->window->drawable.id));
+                      vblank, crtc_msc,
+                      vblank->pixmap ? vblank->pixmap->drawable.id : 0,
+                      vblank->window ? vblank->window->drawable.id : 0));
 
         if (flip_pending)
             flip_pending->abort_flip = TRUE;
@@ -1164,7 +1216,8 @@ retry:
         assert(!vblank->queued);
 
         /* Set the copy_executed field, so this will fall through to present_execute_post next time */
-        event->copy_executed = TRUE;
+        if (event)
+            event->copy_executed = TRUE;
 
         ret = xwl_present_queue_vblank(screen, window, vblank->crtc,
                                        vblank->event_id, crtc_msc + 1);
@@ -1202,39 +1255,64 @@ xwl_present_pixmap(WindowPtr window,
                    present_notify_ptr notifies,
                    int num_notifies)
 {
-    static uint64_t xwl_present_event_id;
+    static uint64_t xwl_present_event_id = 0;
     uint64_t                    ust = 0;
     uint64_t                    target_msc;
     uint64_t                    crtc_msc = 0;
     int                         ret;
     present_vblank_ptr          vblank;
-    ScreenPtr                   screen = window->drawable.pScreen;
-    present_window_priv_ptr     window_priv = present_get_window_priv(window, TRUE);
-    present_screen_priv_ptr     screen_priv = present_screen_priv(screen);
-    struct xwl_screen          *xwl_screen = xwl_screen_get(screen_priv->pScreen);
-    uint32_t                    caps = xwl_screen->present_capabilities;
+    ScreenPtr                   screen;
+    present_window_priv_ptr     window_priv;
+    present_screen_priv_ptr     screen_priv;
+    struct xwl_screen          *xwl_screen;
+    uint32_t                    caps;
     struct xwl_present_event *event;
 
+    if (!window)
+        return BadValue;
+
+    screen = window->drawable.pScreen;
+    if (!screen)
+        return BadValue;
+
+    window_priv = present_get_window_priv(window, TRUE);
     if (!window_priv)
         return BadAlloc;
 
 #ifdef DRI3
+    screen_priv = present_screen_priv(screen);
+    if (!screen_priv)
+        return BadImplementation;
+
+    xwl_screen = xwl_screen_get(screen_priv->pScreen);
+    if (!xwl_screen)
+        return BadImplementation;
+
+    caps = xwl_screen->present_capabilities;
+
     if (!(caps & PresentCapabilitySyncobj) &&
         (acquire_syncobj || release_syncobj))
         return BadValue;
+#else
+    screen_priv = present_screen_priv(screen);
+    if (!screen_priv)
+        return BadImplementation;
+    xwl_screen = xwl_screen_get(screen_priv->pScreen);
+    if (!xwl_screen)
+        return BadImplementation;
+    caps = xwl_screen->present_capabilities;
 #endif /* DRI3 */
 
     target_crtc = xwl_present_get_crtc(screen_priv, window);
 
     ret = xwl_present_get_ust_msc(screen, window, &ust, &crtc_msc);
+    if (ret != Success)
+        return ret;
 
     xwl_present_update_window_crtc(window_priv, target_crtc, crtc_msc);
 
-    if (ret == Success) {
-        /* Stash the current MSC away in case we need it later
-         */
-        window_priv->msc = crtc_msc;
-    }
+    /* Stash the current MSC away in case we need it later */
+    window_priv->msc = crtc_msc;
 
     target_msc = present_get_target_msc(target_window_msc + window_priv->msc_offset,
                                         crtc_msc,
@@ -1253,7 +1331,7 @@ xwl_present_pixmap(WindowPtr window,
                              acquire_syncobj, release_syncobj, acquire_point, release_point,
 #endif /* DRI3 */
                              options, caps, notifies, num_notifies, target_msc, crtc_msc)) {
-        present_vblank_destroy(vblank);
+        free(event);
         return BadAlloc;
     }
 
@@ -1261,7 +1339,12 @@ xwl_present_pixmap(WindowPtr window,
     event->options = options;
     event->divisor = divisor;
     event->remainder = remainder;
-    vblank->exec_msc = xwl_present_get_exec_msc(options, vblank->target_msc);
+
+    /* Precompute exec_msc to avoid function call overhead in hot paths */
+    if (options & PresentOptionAsyncMayTear)
+        vblank->exec_msc = target_msc;
+    else
+        vblank->exec_msc = (target_msc > 0) ? target_msc - 1 : 0;
 
     vblank->queued = TRUE;
     if (crtc_msc < vblank->exec_msc) {
@@ -1294,6 +1377,11 @@ xwl_present_maybe_redirect_window(Window
     struct xwl_present_window *xwl_present_window = xwl_present_window_get_priv(window);
     struct xwl_window *xwl_window = xwl_window_from_window(window);
 
+    (void) pixmap; /* pixmap parameter not used in this implementation */
+
+    if (!xwl_present_window || !xwl_window)
+        return FALSE;
+
     if (xwl_present_window->redirect_failed)
         return FALSE;
 
@@ -1302,17 +1390,20 @@ xwl_present_maybe_redirect_window(Window
         return FALSE;
     }
 
+    xwl_present_window->redirected = TRUE;
+
     xwl_window_update_surface_window(xwl_window);
     if (xwl_window->surface_window != window) {
         compUnredirectWindow(serverClient, window, CompositeRedirectManual);
+        xwl_present_window->redirected = FALSE;
         xwl_present_window->redirect_failed = TRUE;
+        xwl_window_update_surface_window(xwl_window);
         return FALSE;
     }
 
     if (!xwl_window->surface_window_damage)
         xwl_window->surface_window_damage = RegionCreate(NullBox, 1);
 
-    xwl_present_window->redirected = TRUE;
     return TRUE;
 }
 
@@ -1350,6 +1441,14 @@ xwl_present_maybe_unredirect_window(Wind
 }
 
 Bool
+xwl_present_window_redirected(WindowPtr window)
+{
+    struct xwl_present_window *xwl_present_window = xwl_present_window_get_priv(window);
+
+    return xwl_present_window->redirected;
+}
+
+Bool
 xwl_present_init(ScreenPtr screen)
 {
     struct xwl_screen *xwl_screen = xwl_screen_get(screen);
