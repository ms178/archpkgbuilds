--- a/hw/xwayland/xwayland-present.c	2025-07-26 09:12:16.955985549 +0200
+++ a/hw/xwayland/xwayland-present.c	2025-07-26 09:13:52.121013328 +0200
@@ -47,15 +47,15 @@
 
 #define XWL_PRESENT_CAPS PresentCapabilityAsync | PresentCapabilityAsyncMayTear
 
-
 /*
  * When not flipping let Present copy with 60fps.
  * When flipping wait on frame_callback, otherwise
  * the surface is not visible, in this case update
  * with long interval.
  */
-#define TIMER_LEN_COPY      17  // ~60fps
-#define TIMER_LEN_FLIP    1000  // 1fps
+#define TIMER_LEN_FLIP      16  // 60fps for active gaming
+#define TIMER_LEN_COPY      8   // 120fps for copy operations
+#define TIMER_LEN_IDLE      100 // 10fps when idle
 
 static DevPrivateKeyRec xwl_present_window_private_key;
 
@@ -100,6 +100,9 @@ xwl_present_event_from_id(WindowPtr pres
     present_window_priv_ptr window_priv = present_get_window_priv(present_window, TRUE);
     struct xwl_present_event *event;
 
+    if (!window_priv)
+        return NULL;
+
     xorg_list_for_each_entry(event, &window_priv->vblank, vblank.window_list) {
         if (event->vblank.event_id == event_id)
             return event;
@@ -143,9 +146,11 @@ xwl_present_for_each_frame_callback(stru
 static void
 xwl_present_free_timer(struct xwl_present_window *xwl_present_window)
 {
-    TimerFree(xwl_present_window->frame_timer);
-    xwl_present_window->frame_timer = NULL;
-    xwl_present_window->timer_armed = 0;
+    if (xwl_present_window && xwl_present_window->frame_timer) {
+        TimerFree(xwl_present_window->frame_timer);
+        xwl_present_window->frame_timer = NULL;
+        xwl_present_window->timer_armed = 0;
+    }
 }
 
 static CARD32
@@ -158,13 +163,13 @@ xwl_present_get_pending_flip(struct xwl_
 {
     present_vblank_ptr flip_pending;
 
-    if (xorg_list_is_empty(&xwl_present_window->flip_queue))
+    if (!xwl_present_window || xorg_list_is_empty(&xwl_present_window->flip_queue))
         return NULL;
 
     flip_pending = xorg_list_first_entry(&xwl_present_window->flip_queue, present_vblank_rec,
                                          event_queue);
 
-    if (flip_pending->queued)
+    if (flip_pending && flip_pending->queued)
         return NULL;
 
     return flip_pending;
@@ -173,7 +178,12 @@ xwl_present_get_pending_flip(struct xwl_
 static inline Bool
 xwl_present_has_pending_events(struct xwl_present_window *xwl_present_window)
 {
-    present_vblank_ptr flip_pending = xwl_present_get_pending_flip(xwl_present_window);
+    present_vblank_ptr flip_pending;
+
+    if (!xwl_present_window)
+        return FALSE;
+
+    flip_pending = xwl_present_get_pending_flip(xwl_present_window);
 
     return (flip_pending && flip_pending->sync_flip) ||
            !xorg_list_is_empty(&xwl_present_window->wait_list) ||
@@ -183,6 +193,9 @@ xwl_present_has_pending_events(struct xw
 void
 xwl_present_reset_timer(struct xwl_present_window *xwl_present_window)
 {
+    if (!xwl_present_window)
+        return;
+
     if (xwl_present_has_pending_events(xwl_present_window)) {
         struct xwl_window *xwl_window = xwl_window_from_window(xwl_present_window->window);
         CARD32 now = GetTimeInMillis();
@@ -218,7 +231,6 @@ xwl_present_reset_timer(struct xwl_prese
     }
 }
 
-
 static void
 xwl_present_execute(present_vblank_ptr vblank, uint64_t ust, uint64_t crtc_msc);
 
@@ -233,7 +245,7 @@ static uint32_t
 xwl_present_query_capabilities(present_screen_priv_ptr screen_priv)
 {
     struct xwl_screen *xwl_screen = xwl_screen_get(screen_priv->pScreen);
-    return xwl_screen->present_capabilities;
+    return xwl_screen ? xwl_screen->present_capabilities : 0;
 }
 
 static int
@@ -243,7 +255,7 @@ xwl_present_get_ust_msc(ScreenPtr screen
                         uint64_t *msc)
 {
     struct xwl_present_window *xwl_present_window = xwl_present_window_get_priv(present_window);
-    if (!xwl_present_window)
+    if (!xwl_present_window || !ust || !msc)
         return BadAlloc;
 
     *ust = xwl_present_window->ust;
@@ -261,7 +273,7 @@ xwl_present_get_exec_msc(uint32_t option
     if (options & PresentOptionAsyncMayTear)
         return target_msc;
 
-    return target_msc - 1;
+    return target_msc > 0 ? target_msc - 1 : 0;
 }
 
 /*
@@ -271,9 +283,16 @@ xwl_present_get_exec_msc(uint32_t option
 static void
 xwl_present_re_execute(present_vblank_ptr vblank)
 {
-    struct xwl_present_event *event = xwl_present_event_from_vblank(vblank);
+    struct xwl_present_event *event;
     uint64_t ust = 0, crtc_msc = 0;
 
+    if (!vblank)
+        return;
+
+    event = xwl_present_event_from_vblank(vblank);
+    if (!event)
+        return;
+
     (void) xwl_present_get_ust_msc(vblank->screen, vblank->window, &ust, &crtc_msc);
     /* re-compute target / exec msc */
     vblank->target_msc = present_get_target_msc(0, crtc_msc,
@@ -300,6 +319,9 @@ xwl_present_flip_try_ready(struct xwl_pr
 {
     present_vblank_ptr vblank;
 
+    if (!xwl_present_window)
+        return;
+
     xorg_list_for_each_entry(vblank, &xwl_present_window->flip_queue, event_queue) {
         if (vblank->queued) {
             xwl_present_re_execute(vblank);
@@ -311,7 +333,7 @@ xwl_present_flip_try_ready(struct xwl_pr
 static void
 xwl_present_release_pixmap(struct xwl_present_event *event)
 {
-    if (!event->pixmap)
+    if (!event || !event->pixmap)
         return;
 
     xwl_pixmap_del_buffer_release_cb(event->pixmap);
@@ -322,6 +344,9 @@ xwl_present_release_pixmap(struct xwl_pr
 static void
 xwl_present_free_event(struct xwl_present_event *event)
 {
+    if (!event)
+        return;
+
     xwl_present_release_pixmap(event);
     xorg_list_del(&event->vblank.event_queue);
     present_vblank_destroy(&event->vblank);
@@ -330,31 +355,53 @@ xwl_present_free_event(struct xwl_presen
 static void
 xwl_present_free_idle_vblank(present_vblank_ptr vblank)
 {
+    struct xwl_present_event *event;
+
+    if (!vblank)
+        return;
+
+    event = xwl_present_event_from_vblank(vblank);
+    if (!event)
+        return;
+
 #if defined(XWL_HAS_GLAMOR) && defined(DRI3)
     if (vblank->release_syncobj) {
         /* transfer implicit fence to release syncobj */
         int fence_fd = xwl_glamor_dmabuf_export_sync_file(vblank->pixmap);
-        vblank->release_syncobj->import_fence(vblank->release_syncobj,
-                                              vblank->release_point,
-                                              fence_fd);
+        if (fence_fd >= 0 && vblank->release_syncobj) {
+            vblank->release_syncobj->import_fence(vblank->release_syncobj,
+                                                  vblank->release_point,
+                                                  fence_fd);
+        }
     } else
 #endif /* defined(XWL_HAS_GLAMOR) && defined(DRI3) */
         present_pixmap_idle(vblank->pixmap, vblank->window,
                             vblank->serial, vblank->idle_fence);
-    xwl_present_free_event(xwl_present_event_from_vblank(vblank));
+    xwl_present_free_event(event);
 }
 
 static WindowPtr
 xwl_present_toplvl_pixmap_window(WindowPtr window)
 {
-    ScreenPtr       screen = window->drawable.pScreen;
-    PixmapPtr       pixmap = (*screen->GetWindowPixmap)(window);
+    ScreenPtr       screen;
+    PixmapPtr       pixmap;
     WindowPtr       w = window;
     WindowPtr       next_w;
 
+    if (!window)
+        return NULL;
+
+    screen = window->drawable.pScreen;
+    if (!screen)
+        return NULL;
+
+    pixmap = (*screen->GetWindowPixmap)(window);
+    if (!pixmap)
+        return window;
+
     while(w->parent) {
         next_w = w->parent;
-        if ( (*screen->GetWindowPixmap)(next_w) != pixmap) {
+        if ((*screen->GetWindowPixmap)(next_w) != pixmap) {
             break;
         }
         w = next_w;
@@ -368,22 +415,37 @@ xwl_present_flips_stop(WindowPtr window)
     struct xwl_present_window *xwl_present_window = xwl_present_window_priv(window);
     present_vblank_ptr vblank, tmp;
 
+    if (!xwl_present_window)
+        return;
+
     /* Change back to the fast refresh rate */
     xwl_present_reset_timer(xwl_present_window);
 
     /* Free any left over idle vblanks */
-    xorg_list_for_each_entry_safe(vblank, tmp, &xwl_present_window->idle_queue, event_queue)
-        xwl_present_free_idle_vblank(vblank);
+    xorg_list_for_each_entry_safe(vblank, tmp, &xwl_present_window->idle_queue, event_queue) {
+        if (vblank)
+            xwl_present_free_idle_vblank(vblank);
+    }
 
     if (xwl_present_window->flip_active) {
         struct xwl_present_event *event;
 
         vblank = xwl_present_window->flip_active;
         event = xwl_present_event_from_vblank(vblank);
-        if (event->pixmap)
-            xwl_present_free_idle_vblank(vblank);
-        else
-            xwl_present_free_event(event);
+        if (event) {
+            if (!event->pixmap
+#ifdef DRI3
+                /* If this flip used explicit sync, we won't get a release event */
+                || (vblank->release_syncobj)
+#endif /* DRI3 */
+                ) {
+                xwl_present_free_event(event);
+            } else
+                /* Put the previous flip in the idle_queue and wait for further notice from
+                 * the Wayland compositor
+                 */
+                xorg_list_append(&xwl_present_window->flip_active->event_queue, &xwl_present_window->idle_queue);
+        }
 
         xwl_present_window->flip_active = NULL;
     }
@@ -394,19 +456,37 @@ xwl_present_flips_stop(WindowPtr window)
 static void
 xwl_present_flip_notify_vblank(present_vblank_ptr vblank, uint64_t ust, uint64_t crtc_msc)
 {
-    WindowPtr                   window = vblank->window;
+    WindowPtr                   window;
 #ifdef DRI3
-    struct xwl_screen *xwl_screen = xwl_screen_get(window->drawable.pScreen);
+    struct xwl_screen *xwl_screen;
 #endif /* DRI3 */
-    struct xwl_present_window *xwl_present_window = xwl_present_window_priv(window);
+    struct xwl_present_window *xwl_present_window;
     uint8_t mode = PresentCompleteModeFlip;
 
+    if (!vblank)
+        return;
+
+    window = vblank->window;
+    if (!window)
+        return;
+
+#ifdef DRI3
+    xwl_screen = xwl_screen_get(window->drawable.pScreen);
+#endif /* DRI3 */
+    xwl_present_window = xwl_present_window_priv(window);
+
+    if (!xwl_present_window)
+        return;
+
     DebugPresent(("\tn %" PRIu64 " %p %" PRIu64 " %" PRIu64 ": %08" PRIx32 " -> %08" PRIx32 "\n",
                   vblank->event_id, vblank, vblank->exec_msc, vblank->target_msc,
                   vblank->pixmap ? vblank->pixmap->drawable.id : 0,
                   vblank->window ? vblank->window->drawable.id : 0));
 
-    assert (&vblank->event_queue == xwl_present_window->flip_queue.next);
+    if (&vblank->event_queue != xwl_present_window->flip_queue.next) {
+        /* Safety check - list corruption */
+        return;
+    }
 
     xorg_list_del(&vblank->event_queue);
 
@@ -414,14 +494,14 @@ xwl_present_flip_notify_vblank(present_v
         struct xwl_present_event *event =
             xwl_present_event_from_vblank(xwl_present_window->flip_active);
 
-        if (!event->pixmap
+        if (event && (!event->pixmap
 #ifdef DRI3
             /* If this flip used explicit sync, we won't get a release event */
-            || (xwl_screen->explicit_sync && vblank->release_syncobj)
+            || (xwl_screen && xwl_screen->explicit_sync && vblank->release_syncobj)
 #endif /* DRI3 */
-            ) {
+            )) {
             xwl_present_free_event(event);
-        } else
+        } else if (xwl_present_window->flip_active)
             /* Put the previous flip in the idle_queue and wait for further notice from
              * the Wayland compositor
              */
@@ -445,7 +525,7 @@ static void
 xwl_present_update_window_crtc(present_window_priv_ptr window_priv, RRCrtcPtr crtc, uint64_t new_msc)
 {
     /* Crtc unchanged, no offset. */
-    if (crtc == window_priv->crtc)
+    if (!window_priv || crtc == window_priv->crtc)
         return;
 
     /* No crtc earlier to offset against, just set the crtc. */
@@ -463,7 +543,6 @@ xwl_present_update_window_crtc(present_w
     window_priv->crtc = crtc;
 }
 
-
 void
 xwl_present_cleanup(WindowPtr window)
 {
@@ -483,13 +562,18 @@ xwl_present_cleanup(WindowPtr window)
 
     if (window_priv) {
         /* Clear remaining events */
-        xorg_list_for_each_entry_safe(event, tmp, &window_priv->vblank, vblank.window_list)
-            xwl_present_free_event(event);
+        xorg_list_for_each_entry_safe(event, tmp, &window_priv->vblank, vblank.window_list) {
+            if (event)
+                xwl_present_free_event(event);
+        }
     }
 
     /* Clear timer */
     xwl_present_free_timer(xwl_present_window);
-    TimerFree(xwl_present_window->unredirect_timer);
+    if (xwl_present_window->unredirect_timer) {
+        TimerFree(xwl_present_window->unredirect_timer);
+        xwl_present_window->unredirect_timer = NULL;
+    }
 
     /* Remove from privates so we don't try to access it later */
     dixSetPrivate(&window->devPrivates,
@@ -510,21 +594,26 @@ xwl_present_buffer_release(void *data)
         return;
 
     vblank = &event->vblank;
+    if (!vblank->window)
+        return;
 
 #if defined(XWL_HAS_GLAMOR) && defined(DRI3)
     if (vblank->release_syncobj) {
         /* transfer implicit fence to release syncobj */
         int fence_fd = xwl_glamor_dmabuf_export_sync_file(vblank->pixmap);
-        vblank->release_syncobj->import_fence(vblank->release_syncobj,
-                                              vblank->release_point,
-                                              fence_fd);
+        if (fence_fd >= 0 && vblank->release_syncobj) {
+            vblank->release_syncobj->import_fence(vblank->release_syncobj,
+                                                  vblank->release_point,
+                                                  fence_fd);
+        }
     } else
 #endif /* defined(XWL_HAS_GLAMOR) && defined(DRI3) */
         present_pixmap_idle(vblank->pixmap, vblank->window, vblank->serial, vblank->idle_fence);
 
     xwl_present_window = xwl_present_window_priv(vblank->window);
-    if (xwl_present_window->flip_active == vblank ||
-        xwl_present_get_pending_flip(xwl_present_window) == vblank)
+    if (xwl_present_window &&
+        (xwl_present_window->flip_active == vblank ||
+         xwl_present_get_pending_flip(xwl_present_window) == vblank))
         xwl_present_release_pixmap(event);
     else
         xwl_present_free_event(event);
@@ -533,19 +622,24 @@ xwl_present_buffer_release(void *data)
 static void
 xwl_present_msc_bump(struct xwl_present_window *xwl_present_window)
 {
-    present_vblank_ptr flip_pending = xwl_present_get_pending_flip(xwl_present_window);
-    uint64_t msc = ++xwl_present_window->msc;
+    present_vblank_ptr flip_pending;
+    uint64_t msc;
     present_vblank_ptr vblank, tmp;
 
+    if (!xwl_present_window)
+        return;
+
+    msc = ++xwl_present_window->msc;
     xwl_present_window->ust = GetTimeInMicros();
 
     xwl_present_window->timer_armed = 0;
 
+    flip_pending = xwl_present_get_pending_flip(xwl_present_window);
     if (flip_pending && flip_pending->sync_flip)
         xwl_present_flip_notify_vblank(flip_pending, xwl_present_window->ust, msc);
 
     xorg_list_for_each_entry_safe(vblank, tmp, &xwl_present_window->wait_list, event_queue) {
-        if (vblank->exec_msc <= msc) {
+        if (vblank && vblank->exec_msc <= msc) {
             DebugPresent(("\te %" PRIu64 " ust %" PRIu64 " msc %" PRIu64 "\n",
                           vblank->event_id, xwl_present_window->ust, msc));
 
@@ -561,6 +655,9 @@ xwl_present_timer_callback(OsTimerPtr ti
 {
     struct xwl_present_window *xwl_present_window = arg;
 
+    if (!xwl_present_window)
+        return 0;
+
     /* If we were expecting a frame callback for this window, it didn't arrive
      * in a second. Stop listening to it to avoid double-bumping the MSC
      */
@@ -575,6 +672,9 @@ xwl_present_timer_callback(OsTimerPtr ti
 void
 xwl_present_frame_callback(struct xwl_present_window *xwl_present_window)
 {
+    if (!xwl_present_window)
+        return;
+
     xorg_list_del(&xwl_present_window->frame_callback_list);
 
     xwl_present_msc_bump(xwl_present_window);
@@ -591,10 +691,19 @@ xwl_present_sync_callback(void *data,
                uint32_t time)
 {
     present_vblank_ptr vblank = data;
-    struct xwl_present_window *xwl_present_window = xwl_present_window_get_priv(vblank->window);
+    struct xwl_present_window *xwl_present_window;
+
+    if (!vblank || !vblank->window)
+        return;
 
-    wl_callback_destroy(xwl_present_window->sync_callback);
-    xwl_present_window->sync_callback = NULL;
+    xwl_present_window = xwl_present_window_get_priv(vblank->window);
+    if (!xwl_present_window)
+        return;
+
+    if (xwl_present_window->sync_callback) {
+        wl_callback_destroy(xwl_present_window->sync_callback);
+        xwl_present_window->sync_callback = NULL;
+    }
 
     xwl_present_flip_notify_vblank(vblank, xwl_present_window->ust, xwl_present_window->msc);
 }
@@ -609,13 +718,18 @@ xwl_present_get_crtc(present_screen_priv
 {
     struct xwl_present_window *xwl_present_window = xwl_present_window_get_priv(present_window);
     rrScrPrivPtr rr_private;
+    ScreenPtr screen;
 
     if (xwl_present_window == NULL)
         return NULL;
 
-    rr_private = rrGetScrPriv(present_window->drawable.pScreen);
+    if (!present_window || !present_window->drawable.pScreen)
+        return NULL;
+
+    screen = present_window->drawable.pScreen;
+    rr_private = rrGetScrPriv(screen);
 
-    if (rr_private->numCrtcs == 0)
+    if (!rr_private || rr_private->numCrtcs == 0)
         return NULL;
 
     return rr_private->crtcs[0];
@@ -633,9 +747,13 @@ xwl_present_queue_vblank(ScreenPtr scree
                          uint64_t msc)
 {
     struct xwl_present_window *xwl_present_window = xwl_present_window_get_priv(present_window);
-    struct xwl_window *xwl_window = xwl_window_from_window(present_window);
-    struct xwl_present_event *event = xwl_present_event_from_id(present_window, event_id);
+    struct xwl_window *xwl_window;
+    struct xwl_present_event *event;
+
+    if (!xwl_present_window)
+        return BadAlloc;
 
+    event = xwl_present_event_from_id(present_window, event_id);
     if (!event) {
         ErrorF("present: Error getting event\n");
         return BadImplementation;
@@ -647,6 +765,7 @@ xwl_present_queue_vblank(ScreenPtr scree
     xorg_list_append(&event->vblank.event_queue, &xwl_present_window->wait_list);
 
     /* Hook up to frame callback */
+    xwl_window = xwl_window_from_window(present_window);
     if (xwl_window &&
         xorg_list_is_empty(&xwl_present_window->frame_callback_list)) {
         xorg_list_add(&xwl_present_window->frame_callback_list,
@@ -671,26 +790,36 @@ xwl_present_abort_vblank(ScreenPtr scree
                          uint64_t event_id,
                          uint64_t msc)
 {
-    static Bool called;
+    static Bool called = FALSE;
 
     if (called)
         return;
 
+    called = TRUE;
     /* xwl_present_cleanup should have cleaned up everything,
      * present_free_window_vblank shouldn't need to call this.
      */
     ErrorF("Unexpected call to %s:\n", __func__);
     xorg_backtrace();
+    called = FALSE;
 }
 
 static void
 xwl_present_flush(WindowPtr window)
 {
 #ifdef XWL_HAS_GLAMOR
-    ScreenPtr screen = window->drawable.pScreen;
-    struct xwl_screen *xwl_screen = xwl_screen_get(screen);
+    ScreenPtr screen;
+    struct xwl_screen *xwl_screen;
+
+    if (!window)
+        return;
+
+    screen = window->drawable.pScreen;
+    if (!screen)
+        return;
 
-    if (xwl_screen->glamor)
+    xwl_screen = xwl_screen_get(screen);
+    if (xwl_screen && xwl_screen->glamor)
         glamor_block_handler(screen);
 #endif
 }
@@ -698,21 +827,33 @@ xwl_present_flush(WindowPtr window)
 static void
 xwl_present_maybe_set_reason(struct xwl_window *xwl_window, PresentFlipReason *reason)
 {
-    struct xwl_screen *xwl_screen = xwl_window->xwl_screen;
+    struct xwl_screen *xwl_screen;
 
-    if (!reason || xwl_screen->dmabuf_protocol_version < 4)
+    if (!xwl_window || !reason)
+        return;
+
+    xwl_screen = xwl_window->xwl_screen;
+    if (!xwl_screen)
+        return;
+
+    if (reason)
+        *reason = PRESENT_FLIP_REASON_UNKNOWN;
+
+    if (xwl_screen->dmabuf_protocol_version < 4)
         return;
 
     if (xwl_window->feedback.unprocessed_feedback_pending) {
         xwl_window->feedback.unprocessed_feedback_pending = 0;
 
-        *reason = PRESENT_FLIP_REASON_BUFFER_FORMAT;
+        if (reason)
+            *reason = PRESENT_FLIP_REASON_BUFFER_FORMAT;
     }
 
     if (xwl_screen->default_feedback.unprocessed_feedback_pending) {
         xwl_screen->default_feedback.unprocessed_feedback_pending = 0;
 
-        *reason = PRESENT_FLIP_REASON_BUFFER_FORMAT;
+        if (reason)
+            *reason = PRESENT_FLIP_REASON_BUFFER_FORMAT;
     }
 }
 
@@ -720,9 +861,14 @@ static int
 xwl_present_flush_fenced(WindowPtr window)
 {
     int fence = -1;
+
+    if (!window)
+        return -1;
+
 #ifdef XWL_HAS_GLAMOR
     struct xwl_screen *xwl_screen = xwl_screen_get(window->drawable.pScreen);
-    fence = xwl_glamor_get_fence(xwl_screen);
+    if (xwl_screen)
+        fence = xwl_glamor_get_fence(xwl_screen);
 #endif /* XWL_HAS_GLAMOR */
     xwl_present_flush(window);
     return fence;
@@ -738,15 +884,22 @@ xwl_present_check_flip(RRCrtcPtr crtc,
                        int16_t y_off,
                        PresentFlipReason *reason)
 {
-    WindowPtr toplvl_window = xwl_present_toplvl_pixmap_window(present_window);
-    struct xwl_window *xwl_window = xwl_window_from_window(present_window);
-    ScreenPtr screen = pixmap->drawable.pScreen;
-    PixmapPtr window_pixmap = screen->GetWindowPixmap(present_window);
+    WindowPtr toplvl_window;
+    struct xwl_window *xwl_window;
+    ScreenPtr screen;
+    PixmapPtr window_pixmap;
 
     if (reason)
         *reason = PRESENT_FLIP_REASON_UNKNOWN;
 
-    if (!xwl_window)
+    if (!present_window || !pixmap)
+        return FALSE;
+
+    toplvl_window = xwl_present_toplvl_pixmap_window(present_window);
+    xwl_window = xwl_window_from_window(present_window);
+    screen = pixmap->drawable.pScreen;
+
+    if (!xwl_window || !screen)
         return FALSE;
 
     xwl_present_maybe_set_reason(xwl_window, reason);
@@ -762,6 +915,10 @@ xwl_present_check_flip(RRCrtcPtr crtc,
     if (valid)
         return FALSE;
 
+    window_pixmap = screen->GetWindowPixmap(present_window);
+    if (!window_pixmap)
+        return FALSE;
+
     /* Flip pixmap must have same dimensions as the window and its pixmap */
     if (present_window->drawable.width != pixmap->drawable.width ||
         present_window->drawable.height != pixmap->drawable.height ||
@@ -773,7 +930,7 @@ xwl_present_check_flip(RRCrtcPtr crtc,
         return FALSE;
 
     /* Window must be same region as toplevel window */
-    if ( !RegionEqual(&present_window->winSize, &toplvl_window->winSize) )
+    if (!RegionEqual(&present_window->winSize, &toplvl_window->winSize))
         return FALSE;
 
     /* Can't flip if window clipped by children */
@@ -820,7 +977,6 @@ xwl_present_check_flip_window (WindowPtr
     present_vblank_ptr      flip_pending;
     present_vblank_ptr      flip_active;
     present_vblank_ptr      vblank;
-    PresentFlipReason       reason;
 
     /* If this window hasn't ever been used with Present, it can't be
      * flipping
@@ -843,7 +999,8 @@ xwl_present_check_flip_window (WindowPtr
 
     /* Now check any queued vblanks */
     xorg_list_for_each_entry(vblank, &window_priv->vblank, window_list) {
-        if (vblank->queued && vblank->flip &&
+        PresentFlipReason reason = PRESENT_FLIP_REASON_UNKNOWN;
+        if (vblank && vblank->queued && vblank->flip &&
                 !xwl_present_check_flip(vblank->crtc, window, vblank->pixmap,
                                         vblank->sync_flip, vblank->valid, 0, 0, &reason)) {
             vblank->flip = FALSE;
@@ -864,16 +1021,28 @@ xwl_present_clear_window_flip(WindowPtr
 static Bool
 xwl_present_flip(present_vblank_ptr vblank, RegionPtr damage)
 {
-    WindowPtr present_window = vblank->window;
-    PixmapPtr pixmap = vblank->pixmap;
-    struct xwl_window           *xwl_window = xwl_window_from_window(present_window);
-    struct xwl_present_window   *xwl_present_window = xwl_present_window_priv(present_window);
+    WindowPtr present_window;
+    PixmapPtr pixmap;
+    struct xwl_window           *xwl_window;
+    struct xwl_present_window   *xwl_present_window;
     BoxPtr                      damage_box;
     struct wl_buffer            *buffer;
-    struct xwl_present_event    *event = xwl_present_event_from_vblank(vblank);
+    struct xwl_present_event    *event;
     Bool                        implicit_sync = TRUE;
 
-    if (!xwl_window || !xwl_window->allow_commits)
+    if (!vblank)
+        return FALSE;
+
+    present_window = vblank->window;
+    pixmap = vblank->pixmap;
+
+    if (!present_window || !pixmap)
+        return FALSE;
+
+    xwl_window = xwl_window_from_window(present_window);
+    xwl_present_window = xwl_present_window_priv(present_window);
+
+    if (!xwl_window || !xwl_window->allow_commits || !xwl_present_window)
         return FALSE;
 
     buffer = xwl_pixmap_get_wl_buffer(pixmap);
@@ -883,9 +1052,16 @@ xwl_present_flip(present_vblank_ptr vbla
     }
 
     damage_box = RegionExtents(damage);
+    if (!damage_box) {
+        return FALSE;
+    }
 
     pixmap->refcnt++;
 
+    event = xwl_present_event_from_vblank(vblank);
+    if (!event)
+        return FALSE;
+
     event->pixmap = pixmap;
 
 #if defined(XWL_HAS_GLAMOR) && defined(DRI3)
@@ -899,10 +1075,12 @@ xwl_present_flip(present_vblank_ptr vbla
             implicit_sync = FALSE;
         } else {
             /* transfer from acquire syncobj to implicit fence */
-            int fence_fd =
-                vblank->acquire_syncobj->export_fence(vblank->acquire_syncobj,
-                                                      vblank->acquire_point);
-            xwl_glamor_dmabuf_import_sync_file(vblank->pixmap, fence_fd);
+            if (vblank->acquire_syncobj) {
+                int fence_fd =
+                    vblank->acquire_syncobj->export_fence(vblank->acquire_syncobj,
+                                                          vblank->acquire_point);
+                xwl_glamor_dmabuf_import_sync_file(vblank->pixmap, fence_fd);
+            }
         }
     }
 #endif /* defined(XWL_HAS_GLAMOR) && defined(DRI3) */
@@ -948,9 +1126,11 @@ xwl_present_flip(present_vblank_ptr vbla
     if (!vblank->sync_flip) {
         xwl_present_window->sync_callback =
             wl_display_sync(xwl_window->xwl_screen->display);
-        wl_callback_add_listener(xwl_present_window->sync_callback,
-                                 &xwl_present_sync_listener,
-                                 &event->vblank);
+        if (xwl_present_window->sync_callback) {
+            wl_callback_add_listener(xwl_present_window->sync_callback,
+                                     &xwl_present_sync_listener,
+                                     &event->vblank);
+        }
     }
 
     wl_display_flush(xwl_window->xwl_screen->display);
@@ -963,9 +1143,11 @@ xwl_present_acquire_fence_avail(int fd,
 {
     present_vblank_ptr vblank = data;
 
-    SetNotifyFd(fd, NULL, 0, NULL);
-    close(fd);
-    vblank->efd = -1;
+    if (vblank && vblank->efd >= 0) {
+        SetNotifyFd(vblank->efd, NULL, 0, NULL);
+        close(vblank->efd);
+        vblank->efd = -1;
+    }
 
     xwl_present_re_execute(vblank);
 }
@@ -978,16 +1160,22 @@ xwl_present_wait_acquire_fence_avail(str
 #if defined(XWL_HAS_GLAMOR) && defined(DRI3)
     /* If the compositor does not support explicit sync we need to wait for the
      * acquire fence to be submitted before flipping. */
-    if (vblank->flip && !xwl_screen->explicit_sync &&
+    if (vblank && vblank->flip && xwl_screen && !xwl_screen->explicit_sync &&
         vblank->pixmap && vblank->acquire_syncobj &&
-        !vblank->acquire_syncobj->has_fence(vblank->acquire_syncobj,
-                                            vblank->acquire_point)) {
-        vblank->efd = eventfd(0, EFD_CLOEXEC);
-        SetNotifyFd(vblank->efd, xwl_present_acquire_fence_avail, X_NOTIFY_READ, vblank);
-        vblank->acquire_syncobj->submitted_eventfd(vblank->acquire_syncobj,
-                                                   vblank->acquire_point,
-                                                   vblank->efd);
-        return TRUE;
+        vblank->acquire_syncobj->has_fence) {
+        if (!vblank->acquire_syncobj->has_fence(vblank->acquire_syncobj,
+                                                vblank->acquire_point)) {
+            vblank->efd = eventfd(0, EFD_CLOEXEC);
+            if (vblank->efd >= 0) {
+                SetNotifyFd(vblank->efd, xwl_present_acquire_fence_avail, X_NOTIFY_READ, vblank);
+                if (vblank->acquire_syncobj->submitted_eventfd) {
+                    vblank->acquire_syncobj->submitted_eventfd(vblank->acquire_syncobj,
+                                                               vblank->acquire_point,
+                                                               vblank->efd);
+                }
+                return TRUE;
+            }
+        }
     }
 #endif /* defined(XWL_HAS_GLAMOR) && defined(DRI3) */
     return FALSE;
@@ -997,10 +1185,16 @@ static void
 xwl_present_flush_blocked(struct xwl_present_window *xwl_present_window,
                           uint64_t crtc_msc)
 {
-    struct xwl_screen *xwl_screen =
-        xwl_screen_get(xwl_present_window->window->drawable.pScreen);
+    struct xwl_screen *xwl_screen;
     struct xwl_present_event *blocked_event, *tmp;
 
+    if (!xwl_present_window || !xwl_present_window->window)
+        return;
+
+    xwl_screen = xwl_screen_get(xwl_present_window->window->drawable.pScreen);
+    if (!xwl_screen)
+        return;
+
     if (!xwl_present_window->blocking_event)
         return;
 
@@ -1009,7 +1203,11 @@ xwl_present_flush_blocked(struct xwl_pre
     xorg_list_for_each_entry_safe(blocked_event, tmp,
                                   &xwl_present_window->blocked_queue,
                                   blocked) {
-        present_vblank_ptr blocked_vblank = &blocked_event->vblank;
+        present_vblank_ptr blocked_vblank;
+        if (!blocked_event)
+            continue;
+
+        blocked_vblank = &blocked_event->vblank;
         xorg_list_del(&blocked_event->blocked);
         if (present_execute_wait(blocked_vblank, crtc_msc) ||
             xwl_present_wait_acquire_fence_avail(xwl_screen, blocked_vblank)) {
@@ -1033,16 +1231,32 @@ xwl_present_flush_blocked(struct xwl_pre
 static void
 xwl_present_execute(present_vblank_ptr vblank, uint64_t ust, uint64_t crtc_msc)
 {
-    WindowPtr               window = vblank->window;
-    struct xwl_present_window *xwl_present_window = xwl_present_window_get_priv(window);
-    present_vblank_ptr flip_pending = xwl_present_get_pending_flip(xwl_present_window);
-    struct xwl_present_event *event = xwl_present_event_from_vblank(vblank);
-    struct xwl_screen *xwl_screen = xwl_screen_get(window->drawable.pScreen);
-    Bool notify_only = !vblank->window || !vblank->pixmap;
+    WindowPtr               window;
+    struct xwl_present_window *xwl_present_window;
+    present_vblank_ptr flip_pending;
+    struct xwl_present_event *event;
+    struct xwl_screen *xwl_screen;
+    Bool notify_only;
+
+    if (!vblank)
+        return;
+
+    window = vblank->window;
+    if (!window)
+        return;
+
+    xwl_present_window = xwl_present_window_get_priv(window);
+    if (!xwl_present_window)
+        return;
+
+    flip_pending = xwl_present_get_pending_flip(xwl_present_window);
+    event = xwl_present_event_from_vblank(vblank);
+    xwl_screen = xwl_screen_get(window->drawable.pScreen);
+    notify_only = !vblank->window || !vblank->pixmap;
 
     xorg_list_del(&vblank->event_queue);
 
-    if (!notify_only && !event->copy_executed &&
+    if (!notify_only && event && !event->copy_executed &&
         xwl_present_window->blocking_event &&
         xwl_present_window->blocking_event != event->vblank.event_id) {
         /* an earlier request is blocking execution */
@@ -1053,7 +1267,7 @@ xwl_present_execute(present_vblank_ptr v
 retry:
     if (present_execute_wait(vblank, crtc_msc) ||
         xwl_present_wait_acquire_fence_avail(xwl_screen, vblank)) {
-        if (!notify_only)
+        if (!notify_only && event)
             /* block execution of subsequent requests until this request is ready */
             xwl_present_window->blocking_event = event->vblank.event_id;
         return;
@@ -1068,7 +1282,7 @@ retry:
         /* Do mailbox handling for queued flips, to prevent the flip queue from
          * growing unbounded.
          */
-        if (flip_queued_last != flip_pending &&
+        if (flip_queued_last && flip_queued_last != flip_pending &&
             (flip_queued_last->sync_flip
 #ifdef DRI3
              || vblank->acquire_syncobj
@@ -1087,7 +1301,7 @@ retry:
 
     vblank->queued = FALSE;
 
-    if (!notify_only && !event->copy_executed) {
+    if (!notify_only && event && !event->copy_executed) {
         ScreenPtr screen = window->drawable.pScreen;
         int ret;
 
@@ -1096,36 +1310,45 @@ retry:
 
             DebugPresent(("\tf %" PRIu64 " %p %" PRIu64 ": %08" PRIx32 " -> %08" PRIx32 "\n",
                           vblank->event_id, vblank, crtc_msc,
-                          vblank->pixmap->drawable.id, vblank->window->drawable.id));
+                          vblank->pixmap ? vblank->pixmap->drawable.id : 0,
+                          vblank->window ? vblank->window->drawable.id : 0));
 
             /* Set update region as damaged */
             if (vblank->update) {
                 damage = RegionDuplicate(vblank->update);
-                /* Translate update region to screen space */
-                assert(vblank->x_off == 0 && vblank->y_off == 0);
-                RegionTranslate(damage, window->drawable.x, window->drawable.y);
-                RegionIntersect(damage, damage, &window->clipList);
-            } else
+                if (damage) {
+                    /* Translate update region to screen space */
+                    assert(vblank->x_off == 0 && vblank->y_off == 0);
+                    RegionTranslate(damage, window->drawable.x, window->drawable.y);
+                    RegionIntersect(damage, damage, &window->clipList);
+                }
+            } else {
                 damage = RegionDuplicate(&window->clipList);
+            }
 
-            if (xwl_present_flip(vblank, damage)) {
+            if (damage && xwl_present_flip(vblank, damage)) {
                 WindowPtr toplvl_window = xwl_present_toplvl_pixmap_window(vblank->window);
                 struct xwl_window *xwl_window = xwl_window_from_window(window);
                 PixmapPtr old_pixmap = screen->GetWindowPixmap(window);
 
                 /* Replace window pixmap with flip pixmap */
 #ifdef COMPOSITE
-                vblank->pixmap->screen_x = old_pixmap->screen_x;
-                vblank->pixmap->screen_y = old_pixmap->screen_y;
+                if (old_pixmap && vblank->pixmap) {
+                    vblank->pixmap->screen_x = old_pixmap->screen_x;
+                    vblank->pixmap->screen_y = old_pixmap->screen_y;
+                }
 #endif
-                present_set_tree_pixmap(toplvl_window, old_pixmap, vblank->pixmap);
+                if (toplvl_window)
+                    present_set_tree_pixmap(toplvl_window, old_pixmap, vblank->pixmap);
 
                 if (toplvl_window == screen->root &&
                     screen->GetScreenPixmap(screen) == old_pixmap)
                     screen->SetScreenPixmap(vblank->pixmap);
 
-                vblank->pixmap->refcnt++;
-                dixDestroyPixmap(old_pixmap, old_pixmap->drawable.id);
+                if (vblank->pixmap)
+                    vblank->pixmap->refcnt++;
+                if (old_pixmap)
+                    dixDestroyPixmap(old_pixmap, old_pixmap->drawable.id);
 
                 /* Report damage, let damage_report ignore it though */
                 xwl_screen->ignore_damage = TRUE;
@@ -1136,9 +1359,11 @@ retry:
                 /* Clear damage region, to ensure damage_report is called before
                  * any drawing to the window
                  */
-                xwl_window_buffer_add_damage_region(xwl_window);
-                RegionEmpty(xwl_window_get_damage_region(xwl_window));
-                xorg_list_del(&xwl_window->link_damage);
+                if (xwl_window) {
+                    xwl_window_buffer_add_damage_region(xwl_window);
+                    RegionEmpty(xwl_window_get_damage_region(xwl_window));
+                    xorg_list_del(&xwl_window->link_damage);
+                }
 
                 /* Put pending flip at the flip queue head */
                 xorg_list_add(&vblank->event_queue, &xwl_present_window->flip_queue);
@@ -1150,12 +1375,18 @@ retry:
                 return;
             }
 
+            if (damage)
+                RegionDestroy(damage);
+
             vblank->flip = FALSE;
             /* re-execute, falling through to copy */
             goto retry;
         }
+
         DebugPresent(("\tc %p %" PRIu64 ": %08" PRIx32 " -> %08" PRIx32 "\n",
-                      vblank, crtc_msc, vblank->pixmap->drawable.id, vblank->window->drawable.id));
+                      vblank, crtc_msc,
+                      vblank->pixmap ? vblank->pixmap->drawable.id : 0,
+                      vblank->window ? vblank->window->drawable.id : 0));
 
         if (flip_pending)
             flip_pending->abort_flip = TRUE;
@@ -1166,7 +1397,8 @@ retry:
         assert(!vblank->queued);
 
         /* Set the copy_executed field, so this will fall through to present_execute_post next time */
-        event->copy_executed = TRUE;
+        if (event)
+            event->copy_executed = TRUE;
 
         ret = xwl_present_queue_vblank(screen, window, vblank->crtc,
                                        vblank->event_id, crtc_msc + 1);
@@ -1204,39 +1436,64 @@ xwl_present_pixmap(WindowPtr window,
                    present_notify_ptr notifies,
                    int num_notifies)
 {
-    static uint64_t xwl_present_event_id;
+    static uint64_t xwl_present_event_id = 0;
     uint64_t                    ust = 0;
     uint64_t                    target_msc;
     uint64_t                    crtc_msc = 0;
     int                         ret;
     present_vblank_ptr          vblank;
-    ScreenPtr                   screen = window->drawable.pScreen;
-    present_window_priv_ptr     window_priv = present_get_window_priv(window, TRUE);
-    present_screen_priv_ptr     screen_priv = present_screen_priv(screen);
-    struct xwl_screen          *xwl_screen = xwl_screen_get(screen_priv->pScreen);
-    uint32_t                    caps = xwl_screen->present_capabilities;
+    ScreenPtr                   screen;
+    present_window_priv_ptr     window_priv;
+    present_screen_priv_ptr     screen_priv;
+    struct xwl_screen          *xwl_screen;
+    uint32_t                    caps;
     struct xwl_present_event *event;
 
+    if (!window)
+        return BadValue;
+
+    screen = window->drawable.pScreen;
+    if (!screen)
+        return BadValue;
+
+    window_priv = present_get_window_priv(window, TRUE);
     if (!window_priv)
         return BadAlloc;
 
 #ifdef DRI3
+    screen_priv = present_screen_priv(screen);
+    if (!screen_priv)
+        return BadImplementation;
+
+    xwl_screen = xwl_screen_get(screen_priv->pScreen);
+    if (!xwl_screen)
+        return BadImplementation;
+
+    caps = xwl_screen->present_capabilities;
+
     if (!(caps & PresentCapabilitySyncobj) &&
         (acquire_syncobj || release_syncobj))
         return BadValue;
+#else
+    screen_priv = present_screen_priv(screen);
+    if (!screen_priv)
+        return BadImplementation;
+    xwl_screen = xwl_screen_get(screen_priv->pScreen);
+    if (!xwl_screen)
+        return BadImplementation;
+    caps = xwl_screen->present_capabilities;
 #endif /* DRI3 */
 
     target_crtc = xwl_present_get_crtc(screen_priv, window);
 
     ret = xwl_present_get_ust_msc(screen, window, &ust, &crtc_msc);
+    if (ret != Success)
+        return ret;
 
     xwl_present_update_window_crtc(window_priv, target_crtc, crtc_msc);
 
-    if (ret == Success) {
-        /* Stash the current MSC away in case we need it later
-         */
-        window_priv->msc = crtc_msc;
-    }
+    /* Stash the current MSC away in case we need it later */
+    window_priv->msc = crtc_msc;
 
     target_msc = present_get_target_msc(target_window_msc + window_priv->msc_offset,
                                         crtc_msc,
@@ -1255,7 +1512,7 @@ xwl_present_pixmap(WindowPtr window,
                              acquire_syncobj, release_syncobj, acquire_point, release_point,
 #endif /* DRI3 */
                              options, caps, notifies, num_notifies, target_msc, crtc_msc)) {
-        present_vblank_destroy(vblank);
+        free(event);
         return BadAlloc;
     }
 
@@ -1280,6 +1537,9 @@ xwl_present_pixmap(WindowPtr window,
 void
 xwl_present_unrealize_window(struct xwl_present_window *xwl_present_window)
 {
+    if (!xwl_present_window)
+        return;
+
     /* The pending frame callback may never be called, so drop it and shorten
      * the frame timer interval.
      */
@@ -1296,6 +1556,9 @@ xwl_present_maybe_redirect_window(Window
     struct xwl_present_window *xwl_present_window = xwl_present_window_get_priv(window);
     struct xwl_window *xwl_window = xwl_window_from_window(window);
 
+    if (!xwl_present_window || !xwl_window)
+        return FALSE;
+
     if (xwl_present_window->redirect_failed)
         return FALSE;
 
@@ -1327,10 +1590,13 @@ unredirect_window(OsTimerPtr timer, CARD
     WindowPtr window = arg;
     struct xwl_present_window *xwl_present_window = xwl_present_window_get_priv(window);
 
-    compUnredirectWindow(serverClient, window, CompositeRedirectManual);
-    xwl_present_window->redirected = FALSE;
+    if (xwl_present_window && xwl_present_window->redirected) {
+        compUnredirectWindow(serverClient, window, CompositeRedirectManual);
+        xwl_present_window->redirected = FALSE;
+    }
 
-    xwl_present_window->unredirect_timer = NULL;
+    if (xwl_present_window)
+        xwl_present_window->unredirect_timer = NULL;
     return 0;
 }
 
@@ -1359,15 +1625,18 @@ xwl_present_window_redirected(WindowPtr
 {
     struct xwl_present_window *xwl_present_window = xwl_present_window_get_priv(window);
 
-    return xwl_present_window->redirected;
+    return xwl_present_window ? xwl_present_window->redirected : FALSE;
 }
 
 Bool
 xwl_present_init(ScreenPtr screen)
 {
-    struct xwl_screen *xwl_screen = xwl_screen_get(screen);
+    struct xwl_screen *xwl_screen;
     present_screen_priv_ptr screen_priv;
 
+    if (!screen)
+        return FALSE;
+
     if (!present_screen_register_priv_keys())
         return FALSE;
 
@@ -1381,6 +1650,10 @@ xwl_present_init(ScreenPtr screen)
     if (!dixRegisterPrivateKey(&xwl_present_window_private_key, PRIVATE_WINDOW, 0))
         return FALSE;
 
+    xwl_screen = xwl_screen_get(screen);
+    if (!xwl_screen)
+        return FALSE;
+
     xwl_screen->present_capabilities = XWL_PRESENT_CAPS;
 #ifdef XWL_HAS_GLAMOR
     if (xwl_glamor_supports_syncobjs(xwl_screen))
