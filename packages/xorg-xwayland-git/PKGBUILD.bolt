# Maintainer: Super Genius CachyOS Maintainer
pkgname=xorg-xwayland-git
pkgver=24.1.8.r3.g810fa6854
pkgrel=3
pkgdesc='Run X clients under Wayland (git, PGO/CS-PGO with optional BOLT; tuned for real GPU)'
arch=('x86_64')
url='https://xorg.freedesktop.org'
license=('MIT' 'X11')
groups=('xorg')

depends=(
  glibc libxau libxfont2 libxcvt libxshmfence libdrm libepoxy libglvnd
  libei libtirpc mesa nettle pixman systemd-libs wayland xorg-server-common
)
makedepends=(
  git meson clang llvm xorgproto xtrans libxkbfile dbus
  xorg-font-util wayland-protocols systemd
  weston mesa-demos glmark2
  xorg-x11perf xorg-xrandr xorg-xprop xorg-xdpyinfo xclip
  # Optional: llvm-bolt (if present, BOLT step will run; otherwise skipped)
)

provides=(xorg-xwayland xorg-server-xwayland xorg-server-xwayland-git)
conflicts=(xorg-xwayland xorg-server-xwayland xorg-server-xwayland-git)
replaces=(xorg-server-xwayland-git)

source=(
  'xserver::git+https://gitlab.freedesktop.org/xorg/xserver.git#branch=xwayland-24.1'
)
sha256sums=('SKIP')

##############################################################################
# Extra instrumentation flags – append only; do not alter user CFLAGS/CXXFLAGS
##############################################################################
_extra_instr='-g3 -fno-omit-frame-pointer -Xclang -mllvm -Xclang -vp-counters-per-site=150 -Xclang -mllvm -Xclang -runtime-counter-relocation -Xclang -mllvm -Xclang -enable-value-profiling'

##############################################################################
# Meson feature options (shared by all passes)
# Note: xwayland-24.1 builds Xwayland; do not pass legacy component toggles.
##############################################################################
_meson_opts=(
  -Db_ndebug=true
  -Db_pie=false
  -Db_lto=false
  -Dc_std=gnu2x
  -Dcpp_std=gnu++2a
  --wrap-mode=nofallback

  -Dipv6=true
  -Ddri3=true
  -Dglamor=true

  -Dxkb_dir=/usr/share/X11/xkb
  -Dxkb_output_dir=/var/lib/xkb
)

pkgver() {
  cd xserver
  git fetch --tags --quiet || true
  local tag revs
  if tag=$(git describe --abbrev=0 --tags --match 'xwayland-*' 2>/dev/null); then
    revs=$(git rev-list "${tag}..HEAD" --count)
    printf '%s.r%s.g%s' "${tag#xwayland-}" "$revs" "$(git rev-parse --short HEAD)"
  else
    printf '0.0.0.r%s.g%s' "$(git rev-list --count HEAD)" "$(git rev-parse --short HEAD)"
  fi
}

prepare() {
  cd xserver
  # Apply any .patch files present in source=()
  for src in "${source[@]}"; do
    src="${src%%::*}"
    src="${src##*/}"
    [[ $src = *.patch ]] || continue
    echo "Applying patch: $src"
    patch -Np1 -i "../${src}"
  done
}

##############################################################################
# Utilities for robust, reproducible training workload
##############################################################################
# If you are already in a Wayland session (e.g. KWin/Wayland), reuse it.
# Otherwise, start a headless Weston compositor.
_start_headless_weston() {
  if [[ -n ${WAYLAND_DISPLAY:-} && -S ${XDG_RUNTIME_DIR:-/run/user/$(id -u)}/$WAYLAND_DISPLAY ]]; then
    WESTON_PID=''
    echo "Wayland compositor detected (${WAYLAND_DISPLAY}); not starting headless weston."
    return 0
  fi

  if ! command -v weston >/dev/null 2>&1; then
    echo "No Wayland compositor and weston unavailable; training may fail."
    return 1
  fi

  local my_xdg="$srcdir/.xdg-runtime"
  mkdir -p "$my_xdg"
  chmod 700 "$my_xdg"
  export XDG_RUNTIME_DIR="$my_xdg"

  local socket="cachy-xw-pgo-$$"
  export WAYLAND_DISPLAY="$socket"

  echo "Starting headless weston for training (socket: $socket)..."
  dbus-run-session -- \
    sh -c 'weston --backend=headless --socket='"$socket"' --idle-time=0 --renderer=gl >/dev/null 2>&1 || weston --backend=headless-backend.so --socket='"$socket"' --idle-time=0 --renderer=gl >/dev/null 2>&1' &
  WESTON_PID=$!

  local sock="${XDG_RUNTIME_DIR}/${WAYLAND_DISPLAY}"
  for _ in {1..100}; do
    [[ -S $sock ]] && return 0
    sleep 0.1
  done

  echo "Headless weston failed to start."
  kill "$WESTON_PID" 2>/dev/null || true
  WESTON_PID=''
  return 1
}

# Start Xwayland (rootful) on the current Wayland compositor and export DISPLAY.
_start_xwayland() {      # $1 = absolute path to built Xwayland
  local xway="$1"
  local disp_file
  disp_file=$(mktemp -u --tmpdir xw-disp-XXXX)

  echo "Launching training Xwayland instance..."
  "$xway" :77 -noreset -terminate -displayfd 3 3>"$disp_file" >/dev/null 2>&1 &
  XWAY_PID=$!

  for _ in {1..100}; do [[ -s $disp_file ]] && break; sleep 0.1; done
  if [[ ! -s $disp_file ]]; then
    echo "Xwayland failed to report DISPLAY"
    kill "$XWAY_PID" 2>/dev/null || true
    rm -f "$disp_file"
    XWAY_PID=''
    return 1
  fi
  read -r dpy < "$disp_file"
  export DISPLAY=":$dpy"
  rm -f "$disp_file"
  echo "Training DISPLAY is $DISPLAY"
  return 0
}

# Warn if software renderer is in use; continue anyway.
_check_hw_renderer() {
  if ! command -v glxinfo >/dev/null 2>&1; then
    echo "glxinfo not available; skipping renderer check."
    return 0
  fi
  local info
  info=$(glxinfo -B 2>/dev/null | sed -nE 's/^\s*(OpenGL renderer string|Device):\s*(.*)$/\2/p' | head -n1)
  if [[ -z "$info" ]]; then
    echo "Warning: could not determine OpenGL renderer; profiling anyway."
    return 0
  fi
  case "${info,,}" in
    *llvmpipe*|*swrast*|*softpipe*|*software*)
      echo "Warning: Software renderer detected (${info}). Profiles may be low quality."
      ;;
    *)
      echo "Using renderer: $info"
      ;;
  esac
}

# Balanced, typical desktop/gaming workload (time-bounded, comprehensive)
_run_workload() {        # $1 = absolute path to Xwayland to run
  local xway_path="$1"

  # Prefer using the existing compositor (KWin/etc.); otherwise start headless weston
  local WESTON_PID=''
  _start_headless_weston || true

  local XWAY_PID=''
  _start_xwayland "$xway_path" || { echo "Training could not start Xwayland"; return 1; }

  _check_hw_renderer

  # helper to run with a hard timeout
  _rt() { local t="$1"; shift; timeout -k 2 "$t" "$@" >/dev/null 2>&1 || true; }

  echo "PGO/BOLT training: running scenes and queries..."
  # GL Present/vblank path
  if command -v glxgears >/dev/null 2>&1; then
    _rt 8 env vblank_mode=1 glxgears -fullscreen
  fi

  # glmark2 curated scenes (~20–25s total)
  if command -v glmark2 >/dev/null 2>&1; then
    local scenes=(
      "build:use-vbo=false:duration=2500"
      "build:use-fbo=true:duration=2500"
      "jellyfish:duration=2500"
      "shadow:duration=2500"
      "terrain:duration=2500"
      "shading:shading=phong:duration=2500"
    )
    for sc in "${scenes[@]}"; do
      echo " - glmark2 scene: $sc"
      _rt 6 glmark2 --size 1280x720 -b "$sc"
    done
  else
    echo "glmark2 not available; minimal fallback load."
    sleep 5
  fi

  # Core protocol and RandR/atoms/clipboard
  _rt 4 xdpyinfo -ext all
  _rt 3 xrandr --query
  _rt 3 xprop -root
  echo 'xw-pgo-clipboard' | _rt 2 xclip -selection clipboard
  _rt 2 xclip -o -selection clipboard

  # GLX queries
  if command -v glxinfo >/dev/null 2>&1; then
    _rt 3 glxinfo -B
    _rt 3 glxinfo -l
  fi

  # Graceful shutdown to flush profiles
  for _ in {1..30}; do
    kill -0 "$XWAY_PID" 2>/dev/null || { XWAY_PID=''; break; }
    sleep 0.1
  done
  if [[ -n "$XWAY_PID" ]]; then
    kill -INT "$XWAY_PID" 2>/dev/null || true
    for _ in {1..30}; do
      kill -0 "$XWAY_PID" 2>/dev/null || { XWAY_PID=''; break; }
      sleep 0.1
    done
  fi
  if [[ -n "$XWAY_PID" ]]; then
    kill -TERM "$XWAY_PID" 2>/dev/null || true
    wait "$XWAY_PID" 2>/dev/null || true
    XWAY_PID=''
  fi

  if [[ -n "$WESTON_PID" ]]; then
    kill "$WESTON_PID" 2>/dev/null || true
    wait "$WESTON_PID" 2>/dev/null || true
  fi
  echo "Training workload completed."
}

##############################################################################
# Three-pass build: PGO → CS-PGO → Final, with optional BOLT post-link
##############################################################################
build() {
  export CC=clang
  export CXX=clang++

  # Preserve user flags for composition (we pass them via -D* only)
  local U_CFLAGS="$CFLAGS"
  local U_CXXFLAGS="$CXXFLAGS"
  local U_LDFLAGS="$LDFLAGS"

  # Detect CS-PGO support
  local HAVE_CS=0
  clang --help 2>/dev/null | grep -q -- '-fcs-profile-generate' && HAVE_CS=1

  local gen_dir="$srcdir/pgo-gen"
  local cs_dir="$srcdir/pgo-cs"
  mkdir -p "$gen_dir" "$cs_dir"

  cd xserver

  # ---------- PASS 1 : PGO profile-generate --------------------------------
  echo "PASS 1: Building with PGO instrumentation..."
  local c_gen="$U_CFLAGS $_extra_instr -fprofile-generate=$gen_dir"
  local link_gen="$U_LDFLAGS -fprofile-generate=$gen_dir"
  CFLAGS='' CXXFLAGS='' LDFLAGS='' \
  arch-meson . build-gen "${_meson_opts[@]}" --buildtype=release \
    -Dc_args="$c_gen" -Dcpp_args="$c_gen" \
    -Dc_link_args="$link_gen" -Dcpp_link_args="$link_gen"
  ninja -C build-gen

  echo "PASS 1: Running training workload..."
  LLVM_PROFILE_FILE="$gen_dir/%p.profraw" _run_workload "$PWD/build-gen/hw/xwayland/Xwayland"

  if compgen -G "$gen_dir"/*.profraw >/dev/null; then
    echo "PASS 1: Merging profiles..."
    llvm-profdata merge -o "$srcdir/gen.prof" "$gen_dir"/*.profraw
  else
    echo "PASS 1: No profiles collected; continuing without profile-use."
    : > "$srcdir/gen.prof" || true
  fi

  # ---------- PASS 2 : profile-use + CS profile-generate (if supported) ----
  echo "PASS 2: Building with profile-use and CS instrumentation..."
  local c_cs="$U_CFLAGS $_extra_instr"
  local link_cs="$U_LDFLAGS"
  [[ -s "$srcdir/gen.prof" ]] && { c_cs+=" -fprofile-use=$srcdir/gen.prof"; link_cs+=" -fprofile-use=$srcdir/gen.prof"; }
  if [[ $HAVE_CS -eq 1 ]]; then
    c_cs+=" -fcs-profile-generate=$cs_dir"
    link_cs+=" -fcs-profile-generate=$cs_dir"
  else
    echo "PASS 2: CS-PGO not supported by clang; building without CS instrumentation."
  fi

  CFLAGS='' CXXFLAGS='' LDFLAGS='' \
  arch-meson . build-cs "${_meson_opts[@]}" --buildtype=release \
    -Dc_args="$c_cs" -Dcpp_args="$c_cs" \
    -Dc_link_args="$link_cs" -Dcpp_link_args="$link_cs"
  ninja -C build-cs

  echo "PASS 2: Running training workload..."
  LLVM_PROFILE_FILE="$cs_dir/%p.profraw" _run_workload "$PWD/build-cs/hw/xwayland/Xwayland"

  if compgen -G "$cs_dir"/*.profraw >/dev/null; then
    echo "PASS 2: Merging CS profiles with base..."
    llvm-profdata merge -o "$srcdir/final.prof" "$cs_dir"/*.profraw "$srcdir/gen.prof"
  elif [[ -s "$srcdir/gen.prof" ]]; then
    cp -f "$srcdir/gen.prof" "$srcdir/final.prof"
  else
    : > "$srcdir/final.prof" || true
  fi

  # ---------- PASS 3 : final profile-use (PGO + CS-PGO) ---------------------
  echo "PASS 3: Building final optimized binary with merged profiles..."
  local c_fin="$U_CFLAGS"
  local link_fin="$U_LDFLAGS"
  if [[ -s "$srcdir/final.prof" ]]; then
    c_fin+=" -fprofile-use=$srcdir/final.prof"
    link_fin+=" -fprofile-use=$srcdir/final.prof"
  fi

  local link_fin_bolt="$link_fin"
  if command -v llvm-bolt >/dev/null 2>&1; then
    link_fin_bolt+=" -Wl,--emit-relocs"
  fi

  CFLAGS='' CXXFLAGS='' LDFLAGS='' \
  arch-meson . build-final "${_meson_opts[@]}" --buildtype=release \
    -Dc_args="$c_fin" -Dcpp_args="$c_fin" \
    -Dc_link_args="$link_fin_bolt" -Dcpp_link_args="$link_fin_bolt"
  ninja -C build-final

  # ---------- Optional: BOLT post-link optimization -------------------------
  if command -v llvm-bolt >/dev/null 2>&1; then
    echo "BOLT detected: performing post-link instrumentation and optimization..."
    local xway_in="$PWD/build-final/hw/xwayland/Xwayland"
    local bolt_dir="$srcdir/bolt"
    mkdir -p "$bolt_dir"
    cp -f "$xway_in" "$bolt_dir/Xwayland.orig"

    # Instrument (relocation mode, lite, append-pid)
    rm -f "$bolt_dir/xway.fdata" "$bolt_dir"/xway.fdata.*
    if ! llvm-bolt "$xway_in" \
      --relocs \
      --lite \
      --instrument \
      --instrumentation-file="$bolt_dir/xway.fdata" \
      --instrumentation-file-append-pid \
      -o "$bolt_dir/Xwayland.inst"; then
      echo "BOLT instrumentation failed; skipping BOLT step."
      return 0
    fi

    # Train instrumented binary (reuse workload; uses current Wayland if present)
    BOLT_INSTRUMENTATION_FILE="$bolt_dir/xway.fdata" \
    BOLT_INSTRUMENTATION_FILE_APPEND_PID=1 \
      _run_workload "$bolt_dir/Xwayland.inst"

    # Merge fdata shards if any
    local merged="$bolt_dir/xway.merged.fdata"
    if compgen -G "$bolt_dir/xway.fdata".* >/dev/null; then
      if command -v merge-fdata >/dev/null 2>&1; then
        merge-fdata "$bolt_dir/xway.fdata".* -o "$merged" || true
      else
        cat "$bolt_dir/xway.fdata".* > "$merged" || true
      fi
    elif [[ -s "$bolt_dir/xway.fdata" ]]; then
      cp -f "$bolt_dir/xway.fdata" "$merged"
    else
      merged=""
    fi

    if [[ -n "$merged" && -s "$merged" ]]; then
      # Build optimization flags compatible with multiple llvm-bolt versions
      local bolt_help; bolt_help="$(llvm-bolt --help 2>&1 || true)"
      local bolt_align_flags=(--align-blocks)
      grep -q -- '--block-alignment' <<<"$bolt_help" && bolt_align_flags=(--align-blocks --block-alignment=32)

      # Optimize original binary using collected data
      if ! llvm-bolt "$bolt_dir/Xwayland.orig" \
            --relocs \
            --data="$merged" \
            --reorder-blocks=ext-tsp \
            --reorder-functions=cdsort \
            --split-functions \
            --split-strategy=cdsplit \
            --icf=all \
            --jump-tables=move \
            --peepholes=all \
            "${bolt_align_flags[@]}" \
            --dyno-stats \
            -o "$bolt_dir/Xwayland.bolt"; then
        echo "BOLT optimization failed; skipping."
        return 0
      fi

      # Replace the build artifact so packaging picks up the optimized binary
      install -m755 "$bolt_dir/Xwayland.bolt" "$PWD/build-final/hw/xwayland/Xwayland"
      echo "BOLT optimization applied."
    else
      echo "BOLT: no profile produced; skipping optimization."
    fi
  else
    echo "llvm-bolt not found; skipping BOLT step."
  fi
}

##############################################################################
# package
##############################################################################
package() {
  DESTDIR="$pkgdir" ninja -C xserver/build-final install

  # Trim irrelevant bits for the Xwayland-only package
  rm -f "$pkgdir/usr/lib/xorg/protocol.txt" \
        "$pkgdir/usr/share/man/man1/Xserver.1" 2>/dev/null || true
  rmdir --ignore-fail-on-non-empty "$pkgdir/usr/lib/xorg" 2>/dev/null || true

  install -Dm644 xserver/COPYING \
          "$pkgdir/usr/share/licenses/$pkgname/COPYING"
}

# vim: ts=2 sw=2 et
