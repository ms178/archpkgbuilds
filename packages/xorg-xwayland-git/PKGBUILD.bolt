# Maintainer: Super Genius CachyOS Maintainer
pkgname=xorg-xwayland-git
pkgver=24.1.8.r3.g810fa6854
pkgrel=1
pkgdesc='Run X clients under Wayland (git, PGO/CS-PGO with optional BOLT; tuned for real GPU)'
arch=('x86_64')
url='https://xorg.freedesktop.org'
license=('MIT' 'X11')
groups=('xorg')

depends=(
  glibc libxau libxfont2 libxcvt libxshmfence libdrm libepoxy libglvnd
  libei libtirpc mesa nettle pixman systemd-libs wayland xorg-server-common
)
makedepends=(
  git meson clang llvm xorgproto xtrans libxkbfile dbus
  xorg-font-util wayland-protocols systemd
  weston mesa-demos glmark2
  # Optional: llvm-bolt (if present, BOLT step will run; otherwise skipped)
)

provides=(xorg-xwayland xorg-server-xwayland xorg-server-xwayland-git)
conflicts=(xorg-xwayland xorg-server-xwayland xorg-server-xwayland-git)
replaces=(xorg-server-xwayland-git)

source=(
  'xserver::git+https://gitlab.freedesktop.org/xorg/xserver.git#branch=xwayland-24.1'
)
sha256sums=('SKIP')

##############################################################################
# Extra instrumentation flags – append only; do not alter user CFLAGS/CXXFLAGS
##############################################################################
_extra_instr='-g3 -fno-omit-frame-pointer -Xclang -mllvm -Xclang -vp-counters-per-site=150 -Xclang -mllvm -Xclang -runtime-counter-relocation -Xclang -mllvm -Xclang -enable-value-profiling'

##############################################################################
# Meson feature options (shared by all passes)
# Note: xwayland-24.1 builds Xwayland; do not pass legacy component toggles.
##############################################################################
_meson_opts=(
  -Db_ndebug=true
  -Db_pie=false
  -Db_lto=false
  -Dc_std=gnu2x
  -Dcpp_std=gnu++2a
  --wrap-mode=nofallback

  -Dipv6=true
  -Ddri3=true
  -Dglamor=true

  -Dxkb_dir=/usr/share/X11/xkb
  -Dxkb_output_dir=/var/lib/xkb
)

pkgver() {
  cd xserver
  git fetch --tags --quiet || true
  local tag revs
  tag=$(git describe --abbrev=0 --tags --match 'xwayland-*')
  revs=$(git rev-list "${tag}..HEAD" --count)
  printf '%s.r%s.g%s' "${tag#xwayland-}" "$revs" "$(git rev-parse --short HEAD)"
}

prepare() {
  cd xserver
  # Apply any .patch files present in source=()
  for src in "${source[@]}"; do
    src="${src%%::*}"
    src="${src##*/}"
    [[ $src = *.patch ]] || continue
    patch -Np1 -i "../${src}"
  done
}

##############################################################################
# Utilities for robust, reproducible training workload
##############################################################################
# If you are already in a Wayland session (e.g. KWin/Wayland), reuse it.
# Otherwise, start a headless Weston compositor.
_start_headless_weston() {
  if [[ -n ${WAYLAND_DISPLAY:-} && -S ${XDG_RUNTIME_DIR:-/run/user/$(id -u)}/$WAYLAND_DISPLAY ]]; then
    WESTON_PID=''
    echo "Wayland compositor detected (${WAYLAND_DISPLAY}); not starting headless weston."
    return 0
  fi

  if ! command -v weston >/dev/null 2>&1; then
    echo "No Wayland compositor and weston unavailable; training may fail."
    return 1
  fi

  local my_xdg="$srcdir/.xdg-runtime"
  mkdir -p "$my_xdg"
  chmod 700 "$my_xdg"
  export XDG_RUNTIME_DIR="$my_xdg"

  local socket="cachy-xw-pgo-$$"
  export WAYLAND_DISPLAY="$socket"

  echo "Starting headless weston for training (socket: $socket)..."
  dbus-run-session -- \
    sh -c 'weston --backend=headless --socket='"$socket"' --idle-time=0 --renderer=gl >/dev/null 2>&1 || weston --backend=headless-backend.so --socket='"$socket"' --idle-time=0 --renderer=gl >/dev/null 2>&1' &
  WESTON_PID=$!

  local sock="${XDG_RUNTIME_DIR}/${WAYLAND_DISPLAY}"
  for _ in {1..100}; do
    [[ -S $sock ]] && return 0
    sleep 0.1
  done

  echo "Headless weston failed to start."
  kill "$WESTON_PID" 2>/dev/null || true
  WESTON_PID=''
  return 1
}

# Start Xwayland (rootful) on the current Wayland compositor and export DISPLAY.
_start_xwayland() {      # $1 = absolute path to built Xwayland
  local xway="$1"
  local disp_file
  disp_file=$(mktemp -u --tmpdir xw-disp-XXXX)

  echo "Launching training Xwayland instance..."
  "$xway" :77 -noreset -terminate -displayfd 3 3>"$disp_file" >/dev/null 2>&1 &
  XWAY_PID=$!

  for _ in {1..100}; do [[ -s $disp_file ]] && break; sleep 0.1; done
  if [[ ! -s $disp_file ]]; then
    echo "Xwayland failed to report DISPLAY"
    kill "$XWAY_PID" 2>/dev/null || true
    rm -f "$disp_file"
    XWAY_PID=''
    return 1
  fi
  read -r dpy < "$disp_file"
  export DISPLAY=":$dpy"
  rm -f "$disp_file"
  echo "Training DISPLAY is $DISPLAY"
  return 0
}

# Warn if software renderer is in use; continue anyway.
_check_hw_renderer() {
  if ! command -v glxinfo >/dev/null 2>&1; then
    echo "glxinfo not available; skipping renderer check."
    return 0
  fi
  local info
  info=$(glxinfo -B 2>/dev/null | sed -nE 's/^\s*(OpenGL renderer string|Device):\s*(.*)$/\2/p' | head -n1)
  if [[ -z "$info" ]]; then
    echo "Warning: could not determine OpenGL renderer; profiling anyway."
    return 0
  fi
  case "${info,,}" in
    *llvmpipe*|*swrast*|*softpipe*|*software*)
      echo "Warning: Software renderer detected (${info}). Profiles may be low quality."
      ;;
    *)
      echo "Using renderer: $info"
      ;;
  esac
}

# Balanced, typical desktop/gaming workload
_run_workload() {        # $1 = absolute path to Xwayland to run
  local xway_path="$1"

  # Prefer using the existing compositor (KWin/etc.); otherwise start headless weston
  local WESTON_PID=''
  _start_headless_weston || true

  local XWAY_PID=''
  _start_xwayland "$xway_path" || { echo "Training could not start Xwayland"; return 1; }

  _check_hw_renderer

  echo "PGO training: running glmark2 scenes..."
  local GEARS_PID=''
  if command -v glxgears >/dev/null 2>&1; then
    ( vblank_mode=1 glxgears -fullscreen >/dev/null 2>&1 & echo $! ) | { read -r GEARS_PID; }
  fi

  if command -v glmark2 >/dev/null 2>&1; then
    local scenes=(
      "build:use-vbo=false:duration=3500"
      "build:use-fbo=true:duration=3500"
      "jellyfish:duration=3500"
      "refract:duration=3500"
      "bump:duration=3500"
      "shadow:duration=3500"
      "terrain:duration=3500"
      "shading:shading=phong:duration=3500"
    )
    for sc in "${scenes[@]}"; do
      echo " - glmark2 scene: $sc"
      glmark2 --size 1280x720 -b "$sc" >/dev/null 2>&1 || true
    done
  else
    echo "glmark2 not available; using minimal fallback load."
    sleep 10
  fi

  if command -v glxinfo >/dev/null 2>&1; then
    glxinfo -B >/dev/null 2>&1 || true
    glxinfo -l >/dev/null 2>&1 || true
  fi

  # Gracefully stop clients and ensure Xwayland flushes instrumentation (if any)
  [[ -n "$GEARS_PID" ]] && { kill "$GEARS_PID" 2>/dev/null || true; wait "$GEARS_PID" 2>/dev/null || true; }

  # Give Xwayland time to auto-exit due to -terminate when last client disconnects
  for _ in {1..30}; do
    kill -0 "$XWAY_PID" 2>/dev/null || { XWAY_PID=''; break; }
    sleep 0.1
  done
  if [[ -n "$XWAY_PID" ]]; then
    # Send SIGINT to allow atexit handlers (BOLT) to flush profile
    kill -INT "$XWAY_PID" 2>/dev/null || true
    for _ in {1..30}; do
      kill -0 "$XWAY_PID" 2>/dev/null || { XWAY_PID=''; break; }
      sleep 0.1
    done
  fi
  if [[ -n "$XWAY_PID" ]]; then
    kill -TERM "$XWAY_PID" 2>/dev/null || true
    wait "$XWAY_PID" 2>/dev/null || true
    XWAY_PID=''
  fi

  if [[ -n "$WESTON_PID" ]]; then
    kill "$WESTON_PID" 2>/dev/null || true
    wait "$WESTON_PID" 2>/dev/null || true
  fi
  echo "Training workload completed."
}

##############################################################################
# Three-pass build: PGO → CS-PGO → Final, with optional BOLT post-link
##############################################################################
build() {
  export CC=clang
  export CXX=clang++

  # Preserve user flags; only append via Meson args
  local U_CFLAGS="$CFLAGS"
  local U_CXXFLAGS="$CXXFLAGS"
  local U_LDFLAGS="$LDFLAGS"

  local gen_dir="$srcdir/pgo-gen"
  local cs_dir="$srcdir/pgo-cs"
  mkdir -p "$gen_dir" "$cs_dir"

  cd xserver

  # ---------- PASS 1 : PGO profile-generate --------------------------------
  echo "PASS 1: Building with PGO instrumentation..."
  local c_gen="$U_CFLAGS $_extra_instr -fprofile-generate=$gen_dir"
  local link_gen="$U_LDFLAGS -fprofile-generate=$gen_dir"
  arch-meson . build-gen "${_meson_opts[@]}" --buildtype=release \
    -Dc_args="$c_gen" -Dcpp_args="$c_gen" \
    -Dc_link_args="$link_gen" -Dcpp_link_args="$link_gen"
  ninja -C build-gen
  echo "PASS 1: Running training workload..."
  LLVM_PROFILE_FILE="$gen_dir/%p.profraw" _run_workload "$PWD/build-gen/hw/xwayland/Xwayland"
  echo "PASS 1: Merging profiles..."
  llvm-profdata merge -o "$srcdir/gen.prof" "$gen_dir"/*.profraw

  # ---------- PASS 2 : profile-use + CS profile-generate --------------------
  echo "PASS 2: Building with profile-use and CS instrumentation..."
  local c_cs="$U_CFLAGS $_extra_instr -fprofile-use=$srcdir/gen.prof -fcs-profile-generate=$cs_dir"
  local link_cs="$U_LDFLAGS -fprofile-use=$srcdir/gen.prof -fcs-profile-generate=$cs_dir"
  arch-meson . build-cs "${_meson_opts[@]}" --buildtype=release \
    -Dc_args="$c_cs" -Dcpp_args="$c_cs" \
    -Dc_link_args="$link_cs" -Dcpp_link_args="$link_cs"
  ninja -C build-cs
  echo "PASS 2: Running training workload..."
  LLVM_PROFILE_FILE="$cs_dir/%p.profraw" _run_workload "$PWD/build-cs/hw/xwayland/Xwayland"
  echo "PASS 2: Merging CS profiles with base..."
  llvm-profdata merge -o "$srcdir/final.prof" "$cs_dir"/*.profraw "$srcdir/gen.prof"

  # ---------- PASS 3 : final profile-use (PGO + CS-PGO) ---------------------
  echo "PASS 3: Building final optimized binary with merged profiles..."
  # Important: Clang does not use a separate -fcs-profile-use; CS data is embedded in profdata.
  local c_fin="$U_CFLAGS -fprofile-use=$srcdir/final.prof"
  local link_fin="$U_LDFLAGS -fprofile-use=$srcdir/final.prof"

  # If BOLT is available, emit relocs to maximize post-link profiling quality.
  local link_fin_bolt="$link_fin"
  if command -v llvm-bolt >/dev/null 2>&1; then
    link_fin_bolt="$link_fin -Wl,--emit-relocs"
  fi

  arch-meson . build-final "${_meson_opts[@]}" --buildtype=release \
    -Dc_args="$c_fin" -Dcpp_args="$c_fin" \
    -Dc_link_args="$link_fin_bolt" -Dcpp_link_args="$link_fin_bolt"
  ninja -C build-final

  # ---------- Optional: BOLT post-link optimization -------------------------
  if command -v llvm-bolt >/dev/null 2>&1; then
    echo "BOLT detected: performing post-link instrumentation and optimization..."
    local xway_in="$PWD/build-final/hw/xwayland/Xwayland"
    local bolt_dir="$srcdir/bolt"
    mkdir -p "$bolt_dir"
    cp -f "$xway_in" "$bolt_dir/Xwayland.orig"

    # Instrument
    rm -f "$bolt_dir/boltprof.fdata"
    if ! llvm-bolt "$xway_in" \
      --instrument \
      --instrumentation-file="$bolt_dir/boltprof.fdata" \
      -o "$bolt_dir/Xwayland.inst"; then
      echo "BOLT instrumentation failed; skipping BOLT step."
      return 0
    fi

    # Train instrumented binary (reuse workload; uses current Wayland if present)
    # Also pass env override to be extra safe
    BOLT_INSTRUMENTATION_FILE="$bolt_dir/boltprof.fdata" _run_workload "$bolt_dir/Xwayland.inst"

    # Build optimization flag set compatible with multiple llvm-bolt versions
    local bolt_help
    bolt_help="$(llvm-bolt --help 2>&1 || true)"
    local bolt_align_flags=(--align-blocks)
    if grep -q -- '--block-alignment' <<<"$bolt_help"; then
      bolt_align_flags=(--align-blocks --block-alignment=32)
    fi

    # Optimize original binary using collected data
    if ! llvm-bolt "$bolt_dir/Xwayland.orig" \
          --relocs \
          --data="$bolt_dir/boltprof.fdata" \
          --reorder-blocks=ext-tsp \
          --reorder-functions=cdsort \
          --split-functions \
          --split-strategy=cdsplit \
          --icf=all \
          --jump-tables=move \
          --peepholes=all \
          "${bolt_align_flags[@]}" \
          --dyno-stats \
          -o "$bolt_dir/Xwayland.bolt"; then
      echo "BOLT optimization failed; skipping."
      return 0
    fi

    # Replace the build artifact so packaging picks up the optimized binary
    install -m755 "$bolt_dir/Xwayland.bolt" "$PWD/build-final/hw/xwayland/Xwayland"
    echo "BOLT optimization applied."
  else
    echo "llvm-bolt not found; skipping BOLT step."
  fi
}

##############################################################################
# package
##############################################################################
package() {
  DESTDIR="$pkgdir" ninja -C xserver/build-final install

  # Trim irrelevant bits for the Xwayland-only package
  rm -f "$pkgdir/usr/lib/xorg/protocol.txt" \
        "$pkgdir/usr/share/man/man1/Xserver.1" 2>/dev/null || true
  rmdir --ignore-fail-on-non-empty "$pkgdir/usr/lib/xorg" 2>/dev/null || true

  install -Dm644 xserver/COPYING \
          "$pkgdir/usr/share/licenses/$pkgname/COPYING"
}

# vim: ts=2 sw=2 et
