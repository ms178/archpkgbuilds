--- a/src/amdgpu_dri3.c	2025-05-18 12:33:11.100683313 +0200
+++ b/src/amdgpu_dri3.c	2025-05-18 12:41:32.799841439 +0200
@@ -21,277 +21,336 @@
  * OF THIS SOFTWARE.
  */
 
-
-#ifdef HAVE_CONFIG_H
-#include "config.h"
-#endif
+#define _GNU_SOURCE             /* dup3() */
+#include <fcntl.h>
+#include <errno.h>
+#include <libgen.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <unistd.h>
+#include <limits.h>
+#include <string.h>
 
 #include "amdgpu_drv.h"
-
 #ifdef HAVE_DRI3_H
+# include "dri3.h"
+#endif
 
 #include "amdgpu_glamor.h"
 #include "amdgpu_pixmap.h"
-#include "dri3.h"
 
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <fcntl.h>
-#include <gbm.h>
-#include <errno.h>
-#include <libgen.h>
+#define LIKELY(x)   __builtin_expect(!!(x), 1)
+#define UNLIKELY(x) __builtin_expect(!!(x), 0)
+
+/* Hot/Cold function layout hints (advisory to compiler) */
+#if defined(__GNUC__) || defined(__clang__)
+# ifndef AMDGPU_HOT
+#  define AMDGPU_HOT  __attribute__((hot))
+# endif
+# ifndef AMDGPU_COLD
+#  define AMDGPU_COLD __attribute__((cold))
+# endif
+#else
+# ifndef AMDGPU_HOT
+#  define AMDGPU_HOT
+# endif
+# ifndef AMDGPU_COLD
+#  define AMDGPU_COLD
+# endif
+#endif
+
+/* --------------------------------------------------------------------- */
+/* Small RAII helper so we never forget to close() on error              */
+/* --------------------------------------------------------------------- */
+struct fd_guard {
+	int fd;
+};
+static inline void fdg_init(struct fd_guard *g) { g->fd = -1; }
+static inline int  fdg_move(struct fd_guard *g) { int f = g->fd; g->fd = -1; return f; }
+static inline void fdg_disarm(struct fd_guard *g) { g->fd = -1; }
+static inline void fdg_cleanup(struct fd_guard *g)
+{
+	if (g->fd >= 0) close(g->fd);
+}
 
-static int open_card_node(ScreenPtr screen, int *out)
+/* ========== 1. Node opening helpers =================================== */
+static AMDGPU_HOT int
+open_node(const char *path, int *out)
 {
-	ScrnInfoPtr scrn = xf86ScreenToScrn(screen);
-	AMDGPUEntPtr pAMDGPUEnt = AMDGPUEntPriv(scrn);
-	AMDGPUInfoPtr info = AMDGPUPTR(scrn);
+	struct fd_guard g; fdg_init(&g);
+
+	if (UNLIKELY(!path || !out))
+		return BadValue;
+
+	g.fd = open(path, O_RDWR | O_CLOEXEC);
+	if (g.fd < 0)
+		return BadAlloc;
+
+	*out = fdg_move(&g);
+	fdg_cleanup(&g);
+	return Success;
+}
+
+/* ---------- 1a. /dev/dri/card* (master) ------------------------------- */
+static AMDGPU_HOT int
+amdgpu_open_card_node(ScreenPtr screen, int *out)
+{
+	ScrnInfoPtr   scrn   = xf86ScreenToScrn(screen);
+	AMDGPUInfoPtr info   = AMDGPUPTR(scrn);
+	AMDGPUEntPtr  ent    = AMDGPUEntPriv(scrn);
+	struct fd_guard g; fdg_init(&g);
 	drm_magic_t magic;
-	int fd;
 
-	fd = open(info->dri2.device_name, O_RDWR | O_CLOEXEC);
-	if (fd < 0)
+	/* 1) open (master) -------------------------------------------------- */
+	g.fd = open(info->dri2.device_name, O_RDWR | O_CLOEXEC);
+	if (g.fd < 0)
 		return BadAlloc;
 
-	/* Before FD passing in the X protocol with DRI3 (and increased
-	 * security of rendering with per-process address spaces on the
-	 * GPU), the kernel had to come up with a way to have the server
-	 * decide which clients got to access the GPU, which was done by
-	 * each client getting a unique (magic) number from the kernel,
-	 * passing it to the server, and the server then telling the
-	 * kernel which clients were authenticated for using the device.
-	 *
-	 * Now that we have FD passing, the server can just set up the
-	 * authentication on its own and hand the prepared FD off to the
-	 * client.
-	 */
-	if (drmGetMagic(fd, &magic) < 0) {
-		if (errno == EACCES) {
-			/* Assume that we're on a render node, and the fd is
-			 * already as authenticated as it should be.
-			 */
-			*out = fd;
+	/* 2) Check whether authentication is even necessary ---------------- */
+	if (drmGetMagic(g.fd, &magic) < 0) {
+		/* Some kernels/drivers return EACCES/EOPNOTSUPP/ENOTTY when auth is not needed */
+		if (errno == EACCES || errno == EOPNOTSUPP || errno == ENOTTY) {
+			*out = fdg_move(&g);
+			fdg_cleanup(&g);
 			return Success;
-		} else {
-			close(fd);
-			return BadMatch;
 		}
+		fdg_cleanup(&g);
+		return BadMatch;
 	}
 
-	if (drmAuthMagic(pAMDGPUEnt->fd, magic) < 0) {
-		close(fd);
+	/* 3) Authenticate the FD with the server’s already-master FD -------- */
+	if (drmAuthMagic(ent->fd, magic) < 0) {
+		fdg_cleanup(&g);
 		return BadMatch;
 	}
 
-	*out = fd;
+	*out = fdg_move(&g);
+	fdg_cleanup(&g);
 	return Success;
 }
 
-static int open_render_node(ScreenPtr screen, int *out)
+/* ---------- 1b. /dev/dri/render* -------------------------------------- */
+static AMDGPU_HOT int
+amdgpu_open_render_node(ScreenPtr screen, int *out)
 {
-	ScrnInfoPtr scrn = xf86ScreenToScrn(screen);
-	AMDGPUEntPtr pAMDGPUEnt = AMDGPUEntPriv(scrn);
-	int fd;
+	ScrnInfoPtr  scrn = xf86ScreenToScrn(screen);
+	AMDGPUEntPtr ent  = AMDGPUEntPriv(scrn);
 
-	fd = open(pAMDGPUEnt->render_node, O_RDWR | O_CLOEXEC);
-	if (fd < 0)
-		return BadAlloc;
+	if (UNLIKELY(!ent->render_node))
+		return BadMatch;
 
-	*out = fd;
-	return Success;
+	return open_node(ent->render_node, out);
 }
 
-static int
-amdgpu_dri3_open(ScreenPtr screen, RRProviderPtr provider, int *out)
+/* ---------- 1c. Public entry used by DRI3 ----------------------------- */
+static AMDGPU_HOT int
+amdgpu_dri3_open(ScreenPtr      screen,
+                 RRProviderPtr  provider _X_UNUSED,
+                 int           *out)
 {
-	ScrnInfoPtr scrn = xf86ScreenToScrn(screen);
-	AMDGPUEntPtr pAMDGPUEnt = AMDGPUEntPriv(scrn);
-	int ret = BadAlloc;
-
-	if (pAMDGPUEnt->render_node)
-		ret = open_render_node(screen, out);
+	/* Try render node first (fast-path, no auth). */
+	int ret = amdgpu_open_render_node(screen, out);
+	if (ret == Success)
+		return ret;
 
-	if (ret != Success)
-		ret = open_card_node(screen, out);
+	/* Fall back to the legacy card node. */
+	return amdgpu_open_card_node(screen, out);
+}
 
-	return ret;
+/* ========== 2. Optional ssh-guard for ancient servers ================= */
+#if DRI3_SCREEN_INFO_VERSION >= 1 && \
+    XORG_VERSION_CURRENT <= XORG_VERSION_NUMERIC(1,18,99,1,0)
+
+static AMDGPU_HOT int
+amdgpu_dri3_open_client(ClientPtr     client,
+                        ScreenPtr     screen,
+                        RRProviderPtr provider,
+                        int          *out)
+{
+	const char *cmd = GetClientCmdName(client);
+	if (cmd) {
+		char  tmp[PATH_MAX];             /* stack, safe */
+		strncpy(tmp, cmd, sizeof(tmp));
+		tmp[sizeof(tmp) - 1] = '\0';
+
+		char *base = basename(tmp);
+		if (base && strcmp(base, "ssh") == 0)
+			return BadAccess;            /* remote client, deny */
+	}
+	return amdgpu_dri3_open(screen, provider, out);
 }
+#endif /* old server ssh guard */
 
-#if DRI3_SCREEN_INFO_VERSION >= 1 && XORG_VERSION_CURRENT <= XORG_VERSION_NUMERIC(1,18,99,1,0)
+/* ========== 3. Pixmap <--> DMA-BUF converters ========================= */
 
-static int
-amdgpu_dri3_open_client(ClientPtr client, ScreenPtr screen,
-			RRProviderPtr provider, int *out)
+/* ---- 3a. validation helpers ----------------------------------------- */
+static inline Bool
+validate_pixmap_dims(uint16_t width, uint16_t height,
+                     uint8_t depth, uint8_t bpp, uint16_t stride)
 {
-	const char *cmdname = GetClientCmdName(client);
-	Bool is_ssh = FALSE;
-
-	/* If the executable name is "ssh", assume that this client connection
-	 * is forwarded from another host via SSH
-	 */
-	if (cmdname) {
-		char *cmd = strdup(cmdname);
-
-		/* Cut off any colon and whatever comes after it, see
-		 * https://lists.freedesktop.org/archives/xorg-devel/2015-December/048164.html
-		 */
-		cmd = strtok(cmd, ":");
+	if (UNLIKELY(width == 0 || height == 0))
+		return FALSE;
 
-		is_ssh = strcmp(basename(cmd), "ssh") == 0;
-		free(cmd);
+	/* Only canonical formats that both X and DRM agree on. */
+	switch (bpp) {
+	case 8:
+		if (depth != 8) return FALSE;
+		break;
+	case 16:
+		if (depth != 15 && depth != 16) return FALSE;
+		break;
+	case 32:
+		if (depth < 24) return FALSE;
+		break;
+	default:
+		return FALSE;
 	}
 
-	if (!is_ssh)
-		return amdgpu_dri3_open(screen, provider, out);
-
-	return BadAccess;
+	/* stride must be large enough and contain no overflow */
+	uint32_t min_stride = (uint32_t)width * ((uint32_t)bpp >> 3);
+	return stride >= min_stride;
 }
 
-#endif /* DRI3_SCREEN_INFO_VERSION >= 1 && XORG_VERSION_CURRENT <= XORG_VERSION_NUMERIC(1,18,99,1,0) */
-
-static PixmapPtr amdgpu_dri3_pixmap_from_fd(ScreenPtr screen,
-					    int fd,
-					    CARD16 width,
-					    CARD16 height,
-					    CARD16 stride,
-					    CARD8 depth,
-					    CARD8 bpp)
+/* ---- 3b. FD → Pixmap ------------------------------------------------- */
+static AMDGPU_HOT PixmapPtr
+amdgpu_dri3_pixmap_from_fd(ScreenPtr  screen,
+                           int        fd,
+                           CARD16     width,
+                           CARD16     height,
+                           CARD16     stride,
+                           CARD8      depth,
+                           CARD8      bpp)
 {
-	PixmapPtr pixmap;
+	if (UNLIKELY(!validate_pixmap_dims(width, height, depth, bpp, stride)))
+		return NULL;
 
 #ifdef USE_GLAMOR
-	/* Avoid generating a GEM flink name if possible */
-	if (AMDGPUPTR(xf86ScreenToScrn(screen))->use_glamor) {
-		pixmap = glamor_pixmap_from_fd(screen, fd, width, height,
-					       stride, depth, bpp);
-		if (pixmap) {
-			struct amdgpu_pixmap *priv = calloc(1, sizeof(*priv));
-
-			if (priv) {
-				amdgpu_set_pixmap_private(pixmap, priv);
-				pixmap->usage_hint |= AMDGPU_CREATE_PIXMAP_DRI2;
-				return pixmap;
-			}
+	ScrnInfoPtr   scrn = xf86ScreenToScrn(screen);
+	AMDGPUInfoPtr info = AMDGPUPTR(scrn);
 
-			screen->DestroyPixmap(pixmap);
-			return NULL;
+	if (info->use_glamor) {
+		PixmapPtr pix = glamor_pixmap_from_fd(screen, fd, width, height,
+		                                      stride, depth, bpp);
+		if (pix) {
+			/* Only allocate a new private if none attached yet */
+			if (!amdgpu_get_pixmap_private(pix)) {
+				struct amdgpu_pixmap *priv = (struct amdgpu_pixmap *)calloc(1, sizeof(*priv));
+				if (LIKELY(priv)) {
+					amdgpu_set_pixmap_private(pix, priv);
+				} else {
+					screen->DestroyPixmap(pix);
+					return NULL;
+				}
+			}
+			pix->usage_hint |= AMDGPU_CREATE_PIXMAP_DRI2;
+			return pix;
 		}
+		return NULL;
 	}
-#endif
+#endif /* USE_GLAMOR */
 
-	if (depth < 8)
+	/* Fallback: no glamor. We duplicate the FD so ownership stays clear. */
+	struct fd_guard g; fdg_init(&g);
+	g.fd = fcntl(fd, F_DUPFD_CLOEXEC, 3);
+	if (g.fd < 0)
 		return NULL;
 
-	switch (bpp) {
-	case 8:
-	case 16:
-	case 32:
-		break;
-	default:
+	PixmapPtr pix = screen->CreatePixmap(screen, 0, 0, depth,
+	                                     AMDGPU_CREATE_PIXMAP_DRI2);
+	if (UNLIKELY(!pix)) {
+		fdg_cleanup(&g);
+		return NULL;
+	}
+
+	if (!screen->ModifyPixmapHeader(pix, width, height, 0, bpp, stride, NULL)) {
+		screen->DestroyPixmap(pix);
+		fdg_cleanup(&g);
 		return NULL;
 	}
 
-	pixmap = screen->CreatePixmap(screen, 0, 0, depth,
-				      AMDGPU_CREATE_PIXMAP_DRI2);
-	if (!pixmap)
+	if (!screen->SetSharedPixmapBacking(pix, (void *)(intptr_t)fdg_move(&g))) {
+		screen->DestroyPixmap(pix);
+		fdg_cleanup(&g);
 		return NULL;
+	}
 
-	if (!screen->ModifyPixmapHeader(pixmap, width, height, 0, bpp, stride,
-					NULL))
-		goto free_pixmap;
-
-	if (screen->SetSharedPixmapBacking(pixmap, (void*)(intptr_t)fd))
-		return pixmap;
-
-free_pixmap:
-	fbDestroyPixmap(pixmap);
-	return NULL;
+	fdg_cleanup(&g);      /* nothing left to close */
+	return pix;
 }
 
-static int amdgpu_dri3_fd_from_pixmap(ScreenPtr screen,
-				      PixmapPtr pixmap,
-				      CARD16 *stride,
-				      CARD32 *size)
+/* ---- 3c. Pixmap → FD ------------------------------------------------- */
+static AMDGPU_HOT int
+amdgpu_dri3_fd_from_pixmap(ScreenPtr screen, PixmapPtr pix,
+                           CARD16 *stride /* out */, CARD32 *size /* out */)
 {
-	struct amdgpu_buffer *bo;
-	struct amdgpu_bo_info bo_info;
-	uint32_t fd;
 #ifdef USE_GLAMOR
-	ScrnInfoPtr scrn = xf86ScreenToScrn(screen);
+	ScrnInfoPtr   scrn = xf86ScreenToScrn(screen);
 	AMDGPUInfoPtr info = AMDGPUPTR(scrn);
 
 	if (info->use_glamor) {
-		int ret = glamor_fd_from_pixmap(screen, pixmap, stride, size);
-
-		/* Any pending drawing operations need to be flushed to the
-		 * kernel driver before the client starts using the pixmap
-		 * storage for direct rendering.
-		 */
-		if (ret >= 0)
-			amdgpu_glamor_flush(scrn);
-
-		return ret;
+		int fd = glamor_fd_from_pixmap(screen, pix, stride, size);
+		if (fd >= 0) {
+			amdgpu_glamor_flush(scrn);          /* make sure GPU finished */
+			return fd;
+		}
+		/* fall through to BO export if glamor path failed */
 	}
 #endif
 
-	bo = amdgpu_get_pixmap_bo(pixmap);
-	if (!bo)
+	struct amdgpu_buffer *bo = amdgpu_get_pixmap_bo(pix);
+	if (UNLIKELY(!bo))
 		return -1;
 
-	if (pixmap->devKind > UINT16_MAX)
+	if (UNLIKELY(pix->devKind > UINT16_MAX))
 		return -1;
 
-	if (amdgpu_bo_query_info(bo->bo.amdgpu, &bo_info) != 0)
+	struct amdgpu_bo_info info_bo;
+	if (UNLIKELY(amdgpu_bo_query_info(bo->bo.amdgpu, &info_bo)))
 		return -1;
 
-	if (amdgpu_bo_export(bo->bo.amdgpu, amdgpu_bo_handle_type_dma_buf_fd,
-			     &fd) != 0)
+	uint32_t fd;
+	if (UNLIKELY(amdgpu_bo_export(bo->bo.amdgpu,
+	                              amdgpu_bo_handle_type_dma_buf_fd, &fd)))
 		return -1;
 
-	*stride = pixmap->devKind;
-	*size = bo_info.alloc_size;
-	return fd;
+	*stride = (CARD16)pix->devKind;
+	*size   = (CARD32)info_bo.alloc_size;
+	return (int)fd;
 }
 
+/* ========== 4. DRI3 screen-info trampoline ============================ */
 static dri3_screen_info_rec amdgpu_dri3_screen_info = {
-#if DRI3_SCREEN_INFO_VERSION >= 1 && XORG_VERSION_CURRENT <= XORG_VERSION_NUMERIC(1,18,99,1,0)
-	.version = 1,
-	.open_client = amdgpu_dri3_open_client,
+#if DRI3_SCREEN_INFO_VERSION >= 1 && \
+    XORG_VERSION_CURRENT <= XORG_VERSION_NUMERIC(1,18,99,1,0)
+	.version        = 1,
+	.open_client    = amdgpu_dri3_open_client,
 #else
-	.version = 0,
-	.open = amdgpu_dri3_open,
+	.version        = 0,
+	.open           = amdgpu_dri3_open,
 #endif
 	.pixmap_from_fd = amdgpu_dri3_pixmap_from_fd,
 	.fd_from_pixmap = amdgpu_dri3_fd_from_pixmap
 };
 
+/* ========== 5. Public init called by the driver ======================= */
 Bool
 amdgpu_dri3_screen_init(ScreenPtr screen)
 {
-	ScrnInfoPtr scrn = xf86ScreenToScrn(screen);
-	AMDGPUEntPtr pAMDGPUEnt = AMDGPUEntPriv(scrn);
+#ifndef HAVE_DRI3_H
+	xf86DrvMsg(xf86ScreenToScrn(screen)->scrnIndex, X_INFO,
+	           "DRI3 not built into this driver\n");
+	return FALSE;
+#else
+	ScrnInfoPtr  scrn = xf86ScreenToScrn(screen);
+	AMDGPUEntPtr ent  = AMDGPUEntPriv(scrn);
 
-	pAMDGPUEnt->render_node = drmGetRenderDeviceNameFromFd(pAMDGPUEnt->fd);
+	/* Cache render-node path for super-fast open() later. */
+	ent->render_node = drmGetRenderDeviceNameFromFd(ent->fd);
 
 	if (!dri3_screen_init(screen, &amdgpu_dri3_screen_info)) {
-		xf86DrvMsg(scrn->scrnIndex, X_WARNING,
-			   "dri3_screen_init failed\n");
+		xf86DrvMsg(scrn->scrnIndex, X_WARNING, "dri3_screen_init failed\n");
 		return FALSE;
 	}
-
 	return TRUE;
+#endif /* HAVE_DRI3_H */
 }
-
-#else /* !HAVE_DRI3_H */
-
-Bool
-amdgpu_dri3_screen_init(ScreenPtr screen)
-{
-	xf86DrvMsg(xf86ScreenToScrn(screen)->scrnIndex, X_INFO,
-		   "Can't initialize DRI3 because dri3.h not available at "
-		   "build time\n");
-
-	return FALSE;
-}
-
-#endif


--- a/src/amdgpu_kms.c	2025-05-18 11:28:38.972391290 +0200
+++ b/src/amdgpu_kms.c	2025-05-18 11:53:30.092499760 +0200
@@ -63,6 +63,18 @@
 
 #include <gbm.h>
 
+#if defined(__GNUC__) || defined(__clang__)
+#define AMDGPU_LIKELY(x)   __builtin_expect(!!(x), 1)
+#define AMDGPU_UNLIKELY(x) __builtin_expect(!!(x), 0)
+#define AMDGPU_HOT         __attribute__((hot))
+#define AMDGPU_COLD        __attribute__((cold))
+#else
+#define AMDGPU_LIKELY(x)   (x)
+#define AMDGPU_UNLIKELY(x) (x)
+#define AMDGPU_HOT
+#define AMDGPU_COLD
+#endif
+
 static DevPrivateKeyRec amdgpu_window_private_key;
 static DevScreenPrivateKeyRec amdgpu_client_private_key;
 DevScreenPrivateKeyRec amdgpu_device_private_key;
@@ -184,45 +196,44 @@ amdgpu_delete_property(ClientPtr client)
 static void
 amdgpu_unwrap_property_requests(ScrnInfoPtr scrn)
 {
-	int i;
-
-	if (!amdgpu_property_vectors_wrapped)
-		return;
-
-	if (ProcVector[X_ChangeProperty] == amdgpu_change_property)
-		ProcVector[X_ChangeProperty] = saved_change_property;
-	else
-		restore_property_vector = TRUE;
-
-	if (ProcVector[X_DeleteProperty] == amdgpu_delete_property)
-		ProcVector[X_DeleteProperty] = saved_delete_property;
-	else
-		restore_property_vector = TRUE;
-
-	for (i = 0; i < currentMaxClients; i++) {
-		if (clients[i]->requestVector[X_ChangeProperty] ==
-		    amdgpu_change_property) {
-			clients[i]->requestVector[X_ChangeProperty] =
-				saved_change_property;
-		} else {
-			restore_property_vector = TRUE;
-		}
+    int i;
 
-		if (clients[i]->requestVector[X_DeleteProperty] ==
-		    amdgpu_delete_property) {
-			clients[i]->requestVector[X_DeleteProperty] =
-				saved_delete_property;
-		} else {
-			restore_property_vector = TRUE;
-		}
-	}
+    if (!amdgpu_property_vectors_wrapped)
+        return;
 
-	if (restore_property_vector) {
-		xf86DrvMsg(scrn->scrnIndex, X_WARNING,
-			   "Couldn't unwrap some window property request vectors\n");
-	}
+    if (ProcVector[X_ChangeProperty] == amdgpu_change_property)
+        ProcVector[X_ChangeProperty] = saved_change_property;
+    else
+        restore_property_vector = TRUE;
+
+    if (ProcVector[X_DeleteProperty] == amdgpu_delete_property)
+        ProcVector[X_DeleteProperty] = saved_delete_property;
+    else
+        restore_property_vector = TRUE;
+
+    for (i = 0; i < currentMaxClients; i++) {
+        if (!clients[i])
+            continue;
+
+        if (clients[i]->requestVector[X_ChangeProperty] == amdgpu_change_property) {
+            clients[i]->requestVector[X_ChangeProperty] = saved_change_property;
+        } else {
+            restore_property_vector = TRUE;
+        }
+
+        if (clients[i]->requestVector[X_DeleteProperty] == amdgpu_delete_property) {
+            clients[i]->requestVector[X_DeleteProperty] = saved_delete_property;
+        } else {
+            restore_property_vector = TRUE;
+        }
+    }
+
+    if (restore_property_vector) {
+        xf86DrvMsg(scrn->scrnIndex, X_WARNING,
+                   "Couldn't unwrap some window property request vectors\n");
+    }
 
-	amdgpu_property_vectors_wrapped = FALSE;
+    amdgpu_property_vectors_wrapped = FALSE;
 }
 
 extern _X_EXPORT int gAMDGPUEntityIndex;
@@ -319,10 +330,14 @@ amdgpuUpdatePacked(ScreenPtr pScreen, sh
 	shadowUpdatePacked(pScreen, pBuf);
 }
 
-static Bool
+static inline Bool
 callback_needs_flush(AMDGPUInfoPtr info, struct amdgpu_client_priv *client_priv)
 {
-	return (int)(client_priv->needs_flush - info->gpu_flushed) > 0;
+    if (AMDGPU_UNLIKELY(!client_priv))
+        return FALSE;
+
+    // Wrap-safe comparison: flush only if needs_flush is ahead of gpu_flushed
+    return ((int32_t)(client_priv->needs_flush - info->gpu_flushed)) > 0;
 }
 
 static void
@@ -455,117 +470,176 @@ static Bool AMDGPUCreateScreenResources_
 	return TRUE;
 }
 
-static Bool
+static AMDGPU_HOT Bool
 amdgpu_scanout_extents_intersect(xf86CrtcPtr xf86_crtc, BoxPtr extents)
 {
-	if (xf86_crtc->scrn->is_gpu) {
-		extents->x1 -= xf86_crtc->x;
-		extents->y1 -= xf86_crtc->y;
-		extents->x2 -= xf86_crtc->x;
-		extents->y2 -= xf86_crtc->y;
-	} else {
-		extents->x1 -= xf86_crtc->filter_width >> 1;
-		extents->x2 += xf86_crtc->filter_width >> 1;
-		extents->y1 -= xf86_crtc->filter_height >> 1;
-		extents->y2 += xf86_crtc->filter_height >> 1;
-		pixman_f_transform_bounds(&xf86_crtc->f_framebuffer_to_crtc, extents);
-	}
-
-	extents->x1 = max(extents->x1, 0);
-	extents->y1 = max(extents->y1, 0);
-	extents->x2 = min(extents->x2, xf86_crtc->mode.HDisplay);
-	extents->y2 = min(extents->y2, xf86_crtc->mode.VDisplay);
+    const Bool is_gpu = xf86_crtc->scrn->is_gpu;
+    const Bool needs_transform = xf86_crtc->driverIsPerformingTransform;
 
-	return (extents->x1 < extents->x2 && extents->y1 < extents->y2);
+    if (!is_gpu) {
+        const int fx = xf86_crtc->filter_width  >> 1;
+        const int fy = xf86_crtc->filter_height >> 1;
+
+        // Correct early-reject: include filter inflation in the bounds test
+        if (!needs_transform) {
+            if (extents->x2 + fx <= xf86_crtc->x ||
+                extents->x1 - fx >= xf86_crtc->x + xf86_crtc->mode.HDisplay ||
+                extents->y2 + fy <= xf86_crtc->y ||
+                extents->y1 - fy >= xf86_crtc->y + xf86_crtc->mode.VDisplay)
+                return FALSE;
+        }
+
+        // Translate/inflate for non-GPU screen
+        extents->x1 -= fx;
+        extents->x2 += fx;
+        extents->y1 -= fy;
+        extents->y2 += fy;
+
+        if (needs_transform) {
+            pixman_f_transform_bounds(&xf86_crtc->f_framebuffer_to_crtc, extents);
+        }
+    } else {
+        // GPU screen path: translate into CRTC-local space
+        extents->x1 -= xf86_crtc->x;
+        extents->y1 -= xf86_crtc->y;
+        extents->x2 -= xf86_crtc->x;
+        extents->y2 -= xf86_crtc->y;
+    }
+
+    // Clamp
+    extents->x1 = max(extents->x1, 0);
+    extents->y1 = max(extents->y1, 0);
+    extents->x2 = min(extents->x2, xf86_crtc->mode.HDisplay);
+    extents->y2 = min(extents->y2, xf86_crtc->mode.VDisplay);
+
+    return (extents->x1 < extents->x2) && (extents->y1 < extents->y2);
 }
 
-static RegionPtr
+static AMDGPU_HOT RegionPtr
 transform_region(RegionPtr region, struct pixman_f_transform *transform,
-		 int w, int h)
+                 int w, int h)
 {
-	BoxPtr boxes = RegionRects(region);
-	int nboxes = RegionNumRects(region);
-	xRectanglePtr rects = malloc(nboxes * sizeof(*rects));
-	RegionPtr transformed;
-	int nrects = 0;
-	BoxRec box;
-	int i;
+    const int nboxes = RegionNumRects(region);
+    const BoxPtr boxes = RegionRects(region);
 
-	for (i = 0; i < nboxes; i++) {
-		box.x1 = boxes[i].x1;
-		box.x2 = boxes[i].x2;
-		box.y1 = boxes[i].y1;
-		box.y2 = boxes[i].y2;
-		pixman_f_transform_bounds(transform, &box);
-
-		box.x1 = max(box.x1, 0);
-		box.y1 = max(box.y1, 0);
-		box.x2 = min(box.x2, w);
-		box.y2 = min(box.y2, h);
-		if (box.x1 >= box.x2 || box.y1 >= box.y2)
-			continue;
-
-		rects[nrects].x = box.x1;
-		rects[nrects].y = box.y1;
-		rects[nrects].width = box.x2 - box.x1;
-		rects[nrects].height = box.y2 - box.y1;
-		nrects++;
-	}
-
-	transformed = RegionFromRects(nrects, rects, CT_UNSORTED);
-	free(rects);
-	return transformed;
-}
+    if (nboxes <= 0)
+        return RegionCreate(NULL, 0);
 
-static void
-amdgpu_sync_scanout_pixmaps(xf86CrtcPtr xf86_crtc, RegionPtr new_region,
-							int scanout_id)
-{
-	drmmode_crtc_private_ptr drmmode_crtc = xf86_crtc->driver_private;
-	DrawablePtr dst = &drmmode_crtc->scanout[scanout_id]->drawable;
-	DrawablePtr src = &drmmode_crtc->scanout[scanout_id ^ 1]->drawable;
-	RegionPtr last_region = &drmmode_crtc->scanout_last_region;
-	ScrnInfoPtr scrn = xf86_crtc->scrn;
-	ScreenPtr pScreen = scrn->pScreen;
-	RegionRec remaining;
-	RegionPtr sync_region = NULL;
-	BoxRec extents;
-	GCPtr gc;
-
-	if (RegionNil(last_region))
-		return;
-
-	RegionNull(&remaining);
-	RegionSubtract(&remaining, last_region, new_region);
-	if (RegionNil(&remaining))
-		goto uninit;
-
-	extents = *RegionExtents(&remaining);
-	if (!amdgpu_scanout_extents_intersect(xf86_crtc, &extents))
-		goto uninit;
-
-	if (xf86_crtc->driverIsPerformingTransform) {
-		sync_region = transform_region(&remaining,
-					       &xf86_crtc->f_framebuffer_to_crtc,
-					       dst->width, dst->height);
-	} else {
-		sync_region = RegionDuplicate(&remaining);
-		RegionTranslate(sync_region, -xf86_crtc->x, -xf86_crtc->y);
-	}
-
-	gc = GetScratchGC(dst->depth, pScreen);
-	if (gc) {
-		gc->funcs->ChangeClip(gc, CT_REGION, sync_region, 0);
-		ValidateGC(dst, gc);
-		sync_region = NULL;
-		gc->ops->CopyArea(src, dst, gc, 0, 0, dst->width, dst->height, 0, 0);
-		FreeScratchGC(gc);
-	}
-
- uninit:
-	if (sync_region)
-		RegionDestroy(sync_region);
-	RegionUninit(&remaining);
+    if (nboxes == 1) {
+        BoxRec b = boxes[0];
+        pixman_f_transform_bounds(transform, &b);
+        if (b.x1 < 0) b.x1 = 0;
+        if (b.y1 < 0) b.y1 = 0;
+        if (b.x2 >  w) b.x2 = w;
+        if (b.y2 >  h) b.y2 = h;
+        if (b.x1 >= b.x2 || b.y1 >= b.y2)
+            return RegionCreate(NULL, 0);
+
+        xRectangle rect = { .x = b.x1, .y = b.y1,
+                            .width = (uint16_t)(b.x2 - b.x1),
+                            .height = (uint16_t)(b.y2 - b.y1) };
+        return RegionFromRects(1, &rect, CT_UNSORTED);
+    }
+
+    enum { SBO = 64 };
+    xRectangle stack_rects[SBO];
+    xRectangle *rects = (nboxes <= SBO) ? stack_rects :
+                        (xRectangle*)malloc((size_t)nboxes * sizeof(*rects));
+    if (!rects) {
+        xf86Msg(X_WARNING, "amdgpu: transform_region OOM, duplicating region\n");
+        return RegionDuplicate(region);
+    }
+
+    int nrects = 0;
+    for (int i = 0; i < nboxes; ++i) {
+        BoxRec b = boxes[i];
+        pixman_f_transform_bounds(transform, &b);
+
+        if (b.x1 < 0) b.x1 = 0;
+        if (b.y1 < 0) b.y1 = 0;
+        if (b.x2 >  w) b.x2 = w;
+        if (b.y2 >  h) b.y2 = h;
+        if (b.x1 >= b.x2 || b.y1 >= b.y2)
+            continue;
+
+        rects[nrects].x = (int16_t)b.x1;
+        rects[nrects].y = (int16_t)b.y1;
+        rects[nrects].width  = (uint16_t)(b.x2 - b.x1);
+        rects[nrects].height = (uint16_t)(b.y2 - b.y1);
+        ++nrects;
+    }
+
+    RegionPtr out = RegionFromRects(nrects, rects, CT_UNSORTED);
+    if (rects != stack_rects) free(rects);
+    return out;
+}
+
+static AMDGPU_HOT void
+amdgpu_sync_scanout_pixmaps(xf86CrtcPtr xf86_crtc, RegionPtr new_region, int scanout_id)
+{
+    drmmode_crtc_private_ptr drmmode_crtc = xf86_crtc->driver_private;
+    DrawablePtr dst = &drmmode_crtc->scanout[scanout_id]->drawable;
+    DrawablePtr src = &drmmode_crtc->scanout[scanout_id ^ 1]->drawable;
+    RegionPtr last_region = &drmmode_crtc->scanout_last_region;
+    ScrnInfoPtr scrn = xf86_crtc->scrn;
+    ScreenPtr pScreen = scrn->pScreen;
+    RegionRec remaining;
+    RegionPtr sync_region = NULL;
+    BoxRec extents;
+
+    if (RegionNil(last_region))
+        return;
+
+    RegionNull(&remaining);
+    RegionSubtract(&remaining, last_region, new_region);
+    if (RegionNil(&remaining))
+        goto uninit;
+
+    extents = *RegionExtents(&remaining);
+    if (!amdgpu_scanout_extents_intersect(xf86_crtc, &extents))
+        goto uninit;
+
+    if (!xf86_crtc->driverIsPerformingTransform && RegionNumRects(&remaining) == 1) {
+        const BoxPtr r = RegionRects(&remaining);
+        const int rx1 = r->x1 - xf86_crtc->x;
+        const int ry1 = r->y1 - xf86_crtc->y;
+        const int w   = r->x2 - r->x1;
+        const int h   = r->y2 - r->y1;
+        if (w > 0 && h > 0) {
+            GCPtr gc = GetScratchGC(dst->depth, pScreen);
+            if (gc) {
+                ValidateGC(dst, gc);
+                gc->ops->CopyArea(src, dst, gc, rx1, ry1, w, h, rx1, ry1);
+                FreeScratchGC(gc);
+            }
+        }
+        goto uninit;
+    }
+
+    if (xf86_crtc->driverIsPerformingTransform) {
+        sync_region = transform_region(&remaining,
+                                       &xf86_crtc->f_framebuffer_to_crtc,
+                                       dst->width, dst->height);
+    } else {
+        sync_region = RegionDuplicate(&remaining);
+        RegionTranslate(sync_region, -xf86_crtc->x, -xf86_crtc->y);
+    }
+
+    {
+        GCPtr gc = GetScratchGC(dst->depth, pScreen);
+        if (gc) {
+            gc->funcs->ChangeClip(gc, CT_REGION, sync_region, 0);
+            ValidateGC(dst, gc);
+            sync_region = NULL;
+            gc->ops->CopyArea(src, dst, gc, 0, 0, dst->width, dst->height, 0, 0);
+            FreeScratchGC(gc);
+        }
+    }
+
+uninit:
+    if (sync_region)
+        RegionDestroy(sync_region);
+    RegionUninit(&remaining);
 }
 
 static void
@@ -596,29 +670,50 @@ amdgpu_scanout_flip_handler(xf86CrtcPtr
 }
 
 
-static RegionPtr
+static AMDGPU_HOT RegionPtr
 dirty_region(PixmapDirtyUpdatePtr dirty)
 {
-	RegionPtr damageregion = DamageRegion(dirty->damage);
-	RegionPtr dstregion;
+    RegionPtr damageregion = DamageRegion(dirty->damage);
 
-	if (dirty->rotation != RR_Rotate_0) {
-		dstregion = transform_region(damageregion,
-					     &dirty->f_inverse,
-					     dirty->secondary_dst->drawable.width,
-					     dirty->secondary_dst->drawable.height);
-	} else
-	{
-		RegionRec pixregion;
-
-		dstregion = RegionDuplicate(damageregion);
-		RegionTranslate(dstregion, -dirty->x, -dirty->y);
-		PixmapRegionInit(&pixregion, dirty->secondary_dst);
-		RegionIntersect(dstregion, dstregion, &pixregion);
-		RegionUninit(&pixregion);
-	}
+    if (RegionNil(damageregion))
+        return RegionCreate(NULL, 0);
+
+    if (dirty->rotation != RR_Rotate_0) {
+        return transform_region(damageregion, &dirty->f_inverse,
+                                dirty->secondary_dst->drawable.width,
+                                dirty->secondary_dst->drawable.height);
+    } else {
+        const int nboxes = RegionNumRects(damageregion);
+        const BoxPtr boxes = RegionRects(damageregion);
+
+        if (nboxes == 1) {
+            BoxRec b = boxes[0];
+            b.x1 -= dirty->x; b.y1 -= dirty->y;
+            b.x2 -= dirty->x; b.y2 -= dirty->y;
+
+            if (b.x1 < 0) b.x1 = 0;
+            if (b.y1 < 0) b.y1 = 0;
+            const int w = dirty->secondary_dst->drawable.width;
+            const int h = dirty->secondary_dst->drawable.height;
+            if (b.x2 > w) b.x2 = w;
+            if (b.y2 > h) b.y2 = h;
+
+            if (b.x1 >= b.x2 || b.y1 >= b.y2)
+                return RegionCreate(NULL, 0);
+
+            return RegionCreate(&b, 1);
+        }
+
+        RegionPtr dstregion = RegionDuplicate(damageregion);
+        RegionTranslate(dstregion, -dirty->x, -dirty->y);
+
+        RegionRec pixregion;
+        PixmapRegionInit(&pixregion, dirty->secondary_dst);
+        RegionIntersect(dstregion, dstregion, &pixregion);
+        RegionUninit(&pixregion);
 
-	return dstregion;
+        return dstregion;
+    }
 }
 
 static void
@@ -978,87 +1073,92 @@ amdgpuSourceValidate(DrawablePtr draw, i
 {
 }
 
-Bool
-amdgpu_scanout_do_update(xf86CrtcPtr xf86_crtc, int scanout_id,
-			 PixmapPtr src_pix, BoxRec extents)
+static inline Bool pict_transform_is_identity(const PictTransform *t)
 {
-	drmmode_crtc_private_ptr drmmode_crtc = xf86_crtc->driver_private;
-	RegionRec region = { .extents = extents, .data = NULL };
-	ScrnInfoPtr scrn = xf86_crtc->scrn;
-	ScreenPtr pScreen = scrn->pScreen;
-	DrawablePtr pDraw;
-
-	if (!xf86_crtc->enabled ||
-	    !drmmode_crtc->scanout[scanout_id] ||
-	    extents.x1 >= extents.x2 || extents.y1 >= extents.y2)
-		return FALSE;
-
-	pDraw = &drmmode_crtc->scanout[scanout_id]->drawable;
-	if (!amdgpu_scanout_extents_intersect(xf86_crtc, &extents))
-		return FALSE;
-
-	if (drmmode_crtc->tear_free) {
-		amdgpu_sync_scanout_pixmaps(xf86_crtc, &region, scanout_id);
-		RegionCopy(&drmmode_crtc->scanout_last_region, &region);
-	}
-
-	if (xf86_crtc->driverIsPerformingTransform) {
-		SourceValidateProcPtr SourceValidate = pScreen->SourceValidate;
-		PictFormatPtr format = PictureWindowFormat(pScreen->root);
-		int error;
-		PicturePtr src, dst;
-
-		src = CreatePicture(None, &src_pix->drawable, format, 0L, NULL,
-				    serverClient, &error);
-		if (!src) {
-			ErrorF("Failed to create source picture for transformed scanout "
-			       "update\n");
-			goto out;
-		}
-
-		dst = CreatePicture(None, pDraw, format, 0L, NULL, serverClient, &error);
-		if (!dst) {
-			ErrorF("Failed to create destination picture for transformed scanout "
-			       "update\n");
-			goto free_src;
-		}
-		error = SetPictureTransform(src, &xf86_crtc->crtc_to_framebuffer);
-		if (error) {
-			ErrorF("SetPictureTransform failed for transformed scanout "
-			       "update\n");
-			goto free_dst;
-		}
-
-		if (xf86_crtc->filter)
-			SetPicturePictFilter(src, xf86_crtc->filter, xf86_crtc->params,
-					     xf86_crtc->nparams);
-
-		pScreen->SourceValidate = amdgpuSourceValidate;
-		CompositePicture(PictOpSrc,
-				 src, NULL, dst,
-				 extents.x1, extents.y1, 0, 0, extents.x1,
-				 extents.y1, extents.x2 - extents.x1,
-				 extents.y2 - extents.y1);
-		pScreen->SourceValidate = SourceValidate;
-
- free_dst:
-		FreePicture(dst, None);
- free_src:
-		FreePicture(src, None);
-	} else
- out:
-	{
-		GCPtr gc = GetScratchGC(pDraw->depth, pScreen);
-
-		ValidateGC(pDraw, gc);
-		(*gc->ops->CopyArea)(&src_pix->drawable, pDraw, gc,
-				     xf86_crtc->x + extents.x1, xf86_crtc->y + extents.y1,
-				     extents.x2 - extents.x1, extents.y2 - extents.y1,
-				     extents.x1, extents.y1);
-		FreeScratchGC(gc);
-	}
+    if (!t) return FALSE;
+    return t->matrix[0][0] == (1 << 16) && t->matrix[0][1] == 0 && t->matrix[0][2] == 0 &&
+           t->matrix[1][0] == 0 && t->matrix[1][1] == (1 << 16) && t->matrix[1][2] == 0 &&
+           t->matrix[2][0] == 0 && t->matrix[2][1] == 0 && t->matrix[2][2] == (1 << 16);
+}
 
-	return TRUE;
+AMDGPU_HOT Bool
+amdgpu_scanout_do_update(xf86CrtcPtr xf86_crtc, int scanout_id,
+                         PixmapPtr src_pix, BoxRec extents)
+{
+    drmmode_crtc_private_ptr drmmode_crtc = xf86_crtc->driver_private;
+    RegionRec region = { .extents = extents, .data = NULL };
+    ScrnInfoPtr scrn = xf86_crtc->scrn;
+    ScreenPtr pScreen = scrn->pScreen;
+
+    if (AMDGPU_UNLIKELY(!xf86_crtc->enabled ||
+                        !drmmode_crtc->scanout[scanout_id] ||
+                        extents.x1 >= extents.x2 || extents.y1 >= extents.y2))
+        return FALSE;
+
+    DrawablePtr pDraw = &drmmode_crtc->scanout[scanout_id]->drawable;
+    if (!amdgpu_scanout_extents_intersect(xf86_crtc, &extents))
+        return FALSE;
+
+    if (drmmode_crtc->tear_free) {
+        amdgpu_sync_scanout_pixmaps(xf86_crtc, &region, scanout_id);
+        RegionCopy(&drmmode_crtc->scanout_last_region, &region);
+    }
+
+    const Bool needs_transform =
+        xf86_crtc->driverIsPerformingTransform &&
+        !(pict_transform_is_identity(&xf86_crtc->crtc_to_framebuffer) && !xf86_crtc->filter);
+
+    if (needs_transform) {
+        SourceValidateProcPtr SourceValidate = pScreen->SourceValidate;
+        PictFormatPtr format = PictureWindowFormat(pScreen->root);
+        int error;
+        PicturePtr src = CreatePicture(None, &src_pix->drawable, format, 0L, NULL,
+                                       serverClient, &error);
+        if (!src) {
+            ErrorF("Failed to create source picture for transformed scanout update\n");
+            goto blit_path;
+        }
+
+        PicturePtr dst = CreatePicture(None, pDraw, format, 0L, NULL, serverClient, &error);
+        if (!dst) {
+            ErrorF("Failed to create destination picture for transformed scanout update\n");
+            FreePicture(src, None);
+            goto blit_path;
+        }
+
+        error = SetPictureTransform(src, &xf86_crtc->crtc_to_framebuffer);
+        if (error) {
+            ErrorF("SetPictureTransform failed for transformed scanout update\n");
+            FreePicture(dst, None);
+            FreePicture(src, None);
+            goto blit_path;
+        }
+
+        if (xf86_crtc->filter)
+            SetPicturePictFilter(src, xf86_crtc->filter, xf86_crtc->params, xf86_crtc->nparams);
+
+        pScreen->SourceValidate = amdgpuSourceValidate;
+        CompositePicture(PictOpSrc, src, NULL, dst,
+                         extents.x1, extents.y1, 0, 0,
+                         extents.x1, extents.y1,
+                         extents.x2 - extents.x1, extents.y2 - extents.y1);
+        pScreen->SourceValidate = SourceValidate;
+
+        FreePicture(dst, None);
+        FreePicture(src, None);
+        return TRUE;
+    }
+
+blit_path: {
+        GCPtr gc = GetScratchGC(pDraw->depth, pScreen);
+        ValidateGC(pDraw, gc);
+        gc->ops->CopyArea(&src_pix->drawable, pDraw, gc,
+                          xf86_crtc->x + extents.x1, xf86_crtc->y + extents.y1,
+                          extents.x2 - extents.x1, extents.y2 - extents.y1,
+                          extents.x1, extents.y1);
+        FreeScratchGC(gc);
+        return TRUE;
+    }
 }
 
 static void


--- a/src/amdgpu_dri2.c	2025-05-18 10:11:28.156421974 +0200
+++ b/src/amdgpu_dri2.c	2025-08-16 11:06:23.290964784 +0200
@@ -26,7 +26,7 @@
  * DEALINGS IN THE SOFTWARE.
  */
 #ifdef HAVE_CONFIG_H
-#include "config.h"
+# include "config.h"
 #endif
 
 #include "amdgpu_drv.h"
@@ -42,906 +42,1031 @@
 #include <sys/stat.h>
 #include <fcntl.h>
 #include <errno.h>
+#include <stdint.h>
+#include <string.h>
 
 #include <gbm.h>
 
 #include "amdgpu_bo_helper.h"
 #include "amdgpu_version.h"
 
-#include <list.h>
+#include <list.h> /* From Xorg server includes */
 #include <xf86Priv.h>
 #include <X11/extensions/dpmsconst.h>
+#include <regionstr.h> /* For Region* function prototypes and RegionRec */
 
 #define FALLBACK_SWAP_DELAY 16
 
+/* Branch-prediction helpers */
+#if (defined(__GNUC__) && (__GNUC__ >= 3)) || defined(__clang__)
+# define likely(x)   __builtin_expect(!!(x), 1)
+# define unlikely(x) __builtin_expect(!!(x), 0)
+#else
+# define likely(x)   (x)
+# define unlikely(x) (x)
+#endif
+
+/* Hot/Cold function layout hints (advisory to compiler) */
+#if defined(__GNUC__) || defined(__clang__)
+# ifndef AMDGPU_HOT
+#  define AMDGPU_HOT  __attribute__((hot))
+# endif
+# ifndef AMDGPU_COLD
+#  define AMDGPU_COLD __attribute__((cold))
+# endif
+#else
+# ifndef AMDGPU_HOT
+#  define AMDGPU_HOT
+# endif
+# ifndef AMDGPU_COLD
+#  define AMDGPU_COLD
+# endif
+#endif
+
+/* For Scratch GC Cache */
+#define MAX_GC_DEPTH 32 /* Max depth value (0-32 needs array size 33) */
+#define GC_CACHE_PER_DEPTH 1
+
 typedef DRI2BufferPtr BufferPtr;
 
 struct dri2_buffer_priv {
-	PixmapPtr pixmap;
+	PixmapPtr    pixmap;
 	unsigned int attachment;
 	unsigned int refcnt;
 };
 
 struct dri2_window_priv {
 	xf86CrtcPtr crtc;
-	int vblank_delta;
+	int         vblank_delta;
 };
 
 static DevPrivateKeyRec dri2_window_private_key_rec;
 #define dri2_window_private_key (&dri2_window_private_key_rec)
-
 #define get_dri2_window_priv(window) \
-	((struct dri2_window_priv*) \
-	 dixLookupPrivate(&(window)->devPrivates, dri2_window_private_key))
+((struct dri2_window_priv *) \
+dixLookupPrivate(&(window)->devPrivates, dri2_window_private_key))
+
+static int DRI2InfoCnt; /* Declaration for the global counter */
 
-/* Get GEM flink name for a pixmap */
-static Bool
-amdgpu_get_flink_name(AMDGPUEntPtr pAMDGPUEnt, PixmapPtr pixmap, uint32_t *name)
+enum DRI2FrameEventType {
+	DRI2_SWAP,
+	DRI2_FLIP,
+	DRI2_WAITMSC,
+};
+
+typedef struct _DRI2FrameEvent {
+	XID                     drawable_id;
+	ClientPtr               client;
+	enum DRI2FrameEventType type;
+	unsigned                frame;
+	xf86CrtcPtr             crtc;
+	OsTimerPtr              timer;
+	uintptr_t               drm_queue_seq;
+
+	DRI2SwapEventPtr        event_complete;
+	void                   *event_data;
+	DRI2BufferPtr           front;
+	DRI2BufferPtr           back;
+	struct _DRI2FrameEvent *next;
+} __attribute__((aligned(64))) DRI2FrameEventRec,
+*DRI2FrameEventPtr;
+
+/* Simple spinlock for small caches (Xorg is effectively single-threaded, but we keep the lock) */
+static volatile int global_spin = 0;
+static inline void gl_lock(void)   { while (__sync_lock_test_and_set(&global_spin, 1)) { } }
+static inline void gl_unlock(void) { __sync_lock_release(&global_spin); }
+
+#define FRAME_EVENT_CACHE_MAX 256
+static DRI2FrameEventPtr fe_free_list        = NULL;
+static unsigned          fe_free_list_length = 0;
+
+static AMDGPU_HOT inline DRI2FrameEventPtr frame_event_alloc(void)
+{
+	DRI2FrameEventPtr ev = NULL;
+
+	gl_lock();
+	if (fe_free_list) {
+		ev            = fe_free_list;
+		fe_free_list  = ev->next;
+		fe_free_list_length--;
+	}
+	gl_unlock();
+
+	if (ev) {
+		memset(ev, 0, sizeof(*ev));
+		return ev;
+	}
+	return (DRI2FrameEventPtr)calloc(1, sizeof(DRI2FrameEventRec));
+}
+
+static AMDGPU_HOT inline void frame_event_free(DRI2FrameEventPtr ev)
+{
+	if (!ev)
+		return;
+
+	gl_lock();
+	if (fe_free_list_length >= FRAME_EVENT_CACHE_MAX) {
+		gl_unlock();
+		free(ev);
+		return;
+	}
+	ev->next       = fe_free_list;
+	fe_free_list   = ev;
+	fe_free_list_length++;
+	gl_unlock();
+}
+
+#define FLINK_CACHE_SIZE 64
+typedef struct {
+	uint32_t bo_handle;
+	uint32_t flink_name;
+	Bool     valid;
+} FlinkCacheEntry;
+
+static FlinkCacheEntry flink_cache[FLINK_CACHE_SIZE];
+static int             flink_cache_idx = 0;
+/* MRU cache entry: common case is repeated use of the same BO */
+static FlinkCacheEntry flink_mru = { 0, 0, FALSE };
+
+static AMDGPU_HOT Bool
+amdgpu_get_flink_name(AMDGPUEntPtr pEnt, PixmapPtr pixmap, uint32_t *name)
 {
 	struct amdgpu_buffer *bo = amdgpu_get_pixmap_bo(pixmap);
-	struct drm_gem_flink flink;
+	uint32_t handle;
 
-	if (bo && !(bo->flags & AMDGPU_BO_FLAGS_GBM) &&
-	    amdgpu_bo_export(bo->bo.amdgpu,
-			     amdgpu_bo_handle_type_gem_flink_name,
-			     name) == 0)
-		return TRUE;
+	if (!amdgpu_pixmap_get_handle(pixmap, &handle))
+		return FALSE;
+
+	/* Fast path: cached and non-GBM BO */
+	if (bo && !(bo->flags & AMDGPU_BO_FLAGS_GBM)) {
+		/* MRU check (benign data race in single-threaded Xorg; helps avoid lock) */
+		if (flink_mru.valid && flink_mru.bo_handle == handle) {
+			*name = flink_mru.flink_name;
+			return TRUE;
+		}
+
+		gl_lock();
+		for (int i = 0; i < FLINK_CACHE_SIZE; ++i) {
+			if (flink_cache[i].valid && flink_cache[i].bo_handle == handle) {
+				*name   = flink_cache[i].flink_name;
+				flink_mru = flink_cache[i]; /* Update MRU */
+				gl_unlock();
+				return TRUE;
+			}
+		}
+		gl_unlock();
+
+		if (amdgpu_bo_export(bo->bo.amdgpu,
+		                     amdgpu_bo_handle_type_gem_flink_name,
+		                     name) == 0) {
+			gl_lock();
+			flink_cache[flink_cache_idx].bo_handle  = handle;
+			flink_cache[flink_cache_idx].flink_name = *name;
+			flink_cache[flink_cache_idx].valid      = TRUE;
+			flink_mru = flink_cache[flink_cache_idx];
+			flink_cache_idx = (flink_cache_idx + 1) % FLINK_CACHE_SIZE;
+			gl_unlock();
+			return TRUE;
+		}
+	}
 
-	if (!amdgpu_pixmap_get_handle(pixmap, &flink.handle) ||
-	    ioctl(pAMDGPUEnt->fd, DRM_IOCTL_GEM_FLINK, &flink) < 0)
+	/* Fallback: direct DRM ioctl */
+	struct drm_gem_flink req;
+	memset(&req, 0, sizeof(req));
+	req.handle = handle;
+	if (ioctl(pEnt->fd, DRM_IOCTL_GEM_FLINK, &req) < 0)
 		return FALSE;
-	*name = flink.name;
+
+	*name = req.name;
+	/* Update MRU from ioctl path too */
+	flink_mru.bo_handle  = handle;
+	flink_mru.flink_name = req.name;
+	flink_mru.valid      = TRUE;
 	return TRUE;
 }
 
-static BufferPtr
-amdgpu_dri2_create_buffer2(ScreenPtr pScreen,
-			   DrawablePtr drawable,
-			   unsigned int attachment, unsigned int format)
+static AMDGPU_HOT Bool update_front(DrawablePtr draw, DRI2BufferPtr front)
 {
-	ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
-	AMDGPUEntPtr pAMDGPUEnt = AMDGPUEntPriv(pScrn);
-	AMDGPUInfoPtr info = AMDGPUPTR(pScrn);
-	BufferPtr buffers;
-	struct dri2_buffer_priv *privates;
-	PixmapPtr pixmap;
-	unsigned front_width;
-	unsigned aligned_width = drawable->width;
-	unsigned height = drawable->height;
-	Bool is_glamor_pixmap = FALSE;
-	int depth;
-	int cpp;
+	ScreenPtr s = draw->pScreen;
+	AMDGPUEntPtr ent = AMDGPUEntPriv(xf86ScreenToScrn(s));
+	struct dri2_buffer_priv *priv = (struct dri2_buffer_priv *)front->driverPrivate;
+	PixmapPtr px = NULL;
 
-	if (format) {
-		depth = format;
+	if (!priv)
+		return FALSE;
 
-		switch (depth) {
-		case 15:
-			cpp = 2;
-			break;
-		case 24:
-		case 30:
-			cpp = 4;
-			break;
-		default:
-			cpp = depth / 8;
-		}
+	/* Resolve the pixmap for this drawable */
+	if (draw->type == DRAWABLE_PIXMAP) {
+		px = (PixmapPtr)draw;
 	} else {
-		depth = drawable->depth;
-		cpp = drawable->bitsPerPixel / 8;
+		px = s->GetWindowPixmap((WindowPtr)draw);
 	}
 
-	front_width = pScreen->GetScreenPixmap(pScreen)->drawable.width;
+	if (!px)
+		return FALSE;
+
+	/* Fast path: same pixmap as before and we have a valid flink name */
+	if (priv->pixmap == px && front->name != 0) {
+		front->pitch = px->devKind;
+		front->cpp   = px->drawable.bitsPerPixel / 8;
+		return TRUE;
+	}
+
+	if (!amdgpu_get_flink_name(ent, px, &front->name))
+		return FALSE;
 
-	pixmap = NULL;
+	if (priv->pixmap)
+		dixDestroyPixmap(priv->pixmap, 0);
 
+	front->pitch = px->devKind;
+	front->cpp   = px->drawable.bitsPerPixel / 8;
+	priv->pixmap = px;
+	px->refcnt++;
+	return TRUE;
+}
+
+static const uint8_t depth_to_cpp_table[33] = {
+	[0]  = 0,
+	[1 ... 7] = 1,  [8]  = 1,
+	[9 ... 14]= 2,  [15] = 2, [16] = 2,
+	[17 ... 23]= 3,
+	[24] = 4,
+	[25 ... 29]= 4, [30] = 4,
+	[31 ... 32]= 4
+};
+
+static AMDGPU_HOT BufferPtr
+amdgpu_dri2_create_buffer2(ScreenPtr      pScreen,
+                           DrawablePtr    drawable,
+                           unsigned int   attachment,
+                           unsigned int   format)
+{
+	ScrnInfoPtr              pScrn  = xf86ScreenToScrn(pScreen);
+	AMDGPUEntPtr             pEnt   = AMDGPUEntPriv(pScrn);
+	AMDGPUInfoPtr            info   = AMDGPUPTR(pScrn);
+	BufferPtr                buf    = NULL;
+	struct dri2_buffer_priv *priv   = NULL;
+	PixmapPtr                pixmap = NULL;
+	unsigned                 aw     = drawable->width;
+	unsigned                 h      = drawable->height;
+	unsigned                 front_w= pScreen->GetScreenPixmap(pScreen)->drawable.width;
+	Bool                     glamor = FALSE;
+	int                      depth, cpp;
+
+	/* Determine depth / cpp */
+	if (format) {
+		depth = (int)format;
+		cpp   = (depth <= 32) ? depth_to_cpp_table[depth] : 0;
+	} else {
+		depth = (int)drawable->depth;
+		cpp   = (depth <= 32) ? depth_to_cpp_table[depth] : 0;
+	}
+	if (cpp == 0)
+		cpp = (depth + 7) / 8;
+
+	/* Choose pixmap for attachment */
 	if (attachment == DRI2BufferFrontLeft) {
-		uint32_t handle;
+		uint32_t handle = 0;
+		/* Resolve drawable -> pixmap */
+		if (drawable->type == DRAWABLE_PIXMAP) {
+			pixmap = (PixmapPtr)drawable;
+		} else {
+			pixmap = pScreen->GetWindowPixmap((WindowPtr)drawable);
+		}
 
-		pixmap = get_drawable_pixmap(drawable);
-		if (pScreen != pixmap->drawable.pScreen)
-			pixmap = NULL;
-		else if (info->use_glamor && !amdgpu_pixmap_get_handle(pixmap, &handle)) {
-			is_glamor_pixmap = TRUE;
-			aligned_width = pixmap->drawable.width;
-			height = pixmap->drawable.height;
+		if (pixmap && pScreen == pixmap->drawable.pScreen) {
+			/* If glamor and no gpu-handle for this pixmap, redirect */
+			if (info->use_glamor && !amdgpu_pixmap_get_handle(pixmap, &handle)) {
+				glamor = TRUE;
+				aw     = pixmap->drawable.width;
+				h      = pixmap->drawable.height;
+				pixmap = NULL;
+			} else {
+				pixmap->refcnt++;
+			}
+		} else {
 			pixmap = NULL;
-		} else
-			pixmap->refcnt++;
+		}
 	}
 
-	if (!pixmap && (is_glamor_pixmap || attachment != DRI2BufferFrontLeft)) {
-		if (aligned_width == front_width)
-			aligned_width = pScrn->virtualX;
-
-		pixmap = (*pScreen->CreatePixmap) (pScreen,
-						   aligned_width,
-						   height,
-						   depth,
-						   AMDGPU_CREATE_PIXMAP_DRI2);
-	}
+	if (!pixmap && (glamor || attachment != DRI2BufferFrontLeft)) {
+		/* Use virtual width if attachment equals screen width to avoid realloc */
+		if (aw == front_w)
+			aw = (unsigned)pScrn->virtualX;
 
+		pixmap = (*pScreen->CreatePixmap)(pScreen, aw, h, depth,
+		                                  AMDGPU_CREATE_PIXMAP_DRI2);
+	}
 	if (!pixmap)
 		return NULL;
 
-	buffers = calloc(1, sizeof *buffers);
-	if (!buffers)
-		goto error;
-
-	if (is_glamor_pixmap) {
-		pixmap = amdgpu_glamor_set_pixmap_bo(drawable, pixmap);
+	/* Unified allocation for DRI2BufferRec + private */
+	buf  = (BufferPtr)calloc(1, sizeof(DRI2BufferRec) + sizeof(struct dri2_buffer_priv));
+	if (!buf)
+		goto err;
+
+	priv = (struct dri2_buffer_priv *)((char *)buf + sizeof(DRI2BufferRec));
+	buf->driverPrivate = priv;
+
+	/* If glamor redirect was requested, bind BO to drawable */
+	if (glamor) {
+		PixmapPtr new_pixmap = amdgpu_glamor_set_pixmap_bo(drawable, pixmap);
+		if (!new_pixmap)
+			goto err;
+		pixmap = new_pixmap;
 		pixmap->refcnt++;
-
-		/* The copy operation from amdgpu_glamor_set_pixmap_bo needs to
-		 * be flushed to the kernel driver before the client starts
-		 * using the pixmap storage for direct rendering.
-		 */
 		amdgpu_glamor_flush(pScrn);
 	}
 
-	if (!amdgpu_get_flink_name(pAMDGPUEnt, pixmap, &buffers->name))
-		goto error;
+	if (!amdgpu_get_flink_name(pEnt, pixmap, &buf->name))
+		goto err;
 
-	privates = calloc(1, sizeof(struct dri2_buffer_priv));
-	if (!privates)
-		goto error;
-
-	buffers->attachment = attachment;
-	buffers->pitch = pixmap->devKind;
-	buffers->cpp = cpp;
-	buffers->driverPrivate = privates;
-	buffers->format = format;
-	buffers->flags = 0;	/* not tiled */
-	privates->pixmap = pixmap;
-	privates->attachment = attachment;
-	privates->refcnt = 1;
-
-	return buffers;
-
-error:
-	free(buffers);
-	(*pScreen->DestroyPixmap) (pixmap);
+	buf->attachment = attachment;
+	buf->pitch      = (uint32_t)pixmap->devKind;
+	buf->cpp        = (uint32_t)cpp;
+	buf->format     = format;
+	buf->flags      = 0;
+
+	priv->pixmap     = pixmap;
+	priv->attachment = attachment;
+	priv->refcnt     = 1;
+	return buf;
+
+err:
+	if (buf)
+		free(buf);
+	if (pixmap)
+		dixDestroyPixmap(pixmap, 0);
 	return NULL;
 }
 
-static void
-amdgpu_dri2_destroy_buffer2(ScreenPtr pScreen,
-			    DrawablePtr drawable, BufferPtr buffers)
-{
-	if (buffers) {
-		struct dri2_buffer_priv *private = buffers->driverPrivate;
-
-		/* Trying to free an already freed buffer is unlikely to end well */
-		if (private->refcnt == 0) {
-			ScrnInfoPtr scrn = xf86ScreenToScrn(pScreen);
-
-			xf86DrvMsg(scrn->scrnIndex, X_WARNING,
-				   "Attempted to destroy previously destroyed buffer.\
- This is a programming error\n");
-			return;
-		}
+static AMDGPU_HOT void
+amdgpu_dri2_destroy_buffer2(ScreenPtr pScreen, DrawablePtr drawable, BufferPtr buf)
+{
+	(void)pScreen;
+	(void)drawable;
 
-		private->refcnt--;
-		if (private->refcnt == 0) {
-			if (private->pixmap)
-				(*pScreen->DestroyPixmap) (private->pixmap);
+	if (!buf)
+		return;
 
-			free(buffers->driverPrivate);
-			free(buffers);
-		}
+	struct dri2_buffer_priv *priv = (struct dri2_buffer_priv *)buf->driverPrivate;
+	if (!priv)
+		return;
+
+	if (priv->refcnt == 0) {
+		xf86DrvMsg(xf86ScreenToScrn(((PixmapPtr)NULL)->drawable.pScreen)->scrnIndex,
+		           X_WARNING, "DRI2 buffer double-free attempt ignored.\n");
+		return;
+	}
+
+	if (--priv->refcnt == 0) {
+		if (priv->pixmap)
+			dixDestroyPixmap(priv->pixmap, 0);
+		free(buf);
 	}
 }
 
-static inline PixmapPtr GetDrawablePixmap(DrawablePtr drawable)
+static GCPtr gc_cache[MAX_GC_DEPTH + 1][GC_CACHE_PER_DEPTH];
+static int   gc_cache_cnt[MAX_GC_DEPTH + 1];
+
+static AMDGPU_HOT GCPtr cached_GetScratchGC(unsigned depth, ScreenPtr s)
+{
+	if (depth <= MAX_GC_DEPTH && gc_cache_cnt[depth] > 0)
+		return gc_cache[depth][--gc_cache_cnt[depth]];
+	return GetScratchGC(depth, s);
+}
+static AMDGPU_HOT void cached_FreeScratchGC(GCPtr gc)
 {
-	if (drawable->type == DRAWABLE_PIXMAP)
-		return (PixmapPtr) drawable;
-	else {
-		struct _Window *pWin = (struct _Window *)drawable;
-		return drawable->pScreen->GetWindowPixmap(pWin);
+	if (!gc)
+		return;
+	unsigned d = (unsigned)gc->depth;
+	if (d <= MAX_GC_DEPTH && gc_cache_cnt[d] < GC_CACHE_PER_DEPTH) {
+		gc_cache[d][gc_cache_cnt[d]++] = gc;
+	} else {
+		FreeScratchGC(gc);
 	}
 }
 
-static void
-amdgpu_dri2_copy_region2(ScreenPtr pScreen,
-			 DrawablePtr drawable,
-			 RegionPtr region,
-			 BufferPtr dest_buffer, BufferPtr src_buffer)
-{
-	struct dri2_buffer_priv *src_private = src_buffer->driverPrivate;
-	struct dri2_buffer_priv *dst_private = dest_buffer->driverPrivate;
-	DrawablePtr src_drawable;
-	DrawablePtr dst_drawable;
-	RegionPtr copy_clip;
-	GCPtr gc;
-	Bool translate = FALSE;
-	int off_x = 0, off_y = 0;
+static AMDGPU_HOT inline PixmapPtr GetDrawablePixmap(DrawablePtr d)
+{
+	if (d->type == DRAWABLE_PIXMAP)
+		return (PixmapPtr)d;
+	return d->pScreen->GetWindowPixmap((WindowPtr)d);
+}
 
-	src_drawable = &src_private->pixmap->drawable;
-	dst_drawable = &dst_private->pixmap->drawable;
+static AMDGPU_HOT void
+amdgpu_dri2_copy_region2(ScreenPtr pScreen, DrawablePtr drawable,
+                         RegionPtr region_ptr, BufferPtr dst_buf,
+                         BufferPtr src_buf)
+{
+	struct dri2_buffer_priv *srcp = src_buf ? (struct dri2_buffer_priv *)src_buf->driverPrivate : NULL;
+	struct dri2_buffer_priv *dstp = dst_buf ? (struct dri2_buffer_priv *)dst_buf->driverPrivate : NULL;
+	if (!srcp || !dstp || !srcp->pixmap || !dstp->pixmap)
+		return;
+
+	DrawablePtr src_draw = &srcp->pixmap->drawable;
+	DrawablePtr dst_draw = &dstp->pixmap->drawable;
+	Bool translate = FALSE;
+	int  off_x = 0, off_y = 0;
 
-	if (src_private->attachment == DRI2BufferFrontLeft) {
+	if (srcp->attachment == DRI2BufferFrontLeft) {
 		if (drawable->pScreen != pScreen) {
-			src_drawable = DRI2UpdatePrime(drawable, src_buffer);
-			if (!src_drawable)
+			src_draw = DRI2UpdatePrime(drawable, src_buf);
+			if (!src_draw)
 				return;
-		} else
-			src_drawable = drawable;
+		} else {
+			src_draw = drawable;
+		}
 	}
-	if (dst_private->attachment == DRI2BufferFrontLeft) {
+	if (dstp->attachment == DRI2BufferFrontLeft) {
 		if (drawable->pScreen != pScreen) {
-			dst_drawable = DRI2UpdatePrime(drawable, dest_buffer);
-			if (!dst_drawable)
+			dst_draw = DRI2UpdatePrime(drawable, dst_buf);
+			if (!dst_draw)
 				return;
-			if (dst_drawable != drawable)
+			if (dst_draw != drawable)
 				translate = TRUE;
-		} else
-			dst_drawable = drawable;
+		} else {
+			dst_draw = drawable;
+		}
 	}
 
 	if (translate && drawable->type == DRAWABLE_WINDOW) {
-		PixmapPtr pPix = GetDrawablePixmap(drawable);
-
-		off_x = drawable->x - pPix->screen_x;
-		off_y = drawable->y - pPix->screen_y;
+		PixmapPtr winpx = GetDrawablePixmap(drawable);
+		off_x = drawable->x - winpx->screen_x;
+		off_y = drawable->y - winpx->screen_y;
 	}
-	gc = GetScratchGC(dst_drawable->depth, pScreen);
-	copy_clip = REGION_CREATE(pScreen, NULL, 0);
-	REGION_COPY(pScreen, copy_clip, region);
 
-	if (translate) {
-		REGION_TRANSLATE(pScreen, copy_clip, off_x, off_y);
-	}
+	/* Fastpath: region is full-surface */
+	const BoxPtr ext = RegionExtents(region_ptr);
+	const Bool full_surface = (RegionNumRects(region_ptr) == 1) &&
+	                          ext->x1 == 0 && ext->y1 == 0 &&
+	                          ext->x2 == drawable->width &&
+	                          ext->y2 == drawable->height;
 
-	(*gc->funcs->ChangeClip) (gc, CT_REGION, copy_clip, 0);
-	ValidateGC(dst_drawable, gc);
+	GCPtr gc = cached_GetScratchGC(dst_draw->depth, pScreen);
+	if (!gc)
+		return;
 
-	(*gc->ops->CopyArea) (src_drawable, dst_drawable, gc,
-			      0, 0, drawable->width, drawable->height, off_x,
-			      off_y);
+	if (full_surface) {
+		ValidateGC(dst_draw, gc);
+		(*gc->ops->CopyArea)(src_draw, dst_draw, gc,
+		                     0, 0, drawable->width, drawable->height,
+		                     off_x, off_y);
+		cached_FreeScratchGC(gc);
+		return;
+	}
 
-	FreeScratchGC(gc);
-}
+	/* General case: build clip from region */
+	RegionPtr clip = RegionCreate(NULL, 0);
+	if (!clip) {
+		cached_FreeScratchGC(gc);
+		return;
+	}
+	RegionCopy(clip, region_ptr);
+	if (translate)
+		RegionTranslate(clip, off_x, off_y);
 
-enum DRI2FrameEventType {
-	DRI2_SWAP,
-	DRI2_FLIP,
-	DRI2_WAITMSC,
-};
+	(*gc->funcs->ChangeClip)(gc, CT_REGION, clip, 0);
+	ValidateGC(dst_draw, gc);
+	/* ChangeClip may adopt clip; do not destroy clip again here */
+	clip = NULL;
 
-typedef struct _DRI2FrameEvent {
-	XID drawable_id;
-	ClientPtr client;
-	enum DRI2FrameEventType type;
-	unsigned frame;
-	xf86CrtcPtr crtc;
-	OsTimerPtr timer;
-	uintptr_t drm_queue_seq;
+	(*gc->ops->CopyArea)(src_draw, dst_draw, gc,
+	                     0, 0, drawable->width, drawable->height,
+	                     off_x, off_y);
 
-	/* for swaps & flips only */
-	DRI2SwapEventPtr event_complete;
-	void *event_data;
-	DRI2BufferPtr front;
-	DRI2BufferPtr back;
-} DRI2FrameEventRec, *DRI2FrameEventPtr;
+	cached_FreeScratchGC(gc);
+	/* If ChangeClip didn't adopt (implementation-dependent), clip is NULL and this is a no-op */
+	if (clip)
+		RegionDestroy(clip);
+}
 
-static int DRI2InfoCnt;
+static AMDGPU_HOT void amdgpu_dri2_ref_buffer(BufferPtr b)
+{
+	if (likely(b && b->driverPrivate))
+		((struct dri2_buffer_priv *)b->driverPrivate)->refcnt++;
+}
 
-static void amdgpu_dri2_ref_buffer(BufferPtr buffer)
+static AMDGPU_HOT void amdgpu_dri2_unref_buffer(BufferPtr b)
 {
-	struct dri2_buffer_priv *private = buffer->driverPrivate;
-	private->refcnt++;
+	if (unlikely(!b || !b->driverPrivate))
+		return;
+	struct dri2_buffer_priv *p = (struct dri2_buffer_priv *)b->driverPrivate;
+	if (unlikely(!p->pixmap))
+		return;
+	DrawablePtr d = &p->pixmap->drawable;
+	amdgpu_dri2_destroy_buffer2(d->pScreen, d, b);
 }
 
-static void amdgpu_dri2_unref_buffer(BufferPtr buffer)
+static AMDGPU_COLD void
+amdgpu_dri2_frame_event_abort(xf86CrtcPtr crtc, void *event_data)
 {
-	if (buffer) {
-		struct dri2_buffer_priv *private = buffer->driverPrivate;
-		DrawablePtr draw = &private->pixmap->drawable;
+	(void)crtc;
+
+	DRI2FrameEventPtr event = (DRI2FrameEventPtr)event_data;
+	if (unlikely(!event))
+		return;
 
-		amdgpu_dri2_destroy_buffer2(draw->pScreen, draw, buffer);
+	if (event->timer) {
+		TimerCancel(event->timer);
+		TimerFree(event->timer);
+		event->timer = NULL;
 	}
+	amdgpu_dri2_unref_buffer(event->front);
+	amdgpu_dri2_unref_buffer(event->back);
+	frame_event_free(event);
 }
 
-static void
-amdgpu_dri2_client_state_changed(CallbackListPtr * ClientStateCallback,
-				 pointer data, pointer calldata)
+static AMDGPU_COLD void
+amdgpu_dri2_client_state_changed(CallbackListPtr *ClientStateCallback,
+                                 pointer data, pointer calldata)
 {
-	NewClientInfoRec *clientinfo = calldata;
-	ClientPtr pClient = clientinfo->client;
+	(void)ClientStateCallback;
+	(void)data;
 
+	NewClientInfoRec *clientinfo = (NewClientInfoRec *)calldata;
+	ClientPtr pClient = clientinfo->client;
 	switch (pClient->clientState) {
-	case ClientStateRetained:
-	case ClientStateGone:
-		amdgpu_drm_abort_client(pClient);
-		break;
-	default:
-		break;
+		case ClientStateRetained:
+		case ClientStateGone:
+			amdgpu_drm_abort_client(pClient);
+			break;
+		default:
+			break;
 	}
 }
 
-/*
- * Get current frame count delta for the specified drawable and CRTC
- */
-static uint32_t amdgpu_get_msc_delta(DrawablePtr pDraw, xf86CrtcPtr crtc)
+static AMDGPU_HOT uint32_t amdgpu_get_msc_delta(DrawablePtr pDraw, xf86CrtcPtr crtc)
 {
 	drmmode_crtc_private_ptr drmmode_crtc = crtc->driver_private;
-
-	if (pDraw && pDraw->type == DRAWABLE_WINDOW)
-		return drmmode_crtc->interpolated_vblanks +
-			get_dri2_window_priv((WindowPtr)pDraw)->vblank_delta;
-
-	return drmmode_crtc->interpolated_vblanks;
+	if (pDraw && pDraw->type == DRAWABLE_WINDOW) {
+		struct dri2_window_priv *wp = get_dri2_window_priv((WindowPtr)pDraw);
+		return (uint32_t)(drmmode_crtc->interpolated_vblanks + wp->vblank_delta);
+	}
+	return (uint32_t)drmmode_crtc->interpolated_vblanks;
 }
 
-/*
- * Get current frame count and timestamp of the specified CRTC
- */
-static Bool amdgpu_dri2_get_crtc_msc(xf86CrtcPtr crtc, CARD64 *ust, CARD64 *msc)
+static AMDGPU_HOT Bool amdgpu_dri2_get_crtc_msc(xf86CrtcPtr crtc, CARD64 *ust, CARD64 *msc)
 {
 	drmmode_crtc_private_ptr drmmode_crtc = crtc->driver_private;
 
-	if (!amdgpu_crtc_is_enabled(crtc) ||
-	    drmmode_crtc_get_ust_msc(crtc, ust, msc) != Success) {
-		/* CRTC is not running, extrapolate MSC and timestamp */
-		ScrnInfoPtr scrn = crtc->scrn;
-		AMDGPUEntPtr pAMDGPUEnt = AMDGPUEntPriv(scrn);
-		CARD64 now, delta_t, delta_seq;
-
-		if (!drmmode_crtc->dpms_last_ust)
-			return FALSE;
-
-		if (drmmode_get_current_ust(pAMDGPUEnt->fd, &now) != 0) {
-			xf86DrvMsg(scrn->scrnIndex, X_ERROR,
-				   "%s cannot get current time\n", __func__);
-			return FALSE;
-		}
+	/* Fast path: enabled CRTC and kernel can supply UST/MSC */
+	if (amdgpu_crtc_is_enabled(crtc) &&
+	    drmmode_crtc_get_ust_msc(crtc, ust, msc) == Success) {
+		*msc += drmmode_crtc->interpolated_vblanks;
+		return TRUE;
+	}
 
-		delta_t = now - drmmode_crtc->dpms_last_ust;
-		delta_seq = delta_t * drmmode_crtc->dpms_last_fps;
-		delta_seq /= 1000000;
-		*ust = drmmode_crtc->dpms_last_ust;
-		delta_t = delta_seq * 1000000;
-		delta_t /= drmmode_crtc->dpms_last_fps;
-		*ust += delta_t;
-		*msc = drmmode_crtc->dpms_last_seq;
-		*msc += delta_seq;
+	/* Fallback: DPMS off or not available; extrapolate from last DPMS timestamps */
+	ScrnInfoPtr scrn = crtc->scrn;
+	AMDGPUEntPtr pAMDGPUEnt = AMDGPUEntPriv(scrn);
+	CARD64 now = 0, delta_t = 0, delta_seq = 0;
+
+	if (unlikely(!drmmode_crtc->dpms_last_ust))
+		return FALSE;
+	if (unlikely(drmmode_crtc->dpms_last_fps == 0)) {
+		xf86DrvMsg(scrn->scrnIndex, X_WARNING, "%s: dpms_last_fps is zero.\n", __func__);
+		return FALSE;
+	}
+	if (unlikely(drmmode_get_current_ust(pAMDGPUEnt->fd, &now) != 0)) {
+		xf86DrvMsg(scrn->scrnIndex, X_ERROR, "%s: cannot get current time\n", __func__);
+		return FALSE;
 	}
 
-	*msc += drmmode_crtc->interpolated_vblanks;
+	delta_t  = now - drmmode_crtc->dpms_last_ust;
+	delta_seq = (delta_t * (CARD64)drmmode_crtc->dpms_last_fps) / 1000000ULL;
 
+	*ust = drmmode_crtc->dpms_last_ust;
+	/* Align ust to computed whole frames to keep UST and MSC consistent */
+	{
+		CARD64 adj_usec = (delta_seq * 1000000ULL) / (CARD64)drmmode_crtc->dpms_last_fps;
+		*ust += adj_usec;
+	}
+	*msc = drmmode_crtc->dpms_last_seq + delta_seq;
+	*msc += drmmode_crtc->interpolated_vblanks;
 	return TRUE;
 }
 
-static
-xf86CrtcPtr amdgpu_dri2_drawable_crtc(DrawablePtr pDraw)
+static AMDGPU_HOT xf86CrtcPtr amdgpu_dri2_drawable_crtc(DrawablePtr pDraw)
 {
 	ScreenPtr pScreen = pDraw->pScreen;
 	xf86CrtcPtr crtc = amdgpu_pick_best_crtc(pScreen,
-						 pDraw->x, pDraw->x + pDraw->width,
-						 pDraw->y, pDraw->y + pDraw->height);
+	                                         pDraw->x, pDraw->x + pDraw->width,
+	                                         pDraw->y, pDraw->y + pDraw->height);
 
 	if (pDraw->type == DRAWABLE_WINDOW) {
 		struct dri2_window_priv *priv = get_dri2_window_priv((WindowPtr)pDraw);
-
 		if (!crtc) {
 			crtc = priv->crtc;
 		} else if (priv->crtc && priv->crtc != crtc) {
 			CARD64 ust, mscold, mscnew;
-
 			if (amdgpu_dri2_get_crtc_msc(priv->crtc, &ust, &mscold) &&
-			    amdgpu_dri2_get_crtc_msc(crtc, &ust, &mscnew))
-				priv->vblank_delta += mscold - mscnew;
+			    amdgpu_dri2_get_crtc_msc(crtc,      &ust, &mscnew)) {
+				priv->vblank_delta += (int)(mscold - mscnew);
+			}
 		}
-
 		priv->crtc = crtc;
 	}
-
 	return crtc;
 }
 
-static void
-amdgpu_dri2_flip_event_abort(xf86CrtcPtr crtc, void *event_data)
+static AMDGPU_COLD void
+amdgpu_dri2_flip_event_abort_for_pageflip(xf86CrtcPtr crtc, void *event_data)
 {
-	if (crtc)
+	if (likely(crtc))
 		AMDGPUPTR(crtc->scrn)->drmmode.dri2_flipping = FALSE;
 
-	free(event_data);
+	DRI2FrameEventPtr event = (DRI2FrameEventPtr)event_data;
+	if (likely(event)) {
+		amdgpu_dri2_unref_buffer(event->front);
+		amdgpu_dri2_unref_buffer(event->back);
+		frame_event_free(event);
+	}
 }
 
-static void
-amdgpu_dri2_flip_event_handler(xf86CrtcPtr crtc, uint32_t frame, uint64_t usec,
-			       void *event_data)
-{
-	DRI2FrameEventPtr flip = event_data;
-	ScrnInfoPtr scrn = crtc->scrn;
-	unsigned tv_sec, tv_usec;
-	DrawablePtr drawable;
-	ScreenPtr screen;
-	int status;
-	PixmapPtr pixmap;
-
-	status = dixLookupDrawable(&drawable, flip->drawable_id, serverClient,
-				   M_ANY, DixWriteAccess);
-	if (status != Success)
-		goto abort;
+static AMDGPU_HOT void
+amdgpu_dri2_flip_event_handler(xf86CrtcPtr crtc, uint32_t frame,
+                               uint64_t usec, void *event_data)
+{
+	DRI2FrameEventPtr flip = (DRI2FrameEventPtr)event_data;
+	if (!flip)
+		return;
+
+	DrawablePtr drawable = NULL;
+	if (dixLookupDrawable(&drawable, flip->drawable_id, serverClient,
+	                      M_ANY, DixWriteAccess) != Success)
+		goto out;
 
 	frame += amdgpu_get_msc_delta(drawable, crtc);
-
-	screen = scrn->pScreen;
-	pixmap = screen->GetScreenPixmap(screen);
-	xf86DrvMsgVerb(scrn->scrnIndex, X_INFO, AMDGPU_LOGLEVEL_DEBUG,
-		       "%s:%d fevent[%p] width %d pitch %d (/4 %d)\n",
-		       __func__, __LINE__, flip, pixmap->drawable.width,
-		       pixmap->devKind, pixmap->devKind / 4);
-
-	tv_sec = usec / 1000000;
-	tv_usec = usec % 1000000;
-
-	/* We assume our flips arrive in order, so we don't check the frame */
-	switch (flip->type) {
-	case DRI2_SWAP:
-		/* Check for too small vblank count of pageflip completion, taking wraparound
-		 * into account. This usually means some defective kms pageflip completion,
-		 * causing wrong (msc, ust) return values and possible visual corruption.
-		 */
-		if ((frame < flip->frame) && (flip->frame - frame < 5)) {
-			xf86DrvMsg(scrn->scrnIndex, X_WARNING,
-				   "%s: Pageflip completion event has impossible msc %u < target_msc %u\n",
-				   __func__, frame, flip->frame);
-			/* All-Zero values signal failure of (msc, ust) timestamping to client. */
-			frame = tv_sec = tv_usec = 0;
-		}
-
-		DRI2SwapComplete(flip->client, drawable, frame, tv_sec, tv_usec,
-				 DRI2_FLIP_COMPLETE, flip->event_complete,
-				 flip->event_data);
-		break;
-	default:
-		xf86DrvMsg(scrn->scrnIndex, X_WARNING,
-			   "%s: unknown vblank event received\n", __func__);
-		/* Unknown type */
-		break;
-	}
-
-abort:
-	amdgpu_dri2_flip_event_abort(crtc, event_data);
+	DRI2SwapComplete(flip->client, drawable, frame,
+	                 usec / 1000000, usec % 1000000,
+	                 DRI2_FLIP_COMPLETE,
+	                 flip->event_complete, flip->event_data);
+
+out:
+	amdgpu_dri2_unref_buffer(flip->front);
+	amdgpu_dri2_unref_buffer(flip->back);
+	AMDGPUPTR(crtc->scrn)->drmmode.dri2_flipping = FALSE;
+	frame_event_free(flip);
 }
 
-static Bool
+static AMDGPU_HOT Bool
 amdgpu_dri2_schedule_flip(xf86CrtcPtr crtc, ClientPtr client,
-			  DrawablePtr draw, DRI2BufferPtr front,
-			  DRI2BufferPtr back, DRI2SwapEventPtr func,
-			  void *data, unsigned int target_msc)
+                          DrawablePtr draw, DRI2BufferPtr front,
+                          DRI2BufferPtr back, DRI2SwapEventPtr func,
+                          void *data, unsigned int target_msc)
 {
 	ScrnInfoPtr scrn = crtc->scrn;
 	AMDGPUInfoPtr info = AMDGPUPTR(scrn);
-	struct dri2_buffer_priv *back_priv;
-	DRI2FrameEventPtr flip_info;
+	struct dri2_buffer_priv *bp = (struct dri2_buffer_priv *)back->driverPrivate;
 
-	flip_info = calloc(1, sizeof(DRI2FrameEventRec));
-	if (!flip_info)
+	if (!bp || !bp->pixmap)
 		return FALSE;
 
-	flip_info->drawable_id = draw->id;
-	flip_info->client = client;
-	flip_info->type = DRI2_SWAP;
-	flip_info->event_complete = func;
-	flip_info->event_data = data;
-	flip_info->frame = target_msc;
-	flip_info->crtc = crtc;
-
-	xf86DrvMsgVerb(scrn->scrnIndex, X_INFO, AMDGPU_LOGLEVEL_DEBUG,
-		       "%s:%d fevent[%p]\n", __func__, __LINE__, flip_info);
-
-	/* Page flip the full screen buffer */
-	back_priv = back->driverPrivate;
-	if (amdgpu_do_pageflip(scrn, client, back_priv->pixmap,
-			       AMDGPU_DRM_QUEUE_ID_DEFAULT, flip_info, crtc,
-			       amdgpu_dri2_flip_event_handler,
-			       amdgpu_dri2_flip_event_abort, FLIP_VSYNC,
-			       target_msc - amdgpu_get_msc_delta(draw, crtc))) {
+	DRI2FrameEventPtr ev = frame_event_alloc();
+	if (!ev)
+		return FALSE;
+
+	ev->drawable_id    = draw->id;
+	ev->client         = client;
+	ev->type           = DRI2_FLIP;
+	ev->event_complete = func;
+	ev->event_data     = data;
+	ev->frame          = target_msc;
+	ev->crtc           = crtc;
+	ev->front          = front;
+	ev->back           = back;
+
+	if (amdgpu_do_pageflip(scrn, client, bp->pixmap,
+	                       AMDGPU_DRM_QUEUE_ID_DEFAULT, ev, crtc,
+	                       amdgpu_dri2_flip_event_handler,
+	                       amdgpu_dri2_flip_event_abort_for_pageflip,
+	                       FLIP_VSYNC,
+	                       target_msc - amdgpu_get_msc_delta(draw, crtc))) {
 		info->drmmode.dri2_flipping = TRUE;
 		return TRUE;
 	}
-	return FALSE;
-}
-
-static Bool update_front(DrawablePtr draw, DRI2BufferPtr front)
-{
-	ScreenPtr screen = draw->pScreen;
-	ScrnInfoPtr scrn = xf86ScreenToScrn(screen);
-	AMDGPUEntPtr pAMDGPUEnt = AMDGPUEntPriv(scrn);
-	PixmapPtr pixmap = get_drawable_pixmap(draw);
-	struct dri2_buffer_priv *priv = front->driverPrivate;
 
-	if (!amdgpu_get_flink_name(pAMDGPUEnt, pixmap, &front->name))
-		return FALSE;
-
-	(*draw->pScreen->DestroyPixmap) (priv->pixmap);
-	front->pitch = pixmap->devKind;
-	front->cpp = pixmap->drawable.bitsPerPixel / 8;
-	priv->pixmap = pixmap;
-	pixmap->refcnt++;
-
-	return TRUE;
+	/* Page-flip submission failed → clean up only our event; caller still owns buffers */
+	frame_event_free(ev);
+	return FALSE;
 }
 
-static Bool
+static AMDGPU_HOT Bool
 can_exchange(ScrnInfoPtr pScrn, DrawablePtr draw,
-	     DRI2BufferPtr front, DRI2BufferPtr back)
+             DRI2BufferPtr front, DRI2BufferPtr back)
 {
-	struct dri2_buffer_priv *front_priv = front->driverPrivate;
-	struct dri2_buffer_priv *back_priv = back->driverPrivate;
-	PixmapPtr front_pixmap;
-	PixmapPtr back_pixmap = back_priv->pixmap;
-
-	if (!update_front(draw, front))
-		return FALSE;
+	struct dri2_buffer_priv *bp = (struct dri2_buffer_priv *)back->driverPrivate;
 
-	front_pixmap = front_priv->pixmap;
-
-	if (front_pixmap->drawable.width != back_pixmap->drawable.width)
-		return FALSE;
-
-	if (front_pixmap->drawable.height != back_pixmap->drawable.height)
+	if (!bp || !bp->pixmap)
 		return FALSE;
-
-	if (front_pixmap->drawable.bitsPerPixel !=
-	    back_pixmap->drawable.bitsPerPixel)
+	if (!update_front(draw, front))
 		return FALSE;
 
-	if (front_pixmap->devKind != back_pixmap->devKind)
-		return FALSE;
+	struct dri2_buffer_priv *fp = (struct dri2_buffer_priv *)front->driverPrivate;
+	PixmapPtr fpx = fp->pixmap;
+	PixmapPtr bpx = bp->pixmap;
 
-	return TRUE;
+	return fpx->drawable.width  == bpx->drawable.width  &&
+	       fpx->drawable.height == bpx->drawable.height &&
+	       fpx->drawable.bitsPerPixel == bpx->drawable.bitsPerPixel &&
+	       fpx->devKind == bpx->devKind;
 }
 
-static Bool
+static AMDGPU_HOT Bool
 can_flip(xf86CrtcPtr crtc, DrawablePtr draw,
-	 DRI2BufferPtr front, DRI2BufferPtr back)
+         DRI2BufferPtr front, DRI2BufferPtr back)
 {
 	ScrnInfoPtr pScrn = crtc->scrn;
 	AMDGPUInfoPtr info = AMDGPUPTR(pScrn);
 	xf86CrtcConfigPtr config = XF86_CRTC_CONFIG_PTR(pScrn);
-	int num_crtcs_on;
-	int i;
+	int num_crtcs_on = 0;
 
-	if (draw->type != DRAWABLE_WINDOW ||
-	    !info->allowPageFlip ||
-	    info->sprites_visible > 0 ||
-	    info->drmmode.present_flipping ||
-	    !pScrn->vtSema ||
-	    !DRI2CanFlip(draw))
+	if (unlikely(draw->type != DRAWABLE_WINDOW ||
+	             !info->allowPageFlip || info->sprites_visible > 0 ||
+	             info->drmmode.present_flipping || !pScrn->vtSema ||
+	             !DRI2CanFlip(draw)))
 		return FALSE;
 
-	for (i = 0, num_crtcs_on = 0; i < config->num_crtc; i++) {
-		if (drmmode_crtc_can_flip(config->crtc[i]))
+	for (int i = 0; i < config->num_crtc; i++) {
+		if (likely(config->crtc[i] != NULL && drmmode_crtc_can_flip(config->crtc[i])))
 			num_crtcs_on++;
 	}
-
-	return num_crtcs_on > 0 && can_exchange(pScrn, draw, front, back);
+	return likely(num_crtcs_on > 0 && can_exchange(pScrn, draw, front, back));
 }
 
-static void
+static AMDGPU_HOT void
 amdgpu_dri2_exchange_buffers(DrawablePtr draw, DRI2BufferPtr front,
-			     DRI2BufferPtr back)
+                             DRI2BufferPtr back)
 {
-	struct dri2_buffer_priv *front_priv = front->driverPrivate;
-	struct dri2_buffer_priv *back_priv = back->driverPrivate;
-	struct amdgpu_pixmap *front_pix;
-	struct amdgpu_pixmap *back_pix;
-	ScreenPtr screen;
-	AMDGPUInfoPtr info;
-	RegionRec region;
-	int tmp;
-
-	region.extents.x1 = region.extents.y1 = 0;
-	region.extents.x2 = front_priv->pixmap->drawable.width;
-	region.extents.y2 = front_priv->pixmap->drawable.height;
-	region.data = NULL;
-	DamageRegionAppend(&front_priv->pixmap->drawable, &region);
-
-	/* Swap BO names so DRI works */
-	tmp = front->name;
-	front->name = back->name;
-	back->name = tmp;
-
-	/* Swap pixmap privates */
-	front_pix = amdgpu_get_pixmap_private(front_priv->pixmap);
-	back_pix = amdgpu_get_pixmap_private(back_priv->pixmap);
-	amdgpu_set_pixmap_private(front_priv->pixmap, back_pix);
-	amdgpu_set_pixmap_private(back_priv->pixmap, front_pix);
-
-	/* Do we need to update the Screen? */
-	screen = draw->pScreen;
-	info = AMDGPUPTR(xf86ScreenToScrn(screen));
-	if (front_pix->bo == info->front_buffer) {
-		struct amdgpu_pixmap *screen_priv =
-			amdgpu_get_pixmap_private(screen->GetScreenPixmap(screen));
+	struct dri2_buffer_priv *fp = (struct dri2_buffer_priv *)front->driverPrivate;
+	struct dri2_buffer_priv *bp = (struct dri2_buffer_priv *)back->driverPrivate;
+	if (!fp || !bp || !fp->pixmap || !bp->pixmap)
+		return;
 
-		amdgpu_bo_ref(back_pix->bo);
+	RegionRec region;
+	region.extents.x1 = 0;
+	region.extents.y1 = 0;
+	region.extents.x2 = fp->pixmap->drawable.width;
+	region.extents.y2 = fp->pixmap->drawable.height;
+	region.data       = NULL;
+	DamageRegionAppend(&fp->pixmap->drawable, &region);
+
+	uint32_t tmp = front->name;
+	front->name   = back->name;
+	back->name    = tmp;
+
+	struct amdgpu_pixmap *fpx = amdgpu_get_pixmap_private(fp->pixmap);
+	struct amdgpu_pixmap *bpx = amdgpu_get_pixmap_private(bp->pixmap);
+	amdgpu_set_pixmap_private(fp->pixmap, bpx);
+	amdgpu_set_pixmap_private(bp->pixmap, fpx);
+
+	ScreenPtr      s    = draw->pScreen;
+	AMDGPUInfoPtr  info = AMDGPUPTR(xf86ScreenToScrn(s));
+	if (fpx && fpx->bo == info->front_buffer && bpx && bpx->bo) {
+		struct amdgpu_pixmap *scrpriv = amdgpu_get_pixmap_private(s->GetScreenPixmap(s));
+		amdgpu_bo_ref(bpx->bo);
 		amdgpu_bo_unref(&info->front_buffer);
-		info->front_buffer = back_pix->bo;
-		*screen_priv = *back_pix;
+		info->front_buffer = bpx->bo;
+		if (scrpriv)
+			*scrpriv = *bpx;
 	}
 
-	amdgpu_glamor_exchange_buffers(front_priv->pixmap, back_priv->pixmap);
-
-	DamageRegionProcessPending(&front_priv->pixmap->drawable);
+	amdgpu_glamor_exchange_buffers(fp->pixmap, bp->pixmap);
+	DamageRegionProcessPending(&fp->pixmap->drawable);
 }
 
-static void amdgpu_dri2_frame_event_abort(xf86CrtcPtr crtc, void *event_data)
+static AMDGPU_HOT void amdgpu_dri2_frame_event_handler(xf86CrtcPtr crtc, uint32_t seq,
+                                                       uint64_t usec, void *event_data)
 {
-	DRI2FrameEventPtr event = event_data;
-
-	TimerCancel(event->timer);
-	TimerFree(event->timer);
-	amdgpu_dri2_unref_buffer(event->front);
-	amdgpu_dri2_unref_buffer(event->back);
-	free(event);
-}
-
-static void amdgpu_dri2_frame_event_handler(xf86CrtcPtr crtc, uint32_t seq,
-					    uint64_t usec, void *event_data)
-{
-	DRI2FrameEventPtr event = event_data;
-	ScrnInfoPtr scrn = crtc->scrn;
+	DRI2FrameEventPtr event = (DRI2FrameEventPtr)event_data;
+	ScrnInfoPtr scrn;
 	DrawablePtr drawable;
 	int status;
 	int swap_type;
 	BoxRec box;
-	RegionRec region;
+	RegionRec local_region_obj;
 
-	status = dixLookupDrawable(&drawable, event->drawable_id, serverClient,
-				   M_ANY, DixWriteAccess);
-	if (status != Success)
-		goto cleanup;
+	if (unlikely(!event))
+		return;
+	scrn = crtc->scrn;
+
+	status = dixLookupDrawable(&drawable, event->drawable_id, serverClient, M_ANY, DixWriteAccess);
+	if (unlikely(status != Success))
+		goto cleanup_event;
 
 	seq += amdgpu_get_msc_delta(drawable, crtc);
 
 	switch (event->type) {
-	case DRI2_FLIP:
-		if (can_flip(crtc, drawable, event->front, event->back) &&
-		    amdgpu_dri2_schedule_flip(crtc,
-					      event->client,
-					      drawable,
-					      event->front,
-					      event->back,
-					      event->event_complete,
-					      event->event_data,
-					      event->frame)) {
-			amdgpu_dri2_exchange_buffers(drawable, event->front,
-						     event->back);
+		case DRI2_FLIP:
+			if (likely(can_flip(crtc, drawable, event->front, event->back) &&
+			           amdgpu_dri2_schedule_flip(crtc, event->client, drawable,
+			                                     event->front, event->back,
+			                                     event->event_complete, event->event_data,
+			                                     event->frame))) {
+				amdgpu_dri2_exchange_buffers(drawable, event->front, event->back);
+				break;
+			}
+			/* fallthrough */
+		case DRI2_SWAP:
+			if (likely(DRI2CanExchange(drawable) &&
+			           can_exchange(scrn, drawable, event->front, event->back))) {
+				amdgpu_dri2_exchange_buffers(drawable, event->front, event->back);
+				swap_type = DRI2_EXCHANGE_COMPLETE;
+			} else {
+				box.x1 = 0; box.y1 = 0;
+				box.x2 = drawable->width; box.y2 = drawable->height;
+				RegionInit(&local_region_obj, &box, 0);
+				amdgpu_dri2_copy_region2(drawable->pScreen, drawable, &local_region_obj,
+				                         event->front, event->back);
+				RegionUninit(&local_region_obj);
+				swap_type = DRI2_BLIT_COMPLETE;
+			}
+			DRI2SwapComplete(event->client, drawable, seq, usec / 1000000,
+			                 usec % 1000000, swap_type, event->event_complete, event->event_data);
+			break;
+		case DRI2_WAITMSC:
+			DRI2WaitMSCComplete(event->client, drawable, seq, usec / 1000000, usec % 1000000);
+			break;
+		default:
+			xf86DrvMsg(scrn->scrnIndex, X_WARNING, "%s: unknown vblank event received\n", __func__);
 			break;
-		}
-		/* else fall through to exchange/blit */
-	case DRI2_SWAP:
-		if (DRI2CanExchange(drawable) &&
-		    can_exchange(scrn, drawable, event->front, event->back)) {
-			amdgpu_dri2_exchange_buffers(drawable, event->front,
-						     event->back);
-			swap_type = DRI2_EXCHANGE_COMPLETE;
-		} else {
-			box.x1 = 0;
-			box.y1 = 0;
-			box.x2 = drawable->width;
-			box.y2 = drawable->height;
-			REGION_INIT(pScreen, &region, &box, 0);
-			amdgpu_dri2_copy_region2(drawable->pScreen, drawable, &region,
-						 event->front, event->back);
-			swap_type = DRI2_BLIT_COMPLETE;
-		}
-
-		DRI2SwapComplete(event->client, drawable, seq, usec / 1000000,
-				 usec % 1000000, swap_type, event->event_complete,
-				 event->event_data);
-
-		break;
-	case DRI2_WAITMSC:
-		DRI2WaitMSCComplete(event->client, drawable, seq, usec / 1000000,
-				    usec % 1000000);
-		break;
-	default:
-		/* Unknown type */
-		xf86DrvMsg(scrn->scrnIndex, X_WARNING,
-			   "%s: unknown vblank event received\n", __func__);
-		break;
 	}
 
-cleanup:
+cleanup_event:
 	amdgpu_dri2_frame_event_abort(crtc, event_data);
 }
 
-/*
- * This function should be called on a disabled CRTC only (i.e., CRTC
- * in DPMS-off state). It will calculate the delay necessary to reach
- * target_msc from present time if the CRTC were running.
- */
-static
-CARD32 amdgpu_dri2_extrapolate_msc_delay(xf86CrtcPtr crtc, CARD64 * target_msc,
-					 CARD64 divisor, CARD64 remainder)
+static AMDGPU_HOT CARD32 amdgpu_dri2_extrapolate_msc_delay(xf86CrtcPtr crtc, CARD64 *target_msc,
+                                                           CARD64 divisor, CARD64 remainder)
 {
 	drmmode_crtc_private_ptr drmmode_crtc = crtc->driver_private;
 	ScrnInfoPtr pScrn = crtc->scrn;
 	AMDGPUEntPtr pAMDGPUEnt = AMDGPUEntPriv(pScrn);
-	int nominal_frame_rate = drmmode_crtc->dpms_last_fps;
 	CARD64 last_vblank_ust = drmmode_crtc->dpms_last_ust;
 	uint32_t last_vblank_seq = drmmode_crtc->dpms_last_seq;
-	CARD64 now, target_time, delta_t;
-	int64_t d, delta_seq;
+	CARD64 now, target_time_calc, delta_t_calc;
+	int64_t d, delta_seq_calc_signed;
 	int ret;
 	CARD32 d_ms;
+	uint64_t fps_recip = 0;
+	int nominal_frame_rate = drmmode_crtc->dpms_last_fps;
 
-	if (!last_vblank_ust) {
+	if (unlikely(!last_vblank_ust)) {
+		*target_msc = 0;
+		return FALLBACK_SWAP_DELAY;
+	}
+	if (unlikely(nominal_frame_rate == 0)) {
+		xf86DrvMsg(pScrn->scrnIndex, X_WARNING, "%s: nominal_frame_rate is zero.\n", __func__);
 		*target_msc = 0;
 		return FALLBACK_SWAP_DELAY;
 	}
+	fps_recip = (1ULL << 32) / (uint64_t)nominal_frame_rate;
+
 	ret = drmmode_get_current_ust(pAMDGPUEnt->fd, &now);
-	if (ret) {
-		xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
-			   "%s cannot get current time\n", __func__);
+	if (unlikely(ret)) {
+		xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "%s: cannot get current time\n", __func__);
 		*target_msc = 0;
 		return FALLBACK_SWAP_DELAY;
 	}
-	delta_seq = *target_msc - last_vblank_seq;
-	delta_seq *= 1000000;
-	target_time = last_vblank_ust;
-	target_time += delta_seq / nominal_frame_rate;
-	d = target_time - now;
+
+	delta_seq_calc_signed = (int64_t)(*target_msc - (CARD64)last_vblank_seq);
+	delta_seq_calc_signed *= 1000000;
+	target_time_calc = last_vblank_ust + (delta_seq_calc_signed / (CARD64)nominal_frame_rate);
+	d = (int64_t)(target_time_calc - now);
+
 	if (d < 0) {
-		/* we missed the event, adjust target_msc, do the divisor magic */
 		CARD64 current_msc = last_vblank_seq;
+		delta_t_calc = now - last_vblank_ust;
+		delta_seq_calc_signed = (int64_t)((delta_t_calc * fps_recip) >> 32);
+		current_msc += (CARD64)delta_seq_calc_signed;
+		current_msc &= 0xffffffffULL;
 
-		delta_t = now - last_vblank_ust;
-		delta_seq = delta_t * nominal_frame_rate;
-		current_msc += delta_seq / 1000000;
-		current_msc &= 0xffffffff;
 		if (divisor == 0) {
 			*target_msc = current_msc;
 			d = 0;
 		} else {
-			*target_msc =
-			    current_msc - (current_msc % divisor) + remainder;
+			*target_msc = current_msc - (current_msc % divisor) + remainder;
 			if ((current_msc % divisor) >= remainder)
 				*target_msc += divisor;
-			*target_msc &= 0xffffffff;
-			delta_seq = *target_msc - last_vblank_seq;
-			delta_seq *= 1000000;
-			target_time = last_vblank_ust;
-			target_time += delta_seq / nominal_frame_rate;
-			d = target_time - now;
+			*target_msc &= 0xffffffffULL;
+
+			delta_seq_calc_signed = (int64_t)(*target_msc - (CARD64)last_vblank_seq);
+			delta_seq_calc_signed *= 1000000;
+			target_time_calc = last_vblank_ust + (delta_seq_calc_signed / (CARD64)nominal_frame_rate);
+			d = (int64_t)(target_time_calc - now);
 		}
 	}
-	/*
-	 * convert delay to milliseconds and add margin to prevent the client
-	 * from coming back early (due to timer granularity and rounding
-	 * errors) and getting the same MSC it just got
-	 */
-	d_ms = (CARD32) d / 1000;
-	if ((CARD32) d - d_ms * 1000 > 0)
+	d_ms = (CARD32)((uint64_t)(d < 0 ? 0 : d) / 1000ULL);
+	/* Ensure we wake a smidge after target (avoid off-by-one frame) */
+	if (((CARD32)(d - (int64_t)d_ms * 1000)) > 0)
 		d_ms += 2;
 	else
 		d_ms++;
 	return d_ms;
 }
 
-/*
- * Get current interpolated frame count and frame count timestamp, based on
- * drawable's crtc.
- */
-static int amdgpu_dri2_get_msc(DrawablePtr draw, CARD64 * ust, CARD64 * msc)
+static AMDGPU_HOT int amdgpu_dri2_get_msc(DrawablePtr draw, CARD64 *ust, CARD64 *msc)
 {
 	xf86CrtcPtr crtc = amdgpu_dri2_drawable_crtc(draw);
-
-	/* Drawable not displayed, make up a value */
-	if (!crtc) {
+	if (unlikely(!crtc)) {
 		*ust = 0;
 		*msc = 0;
 		return TRUE;
 	}
-
-	if (!amdgpu_dri2_get_crtc_msc(crtc, ust, msc))
+	if (unlikely(!amdgpu_dri2_get_crtc_msc(crtc, ust, msc)))
 		return FALSE;
 
 	if (draw && draw->type == DRAWABLE_WINDOW)
 		*msc += get_dri2_window_priv((WindowPtr)draw)->vblank_delta;
-	*msc &= 0xffffffff;
+
+	*msc &= 0xffffffffULL;
 	return TRUE;
 }
 
-static
-CARD32 amdgpu_dri2_deferred_event(OsTimerPtr timer, CARD32 now, pointer data)
+static AMDGPU_HOT CARD32 amdgpu_dri2_deferred_event(OsTimerPtr timer, CARD32 now_timer, pointer data)
 {
-	DRI2FrameEventPtr event_info = (DRI2FrameEventPtr) data;
-	xf86CrtcPtr crtc = event_info->crtc;
+	(void)timer;
+	(void)now_timer;
+
+	DRI2FrameEventPtr event_info = (DRI2FrameEventPtr)data;
+	xf86CrtcPtr crtc;
 	ScrnInfoPtr scrn;
 	AMDGPUEntPtr pAMDGPUEnt;
 	CARD64 drm_now;
 	int ret;
-	CARD64 delta_t, delta_seq, frame;
-	drmmode_crtc_private_ptr drmmode_crtc;
+	CARD64 delta_t_calc, frame_val;
+	int64_t delta_seq_calc_signed;
+	drmmode_crtc_private_ptr drmmode_crtc_priv;
+	uint64_t fps_recip = 0;
+
+	if (unlikely(!event_info))
+		return 0;
+	crtc = event_info->crtc;
 
-	/*
-	 * This is emulated event, so its time is current time, which we
-	 * have to get in DRM-compatible form (which is a bit messy given
-	 * the information that we have at this point). Can't use now argument
-	 * because DRM event time may come from monotonic clock, while
-	 * DIX timer facility uses real-time clock.
-	 */
-	if (!event_info->crtc) {
-		ErrorF("%s no crtc\n", __func__);
+	if (unlikely(!crtc)) {
+		ErrorF("%s: no crtc\n", __func__);
 		if (event_info->drm_queue_seq)
 			amdgpu_drm_abort_entry(event_info->drm_queue_seq);
 		else
 			amdgpu_dri2_frame_event_abort(NULL, data);
 		return 0;
 	}
-
 	scrn = crtc->scrn;
 	pAMDGPUEnt = AMDGPUEntPriv(scrn);
-	drmmode_crtc = event_info->crtc->driver_private;
-	ret = drmmode_get_current_ust(pAMDGPUEnt->fd, &drm_now);
-	if (ret) {
-		xf86DrvMsg(scrn->scrnIndex, X_ERROR,
-			   "%s cannot get current time\n", __func__);
+	drmmode_crtc_priv = crtc->driver_private;
 
+	ret = drmmode_get_current_ust(pAMDGPUEnt->fd, &drm_now);
+	if (unlikely(ret)) {
+		xf86DrvMsg(scrn->scrnIndex, X_ERROR, "%s: cannot get current time\n", __func__);
 		if (event_info->drm_queue_seq) {
-			drmmode_crtc->drmmode->event_context.
-				vblank_handler(pAMDGPUEnt->fd, 0, 0, 0,
-					       (void*)event_info->drm_queue_seq);
-			drmmode_crtc->wait_flip_nesting_level++;
+			drmmode_crtc_priv->drmmode->event_context.vblank_handler(pAMDGPUEnt->fd,
+			                                                         0, 0, 0,
+			                                                         (void*)event_info->drm_queue_seq);
+			drmmode_crtc_priv->wait_flip_nesting_level++;
 			amdgpu_drm_queue_handle_deferred(crtc);
-
 		} else {
 			amdgpu_dri2_frame_event_handler(crtc, 0, 0, data);
 		}
-
 		return 0;
 	}
-	/*
-	 * calculate the frame number from current time
-	 * that would come from CRTC if it were running
-	 */
-	delta_t = drm_now - (CARD64) drmmode_crtc->dpms_last_ust;
-	delta_seq = delta_t * drmmode_crtc->dpms_last_fps;
-	delta_seq /= 1000000;
-	frame = (CARD64) drmmode_crtc->dpms_last_seq + delta_seq;
+
+	if (unlikely(drmmode_crtc_priv->dpms_last_fps == 0)) {
+		xf86DrvMsg(scrn->scrnIndex, X_WARNING, "%s: dpms_last_fps is zero.\n", __func__);
+		frame_val = (CARD64)drmmode_crtc_priv->dpms_last_seq;
+	} else {
+		fps_recip = (1ULL << 32) / (uint64_t)drmmode_crtc_priv->dpms_last_fps;
+		delta_t_calc = drm_now - (CARD64)drmmode_crtc_priv->dpms_last_ust;
+		delta_seq_calc_signed = (int64_t)((delta_t_calc * fps_recip) >> 32);
+		frame_val = (CARD64)drmmode_crtc_priv->dpms_last_seq + (CARD64)delta_seq_calc_signed;
+	}
 
 	if (event_info->drm_queue_seq) {
-		drmmode_crtc->drmmode->event_context.
-			vblank_handler(pAMDGPUEnt->fd, frame, drm_now / 1000000,
-				       drm_now % 1000000,
-				       (void*)event_info->drm_queue_seq);
-		drmmode_crtc->wait_flip_nesting_level++;
+		drmmode_crtc_priv->drmmode->event_context.vblank_handler(pAMDGPUEnt->fd,
+		                                                         frame_val,
+		                                                         drm_now / 1000000ULL,
+		                                                         drm_now % 1000000ULL,
+		                                                         (void*)event_info->drm_queue_seq);
+		drmmode_crtc_priv->wait_flip_nesting_level++;
 		amdgpu_drm_queue_handle_deferred(crtc);
 	} else {
-		amdgpu_dri2_frame_event_handler(crtc, frame, drm_now, data);
+		amdgpu_dri2_frame_event_handler(crtc, (uint32_t)frame_val, drm_now, data);
 	}
-
 	return 0;
 }
 
-static
-void amdgpu_dri2_schedule_event(CARD32 delay, DRI2FrameEventPtr event_info)
+static AMDGPU_HOT void amdgpu_dri2_schedule_event(CARD32 delay, DRI2FrameEventPtr event_info)
 {
-	event_info->timer = TimerSet(NULL, 0, delay, amdgpu_dri2_deferred_event,
-				     event_info);
+	event_info->timer = TimerSet(NULL, 0, delay, amdgpu_dri2_deferred_event, event_info);
 	if (delay == 0) {
-		CARD32 now = GetTimeInMillis();
-		amdgpu_dri2_deferred_event(event_info->timer, now, event_info);
+		CARD32 current_time_ms = GetTimeInMillis();
+		amdgpu_dri2_deferred_event(event_info->timer, current_time_ms, event_info);
 	}
 }
 
-/*
- * Request a DRM event when the requested conditions will be satisfied.
- *
- * We need to handle the event and ask the server to wake up the client when
- * we receive it.
- */
-static int amdgpu_dri2_schedule_wait_msc(ClientPtr client, DrawablePtr draw,
-					 CARD64 target_msc, CARD64 divisor,
-					 CARD64 remainder)
+static AMDGPU_HOT int amdgpu_dri2_schedule_wait_msc(ClientPtr client, DrawablePtr draw,
+                                                    CARD64 target_msc_in, CARD64 divisor_in,
+                                                    CARD64 remainder_in)
 {
 	ScreenPtr screen = draw->pScreen;
 	ScrnInfoPtr scrn = xf86ScreenToScrn(screen);
@@ -951,149 +1076,96 @@ static int amdgpu_dri2_schedule_wait_msc
 	uint32_t msc_delta;
 	uint32_t seq;
 	CARD64 current_msc;
+	CARD64 target_msc = target_msc_in;
+	CARD64 divisor    = divisor_in;
+	CARD64 remainder  = remainder_in;
+
+	target_msc &= 0xffffffffULL;
+	divisor    &= 0xffffffffULL;
+	remainder  &= 0xffffffffULL;
 
-	/* Truncate to match kernel interfaces; means occasional overflow
-	 * misses, but that's generally not a big deal */
-	target_msc &= 0xffffffff;
-	divisor &= 0xffffffff;
-	remainder &= 0xffffffff;
-
-	/* Drawable not visible, return immediately */
-	if (!crtc)
-		goto out_complete;
+	if (unlikely(!crtc))
+		goto out_complete_no_alloc;
 
 	msc_delta = amdgpu_get_msc_delta(draw, crtc);
-
-	wait_info = calloc(1, sizeof(DRI2FrameEventRec));
-	if (!wait_info)
-		goto out_complete;
+	wait_info = frame_event_alloc();
+	if (unlikely(!wait_info))
+		goto out_complete_no_alloc;
 
 	wait_info->drawable_id = draw->id;
-	wait_info->client = client;
-	wait_info->type = DRI2_WAITMSC;
-	wait_info->crtc = crtc;
-
-	/*
-	 * CRTC is in DPMS off state, calculate wait time from current time,
-	 * target_msc and last vblank time/sequence when CRTC was turned off
-	 */
-	if (!amdgpu_crtc_is_enabled(crtc)) {
+	wait_info->client      = client;
+	wait_info->type        = DRI2_WAITMSC;
+	wait_info->crtc        = crtc;
+
+	if (unlikely(!amdgpu_crtc_is_enabled(crtc))) {
 		CARD32 delay;
 		target_msc -= msc_delta;
-		delay = amdgpu_dri2_extrapolate_msc_delay(crtc, &target_msc,
-							  divisor, remainder);
+		delay = amdgpu_dri2_extrapolate_msc_delay(crtc, &target_msc, divisor, remainder);
 		amdgpu_dri2_schedule_event(delay, wait_info);
 		DRI2BlockClient(client, draw);
 		return TRUE;
 	}
-
-	/* Get current count */
-	if (!drmmode_wait_vblank(crtc, DRM_VBLANK_RELATIVE, 0, 0, NULL, &seq)) {
-		xf86DrvMsg(scrn->scrnIndex, X_WARNING,
-			   "get vblank counter failed: %s\n", strerror(errno));
-		goto out_complete;
+	if (unlikely(!drmmode_wait_vblank(crtc, DRM_VBLANK_RELATIVE, 0, 0, NULL, &seq))) {
+		xf86DrvMsg(scrn->scrnIndex, X_WARNING, "get vblank counter failed: %s\n", strerror(errno));
+		goto out_complete_with_alloc;
 	}
-
-	current_msc = seq + msc_delta;
-	current_msc &= 0xffffffff;
+	current_msc = (CARD64)seq + (CARD64)msc_delta;
+	current_msc &= 0xffffffffULL;
 
 	drm_queue_seq = amdgpu_drm_queue_alloc(crtc, client, AMDGPU_DRM_QUEUE_ID_DEFAULT,
-					       wait_info, amdgpu_dri2_frame_event_handler,
-					       amdgpu_dri2_frame_event_abort, FALSE);
-	if (drm_queue_seq == AMDGPU_DRM_QUEUE_ERROR) {
-		xf86DrvMsg(scrn->scrnIndex, X_WARNING,
-			   "Allocating DRM queue event entry failed.\n");
-		goto out_complete;
+	                                       wait_info, amdgpu_dri2_frame_event_handler,
+	                                       amdgpu_dri2_frame_event_abort, FALSE);
+	if (unlikely(drm_queue_seq == AMDGPU_DRM_QUEUE_ERROR)) {
+		xf86DrvMsg(scrn->scrnIndex, X_WARNING, "Allocating DRM queue event entry failed.\n");
+		goto out_complete_with_alloc;
 	}
 	wait_info->drm_queue_seq = drm_queue_seq;
 
-	/*
-	 * If divisor is zero, or current_msc is smaller than target_msc,
-	 * we just need to make sure target_msc passes  before waking up the
-	 * client.
-	 */
 	if (divisor == 0 || current_msc < target_msc) {
-		/* If target_msc already reached or passed, set it to
-		 * current_msc to ensure we return a reasonable value back
-		 * to the caller. This keeps the client from continually
-		 * sending us MSC targets from the past by forcibly updating
-		 * their count on this call.
-		 */
 		if (current_msc >= target_msc)
 			target_msc = current_msc;
-		if (!drmmode_wait_vblank(crtc, DRM_VBLANK_ABSOLUTE | DRM_VBLANK_EVENT,
-					 target_msc - msc_delta, drm_queue_seq, NULL,
-					 NULL)) {
-			xf86DrvMsg(scrn->scrnIndex, X_WARNING,
-				   "get vblank counter failed: %s\n",
-				   strerror(errno));
-			goto out_complete;
-		}
 
+		if (unlikely(!drmmode_wait_vblank(crtc, DRM_VBLANK_ABSOLUTE | DRM_VBLANK_EVENT,
+		                                  (uint32_t)(target_msc - (CARD64)msc_delta),
+		                                  drm_queue_seq, NULL, NULL))) {
+			xf86DrvMsg(scrn->scrnIndex, X_WARNING, "get vblank counter failed: %s\n", strerror(errno));
+			amdgpu_drm_abort_entry(drm_queue_seq);
+			wait_info = NULL;
+			goto out_complete_no_alloc;
+		}
 		DRI2BlockClient(client, draw);
 		return TRUE;
 	}
 
-	/*
-	 * If we get here, target_msc has already passed or we don't have one,
-	 * so we queue an event that will satisfy the divisor/remainder equation.
-	 */
 	target_msc = current_msc - (current_msc % divisor) + remainder - msc_delta;
-
-	/*
-	 * If calculated remainder is larger than requested remainder,
-	 * it means we've passed the last point where
-	 * seq % divisor == remainder, so we need to wait for the next time
-	 * that will happen.
-	 */
 	if ((current_msc % divisor) >= remainder)
 		target_msc += divisor;
 
-	if (!drmmode_wait_vblank(crtc, DRM_VBLANK_ABSOLUTE | DRM_VBLANK_EVENT,
-				 target_msc, drm_queue_seq, NULL, NULL)) {
-		xf86DrvMsg(scrn->scrnIndex, X_WARNING,
-			   "get vblank counter failed: %s\n", strerror(errno));
-		goto out_complete;
+	if (unlikely(!drmmode_wait_vblank(crtc, DRM_VBLANK_ABSOLUTE | DRM_VBLANK_EVENT,
+	                                  (uint32_t)target_msc, drm_queue_seq, NULL, NULL))) {
+		xf86DrvMsg(scrn->scrnIndex, X_WARNING, "get vblank counter failed: %s\n", strerror(errno));
+		amdgpu_drm_abort_entry(drm_queue_seq);
+		wait_info = NULL;
+		goto out_complete_no_alloc;
 	}
-
 	DRI2BlockClient(client, draw);
-
 	return TRUE;
 
-out_complete:
+out_complete_with_alloc:
 	if (wait_info)
 		amdgpu_dri2_deferred_event(NULL, 0, wait_info);
-	else
-		DRI2WaitMSCComplete(client, draw, 0, 0, 0);
+	return TRUE;
 
+out_complete_no_alloc:
+	if (!wait_info)
+		DRI2WaitMSCComplete(client, draw, 0, 0, 0);
 	return TRUE;
 }
 
-/*
- * ScheduleSwap is responsible for requesting a DRM vblank event for the
- * appropriate frame.
- *
- * In the case of a blit (e.g. for a windowed swap) or buffer exchange,
- * the vblank requested can simply be the last queued swap frame + the swap
- * interval for the drawable.
- *
- * In the case of a page flip, we request an event for the last queued swap
- * frame + swap interval - 1, since we'll need to queue the flip for the frame
- * immediately following the received event.
- *
- * The client will be blocked if it tries to perform further GL commands
- * after queueing a swap, though in the Intel case after queueing a flip, the
- * client is free to queue more commands; they'll block in the kernel if
- * they access buffers busy with the flip.
- *
- * When the swap is complete, the driver should call into the server so it
- * can send any swap complete events that have been requested.
- */
-static int amdgpu_dri2_schedule_swap(ClientPtr client, DrawablePtr draw,
-				     DRI2BufferPtr front, DRI2BufferPtr back,
-				     CARD64 * target_msc, CARD64 divisor,
-				     CARD64 remainder, DRI2SwapEventPtr func,
-				     void *data)
+static AMDGPU_HOT int amdgpu_dri2_schedule_swap(ClientPtr client, DrawablePtr draw,
+                                                DRI2BufferPtr front, DRI2BufferPtr back,
+                                                CARD64 *target_msc_inout, CARD64 divisor_in,
+                                                CARD64 remainder_in, DRI2SwapEventPtr func, void *data)
 {
 	ScreenPtr screen = draw->pScreen;
 	ScrnInfoPtr scrn = xf86ScreenToScrn(screen);
@@ -1103,273 +1175,244 @@ static int amdgpu_dri2_schedule_swap(Cli
 	uint32_t seq;
 	int flip = 0;
 	DRI2FrameEventPtr swap_info = NULL;
-	uintptr_t drm_queue_seq;
+	uintptr_t drm_queue_seq = 0;
 	CARD64 current_msc, event_msc;
 	BoxRec box;
-	RegionRec region;
+	RegionRec local_region_obj;
+	CARD64 target_msc_local = *target_msc_inout;
+	CARD64 divisor   = divisor_in;
+	CARD64 remainder = remainder_in;
+
+	target_msc_local &= 0xffffffffULL;
+	divisor          &= 0xffffffffULL;
+	remainder        &= 0xffffffffULL;
 
-	/* Truncate to match kernel interfaces; means occasional overflow
-	 * misses, but that's generally not a big deal */
-	*target_msc &= 0xffffffff;
-	divisor &= 0xffffffff;
-	remainder &= 0xffffffff;
-
-	/* amdgpu_dri2_frame_event_handler will get called some unknown time in the
-	 * future with these buffers.  Take a reference to ensure that they won't
-	 * get destroyed before then.
-	 */
 	amdgpu_dri2_ref_buffer(front);
 	amdgpu_dri2_ref_buffer(back);
 
-	/* either off-screen or CRTC not usable... just complete the swap */
-	if (!crtc)
-		goto blit_fallback;
+	if (unlikely(!crtc))
+		goto blit_fallback_no_alloc;
 
 	msc_delta = amdgpu_get_msc_delta(draw, crtc);
-
-	swap_info = calloc(1, sizeof(DRI2FrameEventRec));
-	if (!swap_info)
-		goto blit_fallback;
-
-	swap_info->type = DRI2_SWAP;
-	swap_info->drawable_id = draw->id;
-	swap_info->client = client;
+	swap_info = frame_event_alloc();
+	if (unlikely(!swap_info))
+		goto blit_fallback_no_alloc;
+
+	swap_info->type           = DRI2_SWAP;
+	swap_info->drawable_id    = draw->id;
+	swap_info->client         = client;
 	swap_info->event_complete = func;
-	swap_info->event_data = data;
-	swap_info->front = front;
-	swap_info->back = back;
-	swap_info->crtc = crtc;
+	swap_info->event_data     = data;
+	swap_info->front          = front;
+	swap_info->back           = back;
+	swap_info->crtc           = crtc;
 
 	drm_queue_seq = amdgpu_drm_queue_alloc(crtc, client, AMDGPU_DRM_QUEUE_ID_DEFAULT,
-					       swap_info, amdgpu_dri2_frame_event_handler,
-					       amdgpu_dri2_frame_event_abort, FALSE);
-	if (drm_queue_seq == AMDGPU_DRM_QUEUE_ERROR) {
-		xf86DrvMsg(scrn->scrnIndex, X_WARNING,
-			   "Allocating DRM queue entry failed.\n");
-		goto blit_fallback;
+	                                       swap_info, amdgpu_dri2_frame_event_handler,
+	                                       amdgpu_dri2_frame_event_abort, FALSE);
+	if (unlikely(drm_queue_seq == AMDGPU_DRM_QUEUE_ERROR)) {
+		xf86DrvMsg(scrn->scrnIndex, X_WARNING, "Allocating DRM queue event entry failed.\n");
+		goto blit_fallback_with_alloc;
 	}
 	swap_info->drm_queue_seq = drm_queue_seq;
 
-	/*
-	 * CRTC is in DPMS off state, fallback to blit, but calculate
-	 * wait time from current time, target_msc and last vblank
-	 * time/sequence when CRTC was turned off
-	 */
-	if (!amdgpu_crtc_is_enabled(crtc)) {
+	if (unlikely(!amdgpu_crtc_is_enabled(crtc))) {
 		CARD32 delay;
-		*target_msc -= msc_delta;
-		delay = amdgpu_dri2_extrapolate_msc_delay(crtc, target_msc,
-							  divisor, remainder);
-		*target_msc += msc_delta;
-		*target_msc &= 0xffffffff;
+		target_msc_local -= msc_delta;
+		delay = amdgpu_dri2_extrapolate_msc_delay(crtc, &target_msc_local, divisor, remainder);
+		target_msc_local += msc_delta;
+		target_msc_local &= 0xffffffffULL;
 		amdgpu_dri2_schedule_event(delay, swap_info);
+		*target_msc_inout = target_msc_local;
 		return TRUE;
 	}
-
-	/* Get current count */
-	if (!drmmode_wait_vblank(crtc, DRM_VBLANK_RELATIVE, 0, 0, NULL, &seq)) {
-		xf86DrvMsg(scrn->scrnIndex, X_WARNING,
-			   "first get vblank counter failed: %s\n",
-			   strerror(errno));
-		goto blit_fallback;
+	if (unlikely(!drmmode_wait_vblank(crtc, DRM_VBLANK_RELATIVE, 0, 0, NULL, &seq))) {
+		xf86DrvMsg(scrn->scrnIndex, X_WARNING, "first get vblank counter failed: %s\n", strerror(errno));
+		amdgpu_drm_abort_entry(drm_queue_seq);
+		swap_info = NULL;
+		goto blit_fallback_no_alloc;
 	}
+	current_msc = (CARD64)seq + (CARD64)msc_delta;
+	current_msc &= 0xffffffffULL;
 
-	current_msc = seq + msc_delta;
-	current_msc &= 0xffffffff;
-
-	/* Flips need to be submitted one frame before */
-	if (can_flip(crtc, draw, front, back)) {
+	if (likely(can_flip(crtc, draw, front, back))) {
 		swap_info->type = DRI2_FLIP;
 		flip = 1;
 	}
 
-	/* Correct target_msc by 'flip' if swap_info->type == DRI2_FLIP.
-	 * Do it early, so handling of different timing constraints
-	 * for divisor, remainder and msc vs. target_msc works.
-	 */
-	if (*target_msc > 0)
-		*target_msc -= flip;
-
-	/*
-	 * If divisor is zero, or current_msc is smaller than target_msc
-	 * we just need to make sure target_msc passes before initiating
-	 * the swap.
-	 */
-	if (divisor == 0 || current_msc < *target_msc) {
+	if (target_msc_local > 0)
+		target_msc_local -= (CARD64)flip;
+
+	if (divisor == 0 || current_msc < target_msc_local) {
 		type = DRM_VBLANK_ABSOLUTE | DRM_VBLANK_EVENT;
-		/* If non-pageflipping, but blitting/exchanging, we need to use
-		 * DRM_VBLANK_NEXTONMISS to avoid unreliable timestamping later
-		 * on.
-		 */
 		if (flip == 0)
 			type |= DRM_VBLANK_NEXTONMISS;
 
-		/* If target_msc already reached or passed, set it to
-		 * current_msc to ensure we return a reasonable value back
-		 * to the caller. This makes swap_interval logic more robust.
-		 */
-		if (current_msc >= *target_msc)
-			*target_msc = current_msc;
+		if (current_msc >= target_msc_local)
+			target_msc_local = current_msc;
 
-		if (!drmmode_wait_vblank(crtc, type, *target_msc - msc_delta,
-					 drm_queue_seq, NULL, &seq)) {
-			xf86DrvMsg(scrn->scrnIndex, X_WARNING,
-				   "divisor 0 get vblank counter failed: %s\n",
-				   strerror(errno));
-			goto blit_fallback;
+		if (unlikely(!drmmode_wait_vblank(crtc, type,
+		                                  (uint32_t)(target_msc_local - (CARD64)msc_delta),
+		                                  drm_queue_seq, NULL, &seq))) {
+			xf86DrvMsg(scrn->scrnIndex, X_WARNING, "divisor 0 get vblank counter failed: %s\n", strerror(errno));
+			amdgpu_drm_abort_entry(drm_queue_seq);
+			swap_info = NULL;
+			goto blit_fallback_no_alloc;
 		}
-
-		*target_msc = seq + flip + msc_delta;
-		*target_msc &= 0xffffffff;
-		swap_info->frame = *target_msc;
-
+		target_msc_local = (CARD64)seq + (CARD64)flip + (CARD64)msc_delta;
+		target_msc_local &= 0xffffffffULL;
+		swap_info->frame = (unsigned)target_msc_local;
+		*target_msc_inout = target_msc_local;
 		return TRUE;
 	}
 
-	/*
-	 * If we get here, target_msc has already passed or we don't have one,
-	 * and we need to queue an event that will satisfy the divisor/remainder
-	 * equation.
-	 */
 	type = DRM_VBLANK_ABSOLUTE | DRM_VBLANK_EVENT;
 	if (flip == 0)
 		type |= DRM_VBLANK_NEXTONMISS;
 
 	event_msc = current_msc - (current_msc % divisor) + remainder - msc_delta;
-
-	/*
-	 * If the calculated deadline vbl.request.sequence is smaller than
-	 * or equal to current_msc, it means we've passed the last point
-	 * when effective onset frame seq could satisfy
-	 * seq % divisor == remainder, so we need to wait for the next time
-	 * this will happen.
-
-	 * This comparison takes the 1 frame swap delay in pageflipping mode
-	 * into account, as well as a potential DRM_VBLANK_NEXTONMISS delay
-	 * if we are blitting/exchanging instead of flipping.
-	 */
 	if (event_msc <= current_msc)
 		event_msc += divisor;
+	event_msc -= (CARD64)flip;
 
-	/* Account for 1 frame extra pageflip delay if flip > 0 */
-	event_msc -= flip;
-
-	if (!drmmode_wait_vblank(crtc, type, event_msc, drm_queue_seq, NULL, &seq)) {
-		xf86DrvMsg(scrn->scrnIndex, X_WARNING,
-			   "final get vblank counter failed: %s\n",
-			   strerror(errno));
-		goto blit_fallback;
-	}
-
-	/* Adjust returned value for 1 fame pageflip offset of flip > 0 */
-	*target_msc = seq + flip + msc_delta;
-	*target_msc &= 0xffffffff;
-	swap_info->frame = *target_msc;
-
+	if (unlikely(!drmmode_wait_vblank(crtc, type, (uint32_t)event_msc,
+	                                  drm_queue_seq, NULL, &seq))) {
+		xf86DrvMsg(scrn->scrnIndex, X_WARNING, "final get vblank counter failed: %s\n", strerror(errno));
+		amdgpu_drm_abort_entry(drm_queue_seq);
+		swap_info = NULL;
+		goto blit_fallback_no_alloc;
+	}
+	target_msc_local = (CARD64)seq + (CARD64)flip + (CARD64)msc_delta;
+	target_msc_local &= 0xffffffffULL;
+	swap_info->frame = (unsigned)target_msc_local;
+	*target_msc_inout = target_msc_local;
 	return TRUE;
 
-blit_fallback:
+blit_fallback_with_alloc:
 	if (swap_info) {
+		/* We have an allocated event; schedule a short deferred event to complete via BLIT */
 		swap_info->type = DRI2_SWAP;
 		amdgpu_dri2_schedule_event(FALLBACK_SWAP_DELAY, swap_info);
-	} else {
-		box.x1 = 0;
-		box.y1 = 0;
-		box.x2 = draw->width;
-		box.y2 = draw->height;
-		REGION_INIT(pScreen, &region, &box, 0);
-
-		amdgpu_dri2_copy_region2(draw->pScreen, draw, &region, front, back);
-
-		DRI2SwapComplete(client, draw, 0, 0, 0, DRI2_BLIT_COMPLETE, func, data);
-
-		amdgpu_dri2_unref_buffer(front);
-		amdgpu_dri2_unref_buffer(back);
 	}
+	goto end_blit_fallback;
+
+blit_fallback_no_alloc:
+	box.x1 = 0; box.y1 = 0; box.x2 = draw->width; box.y2 = draw->height;
+	RegionInit(&local_region_obj, &box, 0);
+	amdgpu_dri2_copy_region2(draw->pScreen, draw, &local_region_obj, front, back);
+	RegionUninit(&local_region_obj);
+	DRI2SwapComplete(client, draw, 0, 0, 0, DRI2_BLIT_COMPLETE, func, data);
+	amdgpu_dri2_unref_buffer(front);
+	amdgpu_dri2_unref_buffer(back);
 
-	*target_msc = 0;	/* offscreen, so zero out target vblank count */
+end_blit_fallback:
+	*target_msc_inout = 0;
 	return TRUE;
 }
 
-Bool amdgpu_dri2_screen_init(ScreenPtr pScreen)
+AMDGPU_COLD Bool amdgpu_dri2_screen_init(ScreenPtr pScreen)
 {
 	ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
 	AMDGPUInfoPtr info = AMDGPUPTR(pScrn);
 	AMDGPUEntPtr pAMDGPUEnt = AMDGPUEntPriv(pScrn);
-	DRI2InfoRec dri2_info = { 0 };
+	DRI2InfoRec dri2_info;
 	const char *driverNames[2];
 	Bool scheduling_works = TRUE;
 
-	if (!info->dri2.available)
+	if (unlikely(!info->dri2.available))
 		return FALSE;
 
 	info->dri2.device_name = drmGetDeviceNameFromFd(pAMDGPUEnt->fd);
+	if (unlikely(!info->dri2.device_name)) {
+		xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "Failed to get device name from DRM FD.\n");
+		return FALSE;
+	}
 
+	memset(&dri2_info, 0, sizeof(dri2_info));
 	dri2_info.driverName = SI_DRIVER_NAME;
 	dri2_info.fd = pAMDGPUEnt->fd;
 	dri2_info.deviceName = info->dri2.device_name;
 
 	if (info->drmmode.count_crtcs > 2) {
-		uint64_t cap_value;
-
-		if (drmGetCap
-		    (pAMDGPUEnt->fd, DRM_CAP_VBLANK_HIGH_CRTC, &cap_value)) {
+		uint64_t cap_value = 0;
+		if (unlikely(drmGetCap(pAMDGPUEnt->fd, DRM_CAP_VBLANK_HIGH_CRTC, &cap_value))) {
 			xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
-				   "You need a newer kernel "
-				   "for VBLANKs on CRTC > 1\n");
+			           "You need a newer kernel for VBLANKs on CRTC > 1\n");
 			scheduling_works = FALSE;
-		} else if (!cap_value) {
+		} else if (unlikely(!cap_value)) {
 			xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
-				   "Your kernel does not "
-				   "handle VBLANKs on CRTC > 1\n");
+			           "Your kernel does not handle VBLANKs on CRTC > 1\n");
 			scheduling_works = FALSE;
 		}
 	}
-
-	if (scheduling_works) {
-		dri2_info.ScheduleSwap = amdgpu_dri2_schedule_swap;
-		dri2_info.GetMSC = amdgpu_dri2_get_msc;
-		dri2_info.ScheduleWaitMSC = amdgpu_dri2_schedule_wait_msc;
-		dri2_info.numDrivers = ARRAY_SIZE(driverNames);
-		dri2_info.driverNames = driverNames;
+	if (likely(scheduling_works)) {
+		dri2_info.ScheduleSwap   = amdgpu_dri2_schedule_swap;
+		dri2_info.GetMSC         = amdgpu_dri2_get_msc;
+		dri2_info.ScheduleWaitMSC= amdgpu_dri2_schedule_wait_msc;
+		dri2_info.numDrivers     = 2;
+		dri2_info.driverNames    = driverNames;
 		driverNames[0] = driverNames[1] = dri2_info.driverName;
 
-		if (DRI2InfoCnt == 0) {
-			if (!dixRegisterPrivateKey(dri2_window_private_key,
-						   PRIVATE_WINDOW,
-						   sizeof(struct dri2_window_priv))) {
-				xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
-					   "Failed to get DRI2 window private\n");
+		if (unlikely(DRI2InfoCnt == 0)) {
+			if (unlikely(!dixRegisterPrivateKey(dri2_window_private_key, PRIVATE_WINDOW,
+			                                    sizeof(struct dri2_window_priv)))) {
+				xf86DrvMsg(pScrn->scrnIndex, X_WARNING, "Failed to get DRI2 window private\n");
 				return FALSE;
 			}
-
-			AddCallback(&ClientStateCallback,
-				    amdgpu_dri2_client_state_changed, 0);
+			AddCallback(&ClientStateCallback, amdgpu_dri2_client_state_changed, 0);
 		}
-
 		DRI2InfoCnt++;
 	}
-
-	dri2_info.version = 9;
-	dri2_info.CreateBuffer2 = amdgpu_dri2_create_buffer2;
-	dri2_info.DestroyBuffer2 = amdgpu_dri2_destroy_buffer2;
-	dri2_info.CopyRegion2 = amdgpu_dri2_copy_region2;
+	dri2_info.version      = 9;
+	dri2_info.CreateBuffer2= amdgpu_dri2_create_buffer2;
+	dri2_info.DestroyBuffer2= amdgpu_dri2_destroy_buffer2;
+	dri2_info.CopyRegion2  = amdgpu_dri2_copy_region2;
 
 	info->dri2.enabled = DRI2ScreenInit(pScreen, &dri2_info);
 	return info->dri2.enabled;
 }
 
-void amdgpu_dri2_close_screen(ScreenPtr pScreen)
+AMDGPU_COLD void amdgpu_dri2_close_screen(ScreenPtr pScreen)
 {
 	ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
 	AMDGPUInfoPtr info = AMDGPUPTR(pScrn);
 
 	if (--DRI2InfoCnt == 0)
-		DeleteCallback(&ClientStateCallback,
-			       amdgpu_dri2_client_state_changed, 0);
+		DeleteCallback(&ClientStateCallback, amdgpu_dri2_client_state_changed, 0);
+
+	/* Free frame event free-list */
+	gl_lock();
+	DRI2FrameEventPtr curr = fe_free_list;
+	while (curr) {
+		DRI2FrameEventPtr next_ev = curr->next;
+		free(curr);
+		curr = next_ev;
+	}
+	fe_free_list = NULL;
+	fe_free_list_length = 0;
+	gl_unlock();
+
+	/* Free any cached GCs */
+	for (int d = 0; d <= MAX_GC_DEPTH; ++d) {
+		for (int i = 0; i < gc_cache_cnt[d]; ++i) {
+			if (gc_cache[d][i])
+				FreeScratchGC(gc_cache[d][i]);
+		}
+		gc_cache_cnt[d] = 0;
+	}
+
+	/* Reset flink cache */
+	gl_lock();
+	memset(flink_cache, 0, sizeof(flink_cache));
+	flink_cache_idx = 0;
+	flink_mru.valid = FALSE;
+	gl_unlock();
 
 	DRI2CloseScreen(pScreen);
-	drmFree(info->dri2.device_name);
+	if (info->dri2.device_name) {
+		drmFree(info->dri2.device_name);
+		info->dri2.device_name = NULL;
+	}
 }
 
 #endif /* DRI2 */
