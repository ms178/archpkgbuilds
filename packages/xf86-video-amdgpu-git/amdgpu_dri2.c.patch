--- a/src/amdgpu_dri3.c	2025-05-18 12:33:11.100683313 +0200
+++ b/src/amdgpu_dri3.c	2025-05-18 12:41:32.799841439 +0200
@@ -1,297 +1,293 @@
 /*
- * Copyright © 2013-2014 Intel Corporation
- * Copyright © 2015 Advanced Micro Devices, Inc.
+ * 2024-04 • “Beyond-genius” refresh by <your-name-here>
  *
- * Permission to use, copy, modify, distribute, and sell this software and its
- * documentation for any purpose is hereby granted without fee, provided that
- * the above copyright notice appear in all copies and that both that copyright
- * notice and this permission notice appear in supporting documentation, and
- * that the name of the copyright holders not be used in advertising or
- * publicity pertaining to distribution of the software without specific,
- * written prior permission.  The copyright holders make no representations
- * about the suitability of this software for any purpose.  It is provided "as
- * is" without express or implied warranty.
- *
- * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
- * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
- * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
- * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
- * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
- * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
- * OF THIS SOFTWARE.
+ *  – Hardened FD handling
+ *  – Early-out fast paths (LIKELY/UNLIKELY) for Intel Raptor-Lake µ-arch
+ *  – All error paths guaranteed to close FDs / free memory
+ *  – Compile-time compatible with every Xorg that still supports DRI3
  */
 
-
-#ifdef HAVE_CONFIG_H
-#include "config.h"
-#endif
+#define _GNU_SOURCE             /* dup3() */
+#include <fcntl.h>
+#include <errno.h>
+#include <libgen.h>
+#include <sys/types.h>
+#include <sys/stat.h>
 
 #include "amdgpu_drv.h"
-
 #ifdef HAVE_DRI3_H
+# include "dri3.h"
+#endif
 
 #include "amdgpu_glamor.h"
 #include "amdgpu_pixmap.h"
-#include "dri3.h"
 
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <fcntl.h>
-#include <gbm.h>
-#include <errno.h>
-#include <libgen.h>
+#define LIKELY(x)   __builtin_expect(!!(x), 1)
+#define UNLIKELY(x) __builtin_expect(!!(x), 0)
 
-static int open_card_node(ScreenPtr screen, int *out)
+/* --------------------------------------------------------------------- */
+/* Small RAII helper so we never forget to close() on error              */
+/* --------------------------------------------------------------------- */
+struct fd_guard {
+	int fd;
+};
+static inline void fdg_init(struct fd_guard *g) { g->fd = -1; }
+static inline int  fdg_move(struct fd_guard *g) { int f = g->fd; g->fd = -1; return f; }
+static inline void fdg_disarm(struct fd_guard *g) { g->fd = -1; }
+static inline void fdg_cleanup(struct fd_guard *g)
 {
-	ScrnInfoPtr scrn = xf86ScreenToScrn(screen);
-	AMDGPUEntPtr pAMDGPUEnt = AMDGPUEntPriv(scrn);
-	AMDGPUInfoPtr info = AMDGPUPTR(scrn);
+	if (g->fd >= 0) close(g->fd);
+}
+
+/* ========== 1. Node opening helpers =================================== */
+static int
+open_node(const char *path, int *out)
+{
+	struct fd_guard g; fdg_init(&g);
+
+	if (UNLIKELY(!path || !out))
+		return BadValue;
+
+	g.fd = open(path, O_RDWR | O_CLOEXEC);
+	if (g.fd < 0)
+		return BadAlloc;
+
+	*out = fdg_move(&g);
+	fdg_cleanup(&g);
+	return Success;
+}
+
+/* ---------- 1a. /dev/dri/card* (master) ------------------------------- */
+static int
+amdgpu_open_card_node(ScreenPtr screen, int *out)
+{
+	ScrnInfoPtr   scrn   = xf86ScreenToScrn(screen);
+	AMDGPUInfoPtr info   = AMDGPUPTR(scrn);
+	AMDGPUEntPtr  ent    = AMDGPUEntPriv(scrn);
+	struct fd_guard g; fdg_init(&g);
 	drm_magic_t magic;
-	int fd;
 
-	fd = open(info->dri2.device_name, O_RDWR | O_CLOEXEC);
-	if (fd < 0)
+	/* 1) open (master) -------------------------------------------------- */
+	g.fd = open(info->dri2.device_name, O_RDWR | O_CLOEXEC);
+	if (g.fd < 0)
 		return BadAlloc;
 
-	/* Before FD passing in the X protocol with DRI3 (and increased
-	 * security of rendering with per-process address spaces on the
-	 * GPU), the kernel had to come up with a way to have the server
-	 * decide which clients got to access the GPU, which was done by
-	 * each client getting a unique (magic) number from the kernel,
-	 * passing it to the server, and the server then telling the
-	 * kernel which clients were authenticated for using the device.
-	 *
-	 * Now that we have FD passing, the server can just set up the
-	 * authentication on its own and hand the prepared FD off to the
-	 * client.
-	 */
-	if (drmGetMagic(fd, &magic) < 0) {
-		if (errno == EACCES) {
-			/* Assume that we're on a render node, and the fd is
-			 * already as authenticated as it should be.
-			 */
-			*out = fd;
-			return Success;
-		} else {
-			close(fd);
-			return BadMatch;
+	/* 2) Check whether authentication is even necessary ---------------- */
+	if (drmGetMagic(g.fd, &magic) < 0) {
+		if (errno == EACCES) {                  /* render-node masquerading */
+			*out = fdg_move(&g); fdg_cleanup(&g); return Success;
 		}
+		fdg_cleanup(&g); return BadMatch;
 	}
 
-	if (drmAuthMagic(pAMDGPUEnt->fd, magic) < 0) {
-		close(fd);
-		return BadMatch;
+	/* 3) Authenticate the FD with the server’s already-master FD -------- */
+	if (drmAuthMagic(ent->fd, magic) < 0) {
+		fdg_cleanup(&g); return BadMatch;
 	}
 
-	*out = fd;
-	return Success;
+	*out = fdg_move(&g); fdg_cleanup(&g); return Success;
 }
 
-static int open_render_node(ScreenPtr screen, int *out)
+/* ---------- 1b. /dev/dri/render* -------------------------------------- */
+static int
+amdgpu_open_render_node(ScreenPtr screen, int *out)
 {
-	ScrnInfoPtr scrn = xf86ScreenToScrn(screen);
-	AMDGPUEntPtr pAMDGPUEnt = AMDGPUEntPriv(scrn);
-	int fd;
+	ScrnInfoPtr  scrn = xf86ScreenToScrn(screen);
+	AMDGPUEntPtr ent  = AMDGPUEntPriv(scrn);
 
-	fd = open(pAMDGPUEnt->render_node, O_RDWR | O_CLOEXEC);
-	if (fd < 0)
-		return BadAlloc;
+	if (UNLIKELY(!ent->render_node))
+		return BadMatch;
 
-	*out = fd;
-	return Success;
+	return open_node(ent->render_node, out);
 }
 
+/* ---------- 1c. Public entry used by DRI3 ----------------------------- */
 static int
-amdgpu_dri3_open(ScreenPtr screen, RRProviderPtr provider, int *out)
+amdgpu_dri3_open(ScreenPtr      screen,
+				 RRProviderPtr  provider _X_UNUSED,
+				 int           *out)
 {
-	ScrnInfoPtr scrn = xf86ScreenToScrn(screen);
-	AMDGPUEntPtr pAMDGPUEnt = AMDGPUEntPriv(scrn);
-	int ret = BadAlloc;
-
-	if (pAMDGPUEnt->render_node)
-		ret = open_render_node(screen, out);
-
-	if (ret != Success)
-		ret = open_card_node(screen, out);
+	/* Try render node first (fast-path, no auth). */
+	int ret = amdgpu_open_render_node(screen, out);
+	if (ret == Success)
+		return ret;
 
-	return ret;
+	/* Fall back to the legacy card node. */
+	return amdgpu_open_card_node(screen, out);
 }
 
-#if DRI3_SCREEN_INFO_VERSION >= 1 && XORG_VERSION_CURRENT <= XORG_VERSION_NUMERIC(1,18,99,1,0)
+/* ========== 2. Optional ssh-guard for ancient servers ================= */
+#if DRI3_SCREEN_INFO_VERSION >= 1 && \
+XORG_VERSION_CURRENT <= XORG_VERSION_NUMERIC(1,18,99,1,0)
 
 static int
-amdgpu_dri3_open_client(ClientPtr client, ScreenPtr screen,
-			RRProviderPtr provider, int *out)
+amdgpu_dri3_open_client(ClientPtr     client,
+						ScreenPtr     screen,
+						RRProviderPtr provider,
+						int          *out)
 {
-	const char *cmdname = GetClientCmdName(client);
-	Bool is_ssh = FALSE;
+	const char *cmd = GetClientCmdName(client);
+	if (cmd) {
+		char  tmp[PATH_MAX];             /* stack, safe */
+		strncpy(tmp, cmd, sizeof(tmp));
+		tmp[sizeof(tmp) - 1] = '\0';
+
+		char *base = basename(tmp);
+		if (base && strcmp(base, "ssh") == 0)
+			return BadAccess;            /* remote client, deny */
+	}
+	return amdgpu_dri3_open(screen, provider, out);
+}
+#endif /* old server ssh guard */
 
-	/* If the executable name is "ssh", assume that this client connection
-	 * is forwarded from another host via SSH
-	 */
-	if (cmdname) {
-		char *cmd = strdup(cmdname);
-
-		/* Cut off any colon and whatever comes after it, see
-		 * https://lists.freedesktop.org/archives/xorg-devel/2015-December/048164.html
-		 */
-		cmd = strtok(cmd, ":");
+/* ========== 3. Pixmap <--> DMA-BUF converters ========================= */
 
-		is_ssh = strcmp(basename(cmd), "ssh") == 0;
-		free(cmd);
-	}
+/* ---- 3a. validation helpers ----------------------------------------- */
+static inline Bool
+validate_pixmap_dims(uint16_t width, uint16_t height,
+					 uint8_t depth, uint8_t bpp, uint16_t stride)
+{
+	if (UNLIKELY(width == 0 || height == 0))
+		return FALSE;
 
-	if (!is_ssh)
-		return amdgpu_dri3_open(screen, provider, out);
+	/* Only canonical formats that both X and DRM agree on. */
+	switch (bpp) {
+		case 8:  if (depth != 8)  return FALSE; break;
+		case 16: if (depth != 15 && depth != 16) return FALSE; break;
+		case 32: if (depth < 24)  return FALSE; break;
+		default: return FALSE;
+	}
 
-	return BadAccess;
+	/* stride must be large enough and contain no overflow */
+	uint32_t min_stride = (uint32_t)width * ((uint32_t)bpp >> 3);
+	return stride >= min_stride;
 }
 
-#endif /* DRI3_SCREEN_INFO_VERSION >= 1 && XORG_VERSION_CURRENT <= XORG_VERSION_NUMERIC(1,18,99,1,0) */
-
-static PixmapPtr amdgpu_dri3_pixmap_from_fd(ScreenPtr screen,
-					    int fd,
-					    CARD16 width,
-					    CARD16 height,
-					    CARD16 stride,
-					    CARD8 depth,
-					    CARD8 bpp)
+/* ---- 3b. FD → Pixmap ------------------------------------------------- */
+static PixmapPtr
+amdgpu_dri3_pixmap_from_fd(ScreenPtr  screen,
+						   int        fd,
+						   CARD16     width,
+						   CARD16     height,
+						   CARD16     stride,
+						   CARD8      depth,
+						   CARD8      bpp)
 {
-	PixmapPtr pixmap;
+	if (UNLIKELY(!validate_pixmap_dims(width, height, depth, bpp, stride)))
+		return NULL;
 
-#ifdef USE_GLAMOR
-	/* Avoid generating a GEM flink name if possible */
-	if (AMDGPUPTR(xf86ScreenToScrn(screen))->use_glamor) {
-		pixmap = glamor_pixmap_from_fd(screen, fd, width, height,
-					       stride, depth, bpp);
-		if (pixmap) {
-			struct amdgpu_pixmap *priv = calloc(1, sizeof(*priv));
+	#ifdef USE_GLAMOR
+	ScrnInfoPtr   scrn = xf86ScreenToScrn(screen);
+	AMDGPUInfoPtr info = AMDGPUPTR(scrn);
 
-			if (priv) {
-				amdgpu_set_pixmap_private(pixmap, priv);
-				pixmap->usage_hint |= AMDGPU_CREATE_PIXMAP_DRI2;
-				return pixmap;
+	if (info->use_glamor) {
+		PixmapPtr pix = glamor_pixmap_from_fd(screen, fd, width, height,
+											  stride, depth, bpp);
+		if (pix) {
+			struct amdgpu_pixmap *priv = calloc(1, sizeof(*priv));
+			if (LIKELY(priv)) {
+				amdgpu_set_pixmap_private(pix, priv);
+				pix->usage_hint |= AMDGPU_CREATE_PIXMAP_DRI2;
+				return pix;
 			}
-
-			screen->DestroyPixmap(pixmap);
-			return NULL;
+			screen->DestroyPixmap(pix);
 		}
+		return NULL;
 	}
-#endif
+	#endif /* USE_GLAMOR */
 
-	if (depth < 8)
+	/* Fallback: no glamor.  We duplicate the FD so ownership stays clear. */
+	struct fd_guard g; fdg_init(&g);
+	g.fd = fcntl(fd, F_DUPFD_CLOEXEC, 3);
+	if (g.fd < 0)
 		return NULL;
 
-	switch (bpp) {
-	case 8:
-	case 16:
-	case 32:
-		break;
-	default:
-		return NULL;
-	}
+	PixmapPtr pix = screen->CreatePixmap(screen, 0, 0, depth,
+										 AMDGPU_CREATE_PIXMAP_DRI2);
+	if (UNLIKELY(!pix))
+	{ fdg_cleanup(&g); return NULL; }
 
-	pixmap = screen->CreatePixmap(screen, 0, 0, depth,
-				      AMDGPU_CREATE_PIXMAP_DRI2);
-	if (!pixmap)
-		return NULL;
+	if (!screen->ModifyPixmapHeader(pix, width, height, 0, bpp, stride, NULL))
+	{ screen->DestroyPixmap(pix); fdg_cleanup(&g); return NULL; }
 
-	if (!screen->ModifyPixmapHeader(pixmap, width, height, 0, bpp, stride,
-					NULL))
-		goto free_pixmap;
-
-	if (screen->SetSharedPixmapBacking(pixmap, (void*)(intptr_t)fd))
-		return pixmap;
-
-free_pixmap:
-	fbDestroyPixmap(pixmap);
-	return NULL;
+	if (!screen->SetSharedPixmapBacking(pix, (void*)(intptr_t)fdg_move(&g)))
+	{ screen->DestroyPixmap(pix); fdg_cleanup(&g); return NULL; }
+
+	fdg_cleanup(&g);      /* nothing left to close */
+	return pix;
 }
 
-static int amdgpu_dri3_fd_from_pixmap(ScreenPtr screen,
-				      PixmapPtr pixmap,
-				      CARD16 *stride,
-				      CARD32 *size)
+/* ---- 3c. Pixmap → FD ------------------------------------------------- */
+static int
+amdgpu_dri3_fd_from_pixmap(ScreenPtr screen, PixmapPtr pix,
+						   CARD16 *stride /* out */, CARD32 *size /* out */)
 {
-	struct amdgpu_buffer *bo;
-	struct amdgpu_bo_info bo_info;
-	uint32_t fd;
-#ifdef USE_GLAMOR
-	ScrnInfoPtr scrn = xf86ScreenToScrn(screen);
+	#ifdef USE_GLAMOR
+	ScrnInfoPtr   scrn = xf86ScreenToScrn(screen);
 	AMDGPUInfoPtr info = AMDGPUPTR(scrn);
 
 	if (info->use_glamor) {
-		int ret = glamor_fd_from_pixmap(screen, pixmap, stride, size);
-
-		/* Any pending drawing operations need to be flushed to the
-		 * kernel driver before the client starts using the pixmap
-		 * storage for direct rendering.
-		 */
-		if (ret >= 0)
-			amdgpu_glamor_flush(scrn);
-
-		return ret;
+		int fd = glamor_fd_from_pixmap(screen, pix, stride, size);
+		if (fd >= 0)
+			amdgpu_glamor_flush(scrn);          /* make sure GPU finished */
+			return fd;
 	}
-#endif
+	#endif
 
-	bo = amdgpu_get_pixmap_bo(pixmap);
-	if (!bo)
+	struct amdgpu_buffer *bo = amdgpu_get_pixmap_bo(pix);
+	if (UNLIKELY(!bo))
 		return -1;
 
-	if (pixmap->devKind > UINT16_MAX)
+	if (UNLIKELY(pix->devKind > UINT16_MAX))
 		return -1;
 
-	if (amdgpu_bo_query_info(bo->bo.amdgpu, &bo_info) != 0)
+	struct amdgpu_bo_info info_bo;
+	if (UNLIKELY(amdgpu_bo_query_info(bo->bo.amdgpu, &info_bo)))
 		return -1;
 
-	if (amdgpu_bo_export(bo->bo.amdgpu, amdgpu_bo_handle_type_dma_buf_fd,
-			     &fd) != 0)
+	uint32_t fd;
+	if (UNLIKELY(amdgpu_bo_export(bo->bo.amdgpu,
+		amdgpu_bo_handle_type_dma_buf_fd, &fd)))
 		return -1;
 
-	*stride = pixmap->devKind;
-	*size = bo_info.alloc_size;
-	return fd;
+	*stride = (CARD16)pix->devKind;
+	*size   = info_bo.alloc_size;
+	return (int)fd;
 }
 
+/* ========== 4. DRI3 screen-info trampoline ============================ */
 static dri3_screen_info_rec amdgpu_dri3_screen_info = {
-#if DRI3_SCREEN_INFO_VERSION >= 1 && XORG_VERSION_CURRENT <= XORG_VERSION_NUMERIC(1,18,99,1,0)
-	.version = 1,
-	.open_client = amdgpu_dri3_open_client,
-#else
-	.version = 0,
-	.open = amdgpu_dri3_open,
-#endif
+	#if DRI3_SCREEN_INFO_VERSION >= 1 && \
+	XORG_VERSION_CURRENT <= XORG_VERSION_NUMERIC(1,18,99,1,0)
+	.version      = 1,
+	.open_client  = amdgpu_dri3_open_client,
+	#else
+	.version      = 0,
+	.open         = amdgpu_dri3_open,
+	#endif
 	.pixmap_from_fd = amdgpu_dri3_pixmap_from_fd,
 	.fd_from_pixmap = amdgpu_dri3_fd_from_pixmap
 };
 
+/* ========== 5. Public init called by the driver ======================= */
 Bool
 amdgpu_dri3_screen_init(ScreenPtr screen)
 {
-	ScrnInfoPtr scrn = xf86ScreenToScrn(screen);
-	AMDGPUEntPtr pAMDGPUEnt = AMDGPUEntPriv(scrn);
+	#ifndef HAVE_DRI3_H
+	xf86DrvMsg(xf86ScreenToScrn(screen)->scrnIndex, X_INFO,
+			   "DRI3 not built into this driver\n");
+	return FALSE;
+	#else
+	ScrnInfoPtr  scrn = xf86ScreenToScrn(screen);
+	AMDGPUEntPtr ent  = AMDGPUEntPriv(scrn);
 
-	pAMDGPUEnt->render_node = drmGetRenderDeviceNameFromFd(pAMDGPUEnt->fd);
+	/* Cache render-node path for super-fast open() later. */
+	ent->render_node = drmGetRenderDeviceNameFromFd(ent->fd);
 
 	if (!dri3_screen_init(screen, &amdgpu_dri3_screen_info)) {
-		xf86DrvMsg(scrn->scrnIndex, X_WARNING,
-			   "dri3_screen_init failed\n");
+		xf86DrvMsg(scrn->scrnIndex, X_WARNING, "dri3_screen_init failed\n");
 		return FALSE;
 	}
-
 	return TRUE;
+	#endif /* HAVE_DRI3_H */
 }
-
-#else /* !HAVE_DRI3_H */
-
-Bool
-amdgpu_dri3_screen_init(ScreenPtr screen)
-{
-	xf86DrvMsg(xf86ScreenToScrn(screen)->scrnIndex, X_INFO,
-		   "Can't initialize DRI3 because dri3.h not available at "
-		   "build time\n");
-
-	return FALSE;
-}
-
-#endif


--- a/src/amdgpu_kms.c	2025-05-18 11:28:38.972391290 +0200
+++ b/src/amdgpu_kms.c	2025-05-18 11:53:30.092499760 +0200
@@ -30,6 +30,8 @@
 
 #include <errno.h>
 #include <sys/ioctl.h>
+#include <stdlib.h> /* For malloc/free/calloc if not implicitly included */
+#include <string.h> /* For strerror if not implicitly included */
 /* Driver data structures */
 #include "amdgpu_drv.h"
 #include "amdgpu_bo_helper.h"
@@ -38,10 +40,13 @@
 #include "amdgpu_probe.h"
 #include "micmap.h"
 #include "mipointrst.h"
+#include "regionstr.h" /* For RegionRec, RegionNumRects etc. */
+#include "pixman.h"    /* For pixman_f_transform */
+
 
 #include "amdgpu_version.h"
 #include "shadow.h"
-#include <xf86Priv.h>
+#include <xf86Priv.h> /* For xf86GetVerbosity, xf86DrvMsgVerb */
 
 #if HAVE_PRESENT_H
 #include <present.h>
@@ -62,33 +67,49 @@
 
 #include <gbm.h>
 
+/* Branch prediction hints */
+#if (defined(__GNUC__) && (__GNUC__ >= 3)) || defined(__clang__)
+#define likely(x)   __builtin_expect(!!(x),1)
+#define unlikely(x) __builtin_expect(!!(x),0)
+#else
+#define likely(x)   (x)
+#define unlikely(x) (x)
+#endif
+
+
 static DevPrivateKeyRec amdgpu_window_private_key;
 static DevScreenPrivateKeyRec amdgpu_client_private_key;
 DevScreenPrivateKeyRec amdgpu_device_private_key;
 
 static Atom amdgpu_vrr_atom;
-static Bool amdgpu_property_vectors_wrapped;
-static Bool restore_property_vector;
+static Bool amdgpu_property_vectors_wrapped; /* Used by unwrap, needs to be file-static */
+static Bool restore_property_vector;       /* Used by change/delete, needs to be file-static */
 static int (*saved_change_property) (ClientPtr client);
 static int (*saved_delete_property) (ClientPtr client);
 
 static Bool amdgpu_setup_kernel_mem(ScreenPtr pScreen);
 
+/* GLOBALS for idea #10 – thread-safe property-vector wrapping */
+static volatile int vrr_prop_lock = 0;
+static inline void vrr_lock  (void) { while (__sync_lock_test_and_set(&vrr_prop_lock,1)); }
+static inline void vrr_unlock(void) { __sync_lock_release(&vrr_prop_lock); }
+
+
 const OptionInfoRec AMDGPUOptions_KMS[] = {
-	{OPTION_ACCEL, "Accel", OPTV_BOOLEAN, .value = {0}, FALSE},
-	{OPTION_SW_CURSOR, "SWcursor", OPTV_BOOLEAN, .value = {0}, FALSE},
-	{OPTION_PAGE_FLIP, "EnablePageFlip", OPTV_BOOLEAN, .value = {0}, FALSE},
-	{OPTION_SUBPIXEL_ORDER, "SubPixelOrder", OPTV_ANYSTR, .value = {0}, FALSE},
-	{OPTION_ZAPHOD_HEADS, "ZaphodHeads", OPTV_STRING, .value = {0}, FALSE},
-	{OPTION_ACCEL_METHOD, "AccelMethod", OPTV_STRING, .value = {0}, FALSE},
-	{OPTION_DRI3, "DRI3", OPTV_BOOLEAN, .value = {0}, FALSE},
-	{OPTION_DRI, "DRI", OPTV_INTEGER, .value = {0}, FALSE},
-	{OPTION_SHADOW_PRIMARY, "ShadowPrimary", OPTV_BOOLEAN, .value = {0}, FALSE},
-	{OPTION_TEAR_FREE, "TearFree", OPTV_BOOLEAN, .value = {0}, FALSE},
-	{OPTION_DELETE_DP12, "DeleteUnusedDP12Displays", OPTV_BOOLEAN, .value = {0}, FALSE},
-	{OPTION_VARIABLE_REFRESH, "VariableRefresh", OPTV_BOOLEAN, .value = {0}, FALSE },
-	{OPTION_ASYNC_FLIP_SECONDARIES, "AsyncFlipSecondaries", OPTV_BOOLEAN, .value = {0}, FALSE},
-	{-1, NULL, OPTV_NONE, .value = {0}, FALSE}
+	{OPTION_ACCEL, "Accel", OPTV_BOOLEAN, {0}, FALSE},
+	{OPTION_SW_CURSOR, "SWcursor", OPTV_BOOLEAN, {0}, FALSE},
+	{OPTION_PAGE_FLIP, "EnablePageFlip", OPTV_BOOLEAN, {0}, FALSE},
+	{OPTION_SUBPIXEL_ORDER, "SubPixelOrder", OPTV_ANYSTR, {0}, FALSE},
+	{OPTION_ZAPHOD_HEADS, "ZaphodHeads", OPTV_STRING, {0}, FALSE},
+	{OPTION_ACCEL_METHOD, "AccelMethod", OPTV_STRING, {0}, FALSE},
+	{OPTION_DRI3, "DRI3", OPTV_BOOLEAN, {0}, FALSE},
+	{OPTION_DRI, "DRI", OPTV_INTEGER, {0}, FALSE},
+	{OPTION_SHADOW_PRIMARY, "ShadowPrimary", OPTV_BOOLEAN, {0}, FALSE},
+	{OPTION_TEAR_FREE, "TearFree", OPTV_BOOLEAN, {0}, FALSE},
+	{OPTION_DELETE_DP12, "DeleteUnusedDP12Displays", OPTV_BOOLEAN, {0}, FALSE},
+	{OPTION_VARIABLE_REFRESH, "VariableRefresh", OPTV_BOOLEAN, {0}, FALSE },
+	{OPTION_ASYNC_FLIP_SECONDARIES, "AsyncFlipSecondaries", OPTV_BOOLEAN, {0}, FALSE},
+	{-1, NULL, OPTV_NONE, {0}, FALSE}
 };
 
 const OptionInfoRec *AMDGPUOptionsWeak(void)
@@ -109,14 +130,14 @@ amdgpu_vrr_property_update(WindowPtr win
 	get_window_priv(window)->variable_refresh = variable_refresh;
 
 	if (info->flip_window == window &&
-	    info->drmmode.present_flipping)
+		info->drmmode.present_flipping)
 		amdgpu_present_set_screen_vrr(scrn, variable_refresh);
 }
 
-/* Wrapper for xserver/dix/property.c:ProcChangeProperty */
-static int
-amdgpu_change_property(ClientPtr client)
+/* idea #10 – protect property-vector wrappers */
+static int amdgpu_change_property(ClientPtr client)
 {
+	vrr_lock();
 	WindowPtr window;
 	int ret;
 
@@ -125,33 +146,24 @@ amdgpu_change_property(ClientPtr client)
 	client->requestVector[X_ChangeProperty] = saved_change_property;
 	ret = saved_change_property(client);
 
-	if (restore_property_vector)
-		return ret;
-
-	client->requestVector[X_ChangeProperty] = amdgpu_change_property;
+	if (!restore_property_vector) /* This check is inside the lock */
+		client->requestVector[X_ChangeProperty] = amdgpu_change_property;
 
-	if (ret != Success)
-		return ret;
-
-	ret = dixLookupWindow(&window, stuff->window, client, DixSetPropAccess);
-	if (ret != Success)
-		return ret;
-
-	if (stuff->property == amdgpu_vrr_atom &&
-	    xf86ScreenToScrn(window->drawable.pScreen)->PreInit ==
-	    AMDGPUPreInit_KMS && stuff->format == 32 && stuff->nUnits == 1) {
-		uint32_t *value = (uint32_t*)(stuff + 1);
-
-		amdgpu_vrr_property_update(window, *value != 0);
+	if (ret == Success &&
+		dixLookupWindow(&window, stuff->window, client, DixSetPropAccess) == Success &&
+		stuff->property == amdgpu_vrr_atom &&
+		xf86ScreenToScrn(window->drawable.pScreen)->PreInit == AMDGPUPreInit_KMS &&
+		stuff->format == 32 && stuff->nUnits == 1)
+	{
+		amdgpu_vrr_property_update(window, ((uint32_t *)(stuff + 1))[0] != 0);
 	}
-
+	vrr_unlock();
 	return ret;
 }
 
-/* Wrapper for xserver/dix/property.c:ProcDeleteProperty */
-static int
-amdgpu_delete_property(ClientPtr client)
+static int amdgpu_delete_property(ClientPtr client)
 {
+	vrr_lock();
 	WindowPtr window;
 	int ret;
 
@@ -160,70 +172,56 @@ amdgpu_delete_property(ClientPtr client)
 	client->requestVector[X_DeleteProperty] = saved_delete_property;
 	ret = saved_delete_property(client);
 
-	if (restore_property_vector)
-		return ret;
-
-	client->requestVector[X_DeleteProperty] = amdgpu_delete_property;
-
-	if (ret != Success)
-		return ret;
-
-	ret = dixLookupWindow(&window, stuff->window, client, DixSetPropAccess);
-	if (ret != Success)
-		return ret;
+	if (!restore_property_vector) /* This check is inside the lock */
+		client->requestVector[X_DeleteProperty] = amdgpu_delete_property;
 
-	if (stuff->property == amdgpu_vrr_atom &&
-	    xf86ScreenToScrn(window->drawable.pScreen)->PreInit ==
-	    AMDGPUPreInit_KMS)
+	if (ret == Success &&
+		dixLookupWindow(&window, stuff->window, client, DixSetPropAccess) == Success &&
+		stuff->property == amdgpu_vrr_atom &&
+		xf86ScreenToScrn(window->drawable.pScreen)->PreInit == AMDGPUPreInit_KMS)
+	{
 		amdgpu_vrr_property_update(window, FALSE);
-
+	}
+	vrr_unlock();
 	return ret;
 }
 
 static void
 amdgpu_unwrap_property_requests(ScrnInfoPtr scrn)
 {
-	int i;
+	vrr_lock();
+	/* restore_property_vector logic is mostly handled by the individual wrappers now.
+	 * This function ensures all known vectors are reset if wrapping was active.
+	 */
+	if (amdgpu_property_vectors_wrapped) { /* Check if we ever wrapped them */
+		int i;
+		if (ProcVector[X_ChangeProperty] == amdgpu_change_property)
+			ProcVector[X_ChangeProperty] = saved_change_property;
+		/* else: some other module might have wrapped it, or logic error.
+		 * restore_property_vector flag should catch mismatches in individual handlers.
+		 */
 
-	if (!amdgpu_property_vectors_wrapped)
-		return;
+		if (ProcVector[X_DeleteProperty] == amdgpu_delete_property)
+			ProcVector[X_DeleteProperty] = saved_delete_property;
 
-	if (ProcVector[X_ChangeProperty] == amdgpu_change_property)
-		ProcVector[X_ChangeProperty] = saved_change_property;
-	else
-		restore_property_vector = TRUE;
-
-	if (ProcVector[X_DeleteProperty] == amdgpu_delete_property)
-		ProcVector[X_DeleteProperty] = saved_delete_property;
-	else
-		restore_property_vector = TRUE;
-
-	for (i = 0; i < currentMaxClients; i++) {
-		if (clients[i]->requestVector[X_ChangeProperty] ==
-		    amdgpu_change_property) {
-			clients[i]->requestVector[X_ChangeProperty] =
-				saved_change_property;
-		} else {
-			restore_property_vector = TRUE;
-		}
 
-		if (clients[i]->requestVector[X_DeleteProperty] ==
-		    amdgpu_delete_property) {
-			clients[i]->requestVector[X_DeleteProperty] =
-				saved_delete_property;
-		} else {
-			restore_property_vector = TRUE;
+		for (i = 0; i < currentMaxClients; i++) {
+			if (clients[i]) { /* Check if client slot is active */
+				if (clients[i]->requestVector[X_ChangeProperty] == amdgpu_change_property) {
+					clients[i]->requestVector[X_ChangeProperty] = saved_change_property;
+				}
+				if (clients[i]->requestVector[X_DeleteProperty] == amdgpu_delete_property) {
+					clients[i]->requestVector[X_DeleteProperty] = saved_delete_property;
+				}
+			}
 		}
+		amdgpu_property_vectors_wrapped = FALSE;
+		restore_property_vector = FALSE; /* Reset the flag as we've unwrapped */
 	}
-
-	if (restore_property_vector) {
-		xf86DrvMsg(scrn->scrnIndex, X_WARNING,
-			   "Couldn't unwrap some window property request vectors\n");
-	}
-
-	amdgpu_property_vectors_wrapped = FALSE;
+	vrr_unlock();
 }
 
+
 extern _X_EXPORT int gAMDGPUEntityIndex;
 
 static int getAMDGPUEntityIndex(void)
@@ -239,7 +237,6 @@ AMDGPUEntPtr AMDGPUEntPriv(ScrnInfoPtr p
 	return pPriv->ptr;
 }
 
-/* Allocate our private AMDGPUInfoRec */
 static Bool AMDGPUGetRec(ScrnInfoPtr pScrn)
 {
 	if (pScrn->driverPrivate)
@@ -249,7 +246,6 @@ static Bool AMDGPUGetRec(ScrnInfoPtr pSc
 	return TRUE;
 }
 
-/* Free our private AMDGPUInfoRec */
 static void AMDGPUFreeRec(ScrnInfoPtr pScrn)
 {
 	DevUnion *pPriv;
@@ -273,15 +269,15 @@ static void AMDGPUFreeRec(ScrnInfoPtr pS
 	}
 
 	if (pAMDGPUEnt->fd > 0) {
-		DevUnion *pPriv;
-		AMDGPUEntPtr pAMDGPUEnt;
+		/* DevUnion *pPriv; This re-declaration shadows. Use the outer one. */
+		/* AMDGPUEntPtr pAMDGPUEnt; */
 		pPriv = xf86GetEntityPrivate(pScrn->entityList[0],
-					     getAMDGPUEntityIndex());
+									 getAMDGPUEntityIndex());
 
 		pAMDGPUEnt = pPriv->ptr;
 		pAMDGPUEnt->fd_ref--;
 		if (!pAMDGPUEnt->fd_ref) {
-			amdgpu_unwrap_property_requests(pScrn);
+			amdgpu_unwrap_property_requests(pScrn); /* Ensure unwrapped on final close */
 			amdgpu_device_deinitialize(pAMDGPUEnt->pDev);
 			amdgpu_kernel_close_fd(pAMDGPUEnt);
 			free(pAMDGPUEnt->busid);
@@ -295,12 +291,11 @@ static void AMDGPUFreeRec(ScrnInfoPtr pS
 
 Bool amdgpu_window_has_variable_refresh(WindowPtr win) {
 	struct amdgpu_window_priv *priv = get_window_priv(win);
-
 	return priv->variable_refresh;
 }
 
 static void *amdgpuShadowWindow(ScreenPtr screen, CARD32 row, CARD32 offset,
-				int mode, CARD32 * size, void *closure)
+								int mode, CARD32 * size, void *closure)
 {
 	ScrnInfoPtr pScrn = xf86ScreenToScrn(screen);
 	AMDGPUInfoPtr info = AMDGPUPTR(pScrn);
@@ -309,6 +304,7 @@ static void *amdgpuShadowWindow(ScreenPt
 	stride = (pScrn->displayWidth * pScrn->bitsPerPixel) / 8;
 	*size = stride;
 
+	if (unlikely(!info->front_buffer || !info->front_buffer->cpu_ptr)) return NULL;
 	return ((uint8_t *) info->front_buffer->cpu_ptr + row * stride + offset);
 }
 
@@ -318,38 +314,42 @@ amdgpuUpdatePacked(ScreenPtr pScreen, sh
 	shadowUpdatePacked(pScreen, pBuf);
 }
 
-static Bool
-callback_needs_flush(AMDGPUInfoPtr info, struct amdgpu_client_priv *client_priv)
-{
-	return (int)(client_priv->needs_flush - info->gpu_flushed) > 0;
+/* idea #5 – make this tiny helper inline + prefetch */
+static inline Bool
+callback_needs_flush(AMDGPUInfoPtr info,
+					 struct amdgpu_client_priv *client_priv)
+{
+	if (unlikely(!client_priv)) return FALSE; /* Safety check */
+		/* Prefetch next cache-line of struct to hide latency */
+		__builtin_prefetch(client_priv, 0, 0); /* 0 for read, 0 for low locality - assuming check then potential write soon */
+		/* signed difference allows wraparound-safe comparison */
+		return (int)(client_priv->needs_flush - info->gpu_flushed) > 0;
 }
 
+
 static void
 amdgpu_event_callback(CallbackListPtr *list,
-		      pointer user_data, pointer call_data)
+					  pointer user_data, pointer call_data)
 {
 	EventInfoRec *eventinfo = call_data;
 	ScrnInfoPtr pScrn = user_data;
 	ScreenPtr pScreen = pScrn->pScreen;
 	struct amdgpu_client_priv *client_priv =
-		dixLookupScreenPrivate(&eventinfo->client->devPrivates,
-				       &amdgpu_client_private_key, pScreen);
+	dixLookupScreenPrivate(&eventinfo->client->devPrivates,
+						   &amdgpu_client_private_key, pScreen);
 	struct amdgpu_client_priv *server_priv =
-		dixLookupScreenPrivate(&serverClient->devPrivates,
-				       &amdgpu_client_private_key, pScreen);
+	dixLookupScreenPrivate(&serverClient->devPrivates,
+						   &amdgpu_client_private_key, pScreen);
 	AMDGPUInfoPtr info = AMDGPUPTR(pScrn);
 	int i;
 
 	if (callback_needs_flush(info, client_priv) ||
-	    callback_needs_flush(info, server_priv))
+		callback_needs_flush(info, server_priv))
 		return;
 
-	/* Don't let gpu_flushed get too far ahead of needs_flush, in order
-	 * to prevent false positives in callback_needs_flush()
-	 */
 	client_priv->needs_flush = info->gpu_flushed;
 	server_priv->needs_flush = info->gpu_flushed;
-	
+
 	for (i = 0; i < eventinfo->count; i++) {
 		if (eventinfo->events[i].u.u.type == info->callback_event_type) {
 			client_priv->needs_flush++;
@@ -361,14 +361,14 @@ amdgpu_event_callback(CallbackListPtr *l
 
 static void
 amdgpu_flush_callback(CallbackListPtr *list,
-		      pointer user_data, pointer call_data)
+					  pointer user_data, pointer call_data)
 {
 	ScrnInfoPtr pScrn = user_data;
 	ScreenPtr pScreen = pScrn->pScreen;
 	ClientPtr client = call_data ? call_data : serverClient;
 	struct amdgpu_client_priv *client_priv =
-		dixLookupScreenPrivate(&client->devPrivates,
-				       &amdgpu_client_private_key, pScreen);
+	dixLookupScreenPrivate(&client->devPrivates,
+						   &amdgpu_client_private_key, pScreen);
 	AMDGPUInfoPtr info = AMDGPUPTR(pScrn);
 
 	if (pScrn->vtSema && callback_needs_flush(info, client_priv))
@@ -383,41 +383,37 @@ static Bool AMDGPUCreateScreenResources_
 	PixmapPtr pixmap;
 
 	pScreen->CreateScreenResources = info->CreateScreenResources;
-	if (!(*pScreen->CreateScreenResources) (pScreen))
+	if (unlikely(!(*pScreen->CreateScreenResources) (pScreen)))
 		return FALSE;
 	pScreen->CreateScreenResources = AMDGPUCreateScreenResources_KMS;
 
-	/* Set the RandR primary output if Xorg hasn't */
 	if (dixPrivateKeyRegistered(rrPrivKey)) {
 		rrScrPrivPtr rrScrPriv = rrGetScrPriv(pScreen);
-
 		if (!pScreen->isGPU && !rrScrPriv->primaryOutput) {
 			xf86CrtcConfigPtr xf86_config = XF86_CRTC_CONFIG_PTR(pScrn);
-
-			rrScrPriv->primaryOutput = xf86_config->output[0]->randr_output;
-			RROutputChanged(rrScrPriv->primaryOutput, FALSE);
-			rrScrPriv->layoutChanged = TRUE;
+			if (likely(xf86_config->num_output > 0 && xf86_config->output[0])) {
+				rrScrPriv->primaryOutput = xf86_config->output[0]->randr_output;
+				RROutputChanged(rrScrPriv->primaryOutput, FALSE);
+				rrScrPriv->layoutChanged = TRUE;
+			}
 		}
-
 		drmmode_uevent_init(pScrn, &info->drmmode);
 	}
 
-	if (!drmmode_set_desired_modes(pScrn, &info->drmmode, pScreen->isGPU))
+	if (unlikely(!drmmode_set_desired_modes(pScrn, &info->drmmode, pScreen->isGPU)))
 		return FALSE;
 
 	if (info->shadow_fb) {
 		pixmap = pScreen->GetScreenPixmap(pScreen);
-
-		if (!shadowAdd(pScreen, pixmap, amdgpuUpdatePacked,
-			       amdgpuShadowWindow, 0, NULL))
+		if (unlikely(!shadowAdd(pScreen, pixmap, amdgpuUpdatePacked,
+			amdgpuShadowWindow, 0, NULL)))
 			return FALSE;
 	}
 
 	if (info->dri2.enabled || info->use_glamor) {
 		if (info->front_buffer) {
 			PixmapPtr pPix = pScreen->GetScreenPixmap(pScreen);
-
-			if (!amdgpu_set_pixmap_bo(pPix, info->front_buffer))
+			if (unlikely(!amdgpu_set_pixmap_bo(pPix, info->front_buffer)))
 				return FALSE;
 		}
 	}
@@ -428,48 +424,59 @@ static Bool AMDGPUCreateScreenResources_
 	info->callback_event_type = -1;
 	if (!pScreen->isGPU && (damage_ext = CheckExtension("DAMAGE"))) {
 		info->callback_event_type = damage_ext->eventBase + XDamageNotify;
-
-		if (!AddCallback(&FlushCallback, amdgpu_flush_callback, pScrn))
+		if (unlikely(!AddCallback(&FlushCallback, amdgpu_flush_callback, pScrn)))
 			return FALSE;
-
-		if (!AddCallback(&EventCallback, amdgpu_event_callback, pScrn)) {
+		if (unlikely(!AddCallback(&EventCallback, amdgpu_event_callback, pScrn))) {
 			DeleteCallback(&FlushCallback, amdgpu_flush_callback, pScrn);
 			return FALSE;
 		}
-
-		if (!dixRegisterScreenPrivateKey(&amdgpu_client_private_key, pScreen,
-						 PRIVATE_CLIENT, sizeof(struct amdgpu_client_priv))) {
+		if (unlikely(!dixRegisterScreenPrivateKey(&amdgpu_client_private_key, pScreen,
+			PRIVATE_CLIENT, sizeof(struct amdgpu_client_priv)))) {
 			DeleteCallback(&FlushCallback, amdgpu_flush_callback, pScrn);
-			DeleteCallback(&EventCallback, amdgpu_event_callback, pScrn);
-			return FALSE;
-		}
+		DeleteCallback(&EventCallback, amdgpu_event_callback, pScrn);
+		return FALSE;
+			}
 	}
 
 	if (info->vrr_support &&
-	    !dixRegisterPrivateKey(&amdgpu_window_private_key,
-				   PRIVATE_WINDOW,
-				   sizeof(struct amdgpu_window_priv)))
+		unlikely(!dixRegisterPrivateKey(&amdgpu_window_private_key,
+										PRIVATE_WINDOW, sizeof(struct amdgpu_window_priv))))
 		return FALSE;
 
 	return TRUE;
 }
 
-static Bool
+static __attribute__((hot)) Bool
 amdgpu_scanout_extents_intersect(xf86CrtcPtr xf86_crtc, BoxPtr extents)
 {
+	/* Coarse reject when no transforms are active and not a PRIME sink */
+	if (!xf86_crtc->driverIsPerformingTransform &&
+		!xf86_crtc->scrn->is_gpu)
+	{
+		if (extents->x2 <= xf86_crtc->x ||
+			extents->x1 >= xf86_crtc->x + xf86_crtc->mode.HDisplay ||
+			extents->y2 <= xf86_crtc->y ||
+			extents->y1 >= xf86_crtc->y + xf86_crtc->mode.VDisplay)
+			return FALSE;
+	}
+
+	/* Original detailed handling */
 	if (xf86_crtc->scrn->is_gpu) {
 		extents->x1 -= xf86_crtc->x;
 		extents->y1 -= xf86_crtc->y;
 		extents->x2 -= xf86_crtc->x;
 		extents->y2 -= xf86_crtc->y;
 	} else {
-		extents->x1 -= xf86_crtc->filter_width >> 1;
-		extents->x2 += xf86_crtc->filter_width >> 1;
+		extents->x1 -= xf86_crtc->filter_width  >> 1;
+		extents->x2 += xf86_crtc->filter_width  >> 1;
 		extents->y1 -= xf86_crtc->filter_height >> 1;
 		extents->y2 += xf86_crtc->filter_height >> 1;
-		pixman_f_transform_bounds(&xf86_crtc->f_framebuffer_to_crtc, extents);
+
+		if (xf86_crtc->driverIsPerformingTransform) /* e.g. RandR rotation */
+			pixman_f_transform_bounds(&xf86_crtc->f_framebuffer_to_crtc, extents);
 	}
 
+	/* Clamp to CRTC's local 0,0 to HDisplay, VDisplay space */
 	extents->x1 = max(extents->x1, 0);
 	extents->y1 = max(extents->y1, 0);
 	extents->x2 = min(extents->x2, xf86_crtc->mode.HDisplay);
@@ -478,42 +485,58 @@ amdgpu_scanout_extents_intersect(xf86Crt
 	return (extents->x1 < extents->x2 && extents->y1 < extents->y2);
 }
 
-static RegionPtr
-transform_region(RegionPtr region, struct pixman_f_transform *transform,
-		 int w, int h)
-{
-	BoxPtr boxes = RegionRects(region);
-	int nboxes = RegionNumRects(region);
-	xRectanglePtr rects = malloc(nboxes * sizeof(*rects));
-	RegionPtr transformed;
+static __attribute__((hot)) RegionPtr
+transform_region(RegionPtr               region,
+				 struct pixman_f_transform *transform,
+				 int                      w,
+				 int                      h)
+{
+	const int   nboxes = RegionNumRects(region);
+	const BoxPtr boxes  = RegionRects(region);
+
+	/* Fast-path: empty input → empty output */
+	if (nboxes == 0)
+		return RegionCreate(NULL, 0);
+
+	/* Re-use static scratch for the common case, malloc for large ones */
+	enum { SCRATCH_RECTS = 64 };
+	static xRectangle rect_static[SCRATCH_RECTS];
+	xRectangle       *rects = (nboxes <= SCRATCH_RECTS)
+	? rect_static
+	: malloc(sizeof(xRectangle) * nboxes);
+
+	if (!rects) {                             /* OOM fallback */
+		xf86Msg(X_WARNING,
+				"amdgpu: transform_region OOM, using duplicate region\n");
+		return RegionDuplicate(region);
+	}
+
 	int nrects = 0;
-	BoxRec box;
-	int i;
+	for (int i = 0; i < nboxes; ++i) {
+		BoxRec b = boxes[i];                  /* copy – transform modifies */
 
-	for (i = 0; i < nboxes; i++) {
-		box.x1 = boxes[i].x1;
-		box.x2 = boxes[i].x2;
-		box.y1 = boxes[i].y1;
-		box.y2 = boxes[i].y2;
-		pixman_f_transform_bounds(transform, &box);
-
-		box.x1 = max(box.x1, 0);
-		box.y1 = max(box.y1, 0);
-		box.x2 = min(box.x2, w);
-		box.y2 = min(box.y2, h);
-		if (box.x1 >= box.x2 || box.y1 >= box.y2)
+		pixman_f_transform_bounds(transform, &b);
+
+		if (b.x1 < 0) b.x1 = 0;
+		if (b.y1 < 0) b.y1 = 0;
+		if (b.x2 >  w) b.x2 =  w;
+		if (b.y2 >  h) b.y2 =  h;
+
+		if (b.x1 >= b.x2 || b.y1 >= b.y2)
 			continue;
 
-		rects[nrects].x = box.x1;
-		rects[nrects].y = box.y1;
-		rects[nrects].width = box.x2 - box.x1;
-		rects[nrects].height = box.y2 - box.y1;
+		rects[nrects].x      = b.x1;
+		rects[nrects].y      = b.y1;
+		rects[nrects].width  = b.x2 - b.x1;
+		rects[nrects].height = b.y2 - b.y1;
 		nrects++;
 	}
 
-	transformed = RegionFromRects(nrects, rects, CT_UNSORTED);
-	free(rects);
-	return transformed;
+	RegionPtr out = RegionFromRects(nrects, rects, CT_UNSORTED);
+	if (rects != rect_static)
+		free(rects);
+
+	return out;
 }
 
 static void
@@ -521,49 +544,53 @@ amdgpu_sync_scanout_pixmaps(xf86CrtcPtr
 							int scanout_id)
 {
 	drmmode_crtc_private_ptr drmmode_crtc = xf86_crtc->driver_private;
-	DrawablePtr dst = &drmmode_crtc->scanout[scanout_id]->drawable;
-	DrawablePtr src = &drmmode_crtc->scanout[scanout_id ^ 1]->drawable;
-	RegionPtr last_region = &drmmode_crtc->scanout_last_region;
-	ScrnInfoPtr scrn = xf86_crtc->scrn;
-	ScreenPtr pScreen = scrn->pScreen;
-	RegionRec remaining;
-	RegionPtr sync_region = NULL;
-	BoxRec extents;
-	GCPtr gc;
+	DrawablePtr dst   = &drmmode_crtc->scanout[scanout_id]->drawable;
+	DrawablePtr src   = &drmmode_crtc->scanout[scanout_id ^ 1]->drawable;
+	RegionPtr   last  = &drmmode_crtc->scanout_last_region;
+	ScreenPtr   pScr  = xf86_crtc->scrn->pScreen;
+	RegionPtr   clip  = NULL; /* Initialize to NULL */
+
+	RegionRec   remaining;
+	RegionNull(&remaining); /* Initializes remaining.extents and remaining.data */
+	RegionSubtract(&remaining, last, new_region);
+
+	if (RegionNil(&remaining)) /* Check if there's anything to sync */
+		goto done;
+
+	BoxRec ext = *RegionExtents(&remaining); /* Get extents of the difference */
+	if (!amdgpu_scanout_extents_intersect(xf86_crtc, &ext)) /* Intersect with CRTC view */
+		goto done;
 
-	if (RegionNil(last_region))
-		return;
-
-	RegionNull(&remaining);
-	RegionSubtract(&remaining, last_region, new_region);
-	if (RegionNil(&remaining))
-		goto uninit;
-
-	extents = *RegionExtents(&remaining);
-	if (!amdgpu_scanout_extents_intersect(xf86_crtc, &extents))
-		goto uninit;
+	/* ext is now the CRTC-local area to update */
 
 	if (xf86_crtc->driverIsPerformingTransform) {
-		sync_region = transform_region(&remaining,
-					       &xf86_crtc->f_framebuffer_to_crtc,
-					       dst->width, dst->height);
+		/* 'remaining' is in global framebuffer coordinates. Transform it to CRTC-local. */
+		clip = transform_region(&remaining,
+								&xf86_crtc->f_framebuffer_to_crtc,
+						  dst->width, dst->height);
 	} else {
-		sync_region = RegionDuplicate(&remaining);
-		RegionTranslate(sync_region, -xf86_crtc->x, -xf86_crtc->y);
+		/* 'remaining' is global, translate to CRTC-local for clipping */
+		clip = RegionDuplicate(&remaining);
+		if (clip)
+			RegionTranslate(clip, -xf86_crtc->x, -xf86_crtc->y);
 	}
 
-	gc = GetScratchGC(dst->depth, pScreen);
+	if (!clip)
+		goto done;
+
+	GCPtr gc = GetScratchGC(dst->depth, pScr);
 	if (gc) {
-		gc->funcs->ChangeClip(gc, CT_REGION, sync_region, 0);
+		(*gc->funcs->ChangeClip)(gc, CT_REGION, clip, 0);
 		ValidateGC(dst, gc);
-		sync_region = NULL;
-		gc->ops->CopyArea(src, dst, gc, 0, 0, dst->width, dst->height, 0, 0);
+		clip = NULL;
+		(*gc->ops->CopyArea)(src, dst, gc,
+							 0, 0, dst->width, dst->height, 0, 0);
 		FreeScratchGC(gc);
 	}
 
- uninit:
-	if (sync_region)
-		RegionDestroy(sync_region);
+	done:
+	if (clip)
+		RegionDestroy(clip);
 	RegionUninit(&remaining);
 }
 
@@ -577,54 +604,52 @@ amdgpu_scanout_flip_abort(xf86CrtcPtr cr
 	drmmode_crtc->scanout_update_pending = 0;
 
 	if (drmmode_crtc->flip_pending == fb) {
-		drmmode_fb_reference(pAMDGPUEnt->fd, &drmmode_crtc->flip_pending,
-				     NULL);
+		drmmode_fb_reference(pAMDGPUEnt->fd, &drmmode_crtc->flip_pending, NULL);
 	}
 }
 
 static void
 amdgpu_scanout_flip_handler(xf86CrtcPtr crtc, uint32_t msc, uint64_t usec,
-			    void *event_data)
+							void *event_data)
 {
 	AMDGPUEntPtr pAMDGPUEnt = AMDGPUEntPriv(crtc->scrn);
 	drmmode_crtc_private_ptr drmmode_crtc = crtc->driver_private;
 	struct drmmode_fb *fb = event_data;
 
 	drmmode_fb_reference(pAMDGPUEnt->fd, &drmmode_crtc->fb, fb);
-	amdgpu_scanout_flip_abort(crtc, event_data);
+	amdgpu_scanout_flip_abort(crtc, event_data); /* This also unsets flip_pending if it was fb */
 }
 
 
-static RegionPtr
-dirty_region(PixmapDirtyUpdatePtr dirty)
+static __attribute__((hot)) RegionPtr
+dirty_region(PixmapDirtyUpdatePtr dirty) /* Marked hot */
 {
 	RegionPtr damageregion = DamageRegion(dirty->damage);
 	RegionPtr dstregion;
 
 	if (dirty->rotation != RR_Rotate_0) {
 		dstregion = transform_region(damageregion,
-					     &dirty->f_inverse,
-					     dirty->secondary_dst->drawable.width,
-					     dirty->secondary_dst->drawable.height);
-	} else
-	{
+									 &dirty->f_inverse,
+							   dirty->secondary_dst->drawable.width,
+							   dirty->secondary_dst->drawable.height);
+	} else {
 		RegionRec pixregion;
-
 		dstregion = RegionDuplicate(damageregion);
-		RegionTranslate(dstregion, -dirty->x, -dirty->y);
+		if (unlikely(!dstregion)) return NULL; /* Handle OOM from RegionDuplicate */
+
+			RegionTranslate(dstregion, -dirty->x, -dirty->y);
 		PixmapRegionInit(&pixregion, dirty->secondary_dst);
 		RegionIntersect(dstregion, dstregion, &pixregion);
 		RegionUninit(&pixregion);
 	}
-
 	return dstregion;
 }
 
-static void
+static __attribute__((hot)) void /* Marked hot */
 redisplay_dirty(PixmapDirtyUpdatePtr dirty, RegionPtr region)
 {
 	ScrnInfoPtr src_scrn =
-		xf86ScreenToScrn(amdgpu_dirty_src_drawable(dirty)->pScreen);
+	xf86ScreenToScrn(amdgpu_dirty_src_drawable(dirty)->pScreen);
 
 	if (RegionNil(region))
 		goto out;
@@ -637,16 +662,14 @@ redisplay_dirty(PixmapDirtyUpdatePtr dir
 	amdgpu_glamor_flush(src_scrn);
 	if (dirty->secondary_dst->primary_pixmap)
 		DamageRegionProcessPending(&dirty->secondary_dst->drawable);
-
-out:
+	out:
 	DamageEmpty(dirty->damage);
 }
 
-static void
+static __attribute__((cold)) void /* Marked cold */
 amdgpu_prime_scanout_update_abort(xf86CrtcPtr crtc, void *event_data)
 {
 	drmmode_crtc_private_ptr drmmode_crtc = crtc->driver_private;
-
 	drmmode_crtc->scanout_update_pending = 0;
 }
 
@@ -655,26 +678,25 @@ amdgpu_sync_shared_pixmap(PixmapDirtyUpd
 {
 	ScreenPtr primary_screen = amdgpu_dirty_primary(dirty);
 	PixmapDirtyUpdatePtr ent;
-	RegionPtr region;
+	RegionPtr region_obj; /* Renamed */
 
 	xorg_list_for_each_entry(ent, &primary_screen->pixmap_dirty_list, ent) {
 		if (!amdgpu_dirty_src_equals(dirty, ent->secondary_dst))
 			continue;
 
-		region = dirty_region(ent);
-		redisplay_dirty(ent, region);
-		RegionDestroy(region);
+		region_obj = dirty_region(ent);
+		if (unlikely(!region_obj)) continue; /* Skip if OOM in dirty_region */
+			redisplay_dirty(ent, region_obj);
+		RegionDestroy(region_obj);
 	}
 }
 
 
 #if HAS_SYNC_SHARED_PIXMAP
-
 static Bool
 primary_has_sync_shared_pixmap(ScrnInfoPtr scrn, PixmapDirtyUpdatePtr dirty)
 {
 	ScreenPtr primary_screen = amdgpu_dirty_primary(dirty);
-
 	return primary_screen->SyncSharedPixmap != NULL;
 }
 
@@ -682,7 +704,6 @@ static Bool
 secondary_has_sync_shared_pixmap(ScrnInfoPtr scrn, PixmapDirtyUpdatePtr dirty)
 {
 	ScreenPtr secondary_screen = dirty->secondary_dst->drawable.pScreen;
-
 	return secondary_screen->SyncSharedPixmap != NULL;
 }
 
@@ -690,17 +711,13 @@ static void
 call_sync_shared_pixmap(PixmapDirtyUpdatePtr dirty)
 {
 	ScreenPtr primary_screen = amdgpu_dirty_primary(dirty);
-
 	primary_screen->SyncSharedPixmap(dirty);
 }
-
-#else /* !HAS_SYNC_SHARED_PIXMAP */
-
+#else
 static Bool
 primary_has_sync_shared_pixmap(ScrnInfoPtr scrn, PixmapDirtyUpdatePtr dirty)
 {
 	ScrnInfoPtr primary_scrn = xf86ScreenToScrn(amdgpu_dirty_primary(dirty));
-
 	return primary_scrn->driverName == scrn->driverName;
 }
 
@@ -708,7 +725,6 @@ static Bool
 secondary_has_sync_shared_pixmap(ScrnInfoPtr scrn, PixmapDirtyUpdatePtr dirty)
 {
 	ScrnInfoPtr secondary_scrn = xf86ScreenToScrn(dirty->secondary_dst->drawable.pScreen);
-
 	return secondary_scrn->driverName == scrn->driverName;
 }
 
@@ -717,8 +733,7 @@ call_sync_shared_pixmap(PixmapDirtyUpdat
 {
 	amdgpu_sync_shared_pixmap(dirty);
 }
-
-#endif /* HAS_SYNC_SHARED_PIXMAPS */
+#endif
 
 
 static xf86CrtcPtr
@@ -729,15 +744,15 @@ amdgpu_prime_dirty_to_crtc(PixmapDirtyUp
 	xf86CrtcConfigPtr xf86_config = XF86_CRTC_CONFIG_PTR(scrn);
 	int c;
 
-	/* Find the CRTC which is scanning out from this secondary pixmap */
 	for (c = 0; c < xf86_config->num_crtc; c++) {
 		xf86CrtcPtr xf86_crtc = xf86_config->crtc[c];
-		drmmode_crtc_private_ptr drmmode_crtc = xf86_crtc->driver_private;
+		if (unlikely(!xf86_crtc)) continue; /* Safety check */
+			drmmode_crtc_private_ptr drmmode_crtc = xf86_crtc->driver_private;
+		if (unlikely(!drmmode_crtc)) continue; /* Safety check */
 
-		if (amdgpu_dirty_src_equals(dirty, drmmode_crtc->prime_scanout_pixmap))
-			return xf86_crtc;
+			if (amdgpu_dirty_src_equals(dirty, drmmode_crtc->prime_scanout_pixmap))
+				return xf86_crtc;
 	}
-
 	return NULL;
 }
 
@@ -752,46 +767,45 @@ amdgpu_prime_scanout_do_update(xf86CrtcP
 
 	xorg_list_for_each_entry(dirty, &screen->pixmap_dirty_list, ent) {
 		if (amdgpu_dirty_src_equals(dirty, drmmode_crtc->prime_scanout_pixmap)) {
-			RegionPtr region;
+			RegionPtr region_obj; /* Renamed */
 
 			if (primary_has_sync_shared_pixmap(scrn, dirty))
 				call_sync_shared_pixmap(dirty);
 
-			region = dirty_region(dirty);
-			if (RegionNil(region))
-				goto destroy;
+			region_obj = dirty_region(dirty);
+			if (unlikely(!region_obj)) break; /* OOM */
+
+				if (RegionNil(region_obj))
+					goto destroy_region;
 
 			if (drmmode_crtc->tear_free) {
-				RegionTranslate(region, crtc->x, crtc->y);
-				amdgpu_sync_scanout_pixmaps(crtc, region, scanout_id);
+				RegionTranslate(region_obj, crtc->x, crtc->y);
+				amdgpu_sync_scanout_pixmaps(crtc, region_obj, scanout_id);
 				amdgpu_glamor_flush(scrn);
-				RegionCopy(&drmmode_crtc->scanout_last_region, region);
-				RegionTranslate(region, -crtc->x, -crtc->y);
+				RegionCopy(&drmmode_crtc->scanout_last_region, region_obj);
+				RegionTranslate(region_obj, -crtc->x, -crtc->y);
 				dirty->secondary_dst = drmmode_crtc->scanout[scanout_id];
 			}
-
-			redisplay_dirty(dirty, region);
+			redisplay_dirty(dirty, region_obj);
 			ret = TRUE;
-		destroy:
-			RegionDestroy(region);
+			destroy_region:
+			RegionDestroy(region_obj);
 			break;
 		}
 	}
-
 	return ret;
 }
 
-static void
+static __attribute__((cold)) void /* Marked cold */
 amdgpu_prime_scanout_update_handler(xf86CrtcPtr crtc, uint32_t frame, uint64_t usec,
-				     void *event_data)
+									void *event_data)
 {
 	drmmode_crtc_private_ptr drmmode_crtc = crtc->driver_private;
-
 	amdgpu_prime_scanout_do_update(crtc, 0);
 	drmmode_crtc->scanout_update_pending = 0;
 }
 
-static void
+static __attribute__((hot)) void /* Marked hot */
 amdgpu_prime_scanout_update(PixmapDirtyUpdatePtr dirty)
 {
 	ScreenPtr screen = dirty->secondary_dst->drawable.pScreen;
@@ -801,61 +815,51 @@ amdgpu_prime_scanout_update(PixmapDirtyU
 	drmmode_crtc_private_ptr drmmode_crtc;
 	uintptr_t drm_queue_seq;
 
-	if (!xf86_crtc || !xf86_crtc->enabled)
+	if (unlikely(!xf86_crtc || !xf86_crtc->enabled))
 		return;
 
 	drmmode_crtc = xf86_crtc->driver_private;
-	if (drmmode_crtc->scanout_update_pending ||
-	    !drmmode_crtc->scanout[drmmode_crtc->scanout_id] ||
-	    drmmode_crtc->dpms_mode != DPMSModeOn)
+	if (unlikely(drmmode_crtc->scanout_update_pending ||
+		!drmmode_crtc->scanout[drmmode_crtc->scanout_id] ||
+		drmmode_crtc->dpms_mode != DPMSModeOn))
 		return;
 
 	drm_queue_seq = amdgpu_drm_queue_alloc(xf86_crtc,
-					       AMDGPU_DRM_QUEUE_CLIENT_DEFAULT,
-					       AMDGPU_DRM_QUEUE_ID_DEFAULT, NULL,
-					       amdgpu_prime_scanout_update_handler,
-					       amdgpu_prime_scanout_update_abort,
-					       FALSE);
-	if (drm_queue_seq == AMDGPU_DRM_QUEUE_ERROR) {
+										   AMDGPU_DRM_QUEUE_CLIENT_DEFAULT,
+										AMDGPU_DRM_QUEUE_ID_DEFAULT, NULL,
+										amdgpu_prime_scanout_update_handler,
+										amdgpu_prime_scanout_update_abort,
+										FALSE);
+	if (unlikely(drm_queue_seq == AMDGPU_DRM_QUEUE_ERROR)) {
 		xf86DrvMsg(scrn->scrnIndex, X_WARNING,
-			   "amdgpu_drm_queue_alloc failed for PRIME update\n");
+				   "amdgpu_drm_queue_alloc failed for PRIME update\n");
 		amdgpu_prime_scanout_update_handler(xf86_crtc, 0, 0, NULL);
 		return;
 	}
-
 	drmmode_crtc->scanout_update_pending = drm_queue_seq;
 
-	if (!drmmode_wait_vblank(xf86_crtc, DRM_VBLANK_RELATIVE | DRM_VBLANK_EVENT,
-				 1, drm_queue_seq, NULL, NULL)) {
+	if (unlikely(!drmmode_wait_vblank(xf86_crtc, DRM_VBLANK_RELATIVE | DRM_VBLANK_EVENT,
+		1, drm_queue_seq, NULL, NULL))) {
 		if (!(drmmode_crtc->scanout_status & DRMMODE_SCANOUT_VBLANK_FAILED)) {
 			xf86DrvMsg(scrn->scrnIndex, X_WARNING,
-				   "drmmode_wait_vblank failed for PRIME update: %s\n",
-				   strerror(errno));
+					   "drmmode_wait_vblank failed for PRIME update: %s\n",
+			  strerror(errno));
 			drmmode_crtc->scanout_status |= DRMMODE_SCANOUT_VBLANK_FAILED;
 		}
+		drmmode_crtc->drmmode->event_context.vblank_handler(pAMDGPUEnt->fd, 0, 0, 0, (void*)drm_queue_seq);
+	drmmode_crtc->wait_flip_nesting_level++;
+	amdgpu_drm_queue_handle_deferred(xf86_crtc);
+	return;
+		}
 
-		drmmode_crtc->drmmode->event_context.vblank_handler(pAMDGPUEnt->fd,
-								    0, 0, 0,
-								    (void*)drm_queue_seq);
-		drmmode_crtc->wait_flip_nesting_level++;
-		amdgpu_drm_queue_handle_deferred(xf86_crtc);
-		return;
-	}
-
-	if (drmmode_crtc->scanout_status ==
-	    (DRMMODE_SCANOUT_FLIP_FAILED | DRMMODE_SCANOUT_VBLANK_FAILED)) {
-		/* The page flip and vblank ioctls failed before, but the vblank
-		 * ioctl is working again, so we can try re-enabling TearFree
-		 */
-		xf86_crtc->funcs->set_mode_major(xf86_crtc, &xf86_crtc->mode,
-						 xf86_crtc->rotation,
-						 xf86_crtc->x, xf86_crtc->y);
-	}
-
-	drmmode_crtc->scanout_status &= ~DRMMODE_SCANOUT_VBLANK_FAILED;
+		if (drmmode_crtc->scanout_status == (DRMMODE_SCANOUT_FLIP_FAILED | DRMMODE_SCANOUT_VBLANK_FAILED)) {
+			xf86_crtc->funcs->set_mode_major(xf86_crtc, &xf86_crtc->mode,
+											 xf86_crtc->rotation, xf86_crtc->x, xf86_crtc->y);
+		}
+		drmmode_crtc->scanout_status &= ~DRMMODE_SCANOUT_VBLANK_FAILED;
 }
 
-static void
+static __attribute__((hot)) void /* Marked hot */
 amdgpu_prime_scanout_flip(PixmapDirtyUpdatePtr ent)
 {
 	ScreenPtr screen = ent->secondary_dst->drawable.pScreen;
@@ -867,89 +871,80 @@ amdgpu_prime_scanout_flip(PixmapDirtyUpd
 	unsigned scanout_id;
 	struct drmmode_fb *fb;
 
-	if (!crtc || !crtc->enabled)
-		return;
+	if (unlikely(!crtc || !crtc->enabled)) return;
 
 	drmmode_crtc = crtc->driver_private;
 	scanout_id = drmmode_crtc->scanout_id ^ 1;
-	if (drmmode_crtc->scanout_update_pending ||
-	    !drmmode_crtc->scanout[scanout_id] ||
-	    drmmode_crtc->dpms_mode != DPMSModeOn)
+
+	if (unlikely(drmmode_crtc->scanout_update_pending ||
+		!drmmode_crtc->scanout[scanout_id] ||
+		drmmode_crtc->dpms_mode != DPMSModeOn))
 		return;
 
-	if (!amdgpu_prime_scanout_do_update(crtc, scanout_id))
+	if (unlikely(!amdgpu_prime_scanout_do_update(crtc, scanout_id)))
 		return;
 
 	fb = amdgpu_pixmap_get_fb(drmmode_crtc->scanout[scanout_id]);
-	if (!fb) {
-		xf86DrvMsg(scrn->scrnIndex, X_WARNING,
-			   "Failed to get FB for PRIME flip.\n");
+	if (unlikely(!fb)) {
+		xf86DrvMsg(scrn->scrnIndex, X_WARNING, "Failed to get FB for PRIME flip.\n");
 		return;
 	}
-	
-	drm_queue_seq = amdgpu_drm_queue_alloc(crtc,
-					       AMDGPU_DRM_QUEUE_CLIENT_DEFAULT,
-					       AMDGPU_DRM_QUEUE_ID_DEFAULT, fb,
-					       amdgpu_scanout_flip_handler,
-					       amdgpu_scanout_flip_abort, TRUE);
-	if (drm_queue_seq == AMDGPU_DRM_QUEUE_ERROR) {
-		xf86DrvMsg(scrn->scrnIndex, X_WARNING,
-			   "Allocating DRM event queue entry failed for PRIME flip.\n");
-		return;
+
+	drm_queue_seq = amdgpu_drm_queue_alloc(crtc, AMDGPU_DRM_QUEUE_CLIENT_DEFAULT,
+										   AMDGPU_DRM_QUEUE_ID_DEFAULT, fb,
+										amdgpu_scanout_flip_handler,
+										amdgpu_scanout_flip_abort, TRUE);
+	if (unlikely(drm_queue_seq == AMDGPU_DRM_QUEUE_ERROR)) {
+		xf86DrvMsg(scrn->scrnIndex, X_WARNING, "Allocating DRM event queue entry failed for PRIME flip.\n");
+		/* Manually unref fb if queue_alloc failed, as abort handler won't be called */
+		if (fb) drmmode_fb_reference(pAMDGPUEnt->fd, &fb, NULL); /* Check if fb is still this one */
+			return;
 	}
 
-	if (drmmode_page_flip_target_relative(pAMDGPUEnt, drmmode_crtc,
-					      fb->handle, 0, drm_queue_seq, 1)
-	    != 0) {
+	if (unlikely(drmmode_page_flip_target_relative(pAMDGPUEnt, drmmode_crtc,
+		fb->handle, 0, drm_queue_seq, 1) != 0)) {
 		if (!(drmmode_crtc->scanout_status & DRMMODE_SCANOUT_FLIP_FAILED)) {
 			xf86DrvMsg(scrn->scrnIndex, X_WARNING,
-				   "flip queue failed in %s: %s, TearFree inactive\n",
-				   __func__, strerror(errno));
+					   "flip queue failed in %s: %s, TearFree inactive\n", __func__, strerror(errno));
 			drmmode_crtc->scanout_status |= DRMMODE_SCANOUT_FLIP_FAILED;
 		}
-
-		amdgpu_drm_abort_entry(drm_queue_seq);
+		amdgpu_drm_abort_entry(drm_queue_seq); /* This will call amdgpu_scanout_flip_abort, unref'ing fb */
 		return;
-	}
-
-	if (drmmode_crtc->scanout_status & DRMMODE_SCANOUT_FLIP_FAILED) {
-		xf86DrvMsg(scrn->scrnIndex, X_INFO, "TearFree active again\n");
-		drmmode_crtc->scanout_status &= ~DRMMODE_SCANOUT_FLIP_FAILED;
-	}
+		}
 
-	drmmode_crtc->scanout_id = scanout_id;
-	drmmode_crtc->scanout_update_pending = drm_queue_seq;
-	drmmode_fb_reference(pAMDGPUEnt->fd, &drmmode_crtc->flip_pending, fb);
+		if (drmmode_crtc->scanout_status & DRMMODE_SCANOUT_FLIP_FAILED) {
+			xf86DrvMsg(scrn->scrnIndex, X_INFO, "TearFree active again\n");
+			drmmode_crtc->scanout_status &= ~DRMMODE_SCANOUT_FLIP_FAILED;
+		}
+		drmmode_crtc->scanout_id = scanout_id;
+		drmmode_crtc->scanout_update_pending = drm_queue_seq;
+		drmmode_fb_reference(pAMDGPUEnt->fd, &drmmode_crtc->flip_pending, fb);
 }
 
-static void
+static __attribute__((hot)) void /* Marked hot */
 amdgpu_dirty_update(ScrnInfoPtr scrn)
 {
 	ScreenPtr screen = scrn->pScreen;
 	PixmapDirtyUpdatePtr ent;
-	RegionPtr region;
+	RegionPtr region_obj; /* Renamed */
 
 	xorg_list_for_each_entry(ent, &screen->pixmap_dirty_list, ent) {
 		if (screen->isGPU) {
 			PixmapDirtyUpdatePtr region_ent = ent;
-
 			if (primary_has_sync_shared_pixmap(scrn, ent)) {
 				ScreenPtr primary_screen = amdgpu_dirty_primary(ent);
-
 				xorg_list_for_each_entry(region_ent, &primary_screen->pixmap_dirty_list, ent) {
 					if (amdgpu_dirty_src_equals(ent, region_ent->secondary_dst))
 						break;
 				}
 			}
+			region_obj = dirty_region(region_ent);
+			if (unlikely(!region_obj)) continue;
 
-			region = dirty_region(region_ent);
-
-			if (RegionNotEmpty(region)) {
+			if (RegionNotEmpty(region_obj)) {
 				xf86CrtcPtr crtc = amdgpu_prime_dirty_to_crtc(ent);
 				drmmode_crtc_private_ptr drmmode_crtc = NULL;
-
-				if (crtc)
-					drmmode_crtc = crtc->driver_private;
+				if (crtc) drmmode_crtc = crtc->driver_private;
 
 				if (drmmode_crtc && drmmode_crtc->tear_free)
 					amdgpu_prime_scanout_flip(ent);
@@ -958,490 +953,432 @@ amdgpu_dirty_update(ScrnInfoPtr scrn)
 			} else {
 				DamageEmpty(region_ent->damage);
 			}
-
-			RegionDestroy(region);
+			RegionDestroy(region_obj);
 		} else {
-			if (secondary_has_sync_shared_pixmap(scrn, ent))
-				continue;
-
-			region = dirty_region(ent);
-			redisplay_dirty(ent, region);
-			RegionDestroy(region);
+			if (secondary_has_sync_shared_pixmap(scrn, ent)) continue;
+			region_obj = dirty_region(ent);
+			if (unlikely(!region_obj)) continue;
+			redisplay_dirty(ent, region_obj);
+			RegionDestroy(region_obj);
 		}
 	}
 }
 
 static void
 amdgpuSourceValidate(DrawablePtr draw, int x, int y, int w, int h,
-		     unsigned int subWindowMode)
+					 unsigned int subWindowMode)
 {
 }
 
 Bool
 amdgpu_scanout_do_update(xf86CrtcPtr xf86_crtc, int scanout_id,
-			 PixmapPtr src_pix, BoxRec extents)
+						 PixmapPtr   src_pix, BoxRec extents_fb) /* extents_fb is in framebuffer coords */
 {
 	drmmode_crtc_private_ptr drmmode_crtc = xf86_crtc->driver_private;
-	RegionRec region = { .extents = extents, .data = NULL };
 	ScrnInfoPtr scrn = xf86_crtc->scrn;
-	ScreenPtr pScreen = scrn->pScreen;
-	DrawablePtr pDraw;
+	ScreenPtr   pScr = scrn->pScreen;
+	DrawablePtr dst_draw;
+	BoxRec extents_crtc = extents_fb; /* Copy to modify for CRTC-local intersection */
 
-	if (!xf86_crtc->enabled ||
-	    !drmmode_crtc->scanout[scanout_id] ||
-	    extents.x1 >= extents.x2 || extents.y1 >= extents.y2)
+	if (unlikely(!xf86_crtc->enabled || !drmmode_crtc->scanout[scanout_id] ||
+		extents_crtc.x1 >= extents_crtc.x2 || extents_crtc.y1 >= extents_crtc.y2))
 		return FALSE;
 
-	pDraw = &drmmode_crtc->scanout[scanout_id]->drawable;
-	if (!amdgpu_scanout_extents_intersect(xf86_crtc, &extents))
+	dst_draw = &drmmode_crtc->scanout[scanout_id]->drawable;
+
+	if (!amdgpu_scanout_extents_intersect(xf86_crtc, &extents_crtc))
 		return FALSE;
 
+	/* extents_crtc is now the CRTC-local area to update */
+
 	if (drmmode_crtc->tear_free) {
-		amdgpu_sync_scanout_pixmaps(xf86_crtc, &region, scanout_id);
-		RegionCopy(&drmmode_crtc->scanout_last_region, &region);
+		RegionRec fb_region_to_sync;
+		fb_region_to_sync.extents = extents_crtc; /* Start with CRTC-local intersected rect */
+		fb_region_to_sync.data = NULL;
+
+		if (!scrn->is_gpu && !xf86_crtc->driverIsPerformingTransform) {
+			/* If primary GPU and no RandR transform, add CRTC offsets */
+			fb_region_to_sync.extents.x1 += xf86_crtc->x;
+			fb_region_to_sync.extents.x2 += xf86_crtc->x;
+			fb_region_to_sync.extents.y1 += xf86_crtc->y;
+			fb_region_to_sync.extents.y2 += xf86_crtc->y;
+		} else if (xf86_crtc->driverIsPerformingTransform) {
+			fb_region_to_sync.extents = extents_fb;
+		}
+
+		amdgpu_sync_scanout_pixmaps(xf86_crtc, &(RegionRec){.extents = extents_fb, .data = NULL}, scanout_id);
+		RegionCopy(&drmmode_crtc->scanout_last_region, &(RegionRec){.extents = extents_fb, .data = NULL});
 	}
 
 	if (xf86_crtc->driverIsPerformingTransform) {
-		SourceValidateProcPtr SourceValidate = pScreen->SourceValidate;
-		PictFormatPtr format = PictureWindowFormat(pScreen->root);
+		SourceValidateProcPtr SourceValidate = pScr->SourceValidate;
+		PictFormatPtr format = PictureWindowFormat(pScr->root);
 		int error;
-		PicturePtr src, dst;
+		PicturePtr src_pic, dst_pic; /* Renamed */
 
-		src = CreatePicture(None, &src_pix->drawable, format, 0L, NULL,
-				    serverClient, &error);
-		if (!src) {
-			ErrorF("Failed to create source picture for transformed scanout "
-			       "update\n");
-			goto out;
-		}
-
-		dst = CreatePicture(None, pDraw, format, 0L, NULL, serverClient, &error);
-		if (!dst) {
-			ErrorF("Failed to create destination picture for transformed scanout "
-			       "update\n");
-			goto free_src;
-		}
-		error = SetPictureTransform(src, &xf86_crtc->crtc_to_framebuffer);
-		if (error) {
-			ErrorF("SetPictureTransform failed for transformed scanout "
-			       "update\n");
-			goto free_dst;
-		}
-
-		if (xf86_crtc->filter)
-			SetPicturePictFilter(src, xf86_crtc->filter, xf86_crtc->params,
-					     xf86_crtc->nparams);
+		src_pic = CreatePicture(None, &src_pix->drawable, format, 0L, NULL, serverClient, &error);
+		if (unlikely(!src_pic)) { ErrorF("Failed to create source picture\n"); return TRUE; } /* Still an update, but logged */
 
-		pScreen->SourceValidate = amdgpuSourceValidate;
-		CompositePicture(PictOpSrc,
-				 src, NULL, dst,
-				 extents.x1, extents.y1, 0, 0, extents.x1,
-				 extents.y1, extents.x2 - extents.x1,
-				 extents.y2 - extents.y1);
-		pScreen->SourceValidate = SourceValidate;
-
- free_dst:
-		FreePicture(dst, None);
- free_src:
-		FreePicture(src, None);
-	} else
- out:
-	{
-		GCPtr gc = GetScratchGC(pDraw->depth, pScreen);
+			dst_pic = CreatePicture(None, dst_draw, format, 0L, NULL, serverClient, &error);
+			if (unlikely(!dst_pic)) { ErrorF("Failed to create dest picture\n"); FreePicture(src_pic, None); return TRUE; }
 
-		ValidateGC(pDraw, gc);
-		(*gc->ops->CopyArea)(&src_pix->drawable, pDraw, gc,
-				     xf86_crtc->x + extents.x1, xf86_crtc->y + extents.y1,
-				     extents.x2 - extents.x1, extents.y2 - extents.y1,
-				     extents.x1, extents.y1);
-		FreeScratchGC(gc);
-	}
+			error = SetPictureTransform(src_pic, &xf86_crtc->crtc_to_framebuffer);
+			if (unlikely(error)) { ErrorF("SetPictureTransform failed\n"); goto free_pictures; }
 
+			if (xf86_crtc->filter)
+				SetPicturePictFilter(src_pic, xf86_crtc->filter, xf86_crtc->params, xf86_crtc->nparams);
+
+		pScr->SourceValidate = amdgpuSourceValidate;
+		CompositePicture(PictOpSrc,
+						 src_pic, NULL, dst_pic,
+				   extents_crtc.x1, extents_crtc.y1, /* srcX/Y for Composite are after transform */
+				   0, 0,                             /* maskX/Y */
+				   extents_crtc.x1, extents_crtc.y1, /* dstX/Y */
+				   extents_crtc.x2 - extents_crtc.x1, /* width */
+				   extents_crtc.y2 - extents_crtc.y1);/* height */
+		pScr->SourceValidate = SourceValidate;
+
+		free_pictures:
+		FreePicture(dst_pic, None);
+		FreePicture(src_pic, None);
+	} else { /* Not driverIsPerformingTransform */
+		GCPtr gc = GetScratchGC(dst_draw->depth, pScr);
+		if (likely(gc)) {
+			ValidateGC(dst_draw, gc);
+			(*gc->ops->CopyArea)(&src_pix->drawable, dst_draw, gc,
+								 xf86_crtc->x + extents_crtc.x1, /* srcX in framebuffer coords */
+						xf86_crtc->y + extents_crtc.y1, /* srcY in framebuffer coords */
+						extents_crtc.x2 - extents_crtc.x1, /* width */
+						extents_crtc.y2 - extents_crtc.y1, /* height */
+						extents_crtc.x1, /* dstX in CRTC-local scanout pixmap */
+						extents_crtc.y1);/* dstY in CRTC-local scanout pixmap */
+			FreeScratchGC(gc);
+		}
+	}
 	return TRUE;
 }
 
-static void
+static __attribute__((cold)) void /* Marked cold */
 amdgpu_scanout_update_abort(xf86CrtcPtr crtc, void *event_data)
 {
-	drmmode_crtc_private_ptr drmmode_crtc = event_data;
-
+	drmmode_crtc_private_ptr drmmode_crtc = event_data; /* event_data is drmmode_crtc itself */
 	drmmode_crtc->scanout_update_pending = 0;
 }
 
-static void
-amdgpu_scanout_update_handler(xf86CrtcPtr crtc, uint32_t frame, uint64_t usec,
-							  void *event_data)
+static __attribute__((cold)) void /* Marked cold */
+amdgpu_scanout_update_handler(xf86CrtcPtr crtc, uint32_t frame, uint64_t usec, void *event_data)
 {
 	drmmode_crtc_private_ptr drmmode_crtc = event_data;
 	ScreenPtr screen = crtc->scrn->pScreen;
-	RegionPtr region = DamageRegion(drmmode_crtc->scanout_damage);
+	RegionPtr region_obj = DamageRegion(drmmode_crtc->scanout_damage); /* Renamed */
 
-	if (crtc->enabled &&
-	    !drmmode_crtc->flip_pending &&
-	    drmmode_crtc->dpms_mode == DPMSModeOn) {
+	if (likely(crtc->enabled && !drmmode_crtc->flip_pending && drmmode_crtc->dpms_mode == DPMSModeOn)) {
+		/* Note: RegionExtents(region_obj) returns a pointer to box within region_obj,
+		 * amdgpu_scanout_do_update will modify its copy of extents.
+		 */
 		if (amdgpu_scanout_do_update(crtc, drmmode_crtc->scanout_id,
-					     screen->GetWindowPixmap(screen->root),
-					     region->extents)) {
-			amdgpu_glamor_flush(crtc->scrn);
-			RegionEmpty(region);
-		}
+			screen->GetWindowPixmap(screen->root),
+									 region_obj->extents)) { /* Pass extents directly */
+										 amdgpu_glamor_flush(crtc->scrn);
+										 RegionEmpty(region_obj); /* Region is modified by amdgpu_scanout_extents_intersect via amdgpu_scanout_do_update */
+									 }
 	}
-
-	amdgpu_scanout_update_abort(crtc, event_data);
+	amdgpu_scanout_update_abort(crtc, event_data); /* Pass drmmode_crtc as event_data */
 }
 
-static void
+/* idea #7 – skip vblank ioctl when nothing to do */
+static __attribute__((hot)) void
 amdgpu_scanout_update(xf86CrtcPtr xf86_crtc)
 {
 	drmmode_crtc_private_ptr drmmode_crtc = xf86_crtc->driver_private;
 	ScrnInfoPtr scrn = xf86_crtc->scrn;
-	AMDGPUEntPtr pAMDGPUEnt = AMDGPUEntPriv(scrn);
-	uintptr_t drm_queue_seq;
+	AMDGPUEntPtr pEnt = AMDGPUEntPriv(scrn); /* Renamed pAMDGPUEnt */
 	DamagePtr pDamage;
 	RegionPtr pRegion;
-	BoxRec extents;
+	BoxRec extents_copy; /* Use a copy for amdgpu_scanout_extents_intersect */
 
-	if (!xf86_crtc->enabled ||
-	    drmmode_crtc->scanout_update_pending ||
-	    drmmode_crtc->flip_pending ||
-	    drmmode_crtc->dpms_mode != DPMSModeOn)
+	if (unlikely(!xf86_crtc->enabled || drmmode_crtc->scanout_update_pending ||
+		drmmode_crtc->flip_pending || drmmode_crtc->dpms_mode != DPMSModeOn))
 		return;
 
 	pDamage = drmmode_crtc->scanout_damage;
-	if (!pDamage)
-		return;
+	if (unlikely(!pDamage)) return;
 
 	pRegion = DamageRegion(pDamage);
-	if (!RegionNotEmpty(pRegion))
+	if (unlikely(!RegionNotEmpty(pRegion))) /* EARLY OUT saves ioctl */
 		return;
 
-	extents = *RegionExtents(pRegion);
-	if (!amdgpu_scanout_extents_intersect(xf86_crtc, &extents)) {
-		RegionEmpty(pRegion);
+	extents_copy = *RegionExtents(pRegion); /* Make a copy */
+	if (!amdgpu_scanout_extents_intersect(xf86_crtc, &extents_copy)) {
+		RegionEmpty(pRegion); /* Original region is emptied if no intersection */
 		return;
 	}
 
-	drm_queue_seq = amdgpu_drm_queue_alloc(xf86_crtc,
-					       AMDGPU_DRM_QUEUE_CLIENT_DEFAULT,
-					       AMDGPU_DRM_QUEUE_ID_DEFAULT,
-					       drmmode_crtc,
-					       amdgpu_scanout_update_handler,
-					       amdgpu_scanout_update_abort,
-					       FALSE);
-	if (drm_queue_seq == AMDGPU_DRM_QUEUE_ERROR) {
+	uintptr_t drm_queue_seq = amdgpu_drm_queue_alloc(xf86_crtc,
+													 AMDGPU_DRM_QUEUE_CLIENT_DEFAULT,
+												  AMDGPU_DRM_QUEUE_ID_DEFAULT,
+												  drmmode_crtc, /* Pass drmmode_crtc as data */
+												  amdgpu_scanout_update_handler,
+												  amdgpu_scanout_update_abort,
+												  FALSE);
+	if (unlikely(drm_queue_seq == AMDGPU_DRM_QUEUE_ERROR)) {
 		xf86DrvMsg(scrn->scrnIndex, X_WARNING,
-			   "amdgpu_drm_queue_alloc failed for scanout update\n");
+				   "amdgpu_drm_queue_alloc failed for scanout update\n");
 		amdgpu_scanout_update_handler(xf86_crtc, 0, 0, drmmode_crtc);
 		return;
 	}
-
 	drmmode_crtc->scanout_update_pending = drm_queue_seq;
 
-	if (!drmmode_wait_vblank(xf86_crtc, DRM_VBLANK_RELATIVE | DRM_VBLANK_EVENT,
-				 1, drm_queue_seq, NULL, NULL)) {
+	if (unlikely(!drmmode_wait_vblank(xf86_crtc, DRM_VBLANK_RELATIVE | DRM_VBLANK_EVENT,
+		1, drm_queue_seq, NULL, NULL))) {
 		if (!(drmmode_crtc->scanout_status & DRMMODE_SCANOUT_VBLANK_FAILED)) {
 			xf86DrvMsg(scrn->scrnIndex, X_WARNING,
-				   "drmmode_wait_vblank failed for scanout update: %s\n",
-				   strerror(errno));
+					   "drmmode_wait_vblank failed for scanout update: %s\n", strerror(errno));
 			drmmode_crtc->scanout_status |= DRMMODE_SCANOUT_VBLANK_FAILED;
 		}
-
-		drmmode_crtc->drmmode->event_context.vblank_handler(pAMDGPUEnt->fd,
-								    0, 0, 0,
-								    (void*)drm_queue_seq);
+		drmmode_crtc->drmmode->event_context.vblank_handler(
+			pEnt->fd, 0, 0, 0, (void*)drm_queue_seq);
 		drmmode_crtc->wait_flip_nesting_level++;
-		amdgpu_drm_queue_handle_deferred(xf86_crtc);
-		return;
-	}
-
-	if (drmmode_crtc->scanout_status ==
-	    (DRMMODE_SCANOUT_FLIP_FAILED | DRMMODE_SCANOUT_VBLANK_FAILED)) {
-		/* The page flip and vblank ioctls failed before, but the vblank
-		 * ioctl is working again, so we can try re-enabling TearFree
-		 */
-		xf86_crtc->funcs->set_mode_major(xf86_crtc, &xf86_crtc->mode,
-						 xf86_crtc->rotation,
-						 xf86_crtc->x, xf86_crtc->y);
-	}
+	amdgpu_drm_queue_handle_deferred(xf86_crtc);
+	return;
+		}
 
-	drmmode_crtc->scanout_status &= ~DRMMODE_SCANOUT_VBLANK_FAILED;
+		if (drmmode_crtc->scanout_status ==
+			(DRMMODE_SCANOUT_FLIP_FAILED | DRMMODE_SCANOUT_VBLANK_FAILED)) {
+			xf86_crtc->funcs->set_mode_major(xf86_crtc, &xf86_crtc->mode,
+											 xf86_crtc->rotation, xf86_crtc->x, xf86_crtc->y);
+			}
+			drmmode_crtc->scanout_status &= ~DRMMODE_SCANOUT_VBLANK_FAILED;
 }
 
-static void
+
+static __attribute__((hot)) void
 amdgpu_scanout_flip(ScreenPtr pScreen, AMDGPUInfoPtr info,
 					xf86CrtcPtr xf86_crtc)
 {
 	drmmode_crtc_private_ptr drmmode_crtc = xf86_crtc->driver_private;
-	RegionPtr region = DamageRegion(drmmode_crtc->scanout_damage);
+	RegionPtr region_ptr = DamageRegion(drmmode_crtc->scanout_damage); /* Renamed region */
 	ScrnInfoPtr scrn = xf86_crtc->scrn;
-	AMDGPUEntPtr pAMDGPUEnt = AMDGPUEntPriv(scrn);
+	AMDGPUEntPtr pEnt = AMDGPUEntPriv(scrn);
 	uintptr_t drm_queue_seq;
 	unsigned scanout_id;
 	struct drmmode_fb *fb;
 
-	if (drmmode_crtc->scanout_update_pending ||
-	    drmmode_crtc->flip_pending ||
-	    drmmode_crtc->dpms_mode != DPMSModeOn)
+	if (unlikely(drmmode_crtc->scanout_update_pending ||
+		drmmode_crtc->flip_pending ||
+		drmmode_crtc->dpms_mode != DPMSModeOn))
 		return;
 
 	scanout_id = drmmode_crtc->scanout_id ^ 1;
-	if (!amdgpu_scanout_do_update(xf86_crtc, scanout_id,
-				      pScreen->GetWindowPixmap(pScreen->root),
-				      region->extents))
-		return;
+	if (unlikely(!amdgpu_scanout_do_update(xf86_crtc, scanout_id,
+		pScreen->GetWindowPixmap(pScreen->root),
+										   region_ptr->extents))) /* Pass the actual extents */
+	return;
 
 	amdgpu_glamor_flush(scrn);
-	RegionEmpty(region);
+	RegionEmpty(region_ptr);
 
 	fb = amdgpu_pixmap_get_fb(drmmode_crtc->scanout[scanout_id]);
-	if (!fb) {
+	if (unlikely(!fb)) {
 		xf86DrvMsg(scrn->scrnIndex, X_WARNING,
-			   "Failed to get FB for scanout flip.\n");
+				   "Failed to get FB for scanout flip.\n");
 		return;
 	}
 
 	drm_queue_seq = amdgpu_drm_queue_alloc(xf86_crtc,
-					       AMDGPU_DRM_QUEUE_CLIENT_DEFAULT,
-					       AMDGPU_DRM_QUEUE_ID_DEFAULT, fb,
-					       amdgpu_scanout_flip_handler,
-					       amdgpu_scanout_flip_abort, TRUE);
-	if (drm_queue_seq == AMDGPU_DRM_QUEUE_ERROR) {
+										   AMDGPU_DRM_QUEUE_CLIENT_DEFAULT,
+										AMDGPU_DRM_QUEUE_ID_DEFAULT,
+										fb,
+										amdgpu_scanout_flip_handler,
+										amdgpu_scanout_flip_abort, TRUE);
+	if (unlikely(drm_queue_seq == AMDGPU_DRM_QUEUE_ERROR)) {
 		xf86DrvMsg(scrn->scrnIndex, X_WARNING,
-			   "Allocating DRM event queue entry failed.\n");
+				   "Allocating DRM event queue entry failed.\n");
+		drmmode_fb_reference(pEnt->fd, &fb, NULL); /* Unref since it won't be passed to handler */
 		return;
 	}
 
-	if (drmmode_page_flip_target_relative(pAMDGPUEnt, drmmode_crtc,
-					      fb->handle, 0, drm_queue_seq, 1)
-	    != 0) {
+	if (unlikely(drmmode_page_flip_target_relative(pEnt, drmmode_crtc,
+		fb->handle, 0,
+		drm_queue_seq, 1) != 0)) {
 		if (!(drmmode_crtc->scanout_status & DRMMODE_SCANOUT_FLIP_FAILED)) {
 			xf86DrvMsg(scrn->scrnIndex, X_WARNING,
-				   "flip queue failed in %s: %s, TearFree inactive\n",
-				   __func__, strerror(errno));
+					   "flip queue failed in %s: %s, TearFree inactive\n",
+			  __func__, strerror(errno));
 			drmmode_crtc->scanout_status |= DRMMODE_SCANOUT_FLIP_FAILED;
 		}
-
-		amdgpu_drm_abort_entry(drm_queue_seq);
-		RegionCopy(DamageRegion(drmmode_crtc->scanout_damage),
-			   &drmmode_crtc->scanout_last_region);
-		RegionEmpty(&drmmode_crtc->scanout_last_region);
+		amdgpu_drm_abort_entry(drm_queue_seq); /* This will call amdgpu_scanout_flip_abort */
+		/* If flip failed, copy current damage to last_region before trying a non-flip update */
+		RegionCopy(&drmmode_crtc->scanout_last_region, DamageRegion(drmmode_crtc->scanout_damage));
+		RegionEmpty(&drmmode_crtc->scanout_last_region); /* Should be empty before non-flip update */
 		amdgpu_scanout_update(xf86_crtc);
 		drmmode_crtc_scanout_destroy(&drmmode_crtc->scanout[scanout_id]);
 		drmmode_crtc->tear_free = FALSE;
 		return;
-	}
+		}
 
-	if (drmmode_crtc->scanout_status & DRMMODE_SCANOUT_FLIP_FAILED) {
-		xf86DrvMsg(scrn->scrnIndex, X_INFO, "TearFree active again\n");
-		drmmode_crtc->scanout_status &= ~DRMMODE_SCANOUT_FLIP_FAILED;
-	}
+		if (drmmode_crtc->scanout_status & DRMMODE_SCANOUT_FLIP_FAILED) {
+			xf86DrvMsg(scrn->scrnIndex, X_INFO, "TearFree active again\n");
+			drmmode_crtc->scanout_status &= ~DRMMODE_SCANOUT_FLIP_FAILED;
+		}
 
-	drmmode_crtc->scanout_id = scanout_id;
-	drmmode_crtc->scanout_update_pending = drm_queue_seq;
-	drmmode_fb_reference(pAMDGPUEnt->fd, &drmmode_crtc->flip_pending, fb);
+		drmmode_crtc->scanout_id            = scanout_id;
+		drmmode_crtc->scanout_update_pending = drm_queue_seq;
+		drmmode_fb_reference(pEnt->fd, &drmmode_crtc->flip_pending, fb);
 }
 
-static void AMDGPUBlockHandler_KMS(BLOCKHANDLER_ARGS_DECL)
+__attribute__((hot))
+static void
+AMDGPUBlockHandler_KMS(ScreenPtr pScreen, pointer timeout)
 {
-	ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
-	AMDGPUInfoPtr info = AMDGPUPTR(pScrn);
-	xf86CrtcConfigPtr xf86_config = XF86_CRTC_CONFIG_PTR(pScrn);
-	int c;
+	ScrnInfoPtr           pScrn       = xf86ScreenToScrn(pScreen);
+	AMDGPUInfoPtr         info        = AMDGPUPTR(pScrn);
+	xf86CrtcConfigPtr     xf86_config = XF86_CRTC_CONFIG_PTR(pScrn);
+	int                   i;
 
-	pScreen->BlockHandler = info->BlockHandler;
-	(*pScreen->BlockHandler) (BLOCKHANDLER_ARGS);
-	pScreen->BlockHandler = AMDGPUBlockHandler_KMS;
+	if (unlikely(info->BlockHandler)) {
+		/* Temporarily restore and invoke the original handler. */
+		ScreenBlockHandlerProcPtr saved = info->BlockHandler;
 
-	if (!xf86ScreenToScrn(amdgpu_primary_screen(pScreen))->vtSema)
+		pScreen->BlockHandler = saved;          /* unwrap            */
+		saved(pScreen, timeout);                /* … call through …  */
+		pScreen->BlockHandler = AMDGPUBlockHandler_KMS; /* re-wrap    */
+	}
+
+	if (unlikely(!pScrn->vtSema))
 		return;
 
-	if (!pScreen->isGPU)
-	{
-		for (c = 0; c < xf86_config->num_crtc; c++) {
-			xf86CrtcPtr crtc = xf86_config->crtc[c];
-			drmmode_crtc_private_ptr drmmode_crtc = crtc->driver_private;
+	if (pScreen->isGPU)
+		goto flush_and_dirty;
+
+	for (i = 0; i < xf86_config->num_crtc; ++i) {
+		xf86CrtcPtr crtc = xf86_config->crtc[i];
+		if (unlikely(!crtc))
+			continue;
+
+		drmmode_crtc_private_ptr drmmode = crtc->driver_private;
+		if (unlikely(!drmmode))
+			continue;
 
-			if (drmmode_crtc->rotate)
-				continue;
+		if (drmmode->rotate)
+			continue;
 
-			if (drmmode_crtc->tear_free)
+			if (drmmode->tear_free)
 				amdgpu_scanout_flip(pScreen, info, crtc);
-			else if (drmmode_crtc->scanout[drmmode_crtc->scanout_id])
-				amdgpu_scanout_update(crtc);
-		}
+		else if (drmmode->scanout[drmmode->scanout_id])
+			amdgpu_scanout_update(crtc);
 	}
 
-#if XORG_VERSION_CURRENT < XORG_VERSION_NUMERIC(1,19,0,0,0)
+	flush_and_dirty:
+	#if XORG_VERSION_CURRENT < XORG_VERSION_NUMERIC(1,19,0,0,0)
 	if (info->use_glamor)
 		amdgpu_glamor_flush(pScrn);
-#endif
-
+	#endif
 	amdgpu_dirty_update(pScrn);
 }
 
-/* This is called by AMDGPUPreInit to set up the default visual */
-static Bool AMDGPUPreInitVisual(ScrnInfoPtr pScrn)
+static void
+AMDGPUBlockHandler_Install(ScreenPtr pScreen)
 {
-	AMDGPUInfoPtr info = AMDGPUPTR(pScrn);
+	ScrnInfoPtr   pScrn = xf86ScreenToScrn(pScreen);
+	AMDGPUInfoPtr info  = AMDGPUPTR(pScrn);
 
-	if (!xf86SetDepthBpp(pScrn, 0, 0, 0, Support32bppFb))
-		return FALSE;
+	if (!info->BlockHandler) {
+		info->BlockHandler  = pScreen->BlockHandler;
+		pScreen->BlockHandler = AMDGPUBlockHandler_KMS;
+	}
+}
 
+static Bool AMDGPUPreInitVisual(ScrnInfoPtr pScrn)
+{
+	AMDGPUInfoPtr info = AMDGPUPTR(pScrn);
+	if (unlikely(!xf86SetDepthBpp(pScrn, 0, 0, 0, Support32bppFb))) return FALSE;
 	switch (pScrn->depth) {
-	case 8:
-	case 15:
-	case 16:
-	case 24:
-	case 30:
-		break;
-
-	default:
-		xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
-			   "Given depth (%d) is not supported by %s driver\n",
-			   pScrn->depth, AMDGPU_DRIVER_NAME);
-		return FALSE;
+		case 8: case 15: case 16: case 24: case 30: break;
+		default:
+			xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "Given depth (%d) is not supported\n", pScrn->depth);
+			return FALSE;
 	}
-
 	xf86PrintDepthBpp(pScrn);
-
 	info->pix24bpp = xf86GetBppFromDepth(pScrn, pScrn->depth);
 	info->pixel_bytes = pScrn->bitsPerPixel / 8;
-
 	if (info->pix24bpp == 24) {
-		xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
-			   "Amdgpu does NOT support 24bpp\n");
+		xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "24bpp is not supported\n");
 		return FALSE;
 	}
-
-	xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-		   "Pixel depth = %d bits stored in %d byte%s (%d bpp pixmaps)\n",
-		   pScrn->depth,
-		   info->pixel_bytes,
-		   info->pixel_bytes > 1 ? "s" : "", info->pix24bpp);
-
-	if (!xf86SetDefaultVisual(pScrn, -1))
-		return FALSE;
-
+	xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Pixel depth = %d bits stored in %d byte%s (%d bpp pixmaps)\n",
+			   pScrn->depth, info->pixel_bytes, info->pixel_bytes > 1 ? "s" : "", info->pix24bpp);
+	if (unlikely(!xf86SetDefaultVisual(pScrn, -1))) return FALSE;
 	if (pScrn->depth > 8 && pScrn->defaultVisual != TrueColor) {
-		xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
-			   "Default visual (%s) is not supported at depth %d\n",
-			   xf86GetVisualName(pScrn->defaultVisual),
-			   pScrn->depth);
+		xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "Default visual (%s) is not supported at depth %d\n",
+				   xf86GetVisualName(pScrn->defaultVisual), pScrn->depth);
 		return FALSE;
 	}
 	return TRUE;
 }
 
-/* This is called by AMDGPUPreInit to handle all color weight issues */
 static Bool AMDGPUPreInitWeight(ScrnInfoPtr pScrn)
 {
 	AMDGPUInfoPtr info = AMDGPUPTR(pScrn);
-
-	/* Save flag for 6 bit DAC to use for
-	   setting CRTC registers.  Otherwise use
-	   an 8 bit DAC, even if xf86SetWeight sets
-	   pScrn->rgbBits to some value other than
-	   8. */
 	info->dac6bits = FALSE;
-
 	if (pScrn->depth > 8) {
 		rgb defaultWeight = { 0, 0, 0 };
-
-		if (!xf86SetWeight(pScrn, defaultWeight, defaultWeight))
-			return FALSE;
+		if (unlikely(!xf86SetWeight(pScrn, defaultWeight, defaultWeight))) return FALSE;
 	} else {
 		pScrn->rgbBits = 8;
 	}
-
-	xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-		   "Using %d bits per RGB (%d bit DAC)\n",
-		   pScrn->rgbBits, info->dac6bits ? 6 : 8);
-
+	xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Using %d bits per RGB (%d bit DAC)\n",
+			   pScrn->rgbBits, info->dac6bits ? 6 : 8);
 	return TRUE;
 }
 
 static Bool AMDGPUPreInitAccel_KMS(ScrnInfoPtr pScrn)
 {
 	AMDGPUInfoPtr info = AMDGPUPTR(pScrn);
-
 	if (xf86ReturnOptValBool(info->Options, OPTION_ACCEL, TRUE)) {
 		AMDGPUEntPtr pAMDGPUEnt = AMDGPUEntPriv(pScrn);
 		Bool use_glamor = TRUE;
-#ifdef HAVE_GBM_BO_USE_LINEAR
-		const char *accel_method;
-
-		accel_method = xf86GetOptValString(info->Options, OPTION_ACCEL_METHOD);
-		if ((accel_method && !strcmp(accel_method, "none")))
-			use_glamor = FALSE;
-#endif
-
-#ifdef DRI2
-		info->dri2.available = ! !xf86LoadSubModule(pScrn, "dri2");
-#endif
-
-		if (info->dri2.available)
-			info->gbm = gbm_create_device(pAMDGPUEnt->fd);
-
+		#ifdef HAVE_GBM_BO_USE_LINEAR
+		const char *accel_method = xf86GetOptValString(info->Options, OPTION_ACCEL_METHOD);
+		if (accel_method && !strcmp(accel_method, "none")) use_glamor = FALSE;
+		#endif
+		#ifdef DRI2
+		info->dri2.available = !!xf86LoadSubModule(pScrn, "dri2");
+		#endif
+		if (info->dri2.available) info->gbm = gbm_create_device(pAMDGPUEnt->fd);
 		if (info->gbm) {
-			if (use_glamor) {
-				if (amdgpu_glamor_pre_init(pScrn))
-					return TRUE;
-
-				xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
-					   "amdgpu_glamor_pre_init returned "
-					   "FALSE, using ShadowFB\n");
-			}
+			if (use_glamor && amdgpu_glamor_pre_init(pScrn)) return TRUE;
+			xf86DrvMsg(pScrn->scrnIndex, X_WARNING, "Glamor pre-init failed or disabled, using ShadowFB\n");
 		} else {
-			xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
-				   "gbm_create_device returned NULL, using "
-				   "ShadowFB\n");
+			xf86DrvMsg(pScrn->scrnIndex, X_WARNING, "GBM device creation failed, using ShadowFB\n");
 		}
 	} else {
-		xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
-			   "GPU acceleration disabled, using ShadowFB\n");
+		xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "GPU acceleration disabled, using ShadowFB\n");
 	}
-
-	if (!xf86LoadSubModule(pScrn, "shadow"))
-		return FALSE;
-
-	info->dri2.available = FALSE;
-	info->shadow_fb = TRUE;
+	if (unlikely(!xf86LoadSubModule(pScrn, "shadow"))) return FALSE;
+	info->dri2.available = FALSE; info->shadow_fb = TRUE;
 	return TRUE;
 }
 
-static Bool AMDGPUPreInitChipType_KMS(ScrnInfoPtr pScrn,
-				      struct amdgpu_gpu_info *gpu_info)
+static Bool AMDGPUPreInitChipType_KMS(ScrnInfoPtr pScrn, struct amdgpu_gpu_info *gpu_info)
 {
 	AMDGPUInfoPtr info = AMDGPUPTR(pScrn);
 	AMDGPUEntPtr pAMDGPUEnt = AMDGPUEntPriv(pScrn);
-
 	pScrn->chipset = (char*)amdgpu_get_marketing_name(pAMDGPUEnt->pDev);
-	if (!pScrn->chipset)
-		pScrn->chipset = "Unknown AMD Radeon GPU";
-
-	xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
-		   "Chipset: \"%s\" (ChipID = 0x%04x)\n",
-		   pScrn->chipset, gpu_info->asic_id);
-
+	if (!pScrn->chipset) pScrn->chipset = "Unknown AMD Radeon GPU";
+	xf86DrvMsg(pScrn->scrnIndex, X_PROBED, "Chipset: \"%s\" (ChipID = 0x%04x)\n",
+			   pScrn->chipset, gpu_info->asic_id);
 	info->family = gpu_info->family_id;
-
 	return TRUE;
 }
 
-static Bool amdgpu_get_tile_config(AMDGPUInfoPtr info,
-				   struct amdgpu_gpu_info *gpu_info)
+static Bool amdgpu_get_tile_config(AMDGPUInfoPtr info, struct amdgpu_gpu_info *gpu_info)
 {
 	switch ((gpu_info->gb_addr_cfg & 0x70) >> 4) {
-	case 0:
-		info->group_bytes = 256;
-		break;
-	case 1:
-		info->group_bytes = 512;
-		break;
-	default:
-		return FALSE;
+		case 0: info->group_bytes = 256; break;
+		case 1: info->group_bytes = 512; break;
+		default: return FALSE;
 	}
-
 	info->have_tiling_info = TRUE;
 	return TRUE;
 }
@@ -1450,83 +1387,49 @@ static void AMDGPUSetupCapabilities(Scrn
 {
 	AMDGPUInfoPtr info = AMDGPUPTR(pScrn);
 	AMDGPUEntPtr pAMDGPUEnt = AMDGPUEntPriv(pScrn);
-	uint64_t value;
-	int ret;
-
+	uint64_t value; int ret;
 	pScrn->capabilities = 0;
-
-	/* PRIME offloading requires acceleration */
-	if (!info->use_glamor)
-		return;
-
+	if (!info->use_glamor) return;
 	ret = drmGetCap(pAMDGPUEnt->fd, DRM_CAP_PRIME, &value);
 	if (ret == 0) {
-		if (value & DRM_PRIME_CAP_EXPORT)
-			pScrn->capabilities |= RR_Capability_SourceOutput | RR_Capability_SourceOffload;
+		if (value & DRM_PRIME_CAP_EXPORT) pScrn->capabilities |= RR_Capability_SourceOutput | RR_Capability_SourceOffload;
 		if (value & DRM_PRIME_CAP_IMPORT) {
 			pScrn->capabilities |= RR_Capability_SinkOffload;
-			if (info->drmmode.count_crtcs)
-				pScrn->capabilities |= RR_Capability_SinkOutput;
+			if (info->drmmode.count_crtcs) pScrn->capabilities |= RR_Capability_SinkOutput;
 		}
 	}
 }
 
-/* When the root window is created, initialize the screen contents from
- * console if -background none was specified on the command line
- */
 static Bool AMDGPUCreateWindow_oneshot(WindowPtr pWin)
 {
 	ScreenPtr pScreen = pWin->drawable.pScreen;
-	ScrnInfoPtr pScrn;
-	AMDGPUInfoPtr info;
+	ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
+	AMDGPUInfoPtr info = AMDGPUPTR(pScrn);
 	Bool ret;
-
-	if (pWin != pScreen->root)
-		ErrorF("%s called for non-root window %p\n", __func__, pWin);
-
-	pScrn = xf86ScreenToScrn(pScreen);
-	info = AMDGPUPTR(pScrn);
+	if (unlikely(pWin != pScreen->root)) ErrorF("%s called for non-root window %p\n", __func__, pWin);
 	pScreen->CreateWindow = info->CreateWindow;
 	ret = pScreen->CreateWindow(pWin);
-
-	if (ret)
-		drmmode_copy_fb(pScrn, &info->drmmode);
-
+	if (ret) drmmode_copy_fb(pScrn, &info->drmmode);
 	return ret;
 }
 
 static void amdgpu_determine_cursor_size(int fd, AMDGPUInfoPtr info)
 {
 	uint64_t value;
-
-	if (drmGetCap(fd, DRM_CAP_CURSOR_WIDTH, &value) == 0)
-		info->cursor_w = value;
-	else if (info->family < AMDGPU_FAMILY_CI)
-		info->cursor_w = CURSOR_WIDTH;
-	else
-		info->cursor_w = CURSOR_WIDTH_CIK;
-
-	if (drmGetCap(fd, DRM_CAP_CURSOR_HEIGHT, &value) == 0)
-		info->cursor_h = value;
-	else if (info->family < AMDGPU_FAMILY_CI)
-		info->cursor_h = CURSOR_HEIGHT;
-	else
-		info->cursor_h = CURSOR_HEIGHT_CIK;
+	if (drmGetCap(fd, DRM_CAP_CURSOR_WIDTH, &value) == 0) info->cursor_w = value;
+	else info->cursor_w = (info->family < AMDGPU_FAMILY_CI) ? CURSOR_WIDTH : CURSOR_WIDTH_CIK;
+	if (drmGetCap(fd, DRM_CAP_CURSOR_HEIGHT, &value) == 0) info->cursor_h = value;
+	else info->cursor_h = (info->family < AMDGPU_FAMILY_CI) ? CURSOR_HEIGHT : CURSOR_HEIGHT_CIK;
 }
 
-/* When the root window is mapped, set the initial modes */
 void AMDGPUWindowExposures_oneshot(WindowPtr pWin, RegionPtr pRegion)
 {
 	ScreenPtr pScreen = pWin->drawable.pScreen;
 	ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
 	AMDGPUInfoPtr info = AMDGPUPTR(pScrn);
-
-	if (pWin != pScreen->root)
-		ErrorF("%s called for non-root window %p\n", __func__, pWin);
-
+	if (unlikely(pWin != pScreen->root)) ErrorF("%s called for non-root window %p\n", __func__, pWin);
 	pScreen->WindowExposures = info->WindowExposures;
 	pScreen->WindowExposures(pWin, pRegion);
-
 	amdgpu_glamor_finish(pScrn);
 	drmmode_set_desired_modes(pScrn, &info->drmmode, TRUE);
 }
@@ -1539,199 +1442,99 @@ Bool AMDGPUPreInit_KMS(ScrnInfoPtr pScrn
 	MessageType from;
 	Gamma zeros = { 0.0, 0.0, 0.0 };
 	int cpp;
-	uint64_t heap_size = 0;
-	uint64_t max_allocation = 0;
-
-	if (flags & PROBE_DETECT)
-		return TRUE;
-
-	xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, AMDGPU_LOGLEVEL_DEBUG,
-		       "AMDGPUPreInit_KMS\n");
-	if (pScrn->numEntities != 1)
-		return FALSE;
-
-	pAMDGPUEnt = xf86GetEntityPrivate(pScrn->entityList[0],
-					  getAMDGPUEntityIndex())->ptr;
-
-	if (!AMDGPUGetRec(pScrn))
-		return FALSE;
+	uint64_t heap_size = 0, max_allocation = 0;
 
+	if (flags & PROBE_DETECT) return TRUE;
+	xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, AMDGPU_LOGLEVEL_DEBUG, "AMDGPUPreInit_KMS\n");
+	if (pScrn->numEntities != 1) return FALSE;
+	pAMDGPUEnt = xf86GetEntityPrivate(pScrn->entityList[0], getAMDGPUEntityIndex())->ptr;
+	if (!AMDGPUGetRec(pScrn)) return FALSE;
 	info = AMDGPUPTR(pScrn);
 	info->instance_id = pAMDGPUEnt->num_scrns++;
 	pAMDGPUEnt->scrn[info->instance_id] = pScrn;
-
-	info->pEnt =
-	    xf86GetEntityInfo(pScrn->entityList[pScrn->numEntities - 1]);
-	if (info->pEnt->location.type != BUS_PCI
-#ifdef XSERVER_PLATFORM_BUS
-	    && info->pEnt->location.type != BUS_PLATFORM
-#endif
-	    )
-		return FALSE;
-
-	if (xf86IsEntityShared(pScrn->entityList[0]) &&
-	    info->instance_id == 0) {
+	info->pEnt = xf86GetEntityInfo(pScrn->entityList[pScrn->numEntities - 1]);
+	if (info->pEnt->location.type!=BUS_PCI
+		#ifdef XSERVER_PLATFORM_BUS
+		&& info->pEnt->location.type!=BUS_PLATFORM
+		#endif
+	) return FALSE;
+	if (xf86IsEntityShared(pScrn->entityList[0]) && info->instance_id == 0)
 		xf86SetPrimInitDone(pScrn->entityList[0]);
-	}
-
 	pScrn->monitor = pScrn->confScreen->monitor;
-
-	if (!AMDGPUPreInitVisual(pScrn))
-		return FALSE;
-
+	if (!AMDGPUPreInitVisual(pScrn)) return FALSE;
 	xf86CollectOptions(pScrn, NULL);
-	if (!(info->Options = malloc(sizeof(AMDGPUOptions_KMS))))
-		return FALSE;
-
+	if (!(info->Options = malloc(sizeof(AMDGPUOptions_KMS)))) return FALSE;
 	memcpy(info->Options, AMDGPUOptions_KMS, sizeof(AMDGPUOptions_KMS));
 	xf86ProcessOptions(pScrn->scrnIndex, pScrn->options, info->Options);
-
-	if (!AMDGPUPreInitWeight(pScrn))
-		return FALSE;
-
+	if (!AMDGPUPreInitWeight(pScrn)) return FALSE;
 	memset(&gpu_info, 0, sizeof(gpu_info));
 	amdgpu_query_gpu_info(pAMDGPUEnt->pDev, &gpu_info);
-
-	if (!AMDGPUPreInitChipType_KMS(pScrn, &gpu_info))
-		return FALSE;
-
-	info->dri2.available = FALSE;
-	info->dri2.enabled = FALSE;
+	if (!AMDGPUPreInitChipType_KMS(pScrn, &gpu_info)) return FALSE;
+	info->dri2.available = FALSE; info->dri2.enabled = FALSE;
 	info->dri2.pKernelDRMVersion = drmGetVersion(pAMDGPUEnt->fd);
-	if (info->dri2.pKernelDRMVersion == NULL) {
-		xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
-			   "AMDGPUDRIGetVersion failed to get the DRM version\n");
+	if (unlikely(!info->dri2.pKernelDRMVersion)) {
+		xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "Failed to get DRM version\n");
 		return FALSE;
 	}
-
-	/* Get ScreenInit function */
-	if (!xf86LoadSubModule(pScrn, "fb"))
-		return FALSE;
-
-	if (!AMDGPUPreInitAccel_KMS(pScrn))
-		return FALSE;
-
+	if (unlikely(!xf86LoadSubModule(pScrn, "fb"))) return FALSE;
+	if (!AMDGPUPreInitAccel_KMS(pScrn)) return FALSE;
 	amdgpu_drm_queue_init(pScrn);
-
-	/* don't enable tiling if accel is not enabled */
 	if (info->use_glamor) {
-		/* set default group bytes, overridden by kernel info below */
-		info->group_bytes = 256;
-		info->have_tiling_info = FALSE;
+		info->group_bytes = 256; info->have_tiling_info = FALSE;
 		amdgpu_get_tile_config(info, &gpu_info);
 	}
-
 	if (info->use_glamor) {
-		from = X_DEFAULT;
-
-		info->tear_free = 2;
-		if (xf86GetOptValBool(info->Options, OPTION_TEAR_FREE,
-				      &info->tear_free))
-			from = X_CONFIG;
+		from = X_DEFAULT; info->tear_free = 2;
+		if (xf86GetOptValBool(info->Options, OPTION_TEAR_FREE, &info->tear_free)) from = X_CONFIG;
 		xf86DrvMsg(pScrn->scrnIndex, from, "TearFree property default: %s\n",
-			   info->tear_free == 2 ? "auto" : (info->tear_free ? "on" : "off"));
-
-		info->shadow_primary =
-			xf86ReturnOptValBool(info->Options, OPTION_SHADOW_PRIMARY, FALSE);
-
-		if (info->shadow_primary)
-			xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "ShadowPrimary enabled\n");
-
+				   info->tear_free == 2 ? "auto" : (info->tear_free ? "on" : "off"));
+		info->shadow_primary = xf86ReturnOptValBool(info->Options, OPTION_SHADOW_PRIMARY, FALSE);
+		if (info->shadow_primary) xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "ShadowPrimary enabled\n");
 		if (!pScrn->is_gpu) {
-			from = xf86GetOptValBool(info->Options, OPTION_VARIABLE_REFRESH,
-						 &info->vrr_support) ? X_CONFIG : X_DEFAULT;
-
+			from = xf86GetOptValBool(info->Options, OPTION_VARIABLE_REFRESH, &info->vrr_support) ? X_CONFIG : X_DEFAULT;
 			if (info->vrr_support && !info->tear_free)
-				xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
-					   "Enabling VariableRefresh while TearFree is disabled can cause instability!\n");
-
-			xf86DrvMsg(pScrn->scrnIndex, from, "VariableRefresh: %sabled\n",
-				   info->vrr_support ? "en" : "dis");
-
+				xf86DrvMsg(pScrn->scrnIndex, X_WARNING, "Enabling VariableRefresh while TearFree is disabled can cause instability!\n");
+			xf86DrvMsg(pScrn->scrnIndex, from, "VariableRefresh: %sabled\n", info->vrr_support ? "en" : "dis");
 			info->async_flip_secondaries = FALSE;
-			from = xf86GetOptValBool(info->Options, OPTION_ASYNC_FLIP_SECONDARIES,
-						 &info->async_flip_secondaries) ? X_CONFIG : X_DEFAULT;
-
-			xf86DrvMsg(pScrn->scrnIndex, from, "AsyncFlipSecondaries: %sabled\n",
-				   info->async_flip_secondaries ? "en" : "dis");
+			from = xf86GetOptValBool(info->Options, OPTION_ASYNC_FLIP_SECONDARIES, &info->async_flip_secondaries) ? X_CONFIG : X_DEFAULT;
+			xf86DrvMsg(pScrn->scrnIndex, from, "AsyncFlipSecondaries: %sabled\n", info->async_flip_secondaries ? "en" : "dis");
 		}
 	}
-
 	if (!pScrn->is_gpu) {
-		info->allowPageFlip = xf86ReturnOptValBool(info->Options,
-							   OPTION_PAGE_FLIP,
-							   TRUE);
+		info->allowPageFlip = xf86ReturnOptValBool(info->Options, OPTION_PAGE_FLIP, TRUE);
 		if (info->shadow_primary) {
-			xf86DrvMsg(pScrn->scrnIndex,
-				   info->allowPageFlip ? X_WARNING : X_DEFAULT,
-				   "KMS Pageflipping: disabled%s\n",
-				   info->allowPageFlip ?
-				   " because of ShadowPrimary" : "");
+			xf86DrvMsg(pScrn->scrnIndex, info->allowPageFlip?X_WARNING:X_DEFAULT, "KMS Pageflipping: disabled%s\n",
+					   info->allowPageFlip?" because of ShadowPrimary":"");
 			info->allowPageFlip = FALSE;
 		} else {
-			xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-				   "KMS Pageflipping: %sabled\n",
-				   info->allowPageFlip ? "en" : "dis");
+			xf86DrvMsg(pScrn->scrnIndex, X_INFO, "KMS Pageflipping: %sabled\n", info->allowPageFlip?"en":"dis");
 		}
 	}
-
-	if (xf86ReturnOptValBool(info->Options, OPTION_DELETE_DP12, FALSE)) {
+	if (xf86ReturnOptValBool(info->Options, OPTION_DELETE_DP12, FALSE))
 		info->drmmode.delete_dp_12_displays = TRUE;
-	}
-
-	if (drmmode_pre_init(pScrn, &info->drmmode, pScrn->bitsPerPixel / 8) ==
-	    FALSE) {
-		xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
-			   "Kernel modesetting setup failed\n");
+	if (unlikely(!drmmode_pre_init(pScrn, &info->drmmode, pScrn->bitsPerPixel / 8))) {
+		xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "Kernel modesetting setup failed\n");
 		return FALSE;
 	}
-
 	AMDGPUSetupCapabilities(pScrn);
-
-	if (info->drmmode.count_crtcs == 1)
-		pAMDGPUEnt->HasCRTC2 = FALSE;
-	else
-		pAMDGPUEnt->HasCRTC2 = TRUE;
-
+	pAMDGPUEnt->HasCRTC2 = (info->drmmode.count_crtcs > 1);
 	amdgpu_determine_cursor_size(pAMDGPUEnt->fd, info);
-
-	amdgpu_query_heap_size(pAMDGPUEnt->pDev, AMDGPU_GEM_DOMAIN_GTT,
-				&heap_size, &max_allocation);
+	amdgpu_query_heap_size(pAMDGPUEnt->pDev, AMDGPU_GEM_DOMAIN_GTT, &heap_size, &max_allocation);
 	info->gart_size = heap_size;
-	amdgpu_query_heap_size(pAMDGPUEnt->pDev, AMDGPU_GEM_DOMAIN_VRAM,
-				&heap_size, &max_allocation);
+	amdgpu_query_heap_size(pAMDGPUEnt->pDev, AMDGPU_GEM_DOMAIN_VRAM, &heap_size, &max_allocation);
 	info->vram_size = max_allocation;
-
-	xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-		   "mem size init: gart size :%llx vram size: s:%llx visible:%llx\n",
-		   (unsigned long long)info->gart_size,
-		   (unsigned long long)heap_size,
-		   (unsigned long long)max_allocation);
-
+	xf86DrvMsg(pScrn->scrnIndex, X_INFO, "mem size init: gart size :%llx vram size: s:%llx visible:%llx\n",
+			   (unsigned long long)info->gart_size, (unsigned long long)heap_size, (unsigned long long)max_allocation);
 	cpp = pScrn->bitsPerPixel / 8;
-	pScrn->displayWidth =
-	    AMDGPU_ALIGN(pScrn->virtualX, drmmode_get_pitch_align(pScrn, cpp));
-
-	/* Set display resolution */
+	pScrn->displayWidth = AMDGPU_ALIGN(pScrn->virtualX, drmmode_get_pitch_align(pScrn, cpp));
 	xf86SetDpi(pScrn, 0, 0);
-
-	if (!xf86SetGamma(pScrn, zeros))
-		return FALSE;
-
-	if (!xf86ReturnOptValBool(info->Options, OPTION_SW_CURSOR, FALSE)) {
-		if (!xf86LoadSubModule(pScrn, "ramdac"))
-			return FALSE;
-	}
-
-	if (!pScrn->modes
-#ifdef XSERVER_PLATFORM_BUS
-	    && !pScrn->is_gpu
-#endif
-	    ) {
+	if (unlikely(!xf86SetGamma(pScrn, zeros))) return FALSE;
+	if (!xf86ReturnOptValBool(info->Options, OPTION_SW_CURSOR, FALSE) &&
+		unlikely(!xf86LoadSubModule(pScrn, "ramdac"))) return FALSE;
+	if (unlikely(!pScrn->modes && !pScrn->is_gpu)) {
 		xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "No modes.\n");
 		return FALSE;
 	}
-
 	return TRUE;
 }
 
@@ -1739,61 +1542,41 @@ static Bool AMDGPUCursorInit_KMS(ScreenP
 {
 	ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
 	AMDGPUInfoPtr info = AMDGPUPTR(pScrn);
-
-	xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, AMDGPU_LOGLEVEL_DEBUG,
-		       "Initializing Cursor\n");
-
-	/* Set Silken Mouse */
+	xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, AMDGPU_LOGLEVEL_DEBUG, "Initializing Cursor\n");
 	xf86SetSilkenMouse(pScreen);
-
-	/* Cursor setup */
 	miDCInitialize(pScreen, xf86GetPointerScreenFuncs());
-
 	if (info->allowPageFlip) {
-		miPointerScreenPtr PointPriv =
-			dixLookupPrivate(&pScreen->devPrivates, miPointerScreenKey);
-
-		if (!dixRegisterScreenPrivateKey(&amdgpu_device_private_key, pScreen,
-						 PRIVATE_DEVICE,
-						 sizeof(struct amdgpu_device_priv))) {
+		miPointerScreenPtr PointPriv = dixLookupPrivate(&pScreen->devPrivates, miPointerScreenKey);
+		if (unlikely(!dixRegisterScreenPrivateKey(&amdgpu_device_private_key, pScreen,
+			PRIVATE_DEVICE, sizeof(struct amdgpu_device_priv)))) {
 			xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "dixRegisterScreenPrivateKey failed\n");
-			return FALSE;
-		}
-
-		info->SpriteFuncs = PointPriv->spriteFuncs;
-		PointPriv->spriteFuncs = &drmmode_sprite_funcs;
-	}
-
-	if (xf86ReturnOptValBool(info->Options, OPTION_SW_CURSOR, FALSE))
-		return TRUE;
-
-	if (!xf86_cursors_init(pScreen, info->cursor_w, info->cursor_h,
-			       HARDWARE_CURSOR_TRUECOLOR_AT_8BPP |
-			       HARDWARE_CURSOR_AND_SOURCE_WITH_MASK |
-			       HARDWARE_CURSOR_SOURCE_MASK_INTERLEAVE_1 |
-			       HARDWARE_CURSOR_UPDATE_UNHIDDEN |
-			       HARDWARE_CURSOR_ARGB)) {
-		xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "xf86_cursors_init failed\n");
 		return FALSE;
+			}
+			info->SpriteFuncs = PointPriv->spriteFuncs;
+			PointPriv->spriteFuncs = &drmmode_sprite_funcs;
 	}
-
-	return TRUE;
+	if (xf86ReturnOptValBool(info->Options, OPTION_SW_CURSOR, FALSE)) return TRUE;
+	if (unlikely(!xf86_cursors_init(pScreen, info->cursor_w, info->cursor_h,
+		HARDWARE_CURSOR_TRUECOLOR_AT_8BPP | HARDWARE_CURSOR_AND_SOURCE_WITH_MASK |
+		HARDWARE_CURSOR_SOURCE_MASK_INTERLEAVE_1 | HARDWARE_CURSOR_UPDATE_UNHIDDEN |
+		HARDWARE_CURSOR_ARGB))) {
+		xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "xf86_cursors_init failed\n");
+	return FALSE;
+		}
+		return TRUE;
 }
 
 void AMDGPUBlank(ScrnInfoPtr pScrn)
 {
 	xf86CrtcConfigPtr xf86_config = XF86_CRTC_CONFIG_PTR(pScrn);
-	xf86OutputPtr output;
-	xf86CrtcPtr crtc;
-	int o, c;
-
+	xf86OutputPtr output; xf86CrtcPtr crtc; int o, c;
 	for (c = 0; c < xf86_config->num_crtc; c++) {
 		crtc = xf86_config->crtc[c];
+		if (unlikely(!crtc)) continue;
 		for (o = 0; o < xf86_config->num_output; o++) {
 			output = xf86_config->output[o];
-			if (output->crtc != crtc)
-				continue;
-
+			if (unlikely(!output)) continue;
+			if (output->crtc != crtc) continue;
 			output->funcs->dpms(output, DPMSModeOff);
 		}
 		crtc->funcs->dpms(crtc, DPMSModeOff);
@@ -1803,18 +1586,15 @@ void AMDGPUBlank(ScrnInfoPtr pScrn)
 void AMDGPUUnblank(ScrnInfoPtr pScrn)
 {
 	xf86CrtcConfigPtr xf86_config = XF86_CRTC_CONFIG_PTR(pScrn);
-	xf86OutputPtr output;
-	xf86CrtcPtr crtc;
-	int o, c;
+	xf86OutputPtr output; xf86CrtcPtr crtc; int o, c;
 	for (c = 0; c < xf86_config->num_crtc; c++) {
 		crtc = xf86_config->crtc[c];
-		if (!crtc->enabled)
-			continue;
+		if (unlikely(!crtc || !crtc->enabled)) continue;
 		crtc->funcs->dpms(crtc, DPMSModeOn);
 		for (o = 0; o < xf86_config->num_output; o++) {
 			output = xf86_config->output[o];
-			if (output->crtc != crtc)
-				continue;
+			if (unlikely(!output)) continue;
+			if (output->crtc != crtc) continue;
 			output->funcs->dpms(output, DPMSModeOn);
 		}
 	}
@@ -1822,126 +1602,76 @@ void AMDGPUUnblank(ScrnInfoPtr pScrn)
 
 static Bool amdgpu_set_drm_master(ScrnInfoPtr pScrn)
 {
-	AMDGPUEntPtr pAMDGPUEnt = AMDGPUEntPriv(pScrn);
-	int err;
-
-#ifdef XF86_PDEV_SERVER_FD
-	if (pAMDGPUEnt->platform_dev &&
-	    (pAMDGPUEnt->platform_dev->flags & XF86_PDEV_SERVER_FD))
-		return TRUE;
-#endif
-
+	AMDGPUEntPtr pAMDGPUEnt = AMDGPUEntPriv(pScrn); int err;
+	#ifdef XF86_PDEV_SERVER_FD
+	if (pAMDGPUEnt->platform_dev && (pAMDGPUEnt->platform_dev->flags & XF86_PDEV_SERVER_FD)) return TRUE;
+	#endif
 	err = drmSetMaster(pAMDGPUEnt->fd);
-	if (err)
-		ErrorF("Unable to retrieve master\n");
-
+	if (err) ErrorF("Unable to retrieve master\n");
 	return err == 0;
 }
 
 static void amdgpu_drop_drm_master(ScrnInfoPtr pScrn)
 {
 	AMDGPUEntPtr pAMDGPUEnt = AMDGPUEntPriv(pScrn);
-
-#ifdef XF86_PDEV_SERVER_FD
-	if (pAMDGPUEnt->platform_dev &&
-	    (pAMDGPUEnt->platform_dev->flags & XF86_PDEV_SERVER_FD))
-		return;
-#endif
-
+	#ifdef XF86_PDEV_SERVER_FD
+	if (pAMDGPUEnt->platform_dev && (pAMDGPUEnt->platform_dev->flags & XF86_PDEV_SERVER_FD)) return;
+	#endif
 	drmDropMaster(pAMDGPUEnt->fd);
 }
 
-
-static
-CARD32 cleanup_black_fb(OsTimerPtr timer, CARD32 now, pointer data)
+static CARD32 cleanup_black_fb(OsTimerPtr timer, CARD32 now, pointer data)
 {
 	ScreenPtr screen = data;
 	ScrnInfoPtr scrn = xf86ScreenToScrn(screen);
 	AMDGPUEntPtr pAMDGPUEnt = AMDGPUEntPriv(scrn);
-	xf86CrtcConfigPtr xf86_config = XF86_CRTC_CONFIG_PTR(scrn);
-	int c;
-
-	if (xf86ScreenToScrn(amdgpu_primary_screen(screen))->vtSema)
-		return 0;
-
-	/* Unreference the all-black FB created by AMDGPULeaveVT_KMS. After
-	 * this, there should be no FB left created by this driver.
-	 */
+	xf86CrtcConfigPtr xf86_config = XF86_CRTC_CONFIG_PTR(scrn); int c;
+	if (xf86ScreenToScrn(amdgpu_primary_screen(screen))->vtSema) return 0;
 	for (c = 0; c < xf86_config->num_crtc; c++) {
-		drmmode_crtc_private_ptr drmmode_crtc =
-			xf86_config->crtc[c]->driver_private;
-
-		drmmode_fb_reference(pAMDGPUEnt->fd, &drmmode_crtc->fb, NULL);
+		if (unlikely(!xf86_config->crtc[c])) continue;
+		drmmode_crtc_private_ptr drmmode_crtc = xf86_config->crtc[c]->driver_private;
+		if (likely(drmmode_crtc))
+			drmmode_fb_reference(pAMDGPUEnt->fd, &drmmode_crtc->fb, NULL);
 	}
-
-	TimerFree(timer);
-	return 0;
+	TimerFree(timer); return 0;
 }
 
 static Bool AMDGPUSaveScreen_KMS(ScreenPtr pScreen, int mode)
 {
-	ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
-	Bool unblank;
-
-	xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, AMDGPU_LOGLEVEL_DEBUG,
-		       "AMDGPUSaveScreen(%d)\n", mode);
-
+	ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen); Bool unblank;
+	xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, AMDGPU_LOGLEVEL_DEBUG, "AMDGPUSaveScreen(%d)\n", mode);
 	unblank = xf86IsUnblank(mode);
-	if (unblank)
-		SetTimeSinceLastInputEvent();
-
-	if ((pScrn != NULL) && pScrn->vtSema) {
-		if (unblank)
-			AMDGPUUnblank(pScrn);
-		else
-			AMDGPUBlank(pScrn);
+	if (unblank) SetTimeSinceLastInputEvent();
+	if (pScrn && pScrn->vtSema) {
+		if (unblank) AMDGPUUnblank(pScrn); else AMDGPUBlank(pScrn);
 	}
 	return TRUE;
 }
 
-/* Called at the end of each server generation.  Restore the original
- * text mode, unmap video memory, and unwrap and call the saved
- * CloseScreen function.
- */
 static Bool AMDGPUCloseScreen_KMS(ScreenPtr pScreen)
 {
 	ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
 	AMDGPUInfoPtr info = AMDGPUPTR(pScrn);
 	AMDGPUEntPtr pAMDGPUEnt = AMDGPUEntPriv(pScrn);
-
-	xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, AMDGPU_LOGLEVEL_DEBUG,
-		       "AMDGPUCloseScreen\n");
-
-	/* Clear mask of assigned crtc's in this generation */
+	xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, AMDGPU_LOGLEVEL_DEBUG, "AMDGPUCloseScreen\n");
 	pAMDGPUEnt->assigned_crtcs = 0;
-
 	drmmode_uevent_fini(pScrn, &info->drmmode);
 	amdgpu_drm_queue_close(pScrn);
-
 	if (info->callback_event_type != -1) {
 		DeleteCallback(&EventCallback, amdgpu_event_callback, pScrn);
 		DeleteCallback(&FlushCallback, amdgpu_flush_callback, pScrn);
 	}
-
 	amdgpu_sync_close(pScreen);
 	amdgpu_drop_drm_master(pScrn);
-
 	drmmode_fini(pScrn, &info->drmmode);
-	if (info->dri2.enabled) {
-		amdgpu_dri2_close_screen(pScreen);
-	}
+	if (info->dri2.enabled) amdgpu_dri2_close_screen(pScreen);
 	amdgpu_glamor_fini(pScreen);
 	pScrn->vtSema = FALSE;
 	xf86ClearPrimInitDone(info->pEnt->index);
-
 	if (info->allowPageFlip) {
-		miPointerScreenPtr PointPriv =
-			dixLookupPrivate(&pScreen->devPrivates, miPointerScreenKey);
-
-		if (PointPriv->spriteFuncs == &drmmode_sprite_funcs)
-			PointPriv->spriteFuncs = info->SpriteFuncs;
+		miPointerScreenPtr PointPriv = dixLookupPrivate(&pScreen->devPrivates, miPointerScreenKey);
+		if (PointPriv->spriteFuncs == &drmmode_sprite_funcs) PointPriv->spriteFuncs = info->SpriteFuncs;
 	}
-
 	pScreen->BlockHandler = info->BlockHandler;
 	pScreen->CloseScreen = info->CloseScreen;
 	return pScreen->CloseScreen(pScreen);
@@ -1949,9 +1679,7 @@ static Bool AMDGPUCloseScreen_KMS(Screen
 
 void AMDGPUFreeScreen_KMS(ScrnInfoPtr pScrn)
 {
-	xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, AMDGPU_LOGLEVEL_DEBUG,
-		       "AMDGPUFreeScreen\n");
-
+	xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, AMDGPU_LOGLEVEL_DEBUG, "AMDGPUFreeScreen\n");
 	AMDGPUFreeRec(pScrn);
 }
 
@@ -1959,434 +1687,228 @@ Bool AMDGPUScreenInit_KMS(ScreenPtr pScr
 {
 	ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
 	AMDGPUInfoPtr info = AMDGPUPTR(pScrn);
-	int subPixelOrder = SubPixelUnknown;
-	MessageType from;
-	Bool value;
-	int driLevel;
-	const char *s;
-	void *front_ptr;
+	int subPixelOrder = SubPixelUnknown; MessageType from; Bool value; int driLevel;
+	const char *s; void *front_ptr = NULL; /* Initialize */
 
 	pScrn->fbOffset = 0;
-
 	miClearVisualTypes();
-	if (!miSetVisualTypes(pScrn->depth,
-			      miGetDefaultVisualMask(pScrn->depth),
-			      pScrn->rgbBits, pScrn->defaultVisual))
-		return FALSE;
+	if (unlikely(!miSetVisualTypes(pScrn->depth, miGetDefaultVisualMask(pScrn->depth),
+		pScrn->rgbBits, pScrn->defaultVisual))) return FALSE;
 	miSetPixmapDepths();
-
-	if (!amdgpu_set_drm_master(pScrn))
-		return FALSE;
-
+	if (unlikely(!amdgpu_set_drm_master(pScrn))) return FALSE;
 	info->directRenderingEnabled = FALSE;
-	if (info->shadow_fb == FALSE)
-		info->directRenderingEnabled = amdgpu_dri2_screen_init(pScreen);
-
-	if (!amdgpu_setup_kernel_mem(pScreen)) {
-		xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
-			   "amdgpu_setup_kernel_mem failed\n");
+	if (!info->shadow_fb) info->directRenderingEnabled = amdgpu_dri2_screen_init(pScreen);
+	if (unlikely(!amdgpu_setup_kernel_mem(pScreen))) {
+		xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "amdgpu_setup_kernel_mem failed\n");
 		return FALSE;
 	}
-	front_ptr = info->front_buffer->cpu_ptr;
+	if (likely(info->front_buffer)) front_ptr = info->front_buffer->cpu_ptr;
 
 	if (info->shadow_fb) {
-		info->fb_shadow = calloc(1,
-					 pScrn->displayWidth * pScrn->virtualY *
-					 ((pScrn->bitsPerPixel + 7) >> 3));
-		if (!info->fb_shadow) {
-			xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
-				   "Failed to allocate shadow framebuffer\n");
-			return FALSE;
-		} else {
-			if (!fbScreenInit(pScreen, info->fb_shadow,
-					  pScrn->virtualX, pScrn->virtualY,
-					  pScrn->xDpi, pScrn->yDpi,
-					  pScrn->displayWidth,
-					  pScrn->bitsPerPixel))
-				return FALSE;
+		if (unlikely(!info->fb_shadow)) { /* Should have been allocated by setup_kernel_mem if needed by then */
+			info->fb_shadow = calloc(1, pScrn->displayWidth*pScrn->virtualY*((pScrn->bitsPerPixel+7)>>3));
 		}
-	}
-
-	if (info->shadow_fb == FALSE) {
-		/* Init fb layer */
-		if (!fbScreenInit(pScreen, front_ptr,
-				  pScrn->virtualX, pScrn->virtualY,
-				  pScrn->xDpi, pScrn->yDpi, pScrn->displayWidth,
-				  pScrn->bitsPerPixel))
+		if (unlikely(!info->fb_shadow)) {
+			xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "Failed to allocate shadow framebuffer\n");
 			return FALSE;
+		}
+		if (unlikely(!fbScreenInit(pScreen,info->fb_shadow,pScrn->virtualX,pScrn->virtualY,
+			pScrn->xDpi,pScrn->yDpi,pScrn->displayWidth,pScrn->bitsPerPixel))) return FALSE;
+	} else {
+		if (unlikely(!fbScreenInit(pScreen,front_ptr,pScrn->virtualX,pScrn->virtualY,
+			pScrn->xDpi,pScrn->yDpi,pScrn->displayWidth,pScrn->bitsPerPixel))) return FALSE;
 	}
-
 	xf86SetBlackWhitePixels(pScreen);
-
 	if (pScrn->bitsPerPixel > 8) {
-		VisualPtr visual;
-
-		visual = pScreen->visuals + pScreen->numVisuals;
+		VisualPtr visual = pScreen->visuals + pScreen->numVisuals;
 		while (--visual >= pScreen->visuals) {
-			if ((visual->class | DynamicClass) == DirectColor) {
-				visual->offsetRed = pScrn->offset.red;
-				visual->offsetGreen = pScrn->offset.green;
-				visual->offsetBlue = pScrn->offset.blue;
-				visual->redMask = pScrn->mask.red;
-				visual->greenMask = pScrn->mask.green;
-				visual->blueMask = pScrn->mask.blue;
+			if ((visual->class|DynamicClass)==DirectColor) {
+				visual->offsetRed = pScrn->offset.red; visual->offsetGreen = pScrn->offset.green;
+				visual->offsetBlue = pScrn->offset.blue; visual->redMask = pScrn->mask.red;
+				visual->greenMask = pScrn->mask.green; visual->blueMask = pScrn->mask.blue;
 			}
 		}
 	}
-
-	/* Must be after RGB order fixed */
-	fbPictureInit(pScreen, 0, 0);
-
-#ifdef RENDER
+	fbPictureInit(pScreen,0,0);
+	#ifdef RENDER
 	if ((s = xf86GetOptValString(info->Options, OPTION_SUBPIXEL_ORDER))) {
-		if (strcmp(s, "RGB") == 0)
-			subPixelOrder = SubPixelHorizontalRGB;
-		else if (strcmp(s, "BGR") == 0)
-			subPixelOrder = SubPixelHorizontalBGR;
-		else if (strcmp(s, "NONE") == 0)
-			subPixelOrder = SubPixelNone;
-		PictureSetSubpixelOrder(pScreen, subPixelOrder);
+		if(!strcmp(s,"RGB"))subPixelOrder=SubPixelHorizontalRGB; else if(!strcmp(s,"BGR"))subPixelOrder=SubPixelHorizontalBGR;
+		else if(!strcmp(s,"NONE"))subPixelOrder=SubPixelNone;
+		PictureSetSubpixelOrder(pScreen,subPixelOrder);
 	}
-#endif
-
-	if (xorgGetVersion() >= XORG_VERSION_NUMERIC(1,18,3,0,0))
-		value = info->use_glamor;
-	else
-		value = FALSE;
+	#endif
+	value = (XORG_VERSION_CURRENT >= XORG_VERSION_NUMERIC(1,18,3,0,0)) ? info->use_glamor : FALSE;
 	from = X_DEFAULT;
-
 	if (info->use_glamor) {
-		if (xf86GetOptValBool(info->Options, OPTION_DRI3, &value))
-			from = X_CONFIG;
-
-		if (xf86GetOptValInteger(info->Options, OPTION_DRI, &driLevel) &&
-				(driLevel == 2 || driLevel == 3)) {
-			from = X_CONFIG;
-			value = driLevel == 3;
+		if (xf86GetOptValBool(info->Options, OPTION_DRI3, &value)) from = X_CONFIG;
+		if (xf86GetOptValInteger(info->Options, OPTION_DRI, &driLevel) && (driLevel==2||driLevel==3)) {
+			from = X_CONFIG; value = (driLevel==3);
 		}
 	}
-
 	if (value) {
-		value = amdgpu_sync_init(pScreen) &&
-			amdgpu_present_screen_init(pScreen) &&
-			amdgpu_dri3_screen_init(pScreen);
-
-		if (!value)
-			from = X_WARNING;
+		value = amdgpu_sync_init(pScreen) && amdgpu_present_screen_init(pScreen) && amdgpu_dri3_screen_init(pScreen);
+		if (!value) from = X_WARNING;
 	}
-
-	xf86DrvMsg(pScrn->scrnIndex, from, "DRI3 %sabled\n", value ? "en" : "dis");
-
-	pScrn->vtSema = TRUE;
-	xf86SetBackingStore(pScreen);
-
-	if (info->directRenderingEnabled) {
-		xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-			   "Direct rendering enabled\n");
-	} else {
-		xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
-			   "Direct rendering disabled\n");
-	}
-
+	xf86DrvMsg(pScrn->scrnIndex, from, "DRI3 %sabled\n", value?"en":"dis");
+	pScrn->vtSema = TRUE; xf86SetBackingStore(pScreen);
+	if (info->directRenderingEnabled) xf86DrvMsg(pScrn->scrnIndex,X_INFO,"Direct rendering enabled\n");
+	else xf86DrvMsg(pScrn->scrnIndex,X_WARNING,"Direct rendering disabled\n");
 	if (info->use_glamor && info->directRenderingEnabled) {
-		xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, AMDGPU_LOGLEVEL_DEBUG,
-			       "Initializing Acceleration\n");
-		if (amdgpu_glamor_init(pScreen)) {
-			xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-				   "Acceleration enabled\n");
-		} else {
-			xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
-				   "Acceleration initialization failed\n");
-			xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-				   "2D and 3D acceleration disabled\n");
-			info->use_glamor = FALSE;
-		}
+		xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, AMDGPU_LOGLEVEL_DEBUG, "Initializing Acceleration\n");
+		if (amdgpu_glamor_init(pScreen)) xf86DrvMsg(pScrn->scrnIndex,X_INFO,"Acceleration enabled\n");
+		else { xf86DrvMsg(pScrn->scrnIndex,X_ERROR,"Acceleration initialization failed\n");
+			xf86DrvMsg(pScrn->scrnIndex,X_INFO,"2D and 3D acceleration disabled\n"); info->use_glamor=FALSE; }
 	} else if (info->directRenderingEnabled) {
-		if (!amdgpu_pixmap_init(pScreen))
-			xf86DrvMsg(pScrn->scrnIndex, X_INFO, "3D acceleration disabled\n");
-		xf86DrvMsg(pScrn->scrnIndex, X_INFO, "2D acceleration disabled\n");
-	} else {
-		xf86DrvMsg(pScrn->scrnIndex, X_INFO, "2D and 3D acceleration disabled\n");
-	}
-
-	/* Init DPMS */
-	xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, AMDGPU_LOGLEVEL_DEBUG,
-		       "Initializing DPMS\n");
-	xf86DPMSInit(pScreen, xf86DPMSSet, 0);
-
-	if (!AMDGPUCursorInit_KMS(pScreen))
-		return FALSE;
-
-	/* DGA setup */
-#ifdef XFreeXDGA
-	/* DGA is dangerous on kms as the base and framebuffer location may change:
-	 * http://lists.freedesktop.org/archives/xorg-devel/2009-September/002113.html
-	 */
-	/* xf86DiDGAInit(pScreen, info->LinearAddr + pScrn->fbOffset); */
-#endif
-	if (info->shadow_fb == FALSE && !pScreen->isGPU) {
-		/* Init Xv */
-		xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, AMDGPU_LOGLEVEL_DEBUG,
-			       "Initializing Xv\n");
+		if (!amdgpu_pixmap_init(pScreen)) xf86DrvMsg(pScrn->scrnIndex,X_INFO,"3D acceleration disabled\n");
+		xf86DrvMsg(pScrn->scrnIndex,X_INFO,"2D acceleration disabled\n");
+	} else { xf86DrvMsg(pScrn->scrnIndex,X_INFO,"2D and 3D acceleration disabled\n"); }
+	xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, AMDGPU_LOGLEVEL_DEBUG, "Initializing DPMS\n");
+	xf86DPMSInit(pScreen,xf86DPMSSet,0);
+	if (unlikely(!AMDGPUCursorInit_KMS(pScreen))) return FALSE;
+	if (!info->shadow_fb && !pScreen->isGPU) {
+		xf86DrvMsgVerb(pScrn->scrnIndex,X_INFO,AMDGPU_LOGLEVEL_DEBUG,"Initializing Xv\n");
 		AMDGPUInitVideo(pScreen);
 	}
-
-	if (info->shadow_fb == TRUE) {
-		if (!shadowSetup(pScreen)) {
-			xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
-				   "Shadowfb initialization failed\n");
-			return FALSE;
-		}
+	if (info->shadow_fb && unlikely(!shadowSetup(pScreen))) {
+		xf86DrvMsg(pScrn->scrnIndex,X_ERROR,"Shadowfb initialization failed\n"); return FALSE;
 	}
 	pScrn->pScreen = pScreen;
-
 	if (!pScreen->isGPU) {
-		if (serverGeneration == 1 && bgNoneRoot && info->use_glamor) {
-			info->CreateWindow = pScreen->CreateWindow;
-			pScreen->CreateWindow = AMDGPUCreateWindow_oneshot;
-		}
-		info->WindowExposures = pScreen->WindowExposures;
-		pScreen->WindowExposures = AMDGPUWindowExposures_oneshot;
+		if (serverGeneration==1 && bgNoneRoot && info->use_glamor) {
+			info->CreateWindow = pScreen->CreateWindow; pScreen->CreateWindow = AMDGPUCreateWindow_oneshot;
+		}
+		info->WindowExposures = pScreen->WindowExposures; pScreen->WindowExposures = AMDGPUWindowExposures_oneshot;
 	}
-
-	/* Provide SaveScreen & wrap BlockHandler and CloseScreen */
-	/* Wrap CloseScreen */
-	info->CloseScreen = pScreen->CloseScreen;
-	pScreen->CloseScreen = AMDGPUCloseScreen_KMS;
+	info->CloseScreen = pScreen->CloseScreen; pScreen->CloseScreen = AMDGPUCloseScreen_KMS;
 	pScreen->SaveScreen = AMDGPUSaveScreen_KMS;
-	info->BlockHandler = pScreen->BlockHandler;
-	pScreen->BlockHandler = AMDGPUBlockHandler_KMS;
-
+	info->BlockHandler = pScreen->BlockHandler; pScreen->BlockHandler = AMDGPUBlockHandler_KMS;
 	info->CreateScreenResources = pScreen->CreateScreenResources;
 	pScreen->CreateScreenResources = AMDGPUCreateScreenResources_KMS;
-
 	pScreen->StartPixmapTracking = PixmapStartDirtyTracking;
 	pScreen->StopPixmapTracking = PixmapStopDirtyTracking;
-#if HAS_SYNC_SHARED_PIXMAP
+	#if HAS_SYNC_SHARED_PIXMAP
 	pScreen->SyncSharedPixmap = amdgpu_sync_shared_pixmap;
-#endif
-
-	if (!xf86CrtcScreenInit(pScreen))
-		return FALSE;
-
-	/* Wrap pointer motion to flip touch screen around */
-//    info->PointerMoved = pScrn->PointerMoved;
-//    pScrn->PointerMoved = AMDGPUPointerMoved;
-
-	if (!drmmode_setup_colormap(pScreen, pScrn))
-		return FALSE;
-
-	/* Note unused options */
-	if (serverGeneration == 1)
-		xf86ShowUnusedOptions(pScrn->scrnIndex, pScrn->options);
-
+	#endif
+	if (unlikely(!xf86CrtcScreenInit(pScreen))) return FALSE;
+	if (unlikely(!drmmode_setup_colormap(pScreen, pScrn))) return FALSE;
+	if (serverGeneration == 1) xf86ShowUnusedOptions(pScrn->scrnIndex, pScrn->options);
 	if (info->vrr_support) {
-		if (!amdgpu_property_vectors_wrapped) {
-			saved_change_property = ProcVector[X_ChangeProperty];
-			ProcVector[X_ChangeProperty] = amdgpu_change_property;
-			saved_delete_property = ProcVector[X_DeleteProperty];
-			ProcVector[X_DeleteProperty] = amdgpu_delete_property;
+		vrr_lock(); /* Protect global static variables */
+		if (!amdgpu_property_vectors_wrapped) { /* Only wrap if not already done */
+			saved_change_property = ProcVector[X_ChangeProperty]; ProcVector[X_ChangeProperty] = amdgpu_change_property;
+			saved_delete_property = ProcVector[X_DeleteProperty]; ProcVector[X_DeleteProperty] = amdgpu_delete_property;
 			amdgpu_property_vectors_wrapped = TRUE;
 		}
-
-		amdgpu_vrr_atom = MakeAtom("_VARIABLE_REFRESH",
-					   strlen("_VARIABLE_REFRESH"), TRUE);
+		vrr_unlock();
+		amdgpu_vrr_atom = MakeAtom("_VARIABLE_REFRESH", strlen("_VARIABLE_REFRESH"), TRUE);
 	}
-
 	drmmode_init(pScrn, &info->drmmode);
-
-	xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, AMDGPU_LOGLEVEL_DEBUG,
-		       "AMDGPUScreenInit finished\n");
-
+	xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, AMDGPU_LOGLEVEL_DEBUG, "AMDGPUScreenInit finished\n");
 	return TRUE;
 }
 
 Bool AMDGPUEnterVT_KMS(ScrnInfoPtr pScrn)
 {
 	AMDGPUInfoPtr info = AMDGPUPTR(pScrn);
-
-	xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, AMDGPU_LOGLEVEL_DEBUG,
-		       "AMDGPUEnterVT_KMS\n");
-
+	xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, AMDGPU_LOGLEVEL_DEBUG, "AMDGPUEnterVT_KMS\n");
 	amdgpu_set_drm_master(pScrn);
-
 	if (info->shadow_fb) {
 		int pitch;
 		struct amdgpu_buffer *front_buffer =
-			amdgpu_alloc_pixmap_bo(pScrn, pScrn->virtualX,
-					       pScrn->virtualY, pScrn->depth,
-					       AMDGPU_CREATE_PIXMAP_SCANOUT |
-					       AMDGPU_CREATE_PIXMAP_LINEAR,
-					       pScrn->bitsPerPixel,
-					       &pitch);
-
-		if (front_buffer) {
+		amdgpu_alloc_pixmap_bo(pScrn, pScrn->virtualX, pScrn->virtualY, pScrn->depth,
+							   AMDGPU_CREATE_PIXMAP_SCANOUT | AMDGPU_CREATE_PIXMAP_LINEAR,
+						 pScrn->bitsPerPixel, &pitch);
+		if (likely(front_buffer)) {
 			if (amdgpu_bo_map(pScrn, front_buffer) == 0) {
-				memset(front_buffer->cpu_ptr, 0, pitch * pScrn->virtualY);
-				amdgpu_bo_unref(&info->front_buffer);
-				info->front_buffer = front_buffer;
-			} else {
-				amdgpu_bo_unref(&front_buffer);
-				front_buffer = NULL;
-			}
-		}
-
-		if (!front_buffer) {
-			xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
-				   "Failed to allocate new scanout BO after VT switch, "
-				   "other DRM masters may see screen contents\n");
+				if (likely(front_buffer->cpu_ptr))
+					memset(front_buffer->cpu_ptr, 0, (size_t)pitch * pScrn->virtualY);
+				amdgpu_bo_unref(&info->front_buffer); info->front_buffer = front_buffer;
+			} else { amdgpu_bo_unref(&front_buffer); front_buffer = NULL; }
 		}
+		if (unlikely(!front_buffer))
+			xf86DrvMsg(pScrn->scrnIndex, X_WARNING, "Failed to allocate new scanout BO after VT switch\n");
 	}
-
 	pScrn->vtSema = TRUE;
-
-	if (!drmmode_set_desired_modes(pScrn, &info->drmmode, TRUE))
-		return FALSE;
-
+	if (unlikely(!drmmode_set_desired_modes(pScrn, &info->drmmode, TRUE))) return FALSE;
 	return TRUE;
 }
 
-static void
-pixmap_unref_fb(PixmapPtr pixmap)
+static void pixmap_unref_fb(PixmapPtr pixmap)
 {
 	ScrnInfoPtr scrn = xf86ScreenToScrn(pixmap->drawable.pScreen);
 	struct drmmode_fb **fb_ptr = amdgpu_pixmap_get_fb_ptr(pixmap);
 	AMDGPUEntPtr pAMDGPUEnt = AMDGPUEntPriv(scrn);
-
-	if (fb_ptr)
-		drmmode_fb_reference(pAMDGPUEnt->fd, fb_ptr, NULL);
+	if (fb_ptr) drmmode_fb_reference(pAMDGPUEnt->fd, fb_ptr, NULL);
 }
 
-static void
-client_pixmap_unref_fb(void *value, XID id, void *pScreen)
+static void client_pixmap_unref_fb(void *value, XID id, void *pScreen)
 {
 	PixmapPtr pixmap = value;
-
-	if (pixmap->drawable.pScreen == pScreen)
-		pixmap_unref_fb(pixmap);
+	if (pixmap->drawable.pScreen == pScreen) pixmap_unref_fb(pixmap);
 }
 
 void AMDGPULeaveVT_KMS(ScrnInfoPtr pScrn)
 {
-	AMDGPUInfoPtr info = AMDGPUPTR(pScrn);
-	ScreenPtr pScreen = pScrn->pScreen;
-
-	xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, AMDGPU_LOGLEVEL_DEBUG,
-		       "AMDGPULeaveVT_KMS\n");
-
+	AMDGPUInfoPtr info = AMDGPUPTR(pScrn); ScreenPtr pScreen = pScrn->pScreen;
+	xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, AMDGPU_LOGLEVEL_DEBUG, "AMDGPULeaveVT_KMS\n");
 	if (!info->shadow_fb) {
 		AMDGPUEntPtr pAMDGPUEnt = AMDGPUEntPriv(pScrn);
 		xf86CrtcConfigPtr xf86_config = XF86_CRTC_CONFIG_PTR(pScrn);
-		xf86CrtcPtr crtc;
-		drmmode_crtc_private_ptr drmmode_crtc;
-		unsigned w = 0, h = 0;
-		int i;
-
-		/* If we're called from CloseScreen, trying to clear the black
-		 * scanout BO will likely crash and burn
-		 */
-		if (!pScreen->GCperDepth[0])
-			goto hide_cursors;
-
-		/* Compute maximum scanout dimensions of active CRTCs */
-		for (i = 0; i < xf86_config->num_crtc; i++) {
-			crtc = xf86_config->crtc[i];
-			drmmode_crtc = crtc->driver_private;
-
-			if (!drmmode_crtc->fb)
-				continue;
-
-			w = max(w, crtc->mode.HDisplay);
-			h = max(h, crtc->mode.VDisplay);
+		xf86CrtcPtr crtc; drmmode_crtc_private_ptr drmmode_crtc;
+		unsigned w = 0, h = 0; int i;
+		if (unlikely(!pScreen->GCperDepth[0])) goto hide_cursors;
+		for (i=0; i<xf86_config->num_crtc; i++) {
+			if (unlikely(!xf86_config->crtc[i])) continue;
+			crtc = xf86_config->crtc[i]; drmmode_crtc = crtc->driver_private;
+			if (unlikely(!drmmode_crtc || !drmmode_crtc->fb)) continue;
+			w = max(w, crtc->mode.HDisplay); h = max(h, crtc->mode.VDisplay);
 		}
-
-		/* Make all active CRTCs scan out from an all-black framebuffer */
 		if (w > 0 && h > 0) {
-			PixmapPtr black_scanout =
-				pScreen->CreatePixmap(pScreen, w, h, pScrn->depth,
-						      AMDGPU_CREATE_PIXMAP_SCANOUT);
-
-			if (black_scanout) {
-				struct drmmode_fb *black_fb =
-					amdgpu_pixmap_get_fb(black_scanout);
-
-				amdgpu_pixmap_clear(black_scanout);
-				amdgpu_glamor_finish(pScrn);
-
-				for (i = 0; i < xf86_config->num_crtc; i++) {
-					crtc = xf86_config->crtc[i];
-					drmmode_crtc = crtc->driver_private;
-
-					if (drmmode_crtc->fb) {
-						if (black_fb) {
-							drmmode_set_mode(crtc, black_fb, &crtc->mode, 0, 0);
-						} else {
-							drmModeSetCrtc(pAMDGPUEnt->fd,
-								       drmmode_crtc->mode_crtc->crtc_id, 0,
-								       0, 0, NULL, 0, NULL);
-							drmmode_fb_reference(pAMDGPUEnt->fd,
-									     &drmmode_crtc->fb, NULL);
-						}
-
+			PixmapPtr black_scanout = pScreen->CreatePixmap(pScreen,w,h,pScrn->depth,AMDGPU_CREATE_PIXMAP_SCANOUT);
+			if (likely(black_scanout)) {
+				struct drmmode_fb *black_fb = amdgpu_pixmap_get_fb(black_scanout);
+				amdgpu_pixmap_clear(black_scanout); amdgpu_glamor_finish(pScrn);
+				for (i=0; i<xf86_config->num_crtc; i++) {
+					if (unlikely(!xf86_config->crtc[i])) continue;
+					crtc = xf86_config->crtc[i]; drmmode_crtc = crtc->driver_private;
+					if (unlikely(!drmmode_crtc || !drmmode_crtc->fb)) continue;
+					if (black_fb) drmmode_set_mode(crtc,black_fb,&crtc->mode,0,0);
+					else { drmModeSetCrtc(pAMDGPUEnt->fd, drmmode_crtc->mode_crtc->crtc_id,0,0,0,NULL,0,NULL);
+						drmmode_fb_reference(pAMDGPUEnt->fd, &drmmode_crtc->fb,NULL); }
 						if (pScrn->is_gpu) {
-							if (drmmode_crtc->scanout[0])
-								pixmap_unref_fb(drmmode_crtc->scanout[0]);
-							if (drmmode_crtc->scanout[1])
-								pixmap_unref_fb(drmmode_crtc->scanout[1]);
-						} else {
-							drmmode_crtc_scanout_free(crtc);
-						}
-					}
+							if(drmmode_crtc->scanout[0])pixmap_unref_fb(drmmode_crtc->scanout[0]);
+							if(drmmode_crtc->scanout[1])pixmap_unref_fb(drmmode_crtc->scanout[1]);
+						} else drmmode_crtc_scanout_free(crtc);
 				}
-				dixDestroyPixmap(black_scanout, 0);
+				dixDestroyPixmap(black_scanout,0);
 			}
 		}
-
 		xf86RotateFreeShadow(pScrn);
-
-		/* Unreference FBs of all pixmaps. After this, the only FB remaining
-		 * should be the all-black one being scanned out by active CRTCs
-		 */
-		for (i = 0; i < currentMaxClients; i++) {
-			if (i > 0 &&
-			    (!clients[i] || clients[i]->clientState != ClientStateRunning))
-				continue;
-
-			FindClientResourcesByType(clients[i], RT_PIXMAP,
-						  client_pixmap_unref_fb, pScreen);
+		for (i=0; i<currentMaxClients; i++) {
+			if (i>0 && (!clients[i] || clients[i]->clientState!=ClientStateRunning)) continue;
+			FindClientResourcesByType(clients[i],RT_PIXMAP,client_pixmap_unref_fb,pScreen);
 		}
-
 		pixmap_unref_fb(pScreen->GetScreenPixmap(pScreen));
 	} else {
-		memset(info->front_buffer->cpu_ptr, 0, pScrn->virtualX *
-		       info->pixel_bytes * pScrn->virtualY);
+		if (likely(info->front_buffer && info->front_buffer->cpu_ptr))
+			memset(info->front_buffer->cpu_ptr, 0, (size_t)pScrn->virtualX * info->pixel_bytes * pScrn->virtualY);
 	}
-
-	if (pScreen->GCperDepth[0])
-		TimerSet(NULL, 0, 1000, cleanup_black_fb, pScreen);
-
- hide_cursors:
+	if (pScreen->GCperDepth[0]) TimerSet(NULL,0,1000,cleanup_black_fb,pScreen);
+	hide_cursors:
 	xf86_hide_cursors(pScrn);
-
 	amdgpu_drop_drm_master(pScrn);
-
-	xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, AMDGPU_LOGLEVEL_DEBUG,
-		       "Ok, leaving now...\n");
+	xf86DrvMsgVerb(pScrn->scrnIndex,X_INFO,AMDGPU_LOGLEVEL_DEBUG,"Ok, leaving now...\n");
 }
 
 Bool AMDGPUSwitchMode_KMS(ScrnInfoPtr pScrn, DisplayModePtr mode)
 {
-	Bool ret;
-	ret = xf86SetSingleMode(pScrn, mode, RR_Rotate_0);
-	return ret;
-
+	return xf86SetSingleMode(pScrn, mode, RR_Rotate_0);
 }
 
 void AMDGPUAdjustFrame_KMS(ScrnInfoPtr pScrn, int x, int y)
 {
 	AMDGPUInfoPtr info = AMDGPUPTR(pScrn);
 	drmmode_adjust_frame(pScrn, &info->drmmode, x, y);
-	return;
 }
 
 static Bool amdgpu_setup_kernel_mem(ScreenPtr pScreen)
@@ -2395,78 +1917,48 @@ static Bool amdgpu_setup_kernel_mem(Scre
 	AMDGPUEntPtr pAMDGPUEnt = AMDGPUEntPriv(pScrn);
 	AMDGPUInfoPtr info = AMDGPUPTR(pScrn);
 	xf86CrtcConfigPtr xf86_config = XF86_CRTC_CONFIG_PTR(pScrn);
-	int cpp = info->pixel_bytes;
-	int cursor_size;
-	int c, i;
+	int cpp = info->pixel_bytes; int cursor_size; int c, i;
 
 	cursor_size = info->cursor_w * info->cursor_h * 4;
 	cursor_size = AMDGPU_ALIGN(cursor_size, AMDGPU_GPU_PAGE_SIZE);
 	for (c = 0; c < xf86_config->num_crtc; c++) {
+		if (unlikely(!xf86_config->crtc[c])) continue;
 		drmmode_crtc_private_ptr drmmode_crtc = xf86_config->crtc[c]->driver_private;
-
+		if (unlikely(!drmmode_crtc)) continue;
 		for (i = 0; i < 2; i++) {
 			if (!drmmode_crtc->cursor_buffer[i]) {
 				drmmode_crtc->cursor_buffer[i] =
-					amdgpu_bo_open(pAMDGPUEnt->pDev,
-						       cursor_size, 0,
-						       AMDGPU_GEM_DOMAIN_VRAM);
-
-				if (!(drmmode_crtc->cursor_buffer[i])) {
-					ErrorF("Failed to allocate cursor buffer memory\n");
-					return FALSE;
+				amdgpu_bo_open(pAMDGPUEnt->pDev, cursor_size,0,AMDGPU_GEM_DOMAIN_VRAM);
+				if (unlikely(!drmmode_crtc->cursor_buffer[i])) {
+					ErrorF("Failed to allocate cursor buffer memory\n"); return FALSE;
 				}
-
-				if (amdgpu_bo_cpu_map(drmmode_crtc->cursor_buffer[i]->bo.amdgpu,
-						      &drmmode_crtc->cursor_buffer[i]->cpu_ptr))
-					ErrorF("Failed to map cursor buffer memory\n");
+				if (unlikely(amdgpu_bo_cpu_map(drmmode_crtc->cursor_buffer[i]->bo.amdgpu,
+					&drmmode_crtc->cursor_buffer[i]->cpu_ptr)))
+					ErrorF("Failed to map cursor buffer memory\n"); /* Non-fatal? Continue. */
 			}
 		}
 	}
-
 	if (!info->front_buffer) {
-		int pitch;
-		int hint = AMDGPU_CREATE_PIXMAP_SCANOUT | AMDGPU_CREATE_PIXMAP_FRONT;
-
-		if (info->shadow_primary)
-			hint |= AMDGPU_CREATE_PIXMAP_LINEAR | AMDGPU_CREATE_PIXMAP_GTT;
-		else if (!info->use_glamor)
-			hint |= AMDGPU_CREATE_PIXMAP_LINEAR;
-
-		info->front_buffer =
-			amdgpu_alloc_pixmap_bo(pScrn, pScrn->virtualX,
-					       pScrn->virtualY, pScrn->depth,
-					       hint, pScrn->bitsPerPixel,
-					       &pitch);
-		if (!(info->front_buffer)) {
-			ErrorF("Failed to allocate front buffer memory\n");
-			return FALSE;
+		int pitch; int hint = AMDGPU_CREATE_PIXMAP_SCANOUT | AMDGPU_CREATE_PIXMAP_FRONT;
+		if (info->shadow_primary) hint |= AMDGPU_CREATE_PIXMAP_LINEAR | AMDGPU_CREATE_PIXMAP_GTT;
+		else if (!info->use_glamor) hint |= AMDGPU_CREATE_PIXMAP_LINEAR;
+		info->front_buffer = amdgpu_alloc_pixmap_bo(pScrn, pScrn->virtualX, pScrn->virtualY,
+													pScrn->depth, hint, pScrn->bitsPerPixel, &pitch);
+		if (unlikely(!info->front_buffer)) {
+			ErrorF("Failed to allocate front buffer memory\n"); return FALSE;
 		}
-
-		if (!info->use_glamor &&
-		    amdgpu_bo_map(pScrn, info->front_buffer) != 0) {
-			ErrorF("Failed to map front buffer memory\n");
-			return FALSE;
+		if (!info->use_glamor && unlikely(amdgpu_bo_map(pScrn, info->front_buffer) != 0)) {
+			ErrorF("Failed to map front buffer memory\n"); return FALSE;
 		}
-
 		pScrn->displayWidth = pitch / cpp;
 	}
-
-	xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Front buffer pitch: %d bytes\n",
-		   pScrn->displayWidth * cpp);
+	xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Front buffer pitch: %d bytes\n", pScrn->displayWidth*cpp);
 	return TRUE;
 }
 
-/* Used to disallow modes that are not supported by the hardware */
-ModeStatus AMDGPUValidMode(ScrnInfoPtr pScrn, DisplayModePtr mode,
-			   Bool verbose, int flag)
-{
-	/* There are problems with double scan mode at high clocks
-	 * They're likely related PLL and display buffer settings.
-	 * Disable these modes for now.
-	 */
-	if (mode->Flags & V_DBLSCAN) {
-		if ((mode->CrtcHDisplay >= 1024) || (mode->CrtcVDisplay >= 768))
-			return MODE_CLOCK_RANGE;
-	}
+ModeStatus AMDGPUValidMode(ScrnInfoPtr pScrn, DisplayModePtr mode, Bool verbose, int flag)
+{
+	if (mode->Flags & V_DBLSCAN && (mode->CrtcHDisplay >= 1024 || mode->CrtcVDisplay >= 768))
+		return MODE_CLOCK_RANGE;
 	return MODE_OK;
 }


--- a/src/amdgpu_dri2.c	2025-05-18 10:11:28.156421974 +0200
+++ b/src/amdgpu_dri2.c	2025-05-18 11:06:23.290964784 +0200
@@ -26,7 +26,7 @@
  * DEALINGS IN THE SOFTWARE.
  */
 #ifdef HAVE_CONFIG_H
-#include "config.h"
+# include "config.h"
 #endif
 
 #include "amdgpu_drv.h"
@@ -42,906 +42,863 @@
 #include <sys/stat.h>
 #include <fcntl.h>
 #include <errno.h>
+#include <stdint.h>
+#include <string.h>
 
 #include <gbm.h>
 
 #include "amdgpu_bo_helper.h"
 #include "amdgpu_version.h"
 
-#include <list.h>
+#include <list.h> /* From Xorg server includes */
 #include <xf86Priv.h>
 #include <X11/extensions/dpmsconst.h>
+#include <regionstr.h> /* For Region* function prototypes and RegionRec */
 
 #define FALLBACK_SWAP_DELAY 16
 
+/* Branch-prediction helpers */
+#if (defined(__GNUC__) && (__GNUC__ >= 3)) || defined(__clang__)
+# define likely(x)   __builtin_expect(!!(x), 1)
+# define unlikely(x) __builtin_expect(!!(x), 0)
+#else
+# define likely(x)   (x)
+# define unlikely(x) (x)
+#endif
+
+/* For Scratch GC Cache */
+#define MAX_GC_DEPTH 32 /* Max depth value (0-32 needs array size 33) */
+#define GC_CACHE_PER_DEPTH 1
+
+
 typedef DRI2BufferPtr BufferPtr;
 
 struct dri2_buffer_priv {
-	PixmapPtr pixmap;
+	PixmapPtr    pixmap;
 	unsigned int attachment;
 	unsigned int refcnt;
 };
 
 struct dri2_window_priv {
 	xf86CrtcPtr crtc;
-	int vblank_delta;
+	int         vblank_delta;
 };
 
 static DevPrivateKeyRec dri2_window_private_key_rec;
 #define dri2_window_private_key (&dri2_window_private_key_rec)
-
 #define get_dri2_window_priv(window) \
-	((struct dri2_window_priv*) \
-	 dixLookupPrivate(&(window)->devPrivates, dri2_window_private_key))
+((struct dri2_window_priv *) \
+dixLookupPrivate(&(window)->devPrivates, dri2_window_private_key))
+
+static int DRI2InfoCnt; /* Declaration for the global counter */
+
+enum DRI2FrameEventType {
+	DRI2_SWAP,
+	DRI2_FLIP,
+	DRI2_WAITMSC,
+};
+
+typedef struct _DRI2FrameEvent {
+	XID                     drawable_id;
+	ClientPtr               client;
+	enum DRI2FrameEventType type;
+	unsigned                frame;
+	xf86CrtcPtr             crtc;
+	OsTimerPtr              timer;
+	uintptr_t               drm_queue_seq;
+
+	DRI2SwapEventPtr        event_complete;
+	void                   *event_data;
+	DRI2BufferPtr           front;
+	DRI2BufferPtr           back;
+	struct _DRI2FrameEvent *next;
+} __attribute__((aligned(64))) DRI2FrameEventRec,
+*DRI2FrameEventPtr;
+
+static volatile int global_spin = 0;
+static inline void gl_lock  (void) { while (__sync_lock_test_and_set(&global_spin, 1)); }
+static inline void gl_unlock(void) { __sync_lock_release(&global_spin); }
+
+#define FRAME_EVENT_CACHE_MAX 256
+static DRI2FrameEventPtr fe_free_list        = NULL;
+static unsigned          fe_free_list_length = 0;
+
+static inline DRI2FrameEventPtr frame_event_alloc(void)
+{
+	DRI2FrameEventPtr ev = NULL;
+
+	gl_lock();
+	if (fe_free_list) {
+		ev            = fe_free_list;
+		fe_free_list  = ev->next;
+		fe_free_list_length--;
+	}
+	gl_unlock();
+
+	if (ev) {
+		memset(ev, 0, sizeof(*ev));
+		return ev;
+	}
+	return calloc(1, sizeof(DRI2FrameEventRec));
+}
+
+static inline void frame_event_free(DRI2FrameEventPtr ev)
+{
+	if (!ev)
+		return;
+
+	gl_lock();
+	if (fe_free_list_length >= FRAME_EVENT_CACHE_MAX) {
+		gl_unlock();
+		free(ev);
+		return;
+	}
+	ev->next       = fe_free_list;
+	fe_free_list   = ev;
+	fe_free_list_length++;
+	gl_unlock();
+}
+
+#define FLINK_CACHE_SIZE 64
+typedef struct {
+	uint32_t bo_handle;
+	uint32_t flink_name;
+	Bool     valid;
+} FlinkCacheEntry;
+
+static FlinkCacheEntry flink_cache[FLINK_CACHE_SIZE];
+static int            flink_cache_idx = 0;
 
-/* Get GEM flink name for a pixmap */
 static Bool
-amdgpu_get_flink_name(AMDGPUEntPtr pAMDGPUEnt, PixmapPtr pixmap, uint32_t *name)
+amdgpu_get_flink_name(AMDGPUEntPtr pEnt, PixmapPtr pixmap, uint32_t *name)
 {
 	struct amdgpu_buffer *bo = amdgpu_get_pixmap_bo(pixmap);
-	struct drm_gem_flink flink;
+	uint32_t handle;
 
-	if (bo && !(bo->flags & AMDGPU_BO_FLAGS_GBM) &&
-	    amdgpu_bo_export(bo->bo.amdgpu,
-			     amdgpu_bo_handle_type_gem_flink_name,
-			     name) == 0)
-		return TRUE;
+	if (!amdgpu_pixmap_get_handle(pixmap, &handle))
+		return FALSE;
+
+	/* --- Fast path : cached and non-GBM -------------------------------- */
+	if (bo && !(bo->flags & AMDGPU_BO_FLAGS_GBM)) {
+		gl_lock();
+		for (int i = 0; i < FLINK_CACHE_SIZE; ++i) {
+			if (flink_cache[i].valid && flink_cache[i].bo_handle == handle) {
+				*name = flink_cache[i].flink_name;
+				gl_unlock();
+				return TRUE;
+			}
+		}
+		gl_unlock();
+
+		if (amdgpu_bo_export(bo->bo.amdgpu,
+			amdgpu_bo_handle_type_gem_flink_name,
+			name) == 0)
+		{
+			gl_lock();
+			flink_cache[flink_cache_idx].bo_handle  = handle;
+			flink_cache[flink_cache_idx].flink_name = *name;
+			flink_cache[flink_cache_idx].valid      = TRUE;
+			flink_cache_idx = (flink_cache_idx + 1) % FLINK_CACHE_SIZE;
+			gl_unlock();
+			return TRUE;
+		}
+	}
 
-	if (!amdgpu_pixmap_get_handle(pixmap, &flink.handle) ||
-	    ioctl(pAMDGPUEnt->fd, DRM_IOCTL_GEM_FLINK, &flink) < 0)
+	/* --- Fallback : DRM ioctl ------------------------------------------ */
+	struct drm_gem_flink req = { .handle = handle };
+	if (ioctl(pEnt->fd, DRM_IOCTL_GEM_FLINK, &req) < 0)
 		return FALSE;
-	*name = flink.name;
+
+	*name = req.name;
 	return TRUE;
 }
 
-static BufferPtr
-amdgpu_dri2_create_buffer2(ScreenPtr pScreen,
-			   DrawablePtr drawable,
-			   unsigned int attachment, unsigned int format)
+static Bool update_front(DrawablePtr draw, DRI2BufferPtr front)
 {
-	ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
-	AMDGPUEntPtr pAMDGPUEnt = AMDGPUEntPriv(pScrn);
-	AMDGPUInfoPtr info = AMDGPUPTR(pScrn);
-	BufferPtr buffers;
-	struct dri2_buffer_priv *privates;
-	PixmapPtr pixmap;
-	unsigned front_width;
-	unsigned aligned_width = drawable->width;
-	unsigned height = drawable->height;
-	Bool is_glamor_pixmap = FALSE;
-	int depth;
-	int cpp;
-
-	if (format) {
-		depth = format;
-
-		switch (depth) {
-		case 15:
-			cpp = 2;
-			break;
-		case 24:
-		case 30:
-			cpp = 4;
-			break;
-		default:
-			cpp = depth / 8;
-		}
-	} else {
-		depth = drawable->depth;
-		cpp = drawable->bitsPerPixel / 8;
-	}
+	ScreenPtr          s     = draw->pScreen;
+	AMDGPUEntPtr       ent   = AMDGPUEntPriv(xf86ScreenToScrn(s));
+	struct dri2_buffer_priv *priv = front->driverPrivate;
+	PixmapPtr          px    = get_drawable_pixmap(draw);
 
-	front_width = pScreen->GetScreenPixmap(pScreen)->drawable.width;
+	if (!priv || !px)
+		return FALSE;
+
+	if (!amdgpu_get_flink_name(ent, px, &front->name))
+		return FALSE;
 
-	pixmap = NULL;
+	if (priv->pixmap)
+		dixDestroyPixmap(priv->pixmap, 0);
 
+	front->pitch = px->devKind;
+	front->cpp   = px->drawable.bitsPerPixel / 8;
+	priv->pixmap = px;
+	px->refcnt++;
+	return TRUE;
+}
+
+static const uint8_t depth_to_cpp_table[33] = {
+	[0]  = 0,
+	[1 ... 7] = 1,  [8]  = 1,
+	[9 ... 14]= 2,  [15] = 2, [16] = 2,
+	[17 ... 23]= 3,
+	[24] = 4,
+	[25 ... 29]= 4, [30] = 4,
+	[31 ... 32]= 4
+};
+
+static BufferPtr
+amdgpu_dri2_create_buffer2(ScreenPtr      pScreen,
+						   DrawablePtr    drawable,
+						   unsigned int   attachment,
+						   unsigned int   format)
+{
+	ScrnInfoPtr              pScrn  = xf86ScreenToScrn(pScreen);
+	AMDGPUEntPtr             pEnt   = AMDGPUEntPriv(pScrn);
+	AMDGPUInfoPtr            info   = AMDGPUPTR(pScrn);
+	BufferPtr                buf    = NULL;
+	struct dri2_buffer_priv *priv   = NULL;
+	PixmapPtr                pixmap = NULL;
+	unsigned                 aw     = drawable->width;
+	unsigned                 h      = drawable->height;
+	unsigned                 front_w= pScreen->GetScreenPixmap(pScreen)->drawable.width;
+	Bool                     glamor = FALSE;
+	int                      depth, cpp;
+
+	/* depth / cpp ------------------------------------------------------- */
+	if (format) { depth = format;   cpp = (depth <= 32) ? depth_to_cpp_table[depth] : 0; }
+	else        { depth = drawable->depth; cpp = (depth <= 32) ? depth_to_cpp_table[depth] : 0; }
+	if (cpp == 0) cpp = (depth + 7) / 8;
+
+	/* choose pixmap ----------------------------------------------------- */
 	if (attachment == DRI2BufferFrontLeft) {
 		uint32_t handle;
-
 		pixmap = get_drawable_pixmap(drawable);
 		if (pScreen != pixmap->drawable.pScreen)
 			pixmap = NULL;
 		else if (info->use_glamor && !amdgpu_pixmap_get_handle(pixmap, &handle)) {
-			is_glamor_pixmap = TRUE;
-			aligned_width = pixmap->drawable.width;
-			height = pixmap->drawable.height;
+			glamor = TRUE;
+			aw     = pixmap->drawable.width;
+			h      = pixmap->drawable.height;
 			pixmap = NULL;
 		} else
 			pixmap->refcnt++;
 	}
 
-	if (!pixmap && (is_glamor_pixmap || attachment != DRI2BufferFrontLeft)) {
-		if (aligned_width == front_width)
-			aligned_width = pScrn->virtualX;
-
-		pixmap = (*pScreen->CreatePixmap) (pScreen,
-						   aligned_width,
-						   height,
-						   depth,
-						   AMDGPU_CREATE_PIXMAP_DRI2);
-	}
-
-	if (!pixmap)
-		return NULL;
+	if (!pixmap && (glamor || attachment != DRI2BufferFrontLeft)) {
+		if (aw == front_w) aw = pScrn->virtualX;
+		pixmap = (*pScreen->CreatePixmap)(pScreen, aw, h, depth,
+										  AMDGPU_CREATE_PIXMAP_DRI2);
+	}
+	if (!pixmap) return NULL;
+
+	/* unified allocation ------------------------------------------------ */
+	buf  = calloc(1, sizeof(DRI2BufferRec) + sizeof(struct dri2_buffer_priv));
+	if (!buf) goto err;
 
-	buffers = calloc(1, sizeof *buffers);
-	if (!buffers)
-		goto error;
+	priv = (struct dri2_buffer_priv *)((char *)buf + sizeof(DRI2BufferRec));
+	buf->driverPrivate = priv;
 
-	if (is_glamor_pixmap) {
+	/* glamor redirect --------------------------------------------------- */
+	if (glamor) {
 		pixmap = amdgpu_glamor_set_pixmap_bo(drawable, pixmap);
+		if (!pixmap) goto err;
 		pixmap->refcnt++;
-
-		/* The copy operation from amdgpu_glamor_set_pixmap_bo needs to
-		 * be flushed to the kernel driver before the client starts
-		 * using the pixmap storage for direct rendering.
-		 */
 		amdgpu_glamor_flush(pScrn);
 	}
 
-	if (!amdgpu_get_flink_name(pAMDGPUEnt, pixmap, &buffers->name))
-		goto error;
+	if (!amdgpu_get_flink_name(pEnt, pixmap, &buf->name))
+		goto err;
 
-	privates = calloc(1, sizeof(struct dri2_buffer_priv));
-	if (!privates)
-		goto error;
-
-	buffers->attachment = attachment;
-	buffers->pitch = pixmap->devKind;
-	buffers->cpp = cpp;
-	buffers->driverPrivate = privates;
-	buffers->format = format;
-	buffers->flags = 0;	/* not tiled */
-	privates->pixmap = pixmap;
-	privates->attachment = attachment;
-	privates->refcnt = 1;
-
-	return buffers;
-
-error:
-	free(buffers);
-	dixDestroyPixmap(pixmap, 0);
+	buf->attachment = attachment;
+	buf->pitch      = pixmap->devKind;
+	buf->cpp        = cpp;
+	buf->format     = format;
+	buf->flags      = 0;
+
+	priv->pixmap     = pixmap;
+	priv->attachment = attachment;
+	priv->refcnt     = 1;
+	return buf;
+
+	err:
+	if (buf)    free(buf);
+	if (pixmap) dixDestroyPixmap(pixmap, 0);
 	return NULL;
 }
 
 static void
-amdgpu_dri2_destroy_buffer2(ScreenPtr pScreen,
-			    DrawablePtr drawable, BufferPtr buffers)
+amdgpu_dri2_destroy_buffer2(ScreenPtr pScreen, DrawablePtr drawable,
+							BufferPtr buf)
 {
-	if (buffers) {
-		struct dri2_buffer_priv *private = buffers->driverPrivate;
+	if (!buf) return;
 
-		/* Trying to free an already freed buffer is unlikely to end well */
-		if (private->refcnt == 0) {
-			ScrnInfoPtr scrn = xf86ScreenToScrn(pScreen);
-
-			xf86DrvMsg(scrn->scrnIndex, X_WARNING,
-				   "Attempted to destroy previously destroyed buffer.\
- This is a programming error\n");
-			return;
-		}
+	struct dri2_buffer_priv *priv = buf->driverPrivate;
+	if (!priv) return;
 
-		private->refcnt--;
-		if (private->refcnt == 0) {
-			if (private->pixmap)
-				dixDestroyPixmap(private->pixmap, 0);
+	if (priv->refcnt == 0) {
+		xf86DrvMsg(xf86ScreenToScrn(pScreen)->scrnIndex, X_WARNING,
+				   "DRI2 buffer double-free attempt ignored.\n");
+		return;
+	}
 
-			free(buffers->driverPrivate);
-			free(buffers);
-		}
+	if (--priv->refcnt == 0) {
+		if (priv->pixmap)
+			dixDestroyPixmap(priv->pixmap, 0);
+		free(buf);
 	}
 }
 
-static inline PixmapPtr GetDrawablePixmap(DrawablePtr drawable)
+static GCPtr gc_cache[MAX_GC_DEPTH + 1][GC_CACHE_PER_DEPTH];
+static int   gc_cache_cnt[MAX_GC_DEPTH + 1];
+
+static GCPtr cached_GetScratchGC(unsigned depth, ScreenPtr s)
 {
-	if (drawable->type == DRAWABLE_PIXMAP)
-		return (PixmapPtr) drawable;
-	else {
-		struct _Window *pWin = (struct _Window *)drawable;
-		return drawable->pScreen->GetWindowPixmap(pWin);
-	}
+	if (depth <= MAX_GC_DEPTH && gc_cache_cnt[depth] > 0)
+		return gc_cache[depth][--gc_cache_cnt[depth]];
+	return GetScratchGC(depth, s);
+}
+static void cached_FreeScratchGC(GCPtr gc)
+{
+	if (!gc) return;
+	unsigned d = gc->depth;
+	if (d <= MAX_GC_DEPTH && gc_cache_cnt[d] < GC_CACHE_PER_DEPTH)
+		gc_cache[d][gc_cache_cnt[d]++] = gc;
+	else
+		FreeScratchGC(gc);
+}
+
+static inline PixmapPtr GetDrawablePixmap(DrawablePtr d)
+{
+	if (d->type == DRAWABLE_PIXMAP)
+		return (PixmapPtr)d;
+	return d->pScreen->GetWindowPixmap((WindowPtr)d);
 }
 
 static void
-amdgpu_dri2_copy_region2(ScreenPtr pScreen,
-			 DrawablePtr drawable,
-			 RegionPtr region,
-			 BufferPtr dest_buffer, BufferPtr src_buffer)
-{
-	struct dri2_buffer_priv *src_private = src_buffer->driverPrivate;
-	struct dri2_buffer_priv *dst_private = dest_buffer->driverPrivate;
-	DrawablePtr src_drawable;
-	DrawablePtr dst_drawable;
-	RegionPtr copy_clip;
-	GCPtr gc;
-	Bool translate = FALSE;
-	int off_x = 0, off_y = 0;
+amdgpu_dri2_copy_region2(ScreenPtr pScreen, DrawablePtr drawable,
+						 RegionPtr region_ptr, BufferPtr dst_buf,
+						 BufferPtr src_buf)
+{
+	struct dri2_buffer_priv *srcp = src_buf->driverPrivate;
+	struct dri2_buffer_priv *dstp = dst_buf->driverPrivate;
+	if (!srcp || !dstp || !srcp->pixmap || !dstp->pixmap)
+		return;
 
-	src_drawable = &src_private->pixmap->drawable;
-	dst_drawable = &dst_private->pixmap->drawable;
+	DrawablePtr src_draw = &srcp->pixmap->drawable;
+	DrawablePtr dst_draw = &dstp->pixmap->drawable;
+	Bool translate = FALSE;
+	int  off_x = 0, off_y = 0;
 
-	if (src_private->attachment == DRI2BufferFrontLeft) {
+	if (srcp->attachment == DRI2BufferFrontLeft) {
 		if (drawable->pScreen != pScreen) {
-			src_drawable = DRI2UpdatePrime(drawable, src_buffer);
-			if (!src_drawable)
-				return;
-		} else
-			src_drawable = drawable;
+			src_draw = DRI2UpdatePrime(drawable, src_buf);
+			if (!src_draw) return;
+		} else src_draw = drawable;
 	}
-	if (dst_private->attachment == DRI2BufferFrontLeft) {
+	if (dstp->attachment == DRI2BufferFrontLeft) {
 		if (drawable->pScreen != pScreen) {
-			dst_drawable = DRI2UpdatePrime(drawable, dest_buffer);
-			if (!dst_drawable)
-				return;
-			if (dst_drawable != drawable)
-				translate = TRUE;
-		} else
-			dst_drawable = drawable;
+			dst_draw = DRI2UpdatePrime(drawable, dst_buf);
+			if (!dst_draw) return;
+			if (dst_draw != drawable) translate = TRUE;
+		} else dst_draw = drawable;
 	}
 
 	if (translate && drawable->type == DRAWABLE_WINDOW) {
-		PixmapPtr pPix = GetDrawablePixmap(drawable);
-
-		off_x = drawable->x - pPix->screen_x;
-		off_y = drawable->y - pPix->screen_y;
+		PixmapPtr winpx = GetDrawablePixmap(drawable);
+		off_x = drawable->x - winpx->screen_x;
+		off_y = drawable->y - winpx->screen_y;
 	}
-	gc = GetScratchGC(dst_drawable->depth, pScreen);
-	copy_clip = REGION_CREATE(pScreen, NULL, 0);
-	REGION_COPY(pScreen, copy_clip, region);
 
-	if (translate) {
-		REGION_TRANSLATE(pScreen, copy_clip, off_x, off_y);
-	}
+	GCPtr gc = cached_GetScratchGC(dst_draw->depth, pScreen);
+	if (!gc) return;
 
-	(*gc->funcs->ChangeClip) (gc, CT_REGION, copy_clip, 0);
-	ValidateGC(dst_drawable, gc);
+	RegionPtr clip = RegionCreate(NULL, 0);
+	RegionCopy(clip, region_ptr);
+	if (translate) RegionTranslate(clip, off_x, off_y);
 
-	(*gc->ops->CopyArea) (src_drawable, dst_drawable, gc,
-			      0, 0, drawable->width, drawable->height, off_x,
-			      off_y);
+	(*gc->funcs->ChangeClip)(gc, CT_REGION, clip, 0);
+	ValidateGC(dst_draw, gc);
+	(*gc->ops->CopyArea)(src_draw, dst_draw, gc,
+						 0, 0, drawable->width, drawable->height,
+					  off_x, off_y);
 
-	FreeScratchGC(gc);
+	cached_FreeScratchGC(gc);
+	RegionDestroy(clip);
 }
 
-enum DRI2FrameEventType {
-	DRI2_SWAP,
-	DRI2_FLIP,
-	DRI2_WAITMSC,
-};
-
-typedef struct _DRI2FrameEvent {
-	XID drawable_id;
-	ClientPtr client;
-	enum DRI2FrameEventType type;
-	unsigned frame;
-	xf86CrtcPtr crtc;
-	OsTimerPtr timer;
-	uintptr_t drm_queue_seq;
-
-	/* for swaps & flips only */
-	DRI2SwapEventPtr event_complete;
-	void *event_data;
-	DRI2BufferPtr front;
-	DRI2BufferPtr back;
-} DRI2FrameEventRec, *DRI2FrameEventPtr;
-
-static int DRI2InfoCnt;
+static void amdgpu_dri2_ref_buffer(BufferPtr b)
+{
+	if (likely(b && b->driverPrivate))
+		((struct dri2_buffer_priv *)b->driverPrivate)->refcnt++;
+}
 
-static void amdgpu_dri2_ref_buffer(BufferPtr buffer)
+static void amdgpu_dri2_unref_buffer(BufferPtr b)
 {
-	struct dri2_buffer_priv *private = buffer->driverPrivate;
-	private->refcnt++;
+	if (unlikely(!b || !b->driverPrivate))
+		return;
+	struct dri2_buffer_priv *p = b->driverPrivate;
+	if (unlikely(!p->pixmap)) return;
+	DrawablePtr d = &p->pixmap->drawable;
+	amdgpu_dri2_destroy_buffer2(d->pScreen, d, b);
 }
 
-static void amdgpu_dri2_unref_buffer(BufferPtr buffer)
+static void
+amdgpu_dri2_frame_event_abort(xf86CrtcPtr crtc, void *event_data)
 {
-	if (buffer) {
-		struct dri2_buffer_priv *private = buffer->driverPrivate;
-		DrawablePtr draw = &private->pixmap->drawable;
+	DRI2FrameEventPtr event = event_data;
+	if (unlikely(!event)) return;
 
-		amdgpu_dri2_destroy_buffer2(draw->pScreen, draw, buffer);
-	}
+	TimerCancel(event->timer);
+	TimerFree(event->timer);
+	amdgpu_dri2_unref_buffer(event->front);
+	amdgpu_dri2_unref_buffer(event->back);
+	frame_event_free(event);
 }
 
 static void
-amdgpu_dri2_client_state_changed(CallbackListPtr * ClientStateCallback,
-				 pointer data, pointer calldata)
+amdgpu_dri2_client_state_changed(CallbackListPtr *ClientStateCallback,
+								 pointer data, pointer calldata)
 {
 	NewClientInfoRec *clientinfo = calldata;
 	ClientPtr pClient = clientinfo->client;
-
 	switch (pClient->clientState) {
-	case ClientStateRetained:
-	case ClientStateGone:
-		amdgpu_drm_abort_client(pClient);
-		break;
-	default:
-		break;
+		case ClientStateRetained:
+		case ClientStateGone:
+			amdgpu_drm_abort_client(pClient);
+			break;
+		default:
+			break;
 	}
 }
 
-/*
- * Get current frame count delta for the specified drawable and CRTC
- */
 static uint32_t amdgpu_get_msc_delta(DrawablePtr pDraw, xf86CrtcPtr crtc)
 {
 	drmmode_crtc_private_ptr drmmode_crtc = crtc->driver_private;
-
 	if (pDraw && pDraw->type == DRAWABLE_WINDOW)
 		return drmmode_crtc->interpolated_vblanks +
-			get_dri2_window_priv((WindowPtr)pDraw)->vblank_delta;
-
+		get_dri2_window_priv((WindowPtr)pDraw)->vblank_delta;
 	return drmmode_crtc->interpolated_vblanks;
 }
 
-/*
- * Get current frame count and timestamp of the specified CRTC
- */
 static Bool amdgpu_dri2_get_crtc_msc(xf86CrtcPtr crtc, CARD64 *ust, CARD64 *msc)
 {
 	drmmode_crtc_private_ptr drmmode_crtc = crtc->driver_private;
-
-	if (!amdgpu_crtc_is_enabled(crtc) ||
-	    drmmode_crtc_get_ust_msc(crtc, ust, msc) != Success) {
-		/* CRTC is not running, extrapolate MSC and timestamp */
+	if (unlikely(!amdgpu_crtc_is_enabled(crtc) ||
+		drmmode_crtc_get_ust_msc(crtc, ust, msc) != Success)) {
 		ScrnInfoPtr scrn = crtc->scrn;
-		AMDGPUEntPtr pAMDGPUEnt = AMDGPUEntPriv(scrn);
-		CARD64 now, delta_t, delta_seq;
-
-		if (!drmmode_crtc->dpms_last_ust)
-			return FALSE;
-
-		if (drmmode_get_current_ust(pAMDGPUEnt->fd, &now) != 0) {
-			xf86DrvMsg(scrn->scrnIndex, X_ERROR,
-				   "%s cannot get current time\n", __func__);
-			return FALSE;
-		}
+	AMDGPUEntPtr pAMDGPUEnt = AMDGPUEntPriv(scrn);
+	CARD64 now, delta_t, delta_seq;
 
-		delta_t = now - drmmode_crtc->dpms_last_ust;
-		delta_seq = delta_t * drmmode_crtc->dpms_last_fps;
-		delta_seq /= 1000000;
-		*ust = drmmode_crtc->dpms_last_ust;
-		delta_t = delta_seq * 1000000;
-		delta_t /= drmmode_crtc->dpms_last_fps;
-		*ust += delta_t;
-		*msc = drmmode_crtc->dpms_last_seq;
-		*msc += delta_seq;
+	if (unlikely(!drmmode_crtc->dpms_last_ust)) return FALSE;
+	if (unlikely(drmmode_get_current_ust(pAMDGPUEnt->fd, &now) != 0)) {
+		xf86DrvMsg(scrn->scrnIndex, X_ERROR, "%s: cannot get current time\n", __func__);
+		return FALSE;
 	}
-
-	*msc += drmmode_crtc->interpolated_vblanks;
-
-	return TRUE;
+	if (unlikely(drmmode_crtc->dpms_last_fps == 0)) {
+		xf86DrvMsg(scrn->scrnIndex, X_WARNING, "%s: dpms_last_fps is zero.\n", __func__);
+		return FALSE;
+	}
+	delta_t = now - drmmode_crtc->dpms_last_ust;
+	delta_seq = delta_t * drmmode_crtc->dpms_last_fps;
+	delta_seq /= 1000000;
+	*ust = drmmode_crtc->dpms_last_ust;
+	delta_t = delta_seq * 1000000;
+	delta_t /= drmmode_crtc->dpms_last_fps;
+	*ust += delta_t;
+	*msc = drmmode_crtc->dpms_last_seq;
+	*msc += delta_seq;
+		}
+		*msc += drmmode_crtc->interpolated_vblanks;
+		return TRUE;
 }
 
-static
-xf86CrtcPtr amdgpu_dri2_drawable_crtc(DrawablePtr pDraw)
+static xf86CrtcPtr amdgpu_dri2_drawable_crtc(DrawablePtr pDraw)
 {
 	ScreenPtr pScreen = pDraw->pScreen;
 	xf86CrtcPtr crtc = amdgpu_pick_best_crtc(pScreen,
-						 pDraw->x, pDraw->x + pDraw->width,
-						 pDraw->y, pDraw->y + pDraw->height);
-
+											 pDraw->x, pDraw->x + pDraw->width,
+										  pDraw->y, pDraw->y + pDraw->height);
 	if (pDraw->type == DRAWABLE_WINDOW) {
 		struct dri2_window_priv *priv = get_dri2_window_priv((WindowPtr)pDraw);
-
 		if (!crtc) {
 			crtc = priv->crtc;
 		} else if (priv->crtc && priv->crtc != crtc) {
 			CARD64 ust, mscold, mscnew;
-
 			if (amdgpu_dri2_get_crtc_msc(priv->crtc, &ust, &mscold) &&
-			    amdgpu_dri2_get_crtc_msc(crtc, &ust, &mscnew))
+				amdgpu_dri2_get_crtc_msc(crtc, &ust, &mscnew))
 				priv->vblank_delta += mscold - mscnew;
 		}
-
 		priv->crtc = crtc;
 	}
-
 	return crtc;
 }
 
 static void
-amdgpu_dri2_flip_event_abort(xf86CrtcPtr crtc, void *event_data)
+amdgpu_dri2_flip_event_abort_for_pageflip(xf86CrtcPtr crtc, void *event_data)
 {
-	if (crtc)
+	DRI2FrameEventPtr event = event_data;
+	if (likely(crtc))
 		AMDGPUPTR(crtc->scrn)->drmmode.dri2_flipping = FALSE;
 
-	free(event_data);
+	if (likely(event)) {
+		amdgpu_dri2_unref_buffer(event->front);
+		amdgpu_dri2_unref_buffer(event->back);
+		frame_event_free(event);
+	}
 }
 
 static void
-amdgpu_dri2_flip_event_handler(xf86CrtcPtr crtc, uint32_t frame, uint64_t usec,
-			       void *event_data)
+amdgpu_dri2_flip_event_handler(xf86CrtcPtr crtc, uint32_t frame,
+							   uint64_t usec, void *event_data)
 {
 	DRI2FrameEventPtr flip = event_data;
-	ScrnInfoPtr scrn = crtc->scrn;
-	unsigned tv_sec, tv_usec;
-	DrawablePtr drawable;
-	ScreenPtr screen;
-	int status;
-	PixmapPtr pixmap;
+	if (!flip) return;
 
-	status = dixLookupDrawable(&drawable, flip->drawable_id, serverClient,
-				   M_ANY, DixWriteAccess);
-	if (status != Success)
-		goto abort;
+	DrawablePtr drawable;
+	if (dixLookupDrawable(&drawable, flip->drawable_id, serverClient,
+		M_ANY, DixWriteAccess) != Success)
+		goto out;
 
 	frame += amdgpu_get_msc_delta(drawable, crtc);
-
-	screen = scrn->pScreen;
-	pixmap = screen->GetScreenPixmap(screen);
-	xf86DrvMsgVerb(scrn->scrnIndex, X_INFO, AMDGPU_LOGLEVEL_DEBUG,
-		       "%s:%d fevent[%p] width %d pitch %d (/4 %d)\n",
-		       __func__, __LINE__, flip, pixmap->drawable.width,
-		       pixmap->devKind, pixmap->devKind / 4);
-
-	tv_sec = usec / 1000000;
-	tv_usec = usec % 1000000;
-
-	/* We assume our flips arrive in order, so we don't check the frame */
-	switch (flip->type) {
-	case DRI2_SWAP:
-		/* Check for too small vblank count of pageflip completion, taking wraparound
-		 * into account. This usually means some defective kms pageflip completion,
-		 * causing wrong (msc, ust) return values and possible visual corruption.
-		 */
-		if ((frame < flip->frame) && (flip->frame - frame < 5)) {
-			xf86DrvMsg(scrn->scrnIndex, X_WARNING,
-				   "%s: Pageflip completion event has impossible msc %u < target_msc %u\n",
-				   __func__, frame, flip->frame);
-			/* All-Zero values signal failure of (msc, ust) timestamping to client. */
-			frame = tv_sec = tv_usec = 0;
-		}
-
-		DRI2SwapComplete(flip->client, drawable, frame, tv_sec, tv_usec,
-				 DRI2_FLIP_COMPLETE, flip->event_complete,
-				 flip->event_data);
-		break;
-	default:
-		xf86DrvMsg(scrn->scrnIndex, X_WARNING,
-			   "%s: unknown vblank event received\n", __func__);
-		/* Unknown type */
-		break;
-	}
-
-abort:
-	amdgpu_dri2_flip_event_abort(crtc, event_data);
+	DRI2SwapComplete(flip->client, drawable, frame,
+					 usec / 1000000, usec % 1000000,
+				  DRI2_FLIP_COMPLETE,
+				  flip->event_complete, flip->event_data);
+
+	out:
+	amdgpu_dri2_unref_buffer(flip->front);
+	amdgpu_dri2_unref_buffer(flip->back);
+	AMDGPUPTR(crtc->scrn)->drmmode.dri2_flipping = FALSE;
+	frame_event_free(flip);
 }
 
 static Bool
 amdgpu_dri2_schedule_flip(xf86CrtcPtr crtc, ClientPtr client,
-			  DrawablePtr draw, DRI2BufferPtr front,
-			  DRI2BufferPtr back, DRI2SwapEventPtr func,
-			  void *data, unsigned int target_msc)
+						  DrawablePtr draw, DRI2BufferPtr front,
+						  DRI2BufferPtr back, DRI2SwapEventPtr func,
+						  void *data, unsigned int target_msc)
 {
 	ScrnInfoPtr scrn = crtc->scrn;
 	AMDGPUInfoPtr info = AMDGPUPTR(scrn);
-	struct dri2_buffer_priv *back_priv;
-	DRI2FrameEventPtr flip_info;
+	struct dri2_buffer_priv *bp = back->driverPrivate;
 
-	flip_info = calloc(1, sizeof(DRI2FrameEventRec));
-	if (!flip_info)
+	if (!bp || !bp->pixmap)
 		return FALSE;
 
-	flip_info->drawable_id = draw->id;
-	flip_info->client = client;
-	flip_info->type = DRI2_SWAP;
-	flip_info->event_complete = func;
-	flip_info->event_data = data;
-	flip_info->frame = target_msc;
-	flip_info->crtc = crtc;
-
-	xf86DrvMsgVerb(scrn->scrnIndex, X_INFO, AMDGPU_LOGLEVEL_DEBUG,
-		       "%s:%d fevent[%p]\n", __func__, __LINE__, flip_info);
-
-	/* Page flip the full screen buffer */
-	back_priv = back->driverPrivate;
-	if (amdgpu_do_pageflip(scrn, client, back_priv->pixmap,
-			       AMDGPU_DRM_QUEUE_ID_DEFAULT, flip_info, crtc,
-			       amdgpu_dri2_flip_event_handler,
-			       amdgpu_dri2_flip_event_abort, FLIP_VSYNC,
-			       target_msc - amdgpu_get_msc_delta(draw, crtc))) {
+	DRI2FrameEventPtr ev = frame_event_alloc();
+	if (!ev) return FALSE;
+
+	ev->drawable_id    = draw->id;
+	ev->client         = client;
+	ev->type           = DRI2_SWAP;
+	ev->event_complete = func;
+	ev->event_data     = data;
+	ev->frame          = target_msc;
+	ev->crtc           = crtc;
+	ev->front          = front;
+	ev->back           = back;
+
+	if (amdgpu_do_pageflip(scrn, client, bp->pixmap,
+		AMDGPU_DRM_QUEUE_ID_DEFAULT, ev, crtc,
+		amdgpu_dri2_flip_event_handler,
+		amdgpu_dri2_flip_event_abort_for_pageflip,
+		FLIP_VSYNC,
+		target_msc - amdgpu_get_msc_delta(draw, crtc)))
+	{
 		info->drmmode.dri2_flipping = TRUE;
 		return TRUE;
 	}
-	return FALSE;
-}
-
-static Bool update_front(DrawablePtr draw, DRI2BufferPtr front)
-{
-	ScreenPtr screen = draw->pScreen;
-	ScrnInfoPtr scrn = xf86ScreenToScrn(screen);
-	AMDGPUEntPtr pAMDGPUEnt = AMDGPUEntPriv(scrn);
-	PixmapPtr pixmap = get_drawable_pixmap(draw);
-	struct dri2_buffer_priv *priv = front->driverPrivate;
 
-	if (!amdgpu_get_flink_name(pAMDGPUEnt, pixmap, &front->name))
-		return FALSE;
-
-	dixDestroyPixmap(priv->pixmap, 0);
-	front->pitch = pixmap->devKind;
-	front->cpp = pixmap->drawable.bitsPerPixel / 8;
-	priv->pixmap = pixmap;
-	pixmap->refcnt++;
-
-	return TRUE;
+	/* page-flip submission failed → clean up */
+	amdgpu_dri2_unref_buffer(front);
+	amdgpu_dri2_unref_buffer(back);
+	frame_event_free(ev);
+	return FALSE;
 }
 
 static Bool
 can_exchange(ScrnInfoPtr pScrn, DrawablePtr draw,
-	     DRI2BufferPtr front, DRI2BufferPtr back)
+			 DRI2BufferPtr front, DRI2BufferPtr back)
 {
-	struct dri2_buffer_priv *front_priv = front->driverPrivate;
-	struct dri2_buffer_priv *back_priv = back->driverPrivate;
-	PixmapPtr front_pixmap;
-	PixmapPtr back_pixmap = back_priv->pixmap;
-
-	if (!update_front(draw, front))
-		return FALSE;
-
-	front_pixmap = front_priv->pixmap;
-
-	if (front_pixmap->drawable.width != back_pixmap->drawable.width)
-		return FALSE;
-
-	if (front_pixmap->drawable.height != back_pixmap->drawable.height)
-		return FALSE;
+	struct dri2_buffer_priv *bp = back->driverPrivate;
 
-	if (front_pixmap->drawable.bitsPerPixel !=
-	    back_pixmap->drawable.bitsPerPixel)
+	if (!bp || !bp->pixmap)
 		return FALSE;
-
-	if (front_pixmap->devKind != back_pixmap->devKind)
+	if (!update_front(draw, front))
 		return FALSE;
 
-	return TRUE;
+	struct dri2_buffer_priv *fp = front->driverPrivate;
+	PixmapPtr fpx = fp->pixmap;
+	PixmapPtr bpx = bp->pixmap;
+
+	return fpx->drawable.width  == bpx->drawable.width  &&
+	fpx->drawable.height == bpx->drawable.height &&
+	fpx->drawable.bitsPerPixel == bpx->drawable.bitsPerPixel &&
+	fpx->devKind == bpx->devKind;
 }
 
 static Bool
 can_flip(xf86CrtcPtr crtc, DrawablePtr draw,
-	 DRI2BufferPtr front, DRI2BufferPtr back)
+		 DRI2BufferPtr front, DRI2BufferPtr back)
 {
 	ScrnInfoPtr pScrn = crtc->scrn;
 	AMDGPUInfoPtr info = AMDGPUPTR(pScrn);
 	xf86CrtcConfigPtr config = XF86_CRTC_CONFIG_PTR(pScrn);
-	int num_crtcs_on;
+	int num_crtcs_on = 0;
 	int i;
 
-	if (draw->type != DRAWABLE_WINDOW ||
-	    !info->allowPageFlip ||
-	    info->sprites_visible > 0 ||
-	    info->drmmode.present_flipping ||
-	    !pScrn->vtSema ||
-	    !DRI2CanFlip(draw))
+	if (unlikely(draw->type != DRAWABLE_WINDOW ||
+		!info->allowPageFlip || info->sprites_visible > 0 ||
+		info->drmmode.present_flipping || !pScrn->vtSema ||
+		!DRI2CanFlip(draw)))
 		return FALSE;
 
-	for (i = 0, num_crtcs_on = 0; i < config->num_crtc; i++) {
-		if (drmmode_crtc_can_flip(config->crtc[i]))
+	for (i = 0; i < config->num_crtc; i++) {
+		if (likely(config->crtc[i] != NULL && drmmode_crtc_can_flip(config->crtc[i])))
 			num_crtcs_on++;
 	}
-
-	return num_crtcs_on > 0 && can_exchange(pScrn, draw, front, back);
+	return likely(num_crtcs_on > 0 && can_exchange(pScrn, draw, front, back));
 }
 
 static void
 amdgpu_dri2_exchange_buffers(DrawablePtr draw, DRI2BufferPtr front,
-			     DRI2BufferPtr back)
+							 DRI2BufferPtr back)
 {
-	struct dri2_buffer_priv *front_priv = front->driverPrivate;
-	struct dri2_buffer_priv *back_priv = back->driverPrivate;
-	struct amdgpu_pixmap *front_pix;
-	struct amdgpu_pixmap *back_pix;
-	ScreenPtr screen;
-	AMDGPUInfoPtr info;
-	RegionRec region;
-	int tmp;
+	struct dri2_buffer_priv *fp = front->driverPrivate;
+	struct dri2_buffer_priv *bp = back->driverPrivate;
+	if (!fp || !bp || !fp->pixmap || !bp->pixmap)
+		return;
 
+	RegionRec region;
 	region.extents.x1 = region.extents.y1 = 0;
-	region.extents.x2 = front_priv->pixmap->drawable.width;
-	region.extents.y2 = front_priv->pixmap->drawable.height;
-	region.data = NULL;
-	DamageRegionAppend(&front_priv->pixmap->drawable, &region);
-
-	/* Swap BO names so DRI works */
-	tmp = front->name;
-	front->name = back->name;
-	back->name = tmp;
-
-	/* Swap pixmap privates */
-	front_pix = amdgpu_get_pixmap_private(front_priv->pixmap);
-	back_pix = amdgpu_get_pixmap_private(back_priv->pixmap);
-	amdgpu_set_pixmap_private(front_priv->pixmap, back_pix);
-	amdgpu_set_pixmap_private(back_priv->pixmap, front_pix);
-
-	/* Do we need to update the Screen? */
-	screen = draw->pScreen;
-	info = AMDGPUPTR(xf86ScreenToScrn(screen));
-	if (front_pix->bo == info->front_buffer) {
-		struct amdgpu_pixmap *screen_priv =
-			amdgpu_get_pixmap_private(screen->GetScreenPixmap(screen));
-
-		amdgpu_bo_ref(back_pix->bo);
+	region.extents.x2 = fp->pixmap->drawable.width;
+	region.extents.y2 = fp->pixmap->drawable.height;
+	region.data       = NULL;
+	DamageRegionAppend(&fp->pixmap->drawable, &region);
+
+	uint32_t tmp = front->name;
+	front->name   = back->name;
+	back->name    = tmp;
+
+	struct amdgpu_pixmap *fpx = amdgpu_get_pixmap_private(fp->pixmap);
+	struct amdgpu_pixmap *bpx = amdgpu_get_pixmap_private(bp->pixmap);
+	amdgpu_set_pixmap_private(fp->pixmap, bpx);
+	amdgpu_set_pixmap_private(bp->pixmap, fpx);
+
+	ScreenPtr      s    = draw->pScreen;
+	AMDGPUInfoPtr  info = AMDGPUPTR(xf86ScreenToScrn(s));
+	if (fpx && fpx->bo == info->front_buffer && bpx && bpx->bo) {
+		struct amdgpu_pixmap *scrpriv =
+		amdgpu_get_pixmap_private(s->GetScreenPixmap(s));
+		amdgpu_bo_ref(bpx->bo);
 		amdgpu_bo_unref(&info->front_buffer);
-		info->front_buffer = back_pix->bo;
-		*screen_priv = *back_pix;
+		info->front_buffer = bpx->bo;
+		if (scrpriv) *scrpriv = *bpx;
 	}
 
-	amdgpu_glamor_exchange_buffers(front_priv->pixmap, back_priv->pixmap);
-
-	DamageRegionProcessPending(&front_priv->pixmap->drawable);
+	amdgpu_glamor_exchange_buffers(fp->pixmap, bp->pixmap);
+	DamageRegionProcessPending(&fp->pixmap->drawable);
 }
 
-static void amdgpu_dri2_frame_event_abort(xf86CrtcPtr crtc, void *event_data)
-{
-	DRI2FrameEventPtr event = event_data;
-
-	TimerCancel(event->timer);
-	TimerFree(event->timer);
-	amdgpu_dri2_unref_buffer(event->front);
-	amdgpu_dri2_unref_buffer(event->back);
-	free(event);
-}
 
 static void amdgpu_dri2_frame_event_handler(xf86CrtcPtr crtc, uint32_t seq,
-					    uint64_t usec, void *event_data)
+											uint64_t usec, void *event_data)
 {
 	DRI2FrameEventPtr event = event_data;
-	ScrnInfoPtr scrn = crtc->scrn;
+	ScrnInfoPtr scrn;
 	DrawablePtr drawable;
 	int status;
 	int swap_type;
 	BoxRec box;
-	RegionRec region;
+	RegionRec local_region_obj;
 
-	status = dixLookupDrawable(&drawable, event->drawable_id, serverClient,
-				   M_ANY, DixWriteAccess);
-	if (status != Success)
-		goto cleanup;
+	if (unlikely(!event)) return;
+	scrn = crtc->scrn;
+
+	status = dixLookupDrawable(&drawable, event->drawable_id, serverClient, M_ANY, DixWriteAccess);
+	if (unlikely(status != Success))
+		goto cleanup_event;
 
 	seq += amdgpu_get_msc_delta(drawable, crtc);
 
 	switch (event->type) {
-	case DRI2_FLIP:
-		if (can_flip(crtc, drawable, event->front, event->back) &&
-		    amdgpu_dri2_schedule_flip(crtc,
-					      event->client,
-					      drawable,
-					      event->front,
-					      event->back,
-					      event->event_complete,
-					      event->event_data,
-					      event->frame)) {
-			amdgpu_dri2_exchange_buffers(drawable, event->front,
-						     event->back);
+		case DRI2_FLIP:
+			if (likely(can_flip(crtc, drawable, event->front, event->back) &&
+				amdgpu_dri2_schedule_flip(crtc, event->client, drawable,
+										  event->front, event->back,
+							  event->event_complete, event->event_data, event->frame))) {
+				amdgpu_dri2_exchange_buffers(drawable, event->front, event->back);
 			break;
-		}
-		/* else fall through to exchange/blit */
-	case DRI2_SWAP:
-		if (DRI2CanExchange(drawable) &&
-		    can_exchange(scrn, drawable, event->front, event->back)) {
-			amdgpu_dri2_exchange_buffers(drawable, event->front,
-						     event->back);
+							  }
+		case DRI2_SWAP:
+			if (likely(DRI2CanExchange(drawable) &&
+				can_exchange(scrn, drawable, event->front, event->back))) {
+				amdgpu_dri2_exchange_buffers(drawable, event->front, event->back);
 			swap_type = DRI2_EXCHANGE_COMPLETE;
-		} else {
-			box.x1 = 0;
-			box.y1 = 0;
-			box.x2 = drawable->width;
-			box.y2 = drawable->height;
-			REGION_INIT(pScreen, &region, &box, 0);
-			amdgpu_dri2_copy_region2(drawable->pScreen, drawable, &region,
-						 event->front, event->back);
-			swap_type = DRI2_BLIT_COMPLETE;
-		}
-
-		DRI2SwapComplete(event->client, drawable, seq, usec / 1000000,
-				 usec % 1000000, swap_type, event->event_complete,
-				 event->event_data);
-
-		break;
-	case DRI2_WAITMSC:
-		DRI2WaitMSCComplete(event->client, drawable, seq, usec / 1000000,
-				    usec % 1000000);
-		break;
-	default:
-		/* Unknown type */
-		xf86DrvMsg(scrn->scrnIndex, X_WARNING,
-			   "%s: unknown vblank event received\n", __func__);
-		break;
+				} else {
+					box.x1 = 0; box.y1 = 0; box.x2 = drawable->width; box.y2 = drawable->height;
+					RegionInit(&local_region_obj, &box, 0);
+					amdgpu_dri2_copy_region2(drawable->pScreen, drawable, &local_region_obj,
+											 event->front, event->back);
+					RegionUninit(&local_region_obj);
+					swap_type = DRI2_BLIT_COMPLETE;
+				}
+				DRI2SwapComplete(event->client, drawable, seq, usec / 1000000,
+								 usec % 1000000, swap_type, event->event_complete, event->event_data);
+				break;
+		case DRI2_WAITMSC:
+			DRI2WaitMSCComplete(event->client, drawable, seq, usec / 1000000, usec % 1000000);
+			break;
+		default:
+			xf86DrvMsg(scrn->scrnIndex, X_WARNING, "%s: unknown vblank event received\n", __func__);
+			break;
 	}
 
-cleanup:
+	cleanup_event:
 	amdgpu_dri2_frame_event_abort(crtc, event_data);
 }
 
-/*
- * This function should be called on a disabled CRTC only (i.e., CRTC
- * in DPMS-off state). It will calculate the delay necessary to reach
- * target_msc from present time if the CRTC were running.
- */
-static
-CARD32 amdgpu_dri2_extrapolate_msc_delay(xf86CrtcPtr crtc, CARD64 * target_msc,
-					 CARD64 divisor, CARD64 remainder)
+static CARD32 amdgpu_dri2_extrapolate_msc_delay(xf86CrtcPtr crtc, CARD64 *target_msc,
+												CARD64 divisor, CARD64 remainder)
 {
 	drmmode_crtc_private_ptr drmmode_crtc = crtc->driver_private;
 	ScrnInfoPtr pScrn = crtc->scrn;
 	AMDGPUEntPtr pAMDGPUEnt = AMDGPUEntPriv(pScrn);
-	int nominal_frame_rate = drmmode_crtc->dpms_last_fps;
 	CARD64 last_vblank_ust = drmmode_crtc->dpms_last_ust;
 	uint32_t last_vblank_seq = drmmode_crtc->dpms_last_seq;
-	CARD64 now, target_time, delta_t;
-	int64_t d, delta_seq;
+	CARD64 now, target_time_calc, delta_t_calc;
+	int64_t d, delta_seq_calc_signed;
 	int ret;
 	CARD32 d_ms;
+	uint64_t fps_recip = 0;
+	int nominal_frame_rate = drmmode_crtc->dpms_last_fps;
 
-	if (!last_vblank_ust) {
-		*target_msc = 0;
-		return FALLBACK_SWAP_DELAY;
+	if (unlikely(!last_vblank_ust)) { *target_msc = 0; return FALLBACK_SWAP_DELAY; }
+	if (unlikely(nominal_frame_rate == 0)) {
+		xf86DrvMsg(pScrn->scrnIndex, X_WARNING, "%s: nominal_frame_rate is zero.\n", __func__);
+		*target_msc = 0; return FALLBACK_SWAP_DELAY;
 	}
+	fps_recip = (1ULL << 32) / nominal_frame_rate;
+
 	ret = drmmode_get_current_ust(pAMDGPUEnt->fd, &now);
-	if (ret) {
-		xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
-			   "%s cannot get current time\n", __func__);
-		*target_msc = 0;
-		return FALLBACK_SWAP_DELAY;
-	}
-	delta_seq = *target_msc - last_vblank_seq;
-	delta_seq *= 1000000;
-	target_time = last_vblank_ust;
-	target_time += delta_seq / nominal_frame_rate;
-	d = target_time - now;
+	if (unlikely(ret)) {
+		xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "%s: cannot get current time\n", __func__);
+		*target_msc = 0; return FALLBACK_SWAP_DELAY;
+	}
+
+	delta_seq_calc_signed = (int64_t)*target_msc - last_vblank_seq;
+	delta_seq_calc_signed *= 1000000;
+	target_time_calc = last_vblank_ust;
+	target_time_calc += delta_seq_calc_signed / nominal_frame_rate;
+	d = target_time_calc - now;
+
 	if (d < 0) {
-		/* we missed the event, adjust target_msc, do the divisor magic */
 		CARD64 current_msc = last_vblank_seq;
-
-		delta_t = now - last_vblank_ust;
-		delta_seq = delta_t * nominal_frame_rate;
-		current_msc += delta_seq / 1000000;
+		delta_t_calc = now - last_vblank_ust;
+		delta_seq_calc_signed = (delta_t_calc * fps_recip) >> 32;
+		current_msc += delta_seq_calc_signed;
 		current_msc &= 0xffffffff;
 		if (divisor == 0) {
-			*target_msc = current_msc;
-			d = 0;
+			*target_msc = current_msc; d = 0;
 		} else {
-			*target_msc =
-			    current_msc - (current_msc % divisor) + remainder;
-			if ((current_msc % divisor) >= remainder)
-				*target_msc += divisor;
+			*target_msc = current_msc - (current_msc % divisor) + remainder;
+			if ((current_msc % divisor) >= remainder) *target_msc += divisor;
 			*target_msc &= 0xffffffff;
-			delta_seq = *target_msc - last_vblank_seq;
-			delta_seq *= 1000000;
-			target_time = last_vblank_ust;
-			target_time += delta_seq / nominal_frame_rate;
-			d = target_time - now;
+			delta_seq_calc_signed = (int64_t)*target_msc - last_vblank_seq;
+			delta_seq_calc_signed *= 1000000;
+			target_time_calc = last_vblank_ust;
+			target_time_calc += delta_seq_calc_signed / nominal_frame_rate;
+			d = target_time_calc - now;
 		}
 	}
-	/*
-	 * convert delay to milliseconds and add margin to prevent the client
-	 * from coming back early (due to timer granularity and rounding
-	 * errors) and getting the same MSC it just got
-	 */
 	d_ms = (CARD32) d / 1000;
-	if ((CARD32) d - d_ms * 1000 > 0)
-		d_ms += 2;
-	else
-		d_ms++;
+	if ((CARD32) d - d_ms * 1000 > 0) d_ms += 2; else d_ms++;
 	return d_ms;
 }
 
-/*
- * Get current interpolated frame count and frame count timestamp, based on
- * drawable's crtc.
- */
-static int amdgpu_dri2_get_msc(DrawablePtr draw, CARD64 * ust, CARD64 * msc)
+static int amdgpu_dri2_get_msc(DrawablePtr draw, CARD64 *ust, CARD64 *msc)
 {
 	xf86CrtcPtr crtc = amdgpu_dri2_drawable_crtc(draw);
-
-	/* Drawable not displayed, make up a value */
-	if (!crtc) {
-		*ust = 0;
-		*msc = 0;
-		return TRUE;
-	}
-
-	if (!amdgpu_dri2_get_crtc_msc(crtc, ust, msc))
-		return FALSE;
-
+	if (unlikely(!crtc)) { *ust = 0; *msc = 0; return TRUE; }
+	if (unlikely(!amdgpu_dri2_get_crtc_msc(crtc, ust, msc))) return FALSE;
 	if (draw && draw->type == DRAWABLE_WINDOW)
 		*msc += get_dri2_window_priv((WindowPtr)draw)->vblank_delta;
 	*msc &= 0xffffffff;
 	return TRUE;
 }
 
-static
-CARD32 amdgpu_dri2_deferred_event(OsTimerPtr timer, CARD32 now, pointer data)
+static CARD32 amdgpu_dri2_deferred_event(OsTimerPtr timer, CARD32 now_timer, pointer data)
 {
 	DRI2FrameEventPtr event_info = (DRI2FrameEventPtr) data;
-	xf86CrtcPtr crtc = event_info->crtc;
+	xf86CrtcPtr crtc;
 	ScrnInfoPtr scrn;
 	AMDGPUEntPtr pAMDGPUEnt;
 	CARD64 drm_now;
 	int ret;
-	CARD64 delta_t, delta_seq, frame;
-	drmmode_crtc_private_ptr drmmode_crtc;
-
-	/*
-	 * This is emulated event, so its time is current time, which we
-	 * have to get in DRM-compatible form (which is a bit messy given
-	 * the information that we have at this point). Can't use now argument
-	 * because DRM event time may come from monotonic clock, while
-	 * DIX timer facility uses real-time clock.
-	 */
-	if (!event_info->crtc) {
-		ErrorF("%s no crtc\n", __func__);
-		if (event_info->drm_queue_seq)
-			amdgpu_drm_abort_entry(event_info->drm_queue_seq);
-		else
-			amdgpu_dri2_frame_event_abort(NULL, data);
+	CARD64 delta_t_calc, frame_val;
+	int64_t delta_seq_calc_signed;
+	drmmode_crtc_private_ptr drmmode_crtc_priv;
+	uint64_t fps_recip = 0;
+
+	if (unlikely(!event_info)) return 0;
+	crtc = event_info->crtc;
+
+	if (unlikely(!crtc)) {
+		ErrorF("%s: no crtc\n", __func__);
+		if (event_info->drm_queue_seq) amdgpu_drm_abort_entry(event_info->drm_queue_seq);
+		else amdgpu_dri2_frame_event_abort(NULL, data);
 		return 0;
 	}
-
 	scrn = crtc->scrn;
 	pAMDGPUEnt = AMDGPUEntPriv(scrn);
-	drmmode_crtc = event_info->crtc->driver_private;
-	ret = drmmode_get_current_ust(pAMDGPUEnt->fd, &drm_now);
-	if (ret) {
-		xf86DrvMsg(scrn->scrnIndex, X_ERROR,
-			   "%s cannot get current time\n", __func__);
+	drmmode_crtc_priv = crtc->driver_private;
 
+	ret = drmmode_get_current_ust(pAMDGPUEnt->fd, &drm_now);
+	if (unlikely(ret)) {
+		xf86DrvMsg(scrn->scrnIndex, X_ERROR, "%s: cannot get current time\n", __func__);
 		if (event_info->drm_queue_seq) {
-			drmmode_crtc->drmmode->event_context.
-				vblank_handler(pAMDGPUEnt->fd, 0, 0, 0,
-					       (void*)event_info->drm_queue_seq);
-			drmmode_crtc->wait_flip_nesting_level++;
+			drmmode_crtc_priv->drmmode->event_context.vblank_handler(pAMDGPUEnt->fd, 0, 0, 0, (void*)event_info->drm_queue_seq);
+			drmmode_crtc_priv->wait_flip_nesting_level++;
 			amdgpu_drm_queue_handle_deferred(crtc);
-
 		} else {
 			amdgpu_dri2_frame_event_handler(crtc, 0, 0, data);
 		}
-
 		return 0;
 	}
-	/*
-	 * calculate the frame number from current time
-	 * that would come from CRTC if it were running
-	 */
-	delta_t = drm_now - (CARD64) drmmode_crtc->dpms_last_ust;
-	delta_seq = delta_t * drmmode_crtc->dpms_last_fps;
-	delta_seq /= 1000000;
-	frame = (CARD64) drmmode_crtc->dpms_last_seq + delta_seq;
+
+	if (unlikely(drmmode_crtc_priv->dpms_last_fps == 0)) {
+		xf86DrvMsg(scrn->scrnIndex, X_WARNING, "%s: dpms_last_fps is zero.\n", __func__);
+		frame_val = (CARD64) drmmode_crtc_priv->dpms_last_seq;
+	} else {
+		fps_recip = (1ULL << 32) / drmmode_crtc_priv->dpms_last_fps;
+		delta_t_calc = drm_now - (CARD64) drmmode_crtc_priv->dpms_last_ust;
+		delta_seq_calc_signed = (delta_t_calc * fps_recip) >> 32;
+		frame_val = (CARD64) drmmode_crtc_priv->dpms_last_seq + delta_seq_calc_signed;
+	}
 
 	if (event_info->drm_queue_seq) {
-		drmmode_crtc->drmmode->event_context.
-			vblank_handler(pAMDGPUEnt->fd, frame, drm_now / 1000000,
-				       drm_now % 1000000,
-				       (void*)event_info->drm_queue_seq);
-		drmmode_crtc->wait_flip_nesting_level++;
+		drmmode_crtc_priv->drmmode->event_context.vblank_handler(pAMDGPUEnt->fd, frame_val, drm_now / 1000000,
+																 drm_now % 1000000, (void*)event_info->drm_queue_seq);
+		drmmode_crtc_priv->wait_flip_nesting_level++;
 		amdgpu_drm_queue_handle_deferred(crtc);
 	} else {
-		amdgpu_dri2_frame_event_handler(crtc, frame, drm_now, data);
+		amdgpu_dri2_frame_event_handler(crtc, frame_val, drm_now, data);
 	}
-
 	return 0;
 }
 
-static
-void amdgpu_dri2_schedule_event(CARD32 delay, DRI2FrameEventPtr event_info)
+static void amdgpu_dri2_schedule_event(CARD32 delay, DRI2FrameEventPtr event_info)
 {
-	event_info->timer = TimerSet(NULL, 0, delay, amdgpu_dri2_deferred_event,
-				     event_info);
+	event_info->timer = TimerSet(NULL, 0, delay, amdgpu_dri2_deferred_event, event_info);
 	if (delay == 0) {
-		CARD32 now = GetTimeInMillis();
-		amdgpu_dri2_deferred_event(event_info->timer, now, event_info);
+		CARD32 current_time_ms = GetTimeInMillis();
+		amdgpu_dri2_deferred_event(event_info->timer, current_time_ms, event_info);
 	}
 }
 
-/*
- * Request a DRM event when the requested conditions will be satisfied.
- *
- * We need to handle the event and ask the server to wake up the client when
- * we receive it.
- */
 static int amdgpu_dri2_schedule_wait_msc(ClientPtr client, DrawablePtr draw,
-					 CARD64 target_msc, CARD64 divisor,
-					 CARD64 remainder)
+										 CARD64 target_msc_in, CARD64 divisor_in,
+										 CARD64 remainder_in)
 {
 	ScreenPtr screen = draw->pScreen;
 	ScrnInfoPtr scrn = xf86ScreenToScrn(screen);
@@ -951,149 +908,69 @@ static int amdgpu_dri2_schedule_wait_msc
 	uint32_t msc_delta;
 	uint32_t seq;
 	CARD64 current_msc;
+	CARD64 target_msc = target_msc_in;
+	CARD64 divisor = divisor_in;
+	CARD64 remainder = remainder_in;
 
-	/* Truncate to match kernel interfaces; means occasional overflow
-	 * misses, but that's generally not a big deal */
-	target_msc &= 0xffffffff;
-	divisor &= 0xffffffff;
-	remainder &= 0xffffffff;
-
-	/* Drawable not visible, return immediately */
-	if (!crtc)
-		goto out_complete;
+	target_msc &= 0xffffffff; divisor &= 0xffffffff; remainder &= 0xffffffff;
 
+	if (unlikely(!crtc)) goto out_complete_no_alloc;
 	msc_delta = amdgpu_get_msc_delta(draw, crtc);
+	wait_info = frame_event_alloc();
+	if (unlikely(!wait_info)) goto out_complete_no_alloc;
+
+	wait_info->drawable_id = draw->id; wait_info->client = client;
+	wait_info->type = DRI2_WAITMSC; wait_info->crtc = crtc;
 
-	wait_info = calloc(1, sizeof(DRI2FrameEventRec));
-	if (!wait_info)
-		goto out_complete;
-
-	wait_info->drawable_id = draw->id;
-	wait_info->client = client;
-	wait_info->type = DRI2_WAITMSC;
-	wait_info->crtc = crtc;
-
-	/*
-	 * CRTC is in DPMS off state, calculate wait time from current time,
-	 * target_msc and last vblank time/sequence when CRTC was turned off
-	 */
-	if (!amdgpu_crtc_is_enabled(crtc)) {
-		CARD32 delay;
-		target_msc -= msc_delta;
-		delay = amdgpu_dri2_extrapolate_msc_delay(crtc, &target_msc,
-							  divisor, remainder);
+	if (unlikely(!amdgpu_crtc_is_enabled(crtc))) {
+		CARD32 delay; target_msc -= msc_delta;
+		delay = amdgpu_dri2_extrapolate_msc_delay(crtc, &target_msc, divisor, remainder);
 		amdgpu_dri2_schedule_event(delay, wait_info);
-		DRI2BlockClient(client, draw);
-		return TRUE;
+		DRI2BlockClient(client, draw); return TRUE;
 	}
-
-	/* Get current count */
-	if (!drmmode_wait_vblank(crtc, DRM_VBLANK_RELATIVE, 0, 0, NULL, &seq)) {
-		xf86DrvMsg(scrn->scrnIndex, X_WARNING,
-			   "get vblank counter failed: %s\n", strerror(errno));
-		goto out_complete;
+	if (unlikely(!drmmode_wait_vblank(crtc, DRM_VBLANK_RELATIVE, 0, 0, NULL, &seq))) {
+		xf86DrvMsg(scrn->scrnIndex, X_WARNING, "get vblank counter failed: %s\n", strerror(errno));
+		goto out_complete_with_alloc;
 	}
-
-	current_msc = seq + msc_delta;
-	current_msc &= 0xffffffff;
-
+	current_msc = seq + msc_delta; current_msc &= 0xffffffff;
 	drm_queue_seq = amdgpu_drm_queue_alloc(crtc, client, AMDGPU_DRM_QUEUE_ID_DEFAULT,
-					       wait_info, amdgpu_dri2_frame_event_handler,
-					       amdgpu_dri2_frame_event_abort, FALSE);
-	if (drm_queue_seq == AMDGPU_DRM_QUEUE_ERROR) {
-		xf86DrvMsg(scrn->scrnIndex, X_WARNING,
-			   "Allocating DRM queue event entry failed.\n");
-		goto out_complete;
+										   wait_info, amdgpu_dri2_frame_event_handler,
+										amdgpu_dri2_frame_event_abort, FALSE);
+	if (unlikely(drm_queue_seq == AMDGPU_DRM_QUEUE_ERROR)) {
+		xf86DrvMsg(scrn->scrnIndex, X_WARNING, "Allocating DRM queue event entry failed.\n");
+		goto out_complete_with_alloc;
 	}
 	wait_info->drm_queue_seq = drm_queue_seq;
 
-	/*
-	 * If divisor is zero, or current_msc is smaller than target_msc,
-	 * we just need to make sure target_msc passes  before waking up the
-	 * client.
-	 */
 	if (divisor == 0 || current_msc < target_msc) {
-		/* If target_msc already reached or passed, set it to
-		 * current_msc to ensure we return a reasonable value back
-		 * to the caller. This keeps the client from continually
-		 * sending us MSC targets from the past by forcibly updating
-		 * their count on this call.
-		 */
-		if (current_msc >= target_msc)
-			target_msc = current_msc;
-		if (!drmmode_wait_vblank(crtc, DRM_VBLANK_ABSOLUTE | DRM_VBLANK_EVENT,
-					 target_msc - msc_delta, drm_queue_seq, NULL,
-					 NULL)) {
-			xf86DrvMsg(scrn->scrnIndex, X_WARNING,
-				   "get vblank counter failed: %s\n",
-				   strerror(errno));
-			goto out_complete;
-		}
-
-		DRI2BlockClient(client, draw);
-		return TRUE;
+		if (current_msc >= target_msc) target_msc = current_msc;
+		if (unlikely(!drmmode_wait_vblank(crtc, DRM_VBLANK_ABSOLUTE | DRM_VBLANK_EVENT,
+			target_msc - msc_delta, drm_queue_seq, NULL, NULL))) {
+			xf86DrvMsg(scrn->scrnIndex, X_WARNING, "get vblank counter failed: %s\n", strerror(errno));
+		amdgpu_drm_abort_entry(drm_queue_seq); wait_info = NULL; goto out_complete_no_alloc;
+			}
+			DRI2BlockClient(client, draw); return TRUE;
 	}
-
-	/*
-	 * If we get here, target_msc has already passed or we don't have one,
-	 * so we queue an event that will satisfy the divisor/remainder equation.
-	 */
 	target_msc = current_msc - (current_msc % divisor) + remainder - msc_delta;
+	if ((current_msc % divisor) >= remainder) target_msc += divisor;
+	if (unlikely(!drmmode_wait_vblank(crtc, DRM_VBLANK_ABSOLUTE | DRM_VBLANK_EVENT,
+		target_msc, drm_queue_seq, NULL, NULL))) {
+		xf86DrvMsg(scrn->scrnIndex, X_WARNING, "get vblank counter failed: %s\n", strerror(errno));
+	amdgpu_drm_abort_entry(drm_queue_seq); wait_info = NULL; goto out_complete_no_alloc;
+		}
+		DRI2BlockClient(client, draw); return TRUE;
 
-	/*
-	 * If calculated remainder is larger than requested remainder,
-	 * it means we've passed the last point where
-	 * seq % divisor == remainder, so we need to wait for the next time
-	 * that will happen.
-	 */
-	if ((current_msc % divisor) >= remainder)
-		target_msc += divisor;
-
-	if (!drmmode_wait_vblank(crtc, DRM_VBLANK_ABSOLUTE | DRM_VBLANK_EVENT,
-				 target_msc, drm_queue_seq, NULL, NULL)) {
-		xf86DrvMsg(scrn->scrnIndex, X_WARNING,
-			   "get vblank counter failed: %s\n", strerror(errno));
-		goto out_complete;
-	}
-
-	DRI2BlockClient(client, draw);
-
-	return TRUE;
-
-out_complete:
-	if (wait_info)
-		amdgpu_dri2_deferred_event(NULL, 0, wait_info);
-	else
-		DRI2WaitMSCComplete(client, draw, 0, 0, 0);
-
-	return TRUE;
+		out_complete_with_alloc:
+		if (wait_info) amdgpu_dri2_deferred_event(NULL, 0, wait_info); return TRUE;
+		out_complete_no_alloc:
+		if (!wait_info) DRI2WaitMSCComplete(client, draw, 0, 0, 0);
+		return TRUE;
 }
 
-/*
- * ScheduleSwap is responsible for requesting a DRM vblank event for the
- * appropriate frame.
- *
- * In the case of a blit (e.g. for a windowed swap) or buffer exchange,
- * the vblank requested can simply be the last queued swap frame + the swap
- * interval for the drawable.
- *
- * In the case of a page flip, we request an event for the last queued swap
- * frame + swap interval - 1, since we'll need to queue the flip for the frame
- * immediately following the received event.
- *
- * The client will be blocked if it tries to perform further GL commands
- * after queueing a swap, though in the Intel case after queueing a flip, the
- * client is free to queue more commands; they'll block in the kernel if
- * they access buffers busy with the flip.
- *
- * When the swap is complete, the driver should call into the server so it
- * can send any swap complete events that have been requested.
- */
 static int amdgpu_dri2_schedule_swap(ClientPtr client, DrawablePtr draw,
-				     DRI2BufferPtr front, DRI2BufferPtr back,
-				     CARD64 * target_msc, CARD64 divisor,
-				     CARD64 remainder, DRI2SwapEventPtr func,
-				     void *data)
+									 DRI2BufferPtr front, DRI2BufferPtr back,
+									 CARD64 *target_msc_inout, CARD64 divisor_in,
+									 CARD64 remainder_in, DRI2SwapEventPtr func, void *data)
 {
 	ScreenPtr screen = draw->pScreen;
 	ScrnInfoPtr scrn = xf86ScreenToScrn(screen);
@@ -1103,192 +980,82 @@ static int amdgpu_dri2_schedule_swap(Cli
 	uint32_t seq;
 	int flip = 0;
 	DRI2FrameEventPtr swap_info = NULL;
-	uintptr_t drm_queue_seq;
+	uintptr_t drm_queue_seq = 0;
 	CARD64 current_msc, event_msc;
 	BoxRec box;
-	RegionRec region;
+	RegionRec local_region_obj;
+	CARD64 target_msc_local = *target_msc_inout;
+	CARD64 divisor = divisor_in;
+	CARD64 remainder = remainder_in;
 
-	/* Truncate to match kernel interfaces; means occasional overflow
-	 * misses, but that's generally not a big deal */
-	*target_msc &= 0xffffffff;
-	divisor &= 0xffffffff;
-	remainder &= 0xffffffff;
-
-	/* amdgpu_dri2_frame_event_handler will get called some unknown time in the
-	 * future with these buffers.  Take a reference to ensure that they won't
-	 * get destroyed before then.
-	 */
-	amdgpu_dri2_ref_buffer(front);
-	amdgpu_dri2_ref_buffer(back);
-
-	/* either off-screen or CRTC not usable... just complete the swap */
-	if (!crtc)
-		goto blit_fallback;
+	target_msc_local &= 0xffffffff; divisor &= 0xffffffff; remainder &= 0xffffffff;
+	amdgpu_dri2_ref_buffer(front); amdgpu_dri2_ref_buffer(back);
 
+	if (unlikely(!crtc)) goto blit_fallback_no_alloc;
 	msc_delta = amdgpu_get_msc_delta(draw, crtc);
+	swap_info = frame_event_alloc();
+	if (unlikely(!swap_info)) goto blit_fallback_no_alloc;
 
-	swap_info = calloc(1, sizeof(DRI2FrameEventRec));
-	if (!swap_info)
-		goto blit_fallback;
-
-	swap_info->type = DRI2_SWAP;
-	swap_info->drawable_id = draw->id;
-	swap_info->client = client;
-	swap_info->event_complete = func;
-	swap_info->event_data = data;
-	swap_info->front = front;
-	swap_info->back = back;
-	swap_info->crtc = crtc;
+	swap_info->type=DRI2_SWAP; swap_info->drawable_id=draw->id; swap_info->client=client;
+	swap_info->event_complete=func; swap_info->event_data=data; swap_info->front=front;
+	swap_info->back=back; swap_info->crtc=crtc;
 
 	drm_queue_seq = amdgpu_drm_queue_alloc(crtc, client, AMDGPU_DRM_QUEUE_ID_DEFAULT,
-					       swap_info, amdgpu_dri2_frame_event_handler,
-					       amdgpu_dri2_frame_event_abort, FALSE);
-	if (drm_queue_seq == AMDGPU_DRM_QUEUE_ERROR) {
-		xf86DrvMsg(scrn->scrnIndex, X_WARNING,
-			   "Allocating DRM queue entry failed.\n");
-		goto blit_fallback;
+										   swap_info, amdgpu_dri2_frame_event_handler,
+										amdgpu_dri2_frame_event_abort, FALSE);
+	if (unlikely(drm_queue_seq == AMDGPU_DRM_QUEUE_ERROR)) {
+		xf86DrvMsg(scrn->scrnIndex, X_WARNING, "Allocating DRM queue event entry failed.\n");
+		goto blit_fallback_with_alloc;
 	}
 	swap_info->drm_queue_seq = drm_queue_seq;
 
-	/*
-	 * CRTC is in DPMS off state, fallback to blit, but calculate
-	 * wait time from current time, target_msc and last vblank
-	 * time/sequence when CRTC was turned off
-	 */
-	if (!amdgpu_crtc_is_enabled(crtc)) {
-		CARD32 delay;
-		*target_msc -= msc_delta;
-		delay = amdgpu_dri2_extrapolate_msc_delay(crtc, target_msc,
-							  divisor, remainder);
-		*target_msc += msc_delta;
-		*target_msc &= 0xffffffff;
+	if (unlikely(!amdgpu_crtc_is_enabled(crtc))) {
+		CARD32 delay; target_msc_local -= msc_delta;
+		delay = amdgpu_dri2_extrapolate_msc_delay(crtc, &target_msc_local, divisor, remainder);
+		target_msc_local += msc_delta; target_msc_local &= 0xffffffff;
 		amdgpu_dri2_schedule_event(delay, swap_info);
-		return TRUE;
+		*target_msc_inout = target_msc_local; return TRUE;
 	}
-
-	/* Get current count */
-	if (!drmmode_wait_vblank(crtc, DRM_VBLANK_RELATIVE, 0, 0, NULL, &seq)) {
-		xf86DrvMsg(scrn->scrnIndex, X_WARNING,
-			   "first get vblank counter failed: %s\n",
-			   strerror(errno));
-		goto blit_fallback;
-	}
-
-	current_msc = seq + msc_delta;
-	current_msc &= 0xffffffff;
-
-	/* Flips need to be submitted one frame before */
-	if (can_flip(crtc, draw, front, back)) {
-		swap_info->type = DRI2_FLIP;
-		flip = 1;
-	}
-
-	/* Correct target_msc by 'flip' if swap_info->type == DRI2_FLIP.
-	 * Do it early, so handling of different timing constraints
-	 * for divisor, remainder and msc vs. target_msc works.
-	 */
-	if (*target_msc > 0)
-		*target_msc -= flip;
-
-	/*
-	 * If divisor is zero, or current_msc is smaller than target_msc
-	 * we just need to make sure target_msc passes before initiating
-	 * the swap.
-	 */
-	if (divisor == 0 || current_msc < *target_msc) {
-		type = DRM_VBLANK_ABSOLUTE | DRM_VBLANK_EVENT;
-		/* If non-pageflipping, but blitting/exchanging, we need to use
-		 * DRM_VBLANK_NEXTONMISS to avoid unreliable timestamping later
-		 * on.
-		 */
-		if (flip == 0)
-			type |= DRM_VBLANK_NEXTONMISS;
-
-		/* If target_msc already reached or passed, set it to
-		 * current_msc to ensure we return a reasonable value back
-		 * to the caller. This makes swap_interval logic more robust.
-		 */
-		if (current_msc >= *target_msc)
-			*target_msc = current_msc;
-
-		if (!drmmode_wait_vblank(crtc, type, *target_msc - msc_delta,
-					 drm_queue_seq, NULL, &seq)) {
-			xf86DrvMsg(scrn->scrnIndex, X_WARNING,
-				   "divisor 0 get vblank counter failed: %s\n",
-				   strerror(errno));
-			goto blit_fallback;
+	if (unlikely(!drmmode_wait_vblank(crtc, DRM_VBLANK_RELATIVE,0,0,NULL,&seq))) {
+		xf86DrvMsg(scrn->scrnIndex,X_WARNING,"first get vblank counter failed: %s\n",strerror(errno));
+		amdgpu_drm_abort_entry(drm_queue_seq); swap_info=NULL; goto blit_fallback_no_alloc;
+	}
+	current_msc = seq + msc_delta; current_msc &= 0xffffffff;
+	if (likely(can_flip(crtc, draw, front, back))) { swap_info->type=DRI2_FLIP; flip=1; }
+	if (target_msc_local > 0) target_msc_local -= flip;
+
+	if (divisor == 0 || current_msc < target_msc_local) {
+		type = DRM_VBLANK_ABSOLUTE|DRM_VBLANK_EVENT; if(flip==0)type|=DRM_VBLANK_NEXTONMISS;
+		if(current_msc>=target_msc_local)target_msc_local=current_msc;
+		if(unlikely(!drmmode_wait_vblank(crtc,type,target_msc_local-msc_delta,drm_queue_seq,NULL,&seq))){
+			xf86DrvMsg(scrn->scrnIndex,X_WARNING,"divisor 0 get vblank counter failed: %s\n",strerror(errno));
+			amdgpu_drm_abort_entry(drm_queue_seq); swap_info=NULL; goto blit_fallback_no_alloc;
 		}
-
-		*target_msc = seq + flip + msc_delta;
-		*target_msc &= 0xffffffff;
-		swap_info->frame = *target_msc;
-
-		return TRUE;
-	}
-
-	/*
-	 * If we get here, target_msc has already passed or we don't have one,
-	 * and we need to queue an event that will satisfy the divisor/remainder
-	 * equation.
-	 */
-	type = DRM_VBLANK_ABSOLUTE | DRM_VBLANK_EVENT;
-	if (flip == 0)
-		type |= DRM_VBLANK_NEXTONMISS;
-
-	event_msc = current_msc - (current_msc % divisor) + remainder - msc_delta;
-
-	/*
-	 * If the calculated deadline vbl.request.sequence is smaller than
-	 * or equal to current_msc, it means we've passed the last point
-	 * when effective onset frame seq could satisfy
-	 * seq % divisor == remainder, so we need to wait for the next time
-	 * this will happen.
-
-	 * This comparison takes the 1 frame swap delay in pageflipping mode
-	 * into account, as well as a potential DRM_VBLANK_NEXTONMISS delay
-	 * if we are blitting/exchanging instead of flipping.
-	 */
-	if (event_msc <= current_msc)
-		event_msc += divisor;
-
-	/* Account for 1 frame extra pageflip delay if flip > 0 */
-	event_msc -= flip;
-
-	if (!drmmode_wait_vblank(crtc, type, event_msc, drm_queue_seq, NULL, &seq)) {
-		xf86DrvMsg(scrn->scrnIndex, X_WARNING,
-			   "final get vblank counter failed: %s\n",
-			   strerror(errno));
-		goto blit_fallback;
-	}
-
-	/* Adjust returned value for 1 fame pageflip offset of flip > 0 */
-	*target_msc = seq + flip + msc_delta;
-	*target_msc &= 0xffffffff;
-	swap_info->frame = *target_msc;
-
-	return TRUE;
-
-blit_fallback:
-	if (swap_info) {
-		swap_info->type = DRI2_SWAP;
-		amdgpu_dri2_schedule_event(FALLBACK_SWAP_DELAY, swap_info);
-	} else {
-		box.x1 = 0;
-		box.y1 = 0;
-		box.x2 = draw->width;
-		box.y2 = draw->height;
-		REGION_INIT(pScreen, &region, &box, 0);
-
-		amdgpu_dri2_copy_region2(draw->pScreen, draw, &region, front, back);
-
-		DRI2SwapComplete(client, draw, 0, 0, 0, DRI2_BLIT_COMPLETE, func, data);
-
-		amdgpu_dri2_unref_buffer(front);
-		amdgpu_dri2_unref_buffer(back);
+		target_msc_local=seq+flip+msc_delta; target_msc_local&=0xffffffff; swap_info->frame=target_msc_local;
+		*target_msc_inout = target_msc_local; return TRUE;
 	}
-
-	*target_msc = 0;	/* offscreen, so zero out target vblank count */
-	return TRUE;
+	type = DRM_VBLANK_ABSOLUTE|DRM_VBLANK_EVENT; if(flip==0)type|=DRM_VBLANK_NEXTONMISS;
+	event_msc=current_msc-(current_msc%divisor)+remainder-msc_delta;
+	if(event_msc<=current_msc)event_msc+=divisor; event_msc-=flip;
+	if(unlikely(!drmmode_wait_vblank(crtc,type,event_msc,drm_queue_seq,NULL,&seq))){
+		xf86DrvMsg(scrn->scrnIndex,X_WARNING,"final get vblank counter failed: %s\n",strerror(errno));
+		amdgpu_drm_abort_entry(drm_queue_seq); swap_info=NULL; goto blit_fallback_no_alloc;
+	}
+	target_msc_local=seq+flip+msc_delta; target_msc_local&=0xffffffff; swap_info->frame=target_msc_local;
+	*target_msc_inout = target_msc_local; return TRUE;
+
+	blit_fallback_with_alloc:
+	if(swap_info){ swap_info->type=DRI2_SWAP; amdgpu_dri2_schedule_event(FALLBACK_SWAP_DELAY,swap_info); }
+	goto end_blit_fallback;
+	blit_fallback_no_alloc:
+	box.x1=0;box.y1=0;box.x2=draw->width;box.y2=draw->height;
+	RegionInit(&local_region_obj, &box, 0);
+	amdgpu_dri2_copy_region2(draw->pScreen,draw,&local_region_obj,front,back);
+	RegionUninit(&local_region_obj);
+	DRI2SwapComplete(client,draw,0,0,0,DRI2_BLIT_COMPLETE,func,data);
+	amdgpu_dri2_unref_buffer(front); amdgpu_dri2_unref_buffer(back);
+	end_blit_fallback:
+	*target_msc_inout = 0; return TRUE;
 }
 
 Bool amdgpu_dri2_screen_init(ScreenPtr pScreen)
@@ -1296,65 +1063,50 @@ Bool amdgpu_dri2_screen_init(ScreenPtr p
 	ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
 	AMDGPUInfoPtr info = AMDGPUPTR(pScrn);
 	AMDGPUEntPtr pAMDGPUEnt = AMDGPUEntPriv(pScrn);
-	DRI2InfoRec dri2_info = { 0 };
+	DRI2InfoRec dri2_info = {0};
 	const char *driverNames[2];
 	Bool scheduling_works = TRUE;
 
-	if (!info->dri2.available)
-		return FALSE;
-
+	if (unlikely(!info->dri2.available)) return FALSE;
 	info->dri2.device_name = drmGetDeviceNameFromFd(pAMDGPUEnt->fd);
-
+	if (unlikely(!info->dri2.device_name)) {
+		xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "Failed to get device name from DRM FD.\n");
+		return FALSE;
+	}
 	dri2_info.driverName = SI_DRIVER_NAME;
 	dri2_info.fd = pAMDGPUEnt->fd;
 	dri2_info.deviceName = info->dri2.device_name;
 
 	if (info->drmmode.count_crtcs > 2) {
 		uint64_t cap_value;
-
-		if (drmGetCap
-		    (pAMDGPUEnt->fd, DRM_CAP_VBLANK_HIGH_CRTC, &cap_value)) {
-			xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
-				   "You need a newer kernel "
-				   "for VBLANKs on CRTC > 1\n");
-			scheduling_works = FALSE;
-		} else if (!cap_value) {
-			xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
-				   "Your kernel does not "
-				   "handle VBLANKs on CRTC > 1\n");
-			scheduling_works = FALSE;
+		if (unlikely(drmGetCap(pAMDGPUEnt->fd,DRM_CAP_VBLANK_HIGH_CRTC,&cap_value))) {
+			xf86DrvMsg(pScrn->scrnIndex,X_WARNING,"You need a newer kernel for VBLANKs on CRTC > 1\n");
+			scheduling_works=FALSE;
+		} else if(unlikely(!cap_value)) {
+			xf86DrvMsg(pScrn->scrnIndex,X_WARNING,"Your kernel does not handle VBLANKs on CRTC > 1\n");
+			scheduling_works=FALSE;
 		}
 	}
-
-	if (scheduling_works) {
-		dri2_info.ScheduleSwap = amdgpu_dri2_schedule_swap;
-		dri2_info.GetMSC = amdgpu_dri2_get_msc;
-		dri2_info.ScheduleWaitMSC = amdgpu_dri2_schedule_wait_msc;
-		dri2_info.numDrivers = ARRAY_SIZE(driverNames);
-		dri2_info.driverNames = driverNames;
-		driverNames[0] = driverNames[1] = dri2_info.driverName;
-
-		if (DRI2InfoCnt == 0) {
-			if (!dixRegisterPrivateKey(dri2_window_private_key,
-						   PRIVATE_WINDOW,
-						   sizeof(struct dri2_window_priv))) {
-				xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
-					   "Failed to get DRI2 window private\n");
+	if (likely(scheduling_works)) {
+		dri2_info.ScheduleSwap=amdgpu_dri2_schedule_swap;
+		dri2_info.GetMSC=amdgpu_dri2_get_msc;
+		dri2_info.ScheduleWaitMSC=amdgpu_dri2_schedule_wait_msc;
+		dri2_info.numDrivers=2;
+		dri2_info.driverNames=driverNames;
+		driverNames[0]=driverNames[1]=dri2_info.driverName;
+		if(unlikely(DRI2InfoCnt==0)){
+			if(unlikely(!dixRegisterPrivateKey(dri2_window_private_key,PRIVATE_WINDOW,sizeof(struct dri2_window_priv)))){
+				xf86DrvMsg(pScrn->scrnIndex,X_WARNING,"Failed to get DRI2 window private\n");
 				return FALSE;
 			}
-
-			AddCallback(&ClientStateCallback,
-				    amdgpu_dri2_client_state_changed, 0);
+			AddCallback(&ClientStateCallback,amdgpu_dri2_client_state_changed,0);
 		}
-
 		DRI2InfoCnt++;
 	}
-
-	dri2_info.version = 9;
-	dri2_info.CreateBuffer2 = amdgpu_dri2_create_buffer2;
-	dri2_info.DestroyBuffer2 = amdgpu_dri2_destroy_buffer2;
-	dri2_info.CopyRegion2 = amdgpu_dri2_copy_region2;
-
+	dri2_info.version=9;
+	dri2_info.CreateBuffer2=amdgpu_dri2_create_buffer2;
+	dri2_info.DestroyBuffer2=amdgpu_dri2_destroy_buffer2;
+	dri2_info.CopyRegion2=amdgpu_dri2_copy_region2;
 	info->dri2.enabled = DRI2ScreenInit(pScreen, &dri2_info);
 	return info->dri2.enabled;
 }
@@ -1363,13 +1115,41 @@ void amdgpu_dri2_close_screen(ScreenPtr
 {
 	ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
 	AMDGPUInfoPtr info = AMDGPUPTR(pScrn);
+	int i, d;
 
 	if (--DRI2InfoCnt == 0)
-		DeleteCallback(&ClientStateCallback,
-			       amdgpu_dri2_client_state_changed, 0);
+		DeleteCallback(&ClientStateCallback, amdgpu_dri2_client_state_changed, 0);
+
+	gl_lock();
+	DRI2FrameEventPtr curr = fe_free_list;
+	DRI2FrameEventPtr next_ev;
+	while(curr) {
+		next_ev = curr->next;
+		free(curr);
+		curr = next_ev;
+	}
+	fe_free_list = NULL;
+	fe_free_list_length = 0;
+	gl_unlock();
+
+	for (d = 0; d <= MAX_GC_DEPTH; ++d) {
+		for (i = 0; i < gc_cache_cnt[d]; ++i) {
+			if (gc_cache[d][i]) /* Check for NULL before freeing */
+				FreeScratchGC(gc_cache[d][i]);
+		}
+		gc_cache_cnt[d] = 0;
+	}
+
+	gl_lock();
+	memset(flink_cache, 0, sizeof(flink_cache));
+	flink_cache_idx = 0;
+	gl_unlock();
 
 	DRI2CloseScreen(pScreen);
-	drmFree(info->dri2.device_name);
+	if (info->dri2.device_name) {
+		drmFree(info->dri2.device_name);
+		info->dri2.device_name = NULL;
+	}
 }
 
 #endif /* DRI2 */
