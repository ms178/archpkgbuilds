# Maintainer: Andreas Radke <andyrtr@archlinux.org>
# Contributor: Jan de Groot <jgc@archlinux.org>
# PGO Optimization: CachyOS

pkgname=libxpm
pkgver=3.5.18
pkgrel=2.1
pkgdesc="X11 pixmap library (PGO/CS-PGO optimized)"
arch=('x86_64')
license=('custom')
url="https://xorg.freedesktop.org/"
depends=('libxt' 'libxext')
makedepends=('xorg-util-macros' 'clang' 'llvm')
source=(${url}/releases/individual/lib/libXpm-${pkgver}.tar.xz{,.sig})
sha512sums=('52f9d2664a47a26c1a6ad65d18867de870b66947b0b0d99cca3512756a0aaa6ce2a245c0b49f20b70c3ce48bf04c47c333e8119a147465c277bca727f6ab017e'
            'SKIP')
validpgpkeys=('4A193C06D35E7C670FA4EF0BA2FB9E081F2D130E') # Alan Coopersmith <alan.coopersmith@oracle.com>

prepare() {
  cd "libXpm-${pkgver}"
  autoreconf -vfi

  # Generate comprehensive PGO training workload
  cat > "${srcdir}/xpm_pgo_workload.c" << 'EOF'
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <X11/xpm.h>

#define BASE_ITERATIONS 5000

/* Simple 16x16 icon - tests basic parsing */
static const char *icon_16x16[] = {
"16 16 4 1",
"  c None",
". c #000000",
"X c #FF0000",
"o c #0000FF",
"                ",
" .............. ",
" .XXXXXXXXXXXX. ",
" .XooooooooooX. ",
" .XoXXXXXXXXoX. ",
" .XoX      XoX. ",
" .XoX  ..  XoX. ",
" .XoX  ..  XoX. ",
" .XoX      XoX. ",
" .XoX      XoX. ",
" .XoX  ..  XoX. ",
" .XoX  ..  XoX. ",
" .XoX      XoX. ",
" .XoXXXXXXXXoX. ",
" .XooooooooooX. ",
" .XXXXXXXXXXXX. "
};

/* 32x32 gradient - tests many colors */
static const char *gradient_32x32[] = {
"32 32 16 1",
"  c #000000",
". c #111111",
"X c #222222",
"o c #333333",
"O c #444444",
"+ c #555555",
"@ c #666666",
"# c #777777",
"$ c #888888",
"% c #999999",
"& c #AAAAAA",
"* c #BBBBBB",
"= c #CCCCCC",
"- c #DDDDDD",
"; c #EEEEEE",
": c #FFFFFF",
" .XoO+@#$%&*=-;: .XoO+@#$%&*=-;:",
".XoO+@#$%&*=-;:  XoO+@#$%&*=-;: ",
"XoO+@#$%&*=-;: .oO+@#$%&*=-;:  .",
"oO+@#$%&*=-;: .XO+@#$%&*=-;:  .X",
"O+@#$%&*=-;: .Xo+@#$%&*=-;:  .Xo",
"+@#$%&*=-;: .XoO@#$%&*=-;:  .XoO",
"@#$%&*=-;: .XoO+#$%&*=-;:  .XoO+",
"#$%&*=-;: .XoO+@$%&*=-;:  .XoO+@",
"$%&*=-;: .XoO+@#%&*=-;:  .XoO+@#",
"%&*=-;: .XoO+@#$&*=-;:  .XoO+@#$",
"&*=-;: .XoO+@#$%*=-;:  .XoO+@#$%",
"*=-;: .XoO+@#$%&=-;:  .XoO+@#$%&",
"=-;: .XoO+@#$%&*-;:  .XoO+@#$%&*",
"-;: .XoO+@#$%&*=;:  .XoO+@#$%&*=",
";: .XoO+@#$%&*=-:  .XoO+@#$%&*=-",
": .XoO+@#$%&*=-;  .XoO+@#$%&*=-;",
" .XoO+@#$%&*=-;: .XoO+@#$%&*=-;:",
".XoO+@#$%&*=-;:  XoO+@#$%&*=-;: ",
"XoO+@#$%&*=-;: .oO+@#$%&*=-;:  .",
"oO+@#$%&*=-;: .XO+@#$%&*=-;:  .X",
"O+@#$%&*=-;: .Xo+@#$%&*=-;:  .Xo",
"+@#$%&*=-;: .XoO@#$%&*=-;:  .XoO",
"@#$%&*=-;: .XoO+#$%&*=-;:  .XoO+",
"#$%&*=-;: .XoO+@$%&*=-;:  .XoO+@",
"$%&*=-;: .XoO+@#%&*=-;:  .XoO+@#",
"%&*=-;: .XoO+@#$&*=-;:  .XoO+@#$",
"&*=-;: .XoO+@#$%*=-;:  .XoO+@#$%",
"*=-;: .XoO+@#$%&=-;:  .XoO+@#$%&",
"=-;: .XoO+@#$%&*-;:  .XoO+@#$%&*",
"-;: .XoO+@#$%&*=;:  .XoO+@#$%&*=",
";: .XoO+@#$%&*=-:  .XoO+@#$%&*=-",
": .XoO+@#$%&*=-;  .XoO+@#$%&*=-;"
};

/* 24x24 with transparency - tests None color */
static const char *transparency_24x24[] = {
"24 24 5 1",
"  c None",
". c #000000",
"X c #FF0000",
"o c #00FF00",
"O c #0000FF",
"                        ",
"  ....................  ",
" .XXXXXXXXXXXXXXXXXXXX. ",
" .XooooooooooooooooooX. ",
" .XoOOOOOOOOOOOOOOOOoX. ",
" .XoO              OoX. ",
" .XoO  ..........  OoX. ",
" .XoO  .XXXXXXXX.  OoX. ",
" .XoO  .XooooooX.  OoX. ",
" .XoO  .XoOOOOoX.  OoX. ",
" .XoO  .XoO  OoX.  OoX. ",
" .XoO  .XoO  OoX.  OoX. ",
" .XoO  .XoO  OoX.  OoX. ",
" .XoO  .XoO  OoX.  OoX. ",
" .XoO  .XoOOOOoX.  OoX. ",
" .XoO  .XooooooX.  OoX. ",
" .XoO  .XXXXXXXX.  OoX. ",
" .XoO  ..........  OoX. ",
" .XoO              OoX. ",
" .XoOOOOOOOOOOOOOOOOoX. ",
" .XooooooooooooooooooX. ",
" .XXXXXXXXXXXXXXXXXXXX. ",
"  ....................  ",
"                        "
};

/* Cursor with hotspot - tests extended header parsing */
static const char *cursor_16x16[] = {
"16 16 3 1 1 1",
"  c None",
". c #000000",
"X c #FFFFFF",
".               ",
"..              ",
".X.             ",
".XX.            ",
".XXX.           ",
".XXXX.          ",
".XXXXX.         ",
".XXXXXX.        ",
".XXXXXXX.       ",
".XXXXX....      ",
".XX.XX.         ",
".X. .XX.        ",
"..  .XX.        ",
".    .XX.       ",
"      .XX.      ",
"       ..       "
};

/* Multi-character per pixel (cpp=2) - tests extended parsing */
static const char *cpp2_16x16[] = {
"16 16 4 2",
"   c None",
".. c #000000",
"XX c #FFFFFF",
"oo c #FF0000",
"                                ",
"  ............................  ",
"  ..XXXXXXXXXXXXXXXXXXXXXXXX..  ",
"  ..XXooooooooooooooooooooXX..  ",
"  ..XXooXXXXXXXXXXXXXXXXooXX..  ",
"  ..XXooXX            XXooXX..  ",
"  ..XXooXX  ........  XXooXX..  ",
"  ..XXooXX  ..XXXX..  XXooXX..  ",
"  ..XXooXX  ..XXXX..  XXooXX..  ",
"  ..XXooXX  ........  XXooXX..  ",
"  ..XXooXX            XXooXX..  ",
"  ..XXooXXXXXXXXXXXXXXXXooXX..  ",
"  ..XXooooooooooooooooooooXX..  ",
"  ..XXXXXXXXXXXXXXXXXXXXXXXX..  ",
"  ............................  ",
"                                "
};

/* Large 48x48 with 32 colors - stress tests color parsing */
static const char *large_48x48[] = {
"48 48 32 1",
"  c #000000",
". c #080808",
"X c #101010",
"o c #181818",
"O c #202020",
"+ c #282828",
"@ c #303030",
"# c #383838",
"$ c #404040",
"% c #484848",
"& c #505050",
"* c #585858",
"= c #606060",
"- c #686868",
"; c #707070",
": c #787878",
"< c #808080",
"> c #888888",
", c #909090",
"a c #989898",
"b c #A0A0A0",
"c c #A8A8A8",
"d c #B0B0B0",
"e c #B8B8B8",
"f c #C0C0C0",
"g c #C8C8C8",
"h c #D0D0D0",
"i c #D8D8D8",
"j c #E0E0E0",
"k c #E8E8E8",
"l c #F0F0F0",
"m c #F8F8F8",
" .XoO+@#$%&*=-;:<>,abcdefghijklm",
".XoO+@#$%&*=-;:<>,abcdefghijklm ",
"XoO+@#$%&*=-;:<>,abcdefghijklm .",
"oO+@#$%&*=-;:<>,abcdefghijklm .X",
"O+@#$%&*=-;:<>,abcdefghijklm .Xo",
"+@#$%&*=-;:<>,abcdefghijklm .XoO",
"@#$%&*=-;:<>,abcdefghijklm .XoO+",
"#$%&*=-;:<>,abcdefghijklm .XoO+@",
"$%&*=-;:<>,abcdefghijklm .XoO+@#",
"%&*=-;:<>,abcdefghijklm .XoO+@#$",
"&*=-;:<>,abcdefghijklm .XoO+@#$%",
"*=-;:<>,abcdefghijklm .XoO+@#$%&",
"=-;:<>,abcdefghijklm .XoO+@#$%&*",
"-;:<>,abcdefghijklm .XoO+@#$%&*=",
";:<>,abcdefghijklm .XoO+@#$%&*=-",
":<>,abcdefghijklm .XoO+@#$%&*=-;",
"<>,abcdefghijklm .XoO+@#$%&*=-;:",
">,abcdefghijklm .XoO+@#$%&*=-;:<",
",abcdefghijklm .XoO+@#$%&*=-;:<>",
"abcdefghijklm .XoO+@#$%&*=-;:<>,",
"bcdefghijklm .XoO+@#$%&*=-;:<>,a",
"cdefghijklm .XoO+@#$%&*=-;:<>,ab",
"defghijklm .XoO+@#$%&*=-;:<>,abc",
"efghijklm .XoO+@#$%&*=-;:<>,abcd",
"fghijklm .XoO+@#$%&*=-;:<>,abcde",
"ghijklm .XoO+@#$%&*=-;:<>,abcdef",
"hijklm .XoO+@#$%&*=-;:<>,abcdefg",
"ijklm .XoO+@#$%&*=-;:<>,abcdefgh",
"jklm .XoO+@#$%&*=-;:<>,abcdefghi",
"klm .XoO+@#$%&*=-;:<>,abcdefghij",
"lm .XoO+@#$%&*=-;:<>,abcdefghijk",
"m .XoO+@#$%&*=-;:<>,abcdefghijkl",
" .XoO+@#$%&*=-;:<>,abcdefghijklm",
".XoO+@#$%&*=-;:<>,abcdefghijklm ",
"XoO+@#$%&*=-;:<>,abcdefghijklm .",
"oO+@#$%&*=-;:<>,abcdefghijklm .X",
"O+@#$%&*=-;:<>,abcdefghijklm .Xo",
"+@#$%&*=-;:<>,abcdefghijklm .XoO",
"@#$%&*=-;:<>,abcdefghijklm .XoO+",
"#$%&*=-;:<>,abcdefghijklm .XoO+@",
"$%&*=-;:<>,abcdefghijklm .XoO+@#",
"%&*=-;:<>,abcdefghijklm .XoO+@#$",
"&*=-;:<>,abcdefghijklm .XoO+@#$%",
"*=-;:<>,abcdefghijklm .XoO+@#$%&",
"=-;:<>,abcdefghijklm .XoO+@#$%&*",
"-;:<>,abcdefghijklm .XoO+@#$%&*=",
";:<>,abcdefghijklm .XoO+@#$%&*=-",
":<>,abcdefghijklm .XoO+@#$%&*=-;"
};

/* Symbolic color names - tests symbolic name parsing */
static const char *symbolic_32x32[] = {
"32 32 6 1",
"  c None s None",
". c #000000 s foreground",
"X c #FFFFFF s background",
"o c #808080 s shadow",
"O c #C0C0C0 s highlight",
"+ c #404040 s topShadow",
"                                ",
"  ............................  ",
" .XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX.",
" .XooooooooooooooooooooooooooooX.",
" .XoOOOOOOOOOOOOOOOOOOOOOOOOOOoX.",
" .XoO++++++++++++++++++++++++OoX.",
" .XoO+                      +OoX.",
" .XoO+ .................... +OoX.",
" .XoO+ .XXXXXXXXXXXXXXXXXX. +OoX.",
" .XoO+ .X                X. +OoX.",
" .XoO+ .X  ............  X. +OoX.",
" .XoO+ .X  .XXXXXXXXXX.  X. +OoX.",
" .XoO+ .X  .X        X.  X. +OoX.",
" .XoO+ .X  .X  ....  X.  X. +OoX.",
" .XoO+ .X  .X  .XX.  X.  X. +OoX.",
" .XoO+ .X  .X  .XX.  X.  X. +OoX.",
" .XoO+ .X  .X  ....  X.  X. +OoX.",
" .XoO+ .X  .X        X.  X. +OoX.",
" .XoO+ .X  .XXXXXXXXXX.  X. +OoX.",
" .XoO+ .X  ............  X. +OoX.",
" .XoO+ .X                X. +OoX.",
" .XoO+ .XXXXXXXXXXXXXXXXXX. +OoX.",
" .XoO+ .................... +OoX.",
" .XoO+                      +OoX.",
" .XoO++++++++++++++++++++++++OoX.",
" .XoOOOOOOOOOOOOOOOOOOOOOOOOOOoX.",
" .XooooooooooooooooooooooooooooX.",
" .XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX.",
"  ............................  ",
"                                ",
"                                ",
"                                "
};

/* Train XpmImage creation from data */
static void train_xpm_parsing(int iterations) {
    XpmImage image;
    XpmInfo info;
    int i;

    for (i = 0; i < iterations; i++) {
        memset(&image, 0, sizeof(image));
        memset(&info, 0, sizeof(info));
        if (XpmCreateXpmImageFromData((char**)icon_16x16, &image, &info) == XpmSuccess) {
            XpmFreeXpmImage(&image);
            XpmFreeXpmInfo(&info);
        }

        memset(&image, 0, sizeof(image));
        memset(&info, 0, sizeof(info));
        if (XpmCreateXpmImageFromData((char**)gradient_32x32, &image, &info) == XpmSuccess) {
            XpmFreeXpmImage(&image);
            XpmFreeXpmInfo(&info);
        }

        memset(&image, 0, sizeof(image));
        memset(&info, 0, sizeof(info));
        if (XpmCreateXpmImageFromData((char**)transparency_24x24, &image, &info) == XpmSuccess) {
            XpmFreeXpmImage(&image);
            XpmFreeXpmInfo(&info);
        }

        memset(&image, 0, sizeof(image));
        memset(&info, 0, sizeof(info));
        if (XpmCreateXpmImageFromData((char**)cursor_16x16, &image, &info) == XpmSuccess) {
            XpmFreeXpmImage(&image);
            XpmFreeXpmInfo(&info);
        }

        memset(&image, 0, sizeof(image));
        memset(&info, 0, sizeof(info));
        if (XpmCreateXpmImageFromData((char**)cpp2_16x16, &image, &info) == XpmSuccess) {
            XpmFreeXpmImage(&image);
            XpmFreeXpmInfo(&info);
        }

        memset(&image, 0, sizeof(image));
        memset(&info, 0, sizeof(info));
        if (XpmCreateXpmImageFromData((char**)large_48x48, &image, &info) == XpmSuccess) {
            XpmFreeXpmImage(&image);
            XpmFreeXpmInfo(&info);
        }

        memset(&image, 0, sizeof(image));
        memset(&info, 0, sizeof(info));
        if (XpmCreateXpmImageFromData((char**)symbolic_32x32, &image, &info) == XpmSuccess) {
            XpmFreeXpmImage(&image);
            XpmFreeXpmInfo(&info);
        }
    }
}

/* Train data round-trip (parse -> generate -> parse) */
static void train_data_roundtrip(int iterations) {
    XpmImage image, image2;
    XpmInfo info, info2;
    char **buffer;
    int i;

    for (i = 0; i < iterations; i++) {
        memset(&image, 0, sizeof(image));
        memset(&info, 0, sizeof(info));

        if (XpmCreateXpmImageFromData((char**)gradient_32x32, &image, &info) == XpmSuccess) {
            buffer = NULL;
            if (XpmCreateDataFromXpmImage(&buffer, &image, &info) == XpmSuccess) {
                memset(&image2, 0, sizeof(image2));
                memset(&info2, 0, sizeof(info2));
                if (XpmCreateXpmImageFromData(buffer, &image2, &info2) == XpmSuccess) {
                    XpmFreeXpmImage(&image2);
                    XpmFreeXpmInfo(&info2);
                }
                XpmFree(buffer);
            }
            XpmFreeXpmImage(&image);
            XpmFreeXpmInfo(&info);
        }

        memset(&image, 0, sizeof(image));
        memset(&info, 0, sizeof(info));
        if (XpmCreateXpmImageFromData((char**)transparency_24x24, &image, &info) == XpmSuccess) {
            buffer = NULL;
            if (XpmCreateDataFromXpmImage(&buffer, &image, &info) == XpmSuccess) {
                memset(&image2, 0, sizeof(image2));
                memset(&info2, 0, sizeof(info2));
                if (XpmCreateXpmImageFromData(buffer, &image2, &info2) == XpmSuccess) {
                    XpmFreeXpmImage(&image2);
                    XpmFreeXpmInfo(&info2);
                }
                XpmFree(buffer);
            }
            XpmFreeXpmImage(&image);
            XpmFreeXpmInfo(&info);
        }

        memset(&image, 0, sizeof(image));
        memset(&info, 0, sizeof(info));
        if (XpmCreateXpmImageFromData((char**)large_48x48, &image, &info) == XpmSuccess) {
            buffer = NULL;
            if (XpmCreateDataFromXpmImage(&buffer, &image, &info) == XpmSuccess) {
                memset(&image2, 0, sizeof(image2));
                memset(&info2, 0, sizeof(info2));
                if (XpmCreateXpmImageFromData(buffer, &image2, &info2) == XpmSuccess) {
                    XpmFreeXpmImage(&image2);
                    XpmFreeXpmInfo(&info2);
                }
                XpmFree(buffer);
            }
            XpmFreeXpmImage(&image);
            XpmFreeXpmInfo(&info);
        }
    }
}

/* Train file I/O operations */
static void train_file_operations(const char *tmpdir, int iterations) {
    XpmImage image, image2;
    XpmInfo info, info2;
    char filepath[512];
    int i;

    snprintf(filepath, sizeof(filepath), "%s/libxpm_pgo_%d.xpm", tmpdir, getpid());

    for (i = 0; i < iterations; i++) {
        memset(&image, 0, sizeof(image));
        memset(&info, 0, sizeof(info));

        if (XpmCreateXpmImageFromData((char**)icon_16x16, &image, &info) == XpmSuccess) {
            if (XpmWriteFileFromXpmImage(filepath, &image, &info) == XpmSuccess) {
                memset(&image2, 0, sizeof(image2));
                memset(&info2, 0, sizeof(info2));
                if (XpmReadFileToXpmImage(filepath, &image2, &info2) == XpmSuccess) {
                    XpmFreeXpmImage(&image2);
                    XpmFreeXpmInfo(&info2);
                }
            }
            XpmFreeXpmImage(&image);
            XpmFreeXpmInfo(&info);
        }

        memset(&image, 0, sizeof(image));
        memset(&info, 0, sizeof(info));
        if (XpmCreateXpmImageFromData((char**)large_48x48, &image, &info) == XpmSuccess) {
            if (XpmWriteFileFromXpmImage(filepath, &image, &info) == XpmSuccess) {
                memset(&image2, 0, sizeof(image2));
                memset(&info2, 0, sizeof(info2));
                if (XpmReadFileToXpmImage(filepath, &image2, &info2) == XpmSuccess) {
                    XpmFreeXpmImage(&image2);
                    XpmFreeXpmInfo(&info2);
                }
            }
            XpmFreeXpmImage(&image);
            XpmFreeXpmInfo(&info);
        }
    }

    unlink(filepath);
}

int main(int argc, char **argv) {
    const char *tmpdir = argc > 1 ? argv[1] : "/tmp";
    int base_iters = argc > 2 ? atoi(argv[2]) : BASE_ITERATIONS;

    fprintf(stderr, "libXpm PGO Training: Parsing (%d iterations)...\n", base_iters);
    train_xpm_parsing(base_iters);

    fprintf(stderr, "libXpm PGO Training: Roundtrip (%d iterations)...\n", base_iters / 2);
    train_data_roundtrip(base_iters / 2);

    fprintf(stderr, "libXpm PGO Training: File I/O (%d iterations)...\n", base_iters / 10);
    train_file_operations(tmpdir, base_iters / 10);

    fprintf(stderr, "libXpm PGO Training complete.\n");
    return 0;
}
EOF
}

# Run the workload against the build directory using libtool
_run_xpm_workload() {
  local build_dir="$1"
  local pgo_flags="$2"
  local orig_cflags="$3"
  local orig_ldflags="$4"

  cd "$build_dir" || return 1

  local lib_dir="${build_dir}/src/.libs"
  local include_dir="${build_dir}/include"
  local libtool_la="src/libXpm.la"

  if [[ ! -f "$libtool_la" ]]; then
    echo "Error: Could not find $libtool_la"
    find "$build_dir" -name "*.la" -print 2>/dev/null
    return 1
  fi

  echo "Using libtool archive: $libtool_la"
  echo "Library directory: $lib_dir"
  ls -la "$lib_dir"/libXpm*.so* 2>/dev/null || echo "No libXpm shared libraries found"

  echo "Compiling libXpm PGO workload using libtool..."

  # Use environment variables for CC/CFLAGS/LDFLAGS like the blueprint
  # This ensures libtool and the compiler see consistent flags
  CC="${CC:-clang}" \
  CFLAGS="${orig_cflags} ${pgo_flags}" \
  LDFLAGS="${orig_ldflags} ${pgo_flags}" \
  ./libtool --tag=CC --mode=link "${CC:-clang}" \
    "${srcdir}/xpm_pgo_workload.c" \
    -o "${srcdir}/xpm_pgo_runner" \
    -I"$include_dir" \
    "$libtool_la" \
    -Wl,-rpath,"$lib_dir" || { echo "Failed to compile workload"; return 1; }

  echo "Running libXpm PGO workload..."
  "${srcdir}/xpm_pgo_runner" "/tmp" 8000 || echo "Warning: Workload exited with non-zero status"

  # Additional runs with varying parameters for diverse profile coverage
  "${srcdir}/xpm_pgo_runner" "/tmp" 4000 || true
  "${srcdir}/xpm_pgo_runner" "/tmp" 12000 || true

  rm -f "${srcdir}/xpm_pgo_runner"
  return 0
}

build() {
  # --- Setup ---
  export CC="clang"
  export CXX="clang++"
  local _original_cflags="${CFLAGS}"
  local _original_cxxflags="${CXXFLAGS}"
  local _original_ldflags="${LDFLAGS}"

  local PGO_DATA_DIR="${srcdir}/pgo_data"
  local CS_PGO_DATA_DIR="${srcdir}/cspgo_data"
  mkdir -p "$PGO_DATA_DIR" "$CS_PGO_DATA_DIR"

  trap 'rm -rf "$PGO_DATA_DIR" "$CS_PGO_DATA_DIR" "${srcdir}/xpm_pgo_workload.c" "${srcdir}/xpm_pgo_runner"' EXIT

  local _configure_opts=(
    --prefix=/usr
    --sysconfdir=/etc
    --disable-static
    --disable-open-zfile
  )

  local pgo_failed=false
  # --- End Setup ---

  cd "${srcdir}/libXpm-${pkgver}"

  # --- Stage 1: PGO Instrumentation Build ---
  msg2 "Stage 1: Building PGO instrumented build..."

  # Use simple, well-supported PGO flags only
  # Removed problematic -Xclang -mllvm flags that get mangled by libtool
  local _pgo_gen_flags="-fprofile-generate=${PGO_DATA_DIR}"

  export CFLAGS="${_original_cflags} ${_pgo_gen_flags}"
  export CXXFLAGS="${_original_cxxflags} ${_pgo_gen_flags}"
  export LDFLAGS="${_original_ldflags} ${_pgo_gen_flags}"

  ./configure "${_configure_opts[@]}" || { echo "Configure failed (Stage 1)"; return 1; }
  make -j1 || { echo "Make failed (Stage 1)"; return 1; }

  # --- Stage 1: PGO Training Run ---
  msg2 "Stage 1: Running PGO training workloads..."
  export LLVM_PROFILE_FILE="${PGO_DATA_DIR}/libxpm-%p-%m.profraw"

  # Run test suite multiple times for coverage
  for i in 1 2 3; do
    make check &>/dev/null || true
  done

  # Run cxpm tool if available
  if [[ -x "./cxpm/cxpm" ]]; then
    msg2 "Training with cxpm tool..."
    find "${srcdir}/libXpm-${pkgver}" -name "*.xpm" -type f 2>/dev/null | while read -r xpm; do
      for _ in 1 2 3 4 5; do
        ./cxpm/cxpm "$xpm" &>/dev/null || true
      done
    done
  fi

  # Run custom workload
  _run_xpm_workload "$PWD" "${_pgo_gen_flags}" "${_original_cflags}" "${_original_ldflags}" || {
    echo "Custom workload failed (Stage 1)"
    pgo_failed=true
  }

  unset LLVM_PROFILE_FILE

  # --- Stage 1: Merge PGO Profiles ---
  msg2 "Stage 1: Merging PGO profiles..."
  sleep 1  # Ensure all profile files are written

  if ! find "$PGO_DATA_DIR" -name "*.profraw" 2>/dev/null | grep -q .; then
    echo "No raw PGO profile data (*.profraw) generated. Aborting PGO."
    pgo_failed=true
  elif ! $pgo_failed; then
    if ! llvm-profdata merge -output="${PGO_DATA_DIR}/default.profdata" "${PGO_DATA_DIR}"/*.profraw; then
      echo "llvm-profdata merge failed (Stage 1). Aborting PGO."
      pgo_failed=true
    elif [[ ! -s "${PGO_DATA_DIR}/default.profdata" ]]; then
      echo "Merged PGO profile data is empty (Stage 1). Aborting PGO."
      pgo_failed=true
    fi
    rm -f "${PGO_DATA_DIR}"/*.profraw
  fi
  # --- End Stage 1 ---

  # --- Stage 2: CS-PGO Instrumentation Build ---
  if ! $pgo_failed; then
    msg2 "Stage 2: Building CS-PGO instrumented build..."
    make distclean || echo "Warning: make distclean failed before Stage 2"

    if [[ ! -f configure ]]; then
      autoreconf -vfi || { echo "autoreconf failed before Stage 2"; pgo_failed=true; }
    fi

    if ! $pgo_failed; then
      local _cspgo_gen_flags="-fprofile-use=${PGO_DATA_DIR}/default.profdata -fcs-profile-generate=${CS_PGO_DATA_DIR}"

      export CFLAGS="${_original_cflags} ${_cspgo_gen_flags}"
      export CXXFLAGS="${_original_cxxflags} ${_cspgo_gen_flags}"
      export LDFLAGS="${_original_ldflags} ${_cspgo_gen_flags}"

      ./configure "${_configure_opts[@]}" || { echo "Configure failed (Stage 2)"; pgo_failed=true; }

      if ! $pgo_failed; then
        make -j"$(nproc)" || { echo "Make failed (Stage 2)"; pgo_failed=true; }
      fi
    fi
  fi
  # --- End Stage 2 ---

  # --- Stage 2: CS-PGO Training Run ---
  if ! $pgo_failed; then
    msg2 "Stage 2: Running CS-PGO training workloads..."
    export LLVM_PROFILE_FILE="${CS_PGO_DATA_DIR}/libxpm-cs-%p-%m.profraw"

    for i in 1 2 3; do
      make check &>/dev/null || true
    done

    if [[ -x "./cxpm/cxpm" ]]; then
      find "${srcdir}/libXpm-${pkgver}" -name "*.xpm" -type f 2>/dev/null | while read -r xpm; do
        for _ in 1 2 3 4 5; do
          ./cxpm/cxpm "$xpm" &>/dev/null || true
        done
      done
    fi

    _run_xpm_workload "$PWD" "${_cspgo_gen_flags}" "${_original_cflags}" "${_original_ldflags}" || {
      echo "Custom workload failed (Stage 2)"
      pgo_failed=true
    }

    unset LLVM_PROFILE_FILE

    # --- Stage 2: Merge CS-PGO Profiles ---
    msg2 "Stage 2: Merging CS-PGO profiles..."
    sleep 1

    if ! find "$CS_PGO_DATA_DIR" -name "*.profraw" 2>/dev/null | grep -q .; then
      echo "Warning: No raw CS-PGO profile data generated. Using Stage 1 PGO data."
      cp "${PGO_DATA_DIR}/default.profdata" "${CS_PGO_DATA_DIR}/cs.profdata" || {
        echo "Failed to copy fallback profile data."
        pgo_failed=true
      }
    elif ! $pgo_failed; then
      if ! llvm-profdata merge -output="${CS_PGO_DATA_DIR}/cs.profdata" \
           "${CS_PGO_DATA_DIR}"/*.profraw "${PGO_DATA_DIR}/default.profdata"; then
        echo "llvm-profdata merge failed (Stage 2). Aborting CS-PGO."
        pgo_failed=true
      fi
      rm -f "${CS_PGO_DATA_DIR}"/*.profraw
    fi

    if ! $pgo_failed && [[ ! -s "${CS_PGO_DATA_DIR}/cs.profdata" ]]; then
      echo "Final merged CS-PGO profile is empty (Stage 2). Aborting CS-PGO."
      pgo_failed=true
    fi
  fi
  # --- End Stage 2 ---

  # --- Stage 3: Final Optimized Build ---
  msg2 "Stage 3: Building final optimized build..."
  make distclean || echo "Warning: make distclean failed before Stage 3"

  if [[ ! -f configure ]]; then
    autoreconf -vfi || { echo "autoreconf failed before Stage 3"; return 1; }
  fi

  CFLAGS="${_original_cflags}"
  CXXFLAGS="${_original_cxxflags}"
  LDFLAGS="${_original_ldflags}"

  if ! $pgo_failed; then
    local _final_opt_flags=""
    if [[ -s "${CS_PGO_DATA_DIR}/cs.profdata" ]]; then
      msg2 "Applying CS-PGO profile data for final build."
      _final_opt_flags="-fprofile-use=${CS_PGO_DATA_DIR}/cs.profdata"
    elif [[ -s "${PGO_DATA_DIR}/default.profdata" ]]; then
      msg2 "Applying fallback PGO profile data for final build."
      _final_opt_flags="-fprofile-use=${PGO_DATA_DIR}/default.profdata"
    else
      warning "No usable profile data found. Building without PGO."
    fi
    CFLAGS+=" ${_final_opt_flags}"
    CXXFLAGS+=" ${_final_opt_flags}"
    LDFLAGS+=" ${_final_opt_flags}"
  else
    warning "Building final version without PGO optimization due to previous errors."
  fi

  export CFLAGS CXXFLAGS LDFLAGS

  ./configure "${_configure_opts[@]}" || { echo "Configure failed (Stage 3)"; return 1; }
  make -j"$(nproc)" || { echo "Make failed (Stage 3)"; return 1; }
  # --- End Stage 3 ---

  if $pgo_failed; then
    warning "PGO optimization could not be fully applied. Package built without PGO."
  else
    msg "CS-PGO build process completed successfully."
  fi
}

check() {
  cd "${srcdir}/libXpm-${pkgver}"
  # 3 tests fail due to disabling compression support from 3.5.15 on
  make check || true
}

package() {
  cd "${srcdir}/libXpm-${pkgver}"
  make DESTDIR="${pkgdir}" install

  install -Dm644 COPYING "${pkgdir}/usr/share/licenses/${pkgname}/COPYING"
}
