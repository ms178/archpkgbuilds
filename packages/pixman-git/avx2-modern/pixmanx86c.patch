--- pixman-x86.c.orig	2025-07-04 23:57:48.241525147 +0200
+++ pixman-x86.c	2025-07-05 02:02:45.015768208 +0200
@@ -19,178 +19,217 @@
  * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
  * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  */
+
 #ifdef HAVE_CONFIG_H
-#include <pixman-config.h>
+#   include <pixman-config.h>      /* generated by build system          */
 #endif
 
 #include "pixman-private.h"
 
-#if defined(USE_X86_MMX) || defined (USE_SSE2) || defined (USE_SSSE3)
+#if defined(USE_X86_MMX) || defined(USE_SSE2) || defined(USE_SSSE3) || \
+defined(USE_AVX2)
 
-/* The CPU detection code needs to be in a file not compiled with
- * "-mmmx -msse", as gcc would generate CMOV instructions otherwise
- * that would lead to SIGILL instructions on old CPUs that don't have
- * it.
- */
+/* Feature-bit convenience flags -------------------------------------- */
+#define ECX_SSE3     (1u << 0)
+#define ECX_SSSE3    (1u << 9)
+#define ECX_OSXSAVE  (1u << 27)
+#define ECX_AVX      (1u << 28)
+
+#define EDX_MMX      (1u << 23)
+#define EDX_SSE      (1u << 25)
+#define EDX_SSE2     (1u << 26)
+
+#define EBX_AVX2     (1u << 5)
+
+/* -------------------------------------------------------------------- */
+/*  Very small abstraction around CPUID                                 */
+/* -------------------------------------------------------------------- */
+#if defined(__GNUC__) || defined(__clang__)
+#   include <cpuid.h>
+
+static inline void
+pixman_cpuid (uint32_t leaf,
+              uint32_t *a, uint32_t *b, uint32_t *c, uint32_t *d)
+{
+    #   if defined(__i386__) && defined(__PIC__)
+    /* Preserve EBX which is reserved for PIC base register.       */
+    uint32_t ebx;
+    __asm__ volatile ("xchgl %%ebx, %1 ; cpuid ; xchgl %%ebx, %1"
+    : "=a" (*a), "=&r" (ebx), "=c" (*c), "=d" (*d)
+    : "0" (leaf), "2" (0));
+    *b = ebx;
+    #   else
+    __cpuid (leaf, *a, *b, *c, *d);
+    #   endif
+}
 
-typedef enum
+static inline uint64_t
+pixman_xgetbv (void)
 {
-    X86_MMX			= (1 << 0),
-    X86_MMX_EXTENSIONS		= (1 << 1),
-    X86_SSE			= (1 << 2) | X86_MMX_EXTENSIONS,
-    X86_SSE2			= (1 << 3),
-    X86_CMOV			= (1 << 4),
-    X86_SSSE3			= (1 << 5)
-} cpu_features_t;
-
-#ifdef HAVE_GETISAX
+    uint32_t eax, edx;
+    __asm__ volatile (".byte 0x0f, 0x01, 0xd0"   /* xgetbv */
+    : "=a" (eax), "=d" (edx)
+    : "c" (0));
+    return ((uint64_t)edx << 32) | eax;
+}
 
-#include <sys/auxv.h>
+#elif defined(_MSC_VER) /*---------------------- MSVC -----------------*/
+#   include <intrin.h>
+#   pragma intrinsic(__cpuid)
+#   pragma intrinsic(_xgetbv)
+
+static inline void
+pixman_cpuid (uint32_t leaf,
+              uint32_t *a, uint32_t *b, uint32_t *c, uint32_t *d)
+{
+    int regs[4];
+    __cpuidex (regs, (int)leaf, 0);
+    *a = (uint32_t)regs[0];
+    *b = (uint32_t)regs[1];
+    *c = (uint32_t)regs[2];
+    *d = (uint32_t)regs[3];
+}
 
-static cpu_features_t
-detect_cpu_features (void)
+static inline uint64_t
+pixman_xgetbv (void)
 {
-    cpu_features_t features = 0;
-    unsigned int result = 0;
-
-    if (getisax (&result, 1))
-    {
-	if (result & AV_386_CMOV)
-	    features |= X86_CMOV;
-	if (result & AV_386_MMX)
-	    features |= X86_MMX;
-	if (result & AV_386_AMD_MMX)
-	    features |= X86_MMX_EXTENSIONS;
-	if (result & AV_386_SSE)
-	    features |= X86_SSE;
-	if (result & AV_386_SSE2)
-	    features |= X86_SSE2;
-	if (result & AV_386_SSSE3)
-	    features |= X86_SSSE3;
-    }
-
-    return features;
+    return _xgetbv (0);
 }
 
 #else
+#   error "Unsupported compiler for CPUID/XGETBV"
+#endif /* toolchain switch */
 
-#if defined (__GNUC__)
-#include <cpuid.h>
-#elif defined(_MSC_VER)
-#include <intrin.h>
-#endif
-
-static void
-pixman_cpuid (uint32_t feature,
-	      uint32_t *a, uint32_t *b, uint32_t *c, uint32_t *d)
-{
-#if defined (__GNUC__)
-    *a = *b = *c = *d = 0;
-    __get_cpuid(feature, a, b, c, d);
-#elif defined (_MSC_VER)
-    int info[4];
-
-    __cpuid (info, feature);
-
-    *a = info[0];
-    *b = info[1];
-    *c = info[2];
-    *d = info[3];
-#else
-#error Unknown compiler
-#endif
-}
+/* -------------------------------------------------------------------- */
+/*  Existing feature enumeration (unchanged)                            */
+/* -------------------------------------------------------------------- */
+typedef enum
+{
+    X86_MMX              = (1 << 0),
+    X86_MMX_EXTENSIONS   = (1 << 1),
+    X86_SSE              = (1 << 2) | X86_MMX_EXTENSIONS,
+    X86_SSE2             = (1 << 3),
+    X86_CMOV             = (1 << 4),
+    X86_SSSE3            = (1 << 5)
+    /* No public AVX2 flag neededâ€”the test is done separately          */
+} cpu_features_t;
 
+/* -------------------------------------------------------------------- */
+/*  Portable feature detection                                          */
+/* -------------------------------------------------------------------- */
 static cpu_features_t
 detect_cpu_features (void)
 {
-    uint32_t a, b, c, d;
     cpu_features_t features = 0;
+    uint32_t a, b, c, d;
 
-    /* Get feature bits */
     pixman_cpuid (0x01, &a, &b, &c, &d);
-    if (d & (1 << 15))
-	features |= X86_CMOV;
-    if (d & (1 << 23))
-	features |= X86_MMX;
-    if (d & (1 << 25))
-	features |= X86_SSE;
-    if (d & (1 << 26))
-	features |= X86_SSE2;
-    if (c & (1 << 9))
-	features |= X86_SSSE3;
 
-    /* Check for AMD specific features */
+    if (d & (1 << 15))  features |= X86_CMOV;
+    if (d & EDX_MMX)    features |= X86_MMX;
+    if (d & EDX_SSE)    features |= X86_SSE;
+    if (d & EDX_SSE2)   features |= X86_SSE2;
+    if (c & ECX_SSSE3)  features |= X86_SSSE3;
+
+    /* AMD MMX extensions, if SSE is absent -------------------------- */
     if ((features & X86_MMX) && !(features & X86_SSE))
     {
-	char vendor[13];
-
-	/* Get vendor string */
-	memset (vendor, 0, sizeof vendor);
+        char vendor[13] = {0};
 
-	pixman_cpuid (0x00, &a, &b, &c, &d);
-	memcpy (vendor + 0, &b, 4);
-	memcpy (vendor + 4, &d, 4);
-	memcpy (vendor + 8, &c, 4);
-
-	if (strcmp (vendor, "AuthenticAMD") == 0 ||
-	    strcmp (vendor, "HygonGenuine") == 0 ||
-	    strcmp (vendor, "Geode by NSC") == 0)
-	{
-	    pixman_cpuid (0x80000000, &a, &b, &c, &d);
-	    if (a >= 0x80000001)
-	    {
-		pixman_cpuid (0x80000001, &a, &b, &c, &d);
-
-		if (d & (1 << 22))
-		    features |= X86_MMX_EXTENSIONS;
-	    }
-	}
+        pixman_cpuid (0x00, &a, &b, &c, &d);
+        memcpy (vendor + 0, &b, 4);
+        memcpy (vendor + 4, &d, 4);
+        memcpy (vendor + 8, &c, 4);
+
+        if (!strcmp (vendor, "AuthenticAMD")  ||
+            !strcmp (vendor, "HygonGenuine")  ||
+            !strcmp (vendor, "Geode by NSC"))
+        {
+            pixman_cpuid (0x80000000, &a, &b, &c, &d);
+            if (a >= 0x80000001)
+            {
+                pixman_cpuid (0x80000001, &a, &b, &c, &d);
+                if (d & (1 << 22))
+                    features |= X86_MMX_EXTENSIONS;
+            }
+        }
     }
-
     return features;
 }
 
-#endif
-
 static pixman_bool_t
-have_feature (cpu_features_t feature)
+have_feature (cpu_features_t mask)
 {
-    static pixman_bool_t initialized;
-    static cpu_features_t features;
+    static pixman_bool_t   init = FALSE;
+    static cpu_features_t  caps;
 
-    if (!initialized)
+    if (!init)
     {
-	features = detect_cpu_features();
-	initialized = TRUE;
+        caps  = detect_cpu_features();
+        init  = TRUE;
     }
+    return (caps & mask) == mask;
+}
+
+/* -------------------------------------------------------------------- */
+/*  Separate, minimalist AVX2 check                                     */
+/* -------------------------------------------------------------------- */
+#ifdef USE_AVX2
+static pixman_bool_t
+have_avx2 (void)
+{
+    uint32_t a, b, c, d;
 
-    return (features & feature) == feature;
+    /* Need AVX + OSXSAVE ------------------------------------------- */
+    pixman_cpuid (0x01, &a, &b, &c, &d);
+    if (!(c & ECX_AVX) || !(c & ECX_OSXSAVE))
+        return FALSE;
+
+    /* OS must save/restore YMM regs -------------------------------- */
+    if ( (pixman_xgetbv() & 0x6u) != 0x6u )
+        return FALSE;
+
+    /* Leaf 7: AVX2 bit -------------------------------------------- */
+    pixman_cpuid (0x07, &a, &b, &c, &d);
+    return (b & EBX_AVX2) != 0;
 }
+#endif /* USE_AVX2 */
 
-#endif
+#endif /* SIMD capability section */
 
+/* -------------------------------------------------------------------- */
+/*  Public dispatcher used by pixman                                   */
+/* -------------------------------------------------------------------- */
 pixman_implementation_t *
 _pixman_x86_get_implementations (pixman_implementation_t *imp)
 {
-#define MMX_BITS  (X86_MMX | X86_MMX_EXTENSIONS)
-#define SSE2_BITS (X86_MMX | X86_MMX_EXTENSIONS | X86_SSE | X86_SSE2)
-#define SSSE3_BITS (X86_SSE | X86_SSE2 | X86_SSSE3)
+    #if defined(USE_X86_MMX) || defined(USE_SSE2) || defined(USE_SSSE3) || \
+    defined(USE_AVX2)
 
-#ifdef USE_X86_MMX
+    #   define MMX_BITS   (X86_MMX | X86_MMX_EXTENSIONS)
+    #   define SSE2_BITS  (X86_MMX | X86_MMX_EXTENSIONS | X86_SSE | X86_SSE2)
+    #   define SSSE3_BITS (X86_SSE | X86_SSE2 | X86_SSSE3)
+
+    #   ifdef USE_X86_MMX
     if (!_pixman_disabled ("mmx") && have_feature (MMX_BITS))
-	imp = _pixman_implementation_create_mmx (imp);
-#endif
+        imp = _pixman_implementation_create_mmx (imp);
+    #   endif
 
-#ifdef USE_SSE2
+    #   ifdef USE_SSE2
     if (!_pixman_disabled ("sse2") && have_feature (SSE2_BITS))
-	imp = _pixman_implementation_create_sse2 (imp);
-#endif
+        imp = _pixman_implementation_create_sse2 (imp);
+    #   endif
 
-#ifdef USE_SSSE3
+    #   ifdef USE_SSSE3
     if (!_pixman_disabled ("ssse3") && have_feature (SSSE3_BITS))
-	imp = _pixman_implementation_create_ssse3 (imp);
-#endif
+        imp = _pixman_implementation_create_ssse3 (imp);
+    #   endif
+
+    #   ifdef USE_AVX2
+    if (!_pixman_disabled ("avx2") && have_avx2 ())
+        imp = _pixman_implementation_create_avx2 (imp);
+    #   endif
 
+    #endif /* SIMD checks */
     return imp;
 }
