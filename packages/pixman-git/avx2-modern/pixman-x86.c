/*
 * Copyright © 2000 SuSE, Inc.
 * Copyright © 2007 Red Hat, Inc.
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of SuSE not be used in advertising or
 * publicity pertaining to distribution of the software without specific,
 * written prior permission.  SuSE makes no representations about the
 * suitability of this software for any purpose.  It is provided "as is"
 * without express or implied warranty.
 *
 * SuSE DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL SuSE
 * BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
 * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
 * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#ifdef HAVE_CONFIG_H
#   include <pixman-config.h>      /* generated by build system          */
#endif

#include "pixman-private.h"

#if defined(USE_X86_MMX) || defined(USE_SSE2) || defined(USE_SSSE3) || \
defined(USE_AVX2)

/* Feature-bit convenience flags -------------------------------------- */
#define ECX_SSE3     (1u << 0)
#define ECX_SSSE3    (1u << 9)
#define ECX_OSXSAVE  (1u << 27)
#define ECX_AVX      (1u << 28)

#define EDX_MMX      (1u << 23)
#define EDX_SSE      (1u << 25)
#define EDX_SSE2     (1u << 26)

#define EBX_AVX2     (1u << 5)

/* -------------------------------------------------------------------- */
/*  Very small abstraction around CPUID                                 */
/* -------------------------------------------------------------------- */
#if defined(__GNUC__) || defined(__clang__)
#   include <cpuid.h>

static inline void
pixman_cpuid (uint32_t leaf,
              uint32_t *a, uint32_t *b, uint32_t *c, uint32_t *d)
{
    #   if defined(__i386__) && defined(__PIC__)
    /* Preserve EBX which is reserved for PIC base register.       */
    uint32_t ebx;
    __asm__ volatile ("xchgl %%ebx, %1 ; cpuid ; xchgl %%ebx, %1"
    : "=a" (*a), "=&r" (ebx), "=c" (*c), "=d" (*d)
    : "0" (leaf), "2" (0));
    *b = ebx;
    #   else
    __cpuid (leaf, *a, *b, *c, *d);
    #   endif
}

static inline uint64_t
pixman_xgetbv (void)
{
    uint32_t eax, edx;
    __asm__ volatile (".byte 0x0f, 0x01, 0xd0"   /* xgetbv */
    : "=a" (eax), "=d" (edx)
    : "c" (0));
    return ((uint64_t)edx << 32) | eax;
}

#elif defined(_MSC_VER) /*---------------------- MSVC -----------------*/
#   include <intrin.h>
#   pragma intrinsic(__cpuid)
#   pragma intrinsic(_xgetbv)

static inline void
pixman_cpuid (uint32_t leaf,
              uint32_t *a, uint32_t *b, uint32_t *c, uint32_t *d)
{
    int regs[4];
    __cpuidex (regs, (int)leaf, 0);
    *a = (uint32_t)regs[0];
    *b = (uint32_t)regs[1];
    *c = (uint32_t)regs[2];
    *d = (uint32_t)regs[3];
}

static inline uint64_t
pixman_xgetbv (void)
{
    return _xgetbv (0);
}

#else
#   error "Unsupported compiler for CPUID/XGETBV"
#endif /* toolchain switch */

/* -------------------------------------------------------------------- */
/*  Existing feature enumeration (unchanged)                            */
/* -------------------------------------------------------------------- */
typedef enum
{
    X86_MMX              = (1 << 0),
    X86_MMX_EXTENSIONS   = (1 << 1),
    X86_SSE              = (1 << 2) | X86_MMX_EXTENSIONS,
    X86_SSE2             = (1 << 3),
    X86_CMOV             = (1 << 4),
    X86_SSSE3            = (1 << 5)
    /* No public AVX2 flag needed—the test is done separately          */
} cpu_features_t;

/* -------------------------------------------------------------------- */
/*  Portable feature detection                                          */
/* -------------------------------------------------------------------- */
static cpu_features_t
detect_cpu_features (void)
{
    cpu_features_t features = 0;
    uint32_t a, b, c, d;

    pixman_cpuid (0x01, &a, &b, &c, &d);

    if (d & (1 << 15))  features |= X86_CMOV;
    if (d & EDX_MMX)    features |= X86_MMX;
    if (d & EDX_SSE)    features |= X86_SSE;
    if (d & EDX_SSE2)   features |= X86_SSE2;
    if (c & ECX_SSSE3)  features |= X86_SSSE3;

    /* AMD MMX extensions, if SSE is absent -------------------------- */
    if ((features & X86_MMX) && !(features & X86_SSE))
    {
        char vendor[13] = {0};

        pixman_cpuid (0x00, &a, &b, &c, &d);
        memcpy (vendor + 0, &b, 4);
        memcpy (vendor + 4, &d, 4);
        memcpy (vendor + 8, &c, 4);

        if (!strcmp (vendor, "AuthenticAMD")  ||
            !strcmp (vendor, "HygonGenuine")  ||
            !strcmp (vendor, "Geode by NSC"))
        {
            pixman_cpuid (0x80000000, &a, &b, &c, &d);
            if (a >= 0x80000001)
            {
                pixman_cpuid (0x80000001, &a, &b, &c, &d);
                if (d & (1 << 22))
                    features |= X86_MMX_EXTENSIONS;
            }
        }
    }
    return features;
}

static pixman_bool_t
have_feature (cpu_features_t mask)
{
    static pixman_bool_t   init = FALSE;
    static cpu_features_t  caps;

    if (!init)
    {
        caps  = detect_cpu_features();
        init  = TRUE;
    }
    return (caps & mask) == mask;
}

/* -------------------------------------------------------------------- */
/*  Separate, minimalist AVX2 check                                     */
/* -------------------------------------------------------------------- */
#ifdef USE_AVX2
static pixman_bool_t
have_avx2 (void)
{
    uint32_t a, b, c, d;

    /* Need AVX + OSXSAVE ------------------------------------------- */
    pixman_cpuid (0x01, &a, &b, &c, &d);
    if (!(c & ECX_AVX) || !(c & ECX_OSXSAVE))
        return FALSE;

    /* OS must save/restore YMM regs -------------------------------- */
    if ( (pixman_xgetbv() & 0x6u) != 0x6u )
        return FALSE;

    /* Leaf 7: AVX2 bit -------------------------------------------- */
    pixman_cpuid (0x07, &a, &b, &c, &d);
    return (b & EBX_AVX2) != 0;
}
#endif /* USE_AVX2 */

#endif /* SIMD capability section */

/* -------------------------------------------------------------------- */
/*  Public dispatcher used by pixman                                   */
/* -------------------------------------------------------------------- */
pixman_implementation_t *
_pixman_x86_get_implementations (pixman_implementation_t *imp)
{
    #if defined(USE_X86_MMX) || defined(USE_SSE2) || defined(USE_SSSE3) || \
    defined(USE_AVX2)

    #   define MMX_BITS   (X86_MMX | X86_MMX_EXTENSIONS)
    #   define SSE2_BITS  (X86_MMX | X86_MMX_EXTENSIONS | X86_SSE | X86_SSE2)
    #   define SSSE3_BITS (X86_SSE | X86_SSE2 | X86_SSSE3)

    #   ifdef USE_X86_MMX
    if (!_pixman_disabled ("mmx") && have_feature (MMX_BITS))
        imp = _pixman_implementation_create_mmx (imp);
    #   endif

    #   ifdef USE_SSE2
    if (!_pixman_disabled ("sse2") && have_feature (SSE2_BITS))
        imp = _pixman_implementation_create_sse2 (imp);
    #   endif

    #   ifdef USE_SSSE3
    if (!_pixman_disabled ("ssse3") && have_feature (SSSE3_BITS))
        imp = _pixman_implementation_create_ssse3 (imp);
    #   endif

    #   ifdef USE_AVX2
    if (!_pixman_disabled ("avx2") && have_avx2 ())
        imp = _pixman_implementation_create_avx2 (imp);
    #   endif

    #endif /* SIMD checks */
    return imp;
}
