_basename="xf86-input-libinput"
pkgname="xlibre-xf86-input-libinput"
pkgver=1.5.1.0
pkgrel=10
pkgdesc="Generic input driver for the XLibre server based on libinput"
arch=('aarch64' 'x86_64')
url="https://github.com/X11Libre/${_basename}/"
license=('MIT')
depends=('glibc' 'libinput-git')
makedepends=('libx11' 'libxi' 'meson>=0.50' 'xlibre-xserver-devel' 'xorgproto-git'
             'X-ABI-XINPUT_VERSION=26.0'
             'clang' 'llvm' 'xorg-server-xvfb' 'xorg-xinput-git' 'xorg-xdpyinfo'
             'xdotool')
provides=('xf86-input-libinput-xlibre' "${_basename}")
conflicts=("${_basename}" 'xf86-input-libinput-xlibre' 'xorg-server<1.19.0'
           'X-ABI-XINPUT_VERSION<26' 'X-ABI-XINPUT_VERSION>=27')
replaces=('xf86-input-libinput-xlibre')
groups=('xlibre-drivers')
_pkgsrc="${_basename}-xlibre-${_basename}-${pkgver}"
source=("${_pkgsrc}.tar.gz::${url}/archive/refs/tags/xlibre-${_basename}-${pkgver}.tar.gz")
b2sums=('b4a6061dd310c3e900606a128dc28c83b6e0dce6e6aa92e30c1d5788c5f0b6683b41e0e3e24ae8f4cf5014ba217a720240427c9f835038fe1b2794b58a330059')

_extra_instr='-g3 -fno-omit-frame-pointer -fprofile-update=atomic -Xclang -mllvm -Xclang -vp-counters-per-site=50 -Xclang -mllvm -Xclang -runtime-counter-relocation -Xclang -mllvm -Xclang -enable-value-profiling'

prepare() {
  rm -rf build-pgo build-final fakeinstall pgo-gen inst-pgo
  mkdir -p "$srcdir/pgo-gen"
}

_run_driver_workload() {
  local inst_dir="$1"
  command -v Xvfb >/dev/null 2>&1 || { echo "Xvfb not found"; return 0; }
  command -v xinput >/dev/null 2>&1 || { echo "xinput not found"; return 0; }

  local driver_dir
  driver_dir=$(find "$inst_dir" -type d -path "*/xorg/modules/*/input" 2>/dev/null | head -1)

  if [[ -z "$driver_dir" ]]; then
    echo "==> WARNING: Driver directory not found"
    return 0
  fi

  local driver_so
  driver_so=$(find "$driver_dir" -type f -name "*libinput*.so" 2>/dev/null | head -1)

  if [[ -z "$driver_so" || ! -f "$driver_so" ]]; then
    echo "==> WARNING: Driver .so not found"
    return 0
  fi

  echo "==> PGO: Training with driver: $driver_so"

  local d=":95"
  local logfile="${srcdir}/xvfb-pgo.log"
  local xorg_conf="${srcdir}/xorg-pgo.conf"

  cat > "$xorg_conf" << EOF
Section "ServerLayout"
    Identifier "PGOLayout"
    Screen 0 "PGOScreen" 0 0
    InputDevice "Keyboard0" "CoreKeyboard"
    InputDevice "Mouse0" "CorePointer"
EndSection

Section "Files"
    ModulePath "${driver_dir%/input}"
    ModulePath "/usr/lib/xorg/modules"
EndSection

Section "ServerFlags"
    Option "AutoAddDevices" "on"
    Option "AutoEnableDevices" "on"
    Option "AllowEmptyInput" "on"
    Option "AllowMouseOpenFail" "on"
    Option "DontVTSwitch" "on"
    Option "DontZap" "on"
EndSection

Section "InputDevice"
    Identifier "Keyboard0"
    Driver "libinput"
    Option "Device" "/dev/input/event0"
    Option "Ignore" "off"
EndSection

Section "InputDevice"
    Identifier "Mouse0"
    Driver "libinput"
    Option "Device" "/dev/input/mice"
    Option "Ignore" "off"
EndSection

Section "Screen"
    Identifier "PGOScreen"
    Device "Card0"
    DefaultDepth 24
EndSection

Section "Device"
    Identifier "Card0"
    Driver "dummy"
    VideoRam 256000
EndSection
EOF

  local profile_before=0
  if [[ -d "$srcdir/pgo-gen" ]]; then
    profile_before=$(find "$srcdir/pgo-gen" -name "*.profraw" -exec stat -c%s {} + 2>/dev/null | awk '{s+=$1} END {print s+0}')
  fi

  for iter in {1..15}; do
    Xvfb "$d" -screen 0 1920x1080x24 -nolisten tcp -config "$xorg_conf" \
      -modulepath "${driver_dir%/input}:/usr/lib/xorg/modules" \
      -logfile "$logfile" > /dev/null 2>&1 &

    local srv=$!

    for attempt in {1..60}; do
      DISPLAY="$d" xdpyinfo >/dev/null 2>&1 && break
      sleep 0.1
    done

    if ! DISPLAY="$d" xdpyinfo >/dev/null 2>&1; then
      kill "$srv" 2>/dev/null || true
      wait "$srv" 2>/dev/null || true
      continue
    fi

    sleep 0.2

    for round in {1..25}; do
      DISPLAY="$d" xinput --list >/dev/null 2>&1 || true
      DISPLAY="$d" xinput --list --short >/dev/null 2>&1 || true
      DISPLAY="$d" xinput --list --long >/dev/null 2>&1 || true

      local devices
      devices=$(DISPLAY="$d" xinput --list --id-only 2>/dev/null | grep -E '^[0-9]+$')

      for dev in $devices; do
        DISPLAY="$d" xinput --list "$dev" >/dev/null 2>&1 || true
        DISPLAY="$d" xinput --list-props "$dev" >/dev/null 2>&1 || true
        DISPLAY="$d" xinput --query-state "$dev" >/dev/null 2>&1 || true

        local props
        props=$(DISPLAY="$d" xinput --list-props "$dev" 2>/dev/null | grep -oP '(?<=\()[0-9]+(?=\))' | head -15)
        for prop in $props; do
          DISPLAY="$d" xinput --get-prop "$dev" "$prop" >/dev/null 2>&1 || true
        done
      done

      if command -v xdotool >/dev/null 2>&1; then
        DISPLAY="$d" xdotool mousemove 100 100 2>/dev/null || true
        DISPLAY="$d" xdotool mousemove 500 500 2>/dev/null || true
      fi
    done

    kill -TERM "$srv" 2>/dev/null || kill -KILL "$srv" 2>/dev/null || true
    wait "$srv" 2>/dev/null || true
    sleep 0.2
  done

  if [[ -d "$srcdir/pgo-gen" ]]; then
    local profile_after
    profile_after=$(find "$srcdir/pgo-gen" -name "*.profraw" -exec stat -c%s {} + 2>/dev/null | awk '{s+=$1} END {print s+0}')
    local profile_delta=$((profile_after - profile_before))
    echo "==> PGO: Profile data collected: ${profile_delta} bytes"
  fi
}

build() {
  local SAN_CFLAGS="${CFLAGS/-fno-plt}"
  local SAN_CXXFLAGS="${CXXFLAGS/-fno-plt}"
  local SAN_LDFLAGS="${LDFLAGS/-Wl,-z,now}"

  local gen_dir="$srcdir/pgo-gen"
  mkdir -p "$gen_dir" "$srcdir/fakeinstall"

  local c_args_gen="$SAN_CFLAGS $_extra_instr -fprofile-generate=$gen_dir"
  local cxx_args_gen="$SAN_CXXFLAGS $_extra_instr -fprofile-generate=$gen_dir"
  local link_args_gen="$SAN_LDFLAGS -fprofile-generate=$gen_dir"

  echo "==> PASS 1: PGO-instrumented build"
  CFLAGS='' CXXFLAGS='' LDFLAGS='' \
  arch-meson "${_pkgsrc}" "${_pkgsrc}/build-pgo" \
    -Dc_args="$c_args_gen" -Dcpp_args="$cxx_args_gen" \
    -Dc_link_args="$link_args_gen" -Dcpp_link_args="$link_args_gen" \
    -Db_lto=true -Db_pie=false --buildtype=release

  meson compile -C "${_pkgsrc}/build-pgo"

  local inst_pgo="$srcdir/inst-pgo"
  DESTDIR="$inst_pgo" meson install -C "${_pkgsrc}/build-pgo"

  echo "==> PASS 1: PGO training workload"
  _run_driver_workload "$inst_pgo"

  if compgen -G "$gen_dir"/*.profraw >/dev/null 2>&1; then
    local profraw_count profraw_size
    profraw_count=$(find "$gen_dir" -name "*.profraw" | wc -l)
    profraw_size=$(find "$gen_dir" -name "*.profraw" -exec stat -c%s {} + | awk '{s+=$1} END {print s}')

    echo "==> PASS 1: Found $profraw_count profile files, total ${profraw_size} bytes"
    llvm-profdata merge -o "$srcdir/libinput.profdata" "$gen_dir"/*.profraw

    local profdata_size
    profdata_size=$(stat -c%s "$srcdir/libinput.profdata" 2>/dev/null || echo 0)
    echo "==> PASS 1: Merged profile: ${profdata_size} bytes"
  else
    echo "==> PASS 1: No profiles generated, continuing without PGO"
    : > "$srcdir/libinput.profdata" || true
  fi

  local c_args_fin="$SAN_CFLAGS"
  local cxx_args_fin="$SAN_CXXFLAGS"
  local link_args_fin="$SAN_LDFLAGS"

  if [[ -s "$srcdir/libinput.profdata" ]]; then
    c_args_fin+=" -fprofile-use=$srcdir/libinput.profdata -Wno-profile-instr-unprofiled -Wno-profile-instr-out-of-date"
    cxx_args_fin+=" -fprofile-use=$srcdir/libinput.profdata -Wno-profile-instr-unprofiled -Wno-profile-instr-out-of-date"
    link_args_fin+=" -fprofile-use=$srcdir/libinput.profdata"
    echo "==> PASS 2: Building with PGO+LTO optimization"
  else
    echo "==> PASS 2: Building with LTO optimization"
  fi

  CFLAGS='' CXXFLAGS='' LDFLAGS='' \
  arch-meson "${_pkgsrc}" "${_pkgsrc}/build-final" \
    -Dc_args="$c_args_fin" -Dcpp_args="$cxx_args_fin" \
    -Dc_link_args="$link_args_fin" -Dcpp_link_args="$link_args_fin" \
    -Db_lto=true -Db_pie=false --buildtype=release

  meson compile -C "${_pkgsrc}/build-final"
  DESTDIR="$srcdir/fakeinstall" meson install -C "${_pkgsrc}/build-final"

  echo "==> Build complete: PGO+LTO optimized driver"
}

package() {
  cp -a "${srcdir}/fakeinstall"/. "${pkgdir}"/

  cd "${_pkgsrc}"
  install -vDm644 "README.md" "${pkgdir}/usr/share/doc/${pkgname}/README.md"
  install -vDm644 "COPYING" "${pkgdir}/usr/share/licenses/${pkgname}/COPYING"
}
