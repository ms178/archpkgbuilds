_basename="xf86-input-libinput"
pkgname="xlibre-xf86-input-libinput"
pkgver=25.0.0
pkgrel=11
pkgdesc="Generic input driver for the XLibre server based on libinput (CS-PGO optimized)"
arch=('aarch64' 'x86_64')
url="https://github.com/X11Libre/${_basename}/"
license=('MIT')
depends=('glibc' 'libinput')
makedepends=('libx11' 'libxi' 'libxfont2' 'meson>=0.50' 'xlibre-xserver-devel' 'xorgproto'
             'X-ABI-XINPUT_VERSION=26.0'
             'clang' 'llvm' 'lld' 'xorg-server-xvfb' 'xorg-xinput' 'xorg-xdpyinfo'
             'xdotool' 'xorg-xset' 'xorg-xev' 'xorg-xmodmap')
provides=('xf86-input-libinput' 'xf86-input-libinput-xlibre' 'xorg-libinput')
conflicts=("${_basename}" 'xf86-input-libinput-xlibre' 'xorg-server<1.19.0'
           'X-ABI-XINPUT_VERSION<26' 'X-ABI-XINPUT_VERSION>=27')
replaces=('xf86-input-libinput-xlibre')
groups=('xlibre-drivers')
_pkgsrc="${_basename}-xlibre-${_basename}-${pkgver}"
source=("${_pkgsrc}.tar.gz::${url}/archive/refs/tags/xlibre-${_basename}-${pkgver}.tar.gz")
b2sums=('b4a6061dd310c3e900606a128dc28c83b6e0dce6e6aa92e30c1d5788c5f0b6683b41e0e3e24ae8f4cf5014ba217a720240427c9f835038fe1b2794b58a330059')

prepare() {
  rm -rf pgo-profiles cspgo-profiles inst-pgo inst-cspgo inst-final
  mkdir -p "$srcdir"/{pgo-profiles,cspgo-profiles}
  rm -rf "${_pkgsrc}"/build-{pgo,cspgo,final}
}

_run_driver_workload() {
  local inst_dir="$1"
  local iterations="${2:-2}"

  command -v Xvfb >/dev/null 2>&1 || { echo "Xvfb not found"; return 0; }
  command -v xinput >/dev/null 2>&1 || { echo "xinput not found"; return 0; }

  # Find driver - handle XLibre versioned paths (xlibre-25, etc.)
  local driver_so
  driver_so=$(find "$inst_dir" -type f -name "*libinput*.so" 2>/dev/null | head -1)

  if [[ -z "$driver_so" || ! -f "$driver_so" ]]; then
    echo "==> WARNING: Driver .so not found in $inst_dir"
    return 0
  fi

  local driver_dir modules_dir
  driver_dir=$(dirname "$driver_so")
  modules_dir=$(dirname "$driver_dir")

  echo "==> Training: Found driver: $driver_so"
  echo "==> Training: Modules dir: $modules_dir"

  local d=":95"
  local logfile="${srcdir}/xvfb-training.log"
  local xorg_conf="${srcdir}/xorg-training.conf"

  cat > "$xorg_conf" << EOF
Section "ServerLayout"
    Identifier "TrainingLayout"
    Screen 0 "TrainingScreen" 0 0
    InputDevice "Keyboard0" "CoreKeyboard"
    InputDevice "Mouse0" "CorePointer"
EndSection

Section "Files"
    ModulePath "${modules_dir}"
    ModulePath "/usr/lib/xorg/modules"
EndSection

Section "ServerFlags"
    Option "AutoAddDevices" "on"
    Option "AutoEnableDevices" "on"
    Option "AllowEmptyInput" "on"
    Option "AllowMouseOpenFail" "on"
    Option "DontVTSwitch" "on"
    Option "DontZap" "on"
EndSection

Section "InputDevice"
    Identifier "Keyboard0"
    Driver "libinput"
    Option "Device" "/dev/input/event0"
    Option "Ignore" "off"
EndSection

Section "InputDevice"
    Identifier "Mouse0"
    Driver "libinput"
    Option "Device" "/dev/input/mice"
    Option "Ignore" "off"
EndSection

Section "Screen"
    Identifier "TrainingScreen"
    Device "Card0"
    DefaultDepth 24
    SubSection "Display"
        Depth 24
        Modes "1920x1080" "1280x1024" "1024x768"
    EndSubSection
EndSection

Section "Device"
    Identifier "Card0"
    Driver "dummy"
    VideoRam 256000
EndSection
EOF

  echo "==> Training: Running $iterations iterations..."

  for iter in $(seq 1 "$iterations"); do
    echo "==> Training: Iteration $iter/$iterations"

    Xvfb "$d" -screen 0 1920x1080x24 -nolisten tcp -config "$xorg_conf" \
      -modulepath "${modules_dir}:/usr/lib/xorg/modules" \
      -logfile "$logfile" > /dev/null 2>&1 &
    local srv=$!

    local ready=0
    for attempt in {1..80}; do
      if DISPLAY="$d" xdpyinfo >/dev/null 2>&1; then
        ready=1
        break
      fi
      sleep 0.1
    done

    if (( !ready )); then
      kill "$srv" 2>/dev/null || true
      wait "$srv" 2>/dev/null || true
      continue
    fi

    sleep 0.3
    export DISPLAY="$d"

    # ══════════════════════════════════════════════════════════════════════════
    # Device Enumeration
    # ══════════════════════════════════════════════════════════════════════════
    for _ in {1..5}; do
      xinput --list 2>/dev/null || true
      xinput --list --short 2>/dev/null || true
      xinput --list --long 2>/dev/null || true
    done

    local devices
    devices=$(xinput --list --id-only 2>/dev/null | grep -E '^[0-9]+$' || true)

    for dev in $devices; do
      for _ in {1..8}; do
        xinput --list "$dev" 2>/dev/null || true
        xinput --list-props "$dev" 2>/dev/null || true
        xinput --query-state "$dev" 2>/dev/null || true
      done

      local props
      props=$(xinput --list-props "$dev" 2>/dev/null | grep -oP '(?<=\()[0-9]+(?=\))' | head -20 || true)
      for prop in $props; do
        xinput --get-prop "$dev" "$prop" 2>/dev/null || true
      done

      timeout 0.3 xinput --test "$dev" 2>/dev/null || true
      timeout 0.3 xinput --test-xi2 "$dev" 2>/dev/null || true
    done

    # ══════════════════════════════════════════════════════════════════════════
    # Mouse and Keyboard Workload
    # ══════════════════════════════════════════════════════════════════════════
    if command -v xdotool >/dev/null 2>&1; then
      # Mouse movements - linear
      for x in 100 300 500 700 900 1100 1300 1500 1700 1900; do
        xdotool mousemove "$x" 540 2>/dev/null || true
      done
      for y in 100 200 300 400 500 600 700 800 900 1000; do
        xdotool mousemove 960 "$y" 2>/dev/null || true
      done

      # Diagonal movements
      for i in {1..20}; do
        xdotool mousemove $((i * 90)) $((i * 50)) 2>/dev/null || true
      done

      # Rapid relative movements
      for _ in {1..50}; do
        xdotool mousemove_relative -- $((RANDOM % 20 - 10)) $((RANDOM % 20 - 10)) 2>/dev/null || true
      done

      # Edge cases
      xdotool mousemove 0 0 2>/dev/null || true
      xdotool mousemove 1919 1079 2>/dev/null || true

      # Mouse buttons
      for _ in {1..10}; do
        xdotool click 1 2>/dev/null || true
        xdotool click 2 2>/dev/null || true
        xdotool click 3 2>/dev/null || true
      done

      # Double clicks
      for _ in {1..5}; do
        xdotool click --repeat 2 --delay 50 1 2>/dev/null || true
      done

      # Drag operations
      for _ in {1..5}; do
        xdotool mousedown 1 2>/dev/null || true
        xdotool mousemove_relative 100 50 2>/dev/null || true
        xdotool mouseup 1 2>/dev/null || true
      done

      # Scroll
      for _ in {1..15}; do
        xdotool click 4 2>/dev/null || true
        xdotool click 5 2>/dev/null || true
      done

      # Keyboard typing
      xdotool type --delay 10 "The quick brown fox jumps over the lazy dog 1234567890" 2>/dev/null || true
      xdotool type --delay 5 "ABCDEFGHIJKLMNOPQRSTUVWXYZ" 2>/dev/null || true

      # Special keys
      for key in Return Tab space BackSpace Delete Home End Page_Up Page_Down \
                 Left Right Up Down Escape F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12; do
        xdotool key "$key" 2>/dev/null || true
      done

      # Modifier combinations
      for mod in shift ctrl alt super; do
        for key in a b c x z; do
          xdotool key "${mod}+${key}" 2>/dev/null || true
        done
      done
    fi

    # ══════════════════════════════════════════════════════════════════════════
    # XI2 Operations
    # ══════════════════════════════════════════════════════════════════════════
    for dev in $devices; do
      xinput --enable "$dev" 2>/dev/null || true
      xinput --disable "$dev" 2>/dev/null || true
      xinput --enable "$dev" 2>/dev/null || true
      xinput --get-button-map "$dev" 2>/dev/null || true
    done

    if command -v xset >/dev/null 2>&1; then
      xset q 2>/dev/null || true
      xset r rate 250 30 2>/dev/null || true
      xset m 3/1 4 2>/dev/null || true
      xset m default 2>/dev/null || true
    fi

    unset DISPLAY
    kill -TERM "$srv" 2>/dev/null || kill -KILL "$srv" 2>/dev/null || true
    wait "$srv" 2>/dev/null || true
    sleep 0.3
  done

  echo "==> Training: Workload complete"
}

build() {
  # ════════════════════════════════════════════════════════════════════════════
  # Detect LLVM tools from PATH
  # ════════════════════════════════════════════════════════════════════════════
  local _clang _clangxx _llvm_profdata

  _clang=$(command -v clang) || { error "clang not found in PATH"; return 1; }
  _clangxx=$(command -v clang++) || { error "clang++ not found in PATH"; return 1; }
  _llvm_profdata=$(command -v llvm-profdata) || { error "llvm-profdata not found in PATH"; return 1; }

  msg2 "LLVM Toolchain detected:"
  msg2 "  clang:         $_clang ($("$_clang" --version | head -1))"
  msg2 "  llvm-profdata: $_llvm_profdata"

  export CC="$_clang"
  export CXX="$_clangxx"

  local SAN_CFLAGS="${CFLAGS/-fno-plt}"
  local SAN_CXXFLAGS="${CXXFLAGS/-fno-plt}"
  local SAN_LDFLAGS="${LDFLAGS/-Wl,-z,now}"

  local _lld_flags="-fuse-ld=lld"

  local _pgo_dir="$srcdir/pgo-profiles"
  local _cspgo_dir="$srcdir/cspgo-profiles"

  local _meson_common_opts=(
    -D xorg-conf-dir=/usr/share/X11/xorg.conf.d/
  )

  # ════════════════════════════════════════════════════════════════════════════
  # STAGE 1: Standard PGO Instrumented Build
  # ════════════════════════════════════════════════════════════════════════════
  msg2 "STAGE 1/3: Building with PGO instrumentation..."

  local _pgo_gen="-fprofile-generate=$_pgo_dir -fprofile-update=atomic"

  CFLAGS='' CXXFLAGS='' LDFLAGS='' \
  arch-meson "${_pkgsrc}" "${_pkgsrc}/build-pgo" \
    "${_meson_common_opts[@]}" \
    -Dc_args="$SAN_CFLAGS $_pgo_gen" \
    -Dcpp_args="$SAN_CXXFLAGS $_pgo_gen" \
    -Dc_link_args="$SAN_LDFLAGS $_lld_flags $_pgo_gen" \
    -Dcpp_link_args="$SAN_LDFLAGS $_lld_flags $_pgo_gen" \
    -Db_lto=true \
    --buildtype=release

  meson compile -C "${_pkgsrc}/build-pgo"

  local inst_pgo="$srcdir/inst-pgo"
  DESTDIR="$inst_pgo" meson install -C "${_pkgsrc}/build-pgo"

  msg2 "STAGE 1/3: Running PGO training workload..."
  _run_driver_workload "$inst_pgo" 2

  # Merge PGO profiles
  local _pgo_profdata="$_pgo_dir/pgo.profdata"
  if compgen -G "$_pgo_dir"/*.profraw >/dev/null 2>&1; then
    msg2 "STAGE 1/3: Merging PGO profiles..."
    find "$_pgo_dir" -maxdepth 1 -type f -name '*.profraw' \
      | "$_llvm_profdata" merge -o "$_pgo_profdata" -input-files=-
    msg2 "STAGE 1/3: PGO profile: $(du -h "$_pgo_profdata" | cut -f1)"
  else
    warning "No PGO profiles generated"
    touch "$_pgo_profdata"
  fi

  # ════════════════════════════════════════════════════════════════════════════
  # STAGE 2: Context-Sensitive PGO Instrumented Build
  # ════════════════════════════════════════════════════════════════════════════
  msg2 "STAGE 2/3: Building with CS-PGO instrumentation..."

  local _cspgo_gen="-fprofile-use=$_pgo_profdata -fcs-profile-generate=$_cspgo_dir"

  CFLAGS='' CXXFLAGS='' LDFLAGS='' \
  arch-meson "${_pkgsrc}" "${_pkgsrc}/build-cspgo" \
    "${_meson_common_opts[@]}" \
    -Dc_args="$SAN_CFLAGS $_cspgo_gen" \
    -Dcpp_args="$SAN_CXXFLAGS $_cspgo_gen" \
    -Dc_link_args="$SAN_LDFLAGS $_lld_flags $_cspgo_gen" \
    -Dcpp_link_args="$SAN_LDFLAGS $_lld_flags $_cspgo_gen" \
    -Db_lto=true \
    --buildtype=release

  meson compile -C "${_pkgsrc}/build-cspgo"

  local inst_cspgo="$srcdir/inst-cspgo"
  DESTDIR="$inst_cspgo" meson install -C "${_pkgsrc}/build-cspgo"

  msg2 "STAGE 2/3: Running CS-PGO training workload..."
  _run_driver_workload "$inst_cspgo" 2

  # Merge CS-PGO profiles with base PGO
  local _cspgo_profdata="$_cspgo_dir/cspgo.profdata"
  if compgen -G "$_cspgo_dir"/*.profraw >/dev/null 2>&1; then
    msg2 "STAGE 2/3: Merging CS-PGO profiles..."
    find "$_cspgo_dir" -maxdepth 1 -type f -name '*.profraw' \
      | "$_llvm_profdata" merge -o "$_cspgo_profdata" "$_pgo_profdata" -input-files=-
    msg2 "STAGE 2/3: CS-PGO profile: $(du -h "$_cspgo_profdata" | cut -f1)"
  else
    warning "No CS-PGO profiles generated, using standard PGO"
    cp "$_pgo_profdata" "$_cspgo_profdata"
  fi

  # ════════════════════════════════════════════════════════════════════════════
  # STAGE 3: Final CS-PGO Optimized Build
  # ════════════════════════════════════════════════════════════════════════════
  msg2 "STAGE 3/3: Building final CS-PGO optimized binary..."

  local _pgo_use="-fprofile-use=$_cspgo_profdata -Wno-profile-instr-unprofiled -Wno-profile-instr-out-of-date"

  CFLAGS='' CXXFLAGS='' LDFLAGS='' \
  arch-meson "${_pkgsrc}" "${_pkgsrc}/build-final" \
    "${_meson_common_opts[@]}" \
    -Dc_args="$SAN_CFLAGS $_pgo_use" \
    -Dcpp_args="$SAN_CXXFLAGS $_pgo_use" \
    -Dc_link_args="$SAN_LDFLAGS $_lld_flags $_pgo_use" \
    -Dcpp_link_args="$SAN_LDFLAGS $_lld_flags $_pgo_use" \
    -Db_lto=true \
    --buildtype=release

  meson compile -C "${_pkgsrc}/build-final"

  msg "Build complete: CS-PGO + LTO optimized"
}

check() {
  meson test -C "${_pkgsrc}/build-final" --print-errorlogs || true
}

package() {
  DESTDIR="$pkgdir" meson install -C "${_pkgsrc}/build-final"

  # ════════════════════════════════════════════════════════════════════════════
  # Install libinput-properties.h header (required by plasma-desktop, etc.)
  # ════════════════════════════════════════════════════════════════════════════
  local _incdir="$pkgdir/usr/include/xorg"
  mkdir -p "$_incdir"

  local _header_installed
  _header_installed=$(find "$pkgdir" -name "libinput-properties.h" -type f 2>/dev/null | head -1)

  if [[ -n "$_header_installed" && -f "$_header_installed" ]]; then
    if [[ "$_header_installed" != "$_incdir/libinput-properties.h" ]]; then
      msg2 "Copying libinput-properties.h to $_incdir/"
      cp "$_header_installed" "$_incdir/"
    fi
  else
    local _src_header
    _src_header=$(find "$srcdir/${_pkgsrc}" -name "libinput-properties.h" -type f 2>/dev/null | head -1)

    if [[ -n "$_src_header" && -f "$_src_header" ]]; then
      msg2 "Installing libinput-properties.h from source tree..."
      install -Dm644 "$_src_header" "$_incdir/libinput-properties.h"
    else
      error "libinput-properties.h not found!"
      return 1
    fi
  fi

  # ════════════════════════════════════════════════════════════════════════════
  # Verify/Create xorg-libinput.pc
  # ════════════════════════════════════════════════════════════════════════════
  local _pcfile="$pkgdir/usr/lib/pkgconfig/xorg-libinput.pc"

  if [[ ! -f "$_pcfile" ]]; then
    if [[ -f "$pkgdir/usr/share/pkgconfig/xorg-libinput.pc" ]]; then
      mkdir -p "$pkgdir/usr/lib/pkgconfig"
      mv "$pkgdir/usr/share/pkgconfig/xorg-libinput.pc" "$_pcfile"
    fi
  fi

  if [[ ! -f "$_pcfile" ]]; then
    msg2 "Creating xorg-libinput.pc..."
    mkdir -p "$pkgdir/usr/lib/pkgconfig"

    cat > "$_pcfile" << EOF
prefix=/usr
exec_prefix=\${prefix}
libdir=\${exec_prefix}/lib
includedir=\${prefix}/include/xorg
moduledir=\${libdir}/xorg/modules/input

Name: xorg-libinput
Description: X.Org libinput input driver
Version: ${pkgver}
Requires.private: libinput
Cflags: -I\${includedir}
EOF
  else
    if ! grep -q "Cflags:" "$_pcfile"; then
      echo "Cflags: -I\${includedir}" >> "$_pcfile"
    fi
    if ! grep -q "includedir=" "$_pcfile"; then
      sed -i '/^prefix=/a includedir=${prefix}/include/xorg' "$_pcfile"
    fi
  fi

  # ════════════════════════════════════════════════════════════════════════════
  # Verify installation
  # ════════════════════════════════════════════════════════════════════════════
  msg2 "Verifying package contents..."

  local _driver
  _driver=$(find "$pkgdir" -name "libinput_drv.so" -type f 2>/dev/null | head -1)
  if [[ -f "$_driver" ]]; then
    msg2 "  Driver: $_driver ($(du -h "$_driver" | cut -f1))"
  else
    warning "Driver not found!"
  fi

  if [[ -f "$_pcfile" ]]; then
    msg2 "  pkg-config: $_pcfile"
  else
    error "xorg-libinput.pc not installed!"
    return 1
  fi

  if [[ -f "$_incdir/libinput-properties.h" ]]; then
    msg2 "  Header: $_incdir/libinput-properties.h"
  else
    error "libinput-properties.h not installed!"
    return 1
  fi

  cd "${_pkgsrc}"
  install -vDm644 "README.md" "${pkgdir}/usr/share/doc/${pkgname}/README.md"
  install -vDm644 "COPYING" "${pkgdir}/usr/share/licenses/${pkgname}/COPYING"
}
