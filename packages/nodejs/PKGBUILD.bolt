pkgname=nodejs
pkgver=25.3.0
pkgrel=7.5
pkgdesc='Evented I/O for V8 JavaScript (PGO + BOLT; advanced instrumentation)'
arch=('x86_64')
url='https://nodejs.org/'
license=('MIT')
options=('strip')
depends=(
  brotli
  c-ares
  icu
  libnghttp2
  libnghttp3
  libngtcp2
  libuv
  openssl
  zlib
)
makedepends=(
  git
  procps-ng
  python
  clang
  llvm
  lld
)
source=("node::git+https://github.com/nodejs/node.git#tag=v$pkgver?signed")
sha512sums=('SKIP')

# Advanced compile-time instrumentation for higher quality PGO
_extra_instr='-g -fno-omit-frame-pointer -Xclang -mllvm -Xclang -vp-counters-per-site=200 -Xclang -mllvm -Xclang -runtime-counter-relocation -Xclang -mllvm -Xclang -enable-value-profiling'

# Comprehensive, robust training workload
_run_node_workload() {
  local nodebin="$1"

  _rt() {
    local secs="$1"; shift
    echo "Training: $*" >&2
    # Use timeout with SIGKILL to ensure termination
    timeout -k 5s "$secs" "$@" >/dev/null 2>&1 || true
  }

  # V8 optimization tiers and type feedback
  _rt 15 "$nodebin" -e "
    // Warm up V8's optimizer with polymorphic and monomorphic calls
    function hotFunction(x) {
      let sum = 0;
      for (let i = 0; i < 5e5; i++) {
        sum += i % 2 ? x * 1.5 : x * 2;
        if (i % 1000 === 0) Math.sqrt(sum);
      }
      return sum;
    }
    for (let i = 0; i < 30; i++) {
      hotFunction(i);
      hotFunction(i * 1.5);
    }
    if (global.gc) global.gc();
  "

  # Modern JavaScript features (async/await, Promises, classes)
  _rt 20 "$nodebin" -e "
    class DataProcessor {
      constructor() { this.buffer = Buffer.alloc(8192); this.streams = new Map(); }
      async processData(id) {
        return new Promise((resolve) => {
          setImmediate(() => {
            const hash = require('crypto').createHash('sha256');
            for (let i = 0; i < 500; i++) hash.update(this.buffer);
            this.streams.set(id, hash.digest('hex'));
            resolve(id);
          });
        });
      }
    }
    async function runParallel() {
      const processor = new DataProcessor();
      const promises = Array.from({ length: 50 }, (_, i) => processor.processData(i));
      await Promise.all(promises);
    }
    runParallel().catch(() => {});
  "

  # Filesystem I/O with proper error handling
  _rt 25 "$nodebin" -e "
    const fs = require('fs').promises;
    const path = require('path');
    const os = require('os');
    async function fileOps() {
      const tmpDir = path.join(os.tmpdir(), 'node_pgo_' + Math.random().toString(36).slice(2));
      try {
        await fs.mkdir(tmpDir, { recursive: true });
        const files = [];
        for (let i = 0; i < 10; i++) {
          const filePath = path.join(tmpDir, 'file_' + i + '.json');
          const data = { index: i, timestamp: Date.now(), buffer: 'x'.repeat(512), nested: { l1: { l2: Array.from({length: 50}, (_, j) => j) }}};
          await fs.writeFile(filePath, JSON.stringify(data));
          files.push(filePath);
        }
        await Promise.all(files.map(file => fs.readFile(file, 'utf8').then(JSON.parse)));
      } finally {
        await fs.rm(tmpDir, { recursive: true, force: true }).catch(() => {});
      }
    }
    fileOps().catch(() => {});
  "

  # Network simulation with proper server ready detection
  _rt 35 "$nodebin" -e "
    const http = require('http');
    const { once } = require('events');
    async function networkTest() {
      const server = http.createServer((req, res) => {
        req.on('data', () => {}).on('end', () => {
          res.writeHead(200, { 'Content-Type': 'application/json' });
          res.end(JSON.stringify({ ok: true }));
        });
      });
      server.listen(0, 'localhost');
      await once(server, 'listening');
      const port = server.address().port;
      try {
        const requests = Array.from({ length: 30 }, (_, i) => new Promise((resolve) => {
          const req = http.request({ host: 'localhost', port, path: '/test' + i, method: i % 2 ? 'POST' : 'GET' }, (res) => {
            res.on('data', () => {}).on('end', resolve);
          });
          if (i % 2) req.write('data');
          req.end();
        }));
        await Promise.all(requests);
      } finally {
        server.close();
      }
    }
    networkTest().catch(() => {});
  "

  # Crypto and Zlib intensive operations
  _rt 20 "$nodebin" -e "
    const crypto = require('crypto');
    const zlib = require('zlib');
    const data = 'data';
    for (let i = 0; i < 2000; i++) {
      crypto.createHash('sha256').update(data + i).digest();
      if (i % 50 === 0) crypto.createCipheriv('aes-128-gcm', Buffer.alloc(16), Buffer.alloc(12)).update('test').final();
    }
    const compressData = Buffer.alloc(32768, 'c');
    for (let i = 0; i < 50; i++) zlib.gzipSync(compressData);
  "

  # Child process and VM operations
  _rt 15 "$nodebin" -e "
    const { spawn } = require('child_process');
    const vm = require('vm');
    for (let i = 0; i < 50; i++) vm.runInNewContext('a = 1 + 1', {});
    const promises = Array.from({ length: 4 }, () => new Promise(r => spawn(process.execPath, ['-e', 'process.exit(0)']).on('close', r)));
    Promise.all(promises).catch(() => {});
  "
}

build() {
  cd "$srcdir/node"

  local pgo_dir="$srcdir/pgo-profiles"
  mkdir -p "$pgo_dir"

  # --- Shared configure options ---
  local configure_flags=(
    --prefix=/usr
    --with-intl=system-icu
    --without-npm
    --shared-openssl
    --shared-zlib
    --shared-libuv
    --experimental-http-parser
    --shared-nghttp2
    --shared-nghttp3
    --shared-ngtcp2
    --shared-cares
    --shared-brotli
    --without-inspector
  )

  # --- PASS 1: PGO-instrumented build ---
  echo "==> Building PGO-instrumented node..."

  ./configure "${configure_flags[@]}"

  # Set environment for the instrumented build
  export CFLAGS="${CFLAGS} ${_extra_instr} -fprofile-generate=${pgo_dir}"
  export CXXFLAGS="${CXXFLAGS} ${_extra_instr} -fprofile-generate=${pgo_dir}"
  export LDFLAGS="${LDFLAGS} -fprofile-generate=${pgo_dir}"

  make -j"$(nproc)"

  echo "==> Running PGO training workload..."
  local node_gen_bin="$srcdir/node/out/Release/node"
  export LLVM_PROFILE_FILE="$pgo_dir/node.%p.profraw"
  _run_node_workload "$node_gen_bin"

  unset CFLAGS CXXFLAGS LDFLAGS LLVM_PROFILE_FILE

  # Merge profiles
  if ! ls -A "$pgo_dir"/*.profraw &>/dev/null; then
    echo "FEHLER: No PGO profiles were generated. Aborting."
    return 1
  fi

  echo "==> Merging PGO profiles..."
  llvm-profdata merge -o "$srcdir/pgo-merged.profdata" "$pgo_dir"/*.profraw
  echo "PGO profile merged successfully."

  # --- PASS 2: PGO-optimized build with BOLT instrumentation ---
  echo "==> Building PGO-optimized node for BOLT..."

  # Clean the build tree for the next pass
  make clean

  # Set environment for the PGO-use build
  export CFLAGS="${CFLAGS} -fprofile-use=$srcdir/pgo-merged.profdata -Wno-profile-instr-missing -Wno-profile-instr-out-of-date"
  export CXXFLAGS="${CXXFLAGS} -fprofile-use=$srcdir/pgo-merged.profdata -Wno-profile-instr-missing -Wno-profile-instr-out-of-date"
  export LDFLAGS="${LDFLAGS} -fprofile-use=$srcdir/pgo-merged.profdata -Wl,--emit-relocs"

  ./configure "${configure_flags[@]}"

  make -j"$(nproc)"

  unset CFLAGS CXXFLAGS LDFLAGS

  # --- BOLT Optimization ---
  echo "==> Starting BOLT optimization..."
  local bolt_dir="$srcdir/bolt"
  mkdir -p "$bolt_dir"
  local release_dir="$srcdir/node/out/Release"
  local node_bin="$release_dir/node"
  local libnode_so
  libnode_so=$(find "$release_dir" -name 'libnode.so.*' -type f)

  # Save original PGO-optimized binaries
  cp -f "$node_bin" "$bolt_dir/node.pgo"
  [[ -f "$libnode_so" ]] && cp -f "$libnode_so" "$bolt_dir/libnode.so.pgo"

  # Instrument binaries for BOLT
  echo "==> BOLT: Instrumenting binaries..."
  llvm-bolt "$bolt_dir/node.pgo" -instrument -o "$bolt_dir/node.inst" --instrumentation-file="$bolt_dir/node.fdata"
  install -m755 "$bolt_dir/node.inst" "$node_bin"

  if [[ -f "$libnode_so" ]]; then
    llvm-bolt "$bolt_dir/libnode.so.pgo" -instrument -o "$bolt_dir/libnode.so.inst" --instrumentation-file="$bolt_dir/libnode.fdata"
    install -m755 "$bolt_dir/libnode.so.inst" "$libnode_so"
  fi

  # Run BOLT training workload
  echo "==> BOLT: Running training workload..."
  _run_node_workload "$node_bin"

  # Merge BOLT profiles
  echo "==> BOLT: Merging profiles..."
  if ls -A "$bolt_dir"/node.fdata.* &>/dev/null; then
    merge-fdata "$bolt_dir"/node.fdata.* > "$bolt_dir/node.merged.fdata"
  fi
  if [[ -f "$libnode_so" ]] && ls -A "$bolt_dir"/libnode.fdata.* &>/dev/null; then
    merge-fdata "$bolt_dir"/libnode.fdata.* > "$bolt_dir/libnode.merged.fdata"
  fi

  # Optimize binaries with BOLT
  echo "==> BOLT: Optimizing binaries..."
  local bolt_opts=(
    -reorder-blocks=ext-tsp
    -reorder-functions=cdsort
    -split-functions
    -split-all-cold
    -split-eh
    -icf=1
    -jump-tables=aggressive
    -frame-opt=hot
    -peepholes=all
  )

  if [[ -s "$bolt_dir/node.merged.fdata" ]]; then
    llvm-bolt "$bolt_dir/node.pgo" -data="$bolt_dir/node.merged.fdata" -o "$bolt_dir/node.bolt" "${bolt_opts[@]}"
    install -m755 "$bolt_dir/node.bolt" "$node_bin"
  fi

  if [[ -f "$libnode_so" && -s "$bolt_dir/libnode.merged.fdata" ]]; then
    llvm-bolt "$bolt_dir/libnode.so.pgo" -data="$bolt_dir/libnode.merged.fdata" -o "$bolt_dir/libnode.so.bolt" "${bolt_opts[@]}"
    install -m755 "$bolt_dir/libnode.so.bolt" "$libnode_so"
  fi
  echo "BOLT optimization complete."
}

package() {
  cd "$srcdir/node"
  make DESTDIR="$pkgdir" install

  install -Dm644 LICENSE -t "$pkgdir"/usr/share/licenses/$pkgname

  # Ensure libnode.so symlink exists for embedders
  if [[ -f "$libnode_so" ]]; then
    ln -sfr "$pkgdir/usr/lib/$(basename "$libnode_so")" "$pkgdir/usr/lib/libnode.so"
  fi
}
