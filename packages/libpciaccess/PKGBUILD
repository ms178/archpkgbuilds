pkgname=libpciaccess
pkgver=0.18.1
pkgrel=3.5
pkgdesc="X11 PCI access library"
arch=(x86_64)
license=('LicenseRef-libpciaccess')
url="https://gitlab.freedesktop.org/xorg/lib/libpciaccess"
depends=('glibc' 'zlib')
makedepends=('xorg-util-macros' 'meson' 'llvm' 'clang' 'lld' 'ninja' 'python' 'bolt')
source=(https://xorg.freedesktop.org/releases/individual/lib/${pkgname}-${pkgver}.tar.xz{,.sig}
        ms178.patch)
sha512sums=('ef27999446e735df2331e94219ee3dafe9198a2472bb452f63ef9c9c446d5431f9e231e224cfabdeba1402974a5a0064546f9abced4d1770f994f5fc0c2b3310'
            'SKIP'
            'SKIP')
validpgpkeys=('4A193C06D35E7C670FA4EF0BA2FB9E081F2D130E')

_create_test_program() {
    cat > "${1}" << 'EOF'
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <pciaccess.h>
#include <time.h>
#include <unistd.h>

#ifndef PCI_NUM_REGIONS
#define PCI_NUM_REGIONS 6
#endif

void dump_device_info(struct pci_device *dev) {
    printf("PCI Device: %04x:%04x (rev %02x)\n",
        dev->vendor_id, dev->device_id, dev->revision);
    printf("  Class:    %06x\n", dev->device_class);
    printf("  Regions:  %d\n", PCI_NUM_REGIONS);

    for (int i = 0; i < PCI_NUM_REGIONS; i++) {
        if (dev->regions[i].size > 0) {
            printf("    Region %d: base=%llx size=%llx is_IO=%d is_prefetchable=%d\n",
                i, (unsigned long long)dev->regions[i].base_addr,
                (unsigned long long)dev->regions[i].size,
                dev->regions[i].is_IO, dev->regions[i].is_prefetchable);
        }
    }
}

int test_config_access_patterns(struct pci_device *dev) {
    int ret;
    uint32_t value;

    for (int offset = 0; offset < 256; offset += 4) {
        ret = pci_device_cfg_read_u32(dev, &value, offset);
        if (ret != 0) return ret;
    }

    for (int i = 0; i < 50; i++) {
        int offset = (rand() % 64) * 4;
        ret = pci_device_cfg_read_u32(dev, &value, offset);
        if (ret != 0) return ret;
    }

    uint8_t byte_val;
    for (int offset = 0; offset < 64; offset++) {
        ret = pci_device_cfg_read_u8(dev, &byte_val, offset);
        if (ret != 0) return ret;
    }

    uint16_t word_val;
    for (int offset = 0; offset < 64; offset += 2) {
        ret = pci_device_cfg_read_u16(dev, &word_val, offset);
        if (ret != 0) return ret;
    }

    return 0;
}

int main(int argc, char **argv) {
    int ret, i;
    uint32_t value;
    struct pci_device_iterator *iter;
    struct pci_device *dev;

    srand(time(NULL));

    ret = pci_system_init();
    if (ret != 0) {
        fprintf(stderr, "pci_system_init failed: %d\n", ret);
        return 1;
    }

    if (argc < 2) {
        fprintf(stderr, "Usage: %s <command>\n", argv[0]);
        pci_system_cleanup();
        return 1;
    }

    const char *cmd = argv[1];

    iter = pci_slot_match_iterator_create(NULL);
    if (iter == NULL) {
        fprintf(stderr, "Failed to create iterator\n");
        pci_system_cleanup();
        return 1;
    }

    if (strcmp(cmd, "--list") == 0) {
        while ((dev = pci_device_next(iter)) != NULL) {
            printf("%04x:%04x [%04x:%04x] class %06x\n",
                dev->vendor_id, dev->device_id,
                dev->subvendor_id, dev->subdevice_id,
                dev->device_class);
        }
    } else if (strcmp(cmd, "--scan") == 0) {
        while ((dev = pci_device_next(iter)) != NULL) {
            ret = pci_device_probe(dev);
            if (ret == 0) {
                dump_device_info(dev);
            }
        }
    } else if (strcmp(cmd, "--read") == 0 && argc > 3) {
        unsigned int bus = 0, dev_id = 0, func = 0;
        int offset = 0;

        sscanf(argv[2], "%x:%x.%x", &bus, &dev_id, &func);
        offset = strtol(argv[3], NULL, 0);

        struct pci_id_match match = {
            .vendor_id = PCI_MATCH_ANY,
            .device_id = PCI_MATCH_ANY,
            .subvendor_id = PCI_MATCH_ANY,
            .subdevice_id = PCI_MATCH_ANY,
            .device_class = 0,
            .device_class_mask = 0,
            .match_data = 0
        };

        pci_iterator_destroy(iter);
        iter = pci_id_match_iterator_create(&match);
        while ((dev = pci_device_next(iter)) != NULL) {
            if (dev->bus == bus && dev->dev == dev_id && dev->func == func) {
                ret = pci_device_probe(dev);
                if (ret != 0) continue;

                ret = pci_device_cfg_read_u32(dev, &value, offset);
                if (ret == 0) {
                    printf("Value at offset 0x%x: 0x%08x\n", offset, value);
                } else {
                    printf("Failed to read: %d\n", ret);
                }
                break;
            }
        }
    } else if (strcmp(cmd, "--loop") == 0) {
        for (i = 0; i < 100; i++) {
            pci_iterator_destroy(iter);
            iter = pci_slot_match_iterator_create(NULL);

            while ((dev = pci_device_next(iter)) != NULL) {
                pci_device_probe(dev);
                for (int offset = 0; offset < 64; offset += 4) {
                    pci_device_cfg_read_u32(dev, &value, offset);
                }
            }
        }
    } else if (strcmp(cmd, "--vga") == 0) {
        while ((dev = pci_device_next(iter)) != NULL) {
            if ((dev->device_class >> 16) == 0x03) {
                pci_device_probe(dev);
                dump_device_info(dev);
                test_config_access_patterns(dev);
            }
        }
    } else if (strcmp(cmd, "--network") == 0) {
        while ((dev = pci_device_next(iter)) != NULL) {
            if ((dev->device_class >> 16) == 0x02) {
                pci_device_probe(dev);
                dump_device_info(dev);
                test_config_access_patterns(dev);
            }
        }
    } else if (strcmp(cmd, "--stress") == 0) {
        for (int run = 0; run < 5; run++) {
            pci_iterator_destroy(iter);
            iter = pci_slot_match_iterator_create(NULL);

            while ((dev = pci_device_next(iter)) != NULL) {
                pci_device_probe(dev);
                test_config_access_patterns(dev);
            }
        }
    } else if (strcmp(cmd, "--benchmark") == 0) {
        clock_t start = clock();
        int iterations = 1000;

        for (i = 0; i < iterations; i++) {
            pci_iterator_destroy(iter);
            iter = pci_slot_match_iterator_create(NULL);
            dev = pci_device_next(iter);

            if (dev) {
                pci_device_probe(dev);
                for (int offset = 0; offset < 64; offset += 4) {
                    pci_device_cfg_read_u32(dev, &value, offset);
                }
            }
        }

        clock_t end = clock();
        double cpu_time = ((double) (end - start)) / CLOCKS_PER_SEC;
        printf("PCI benchmark: %d iterations in %.6f seconds (%.0f iterations/sec)\n",
               iterations, cpu_time, iterations / cpu_time);
    } else {
        while ((dev = pci_device_next(iter)) != NULL) {
            printf("%04x:%04x [%02x:%02x.%d]\n",
                dev->vendor_id, dev->device_id,
                dev->bus, dev->dev, dev->func);
        }
    }

    pci_iterator_destroy(iter);
    pci_system_cleanup();
    return 0;
}
EOF
}

run_pgo_training() {
    local lib_dir="$1"
    local pgo_dir="$2"
    local scanpci_dir="$3"

    if [[ -z "${scanpci_dir}" ]]; then
        scanpci_dir="${lib_dir}/../scanpci"
    fi

    echo "Running PCI training workload..."

    if [[ -x "${scanpci_dir}/scanpci" ]]; then
        echo "  -> Running native scanpci"
        LD_LIBRARY_PATH="${lib_dir}" "${scanpci_dir}/scanpci" || true
    fi

    if [[ -x "${pgo_dir}/pci_test" ]]; then
        local commands=("--list" "--scan" "--vga" "--network" "--loop" "--stress" "--benchmark")
        for cmd in "${commands[@]}"; do
            echo "  -> Running test ${cmd}"
            LD_LIBRARY_PATH="${lib_dir}" "${pgo_dir}/pci_test" "${cmd}" >/dev/null 2>&1 || true
        done

        for i in {1..10}; do
            LD_LIBRARY_PATH="${lib_dir}" "${pgo_dir}/pci_test" --list >/dev/null 2>&1 || true
            LD_LIBRARY_PATH="${lib_dir}" "${pgo_dir}/pci_test" --scan >/dev/null 2>&1 || true
            LD_LIBRARY_PATH="${lib_dir}" "${pgo_dir}/pci_test" --stress >/dev/null 2>&1 || true
        done
    fi

    echo "Training workload complete"
}

prepare() {
    cd "${srcdir}"

    for src in "${source[@]}"; do
        src="${src%%::*}"
        src="${src##*/}"
        [[ $src = *.patch ]] || continue
        echo "Applying patch: ${src}"
        patch -Np1 -i "${src}"
    done
}

build() {
    cd "${srcdir}/${pkgname}-${pkgver}"

    export CC=clang
    export CXX=clang++
    export AR=llvm-ar
    export NM=llvm-nm
    export RANLIB=llvm-ranlib

    local PGO_DIR="${srcdir}/${pkgname}-pgo"
    local STANDARD_PROFILE_DIR="${PGO_DIR}/standard"
    local CS_PROFILE_DIR="${PGO_DIR}/cs"
    local MERGED_PROFDATA="${PGO_DIR}/merged.profdata"
    local BOLT_PROFILE_DIR="${PGO_DIR}/bolt_profiles"
    local BOLT_FDATA_PCIACCESS="${BOLT_PROFILE_DIR}/libpciaccess.fdata"

    local orig_cflags="${CFLAGS}"
    local orig_cxxflags="${CXXFLAGS}"
    local orig_ldflags="${LDFLAGS}"

    rm -rf "${PGO_DIR}"
    mkdir -p "${STANDARD_PROFILE_DIR}" "${CS_PROFILE_DIR}" "${BOLT_PROFILE_DIR}"

    ###########################################################################
    # Phase 1: Standard PGO Instrumentation Build
    ###########################################################################
    msg2 "Phase 1: Building with standard PGO instrumentation..."

    export CFLAGS="${orig_cflags} -fprofile-generate=${STANDARD_PROFILE_DIR} -fno-omit-frame-pointer -mllvm -vp-counters-per-site=2000"
    export CXXFLAGS="${orig_cxxflags} -fprofile-generate=${STANDARD_PROFILE_DIR} -fno-omit-frame-pointer -mllvm -vp-counters-per-site=2000"
    export LDFLAGS="${orig_ldflags} -fprofile-generate=${STANDARD_PROFILE_DIR}"

    rm -rf "${srcdir}/build_std_pgo"
    meson setup "${srcdir}/build_std_pgo" \
        --prefix=/usr \
        -D b_ndebug=false \
        -D b_pie=false \
        -D c_std=gnu2x \
        -D cpp_std=gnu++2a \
        -D b_lto=true \
        --buildtype=debug \
        --wrap-mode=nofallback

    ninja -C "${srcdir}/build_std_pgo"

    ###########################################################################
    # Phase 1: Standard PGO Training
    ###########################################################################
    msg2 "Phase 1: Running standard PGO training..."

    _create_test_program "${PGO_DIR}/pci_test.c"

    gcc -O2 -o "${PGO_DIR}/pci_test" "${PGO_DIR}/pci_test.c" \
        -I"${srcdir}/${pkgname}-${pkgver}/include" \
        -L"${srcdir}/build_std_pgo/src" \
        -Wl,-rpath,"${srcdir}/build_std_pgo/src" \
        -lpciaccess

    run_pgo_training "${srcdir}/build_std_pgo/src" "${PGO_DIR}" "${srcdir}/build_std_pgo/scanpci"

    meson test -C "${srcdir}/build_std_pgo" --print-errorlogs || true

    msg2 "Phase 1: Merging standard PGO profiles..."
    if ! llvm-profdata merge -output="${PGO_DIR}/standard.profdata" "${STANDARD_PROFILE_DIR}"/*.profraw; then
        error "Standard PGO profile merge failed"
        return 1
    fi

    ###########################################################################
    # Phase 2: Context-sensitive PGO Instrumentation Build
    ###########################################################################
    msg2 "Phase 2: Building with context-sensitive PGO instrumentation..."

    export CFLAGS="${orig_cflags} -fprofile-use=${PGO_DIR}/standard.profdata -fprofile-correction -fcs-profile-generate=${CS_PROFILE_DIR} -fno-omit-frame-pointer -mllvm -vp-counters-per-site=2000"
    export CXXFLAGS="${orig_cxxflags} -fprofile-use=${PGO_DIR}/standard.profdata -fprofile-correction -fcs-profile-generate=${CS_PROFILE_DIR} -fno-omit-frame-pointer -mllvm -vp-counters-per-site=2000"
    export LDFLAGS="${orig_ldflags} -fprofile-use=${PGO_DIR}/standard.profdata -fcs-profile-generate=${CS_PROFILE_DIR}"

    rm -rf "${srcdir}/build_cs_pgo"
    meson setup "${srcdir}/build_cs_pgo" \
        --prefix=/usr \
        -D b_ndebug=false \
        -D b_pie=false \
        -D c_std=gnu2x \
        -D cpp_std=gnu++2a \
        -D b_lto=true \
        --buildtype=debug \
        --wrap-mode=nofallback

    ninja -C "${srcdir}/build_cs_pgo"

    ###########################################################################
    # Phase 2: Context-sensitive PGO Training
    ###########################################################################
    msg2 "Phase 2: Running context-sensitive PGO training..."

    gcc -O2 -o "${PGO_DIR}/pci_test_cs" "${PGO_DIR}/pci_test.c" \
        -I"${srcdir}/${pkgname}-${pkgver}/include" \
        -L"${srcdir}/build_cs_pgo/src" \
        -Wl,-rpath,"${srcdir}/build_cs_pgo/src" \
        -lpciaccess

    run_pgo_training "${srcdir}/build_cs_pgo/src" "${PGO_DIR}" "${srcdir}/build_cs_pgo/scanpci"

    meson test -C "${srcdir}/build_cs_pgo" --print-errorlogs || true

    msg2 "Phase 2: Merging CS-PGO and standard profiles..."
    if ! llvm-profdata merge -output="${MERGED_PROFDATA}" "${CS_PROFILE_DIR}"/*.profraw "${PGO_DIR}/standard.profdata"; then
        error "CS-PGO profile merge failed"
        return 1
    fi

    ###########################################################################
    # Phase 3: Final optimized build with merged profiles
    ###########################################################################
    msg2 "Phase 3: Building final optimized libraries with merged profiles..."

    export CFLAGS="${orig_cflags} -fprofile-use=${MERGED_PROFDATA} -fprofile-correction -fno-common -ffunction-sections -fdata-sections"
    export CXXFLAGS="${orig_cxxflags} -fprofile-use=${MERGED_PROFDATA} -fprofile-correction -fno-common -ffunction-sections -fdata-sections"
    export LDFLAGS="${orig_ldflags} -fprofile-use=${MERGED_PROFDATA} -Wl,--emit-relocs"

    rm -rf "${srcdir}/build_opt"
    meson setup "${srcdir}/build_opt" \
        --prefix=/usr \
        -D b_ndebug=true \
        -D b_pie=false \
        -D c_std=gnu2x \
        -D cpp_std=gnu++2a \
        -D b_lto=true \
        --buildtype=release \
        --wrap-mode=nofallback

    ninja -C "${srcdir}/build_opt"

    ###########################################################################
    # Phase 4: BOLT instrumentation and training (zlib-ng style)
    ###########################################################################
    msg2 "Phase 4: BOLT instrumentation and training..."

    local lib_dir="${srcdir}/build_opt/src"
    local scanpci_dir="${srcdir}/build_opt/scanpci"
    local lib_file
    lib_file=$(readlink -f "${lib_dir}/libpciaccess.so")

    if [[ -z "${lib_file}" || ! -f "${lib_file}" ]]; then
        error "Could not resolve libpciaccess.so in ${lib_dir}"
        return 1
    fi

    cp "${lib_file}" "${lib_file}.cspgo"

    llvm-bolt "${lib_file}.cspgo" \
        --instrument \
        --instrumentation-file-append-pid \
        --instrumentation-file="${BOLT_FDATA_PCIACCESS}" \
        -o "${lib_file}.bolt.inst"

    mv "${lib_file}.bolt.inst" "${lib_file}"

    ln -sf "$(basename "${lib_file}")" "${lib_dir}/libpciaccess.so.0"
    ln -sf "libpciaccess.so.0" "${lib_dir}/libpciaccess.so"

    gcc -O2 -o "${PGO_DIR}/pci_test_bolt" "${PGO_DIR}/pci_test.c" \
        -I"${srcdir}/${pkgname}-${pkgver}/include" \
        -L"${lib_dir}" \
        -Wl,-rpath,"${lib_dir}" \
        -lpciaccess

    BOLT_PROFILE_FILE="${BOLT_FDATA_PCIACCESS}" \
      run_pgo_training "${lib_dir}" "${PGO_DIR}" "${scanpci_dir}"

    if ! compgen -G "${BOLT_FDATA_PCIACCESS}.*" >/dev/null; then
        error "No BOLT .fdata.* profiles found in ${BOLT_PROFILE_DIR}"
        return 1
    fi

    ###########################################################################
    # Phase 5: Merging and applying BOLT profiles (stable flag set)
    ###########################################################################
    msg2 "Phase 5: Merging BOLT profiles..."

    if ! command -v merge-fdata >/dev/null 2>&1; then
        warning "merge-fdata not found, skipping BOLT optimization"
        mv "${lib_file}.cspgo" "${lib_file}"
    else
        local merged_bolt="${PGO_DIR}/bolt_pciaccess_merged.fdata"

        merge-fdata "${BOLT_FDATA_PCIACCESS}".* -o "${merged_bolt}"

        if [[ ! -s "${merged_bolt}" ]]; then
            warning "BOLT profile merge failed for libpciaccess, skipping optimization"
            mv "${lib_file}.cspgo" "${lib_file}"
        else
            msg2 "Phase 5: Applying BOLT optimizations to libpciaccess..." #--hugify causes segfaults

            if llvm-bolt "${lib_file}.cspgo" \
                --data "${merged_bolt}" \
                -o "${lib_file}.bolt" \
                --dyno-stats \
                --lite=false \
                --split-functions \
                --split-strategy=cdsplit \
                --icf=all \
                --plt=all \
                --peepholes=all \
                --indirect-call-promotion=all \
                --reorder-blocks=ext-tsp \
                --reorder-functions=cdsort \
                --x86-strip-redundant-address-size; then
                mv "${lib_file}.bolt" "${lib_file}"
            else
                warning "BOLT optimization failed for libpciaccess, restoring CS-PGO binary"
                mv "${lib_file}.cspgo" "${lib_file}"
            fi
        fi
    fi

    ###########################################################################
    # Phase 6: Verification (runtime smoke checks)
    ###########################################################################
    msg2 "Phase 6: Verifying BOLT output..."

    if ! file "${lib_file}" | grep -q 'ELF 64-bit'; then
        error "Final library is not a valid ELF binary"
        return 1
    fi

    LD_LIBRARY_PATH="${lib_dir}" "${PGO_DIR}/pci_test_bolt" --list >/dev/null 2>&1
    local rc=$?
    if (( rc >= 128 )); then
        error "BOLT-optimized library crashed during verification (exit ${rc})"
        return 1
    fi

    ln -sf "$(basename "${lib_file}")" "${lib_dir}/libpciaccess.so.0"
    ln -sf "libpciaccess.so.0" "${lib_dir}/libpciaccess.so"

    export CFLAGS="${orig_cflags}"
    export CXXFLAGS="${orig_cxxflags}"
    export LDFLAGS="${orig_ldflags}"
}

check() {
    meson test -C "${srcdir}/build_opt" --print-errorlogs || true
}

package() {
    DESTDIR="${pkgdir}" ninja -C "${srcdir}/build_opt" install

    find "${pkgdir}" -type f \( -name '*.so*' -o -name '*.a' -o -executable \) -print0 | \
    while IFS= read -r -d '' file; do
        if file "${file}" | grep -q 'ELF'; then
            llvm-strip --strip-unneeded "${file}" 2>/dev/null || true
        fi
    done

    install -Dm644 "${srcdir}/${pkgname}-${pkgver}/COPYING" \
        -t "${pkgdir}/usr/share/licenses/${pkgname}/"
}
