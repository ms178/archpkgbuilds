pkgname=libpciaccess
pkgver=0.18.1
pkgrel=3.1
pkgdesc="X11 PCI access library"
arch=(x86_64)
license=('LicenseRef-libpciaccess')
url="https://gitlab.freedesktop.org/xorg/lib/libpciaccess"
depends=('glibc' 'zlib')
makedepends=('xorg-util-macros' 'meson' 'llvm' 'clang' 'ninja' 'python')
source=(https://xorg.freedesktop.org/releases/individual/lib/${pkgname}-${pkgver}.tar.xz{,.sig})
sha512sums=('ef27999446e735df2331e94219ee3dafe9198a2472bb452f63ef9c9c446d5431f9e231e224cfabdeba1402974a5a0064546f9abced4d1770f994f5fc0c2b3310'
            'SKIP')
validpgpkeys=('4A193C06D35E7C670FA4EF0BA2FB9E081F2D130E') # Alan Coopersmith <alan.coopersmith@oracle.com>
#validpgpkeys+=('8703B6700E7EE06D7A39B8D6EDAE37B02CEB490D') # "Emil Velikov <emil.l.velikov@gmail.com>"
#validpgpkeys+=('995ED5C8A6138EB0961F18474C09DD83CAAA50B2') # "Adam Jackson <ajax@nwnk.net>"

generate_training_data() {
    local pgo_dir="$1"

    echo "Generating PCI access training data..."
    mkdir -p "${pgo_dir}/training"

    # Create a set of PCI device IDs to test with
    # These include common device types across various categories
    cat > "${pgo_dir}/training/pci_ids.txt" << EOF
# Format: vendor_id device_id
8086 1234 # Intel generic
8086 2922 # Intel SATA controller
8086 10DE # Intel network controller
8086 9A14 # Intel Tigerlake GPU
10DE 2204 # NVIDIA GPU
10DE 1B80 # NVIDIA GTX 1080
1002 67DF # AMD GPU
1002 AAE0 # AMD Network adapter
1022 1630 # AMD Host bridge
14E4 1677 # Broadcom network
8086 3B64 # Intel SATA AHCI Controller
1B36 000D # QEMU virtual PCI bridge
1AF4 1000 # QEMU virtual network
1AF4 1001 # QEMU virtual block device
1AF4 1002 # QEMU virtual balloon
1AF4 1003 # QEMU virtual console
1AF4 1004 # QEMU virtual SCSI controller
1AF4 1005 # QEMU virtual memory balloon
1AF4 1009 # QEMU virtual 9P transport
1AF4 1041 # QEMU virtual RNG
1AF4 1042 # QEMU virtual filesystem
1AF4 1043 # QEMU virtual GPU
1AF4 1044 # QEMU virtual input
1AF4 1045 # QEMU virtual socket
1AF4 1048 # QEMU virtual IOMMU
1AF4 1049 # QEMU virtual memory
1AF4 1050 # QEMU virtual sound
1AF4 1052 # QEMU virtual watchdog
1AF4 1053 # QEMU virtual RPMB
1AF4 1054 # QEMU virtual crypto
1AF4 1110 # QEMU virtual NVME
15AD 0405 # VMware SVGA II
15AD 0710 # VMware PVSCSI
15AD 0720 # VMware VMXNET3
15AD 07A0 # VMware HD Audio
EOF

    # Generate simulated PCI configuration space data
    mkdir -p "${pgo_dir}/training/pci_config"
    for i in {0..255}; do
        # Create sample PCI configuration space (first 256 bytes)
        dd if=/dev/urandom bs=256 count=1 of="${pgo_dir}/training/pci_config/dev_${i}.bin" 2>/dev/null
    done

    # Create PCI device tree simulations (for complex hierarchies)
    mkdir -p "${pgo_dir}/training/pci_tree"

    # Simple flat hierarchy
    cat > "${pgo_dir}/training/pci_tree/simple.txt" << EOF
00:00.0 Host bridge
00:01.0 PCI bridge
00:1c.0 PCI bridge
00:1f.0 ISA bridge
00:1f.2 SATA controller
01:00.0 VGA compatible controller
02:00.0 Ethernet controller
02:00.1 Audio device
EOF

    # Complex multi-level hierarchy
    cat > "${pgo_dir}/training/pci_tree/complex.txt" << EOF
00:00.0 Host bridge
00:01.0 PCI bridge
00:02.0 VGA compatible controller
00:03.0 Audio device
00:14.0 USB controller
00:14.2 RAM memory
00:16.0 Communication controller
00:17.0 SATA controller
00:1c.0 PCI bridge
00:1c.1 PCI bridge
00:1c.4 PCI bridge
00:1c.5 PCI bridge
00:1d.0 PCI bridge
00:1f.0 ISA bridge
00:1f.2 Memory controller
00:1f.3 Audio device
00:1f.4 SMBus
00:1f.5 Serial bus controller
01:00.0 VGA compatible controller
01:00.1 Audio device
02:00.0 Non-Volatile memory controller
03:00.0 Network controller
2e:00.0 Ethernet controller
2f:00.0 Ethernet controller
30:00.0 Non-Volatile memory controller
EOF

    # Generate synthetic PCI regions for memory mapping tests
    mkdir -p "${pgo_dir}/training/pci_regions"
    for region in {0..5}; do
        # Create sample PCI memory regions of varying sizes
        dd if=/dev/urandom bs=1M count=$((region+1)) of="${pgo_dir}/training/pci_regions/region_${region}.bin" 2>/dev/null
    done

    # Generate PCI VPD (Vital Product Data) samples
    mkdir -p "${pgo_dir}/training/pci_vpd"
    for i in {0..10}; do
        dd if=/dev/urandom bs=$((i*256+256)) count=1 of="${pgo_dir}/training/pci_vpd/vpd_${i}.bin" 2>/dev/null
    done

    # Create PCI ROM images for testing
    mkdir -p "${pgo_dir}/training/pci_rom"
    for i in {0..5}; do
        dd if=/dev/urandom bs=$((i*4096+4096)) count=1 of="${pgo_dir}/training/pci_rom/rom_${i}.bin" 2>/dev/null
    done

    # Create device lists for multi-device operations
    cat > "${pgo_dir}/training/device_list.txt" << EOF
# Bus:Device.Function for various operations
00:00.0
00:01.0
00:02.0
01:00.0
02:00.0
03:00.0
00:14.0
00:1f.2
EOF

    echo "Training data generation complete"
}

run_training_workload() {
    local build_dir="$1"
    local pgo_dir="$2"
    local tmpdir="$3"

    echo "Running PCI access training workload..."
    mkdir -p "${tmpdir}/results"

    # Function to test PCI operations
    test_pci_operations() {
        local testname="$1"
        local cmd="$2"

        echo "Running test: ${testname}"
        LD_LIBRARY_PATH="${build_dir}" $cmd > "${tmpdir}/results/${testname}.log" 2>&1 || true
    }

    # Create test program with corrected struct members and function names
    cat > "${tmpdir}/test_pci.c" << 'EOF'
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <pciaccess.h>

// Define number of standard PCI regions if not defined
#ifndef PCI_NUM_REGIONS
#define PCI_NUM_REGIONS 6
#endif

void dump_device_info(struct pci_device *dev) {
    printf("PCI Device: %04x:%04x (rev %02x)\n",
        dev->vendor_id, dev->device_id, dev->revision);
    printf("  Class:    %06x\n", dev->device_class);
    printf("  Regions:  %d\n", PCI_NUM_REGIONS);

    for (int i = 0; i < PCI_NUM_REGIONS; i++) {
        if (dev->regions[i].size > 0) {
            printf("    Region %d: base=%llx size=%llx\n",
                i, (unsigned long long)dev->regions[i].base_addr,
                (unsigned long long)dev->regions[i].size);
        }
    }
}

int main(int argc, char **argv) {
    int ret, i;
    uint32_t value;
    struct pci_device_iterator *iter;
    struct pci_device *dev;

    ret = pci_system_init();
    if (ret != 0) {
        fprintf(stderr, "pci_system_init failed: %d\n", ret);
        return 1;
    }

    // Scan all devices
    iter = pci_slot_match_iterator_create(NULL);
    if (iter == NULL) {
        fprintf(stderr, "Failed to create iterator\n");
        return 1;
    }

    if (argc > 1 && strcmp(argv[1], "--list") == 0) {
        while ((dev = pci_device_next(iter)) != NULL) {
            printf("%04x:%04x [%04x:%04x] class %06x\n",
                dev->vendor_id, dev->device_id,
                dev->subvendor_id, dev->subdevice_id,
                dev->device_class);
        }
    } else if (argc > 1 && strcmp(argv[1], "--scan") == 0) {
        while ((dev = pci_device_next(iter)) != NULL) {
            ret = pci_device_probe(dev);
            if (ret == 0) {
                dump_device_info(dev);
            }
        }
    } else if (argc > 3 && strcmp(argv[1], "--read") == 0) {
        // Read specific device
        unsigned int domain = 0, bus = 0, dev_id = 0, func = 0;
        int offset = 0;

        sscanf(argv[2], "%x:%x.%x", &bus, &dev_id, &func);
        offset = strtol(argv[3], NULL, 0);

        struct pci_id_match match = {
            .vendor_id = PCI_MATCH_ANY,
            .device_id = PCI_MATCH_ANY,
            .subvendor_id = PCI_MATCH_ANY,
            .subdevice_id = PCI_MATCH_ANY,
            .device_class = 0,
            .device_class_mask = 0,
            .match_data = 0
        };

        iter = pci_id_match_iterator_create(&match);
        while ((dev = pci_device_next(iter)) != NULL) {
            if (dev->bus == bus && dev->dev == dev_id && dev->func == func) {
                ret = pci_device_probe(dev);
                if (ret != 0) continue;

                ret = pci_device_cfg_read_u32(dev, &value, offset);
                if (ret == 0) {
                    printf("Value at offset 0x%x: 0x%08x\n", offset, value);
                } else {
                    printf("Failed to read: %d\n", ret);
                }
                break;
            }
        }
    } else if (argc > 1 && strcmp(argv[1], "--loop") == 0) {
        // Heavy load test - iteration over all devices multiple times
        for (i = 0; i < 100; i++) {
            pci_iterator_destroy(iter);
            iter = pci_slot_match_iterator_create(NULL);

            while ((dev = pci_device_next(iter)) != NULL) {
                pci_device_probe(dev);
                // Read device config space
                for (int offset = 0; offset < 64; offset += 4) {
                    pci_device_cfg_read_u32(dev, &value, offset);
                }
            }
        }
    } else if (argc > 1 && strcmp(argv[1], "--vga") == 0) {
        // Find VGA devices
        while ((dev = pci_device_next(iter)) != NULL) {
            if ((dev->device_class >> 8) == 0x0300) { // VGA compatible controller
                pci_device_probe(dev);
                dump_device_info(dev);
            }
        }
    } else if (argc > 1 && strcmp(argv[1], "--network") == 0) {
        // Find network devices
        while ((dev = pci_device_next(iter)) != NULL) {
            if ((dev->device_class >> 8) == 0x0200) { // Network controller
                pci_device_probe(dev);
                dump_device_info(dev);
            }
        }
    } else if (argc > 1 && strcmp(argv[1], "--memory-test") == 0) {
        // Test memory mapping on some devices
        while ((dev = pci_device_next(iter)) != NULL) {
            pci_device_probe(dev);
            for (i = 0; i < PCI_NUM_REGIONS; i++) {
                if (dev->regions[i].size > 0 &&
                    !(dev->regions[i].is_IO) &&
                    dev->regions[i].size < (1024*1024*16)) {
                    void *mapped = NULL;
                    ret = pci_device_map_range(dev,
                                             dev->regions[i].base_addr,
                                             dev->regions[i].size,
                                             PCI_DEV_MAP_FLAG_WRITABLE,
                                             &mapped);
                    if (ret == 0 && mapped != NULL) {
                        // Just access some memory to exercise the mapping
                        volatile unsigned char *ptr = (volatile unsigned char *)mapped;
                        unsigned char val = *ptr;
                        // Don't actually write unless we know it's safe
                        pci_device_unmap_range(dev, mapped, dev->regions[i].size);
                    }
                }
            }
        }
    } else {
        // Default basic info dump
        while ((dev = pci_device_next(iter)) != NULL) {
            printf("%04x:%04x [%02x:%02x.%d]\n",
                dev->vendor_id, dev->device_id,
                dev->bus, dev->dev, dev->func);
        }
    }

    pci_iterator_destroy(iter);
    pci_system_cleanup();
    return 0;
}
EOF

    # Compile the test program
    cd "${tmpdir}"
    gcc -o test_pci test_pci.c -I"${build_dir}/include" -L"${build_dir}" -lpciaccess

    # Run various PCI access patterns
    test_pci_operations "list_all" "./test_pci --list"
    test_pci_operations "scan_all" "./test_pci --scan"
    test_pci_operations "vga_devices" "./test_pci --vga"
    test_pci_operations "network_devices" "./test_pci --network"

    # Run memory-mapped I/O tests if we have permissions
    if [ "$(id -u)" -eq 0 ]; then
        test_pci_operations "memory_mapping" "./test_pci --memory-test"
    fi

    # Heavy load test with multiple iterations
    test_pci_operations "heavy_load" "./test_pci --loop"

    # Test specific devices (will likely fail on most systems without actual hardware, but exercises the code paths)
    while read -r line; do
        # Skip comments and empty lines
        [[ "$line" =~ ^# ]] && continue
        [[ -z "$line" ]] && continue

        # Extract bus:device.function
        if [[ "$line" =~ ^([0-9A-Fa-f]+):([0-9A-Fa-f]+)\.([0-9A-Fa-f]+) ]]; then
            bus="${BASH_REMATCH[1]}"
            dev="${BASH_REMATCH[2]}"
            func="${BASH_REMATCH[3]}"

            # Try reading different offsets in the PCI configuration space
            for offset in 0 4 8 12 16 20 24 28; do
                test_pci_operations "read_${bus}_${dev}_${func}_${offset}" "./test_pci --read ${bus}:${dev}.${func} ${offset}"
            done
        fi
    done < "${pgo_dir}/training/device_list.txt"

    # Test PCI device enumeration speed with repeated scans
    for i in {1..10}; do
        test_pci_operations "enum_speed_${i}" "./test_pci --list"
    done

    echo "Training workload complete"
}
export -f run_training_workload

prepare() {
  mkdir -p build
}

build() {
  cd "${srcdir}/${pkgname}-${pkgver}"

  # Save original flags
  orig_cflags="${CFLAGS}"
  orig_cxxflags="${CXXFLAGS}"
  orig_ldflags="${LDFLAGS}"

  # Set PGO directory
  pgo_dir="/tmp/makepkg/${pkgname}/src/${pkgname}-pgo"
  mkdir -p "${pgo_dir}"

  # PGO instrumentation flags
  _common_instrument_flags=" -g3 -fno-omit-frame-pointer -Xclang -mllvm -Xclang -vp-counters-per-site=50 -mllvm -runtime-counter-relocation -mllvm -enable-value-profiling"

  ###########################################################################
  # Phase 1: Standard PGO Instrumentation Build
  ###########################################################################
  msg2 "== Building with standard PGO instrumentation"

  # Clean previous build artifacts
  rm -rf "${srcdir}/build_std"
  rm -rf "${pgo_dir}/standard"
  mkdir -p "${srcdir}/build_std"
  mkdir -p "${pgo_dir}/standard"

  # Configure with standard instrumentation flags
  export CFLAGS="${orig_cflags}${_common_instrument_flags} -fprofile-generate=${pgo_dir}/standard"
  export CXXFLAGS="${orig_cxxflags}${_common_instrument_flags} -fprofile-generate=${pgo_dir}/standard"
  export LDFLAGS="${orig_ldflags} -fprofile-generate=${pgo_dir}/standard"

  meson setup "${srcdir}/build_std" \
      --prefix=/usr \
      -D b_ndebug=false \
      -D b_pie=false \
      -D c_std=gnu2x \
      -D cpp_std=gnu++2a \
      -D b_lto=true \
      --buildtype=debug \
      --wrap-mode=nofallback

  ninja -C "${srcdir}/build_std"

  ###########################################################################
  # Phase 2: Standard PGO Training
  ###########################################################################
  msg2 "== Running standard PGO training workload"

  # Train the standard version
  export LD_LIBRARY_PATH="${srcdir}/build_std"
  cd "${srcdir}/build_std"
  meson test || true

  # Additional training
  echo "Running PCI access training workload in standard build..."
  test_executables=$(find "${srcdir}/build_std" -type f -executable | grep -v ".so" | sort)
  for test_exe in $test_executables; do
    echo "Running test executable: $test_exe"
    "$test_exe" || true
  done

  cd "${srcdir}/${pkgname}-${pkgver}"

  # Merge standard PGO profiles
  echo "Merging standard PGO profiles..."
  llvm-profdata merge -output="${pgo_dir}/standard.profdata" "${pgo_dir}/standard"

  ###########################################################################
  # Phase 3: Context-sensitive PGO Instrumentation Build (uses standard profiles)
  ###########################################################################
  msg2 "== Building with context-sensitive PGO instrumentation"

  # Clean previous build artifacts
  rm -rf "${srcdir}/build_cs"
  rm -rf "${pgo_dir}/cs"
  mkdir -p "${srcdir}/build_cs"
  mkdir -p "${pgo_dir}/cs"

  # Configure with context-sensitive instrumentation AND standard profile data
  export CFLAGS="${orig_cflags}${_common_instrument_flags} -fprofile-use=${pgo_dir}/standard.profdata -fcs-profile-generate=${pgo_dir}/cs"
  export CXXFLAGS="${orig_cxxflags}${_common_instrument_flags} -fprofile-use=${pgo_dir}/standard.profdata -fcs-profile-generate=${pgo_dir}/cs"
  export LDFLAGS="${orig_ldflags} -fprofile-use=${pgo_dir}/standard.profdata -fcs-profile-generate=${pgo_dir}/cs"

  meson setup "${srcdir}/build_cs" \
      --prefix=/usr \
      -D b_ndebug=false \
      -D b_pie=false \
      -D c_std=gnu2x \
      -D cpp_std=gnu++2a \
      -D b_lto=true \
      --buildtype=debug \
      --wrap-mode=nofallback

  ninja -C "${srcdir}/build_cs"

  ###########################################################################
  # Phase 4: Context-sensitive PGO Training
  ###########################################################################
  msg2 "== Running context-sensitive PGO training workload"

  # Train the context-sensitive version
  export LD_LIBRARY_PATH="${srcdir}/build_cs"
  cd "${srcdir}/build_cs"
  meson test || true

  # Additional training
  echo "Running PCI access training workload in context-sensitive build..."
  test_executables=$(find "${srcdir}/build_cs" -type f -executable | grep -v ".so" | sort)
  for test_exe in $test_executables; do
    echo "Running test executable: $test_exe"
    "$test_exe" || true
  done

  cd "${srcdir}/${pkgname}-${pkgver}"

  # Merge context-sensitive profiles
  echo "Merging context-sensitive PGO profiles..."
  llvm-profdata merge -output="${pgo_dir}/cs.profdata" "${pgo_dir}/cs"

  ###########################################################################
  # Phase 5: Build with PGO Optimization (using both profile types)
  ###########################################################################
  msg2 "== Building with PGO optimization"

  # Clean optimized build directory
  rm -rf "${srcdir}/build_opt"
  mkdir -p "${srcdir}/build_opt"

  # Merge both profiles into a final profile
  llvm-profdata merge -output="${pgo_dir}/merged.profdata" \
    "${pgo_dir}/standard.profdata" "${pgo_dir}/cs.profdata"

  # Configure with profile use flags
  export CFLAGS="${orig_cflags} -fprofile-use=${pgo_dir}/merged.profdata"
  export CXXFLAGS="${orig_cxxflags} -fprofile-use=${pgo_dir}/merged.profdata"
  export LDFLAGS="${orig_ldflags} -fprofile-use=${pgo_dir}/merged.profdata -Wl,--emit-relocs"

  meson setup "${srcdir}/build_opt" \
      --prefix=/usr \
      -D b_ndebug=true \
      -D b_pie=false \
      -D c_std=gnu2x \
      -D cpp_std=gnu++2a \
      -D b_lto=true \
      --buildtype=release \
      --wrap-mode=nofallback

  # Build with profile optimizations
  ninja -C "${srcdir}/build_opt"

  ###########################################################################
  # Phase 6: BOLT Instrumentation
  ###########################################################################
  msg2 "== BOLT instrumentation phase"

  # Find the main library file
  lib_file=$(find "${srcdir}/build_opt" -name "*.so.*" -type f | head -1)
  lib_name=$(basename "$lib_file")
  lib_dir=$(dirname "$lib_file")

  echo "Instrumenting library: ${lib_file}"

  # Create a clean directory for BOLT profile data
  rm -rf "${pgo_dir}/bolt_profiles"
  mkdir -p "${pgo_dir}/bolt_profiles"

  # Instrument the library with BOLT
  llvm-bolt "${lib_file}" \
    --instrument \
    --lite=false \
    --skip-funcs=".text/1" \
    --instrumentation-file="${pgo_dir}/bolt_profiles/profile" \
    -o "${lib_file}.inst"

  # Backup original and replace with instrumented version
  mv "${lib_file}" "${lib_file}.org"
  mv "${lib_file}.inst" "${lib_file}"

  ###########################################################################
  # Phase 7: BOLT Training
  ###########################################################################
  msg2 "== Running BOLT training workload"

  # Set explicit environment variables for instrumentation
  export BOLT_USE_INSTRUMENT=1
  export BOLT_OUTPUT_DIR="${pgo_dir}/bolt_profiles"
  export LD_LIBRARY_PATH="${lib_dir}"

  # Run meson tests as the training workload
  cd "${srcdir}/build_opt"
  meson test || true

  # Also run any test executables to exercise the library
  echo "Running PCI access training workload..."
  test_executables=$(find "${srcdir}/build_opt" -type f -executable | grep -v ".so" | sort)
  for test_exe in $test_executables; do
    echo "Running test executable: $test_exe"
    "$test_exe" || true  # Continue even if test fails
  done

  cd "${srcdir}/${pkgname}-${pkgver}"
  echo "Training workload complete"

  # Debug - list all generated profiles
  echo "BOLT profiles generated:"
  find "${pgo_dir}/bolt_profiles" -type f

  ###########################################################################
  # Phase 8: Merge BOLT Profiles
  ###########################################################################
  msg2 "== Merging BOLT profiles"

  # Only proceed if profiles were generated
  bolt_profiles=$(find "${pgo_dir}/bolt_profiles" -type f)
  if [ -n "$bolt_profiles" ]; then
    # Merge all profiles into one
    merge-fdata ${bolt_profiles} -o "${pgo_dir}/combined.fdata"
    echo "BOLT profiles merged successfully"
  else
    echo "Warning: No BOLT profiles found, skipping optimization"
    cp "${lib_file}.org" "${lib_file}.bolt" || true
    touch "${pgo_dir}/combined.fdata" || true  # Create empty file to prevent failure
  fi

  ###########################################################################
  # Phase 9: Final BOLT Optimization
  ###########################################################################
  msg2 "== Applying final BOLT optimizations"

  # Use combined.fdata and have a fallback if it's missing
  if [ -s "${pgo_dir}/combined.fdata" ]; then
    # Apply BOLT optimizations with profile data
    llvm-bolt "${lib_file}.org" \
      --data="${pgo_dir}/combined.fdata" \
      -o "${lib_file}.bolt" \
      --dyno-stats \
      --frame-opt=all \
      --lite=false \
      --infer-stale-profile=1 \
      --icf=all \
      --plt=all \
      --hugify \
      --peepholes=all \
      --x86-strip-redundant-address-size \
      --indirect-call-promotion=all \
      --reorder-blocks=ext-tsp \
      --reorder-functions=cdsort \
      --split-all-cold \
      --split-eh \
      --split-functions \
      --split-strategy=cdsplit \
      --align-functions=32 \
      --frame-opt-rm-stores \
      --jump-tables=aggressive \
      --skip-funcs=".text/1" \
      --stoke || cp "${lib_file}.org" "${lib_file}.bolt"
  else
    # If no valid profile data, just optimize without profile data
    echo "No valid profile data, applying basic BOLT optimizations"
    llvm-bolt "${lib_file}.org" \
      -o "${lib_file}.bolt" \
      --dyno-stats \
      --reorder-blocks=ext-tsp \
      --split-functions \
      --split-eh \
      --skip-funcs=".text/1" || cp "${lib_file}.org" "${lib_file}.bolt"
  fi

  ###########################################################################
  # Phase 10: Finalize Build
  ###########################################################################
  msg2 "== Finalizing build with optimized library"

  # Replace original library with BOLT-optimized version
  mv "${lib_file}.bolt" "${lib_file}"

  # Fix symlinks if needed
  soname=$(echo "$lib_name" | sed -r 's/libpciaccess\.so\.([0-9]+).*/\1/')
  if [ -n "$soname" ]; then
    cd "${lib_dir}"
    ln -sf "${lib_name}" "libpciaccess.so.${soname}"
    ln -sf "libpciaccess.so.${soname}" "libpciaccess.so"
  fi

  # Restore environment
  cd "${srcdir}"
  export CFLAGS="${orig_cflags}"
  export CXXFLAGS="${orig_cxxflags}"
  export LDFLAGS="${orig_ldflags}"
}

check() {
  meson test -C build_opt
}

package() {
  DESTDIR="$pkgdir" ninja -C build_opt install

  # Use LLVM strip
  find "$pkgdir" -type f \( -name '*.so*' -o -name '*.a' -o -executable \) -print0 | while IFS= read -r -d '' file; do
    if llvm-strip --strip-unneeded "$file" 2>/dev/null || llvm-strip --strip-all "$file" 2>/dev/null; then
      echo "Stripped: $file"
    else
      echo "Skipping: $file (not a valid object file)" >&2
    fi
  done

  install -Dm644 "$pkgname"-$pkgver/COPYING -t "${pkgdir}/usr/share/licenses/${pkgname}/"
}
