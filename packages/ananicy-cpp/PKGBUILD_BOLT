_pkgname=ananicy-cpp
pkgname=ananicy-cpp-git
pkgver=1.1.1.r14.g99e6481
pkgrel=8 # Increment pkgrel for find -delete fix
pkgdesc="Ananicy Cpp is a full rewrite of Ananicy in C++, featuring lower CPU and RAM usage."
arch=(x86_64 i386 armv7h)
url="https://gitlab.com/ananicy-cpp/ananicy-cpp.git"
license=('GPLv3')
depends=(fmt spdlog nlohmann-json systemd libelf zlib libbpf)
makedepends=(cmake ninja clang git nlohmann-json bpf llvm llvm-bolt)
options=(!strip)
optdepends=("ananicy-rules-git: community rules"
            "ananicy-rules: Rules based for ananicy-cpp"
            "jemalloc: Optional, potentially improves llvm-bolt performance during build")
source=("${_pkgname}::git+https://gitlab.com/ananicy-cpp/ananicy-cpp.git"
        "git+https://gitlab.com/vnepogodin/std-format.git"
        "patch.patch::https://raw.githubusercontent.com/CachyOS/ananicy-cpp-git/master/patch.patch" # Example source, adjust if local
        )
sha512sums=('SKIP'
            'SKIP'
            'SKIP' # Checksum for patch.patch if used
            )
provides=('ananicy-cpp')
conflicts=('ananicy-cpp')

# Error handling function (now defined in PKGBUILD)
die() {
    local mesg=$1; shift
    echo -e "\e[1;31m==> ERROR:\e[0m\e[1m ${mesg}\e[0m" "$@" >&2
    exit 1
}

_patch() {
    local patch_file="$1"
    local patch_level="${2:-p1}" # Default to -p1 if not specified
    echo -e "\E[1;33m Applying patch: ${patch_file} with level ${patch_level}\E[0m"
    patch --forward --strip="${patch_level#p}" --input="${srcdir}/${patch_file}" || die "Failed to apply patch: ${patch_file}"
}

pkgver() {
  cd "${srcdir}/${_pkgname}"
  git describe --tags --long | sed 's/^v//;s/\([^-]*-g\)/r\1/;s/-/./g'
}

prepare() {
  cd "${srcdir}/${_pkgname}"
  git submodule init
  git -c protocol.file.allow=always submodule update --init --recursive # Ensure all submodules are fetched

  # Apply original patch if it exists and is specified in source
  if [ -f "${srcdir}/patch.patch" ]; then
    _patch patch.patch p1
  fi

  # Prepare directories with proper permissions
  _build_dir="${srcdir}/${_pkgname}/build"
  _pgo_dir="${srcdir}/${_pkgname}/pgo-data"
  _bolt_data_dir="${srcdir}/${_pkgname}/bolt-data"
  _bolt_binary_dir="${srcdir}/${_pkgname}/bolt-binary"

  # Remove old directories if they exist
  rm -rf "${_build_dir}" "${_pgo_dir}" "${_bolt_data_dir}" "${_bolt_binary_dir}"

  # Create fresh directories with proper permissions
  mkdir -p "${_build_dir}"
  mkdir -p "${_pgo_dir}"
  mkdir -p "${_bolt_data_dir}"
  mkdir -p "${_bolt_binary_dir}"

  # Ensure proper permissions
  chmod 755 "${_build_dir}" "${_pgo_dir}" "${_bolt_data_dir}" "${_bolt_binary_dir}"
}

_run_tests() {
    local build_dir="$1"

    echo "Running tests/benchmarks from: ${build_dir}"

    # Verify binary existence before running
    [ -x "${build_dir}/src/tests/test-core" ] || die "test-core binary not found or not executable in ${build_dir}"
    [ -x "${build_dir}/src/tests/test-utility" ] || die "test-utility binary not found or not executable in ${build_dir}"
    [ -x "${build_dir}/benchmarks/ananicy_cpp_benchmarks" ] || die "benchmarks binary not found or not executable in ${build_dir}"

    # Run tests
    "${build_dir}/src/tests/test-core" || die "core test failed!"
    "${build_dir}/src/tests/test-utility" || die "utility test failed!"
    "${build_dir}/benchmarks/ananicy_cpp_benchmarks" || die "failed on ananicy-cpp benchmarks!"
}

_instrument_binary() {
    local original_binary="$1"
    local instrumentation_file="$2"
    local output_file="$3"

    # Ensure output directory exists
    mkdir -p "$(dirname "${output_file}")"
    mkdir -p "$(dirname "${instrumentation_file}")"

    echo "==== Instrumenting ${original_binary} ===="

    local bolt_common_args=(
        --instrument
        --instrumentation-file-append-pid
        --lite=false
        --instrumentation-file="${instrumentation_file}"
        "${original_binary}"
        -o "${output_file}"
    )

    # Check if jemalloc is available
    if [ -f "/usr/lib/libjemalloc.so" ]; then
      echo "INFO: Using jemalloc for llvm-bolt instrumentation."
      env LD_PRELOAD=/usr/lib/libjemalloc.so llvm-bolt "${bolt_common_args[@]}" || die "Could not create instrumented binary (with jemalloc) from ${original_binary}"
    else
      echo "INFO: jemalloc not found (/usr/lib/libjemalloc.so), running llvm-bolt without LD_PRELOAD."
      llvm-bolt "${bolt_common_args[@]}" || die "Could not create instrumented binary (without jemalloc) from ${original_binary}"
    fi

    # Check if the output file was created (redundant check, but harmless)
    if [ ! -f "${output_file}" ]; then
        die "Output file ${output_file} was not created during instrumentation"
    fi

    # Debug output
    echo "Instrumentation file base: ${instrumentation_file}"
    echo "Output binary created at: ${output_file}"

    # Ensure proper permissions
    chmod 755 "${output_file}"

    echo "==== Done instrumenting ${original_binary} ===="
}


_merge_instrumented_data() {
    local instrumentation_folder="$1"
    local merged_profile="$2"

    echo "==== Merging generated profiles ===="
    mkdir -p "$(dirname "${merged_profile}")"
    echo "Available .fdata files in ${instrumentation_folder}:"
    ls -l "${instrumentation_folder}"/*.fdata* || echo "No .fdata files found, proceeding..."

    shopt -s nullglob
    local fdata_files=("${instrumentation_folder}"/*.fdata*)
    shopt -u nullglob

    if [ ${#fdata_files[@]} -eq 0 ]; then
        die "No .fdata files found in ${instrumentation_folder} to merge."
    fi

    local temp_profile="${merged_profile}.tmp"

    # Merge the profiles with explicit error checking, conditionally using jemalloc
    if [ -f "/usr/lib/libjemalloc.so" ]; then
      echo "INFO: Using jemalloc for merge-fdata."
      if ! env LD_PRELOAD=/usr/lib/libjemalloc.so merge-fdata "${fdata_files[@]}" > "${temp_profile}"; then
          rm -f "${temp_profile}"
          die "Failed to merge fdata files (with jemalloc) from ${instrumentation_folder}"
      fi
    else
      echo "INFO: jemalloc not found (/usr/lib/libjemalloc.so), running merge-fdata without LD_PRELOAD."
       if ! merge-fdata "${fdata_files[@]}" > "${temp_profile}"; then
          rm -f "${temp_profile}"
          die "Failed to merge fdata files (without jemalloc) from ${instrumentation_folder}"
      fi
    fi

    # Rest of the function
    if [ ! -s "${temp_profile}" ]; then
        rm -f "${temp_profile}"
        die "Merged profile ${temp_profile} is empty"
    fi
    mv "${temp_profile}" "${merged_profile}"
    sync
    if [ ! -s "${merged_profile}" ]; then
        die "Final merged profile ${merged_profile} is missing or empty"
    fi
    echo "Merged profile size: $(wc -c < "${merged_profile}") bytes"
    echo "Merged profile location: ${merged_profile}"
    echo "Contents of ${instrumentation_folder} BEFORE cleanup:" # Added for debug
    ls -la "${instrumentation_folder}"
    chmod 644 "${merged_profile}"
    # Delete the original .fdata files, EXCLUDING the merged one
    echo "INFO: Cleaning up original fdata files..."
    find "${instrumentation_folder}" -maxdepth 1 -name '*.fdata*' -not -name "$(basename "${merged_profile}")" -type f -delete # <-- FIXED LINE
    echo "Contents of ${instrumentation_folder} AFTER cleanup:" # Added for debug
    ls -la "${instrumentation_folder}"
    echo "==== Done merging profiles ===="
}


build() {
  cd "${srcdir}/${_pkgname}"
  _build_dir="${srcdir}/${_pkgname}/build"
  _pgo_dir="${srcdir}/${_pkgname}/pgo-data"
  _bolt_data_dir="${srcdir}/${_pkgname}/bolt-data"
  _bolt_binary_dir="${srcdir}/${_pkgname}/bolt-binary"

  # Clean previous build and create directories
  rm -rf "${_build_dir}" "${_pgo_dir}" "${_bolt_data_dir}" "${_bolt_binary_dir}"
  mkdir -p "${_build_dir}" "${_pgo_dir}" "${_bolt_data_dir}" "${_bolt_binary_dir}"

  # Define the CMake argument needed for the dependency
  local cmake_policy_arg="-DCMAKE_POLICY_VERSION_MINIMUM=3.5"

  # 1. First stage: PGO instrumentation
  # Use -- separator to pass the policy argument to CMake via configure.sh
  CFLAGS="${CFLAGS} -fprofile-generate=${_pgo_dir} -g3 -fno-omit-frame-pointer -Xclang -mllvm -Xclang -vp-counters-per-site=50 -Xclang -mllvm -Xclang -runtime-counter-relocation -Xclang -mllvm -Xclang -enable-value-profiling" \
  CXXFLAGS="${CXXFLAGS} -fprofile-generate=${_pgo_dir} -g3 -fno-omit-frame-pointer -Xclang -mllvm -Xclang -vp-counters-per-site=50 -Xclang -mllvm -Xclang -runtime-counter-relocation -Xclang -mllvm -Xclang -enable-value-profiling" \
  LDFLAGS="${LDFLAGS} -fprofile-generate=${_pgo_dir} -g3 -fno-omit-frame-pointer -Xclang -mllvm -Xclang -vp-counters-per-site=50 -Xclang -mllvm -Xclang -runtime-counter-relocation -Xclang -mllvm -Xclang -enable-value-profiling" \
  ./configure.sh \
    --buildtype=Release \
    --builddir="${_build_dir}" \
    --prefix=/usr \
    --use_clang \
    --pgofolder="${_pgo_dir}" \
    --generate_pgo \
    --enable_benchmarks \
    --enable_tests \
    -- \
    "${cmake_policy_arg}" # Pass the arg after --

  ./build.sh

  # 2. Run tests to generate PGO data
  _run_tests "${_build_dir}"

  # 3. Merge PGO data
  llvm-profdata merge -output="${_pgo_dir}/default.profdata" "${_pgo_dir}"/*.profraw || die "Failed to merge PGO data"
  rm -f "${_pgo_dir}"/*.profraw

  # Clean for second stage
  rm -rf "${_build_dir}"
  # Recreate build dir for the next stage
  mkdir -p "${_build_dir}"

  # 4. Second stage: Build with PGO optimization
  # Use -- separator again
  CFLAGS="${CFLAGS//-fprofile-generate=*/ -fprofile-use=${_pgo_dir}/default.profdata}" \
  CXXFLAGS="${CXXFLAGS//-fprofile-generate=*/ -fprofile-use=${_pgo_dir}/default.profdata}" \
  LDFLAGS="${LDFLAGS//-fprofile-generate=*/ -fprofile-use=${_pgo_dir}/default.profdata -Wl,--emit-relocs}" \
  ./configure.sh \
    --buildtype=Release \
    --builddir="${_build_dir}" \
    --prefix=/usr \
    --use_clang \
    --pgofolder="${_pgo_dir}" \
    --use_pgo \
    --enable_relocs \
    --enable_benchmarks \
    --enable_tests \
    -- \
    "${cmake_policy_arg}" # Pass the arg after --

  ./build.sh

  # Ensure main binary exists after PGO build
  [ -x "${_build_dir}/ananicy-cpp" ] || die "Main ananicy-cpp binary not found after PGO build"

  # 5. Instrument binaries for BOLT - maintain directory structure
  _instrument_binary "${_build_dir}/src/tests/test-core" \
    "${_bolt_data_dir}/test-core.fdata" \
    "${_bolt_binary_dir}/src/tests/test-core"

  _instrument_binary "${_build_dir}/src/tests/test-utility" \
    "${_bolt_data_dir}/test-utility.fdata" \
    "${_bolt_binary_dir}/src/tests/test-utility"

  _instrument_binary "${_build_dir}/benchmarks/ananicy_cpp_benchmarks" \
    "${_bolt_data_dir}/ananicy_cpp_benchmarks.fdata" \
    "${_bolt_binary_dir}/benchmarks/ananicy_cpp_benchmarks"

  # 6. Run instrumented tests and benchmarks to generate BOLT data
  _run_tests "${_bolt_binary_dir}"

  # 7. Merge instrumented data
  _merged_profile="${_bolt_data_dir}/bolt-merged.fdata"
  _merge_instrumented_data "${_bolt_data_dir}" "${_merged_profile}"

  # 8. Optimize main binary with BOLT using custom options
  if [ ! -f "${_merged_profile}" ]; then
      # Add extra check for debugging if this happens again
      echo "ERROR: Merged profile check failed. Checking path: ${_merged_profile}" >&2
      ls -la "$(dirname "${_merged_profile}")" >&2
      die "Merged profile ${_merged_profile} not found before BOLT optimization"
  fi

  echo "INFO: Verifying merged profile before BOLT:"
  ls -l "${_merged_profile}"

  # Create BOLT output directory if it doesn't exist
  mkdir -p "$(dirname "${_bolt_binary_dir}/ananicy-cpp.bolt")"

  # Define common BOLT optimization arguments
  local bolt_optimize_args=(
    "${_build_dir}/ananicy-cpp"
    --data "${_merged_profile}"
    -o "${_bolt_binary_dir}/ananicy-cpp.bolt"
    --dyno-stats
    --lite=false
    --cu-processing-batch-size=64
    --eliminate-unreachable
    --frame-opt=all
    --icf=1
    --jump-tables=aggressive
    --min-branch-clusters
    --stoke
    --sctc-mode=always
    --plt=all
    --hot-data
    --hot-text
    --frame-opt-rm-stores
    --peepholes=all
    --infer-stale-profile=1
    --x86-strip-redundant-address-size
    --indirect-call-promotion=all
    --reg-reassign
    --use-aggr-reg-reassign
    --reorder-blocks=ext-tsp
    --reorder-functions=cdsort
    --split-all-cold
    --split-eh
    --split-functions
    --split-strategy=cdsplit
  )

  # Check if jemalloc is available and run BOLT optimization accordingly
  if [ -f "/usr/lib/libjemalloc.so" ]; then
    echo "INFO: Using jemalloc for llvm-bolt optimization."
    env LD_PRELOAD=/usr/lib/libjemalloc.so llvm-bolt "${bolt_optimize_args[@]}" || die "BOLT optimization failed (with jemalloc) for ananicy-cpp"
  else
    echo "INFO: jemalloc not found (/usr/lib/libjemalloc.so), running llvm-bolt optimization without LD_PRELOAD."
    llvm-bolt "${bolt_optimize_args[@]}" || die "BOLT optimization failed (without jemalloc) for ananicy-cpp"
  fi


  # Verify BOLT output was created
  if [ ! -f "${_bolt_binary_dir}/ananicy-cpp.bolt" ]; then
      die "BOLT failed to create output binary ananicy-cpp.bolt"
  fi

  # 9. Move the final BOLTed binary to the build directory for packaging
  mv "${_bolt_binary_dir}/ananicy-cpp.bolt" "${_build_dir}/ananicy-cpp" || die "Failed to move BOLTed binary"
  chmod 755 "${_build_dir}/ananicy-cpp"
}

check() {
  # Check relies on the PGO-optimized build before BOLT instrumentation/optimization
  cd "${srcdir}/${_pkgname}"
  _build_dir="${srcdir}/${_pkgname}/build"
  _pgo_dir="${srcdir}/${_pkgname}/pgo-data"
  local cmake_policy_arg="-DCMAKE_POLICY_VERSION_MINIMUM=3.5" # Need this for potential rebuild

  # Check if the PGO build directory exists and contains the necessary files
  if [ ! -d "${_build_dir}" ] || \
     [ ! -x "${_build_dir}/src/tests/test-core" ] || \
     [ ! -x "${_build_dir}/src/tests/test-utility" ] || \
     [ ! -x "${_build_dir}/benchmarks/ananicy_cpp_benchmarks" ]; then
    echo "Build directory for check() not found or incomplete, rebuilding PGO stage..."
    rm -rf "${_build_dir}"
    mkdir -p "${_build_dir}"

    # Rebuild the PGO stage, passing the policy arg again after --
    CFLAGS="${CFLAGS//-fprofile-generate=*/ -fprofile-use=${_pgo_dir}/default.profdata}" \
    CXXFLAGS="${CXXFLAGS//-fprofile-generate=*/ -fprofile-use=${_pgo_dir}/default.profdata}" \
    LDFLAGS="${LDFLAGS//-fprofile-generate=*/ -fprofile-use=${_pgo_dir}/default.profdata -Wl,--emit-relocs}" \
    ./configure.sh \
      --buildtype=Release \
      --builddir="${_build_dir}" \
      --prefix=/usr \
      --use_clang \
      --pgofolder="${_pgo_dir}" \
      --use_pgo \
      --enable_relocs \
      --enable_benchmarks \
      --enable_tests \
      -- \
      "${cmake_policy_arg}" # Pass the arg after --
    ./build.sh
  fi

  echo "Running checks on PGO-optimized build..."
  _run_tests "${_build_dir}"
}

package() {
  cd "${srcdir}/${_pkgname}/build"
  DESTDIR="${pkgdir}" cmake --install . --component Runtime

  install -m755 -d "${pkgdir}/etc/ananicy.d"

  # Use llvm-strip only on recognized file formats
  if ! command -v llvm-strip &> /dev/null; then
      echo "WARNING: llvm-strip command not found. Skipping stripping. Please install llvm." >&2
      return 0 # Don't fail the package build if strip isn't found
  fi

  find "$pkgdir" -type f \( -name '*.so*' -o -name '*.a' -o -executable \) -print0 | while IFS= read -r -d '' file; do
    # Check if file is an ELF executable or shared object before stripping
    if file -b "$file" | grep -qE 'ELF.*(executable|shared object)'; then
      if llvm-strip --strip-unneeded "$file" 2>/dev/null; then
        echo "Stripped (unneeded): $file"
      elif llvm-strip --strip-all "$file" 2>/dev/null; then
         echo "Stripped (all): $file"
      else
        echo "WARNING: Failed to strip $file" >&2
      fi
    else
      echo "Skipping strip: $file (not an ELF executable or shared object)" >&2
    fi
  done
}
