# Maintainer: Chocobo1 <chocobo1 AT archlinux DOT net>
# PGO Optimization: CachyOS

pkgname=libxi-git
pkgver=1.8.2.r1.g3103b58
pkgrel=1
pkgdesc="X11 Input extension library (PGO/CS-PGO optimized)"
arch=('i686' 'x86_64')
url="https://www.x.org/wiki/"
license=('custom')
depends=('glibc' 'libxext' 'xorgproto')
makedepends=('git' 'libxfixes' 'xorg-util-macros' 'clang' 'llvm')
provides=('libxi')
conflicts=('libxi')
options=('staticlibs')
source=("git+https://gitlab.freedesktop.org/xorg/lib/libxi.git")
sha256sums=('SKIP')

pkgver() {
  cd "libxi"

  git describe --long --tags | sed 's/^libXi-//;s/\([^-]*-g\)/r\1/;s/-/./g'
}

prepare() {
  cd "libxi"
  autoreconf -vfi

  # Generate comprehensive PGO training workload for XI2
  cat > "${srcdir}/xi_pgo_workload.c" << 'EOF'
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <X11/Xlib.h>
#include <X11/extensions/XInput2.h>

#define WORKLOAD_ITERATIONS 3
#define SYNC_INTERVAL 50

/* Global error flag */
static int x_error_occurred = 0;

/* Custom X error handler to prevent crashes */
static int xi_error_handler(Display *dpy, XErrorEvent *event) {
    x_error_occurred = 1;
    /* Just log and continue - don't crash */
    fprintf(stderr, "X Error (ignored): request=%d, error=%d\n",
            event->request_code, event->error_code);
    return 0;
}

/* Sync with X server periodically to prevent buffer issues */
static inline void maybe_sync(Display *dpy, int counter) {
    if (counter % SYNC_INTERVAL == 0) {
        XSync(dpy, False);
    }
}

/* Exercise extension and version queries */
static void train_extension_queries(Display *dpy, int iterations) {
    int i;
    int xi_opcode, event, error;
    int major, minor;

    for (i = 0; i < iterations; i++) {
        /* Query extension presence */
        XQueryExtension(dpy, "XInputExtension", &xi_opcode, &event, &error);

        /* Query XI2 version */
        major = 2;
        minor = 4;
        XIQueryVersion(dpy, &major, &minor);

        maybe_sync(dpy, i);
    }
}

/* Exercise device enumeration and info queries */
static void train_device_queries(Display *dpy, int iterations) {
    int i, j;
    int ndevices;
    XIDeviceInfo *devices;

    for (i = 0; i < iterations; i++) {
        /* Query all devices */
        devices = XIQueryDevice(dpy, XIAllDevices, &ndevices);
        if (devices) {
            for (j = 0; j < ndevices; j++) {
                XIDeviceInfo *dev = &devices[j];

                /* Access device info fields */
                volatile int deviceid = dev->deviceid;
                volatile const char *name = dev->name;
                volatile int use = dev->use;
                volatile int attachment = dev->attachment;
                volatile Bool enabled = dev->enabled;
                volatile int num_classes = dev->num_classes;

                (void)deviceid; (void)name; (void)use;
                (void)attachment; (void)enabled; (void)num_classes;

                /* Examine device classes */
                int k;
                for (k = 0; k < dev->num_classes; k++) {
                    XIAnyClassInfo *class = dev->classes[k];
                    volatile int type = class->type;
                    volatile int sourceid = class->sourceid;
                    (void)type; (void)sourceid;

                    switch (class->type) {
                        case XIKeyClass: {
                            XIKeyClassInfo *key = (XIKeyClassInfo *)class;
                            volatile int num_keycodes = key->num_keycodes;
                            (void)num_keycodes;
                            break;
                        }
                        case XIButtonClass: {
                            XIButtonClassInfo *btn = (XIButtonClassInfo *)class;
                            volatile int num_buttons = btn->num_buttons;
                            (void)num_buttons;
                            break;
                        }
                        case XIValuatorClass: {
                            XIValuatorClassInfo *val = (XIValuatorClassInfo *)class;
                            volatile int number = val->number;
                            volatile double min = val->min;
                            volatile double max = val->max;
                            volatile double value = val->value;
                            volatile int resolution = val->resolution;
                            volatile int mode = val->mode;
                            (void)number; (void)min; (void)max;
                            (void)value; (void)resolution; (void)mode;
                            break;
                        }
                        case XIScrollClass: {
                            XIScrollClassInfo *scroll = (XIScrollClassInfo *)class;
                            volatile int number = scroll->number;
                            volatile int scroll_type = scroll->scroll_type;
                            volatile double increment = scroll->increment;
                            volatile int flags = scroll->flags;
                            (void)number; (void)scroll_type;
                            (void)increment; (void)flags;
                            break;
                        }
                        case XITouchClass: {
                            XITouchClassInfo *touch = (XITouchClassInfo *)class;
                            volatile int mode = touch->mode;
                            volatile int num_touches = touch->num_touches;
                            (void)mode; (void)num_touches;
                            break;
                        }
                    }
                }
            }
            XIFreeDeviceInfo(devices);
        }

        /* Query master devices only */
        devices = XIQueryDevice(dpy, XIAllMasterDevices, &ndevices);
        if (devices) {
            XIFreeDeviceInfo(devices);
        }

        maybe_sync(dpy, i);
    }
}

/* Exercise individual device queries */
static void train_individual_device_queries(Display *dpy, int iterations) {
    int i, j;
    int ndevices;
    XIDeviceInfo *all_devices;

    /* Get device list first */
    all_devices = XIQueryDevice(dpy, XIAllDevices, &ndevices);
    if (!all_devices || ndevices == 0) return;

    for (i = 0; i < iterations; i++) {
        /* Query each device individually */
        for (j = 0; j < ndevices && j < 10; j++) {
            int deviceid = all_devices[j].deviceid;
            int count;
            XIDeviceInfo *dev = XIQueryDevice(dpy, deviceid, &count);
            if (dev) {
                XIFreeDeviceInfo(dev);
            }
        }
        maybe_sync(dpy, i);
    }

    XIFreeDeviceInfo(all_devices);
}

/* Exercise device property queries */
static void train_device_properties(Display *dpy, int iterations) {
    int i, j, k;
    int ndevices;
    XIDeviceInfo *devices;

    devices = XIQueryDevice(dpy, XIAllDevices, &ndevices);
    if (!devices) return;

    for (i = 0; i < iterations; i++) {
        for (j = 0; j < ndevices && j < 5; j++) {
            int deviceid = devices[j].deviceid;
            int nprops = 0;
            Atom *props = XIListProperties(dpy, deviceid, &nprops);

            if (props && nprops > 0) {
                /* Query first few properties */
                int max_props = nprops < 5 ? nprops : 5;
                for (k = 0; k < max_props; k++) {
                    Atom type_return;
                    int format_return;
                    unsigned long num_items, bytes_after;
                    unsigned char *data = NULL;

                    if (XIGetProperty(dpy, deviceid, props[k],
                                     0, 100, False, AnyPropertyType,
                                     &type_return, &format_return,
                                     &num_items, &bytes_after, &data) == Success) {
                        if (data) {
                            XFree(data);
                        }
                    }
                }
                XFree(props);
            }
        }
        maybe_sync(dpy, i);
    }

    XIFreeDeviceInfo(devices);
}

/* Exercise event mask operations - FIXED: separate masks for global vs device-specific events */
static void train_event_masks(Display *dpy, Window root, int iterations) {
    int i, j;
    int ndevices;
    XIDeviceInfo *devices;
    XIEventMask mask;
    unsigned char global_mask_data[XIMaskLen(XI_LASTEVENT)];
    unsigned char device_mask_data[XIMaskLen(XI_LASTEVENT)];

    devices = XIQueryDevice(dpy, XIAllMasterDevices, &ndevices);
    if (!devices) return;

    for (i = 0; i < iterations; i++) {
        /* Global event mask (for XIAllDevices/XIAllMasterDevices only) */
        /* Includes hierarchy and property events which are global-only */
        memset(global_mask_data, 0, sizeof(global_mask_data));
        XISetMask(global_mask_data, XI_Motion);
        XISetMask(global_mask_data, XI_ButtonPress);
        XISetMask(global_mask_data, XI_ButtonRelease);
        XISetMask(global_mask_data, XI_KeyPress);
        XISetMask(global_mask_data, XI_KeyRelease);
        XISetMask(global_mask_data, XI_Enter);
        XISetMask(global_mask_data, XI_Leave);
        XISetMask(global_mask_data, XI_FocusIn);
        XISetMask(global_mask_data, XI_FocusOut);
        XISetMask(global_mask_data, XI_HierarchyChanged);  /* Global only */
        XISetMask(global_mask_data, XI_PropertyEvent);     /* Global only */

        mask.deviceid = XIAllDevices;
        mask.mask_len = sizeof(global_mask_data);
        mask.mask = global_mask_data;

        XISelectEvents(dpy, root, &mask, 1);
        XSync(dpy, False);

        /* Device-specific event mask (NO hierarchy/property events) */
        memset(device_mask_data, 0, sizeof(device_mask_data));
        XISetMask(device_mask_data, XI_Motion);
        XISetMask(device_mask_data, XI_ButtonPress);
        XISetMask(device_mask_data, XI_ButtonRelease);
        XISetMask(device_mask_data, XI_KeyPress);
        XISetMask(device_mask_data, XI_KeyRelease);
        XISetMask(device_mask_data, XI_Enter);
        XISetMask(device_mask_data, XI_Leave);

        mask.mask_len = sizeof(device_mask_data);
        mask.mask = device_mask_data;

        /* Select for specific master devices */
        for (j = 0; j < ndevices && j < 3; j++) {
            mask.deviceid = devices[j].deviceid;
            XISelectEvents(dpy, root, &mask, 1);
        }
        XSync(dpy, False);

        /* Query current event mask */
        XIEventMask *masks = NULL;
        int nmasks = 0;
        masks = XIGetSelectedEvents(dpy, root, &nmasks);
        if (masks) {
            XFree(masks);
        }

        /* Clear event masks */
        memset(global_mask_data, 0, sizeof(global_mask_data));
        mask.deviceid = XIAllDevices;
        mask.mask_len = sizeof(global_mask_data);
        mask.mask = global_mask_data;
        XISelectEvents(dpy, root, &mask, 1);
        XSync(dpy, False);

        maybe_sync(dpy, i);
    }

    XIFreeDeviceInfo(devices);
}

/* Exercise hierarchy queries */
static void train_hierarchy(Display *dpy, int iterations) {
    int i;
    int ndevices;
    XIDeviceInfo *devices;

    for (i = 0; i < iterations; i++) {
        /* Query full hierarchy */
        devices = XIQueryDevice(dpy, XIAllDevices, &ndevices);
        if (devices) {
            /* Find master-slave relationships */
            int j;
            for (j = 0; j < ndevices; j++) {
                if (devices[j].use == XIMasterPointer ||
                    devices[j].use == XIMasterKeyboard) {
                    /* This is a master device */
                    volatile int master_id = devices[j].deviceid;
                    (void)master_id;
                } else if (devices[j].use == XISlavePointer ||
                           devices[j].use == XISlaveKeyboard) {
                    /* This is a slave device, check attachment */
                    volatile int slave_id = devices[j].deviceid;
                    volatile int attached_to = devices[j].attachment;
                    (void)slave_id; (void)attached_to;
                } else if (devices[j].use == XIFloatingSlave) {
                    /* Floating slave */
                    volatile int floating_id = devices[j].deviceid;
                    (void)floating_id;
                }
            }
            XIFreeDeviceInfo(devices);
        }
        maybe_sync(dpy, i);
    }
}

/* Exercise focus queries */
static void train_focus_queries(Display *dpy, int iterations) {
    int i;
    int ndevices;
    XIDeviceInfo *devices;

    devices = XIQueryDevice(dpy, XIAllMasterDevices, &ndevices);
    if (!devices) return;

    for (i = 0; i < iterations; i++) {
        int j;
        for (j = 0; j < ndevices; j++) {
            /* Only query focus for keyboard devices */
            if (devices[j].use == XIMasterKeyboard) {
                Window focus_return;

                x_error_occurred = 0;
                XIGetFocus(dpy, devices[j].deviceid, &focus_return);
                XSync(dpy, False);
                (void)focus_return;
            }
        }
        maybe_sync(dpy, i);
    }

    XIFreeDeviceInfo(devices);
}

/* Exercise pointer queries */
static void train_pointer_queries(Display *dpy, Window root, int iterations) {
    int i;
    int ndevices;
    XIDeviceInfo *devices;

    devices = XIQueryDevice(dpy, XIAllMasterDevices, &ndevices);
    if (!devices) return;

    for (i = 0; i < iterations; i++) {
        int j;
        for (j = 0; j < ndevices; j++) {
            /* Only query pointer for pointer devices */
            if (devices[j].use == XIMasterPointer) {
                Window root_return, child_return;
                double root_x, root_y, win_x, win_y;
                XIButtonState buttons;
                XIModifierState mods;
                XIGroupState group;

                memset(&buttons, 0, sizeof(buttons));

                x_error_occurred = 0;
                if (XIQueryPointer(dpy, devices[j].deviceid, root,
                                   &root_return, &child_return,
                                   &root_x, &root_y, &win_x, &win_y,
                                   &buttons, &mods, &group)) {
                    /* Access returned values */
                    volatile double rx = root_x;
                    volatile double ry = root_y;
                    volatile Window cr = child_return;
                    (void)rx; (void)ry; (void)cr;

                    /* Free button state mask if allocated */
                    if (buttons.mask) {
                        XFree(buttons.mask);
                    }
                }
            }
        }
        maybe_sync(dpy, i);
    }

    XIFreeDeviceInfo(devices);
}

/* Exercise grab parameter preparation (without actually grabbing) */
static void train_grab_params(Display *dpy, Window root, int iterations) {
    int i;
    XIGrabModifiers modifiers[4];
    unsigned char mask_data[XIMaskLen(XI_LASTEVENT)];
    XIEventMask mask;

    memset(mask_data, 0, sizeof(mask_data));
    XISetMask(mask_data, XI_ButtonPress);
    XISetMask(mask_data, XI_ButtonRelease);
    XISetMask(mask_data, XI_Motion);

    mask.deviceid = XIAllMasterDevices;
    mask.mask_len = sizeof(mask_data);
    mask.mask = mask_data;

    /* Setup grab modifiers */
    modifiers[0].modifiers = XIAnyModifier;
    modifiers[1].modifiers = 0;
    modifiers[2].modifiers = ShiftMask;
    modifiers[3].modifiers = ControlMask;

    for (i = 0; i < iterations; i++) {
        /* Just prepare the structures without grabbing */
        /* This exercises the library's internal handling */
        int j;
        for (j = 0; j < 4; j++) {
            volatile int mod = modifiers[j].modifiers;
            (void)mod;
        }

        volatile int mask_len = mask.mask_len;
        volatile int deviceid = mask.deviceid;
        (void)mask_len; (void)deviceid;

        maybe_sync(dpy, i);
    }
}

/* Exercise client pointer operations */
static void train_client_pointer(Display *dpy, int iterations) {
    int i;
    int ndevices;
    XIDeviceInfo *devices;

    for (i = 0; i < iterations; i++) {
        /* Get client pointer */
        int client_pointer = 0;

        x_error_occurred = 0;
        XIGetClientPointer(dpy, None, &client_pointer);
        XSync(dpy, False);

        if (!x_error_occurred && client_pointer > 0) {
            /* Verify it's a valid master pointer */
            devices = XIQueryDevice(dpy, client_pointer, &ndevices);
            if (devices) {
                volatile int use = devices[0].use;
                (void)use;
                XIFreeDeviceInfo(devices);
            }
        }

        maybe_sync(dpy, i);
    }
}

/* Exercise modifier and button state queries */
static void train_state_queries(Display *dpy, Window root, int iterations) {
    int i;
    int ndevices;
    XIDeviceInfo *devices;

    devices = XIQueryDevice(dpy, XIAllMasterDevices, &ndevices);
    if (!devices) return;

    for (i = 0; i < iterations; i++) {
        int j;
        for (j = 0; j < ndevices; j++) {
            Window root_return, child_return;
            double root_x, root_y, win_x, win_y;
            XIButtonState buttons;
            XIModifierState mods;
            XIGroupState group;

            memset(&buttons, 0, sizeof(buttons));

            if (devices[j].use == XIMasterPointer) {
                x_error_occurred = 0;
                if (XIQueryPointer(dpy, devices[j].deviceid, root,
                                   &root_return, &child_return,
                                   &root_x, &root_y, &win_x, &win_y,
                                   &buttons, &mods, &group)) {
                    /* Access modifier state */
                    volatile int base = mods.base;
                    volatile int latched = mods.latched;
                    volatile int locked = mods.locked;
                    volatile int effective = mods.effective;
                    (void)base; (void)latched; (void)locked; (void)effective;

                    /* Access group state */
                    volatile int g_base = group.base;
                    volatile int g_latched = group.latched;
                    volatile int g_locked = group.locked;
                    volatile int g_effective = group.effective;
                    (void)g_base; (void)g_latched; (void)g_locked; (void)g_effective;

                    if (buttons.mask) {
                        XFree(buttons.mask);
                    }
                }
            }
        }
        maybe_sync(dpy, i);
    }

    XIFreeDeviceInfo(devices);
}

int main(int argc, char **argv) {
    Display *dpy;
    Window root;
    int screen;
    int xi_opcode, event, error;
    int major = 2, minor = 2;
    int iterations = argc > 1 ? atoi(argv[1]) : WORKLOAD_ITERATIONS;

    fprintf(stderr, "XI2 PGO Training starting...\n");

    dpy = XOpenDisplay(NULL);
    if (!dpy) {
        fprintf(stderr, "Cannot open display, skipping XI2 training\n");
        return 0;
    }

    /* Set custom error handler to prevent crashes */
    XSetErrorHandler(xi_error_handler);

    /* Check for XInput extension */
    if (!XQueryExtension(dpy, "XInputExtension", &xi_opcode, &event, &error)) {
        fprintf(stderr, "XInput extension not available\n");
        XCloseDisplay(dpy);
        return 0;
    }

    /* Check for XI2 */
    if (XIQueryVersion(dpy, &major, &minor) != Success) {
        fprintf(stderr, "XI2 not available\n");
        XCloseDisplay(dpy);
        return 0;
    }

    fprintf(stderr, "XI2 version %d.%d\n", major, minor);

    screen = DefaultScreen(dpy);
    root = RootWindow(dpy, screen);

    fprintf(stderr, "Training: Extension queries (%d iterations)...\n", iterations * 100);
    train_extension_queries(dpy, iterations * 100);

    fprintf(stderr, "Training: Device queries (%d iterations)...\n", iterations * 50);
    train_device_queries(dpy, iterations * 50);

    fprintf(stderr, "Training: Individual device queries (%d iterations)...\n", iterations * 30);
    train_individual_device_queries(dpy, iterations * 30);

    fprintf(stderr, "Training: Device properties (%d iterations)...\n", iterations * 30);
    train_device_properties(dpy, iterations * 30);

    fprintf(stderr, "Training: Event masks (%d iterations)...\n", iterations * 20);
    train_event_masks(dpy, root, iterations * 20);

    fprintf(stderr, "Training: Hierarchy (%d iterations)...\n", iterations * 40);
    train_hierarchy(dpy, iterations * 40);

    fprintf(stderr, "Training: Focus queries (%d iterations)...\n", iterations * 50);
    train_focus_queries(dpy, iterations * 50);

    fprintf(stderr, "Training: Pointer queries (%d iterations)...\n", iterations * 50);
    train_pointer_queries(dpy, root, iterations * 50);

    fprintf(stderr, "Training: Grab parameters (%d iterations)...\n", iterations * 100);
    train_grab_params(dpy, root, iterations * 100);

    fprintf(stderr, "Training: Client pointer (%d iterations)...\n", iterations * 50);
    train_client_pointer(dpy, iterations * 50);

    fprintf(stderr, "Training: State queries (%d iterations)...\n", iterations * 40);
    train_state_queries(dpy, root, iterations * 40);

    XSync(dpy, False);
    XCloseDisplay(dpy);

    fprintf(stderr, "XI2 PGO Training complete.\n");
    return 0;
}
EOF
}

# Run the workload against the build directory using libtool
_run_xi_workload() {
  local build_dir="$1"
  local pgo_flags="$2"
  local orig_cflags="$3"
  local orig_ldflags="$4"

  cd "$build_dir" || return 1

  local lib_dir="${build_dir}/src/.libs"
  local include_dir="${build_dir}/include"
  local libtool_la="src/libXi.la"

  if [[ ! -f "$libtool_la" ]]; then
    echo "Error: Could not find $libtool_la"
    find "$build_dir" -name "*.la" -print 2>/dev/null
    return 1
  fi

  echo "Using libtool archive: $libtool_la"
  echo "Library directory: $lib_dir"
  ls -la "$lib_dir"/libXi*.so* 2>/dev/null || echo "No libXi shared libraries found"

  echo "Compiling XI2 PGO workload using libtool..."

  CC="${CC:-clang}" \
  CFLAGS="${orig_cflags} ${pgo_flags}" \
  LDFLAGS="${orig_ldflags} ${pgo_flags}" \
  ./libtool --tag=CC --mode=link "${CC:-clang}" \
    "${srcdir}/xi_pgo_workload.c" \
    -o "${srcdir}/xi_pgo_runner" \
    -I"$include_dir" \
    -I"${srcdir}/libxi/include" \
    "$libtool_la" \
    -lX11 -lXext \
    -Wl,-rpath,"$lib_dir" || { echo "Failed to compile workload"; return 1; }

  echo "Running XI2 PGO workload..."
  "${srcdir}/xi_pgo_runner" 5 || echo "Warning: Workload exited with non-zero status (may be missing display)"

  # Additional runs with varying parameters for diverse profile coverage
  "${srcdir}/xi_pgo_runner" 3 || true
  "${srcdir}/xi_pgo_runner" 8 || true

  rm -f "${srcdir}/xi_pgo_runner"
  return 0
}

build() {
  # --- Setup ---
  export CC="clang"
  export CXX="clang++"
  local _original_cflags="${CFLAGS}"
  local _original_cxxflags="${CXXFLAGS}"
  local _original_ldflags="${LDFLAGS}"

  local PGO_DATA_DIR="${srcdir}/pgo_data"
  local CS_PGO_DATA_DIR="${srcdir}/cspgo_data"
  mkdir -p "$PGO_DATA_DIR" "$CS_PGO_DATA_DIR"

  trap 'rm -rf "$PGO_DATA_DIR" "$CS_PGO_DATA_DIR" "${srcdir}/xi_pgo_workload.c" "${srcdir}/xi_pgo_runner"' EXIT

  local _configure_opts=(
    --prefix=/usr
    --disable-static
    --disable-docs
    --without-xmlto
  )

  local pgo_failed=false
  # --- End Setup ---

  cd "${srcdir}/libxi"

  # --- Stage 1: PGO Instrumentation Build ---
  msg2 "Stage 1: Building PGO instrumented build..."

  local _pgo_gen_flags="-fprofile-generate=${PGO_DATA_DIR}"

  export CFLAGS="${_original_cflags} ${_pgo_gen_flags}"
  export CXXFLAGS="${_original_cxxflags} ${_pgo_gen_flags}"
  export LDFLAGS="${_original_ldflags} ${_pgo_gen_flags}"

  ./configure "${_configure_opts[@]}" || { echo "Configure failed (Stage 1)"; return 1; }
  make -j1 || { echo "Make failed (Stage 1)"; return 1; }

  # --- Stage 1: PGO Training Run ---
  msg2 "Stage 1: Running PGO training workloads..."
  export LLVM_PROFILE_FILE="${PGO_DATA_DIR}/libxi-%p-%m.profraw"

  # Run test suite if available
  make check &>/dev/null || true

  # Run custom workload
  _run_xi_workload "$PWD" "${_pgo_gen_flags}" "${_original_cflags}" "${_original_ldflags}" || {
    echo "Custom workload failed (Stage 1)"
    pgo_failed=true
  }

  unset LLVM_PROFILE_FILE

  # --- Stage 1: Merge PGO Profiles ---
  msg2 "Stage 1: Merging PGO profiles..."
  sleep 1

  if ! find "$PGO_DATA_DIR" -name "*.profraw" 2>/dev/null | grep -q .; then
    echo "No raw PGO profile data (*.profraw) generated. Aborting PGO."
    pgo_failed=true
  elif ! $pgo_failed; then
    if ! llvm-profdata merge -output="${PGO_DATA_DIR}/default.profdata" "${PGO_DATA_DIR}"/*.profraw; then
      echo "llvm-profdata merge failed (Stage 1). Aborting PGO."
      pgo_failed=true
    elif [[ ! -s "${PGO_DATA_DIR}/default.profdata" ]]; then
      echo "Merged PGO profile data is empty (Stage 1). Aborting PGO."
      pgo_failed=true
    fi
    rm -f "${PGO_DATA_DIR}"/*.profraw
  fi
  # --- End Stage 1 ---

  # --- Stage 2: CS-PGO Instrumentation Build ---
  if ! $pgo_failed; then
    msg2 "Stage 2: Building CS-PGO instrumented build..."
    make distclean || echo "Warning: make distclean failed before Stage 2"

    if [[ ! -f configure ]]; then
      autoreconf -vfi || { echo "autoreconf failed before Stage 2"; pgo_failed=true; }
    fi

    if ! $pgo_failed; then
      local _cspgo_gen_flags="-fprofile-use=${PGO_DATA_DIR}/default.profdata -fcs-profile-generate=${CS_PGO_DATA_DIR}"

      export CFLAGS="${_original_cflags} ${_cspgo_gen_flags}"
      export CXXFLAGS="${_original_cxxflags} ${_cspgo_gen_flags}"
      export LDFLAGS="${_original_ldflags} ${_cspgo_gen_flags}"

      ./configure "${_configure_opts[@]}" || { echo "Configure failed (Stage 2)"; pgo_failed=true; }

      if ! $pgo_failed; then
        make -j"$(nproc)" || { echo "Make failed (Stage 2)"; pgo_failed=true; }
      fi
    fi
  fi
  # --- End Stage 2 ---

  # --- Stage 2: CS-PGO Training Run ---
  if ! $pgo_failed; then
    msg2 "Stage 2: Running CS-PGO training workloads..."
    export LLVM_PROFILE_FILE="${CS_PGO_DATA_DIR}/libxi-cs-%p-%m.profraw"

    make check &>/dev/null || true

    _run_xi_workload "$PWD" "${_cspgo_gen_flags}" "${_original_cflags}" "${_original_ldflags}" || {
      echo "Custom workload failed (Stage 2)"
      pgo_failed=true
    }

    unset LLVM_PROFILE_FILE

    # --- Stage 2: Merge CS-PGO Profiles ---
    msg2 "Stage 2: Merging CS-PGO profiles..."
    sleep 1

    if ! find "$CS_PGO_DATA_DIR" -name "*.profraw" 2>/dev/null | grep -q .; then
      echo "Warning: No raw CS-PGO profile data generated. Using Stage 1 PGO data."
      cp "${PGO_DATA_DIR}/default.profdata" "${CS_PGO_DATA_DIR}/cs.profdata" || {
        echo "Failed to copy fallback profile data."
        pgo_failed=true
      }
    elif ! $pgo_failed; then
      if ! llvm-profdata merge -output="${CS_PGO_DATA_DIR}/cs.profdata" \
           "${CS_PGO_DATA_DIR}"/*.profraw "${PGO_DATA_DIR}/default.profdata"; then
        echo "llvm-profdata merge failed (Stage 2). Aborting CS-PGO."
        pgo_failed=true
      fi
      rm -f "${CS_PGO_DATA_DIR}"/*.profraw
    fi

    if ! $pgo_failed && [[ ! -s "${CS_PGO_DATA_DIR}/cs.profdata" ]]; then
      echo "Final merged CS-PGO profile is empty (Stage 2). Aborting CS-PGO."
      pgo_failed=true
    fi
  fi
  # --- End Stage 2 ---

  # --- Stage 3: Final Optimized Build ---
  msg2 "Stage 3: Building final optimized build..."
  make distclean || echo "Warning: make distclean failed before Stage 3"

  if [[ ! -f configure ]]; then
    autoreconf -vfi || { echo "autoreconf failed before Stage 3"; return 1; }
  fi

  CFLAGS="${_original_cflags}"
  CXXFLAGS="${_original_cxxflags}"
  LDFLAGS="${_original_ldflags}"

  if ! $pgo_failed; then
    local _final_opt_flags=""
    if [[ -s "${CS_PGO_DATA_DIR}/cs.profdata" ]]; then
      msg2 "Applying CS-PGO profile data for final build."
      _final_opt_flags="-fprofile-use=${CS_PGO_DATA_DIR}/cs.profdata"
    elif [[ -s "${PGO_DATA_DIR}/default.profdata" ]]; then
      msg2 "Applying fallback PGO profile data for final build."
      _final_opt_flags="-fprofile-use=${PGO_DATA_DIR}/default.profdata"
    else
      warning "No usable profile data found. Building without PGO."
    fi
    CFLAGS+=" ${_final_opt_flags}"
    CXXFLAGS+=" ${_final_opt_flags}"
    LDFLAGS+=" ${_final_opt_flags}"
  else
    warning "Building final version without PGO optimization due to previous errors."
  fi

  export CFLAGS CXXFLAGS LDFLAGS

  ./configure "${_configure_opts[@]}" || { echo "Configure failed (Stage 3)"; return 1; }
  make -j"$(nproc)" || { echo "Make failed (Stage 3)"; return 1; }
  # --- End Stage 3 ---

  if $pgo_failed; then
    warning "PGO optimization could not be fully applied. Package built without PGO."
  else
    msg "CS-PGO build process completed successfully."
  fi
}

check() {
  cd "${srcdir}/libxi"
  make check
}

package() {
  cd "${srcdir}/libxi"

  make DESTDIR="$pkgdir" install
  install -Dm644 "COPYING" -t "$pkgdir/usr/share/licenses/libxi"
}
