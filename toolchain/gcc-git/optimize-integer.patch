Assertions were originally enabled in the compiled-in floating-point
std::to_chars implementation to help shake out any bugs, but they
apparently impose a significant performance penalty, in particular for
the hex formatting which is around 25% slower with assertions enabled.
This seems too high of a cost for unconditionally enabling them.

The newly added calls to __builtin_unreachable work around the compiler
no longer knowing that the set of valid values of 'fmt' is limited (which
was previously upheld by an assert).

Tested on x86_64-pc-linux-gnu, does this look OK for trunk?

libstdc++-v3/ChangeLog:

	* src/c++17/floating_to_chars.cc: Don't define
	_GLIBCXX_ASSERTIONS.
	(__floating_to_chars_shortest): Add __builtin_unreachable calls to
	squelch false-positive -Wmaybe-uninitialized and -Wreturn-type
	warnings.
	(__floating_to_chars_precision): Likewise.
---
 libstdc++-v3/src/c++17/floating_to_chars.cc | 9 ++++++---
 1 file changed, 6 insertions(+), 3 deletions(-)

diff --git a/libstdc++-v3/src/c++17/floating_to_chars.cc b/libstdc++-v3/src/c++17/floating_to_chars.cc
index 66bd457cbe2..4599d68a39c 100644
--- a/libstdc++-v3/src/c++17/floating_to_chars.cc
+++ b/libstdc++-v3/src/c++17/floating_to_chars.cc
@@ -22,9 +22,6 @@
 // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 // <http://www.gnu.org/licenses/>.

-// Activate __glibcxx_assert within this file to shake out any bugs.
-#define _GLIBCXX_ASSERTIONS 1
-
 #include <charconv>

 #include <bit>
@@ -1114,6 +1111,7 @@ template<typename T>
       }

     __glibcxx_assert(false);
+    __builtin_unreachable();
   }

 template<typename T>
@@ -1202,6 +1200,8 @@ template<typename T>
 	    effective_precision = min(precision, max_eff_scientific_precision);
 	    output_specifier = "%.*Lg";
 	  }
+	else
+	  __builtin_unreachable();
 	const int excess_precision = (fmt != chars_format::general
 				      ? precision - effective_precision : 0);

@@ -1234,6 +1234,8 @@ template<typename T>
 	      output_length_upper_bound = sign + strlen("0");
 	    output_length_upper_bound += sizeof(radix) + effective_precision;
 	  }
+	else
+	  __builtin_unreachable();

 	// Do the sprintf into the local buffer.
 	char buffer[output_length_upper_bound+1];
@@ -1570,6 +1572,7 @@ template<typename T>
       }

     __glibcxx_assert(false);
+    __builtin_unreachable();
   }

 // Define the overloads for float.
--
2.36.0.rc2.10.g1ac7422e39
